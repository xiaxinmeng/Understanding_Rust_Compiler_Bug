{"sha": "237d54ff6c4fb3577e02d4c5af02813c11b63d01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzN2Q1NGZmNmM0ZmIzNTc3ZTAyZDRjNWFmMDI4MTNjMTFiNjNkMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-15T15:14:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-15T15:14:43Z"}, "message": "Auto merge of #65433 - Centril:rollup-rzvry15, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #64035 (Stabilize proc macros generating `macro_rules` items)\n - #65376 (syntax: misc extractions)\n - #65426 (Remove custom `PartialEq` impls for `LocalInternedString`.)\n - #65428 (Refactor: Rename `db` locals to `diag`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "339914aceec730f698e799ed859a7858443967d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/339914aceec730f698e799ed859a7858443967d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/237d54ff6c4fb3577e02d4c5af02813c11b63d01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/237d54ff6c4fb3577e02d4c5af02813c11b63d01", "html_url": "https://github.com/rust-lang/rust/commit/237d54ff6c4fb3577e02d4c5af02813c11b63d01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/237d54ff6c4fb3577e02d4c5af02813c11b63d01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "437ca55f23b7ed0051334a7e38ecabd83a173b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/437ca55f23b7ed0051334a7e38ecabd83a173b53", "html_url": "https://github.com/rust-lang/rust/commit/437ca55f23b7ed0051334a7e38ecabd83a173b53"}, {"sha": "8370f14225cfb1a7f0eae8b8dadfaa4393e00d7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8370f14225cfb1a7f0eae8b8dadfaa4393e00d7c", "html_url": "https://github.com/rust-lang/rust/commit/8370f14225cfb1a7f0eae8b8dadfaa4393e00d7c"}], "stats": {"total": 1143, "additions": 531, "deletions": 612}, "files": [{"sha": "ab5a3c0651033257bde90cc9adc54a1b88a45fca", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -67,11 +67,11 @@ use syntax::errors;\n use syntax::ext::base::SpecialDerives;\n use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n-use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n-use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Nonterminal, Token};\n-use syntax::parse::ParseSess;\n+use syntax::sess::ParseSess;\n+use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n "}, {"sha": "b852098d4cef7fc2a9e148c0df1def1da5659227", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,10 +1,10 @@\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::source_map::{SourceMap, Spanned};\n-use syntax::parse::ParseSess;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self, Comments, PrintState};\n+use syntax::sess::ParseSess;\n use syntax::symbol::kw;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};"}, {"sha": "8943fc342c023efa22c6b9f52919df12807e799d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -56,7 +56,7 @@\n #![feature(test)]\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n-#![feature(proc_macro_hygiene)]\n+#![cfg_attr(bootstrap, feature(proc_macro_hygiene))]\n #![feature(log_syntax)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]"}, {"sha": "675e3bbd002b0e46c975d6ad0ec56f103f5dee6c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -16,8 +16,9 @@ use syntax;\n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n-use syntax::parse::{ParseSess, new_parser_from_source_str};\n+use syntax::parse::new_parser_from_source_str;\n use syntax::parse::token;\n+use syntax::sess::ParseSess;\n use syntax::symbol::{sym, Symbol};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::source_map::SourceMap;"}, {"sha": "c59df146629f50acd6bdab12377d3e3663c98bd5", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -28,7 +28,7 @@ use syntax::ext::allocator::AllocatorKind;\n use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;\n-use syntax::parse::{self, ParseSess};\n+use syntax::sess::ParseSess;\n use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n use crate::util::profiling::{SelfProfiler, SelfProfilerRef};\n@@ -1159,7 +1159,7 @@ fn build_session_(\n     );\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n-    let parse_sess = parse::ParseSess::with_span_handler(\n+    let parse_sess = ParseSess::with_span_handler(\n         span_diagnostic,\n         source_map,\n     );"}, {"sha": "5339134a2a84970633c883fbb02b5c7e338b7f76", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1667,13 +1667,13 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit_diagnostic(&mut self, db: &rustc_errors::Diagnostic) {\n+    fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-            msg: db.message(),\n-            code: db.code.clone(),\n-            lvl: db.level,\n+            msg: diag.message(),\n+            code: diag.code.clone(),\n+            lvl: diag.level,\n         })));\n-        for child in &db.children {\n+        for child in &diag.children {\n             drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n                 msg: child.message(),\n                 code: None,"}, {"sha": "491bc2aa6a2eb7034669b33c4ae7cbba214164e5", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -31,19 +31,19 @@ pub struct AnnotateSnippetEmitterWriter {\n \n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n-    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n-        let mut children = db.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n+    fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let mut children = diag.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n         self.fix_multispans_in_std_macros(&self.source_map,\n                                           &mut primary_span,\n                                           &mut children,\n-                                          &db.level,\n+                                          &diag.level,\n                                           self.external_macro_backtrace);\n \n-        self.emit_messages_default(&db.level,\n-                                   db.message(),\n-                                   &db.code,\n+        self.emit_messages_default(&diag.level,\n+                                   diag.message(),\n+                                   &diag.code,\n                                    &primary_span,\n                                    &children,\n                                    &suggestions);"}, {"sha": "1e486786f6861a90dff68ed0b2b7e0a11dfb7e05", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -180,7 +180,7 @@ const ANONYMIZED_LINE_NUM: &str = \"LL\";\n /// Emitter trait for emitting errors.\n pub trait Emitter {\n     /// Emit a structured diagnostic.\n-    fn emit_diagnostic(&mut self, db: &Diagnostic);\n+    fn emit_diagnostic(&mut self, diag: &Diagnostic);\n \n     /// Emit a notification that an artifact has been output.\n     /// This is currently only supported for the JSON format,\n@@ -206,10 +206,10 @@ pub trait Emitter {\n     ///   we return the original `primary_span` and the original suggestions.\n     fn primary_span_formatted<'a>(\n         &mut self,\n-        db: &'a Diagnostic,\n+        diag: &'a Diagnostic,\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n-        let mut primary_span = db.span.clone();\n-        if let Some((sugg, rest)) = db.suggestions.split_first() {\n+        let mut primary_span = diag.span.clone();\n+        if let Some((sugg, rest)) = diag.suggestions.split_first() {\n             if rest.is_empty() &&\n                // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n@@ -260,10 +260,10 @@ pub trait Emitter {\n                 // to be consistent. We could try to figure out if we can\n                 // make one (or the first one) inline, but that would give\n                 // undue importance to a semi-random suggestion\n-                (primary_span, &db.suggestions)\n+                (primary_span, &diag.suggestions)\n             }\n         } else {\n-            (primary_span, &db.suggestions)\n+            (primary_span, &diag.suggestions)\n         }\n     }\n \n@@ -401,19 +401,19 @@ impl Emitter for EmitterWriter {\n         self.sm.as_ref()\n     }\n \n-    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n-        let mut children = db.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n+    fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let mut children = diag.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n         self.fix_multispans_in_std_macros(&self.sm,\n                                           &mut primary_span,\n                                           &mut children,\n-                                          &db.level,\n+                                          &diag.level,\n                                           self.external_macro_backtrace);\n \n-        self.emit_messages_default(&db.level,\n-                                   &db.styled_message(),\n-                                   &db.code,\n+        self.emit_messages_default(&diag.level,\n+                                   &diag.styled_message(),\n+                                   &diag.code,\n                                    &primary_span,\n                                    &children,\n                                    &suggestions);"}, {"sha": "706f52d03221b597c9169ec377e4b96accaa2977", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -9,7 +9,7 @@ use std::ops;\n \n use syntax::symbol::{Symbol, sym};\n use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, LitKind};\n-use syntax::parse::ParseSess;\n+use syntax::sess::ParseSess;\n use syntax::feature_gate::Features;\n \n use syntax_pos::Span;"}, {"sha": "30c9453a643d48bde9a5c9754229ca057ba39607", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -14,7 +14,7 @@ use std::io::prelude::*;\n use syntax::source_map::{SourceMap, FilePathMapping};\n use syntax::parse::lexer;\n use syntax::parse::token::{self, Token};\n-use syntax::parse;\n+use syntax::sess::ParseSess;\n use syntax::symbol::{kw, sym};\n use syntax_pos::{Span, FileName};\n \n@@ -33,7 +33,7 @@ pub fn render_with_highlighting(\n                class, tooltip).unwrap();\n     }\n \n-    let sess = parse::ParseSess::new(FilePathMapping::empty());\n+    let sess = ParseSess::new(FilePathMapping::empty());\n     let fm = sess.source_map().new_source_file(\n         FileName::Custom(String::from(\"rustdoc-highlighting\")),\n         src.to_owned(),"}, {"sha": "10e15ab8881afa29c7c5b55ffa54f3bf210e08ef", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,6 +1,7 @@\n use errors::Applicability;\n use syntax::parse::lexer::{StringReader as Lexer};\n-use syntax::parse::{ParseSess, token};\n+use syntax::parse::token;\n+use syntax::sess::ParseSess;\n use syntax::source_map::FilePathMapping;\n use syntax_pos::{InnerSpan, FileName};\n "}, {"sha": "0be6340df96e87d5b946b5a2d086e31bbe975461", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -394,7 +394,7 @@ pub fn make_test(s: &str,\n     // Uses libsyntax to parse the doctest and find if there's a main fn and the extern\n     // crate already is included.\n     let (already_has_main, already_has_extern_crate, found_macro) = with_globals(edition, || {\n-        use crate::syntax::{parse::{self, ParseSess}, source_map::FilePathMapping};\n+        use crate::syntax::{parse, sess::ParseSess, source_map::FilePathMapping};\n         use errors::emitter::EmitterWriter;\n         use errors::Handler;\n "}, {"sha": "1fe698c2572cae681bc53839086bfbed360751d5", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -4,8 +4,8 @@ use crate::ast::{self, Attribute, MetaItem, NestedMetaItem};\n use crate::early_buffered_lints::BufferedEarlyLintId;\n use crate::ext::base::ExtCtxt;\n use crate::feature_gate::{Features, GatedCfg};\n-use crate::parse::ParseSess;\n use crate::print::pprust;\n+use crate::sess::ParseSess;\n \n use errors::{Applicability, Handler};\n use syntax_pos::hygiene::Transparency;"}, {"sha": "d291e502c2553ed20b31fc6f5448d8ea03f47caf", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -16,9 +16,10 @@ use crate::mut_visit::visit_clobber;\n use crate::source_map::{BytePos, Spanned, DUMMY_SP};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::parser::Parser;\n-use crate::parse::{ParseSess, PResult};\n+use crate::parse::PResult;\n use crate::parse::token::{self, Token};\n use crate::ptr::P;\n+use crate::sess::ParseSess;\n use crate::symbol::{sym, Symbol};\n use crate::ThinVec;\n use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};"}, {"sha": "2099d018b7b3d60f4c336ff058412dd7430dd0a4", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -10,8 +10,9 @@ use crate::attr;\n use crate::ast;\n use crate::edition::Edition;\n use crate::mut_visit::*;\n-use crate::parse::{token, ParseSess};\n+use crate::parse::token;\n use crate::ptr::P;\n+use crate::sess::ParseSess;\n use crate::symbol::sym;\n use crate::util::map_in_place::MapInPlace;\n "}, {"sha": "01be5642d5c432362cc99a055628bfc65a53d9ea", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -5,9 +5,10 @@ use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n use crate::ext::hygiene::ExpnId;\n use crate::mut_visit::{self, MutVisitor};\n-use crate::parse::{self, parser, ParseSess, DirectoryOwnership};\n+use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n+use crate::sess::ParseSess;\n use crate::symbol::{kw, sym, Ident, Symbol};\n use crate::{ThinVec, MACRO_ARGUMENTS};\n use crate::tokenstream::{self, TokenStream};\n@@ -892,7 +893,7 @@ pub struct ExpansionData {\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n /// -> expn_data` of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n-    pub parse_sess: &'a parse::ParseSess,\n+    pub parse_sess: &'a ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub root_path: PathBuf,\n     pub resolver: &'a mut dyn Resolver,\n@@ -901,7 +902,7 @@ pub struct ExtCtxt<'a> {\n }\n \n impl<'a> ExtCtxt<'a> {\n-    pub fn new(parse_sess: &'a parse::ParseSess,\n+    pub fn new(parse_sess: &'a ParseSess,\n                ecfg: expand::ExpansionConfig<'a>,\n                resolver: &'a mut dyn Resolver)\n                -> ExtCtxt<'a> {\n@@ -935,7 +936,7 @@ impl<'a> ExtCtxt<'a> {\n         parse::stream_to_parser(self.parse_sess, stream, MACRO_ARGUMENTS)\n     }\n     pub fn source_map(&self) -> &'a SourceMap { self.parse_sess.source_map() }\n-    pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n+    pub fn parse_sess(&self) -> &'a ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n         self.current_expansion.id.expn_data().call_site"}, {"sha": "2559e874762774f1367884a9665a2dfacf864a7e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -10,14 +10,14 @@ use crate::ext::mbe::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n use crate::mut_visit::*;\n-use crate::parse::{DirectoryOwnership, PResult, ParseSess};\n+use crate::parse::{DirectoryOwnership, PResult};\n use crate::parse::token;\n use crate::parse::parser::Parser;\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::symbol::{sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n-use crate::visit::{self, Visitor};\n+use crate::visit::Visitor;\n use crate::util::map_in_place::MapInPlace;\n \n use errors::{Applicability, FatalError};\n@@ -577,10 +577,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n                     let tok_result = expander.expand(self.cx, span, mac.stream());\n-                    let result =\n-                        self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span);\n-                    self.gate_proc_macro_expansion(span, &result);\n-                    result\n+                    self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n                     let prev = self.cx.current_expansion.prior_type_ascription;\n@@ -624,10 +621,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     })), DUMMY_SP).into();\n                     let input = self.extract_proc_macro_attr_input(attr.item.tokens, span);\n                     let tok_result = expander.expand(self.cx, span, input, item_tok);\n-                    let res =\n-                        self.parse_ast_fragment(tok_result, fragment_kind, &attr.item.path, span);\n-                    self.gate_proc_macro_expansion(span, &res);\n-                    res\n+                    self.parse_ast_fragment(tok_result, fragment_kind, &attr.item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match attr.parse_meta(self.cx.parse_sess) {\n@@ -718,41 +712,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    fn gate_proc_macro_expansion(&self, span: Span, fragment: &AstFragment) {\n-        if self.cx.ecfg.proc_macro_hygiene() {\n-            return\n-        }\n-\n-        fragment.visit_with(&mut DisallowMacros {\n-            span,\n-            parse_sess: self.cx.parse_sess,\n-        });\n-\n-        struct DisallowMacros<'a> {\n-            span: Span,\n-            parse_sess: &'a ParseSess,\n-        }\n-\n-        impl<'ast, 'a> Visitor<'ast> for DisallowMacros<'a> {\n-            fn visit_item(&mut self, i: &'ast ast::Item) {\n-                if let ast::ItemKind::MacroDef(_) = i.kind {\n-                    emit_feature_err(\n-                        self.parse_sess,\n-                        sym::proc_macro_hygiene,\n-                        self.span,\n-                        GateIssue::Language,\n-                        \"procedural macros cannot expand to macro definitions\",\n-                    );\n-                }\n-                visit::walk_item(self, i);\n-            }\n-\n-            fn visit_mac(&mut self, _mac: &'ast ast::Mac) {\n-                // ...\n-            }\n-        }\n-    }\n-\n     fn gate_proc_macro_expansion_kind(&self, span: Span, kind: AstFragmentKind) {\n         let kind = match kind {\n             AstFragmentKind::Expr |"}, {"sha": "aabaff4e1c30c9729cd786613e7a16ecf0adf8ae", "filename": "src/libsyntax/ext/mbe/macro_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -109,7 +109,7 @@ use crate::early_buffered_lints::BufferedEarlyLintId;\n use crate::ext::mbe::{KleeneToken, TokenTree};\n use crate::parse::token::TokenKind;\n use crate::parse::token::{DelimToken, Token};\n-use crate::parse::ParseSess;\n+use crate::sess::ParseSess;\n use crate::symbol::{kw, sym};\n \n use rustc_data_structures::fx::FxHashMap;"}, {"sha": "ff382c316ffacb2857670790e2f8dae299135556", "filename": "src/libsyntax/ext/mbe/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -76,10 +76,11 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::ast::{Ident, Name};\n use crate::ext::mbe::{self, TokenTree};\n-use crate::parse::{Directory, ParseSess, PResult};\n+use crate::parse::{Directory, PResult};\n use crate::parse::parser::{Parser, PathStyle};\n use crate::parse::token::{self, DocComment, Nonterminal, Token};\n use crate::print::pprust;\n+use crate::sess::ParseSess;\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream};\n "}, {"sha": "b422329842260a38bd314c29a5010a20e7e11d73", "filename": "src/libsyntax/ext/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -14,8 +14,9 @@ use crate::feature_gate::Features;\n use crate::parse::parser::Parser;\n use crate::parse::token::TokenKind::*;\n use crate::parse::token::{self, NtTT, Token};\n-use crate::parse::{Directory, ParseSess};\n+use crate::parse::Directory;\n use crate::print::pprust;\n+use crate::sess::ParseSess;\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n "}, {"sha": "3cec4bc60e7a81e11d2683f192b529303c68c4ab", "filename": "src/libsyntax/ext/mbe/quoted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -2,8 +2,8 @@ use crate::ast;\n use crate::ext::mbe::macro_parser;\n use crate::ext::mbe::{TokenTree, KleeneOp, KleeneToken, SequenceRepetition, Delimited};\n use crate::parse::token::{self, Token};\n-use crate::parse::ParseSess;\n use crate::print::pprust;\n+use crate::sess::ParseSess;\n use crate::symbol::kw;\n use crate::tokenstream;\n "}, {"sha": "300523c1b0a445ce6dfbe6dd3aa25fcb4fa9bbd7", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,8 +1,9 @@\n use crate::ast;\n use crate::ext::base::ExtCtxt;\n-use crate::parse::{self, token, ParseSess};\n+use crate::parse::{self, token};\n use crate::parse::lexer::comments;\n use crate::print::pprust;\n+use crate::sess::ParseSess;\n use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n \n use errors::Diagnostic;"}, {"sha": "043a2ffb5a480dddbe32715febd7484020281c21", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -9,8 +9,8 @@ use super::active::Features;\n \n use crate::ast;\n use crate::attr::AttributeTemplate;\n+use crate::sess::ParseSess;\n use crate::symbol::{Symbol, sym};\n-use crate::parse::ParseSess;\n \n use syntax_pos::Span;\n use rustc_data_structures::fx::FxHashMap;"}, {"sha": "c07b6050afe31af5c0315f43e37a13866ca562cd", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -5,14 +5,14 @@ use super::builtin_attrs::{AttributeGate, BUILTIN_ATTRIBUTE_MAP};\n \n use crate::ast::{\n     self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n-    PatKind, RangeEnd,\n+    PatKind, RangeEnd, VariantData,\n };\n use crate::attr::{self, check_builtin_attribute};\n use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n-use crate::parse::{token, ParseSess};\n-use crate::parse::parser::Parser;\n+use crate::parse::token;\n+use crate::sess::ParseSess;\n use crate::symbol::{Symbol, sym};\n use crate::tokenstream::TokenTree;\n \n@@ -246,6 +246,51 @@ impl<'a> PostExpansionVisitor<'a> {\n             Abi::System => {}\n         }\n     }\n+\n+    fn maybe_report_invalid_custom_discriminants(&self, variants: &[ast::Variant]) {\n+        let has_fields = variants.iter().any(|variant| match variant.data {\n+            VariantData::Tuple(..) | VariantData::Struct(..) => true,\n+            VariantData::Unit(..) => false,\n+        });\n+\n+        let discriminant_spans = variants.iter().filter(|variant| match variant.data {\n+            VariantData::Tuple(..) | VariantData::Struct(..) => false,\n+            VariantData::Unit(..) => true,\n+        })\n+        .filter_map(|variant| variant.disr_expr.as_ref().map(|c| c.value.span))\n+        .collect::<Vec<_>>();\n+\n+        if !discriminant_spans.is_empty() && has_fields {\n+            let mut err = feature_err(\n+                self.parse_sess,\n+                sym::arbitrary_enum_discriminant,\n+                discriminant_spans.clone(),\n+                crate::feature_gate::GateIssue::Language,\n+                \"custom discriminant values are not allowed in enums with tuple or struct variants\",\n+            );\n+            for sp in discriminant_spans {\n+                err.span_label(sp, \"disallowed custom discriminant\");\n+            }\n+            for variant in variants.iter() {\n+                match &variant.data {\n+                    VariantData::Struct(..) => {\n+                        err.span_label(\n+                            variant.span,\n+                            \"struct variant defined here\",\n+                        );\n+                    }\n+                    VariantData::Tuple(..) => {\n+                        err.span_label(\n+                            variant.span,\n+                            \"tuple variant defined here\",\n+                        );\n+                    }\n+                    VariantData::Unit(..) => {}\n+                }\n+            }\n+            err.emit();\n+        }\n+    }\n }\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n@@ -353,7 +398,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n                 let has_feature = self.features.arbitrary_enum_discriminant;\n                 if !has_feature && !i.span.allows_unstable(sym::arbitrary_enum_discriminant) {\n-                    Parser::maybe_report_invalid_custom_discriminants(self.parse_sess, &variants);\n+                    self.maybe_report_invalid_custom_discriminants(&variants);\n                 }\n             }\n \n@@ -769,7 +814,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             }\n \n             if let Some(allowed) = allow_features.as_ref() {\n-                if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n+                if allowed.iter().find(|&f| f == &name.as_str() as &str).is_none() {\n                     span_err!(span_handler, mi.span(), E0725,\n                               \"the feature `{}` is not in the list of allowed features\",\n                               name);"}, {"sha": "e3296788d9fa78530ab1dd528a9e55e63076b417", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -89,8 +89,8 @@ impl JsonEmitter {\n }\n \n impl Emitter for JsonEmitter {\n-    fn emit_diagnostic(&mut self, db: &errors::Diagnostic) {\n-        let data = Diagnostic::from_errors_diagnostic(db, self);\n+    fn emit_diagnostic(&mut self, diag: &errors::Diagnostic) {\n+        let data = Diagnostic::from_errors_diagnostic(diag, self);\n         let result = if self.pretty {\n             writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n         } else {\n@@ -209,10 +209,10 @@ struct ArtifactNotification<'a> {\n }\n \n impl Diagnostic {\n-    fn from_errors_diagnostic(db: &errors::Diagnostic,\n+    fn from_errors_diagnostic(diag: &errors::Diagnostic,\n                                je: &JsonEmitter)\n                                -> Diagnostic {\n-        let sugg = db.suggestions.iter().map(|sugg| {\n+        let sugg = diag.suggestions.iter().map(|sugg| {\n             Diagnostic {\n                 message: sugg.msg.clone(),\n                 code: None,\n@@ -241,30 +241,30 @@ impl Diagnostic {\n         let output = buf.clone();\n         je.json_rendered.new_emitter(\n             Box::new(buf), Some(je.sm.clone()), false, None, je.external_macro_backtrace\n-        ).ui_testing(je.ui_testing).emit_diagnostic(db);\n+        ).ui_testing(je.ui_testing).emit_diagnostic(diag);\n         let output = Arc::try_unwrap(output.0).unwrap().into_inner().unwrap();\n         let output = String::from_utf8(output).unwrap();\n \n         Diagnostic {\n-            message: db.message(),\n-            code: DiagnosticCode::map_opt_string(db.code.clone(), je),\n-            level: db.level.to_str(),\n-            spans: DiagnosticSpan::from_multispan(&db.span, je),\n-            children: db.children.iter().map(|c| {\n+            message: diag.message(),\n+            code: DiagnosticCode::map_opt_string(diag.code.clone(), je),\n+            level: diag.level.to_str(),\n+            spans: DiagnosticSpan::from_multispan(&diag.span, je),\n+            children: diag.children.iter().map(|c| {\n                 Diagnostic::from_sub_diagnostic(c, je)\n             }).chain(sugg).collect(),\n             rendered: Some(output),\n         }\n     }\n \n-    fn from_sub_diagnostic(db: &SubDiagnostic, je: &JsonEmitter) -> Diagnostic {\n+    fn from_sub_diagnostic(diag: &SubDiagnostic, je: &JsonEmitter) -> Diagnostic {\n         Diagnostic {\n-            message: db.message(),\n+            message: diag.message(),\n             code: None,\n-            level: db.level.to_str(),\n-            spans: db.render_span.as_ref()\n+            level: diag.level.to_str(),\n+            spans: diag.render_span.as_ref()\n                      .map(|sp| DiagnosticSpan::from_multispan(sp, je))\n-                     .unwrap_or_else(|| DiagnosticSpan::from_multispan(&db.span, je)),\n+                     .unwrap_or_else(|| DiagnosticSpan::from_multispan(&diag.span, je)),\n             children: vec![],\n             rendered: None,\n         }"}, {"sha": "fa75f5624f8f882b12fa99c9b38656beebd386c8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -147,6 +147,7 @@ pub mod ptr;\n pub mod show_span;\n pub use syntax_pos::edition;\n pub use syntax_pos::symbol;\n+pub mod sess;\n pub mod tokenstream;\n pub mod visit;\n "}, {"sha": "943838d9dda76b9fdfe2a8b0bdd281f9ea5e47f8", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 52, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,9 +1,8 @@\n use crate::ast::{\n     self, Param, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Ident, Item, ItemKind,\n-    Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind, VariantData,\n+    Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind,\n };\n-use crate::feature_gate::feature_err;\n-use crate::parse::{SeqSep, PResult, Parser, ParseSess};\n+use crate::parse::{SeqSep, PResult, Parser};\n use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, TokenExpectType};\n use crate::parse::token::{self, TokenKind};\n use crate::print::pprust;\n@@ -715,55 +714,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn maybe_report_invalid_custom_discriminants(\n-        sess: &ParseSess,\n-        variants: &[ast::Variant],\n-    ) {\n-        let has_fields = variants.iter().any(|variant| match variant.data {\n-            VariantData::Tuple(..) | VariantData::Struct(..) => true,\n-            VariantData::Unit(..) => false,\n-        });\n-\n-        let discriminant_spans = variants.iter().filter(|variant| match variant.data {\n-            VariantData::Tuple(..) | VariantData::Struct(..) => false,\n-            VariantData::Unit(..) => true,\n-        })\n-        .filter_map(|variant| variant.disr_expr.as_ref().map(|c| c.value.span))\n-        .collect::<Vec<_>>();\n-\n-        if !discriminant_spans.is_empty() && has_fields {\n-            let mut err = feature_err(\n-                sess,\n-                sym::arbitrary_enum_discriminant,\n-                discriminant_spans.clone(),\n-                crate::feature_gate::GateIssue::Language,\n-                \"custom discriminant values are not allowed in enums with tuple or struct variants\",\n-            );\n-            for sp in discriminant_spans {\n-                err.span_label(sp, \"disallowed custom discriminant\");\n-            }\n-            for variant in variants.iter() {\n-                match &variant.data {\n-                    VariantData::Struct(..) => {\n-                        err.span_label(\n-                            variant.span,\n-                            \"struct variant defined here\",\n-                        );\n-                    }\n-                    VariantData::Tuple(..) => {\n-                        err.span_label(\n-                            variant.span,\n-                            \"tuple variant defined here\",\n-                        );\n-                    }\n-                    VariantData::Unit(..) => {}\n-                }\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    crate fn maybe_recover_from_bad_type_plus(\n+    pub(super) fn maybe_recover_from_bad_type_plus(\n         &mut self,\n         allow_plus: bool,\n         ty: &Ty,"}, {"sha": "e6dc9a4c134174bd10158c2efc99848905bed71c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,5 +1,5 @@\n-use crate::parse::ParseSess;\n use crate::parse::token::{self, Token, TokenKind};\n+use crate::sess::ParseSess;\n use crate::symbol::{sym, Symbol};\n use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n "}, {"sha": "14e1696610a4d0bd8e004a32d80327eb2fe72143", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 3, "deletions": 166, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,14 +1,10 @@\n //! Code related to parsing literals.\n \n use crate::ast::{self, Lit, LitKind};\n-use crate::parse::parser::Parser;\n-use crate::parse::PResult;\n-use crate::parse::token::{self, Token, TokenKind};\n-use crate::print::pprust;\n+use crate::parse::token::{self, Token};\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n \n-use errors::{Applicability, Handler};\n use log::debug;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::Span;\n@@ -28,72 +24,6 @@ crate enum LitError {\n     IntTooLarge,\n }\n \n-impl LitError {\n-    fn report(&self, diag: &Handler, lit: token::Lit, span: Span) {\n-        let token::Lit { kind, suffix, .. } = lit;\n-        match *self {\n-            // `NotLiteral` is not an error by itself, so we don't report\n-            // it and give the parser opportunity to try something else.\n-            LitError::NotLiteral => {}\n-            // `LexerError` *is* an error, but it was already reported\n-            // by lexer, so here we don't report it the second time.\n-            LitError::LexerError => {}\n-            LitError::InvalidSuffix => {\n-                expect_no_suffix(\n-                    diag, span, &format!(\"{} {} literal\", kind.article(), kind.descr()), suffix\n-                );\n-            }\n-            LitError::InvalidIntSuffix => {\n-                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n-                if looks_like_width_suffix(&['i', 'u'], &suf) {\n-                    // If it looks like a width, try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n-                    diag.struct_span_err(span, &msg)\n-                        .help(\"valid widths are 8, 16, 32, 64 and 128\")\n-                        .emit();\n-                } else {\n-                    let msg = format!(\"invalid suffix `{}` for integer literal\", suf);\n-                    diag.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n-                        .help(\"the suffix must be one of the integral types (`u32`, `isize`, etc)\")\n-                        .emit();\n-                }\n-            }\n-            LitError::InvalidFloatSuffix => {\n-                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n-                if looks_like_width_suffix(&['f'], &suf) {\n-                    // If it looks like a width, try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n-                    diag.struct_span_err(span, &msg)\n-                        .help(\"valid widths are 32 and 64\")\n-                        .emit();\n-                } else {\n-                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n-                    diag.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n-                        .help(\"valid suffixes are `f32` and `f64`\")\n-                        .emit();\n-                }\n-            }\n-            LitError::NonDecimalFloat(base) => {\n-                let descr = match base {\n-                    16 => \"hexadecimal\",\n-                    8 => \"octal\",\n-                    2 => \"binary\",\n-                    _ => unreachable!(),\n-                };\n-                diag.struct_span_err(span, &format!(\"{} float literal is not supported\", descr))\n-                    .span_label(span, \"not supported\")\n-                    .emit();\n-            }\n-            LitError::IntTooLarge => {\n-                diag.struct_span_err(span, \"integer literal is too large\")\n-                    .emit();\n-            }\n-        }\n-    }\n-}\n-\n impl LitKind {\n     /// Converts literal token into a semantic literal.\n     fn from_lit_token(lit: token::Lit) -> Result<LitKind, LitError> {\n@@ -204,7 +134,7 @@ impl LitKind {\n         let (kind, symbol, suffix) = match *self {\n             LitKind::Str(symbol, ast::StrStyle::Cooked) => {\n                 // Don't re-intern unless the escaped string is different.\n-                let s = &symbol.as_str();\n+                let s: &str = &symbol.as_str();\n                 let escaped = s.escape_default().to_string();\n                 let symbol = if escaped == *s { symbol } else { Symbol::intern(&escaped) };\n                 (token::Str, symbol, None)\n@@ -254,7 +184,7 @@ impl LitKind {\n \n impl Lit {\n     /// Converts literal token into an AST literal.\n-    fn from_lit_token(token: token::Lit, span: Span) -> Result<Lit, LitError> {\n+    crate fn from_lit_token(token: token::Lit, span: Span) -> Result<Lit, LitError> {\n         Ok(Lit { token, kind: LitKind::from_lit_token(token)?, span })\n     }\n \n@@ -296,99 +226,6 @@ impl Lit {\n     }\n }\n \n-impl<'a> Parser<'a> {\n-    /// Matches `lit = true | false | token_lit`.\n-    crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        let mut recovered = None;\n-        if self.token == token::Dot {\n-            // Attempt to recover `.4` as `0.4`.\n-            recovered = self.look_ahead(1, |next_token| {\n-                if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix })\n-                        = next_token.kind {\n-                    if self.token.span.hi() == next_token.span.lo() {\n-                        let s = String::from(\"0.\") + &symbol.as_str();\n-                        let kind = TokenKind::lit(token::Float, Symbol::intern(&s), suffix);\n-                        return Some(Token::new(kind, self.token.span.to(next_token.span)));\n-                    }\n-                }\n-                None\n-            });\n-            if let Some(token) = &recovered {\n-                self.bump();\n-                self.diagnostic()\n-                    .struct_span_err(token.span, \"float literals must have an integer part\")\n-                    .span_suggestion(\n-                        token.span,\n-                        \"must have an integer part\",\n-                        pprust::token_to_string(token),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-            }\n-        }\n-\n-        let token = recovered.as_ref().unwrap_or(&self.token);\n-        match Lit::from_token(token) {\n-            Ok(lit) => {\n-                self.bump();\n-                Ok(lit)\n-            }\n-            Err(LitError::NotLiteral) => {\n-                let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n-                Err(self.span_fatal(token.span, &msg))\n-            }\n-            Err(err) => {\n-                let (lit, span) = (token.expect_lit(), token.span);\n-                self.bump();\n-                err.report(&self.sess.span_diagnostic, lit, span);\n-                // Pack possible quotes and prefixes from the original literal into\n-                // the error literal's symbol so they can be pretty-printed faithfully.\n-                let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n-                let symbol = Symbol::intern(&suffixless_lit.to_string());\n-                let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n-                Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n-            }\n-        }\n-    }\n-}\n-\n-crate fn expect_no_suffix(diag: &Handler, sp: Span, kind: &str, suffix: Option<Symbol>) {\n-    if let Some(suf) = suffix {\n-        let mut err = if kind == \"a tuple index\" &&\n-                         [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suf) {\n-            // #59553: warn instead of reject out of hand to allow the fix to percolate\n-            // through the ecosystem when people fix their macros\n-            let mut err = diag.struct_span_warn(\n-                sp,\n-                &format!(\"suffixes on {} are invalid\", kind),\n-            );\n-            err.note(&format!(\n-                \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n-                    incorrectly accepted on stable for a few releases\",\n-                suf,\n-            ));\n-            err.help(\n-                \"on proc macros, you'll want to use `syn::Index::from` or \\\n-                    `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n-                    to tuple field access\",\n-            );\n-            err.note(\n-                \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n-            );\n-            err\n-        } else {\n-            diag.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n-        };\n-        err.span_label(sp, format!(\"invalid suffix `{}`\", suf));\n-        err.emit();\n-    }\n-}\n-\n-// Checks if `s` looks like i32 or u1234 etc.\n-fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n-    s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n-}\n-\n fn strip_underscores(symbol: Symbol) -> Symbol {\n     // Do not allocate a new string unless necessary.\n     let s = symbol.as_str();"}, {"sha": "cb90caab77a8867dac106143f0a695893ec108d3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 118, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,26 +1,20 @@\n //! The main parser interface.\n \n-use crate::ast::{self, CrateConfig, NodeId};\n-use crate::early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n-use crate::source_map::{SourceMap, FilePathMapping};\n-use crate::feature_gate::UnstableFeatures;\n+use crate::ast;\n use crate::parse::parser::{Parser, emit_unclosed_delims};\n use crate::parse::token::{Nonterminal, TokenKind};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n use crate::print::pprust;\n-use crate::symbol::Symbol;\n+use crate::sess::ParseSess;\n \n-use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use errors::{FatalError, Level, Diagnostic, DiagnosticBuilder};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n-use rustc_data_structures::sync::{Lrc, Lock, Once};\n-use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n-use syntax_pos::edition::Edition;\n-use syntax_pos::hygiene::ExpnId;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::{Span, SourceFile, FileName};\n \n use std::borrow::Cow;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::str;\n \n use log::info;\n@@ -46,112 +40,6 @@ pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PResult<'_, bool>, 16);\n \n-/// Collected spans during parsing for places where a certain feature was\n-/// used and should be feature gated accordingly in `check_crate`.\n-#[derive(Default)]\n-pub struct GatedSpans {\n-    /// Spans collected for gating `let_chains`, e.g. `if a && let b = c {}`.\n-    pub let_chains: Lock<Vec<Span>>,\n-    /// Spans collected for gating `async_closure`, e.g. `async || ..`.\n-    pub async_closure: Lock<Vec<Span>>,\n-    /// Spans collected for gating `yield e?` expressions (`generators` gate).\n-    pub yields: Lock<Vec<Span>>,\n-    /// Spans collected for gating `or_patterns`, e.g. `Some(Foo | Bar)`.\n-    pub or_patterns: Lock<Vec<Span>>,\n-    /// Spans collected for gating `const_extern_fn`, e.g. `const extern fn foo`.\n-    pub const_extern_fn: Lock<Vec<Span>>,\n-}\n-\n-/// Info about a parsing session.\n-pub struct ParseSess {\n-    pub span_diagnostic: Handler,\n-    pub unstable_features: UnstableFeatures,\n-    pub config: CrateConfig,\n-    pub edition: Edition,\n-    pub missing_fragment_specifiers: Lock<FxHashSet<Span>>,\n-    /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n-    pub raw_identifier_spans: Lock<Vec<Span>>,\n-    /// Used to determine and report recursive module inclusions.\n-    included_mod_stack: Lock<Vec<PathBuf>>,\n-    source_map: Lrc<SourceMap>,\n-    pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n-    /// Contains the spans of block expressions that could have been incomplete based on the\n-    /// operation token that followed it, but that the parser cannot identify without further\n-    /// analysis.\n-    pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n-    pub injected_crate_name: Once<Symbol>,\n-    pub gated_spans: GatedSpans,\n-}\n-\n-impl ParseSess {\n-    pub fn new(file_path_mapping: FilePathMapping) -> Self {\n-        let cm = Lrc::new(SourceMap::new(file_path_mapping));\n-        let handler = Handler::with_tty_emitter(\n-            ColorConfig::Auto,\n-            true,\n-            None,\n-            Some(cm.clone()),\n-        );\n-        ParseSess::with_span_handler(handler, cm)\n-    }\n-\n-    pub fn with_span_handler(handler: Handler, source_map: Lrc<SourceMap>) -> Self {\n-        Self {\n-            span_diagnostic: handler,\n-            unstable_features: UnstableFeatures::from_environment(),\n-            config: FxHashSet::default(),\n-            edition: ExpnId::root().expn_data().edition,\n-            missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n-            raw_identifier_spans: Lock::new(Vec::new()),\n-            included_mod_stack: Lock::new(vec![]),\n-            source_map,\n-            buffered_lints: Lock::new(vec![]),\n-            ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-            injected_crate_name: Once::new(),\n-            gated_spans: GatedSpans::default(),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn source_map(&self) -> &SourceMap {\n-        &self.source_map\n-    }\n-\n-    pub fn buffer_lint<S: Into<MultiSpan>>(&self,\n-        lint_id: BufferedEarlyLintId,\n-        span: S,\n-        id: NodeId,\n-        msg: &str,\n-    ) {\n-        self.buffered_lints.with_lock(|buffered_lints| {\n-            buffered_lints.push(BufferedEarlyLint{\n-                span: span.into(),\n-                id,\n-                msg: msg.into(),\n-                lint_id,\n-            });\n-        });\n-    }\n-\n-    /// Extend an error with a suggestion to wrap an expression with parentheses to allow the\n-    /// parser to continue parsing the following operation as part of the same expression.\n-    pub fn expr_parentheses_needed(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        span: Span,\n-        alt_snippet: Option<String>,\n-    ) {\n-        if let Some(snippet) = self.source_map().span_to_snippet(span).ok().or(alt_snippet) {\n-            err.span_suggestion(\n-                span,\n-                \"parentheses are required to parse this as an expression\",\n-                format!(\"({})\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct Directory<'a> {\n     pub path: Cow<'a, Path>,"}, {"sha": "86383761484db95f15398a50579da9ea77484d4e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -15,12 +15,13 @@ use crate::ast::{\n     self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n     IsAsync, MacDelimiter, Mutability, StrStyle, Visibility, VisibilityKind, Unsafety,\n };\n-use crate::parse::{ParseSess, PResult, Directory, DirectoryOwnership, SeqSep, literal, token};\n+use crate::parse::{PResult, Directory, DirectoryOwnership, SeqSep};\n use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use crate::parse::token::{Token, TokenKind, DelimToken};\n+use crate::parse::token::{self, Token, TokenKind, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n+use crate::sess::ParseSess;\n use crate::source_map::respan;\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n@@ -637,10 +638,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n-        literal::expect_no_suffix(&self.sess.span_diagnostic, sp, kind, suffix)\n-    }\n-\n     /// Attempts to consume a `<`. If `<<` is seen, replaces it with a single\n     /// `<` and continue. If `<-` is seen, replaces it with a single `<`\n     /// and continue. If a `<` is not seen, returns false.\n@@ -1366,7 +1363,7 @@ impl<'a> Parser<'a> {\n             ],\n             Applicability::MaybeIncorrect,\n         ).span_suggestion(\n-            self.sess.source_map.next_point(self.prev_span),\n+            self.sess.source_map().next_point(self.prev_span),\n             \"add a semicolon\",\n             ';'.to_string(),\n             Applicability::MaybeIncorrect,"}, {"sha": "dd0fd834fb0c901d76fbbbe415fc84a097b4abb1", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 166, "deletions": 6, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,17 +1,17 @@\n-use super::{\n-    Parser, PResult, Restrictions, PrevTokenKind, TokenType, PathStyle, BlockMode, SemiColonMode,\n-    SeqSep, TokenExpectType,\n-};\n+use super::{Parser, PResult, Restrictions, PrevTokenKind, TokenType, PathStyle, BlockMode};\n+use super::{SemiColonMode, SeqSep, TokenExpectType};\n use super::pat::{GateOr, PARAM_EXPECTED};\n \n+use crate::parse::literal::LitError;\n+\n use crate::ast::{\n     self, DUMMY_NODE_ID, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode,\n     Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm, Ty, TyKind,\n-    FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst, Field,\n+    FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst, Field, Lit,\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n use crate::parse::classify;\n-use crate::parse::token::{self, Token};\n+use crate::parse::token::{self, Token, TokenKind};\n use crate::parse::diagnostics::Error;\n use crate::print::pprust;\n use crate::ptr::P;\n@@ -20,6 +20,7 @@ use crate::symbol::{kw, sym};\n use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n \n use errors::Applicability;\n+use syntax_pos::Symbol;\n use std::mem;\n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -1072,6 +1073,165 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n+    /// Matches `lit = true | false | token_lit`.\n+    crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n+        let mut recovered = None;\n+        if self.token == token::Dot {\n+            // Attempt to recover `.4` as `0.4`.\n+            recovered = self.look_ahead(1, |next_token| {\n+                if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix })\n+                        = next_token.kind {\n+                    if self.token.span.hi() == next_token.span.lo() {\n+                        let s = String::from(\"0.\") + &symbol.as_str();\n+                        let kind = TokenKind::lit(token::Float, Symbol::intern(&s), suffix);\n+                        return Some(Token::new(kind, self.token.span.to(next_token.span)));\n+                    }\n+                }\n+                None\n+            });\n+            if let Some(token) = &recovered {\n+                self.bump();\n+                self.struct_span_err(token.span, \"float literals must have an integer part\")\n+                    .span_suggestion(\n+                        token.span,\n+                        \"must have an integer part\",\n+                        pprust::token_to_string(token),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+            }\n+        }\n+\n+        let token = recovered.as_ref().unwrap_or(&self.token);\n+        match Lit::from_token(token) {\n+            Ok(lit) => {\n+                self.bump();\n+                Ok(lit)\n+            }\n+            Err(LitError::NotLiteral) => {\n+                let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n+                Err(self.span_fatal(token.span, &msg))\n+            }\n+            Err(err) => {\n+                let (lit, span) = (token.expect_lit(), token.span);\n+                self.bump();\n+                self.error_literal_from_token(err, lit, span);\n+                // Pack possible quotes and prefixes from the original literal into\n+                // the error literal's symbol so they can be pretty-printed faithfully.\n+                let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n+                let symbol = Symbol::intern(&suffixless_lit.to_string());\n+                let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n+                Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n+            }\n+        }\n+    }\n+\n+    fn error_literal_from_token(&self, err: LitError, lit: token::Lit, span: Span) {\n+        // Checks if `s` looks like i32 or u1234 etc.\n+        fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n+            s.len() > 1\n+            && s.starts_with(first_chars)\n+            && s[1..].chars().all(|c| c.is_ascii_digit())\n+        }\n+\n+        let token::Lit { kind, suffix, .. } = lit;\n+        match err {\n+            // `NotLiteral` is not an error by itself, so we don't report\n+            // it and give the parser opportunity to try something else.\n+            LitError::NotLiteral => {}\n+            // `LexerError` *is* an error, but it was already reported\n+            // by lexer, so here we don't report it the second time.\n+            LitError::LexerError => {}\n+            LitError::InvalidSuffix => {\n+                self.expect_no_suffix(\n+                    span,\n+                    &format!(\"{} {} literal\", kind.article(), kind.descr()),\n+                    suffix,\n+                );\n+            }\n+            LitError::InvalidIntSuffix => {\n+                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n+                if looks_like_width_suffix(&['i', 'u'], &suf) {\n+                    // If it looks like a width, try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n+                    self.struct_span_err(span, &msg)\n+                        .help(\"valid widths are 8, 16, 32, 64 and 128\")\n+                        .emit();\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for integer literal\", suf);\n+                    self.struct_span_err(span, &msg)\n+                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .help(\"the suffix must be one of the integral types (`u32`, `isize`, etc)\")\n+                        .emit();\n+                }\n+            }\n+            LitError::InvalidFloatSuffix => {\n+                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n+                if looks_like_width_suffix(&['f'], &suf) {\n+                    // If it looks like a width, try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n+                    self.struct_span_err(span, &msg)\n+                        .help(\"valid widths are 32 and 64\")\n+                        .emit();\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n+                    self.struct_span_err(span, &msg)\n+                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .help(\"valid suffixes are `f32` and `f64`\")\n+                        .emit();\n+                }\n+            }\n+            LitError::NonDecimalFloat(base) => {\n+                let descr = match base {\n+                    16 => \"hexadecimal\",\n+                    8 => \"octal\",\n+                    2 => \"binary\",\n+                    _ => unreachable!(),\n+                };\n+                self.struct_span_err(span, &format!(\"{} float literal is not supported\", descr))\n+                    .span_label(span, \"not supported\")\n+                    .emit();\n+            }\n+            LitError::IntTooLarge => {\n+                self.struct_span_err(span, \"integer literal is too large\")\n+                    .emit();\n+            }\n+        }\n+    }\n+\n+    pub(super) fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<Symbol>) {\n+        if let Some(suf) = suffix {\n+            let mut err = if kind == \"a tuple index\"\n+                && [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suf)\n+            {\n+                // #59553: warn instead of reject out of hand to allow the fix to percolate\n+                // through the ecosystem when people fix their macros\n+                let mut err = self.sess.span_diagnostic.struct_span_warn(\n+                    sp,\n+                    &format!(\"suffixes on {} are invalid\", kind),\n+                );\n+                err.note(&format!(\n+                    \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n+                        incorrectly accepted on stable for a few releases\",\n+                    suf,\n+                ));\n+                err.help(\n+                    \"on proc macros, you'll want to use `syn::Index::from` or \\\n+                        `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n+                        to tuple field access\",\n+                );\n+                err.note(\n+                    \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n+                );\n+                err\n+            } else {\n+                self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+            };\n+            err.span_label(sp, format!(\"invalid suffix `{}`\", suf));\n+            err.emit();\n+        }\n+    }\n+\n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n     crate fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);"}, {"sha": "136fc355f89d499f29f6843977d8c51977d5f326", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -6,10 +6,11 @@ use crate::attr;\n use crate::source_map::{self, SourceMap, Spanned};\n use crate::parse::token::{self, BinOpToken, DelimToken, Nonterminal, Token, TokenKind};\n use crate::parse::lexer::comments;\n-use crate::parse::{self, ParseSess};\n+use crate::parse;\n use crate::print::pp::{self, Breaks};\n use crate::print::pp::Breaks::{Consistent, Inconsistent};\n use crate::ptr::P;\n+use crate::sess::ParseSess;\n use crate::symbol::{kw, sym};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n "}, {"sha": "e49d3954f8e6976e76f5d57ac271f1d8c2a89114", "filename": "src/libsyntax/sess.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fsess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Fsess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsess.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -0,0 +1,124 @@\n+//! Contains `ParseSess` which holds state living beyond what one `Parser` might.\n+//! It also serves as an input to the parser itself.\n+\n+use crate::ast::{CrateConfig, NodeId};\n+use crate::early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n+use crate::source_map::{SourceMap, FilePathMapping};\n+use crate::feature_gate::UnstableFeatures;\n+\n+use errors::{Applicability, Handler, ColorConfig, DiagnosticBuilder};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_data_structures::sync::{Lrc, Lock, Once};\n+use syntax_pos::{Symbol, Span, MultiSpan};\n+use syntax_pos::edition::Edition;\n+use syntax_pos::hygiene::ExpnId;\n+\n+use std::path::PathBuf;\n+use std::str;\n+\n+/// Collected spans during parsing for places where a certain feature was\n+/// used and should be feature gated accordingly in `check_crate`.\n+#[derive(Default)]\n+crate struct GatedSpans {\n+    /// Spans collected for gating `let_chains`, e.g. `if a && let b = c {}`.\n+    crate let_chains: Lock<Vec<Span>>,\n+    /// Spans collected for gating `async_closure`, e.g. `async || ..`.\n+    crate async_closure: Lock<Vec<Span>>,\n+    /// Spans collected for gating `yield e?` expressions (`generators` gate).\n+    crate yields: Lock<Vec<Span>>,\n+    /// Spans collected for gating `or_patterns`, e.g. `Some(Foo | Bar)`.\n+    crate or_patterns: Lock<Vec<Span>>,\n+    /// Spans collected for gating `const_extern_fn`, e.g. `const extern fn foo`.\n+    crate const_extern_fn: Lock<Vec<Span>>,\n+}\n+\n+/// Info about a parsing session.\n+pub struct ParseSess {\n+    pub span_diagnostic: Handler,\n+    crate unstable_features: UnstableFeatures,\n+    pub config: CrateConfig,\n+    pub edition: Edition,\n+    pub missing_fragment_specifiers: Lock<FxHashSet<Span>>,\n+    /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n+    pub raw_identifier_spans: Lock<Vec<Span>>,\n+    /// Used to determine and report recursive module inclusions.\n+    pub(super) included_mod_stack: Lock<Vec<PathBuf>>,\n+    source_map: Lrc<SourceMap>,\n+    pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n+    /// Contains the spans of block expressions that could have been incomplete based on the\n+    /// operation token that followed it, but that the parser cannot identify without further\n+    /// analysis.\n+    pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n+    pub injected_crate_name: Once<Symbol>,\n+    crate gated_spans: GatedSpans,\n+}\n+\n+impl ParseSess {\n+    pub fn new(file_path_mapping: FilePathMapping) -> Self {\n+        let cm = Lrc::new(SourceMap::new(file_path_mapping));\n+        let handler = Handler::with_tty_emitter(\n+            ColorConfig::Auto,\n+            true,\n+            None,\n+            Some(cm.clone()),\n+        );\n+        ParseSess::with_span_handler(handler, cm)\n+    }\n+\n+    pub fn with_span_handler(handler: Handler, source_map: Lrc<SourceMap>) -> Self {\n+        Self {\n+            span_diagnostic: handler,\n+            unstable_features: UnstableFeatures::from_environment(),\n+            config: FxHashSet::default(),\n+            edition: ExpnId::root().expn_data().edition,\n+            missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n+            raw_identifier_spans: Lock::new(Vec::new()),\n+            included_mod_stack: Lock::new(vec![]),\n+            source_map,\n+            buffered_lints: Lock::new(vec![]),\n+            ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n+            injected_crate_name: Once::new(),\n+            gated_spans: GatedSpans::default(),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn source_map(&self) -> &SourceMap {\n+        &self.source_map\n+    }\n+\n+    pub fn buffer_lint(\n+        &self,\n+        lint_id: BufferedEarlyLintId,\n+        span: impl Into<MultiSpan>,\n+        id: NodeId,\n+        msg: &str,\n+    ) {\n+        self.buffered_lints.with_lock(|buffered_lints| {\n+            buffered_lints.push(BufferedEarlyLint{\n+                span: span.into(),\n+                id,\n+                msg: msg.into(),\n+                lint_id,\n+            });\n+        });\n+    }\n+\n+    /// Extend an error with a suggestion to wrap an expression with parentheses to allow the\n+    /// parser to continue parsing the following operation as part of the same expression.\n+    pub fn expr_parentheses_needed(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        span: Span,\n+        alt_snippet: Option<String>,\n+    ) {\n+        if let Some(snippet) = self.source_map().span_to_snippet(span).ok().or(alt_snippet) {\n+            err.span_suggestion(\n+                span,\n+                \"parentheses are required to parse this as an expression\",\n+                format!(\"({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "fbcf368ccb7b8aaa92a9b11420704bba286bf6e6", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,7 +1,8 @@\n use crate::{ast, panictry};\n-use crate::parse::{ParseSess, PResult, source_file_to_stream};\n+use crate::parse::{PResult, source_file_to_stream};\n use crate::parse::new_parser_from_source_str;\n use crate::parse::parser::Parser;\n+use crate::sess::ParseSess;\n use crate::source_map::{SourceMap, FilePathMapping};\n use crate::tokenstream::TokenStream;\n use crate::with_default_globals;"}, {"sha": "2c3159739e2431a20fff6aacaf2e30a08bd0a4ab", "filename": "src/libsyntax_ext/cmdline_attrs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcmdline_attrs.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -3,7 +3,8 @@\n use syntax::ast::{self, AttrItem, AttrStyle};\n use syntax::attr::mk_attr;\n use syntax::panictry;\n-use syntax::parse::{self, token, ParseSess};\n+use syntax::parse::{self, token};\n+use syntax::sess::ParseSess;\n use syntax_pos::FileName;\n \n pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {"}, {"sha": "9c3ec06d59a344c855824ccd837f279f111804a7", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -190,8 +190,8 @@ use syntax::ext::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::source_map::respan;\n use syntax::util::map_in_place::MapInPlace;\n use syntax::ptr::P;\n+use syntax::sess::ParseSess;\n use syntax::symbol::{Symbol, kw, sym};\n-use syntax::parse::ParseSess;\n use syntax_pos::{Span};\n \n use ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};"}, {"sha": "1b7068818b014dc5be00444028273e885cc0a504", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -6,9 +6,9 @@ use syntax::attr;\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::proc_macro::is_proc_macro_attr;\n-use syntax::parse::ParseSess;\n use syntax::print::pprust;\n use syntax::ptr::P;\n+use syntax::sess::ParseSess;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, DUMMY_SP};"}, {"sha": "4f17acf2d0f66a352f720cc90e177afffb510e35", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -3,8 +3,8 @@ use syntax::edition::Edition;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::ext::hygiene::AstPass;\n use syntax::ext::base::{ExtCtxt, Resolver};\n-use syntax::parse::ParseSess;\n use syntax::ptr::P;\n+use syntax::sess::ParseSess;\n use syntax::symbol::{Ident, Symbol, kw, sym};\n use syntax_pos::DUMMY_SP;\n "}, {"sha": "0bb279c0cb0d2ed32065306fee9eaaec2fecc2b6", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -10,8 +10,8 @@ use syntax::ext::base::{ExtCtxt, Resolver};\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::feature_gate::Features;\n use syntax::mut_visit::{*, ExpectOne};\n-use syntax::parse::ParseSess;\n use syntax::ptr::P;\n+use syntax::sess::ParseSess;\n use syntax::source_map::respan;\n use syntax::symbol::{sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP};"}, {"sha": "7f7c5cb2e454865aa188616c11958410f98fe3b9", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -12,7 +12,7 @@\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n #![feature(rustc_attrs)]\n-#![feature(proc_macro_hygiene)]\n+#![cfg_attr(bootstrap, feature(proc_macro_hygiene))]\n #![feature(specialization)]\n #![feature(step_trait)]\n "}, {"sha": "8298edb42d46ef5e6b8e3d4f0aad99fcc92d36b8", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1202,30 +1202,6 @@ impl<T: std::ops::Deref<Target = str>> std::cmp::PartialEq<T> for LocalInternedS\n     }\n }\n \n-impl std::cmp::PartialEq<LocalInternedString> for str {\n-    fn eq(&self, other: &LocalInternedString) -> bool {\n-        self == other.string\n-    }\n-}\n-\n-impl<'a> std::cmp::PartialEq<LocalInternedString> for &'a str {\n-    fn eq(&self, other: &LocalInternedString) -> bool {\n-        *self == other.string\n-    }\n-}\n-\n-impl std::cmp::PartialEq<LocalInternedString> for String {\n-    fn eq(&self, other: &LocalInternedString) -> bool {\n-        self == other.string\n-    }\n-}\n-\n-impl<'a> std::cmp::PartialEq<LocalInternedString> for &'a String {\n-    fn eq(&self, other: &LocalInternedString) -> bool {\n-        *self == other.string\n-    }\n-}\n-\n impl !Send for LocalInternedString {}\n impl !Sync for LocalInternedString {}\n "}, {"sha": "5479119d812f8e9fb3460d60f7f6f3f1bedf6223", "filename": "src/test/ui-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -10,9 +10,10 @@ extern crate syntax;\n use syntax::ast::*;\n use syntax::attr::*;\n use syntax::ast;\n+use syntax::sess::ParseSess;\n use syntax::source_map::{FilePathMapping, FileName};\n use syntax::parse;\n-use syntax::parse::{ParseSess, PResult};\n+use syntax::parse::PResult;\n use syntax::parse::new_parser_from_source_str;\n use syntax::parse::parser::Parser;\n use syntax::parse::token;"}, {"sha": "ac97ec70be207c6fca136bd0687cc8108cc8b93a", "filename": "src/test/ui-fulldeps/mod_dir_path_canonicalized.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -7,8 +7,9 @@\n extern crate syntax;\n \n use std::path::Path;\n+use syntax::sess::ParseSess;\n use syntax::source_map::FilePathMapping;\n-use syntax::parse::{self, ParseSess};\n+use syntax::parse;\n \n #[path = \"mod_dir_simple/test.rs\"]\n mod gravy;"}, {"sha": "932a173bc67a865e5723a34a97e54b0e3e81cae2", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -24,14 +24,14 @@ extern crate syntax;\n \n use rustc_data_structures::thin_vec::ThinVec;\n use syntax::ast::*;\n+use syntax::sess::ParseSess;\n use syntax::source_map::{Spanned, DUMMY_SP, FileName};\n use syntax::source_map::FilePathMapping;\n use syntax::mut_visit::{self, MutVisitor, visit_clobber};\n-use syntax::parse::{self, ParseSess};\n+use syntax::parse;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n-\n fn parse_expr(ps: &ParseSess, src: &str) -> Option<P<Expr>> {\n     let src_as_string = src.to_string();\n "}, {"sha": "e0bb4d98525b9c4d5d61fc1fc200407fcc03e4c4", "filename": "src/test/ui/macros/same-sequence-span.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -4,7 +4,6 @@\n // left-hand side of a macro definition behave as if they had unique spans, and in particular that\n // they don't crash the compiler.\n \n-#![feature(proc_macro_hygiene)]\n #![allow(unused_macros)]\n \n extern crate proc_macro_sequence;"}, {"sha": "896f579765f957c58ba6df3efa3e72055aeaa762", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -1,21 +1,21 @@\n error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n-  --> $DIR/same-sequence-span.rs:15:18\n+  --> $DIR/same-sequence-span.rs:14:18\n    |\n LL |     (1 $x:expr $($y:tt,)*\n    |                  ^^^^^ not allowed after `expr` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n-  --> $DIR/same-sequence-span.rs:16:18\n+  --> $DIR/same-sequence-span.rs:15:18\n    |\n LL |                $(= $z:tt)*\n    |                  ^ not allowed after `expr` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n-  --> $DIR/same-sequence-span.rs:20:1\n+  --> $DIR/same-sequence-span.rs:19:1\n    |\n LL |   proc_macro_sequence::make_foo!();\n    |   ^--------------------------------\n@@ -30,7 +30,7 @@ LL | | fn main() {}\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n-  --> $DIR/same-sequence-span.rs:20:1\n+  --> $DIR/same-sequence-span.rs:19:1\n    |\n LL | proc_macro_sequence::make_foo!();\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "548fefe76f57111a25c50726aa6c6e0500b0d3c9", "filename": "src/test/ui/proc-macro/auxiliary/gen-macro-rules-hygiene.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules-hygiene.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -0,0 +1,23 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn gen_macro_rules(_: TokenStream) -> TokenStream {\n+    \"\n+    macro_rules! generated {() => {\n+        struct ItemDef;\n+        let local_def = 0;\n+\n+        ItemUse; // OK\n+        local_use; // ERROR\n+        break 'label_use; // ERROR\n+\n+        type DollarCrate = $crate::ItemUse; // OK\n+    }}\n+    \".parse().unwrap()\n+}"}, {"sha": "6b609eaee1295dd0e87c6fba02af46c8b7b82648", "filename": "src/test/ui/proc-macro/auxiliary/more-gates.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/437ca55f23b7ed0051334a7e38ecabd83a173b53/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmore-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/437ca55f23b7ed0051334a7e38ecabd83a173b53/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmore-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmore-gates.rs?ref=437ca55f23b7ed0051334a7e38ecabd83a173b53", "patch": "@@ -1,35 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::*;\n-\n-#[proc_macro_attribute]\n-pub fn attr2mac1(_: TokenStream, _: TokenStream) -> TokenStream {\n-    \"macro_rules! foo1 { (a) => (a) }\".parse().unwrap()\n-}\n-\n-#[proc_macro_attribute]\n-pub fn attr2mac2(_: TokenStream, _: TokenStream) -> TokenStream {\n-    \"macro foo2(a) { a }\".parse().unwrap()\n-}\n-\n-#[proc_macro]\n-pub fn mac2mac1(_: TokenStream) -> TokenStream {\n-    \"macro_rules! foo3 { (a) => (a) }\".parse().unwrap()\n-}\n-\n-#[proc_macro]\n-pub fn mac2mac2(_: TokenStream) -> TokenStream {\n-    \"macro foo4(a) { a }\".parse().unwrap()\n-}\n-\n-#[proc_macro]\n-pub fn tricky(_: TokenStream) -> TokenStream {\n-    \"fn foo() {\n-        macro_rules! foo { (a) => (a) }\n-    }\".parse().unwrap()\n-}"}, {"sha": "195bda82e9ce1f3cee048362d59f5650d3549592", "filename": "src/test/ui/proc-macro/gen-macro-rules-hygiene.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules-hygiene.rs?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -0,0 +1,23 @@\n+// `macro_rules` items produced by transparent macros have correct hygiene in basic cases.\n+// Local variables and labels are hygienic, items are not hygienic.\n+// `$crate` refers to the crate that defines `macro_rules` and not the outer transparent macro.\n+\n+// aux-build:gen-macro-rules-hygiene.rs\n+\n+#[macro_use]\n+extern crate gen_macro_rules_hygiene;\n+\n+struct ItemUse;\n+\n+gen_macro_rules!();\n+//~^ ERROR use of undeclared label `'label_use`\n+//~| ERROR cannot find value `local_use` in this scope\n+\n+fn main() {\n+    'label_use: loop {\n+        let local_use = 1;\n+        generated!();\n+        ItemDef; // OK\n+        local_def; //~ ERROR cannot find value `local_def` in this scope\n+    }\n+}"}, {"sha": "ecebdfa965666ec7fc2771a6f41fdc88a1c71516", "filename": "src/test/ui/proc-macro/gen-macro-rules-hygiene.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules-hygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/237d54ff6c4fb3577e02d4c5af02813c11b63d01/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules-hygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules-hygiene.stderr?ref=237d54ff6c4fb3577e02d4c5af02813c11b63d01", "patch": "@@ -0,0 +1,28 @@\n+error[E0426]: use of undeclared label `'label_use`\n+  --> $DIR/gen-macro-rules-hygiene.rs:12:1\n+   |\n+LL | gen_macro_rules!();\n+   | ^^^^^^^^^^^^^^^^^^^ undeclared label `'label_use`\n+...\n+LL |         generated!();\n+   |         ------------- in this macro invocation\n+\n+error[E0425]: cannot find value `local_use` in this scope\n+  --> $DIR/gen-macro-rules-hygiene.rs:12:1\n+   |\n+LL | gen_macro_rules!();\n+   | ^^^^^^^^^^^^^^^^^^^ not found in this scope\n+...\n+LL |         generated!();\n+   |         ------------- in this macro invocation\n+\n+error[E0425]: cannot find value `local_def` in this scope\n+  --> $DIR/gen-macro-rules-hygiene.rs:21:9\n+   |\n+LL |         local_def;\n+   |         ^^^^^^^^^ not found in this scope\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0425, E0426.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "b870b438a65406101839550ab906fca5a9123ad3", "filename": "src/test/ui/proc-macro/more-gates.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/437ca55f23b7ed0051334a7e38ecabd83a173b53/src%2Ftest%2Fui%2Fproc-macro%2Fmore-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/437ca55f23b7ed0051334a7e38ecabd83a173b53/src%2Ftest%2Fui%2Fproc-macro%2Fmore-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmore-gates.rs?ref=437ca55f23b7ed0051334a7e38ecabd83a173b53", "patch": "@@ -1,22 +0,0 @@\n-// aux-build:more-gates.rs\n-\n-#![feature(decl_macro)]\n-\n-extern crate more_gates as foo;\n-\n-use foo::*;\n-\n-#[attr2mac1]\n-//~^ ERROR: cannot expand to macro definitions\n-pub fn a() {}\n-#[attr2mac2]\n-//~^ ERROR: cannot expand to macro definitions\n-pub fn a() {}\n-\n-mac2mac1!(); //~ ERROR: cannot expand to macro definitions\n-mac2mac2!(); //~ ERROR: cannot expand to macro definitions\n-\n-tricky!();\n-//~^ ERROR: cannot expand to macro definitions\n-\n-fn main() {}"}, {"sha": "ad96f78c77ad026947b1941d51e027e090dc81e7", "filename": "src/test/ui/proc-macro/more-gates.stderr", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/437ca55f23b7ed0051334a7e38ecabd83a173b53/src%2Ftest%2Fui%2Fproc-macro%2Fmore-gates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/437ca55f23b7ed0051334a7e38ecabd83a173b53/src%2Ftest%2Fui%2Fproc-macro%2Fmore-gates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmore-gates.stderr?ref=437ca55f23b7ed0051334a7e38ecabd83a173b53", "patch": "@@ -1,48 +0,0 @@\n-error[E0658]: procedural macros cannot expand to macro definitions\n-  --> $DIR/more-gates.rs:9:1\n-   |\n-LL | #[attr2mac1]\n-   | ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n-   = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n-\n-error[E0658]: procedural macros cannot expand to macro definitions\n-  --> $DIR/more-gates.rs:12:1\n-   |\n-LL | #[attr2mac2]\n-   | ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n-   = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n-\n-error[E0658]: procedural macros cannot expand to macro definitions\n-  --> $DIR/more-gates.rs:16:1\n-   |\n-LL | mac2mac1!();\n-   | ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n-   = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n-\n-error[E0658]: procedural macros cannot expand to macro definitions\n-  --> $DIR/more-gates.rs:17:1\n-   |\n-LL | mac2mac2!();\n-   | ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n-   = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n-\n-error[E0658]: procedural macros cannot expand to macro definitions\n-  --> $DIR/more-gates.rs:19:1\n-   |\n-LL | tricky!();\n-   | ^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n-   = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n-\n-error: aborting due to 5 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}]}