{"sha": "a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "node_id": "C_kwDOAAsO6NoAKGE4ZWUwZTljMmNmYTdjNjA3ZTI0ZDc4Yzc3NGU5ZTg0M2RhMDhlNDU", "commit": {"author": {"name": "Lo\u00efc BRANSTETT", "email": "loic.branstett@epitech.eu", "date": "2021-11-18T10:48:52Z"}, "committer": {"name": "Lo\u00efc BRANSTETT", "email": "loic.branstett@epitech.eu", "date": "2021-11-20T09:14:03Z"}, "message": "Implement IEEE 754-2019 minimun and maximum functions for f32/f64", "tree": {"sha": "01ff0246ad51af0a7eea2bf37eb143704a204ca2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01ff0246ad51af0a7eea2bf37eb143704a204ca2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "html_url": "https://github.com/rust-lang/rust/commit/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/comments", "author": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41301c3b2371365b753c2ad6a74528a38f3815ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/41301c3b2371365b753c2ad6a74528a38f3815ce", "html_url": "https://github.com/rust-lang/rust/commit/41301c3b2371365b753c2ad6a74528a38f3815ce"}], "stats": {"total": 199, "additions": 199, "deletions": 0}, "files": [{"sha": "4571df917f385b0500ca24747c19863584feef74", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "patch": "@@ -703,6 +703,68 @@ impl f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n+    /// Returns the maximum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f32::max`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.maximum(y), y);\n+    /// assert!(x.maximum(f32::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follow the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn maximum(self, other: f32) -> f32 {\n+        if self > other {\n+            self\n+        } else if other > self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_positive() && other.is_sign_negative() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n+    /// Returns the minimum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f32::min`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.minimum(y), x);\n+    /// assert!(x.minimum(f32::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follow the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn minimum(self, other: f32) -> f32 {\n+        if self < other {\n+            self\n+        } else if other < self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_negative() && other.is_sign_positive() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n     /// Rounds toward zero and converts to any primitive integer type,\n     /// assuming that the value is finite and fits in that type.\n     ///"}, {"sha": "0ae32c5ea9507860376961d9a1be55f72606f5d9", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "patch": "@@ -719,6 +719,68 @@ impl f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n+    /// Returns the maximum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f64::max`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.maximum(y), y);\n+    /// assert!(x.maximum(f64::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follow the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn maximum(self, other: f64) -> f64 {\n+        if self > other {\n+            self\n+        } else if other > self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_positive() && other.is_sign_negative() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n+    /// Returns the minimum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f64::min`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.minimum(y), x);\n+    /// assert!(x.minimum(f64::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follow the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn minimum(self, other: f64) -> f64 {\n+        if self < other {\n+            self\n+        } else if other < self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_negative() && other.is_sign_positive() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n     /// Rounds toward zero and converts to any primitive integer type,\n     /// assuming that the value is finite and fits in that type.\n     ///"}, {"sha": "a56a1dbd17ae01df0cb35ed8e597c23f407be92e", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "patch": "@@ -27,6 +27,7 @@\n #![feature(extern_types)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n+#![feature(float_minimum_maximum)]\n #![feature(array_from_fn)]\n #![feature(hashmap_internals)]\n #![feature(try_find)]"}, {"sha": "4f773a824efd29a4aaa36d33a068675ca9324d61", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "patch": "@@ -715,6 +715,67 @@ macro_rules! test_float {\n                 assert!(($nan as $fty).max($nan).is_nan());\n             }\n             #[test]\n+            fn minimum() {\n+                assert_eq!((0.0 as $fty).minimum(0.0), 0.0);\n+                assert!((0.0 as $fty).minimum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).minimum(0.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(0.0).is_sign_negative());\n+                assert_eq!((-0.0 as $fty).minimum(-0.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(-0.0).is_sign_negative());\n+                assert_eq!((9.0 as $fty).minimum(9.0), 9.0);\n+                assert_eq!((-9.0 as $fty).minimum(0.0), -9.0);\n+                assert_eq!((0.0 as $fty).minimum(9.0), 0.0);\n+                assert!((0.0 as $fty).minimum(9.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).minimum(9.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(9.0).is_sign_negative());\n+                assert_eq!((-0.0 as $fty).minimum(-9.0), -9.0);\n+                assert_eq!(($inf as $fty).minimum(9.0), 9.0);\n+                assert_eq!((9.0 as $fty).minimum($inf), 9.0);\n+                assert_eq!(($inf as $fty).minimum(-9.0), -9.0);\n+                assert_eq!((-9.0 as $fty).minimum($inf), -9.0);\n+                assert_eq!(($neginf as $fty).minimum(9.0), $neginf);\n+                assert_eq!((9.0 as $fty).minimum($neginf), $neginf);\n+                assert_eq!(($neginf as $fty).minimum(-9.0), $neginf);\n+                assert_eq!((-9.0 as $fty).minimum($neginf), $neginf);\n+                assert!(($nan as $fty).minimum(9.0).is_nan());\n+                assert!(($nan as $fty).minimum(-9.0).is_nan());\n+                assert!((9.0 as $fty).minimum($nan).is_nan());\n+                assert!((-9.0 as $fty).minimum($nan).is_nan());\n+                assert!(($nan as $fty).minimum($nan).is_nan());\n+            }\n+            #[test]\n+            fn maximum() {\n+                assert_eq!((0.0 as $fty).maximum(0.0), 0.0);\n+                assert!((0.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(0.0), 0.0);\n+                assert!((-0.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(-0.0), -0.0);\n+                assert!((-0.0 as $fty).maximum(-0.0).is_sign_negative());\n+                assert_eq!((9.0 as $fty).maximum(9.0), 9.0);\n+                assert_eq!((-9.0 as $fty).maximum(0.0), 0.0);\n+                assert!((-9.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-9.0 as $fty).maximum(-0.0), -0.0);\n+                assert!((-9.0 as $fty).maximum(-0.0).is_sign_negative());\n+                assert_eq!((0.0 as $fty).maximum(9.0), 9.0);\n+                assert_eq!((0.0 as $fty).maximum(-9.0), 0.0);\n+                assert!((0.0 as $fty).maximum(-9.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(-9.0), -0.0);\n+                assert!((-0.0 as $fty).maximum(-9.0).is_sign_negative());\n+                assert_eq!(($inf as $fty).maximum(9.0), $inf);\n+                assert_eq!((9.0 as $fty).maximum($inf), $inf);\n+                assert_eq!(($inf as $fty).maximum(-9.0), $inf);\n+                assert_eq!((-9.0 as $fty).maximum($inf), $inf);\n+                assert_eq!(($neginf as $fty).maximum(9.0), 9.0);\n+                assert_eq!((9.0 as $fty).maximum($neginf), 9.0);\n+                assert_eq!(($neginf as $fty).maximum(-9.0), -9.0);\n+                assert_eq!((-9.0 as $fty).maximum($neginf), -9.0);\n+                assert!(($nan as $fty).maximum(9.0).is_nan());\n+                assert!(($nan as $fty).maximum(-9.0).is_nan());\n+                assert!((9.0 as $fty).maximum($nan).is_nan());\n+                assert!((-9.0 as $fty).maximum($nan).is_nan());\n+                assert!(($nan as $fty).maximum($nan).is_nan());\n+            }\n+            #[test]\n             fn rem_euclid() {\n                 let a: $fty = 42.0;\n                 assert!($inf.rem_euclid(a).is_nan());"}, {"sha": "69fa203ff4e70bb03c9f0a15615348345670a625", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "patch": "@@ -19,6 +19,18 @@ fn test_max_nan() {\n     assert_eq!(2.0f32.max(f32::NAN), 2.0);\n }\n \n+#[test]\n+fn test_minimum() {\n+    assert!(f32::NAN.minimum(2.0).is_nan());\n+    assert!(2.0f32.minimum(f32::NAN).is_nan());\n+}\n+\n+#[test]\n+fn test_maximum() {\n+    assert!(f32::NAN.maximum(2.0).is_nan());\n+    assert!(2.0f32.maximum(f32::NAN).is_nan());\n+}\n+\n #[test]\n fn test_nan() {\n     let nan: f32 = f32::NAN;"}, {"sha": "afd8d8edaa169f8b41d1bed27fdb56f7a4eb6ad8", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ee0e9c2cfa7c607e24d78c774e9e843da08e45/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=a8ee0e9c2cfa7c607e24d78c774e9e843da08e45", "patch": "@@ -287,6 +287,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n #![feature(fn_traits)]\n+#![feature(float_minimum_maximum)]\n #![feature(format_args_nl)]\n #![feature(gen_future)]\n #![feature(generator_trait)]"}]}