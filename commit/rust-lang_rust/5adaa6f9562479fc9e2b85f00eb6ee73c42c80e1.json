{"sha": "5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZGFhNmY5NTYyNDc5ZmM5ZTJiODVmMDBlYjZlZTczYzQyYzgwZTE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-10T00:36:07Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-10T00:53:52Z"}, "message": "Do some cleanup in stdlib.", "tree": {"sha": "bf93ee7faee9df2c4ea68a71bdcd094949bb5f03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf93ee7faee9df2c4ea68a71bdcd094949bb5f03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "html_url": "https://github.com/rust-lang/rust/commit/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "169f1e5b5a419eeca34e1d477b8fa44e1ace4b4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/169f1e5b5a419eeca34e1d477b8fa44e1ace4b4c", "html_url": "https://github.com/rust-lang/rust/commit/169f1e5b5a419eeca34e1d477b8fa44e1ace4b4c"}], "stats": {"total": 138, "additions": 69, "deletions": 69}, "files": [{"sha": "c5f895533bcad8cf70d582f257d43f8164934b95", "filename": "src/lib/list.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "patch": "@@ -1,11 +1,6 @@\n-\n import option::some;\n import option::none;\n \n-\n-// FIXME: It would probably be more appealing to define this as\n-// type list[T] = rec(T hd, option[@list[T]] tl), but at the moment\n-// our recursion rules do not permit that.\n tag list[T] { cons(T, @list[T]); nil; }\n \n fn from_vec[@T](v: vec[T]) -> list[T] {\n@@ -48,31 +43,41 @@ fn has[@T](ls_: &list[T], elt: &T) -> bool {\n     while true {\n         alt ls {\n           cons(hd, tl) { if elt == hd { ret true; } else { ls = *tl; } }\n-          nil. { ret false; }\n+          nil. { break; }\n         }\n     }\n-    ret false; // Typestate checker doesn't understand infinite loops\n-\n+    ret false;\n }\n \n fn length[@T](ls: &list[T]) -> uint {\n     fn count[T](t: &T, u: &uint) -> uint { ret u + 1u; }\n-    ret foldl[T, uint](ls, 0u, bind count[T](_, _));\n+    ret foldl(ls, 0u, count);\n }\n \n-fn cdr[@T](ls: &list[T]) -> list[T] { alt ls { cons(_, tl) { ret *tl; } } }\n+fn cdr[@T](ls: &list[T]) -> list[T] {\n+    alt ls {\n+      cons(_, tl) { ret *tl; }\n+      nil. { fail \"list empty\" }\n+    }\n+}\n \n-fn car[@T](ls: &list[T]) -> T { alt ls { cons(hd, _) { ret hd; } } }\n+fn car[@T](ls: &list[T]) -> T {\n+    alt ls {\n+      cons(hd, _) { ret hd; }\n+      nil. { fail \"list empty\" }\n+    }\n+}\n \n fn append[@T](l: &list[T], m: &list[T]) -> list[T] {\n     alt l {\n       nil. { ret m; }\n       cons(x, xs) {\n-        let rest: list[T] = append[T](*xs, m);\n-        ret cons[T](x, @rest);\n+        let rest = append(*xs, m);\n+        ret cons(x, @rest);\n       }\n     }\n }\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "68aecc6cbe0752053ae4638514a8c8ecc56169e2", "filename": "src/lib/map.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "patch": "@@ -53,10 +53,9 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n      * will fail.\n      */\n \n-    fn insert_common[@K,\n-                     @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                         bkts: &[mutable bucket[K, V]], nbkts: uint,\n-                         key: &K, val: &V) -> bool {\n+    fn insert_common[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K],\n+                             bkts: &[mutable bucket[K, V]], nbkts: uint,\n+                             key: &K, val: &V) -> bool {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n@@ -67,93 +66,88 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n \n                 let k_ = k;\n                 if eqer(key, k_) {\n-                    bkts.(j) = some[K, V](k_, val);\n+                    bkts.(j) = some(k_, val);\n                     ret false;\n                 }\n                 i += 1u;\n               }\n-              _ { bkts.(j) = some[K, V](key, val); ret true; }\n+              _ { bkts.(j) = some(key, val); ret true; }\n             }\n         }\n         fail; // full table\n-\n     }\n-    fn find_common[@K,\n-                   @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                       bkts: &[mutable bucket[K, V]], nbkts: uint, key: &K)\n-       -> option::t[V] {\n+    fn find_common[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K],\n+                           bkts: &[mutable bucket[K, V]], nbkts: uint,\n+                           key: &K) -> option::t[V] {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n             let j: uint = hash(h, nbkts, i);\n             alt bkts.(j) {\n               some(k, v) {\n                 // Copy to please alias analysis.\n-\n                 let k_ = k;\n                 let v_ = v;\n-                if eqer(key, k_) { ret option::some[V](v_); }\n+                if eqer(key, k_) { ret option::some(v_); }\n               }\n-              nil. { ret option::none[V]; }\n-              deleted[K, V]. { }\n+              nil. { ret option::none; }\n+              deleted. { }\n             }\n             i += 1u;\n         }\n-        ret option::none[V];\n+        ret option::none;\n     }\n-    fn rehash[@K,\n-              @V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                  oldbkts: &[mutable bucket[K, V]], noldbkts: uint,\n-                  newbkts: &[mutable bucket[K, V]], nnewbkts: uint) {\n+    fn rehash[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K],\n+                      oldbkts: &[mutable bucket[K, V]], noldbkts: uint,\n+                      newbkts: &[mutable bucket[K, V]], nnewbkts: uint) {\n         for b: bucket[K, V]  in oldbkts {\n             alt b {\n               some(k_, v_) {\n                 let k = k_;\n                 let v = v_;\n-                insert_common[K, V](hasher, eqer, newbkts, nnewbkts, k, v);\n+                insert_common(hasher, eqer, newbkts, nnewbkts, k, v);\n               }\n               _ { }\n             }\n         }\n     }\n-    obj hashmap[@K,\n-                @V](hasher: hashfn[K],\n-                    eqer: eqfn[K],\n-                    mutable bkts: [mutable bucket[K, V]],\n-                    mutable nbkts: uint,\n-                    mutable nelts: uint,\n-                    lf: util::rational) {\n+    obj hashmap[@K, @V](hasher: hashfn[K],\n+                        eqer: eqfn[K],\n+                        mutable bkts: [mutable bucket[K, V]],\n+                        mutable nbkts: uint,\n+                        mutable nelts: uint,\n+                        lf: util::rational) {\n         fn size() -> uint { ret nelts; }\n         fn insert(key: &K, val: &V) -> bool {\n             let load: util::rational =\n                 {num: nelts + 1u as int, den: nbkts as int};\n             if !util::rational_leq(load, lf) {\n                 let nnewbkts: uint = uint::next_power_of_two(nbkts + 1u);\n-                let newbkts = make_buckets[K, V](nnewbkts);\n-                rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nnewbkts);\n+                let newbkts = make_buckets(nnewbkts);\n+                rehash(hasher, eqer, bkts, nbkts, newbkts, nnewbkts);\n                 bkts = newbkts;\n                 nbkts = nnewbkts;\n             }\n-            if insert_common[K, V](hasher, eqer, bkts, nbkts, key, val) {\n+            if insert_common(hasher, eqer, bkts, nbkts, key, val) {\n                 nelts += 1u;\n                 ret true;\n             }\n             ret false;\n         }\n         fn contains_key(key: &K) -> bool {\n-            ret alt find_common[K, V](hasher, eqer, bkts, nbkts, key) {\n+            ret alt find_common(hasher, eqer, bkts, nbkts, key) {\n                   option::some(_) { true }\n                   _ { false }\n                 };\n         }\n         fn get(key: &K) -> V {\n-            ret alt find_common[K, V](hasher, eqer, bkts, nbkts, key) {\n+            ret alt find_common(hasher, eqer, bkts, nbkts, key) {\n                   option::some(val) { val }\n                   _ { fail }\n                 };\n         }\n         fn find(key: &K) -> option::t[V] {\n-            be find_common[K, V](hasher, eqer, bkts, nbkts, key);\n+            be find_common(hasher, eqer, bkts, nbkts, key);\n         }\n         fn remove(key: &K) -> option::t[V] {\n             let i: uint = 0u;\n@@ -165,21 +159,21 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n                     let k_ = k;\n                     let vo = option::some(v);\n                     if eqer(key, k_) {\n-                        bkts.(j) = deleted[K, V];\n+                        bkts.(j) = deleted;\n                         nelts -= 1u;\n                         ret vo;\n                     }\n                   }\n                   deleted. { }\n-                  nil. { ret option::none[V]; }\n+                  nil. { ret option::none; }\n                 }\n                 i += 1u;\n             }\n-            ret option::none[V];\n+            ret option::none;\n         }\n         fn rehash() {\n-            let newbkts = make_buckets[K, V](nbkts);\n-            rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nbkts);\n+            let newbkts = make_buckets(nbkts);\n+            rehash(hasher, eqer, bkts, nbkts, newbkts, nbkts);\n             bkts = newbkts;\n         }\n         iter items() -> @{key: K, val: V} {\n@@ -193,8 +187,8 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n             }\n         }\n     }\n-    let bkts = make_buckets[K, V](initial_capacity);\n-    ret hashmap[K, V](hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n+    let bkts = make_buckets(initial_capacity);\n+    ret hashmap(hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n }\n \n // Hash map constructors for basic types\n@@ -206,13 +200,13 @@ fn new_str_hash[@V]() -> hashmap[str, V] {\n fn new_int_hash[@V]() -> hashmap[int, V] {\n     fn hash_int(x: &int) -> uint { ret x as uint; }\n     fn eq_int(a: &int, b: &int) -> bool { ret a == b; }\n-    ret mk_hashmap[int, V](hash_int, eq_int);\n+    ret mk_hashmap(hash_int, eq_int);\n }\n \n fn new_uint_hash[@V]() -> hashmap[uint, V] {\n     fn hash_uint(x: &uint) -> uint { ret x; }\n     fn eq_uint(a: &uint, b: &uint) -> bool { ret a == b; }\n-    ret mk_hashmap[uint, V](hash_uint, eq_uint);\n+    ret mk_hashmap(hash_uint, eq_uint);\n }\n \n // Local Variables:"}, {"sha": "b7d145cbeead1ed545feaa608aebf7f2514fa898", "filename": "src/lib/option.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "patch": "@@ -1,37 +1,39 @@\n-\n-\n-\n // lib/option::rs\n+\n tag t[@T] { none; some(T); }\n \n type operator[@T, @U] = fn(&T) -> U ;\n \n-fn get[@T](opt: &t[T]) -> T { ret alt opt { some(x) { x } none. { fail } }; }\n+fn get[@T](opt: &t[T]) -> T {\n+    alt opt {\n+      some(x) { x }\n+      none. { fail \"option none\" }\n+    }\n+}\n \n fn map[@T, @U](f: &operator[T, U], opt: &t[T]) -> t[U] {\n-    ret alt opt { some(x) { some[U](f(x)) } none. { none[U] } };\n+    alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n fn is_none[@T](opt: &t[T]) -> bool {\n-    ret alt opt { none. { true } some(_) { false } };\n+    alt opt { none. { true } some(_) { false } }\n }\n \n-fn is_some[@T](opt: &t[T]) -> bool { ret !is_none(opt); }\n+fn is_some[@T](opt: &t[T]) -> bool { !is_none(opt) }\n \n fn from_maybe[@T](def: &T, opt: &t[T]) -> T {\n-    let f = bind util::id[T](_);\n-    ret maybe[T, T](def, f, opt);\n+    alt opt { some(x) { x } none. { def } }\n }\n \n fn maybe[@T, @U](def: &U, f: fn(&T) -> U , opt: &t[T]) -> U {\n-    ret alt opt { none. { def } some(t) { f(t) } };\n+    alt opt { none. { def } some(t) { f(t) } }\n }\n \n-\n // Can be defined in terms of the above when/if we have const bind.\n fn may[@T](f: fn(&T) , opt: &t[T]) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "fbeef737a1092d7fa1012e01157cebb6c2f743cd", "filename": "src/lib/sio.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/src%2Flib%2Fsio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1/src%2Flib%2Fsio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsio.rs?ref=5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "patch": "@@ -17,9 +17,8 @@ fn make_socket(ctx: ctx, p: port[aio::socket_event]) -> client {\n       aio::connected(client) {\n         ret { ctx: ctx, client: client, evt: p };\n       }\n+      _ { fail \"Could not connect to client\"; }\n     }\n-    log_err (\"Could not connect to client\");\n-    fail;\n }\n \n fn connect_to(ctx: ctx, ip: str, portnum: int) -> client {"}]}