{"sha": "4a01cab4b7ae190800e577bf40c97c9bcb29e901", "node_id": "C_kwDOAAsO6NoAKDRhMDFjYWI0YjdhZTE5MDgwMGU1NzdiZjQwYzk3YzliY2IyOWU5MDE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-27T13:03:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-27T13:03:57Z"}, "message": "Rollup merge of #103524 - petrochenkov:modchild4, r=cjgillot\n\nrustc_metadata: Add struct and variant constructors to module children at encoding time\n\ninstead of decoding time.\n\nContinuation of https://github.com/rust-lang/rust/pull/95899.\nThe last time it caused some ICEs from generator use, but not everything seems ok.", "tree": {"sha": "dac6f500ad8986c7548debf9867f5cc1e091f6b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dac6f500ad8986c7548debf9867f5cc1e091f6b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a01cab4b7ae190800e577bf40c97c9bcb29e901", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjWoG9CRBK7hj4Ov3rIwAADuoIAJwu568K6L0NuO88y7Qzthf5\n1jgt3HTnJK95hCSab0zXxIDQNn60kMdK+6xNCUV/W4PukoqfXMQGAuGQcQamFjHI\nGa4RMYeBFlXppZrAixXcuL9K3m2wBpRbF4a0ZTjbD+txcRwjED60wcflo9sCGHIU\nwWM3Gjn83cCG+8uX9x9VRLc0KAYxgZiQQCKRkpFQuLStIZVBeuYYFCjFgKCof/Aw\nDRiKK0A2/3ABvJw6ykIOrioeXADyL5dTE3CKiG7tkcXTcc1ebrCTGrCbKTIolp5j\n3++ZzRlPA0Vs9eHGbZZd4cI+rm7dqx8lbMGvYyoFv8O3A7XRMsd9xuUnXgL8IeQ=\n=2Qax\n-----END PGP SIGNATURE-----\n", "payload": "tree dac6f500ad8986c7548debf9867f5cc1e091f6b2\nparent 5623024cf818400f222300a48dc9b059bf440b6f\nparent 2283a5e65bf7efd63e9456f9fa336bfc69f7b277\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1666875837 +0200\ncommitter GitHub <noreply@github.com> 1666875837 +0200\n\nRollup merge of #103524 - petrochenkov:modchild4, r=cjgillot\n\nrustc_metadata: Add struct and variant constructors to module children at encoding time\n\ninstead of decoding time.\n\nContinuation of https://github.com/rust-lang/rust/pull/95899.\nThe last time it caused some ICEs from generator use, but not everything seems ok.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a01cab4b7ae190800e577bf40c97c9bcb29e901", "html_url": "https://github.com/rust-lang/rust/commit/4a01cab4b7ae190800e577bf40c97c9bcb29e901", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a01cab4b7ae190800e577bf40c97c9bcb29e901/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5623024cf818400f222300a48dc9b059bf440b6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5623024cf818400f222300a48dc9b059bf440b6f", "html_url": "https://github.com/rust-lang/rust/commit/5623024cf818400f222300a48dc9b059bf440b6f"}, {"sha": "2283a5e65bf7efd63e9456f9fa336bfc69f7b277", "url": "https://api.github.com/repos/rust-lang/rust/commits/2283a5e65bf7efd63e9456f9fa336bfc69f7b277", "html_url": "https://github.com/rust-lang/rust/commit/2283a5e65bf7efd63e9456f9fa336bfc69f7b277"}], "stats": {"total": 103, "additions": 53, "deletions": 50}, "files": [{"sha": "691e3d0f8f9026aafc0b2fde5040962be4e7e1fe", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4a01cab4b7ae190800e577bf40c97c9bcb29e901/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a01cab4b7ae190800e577bf40c97c9bcb29e901/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=4a01cab4b7ae190800e577bf40c97c9bcb29e901", "patch": "@@ -773,7 +773,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn opt_item_name(self, item_index: DefIndex) -> Option<Symbol> {\n-        self.def_key(item_index).disambiguated_data.data.get_opt_name()\n+        let def_key = self.def_key(item_index);\n+        def_key.disambiguated_data.data.get_opt_name().or_else(|| {\n+            if def_key.disambiguated_data.data == DefPathData::Ctor {\n+                let parent_index = def_key.parent.expect(\"no parent for a constructor\");\n+                self.def_key(parent_index).disambiguated_data.data.get_opt_name()\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     fn item_name(self, item_index: DefIndex) -> Symbol {\n@@ -905,7 +913,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n-                .map(|index| self.get_variant(&self.def_kind(index), index, did))\n+                .filter_map(|index| {\n+                    let kind = self.def_kind(index);\n+                    match kind {\n+                        DefKind::Ctor(..) => None,\n+                        _ => Some(self.get_variant(&kind, index, did)),\n+                    }\n+                })\n                 .collect()\n         } else {\n             std::iter::once(self.get_variant(&kind, item_id, did)).collect()\n@@ -1029,50 +1043,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                 callback(ModChild { ident, res, vis, span, macro_rules });\n \n-                // For non-re-export structs and variants add their constructors to children.\n-                // Re-export lists automatically contain constructors when necessary.\n-                match kind {\n-                    DefKind::Struct => {\n-                        if let Some((ctor_def_id, ctor_kind)) =\n-                            self.get_ctor_def_id_and_kind(child_index)\n-                        {\n-                            let ctor_res =\n-                                Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n-                            let vis = self.get_visibility(ctor_def_id.index);\n-                            callback(ModChild {\n-                                ident,\n-                                res: ctor_res,\n-                                vis,\n-                                span,\n-                                macro_rules: false,\n-                            });\n-                        }\n-                    }\n-                    DefKind::Variant => {\n-                        // Braced variants, unlike structs, generate unusable names in\n-                        // value namespace, they are reserved for possible future use.\n-                        // It's ok to use the variant's id as a ctor id since an\n-                        // error will be reported on any use of such resolution anyway.\n-                        let (ctor_def_id, ctor_kind) = self\n-                            .get_ctor_def_id_and_kind(child_index)\n-                            .unwrap_or((def_id, CtorKind::Fictive));\n-                        let ctor_res =\n-                            Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-                        let mut vis = self.get_visibility(ctor_def_id.index);\n-                        if ctor_def_id == def_id && vis.is_public() {\n-                            // For non-exhaustive variants lower the constructor visibility to\n-                            // within the crate. We only need this for fictive constructors,\n-                            // for other constructors correct visibilities\n-                            // were already encoded in metadata.\n-                            let mut attrs = self.get_item_attrs(def_id.index, sess);\n-                            if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n-                                let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n-                                vis = ty::Visibility::Restricted(crate_def_id);\n-                            }\n+                // For non-reexport variants add their fictive constructors to children.\n+                // Braced variants, unlike structs, generate unusable names in value namespace,\n+                // they are reserved for possible future use. It's ok to use the variant's id as\n+                // a ctor id since an error will be reported on any use of such resolution anyway.\n+                // Reexport lists automatically contain such constructors when necessary.\n+                if kind == DefKind::Variant && self.get_ctor_def_id_and_kind(child_index).is_none()\n+                {\n+                    let ctor_res =\n+                        Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive), def_id);\n+                    let mut vis = vis;\n+                    if vis.is_public() {\n+                        // For non-exhaustive variants lower the constructor visibility to\n+                        // within the crate. We only need this for fictive constructors,\n+                        // for other constructors correct visibilities\n+                        // were already encoded in metadata.\n+                        let mut attrs = self.get_item_attrs(def_id.index, sess);\n+                        if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n+                            vis = ty::Visibility::Restricted(self.local_def_id(CRATE_DEF_INDEX));\n                         }\n-                        callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                     }\n-                    _ => {}\n+                    callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                 }\n             }\n         }"}, {"sha": "1743bbd6a219d1c254a21125dde7055293e1bfd1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4a01cab4b7ae190800e577bf40c97c9bcb29e901/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a01cab4b7ae190800e577bf40c97c9bcb29e901/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=4a01cab4b7ae190800e577bf40c97c9bcb29e901", "patch": "@@ -1297,6 +1297,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         // Only encode named non-reexport children, reexports are encoded\n                         // separately and unnamed items are not used by name resolution.\n                         hir::ItemKind::ExternCrate(..) => continue,\n+                        hir::ItemKind::Struct(ref vdata, _) => {\n+                            yield item_id.def_id.def_id.local_def_index;\n+                            // Encode constructors which take a separate slot in value namespace.\n+                            if let Some(ctor_hir_id) = vdata.ctor_hir_id() {\n+                                yield tcx.hir().local_def_id(ctor_hir_id).local_def_index;\n+                            }\n+                        }\n                         _ if tcx.def_key(item_id.def_id.to_def_id()).get_opt_name().is_some() => {\n                             yield item_id.def_id.def_id.local_def_index;\n                         }\n@@ -1620,12 +1627,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => record_array!(self.tables.children[def_id] <-\n-                self.tcx.adt_def(def_id).variants().iter().map(|v| {\n-                    assert!(v.def_id.is_local());\n-                    v.def_id.index\n-                })\n-            ),\n+            hir::ItemKind::Enum(..) => {\n+                record_array!(self.tables.children[def_id] <- iter::from_generator(||\n+                    for variant in tcx.adt_def(def_id).variants() {\n+                        yield variant.def_id.index;\n+                        // Encode constructors which take a separate slot in value namespace.\n+                        if let Some(ctor_def_id) = variant.ctor_def_id {\n+                            yield ctor_def_id.index;\n+                        }\n+                    }\n+                ))\n+            }\n             hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                 record_array!(self.tables.children[def_id] <-\n                     self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {"}]}