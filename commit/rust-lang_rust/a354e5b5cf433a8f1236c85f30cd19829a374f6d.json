{"sha": "a354e5b5cf433a8f1236c85f30cd19829a374f6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNTRlNWI1Y2Y0MzNhOGYxMjM2Yzg1ZjMwY2QxOTgyOWEzNzRmNmQ=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-03T03:04:52Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-03T22:56:58Z"}, "message": "SSR: Update tests so that all paths in patterns can be resolved", "tree": {"sha": "f9e6f2a0c8dc68ac31a55df1a67b8e71b12e5374", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9e6f2a0c8dc68ac31a55df1a67b8e71b12e5374"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a354e5b5cf433a8f1236c85f30cd19829a374f6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a354e5b5cf433a8f1236c85f30cd19829a374f6d", "html_url": "https://github.com/rust-lang/rust/commit/a354e5b5cf433a8f1236c85f30cd19829a374f6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a354e5b5cf433a8f1236c85f30cd19829a374f6d/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69051d2f9dcf008124918ef34d2f11221a6a20f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/69051d2f9dcf008124918ef34d2f11221a6a20f0", "html_url": "https://github.com/rust-lang/rust/commit/69051d2f9dcf008124918ef34d2f11221a6a20f0"}], "stats": {"total": 164, "additions": 97, "deletions": 67}, "files": [{"sha": "f20ae2cdf9a0c2eca5930bc9af19e02111e904a7", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 97, "deletions": 67, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/a354e5b5cf433a8f1236c85f30cd19829a374f6d/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a354e5b5cf433a8f1236c85f30cd19829a374f6d/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=a354e5b5cf433a8f1236c85f30cd19829a374f6d", "patch": "@@ -148,62 +148,62 @@ fn assert_match_failure_reason(pattern: &str, code: &str, snippet: &str, expecte\n fn ssr_function_to_method() {\n     assert_ssr_transform(\n         \"my_function($a, $b) ==>> ($a).my_method($b)\",\n-        \"loop { my_function( other_func(x, y), z + w) }\",\n-        \"loop { (other_func(x, y)).my_method(z + w) }\",\n+        \"fn my_function() {} fn main() { loop { my_function( other_func(x, y), z + w) } }\",\n+        \"fn my_function() {} fn main() { loop { (other_func(x, y)).my_method(z + w) } }\",\n     )\n }\n \n #[test]\n fn ssr_nested_function() {\n     assert_ssr_transform(\n         \"foo($a, $b, $c) ==>> bar($c, baz($a, $b))\",\n-        \"fn main { foo  (x + value.method(b), x+y-z, true && false) }\",\n-        \"fn main { bar(true && false, baz(x + value.method(b), x+y-z)) }\",\n+        \"fn foo() {} fn main { foo  (x + value.method(b), x+y-z, true && false) }\",\n+        \"fn foo() {} fn main { bar(true && false, baz(x + value.method(b), x+y-z)) }\",\n     )\n }\n \n #[test]\n fn ssr_expected_spacing() {\n     assert_ssr_transform(\n         \"foo($x) + bar() ==>> bar($x)\",\n-        \"fn main() { foo(5) + bar() }\",\n-        \"fn main() { bar(5) }\",\n+        \"fn foo() {} fn bar() {} fn main() { foo(5) + bar() }\",\n+        \"fn foo() {} fn bar() {} fn main() { bar(5) }\",\n     );\n }\n \n #[test]\n fn ssr_with_extra_space() {\n     assert_ssr_transform(\n         \"foo($x  ) +    bar() ==>> bar($x)\",\n-        \"fn main() { foo(  5 )  +bar(   ) }\",\n-        \"fn main() { bar(5) }\",\n+        \"fn foo() {} fn bar() {} fn main() { foo(  5 )  +bar(   ) }\",\n+        \"fn foo() {} fn bar() {} fn main() { bar(5) }\",\n     );\n }\n \n #[test]\n fn ssr_keeps_nested_comment() {\n     assert_ssr_transform(\n         \"foo($x) ==>> bar($x)\",\n-        \"fn main() { foo(other(5 /* using 5 */)) }\",\n-        \"fn main() { bar(other(5 /* using 5 */)) }\",\n+        \"fn foo() {} fn main() { foo(other(5 /* using 5 */)) }\",\n+        \"fn foo() {} fn main() { bar(other(5 /* using 5 */)) }\",\n     )\n }\n \n #[test]\n fn ssr_keeps_comment() {\n     assert_ssr_transform(\n         \"foo($x) ==>> bar($x)\",\n-        \"fn main() { foo(5 /* using 5 */) }\",\n-        \"fn main() { bar(5)/* using 5 */ }\",\n+        \"fn foo() {} fn main() { foo(5 /* using 5 */) }\",\n+        \"fn foo() {} fn main() { bar(5)/* using 5 */ }\",\n     )\n }\n \n #[test]\n fn ssr_struct_lit() {\n     assert_ssr_transform(\n         \"foo{a: $a, b: $b} ==>> foo::new($a, $b)\",\n-        \"fn main() { foo{b:2, a:1} }\",\n-        \"fn main() { foo::new(1, 2) }\",\n+        \"fn foo() {} fn main() { foo{b:2, a:1} }\",\n+        \"fn foo() {} fn main() { foo::new(1, 2) }\",\n     )\n }\n \n@@ -225,16 +225,18 @@ fn match_fn_definition() {\n \n #[test]\n fn match_struct_definition() {\n-    assert_matches(\n-        \"struct $n {$f: Option<String>}\",\n-        \"struct Bar {} struct Foo {name: Option<String>}\",\n-        &[\"struct Foo {name: Option<String>}\"],\n-    );\n+    let code = r#\"\n+        struct Option<T> {}\n+        struct Bar {}\n+        struct Foo {name: Option<String>}\"#;\n+    assert_matches(\"struct $n {$f: Option<String>}\", code, &[\"struct Foo {name: Option<String>}\"]);\n }\n \n #[test]\n fn match_expr() {\n-    let code = \"fn f() -> i32 {foo(40 + 2, 42)}\";\n+    let code = r#\"\n+        fn foo() {}\n+        fn f() -> i32 {foo(40 + 2, 42)}\"#;\n     assert_matches(\"foo($a, $b)\", code, &[\"foo(40 + 2, 42)\"]);\n     assert_no_match(\"foo($a, $b, $c)\", code);\n     assert_no_match(\"foo($a)\", code);\n@@ -263,7 +265,9 @@ fn match_nested_method_calls_with_macro_call() {\n \n #[test]\n fn match_complex_expr() {\n-    let code = \"fn f() -> i32 {foo(bar(40, 2), 42)}\";\n+    let code = r#\"\n+        fn foo() {} fn bar() {}\n+        fn f() -> i32 {foo(bar(40, 2), 42)}\"#;\n     assert_matches(\"foo($a, $b)\", code, &[\"foo(bar(40, 2), 42)\"]);\n     assert_no_match(\"foo($a, $b, $c)\", code);\n     assert_no_match(\"foo($a)\", code);\n@@ -274,53 +278,62 @@ fn match_complex_expr() {\n #[test]\n fn match_with_trailing_commas() {\n     // Code has comma, pattern doesn't.\n-    assert_matches(\"foo($a, $b)\", \"fn f() {foo(1, 2,);}\", &[\"foo(1, 2,)\"]);\n-    assert_matches(\"Foo{$a, $b}\", \"fn f() {Foo{1, 2,};}\", &[\"Foo{1, 2,}\"]);\n+    assert_matches(\"foo($a, $b)\", \"fn foo() {} fn f() {foo(1, 2,);}\", &[\"foo(1, 2,)\"]);\n+    assert_matches(\"Foo{$a, $b}\", \"struct Foo {} fn f() {Foo{1, 2,};}\", &[\"Foo{1, 2,}\"]);\n \n     // Pattern has comma, code doesn't.\n-    assert_matches(\"foo($a, $b,)\", \"fn f() {foo(1, 2);}\", &[\"foo(1, 2)\"]);\n-    assert_matches(\"Foo{$a, $b,}\", \"fn f() {Foo{1, 2};}\", &[\"Foo{1, 2}\"]);\n+    assert_matches(\"foo($a, $b,)\", \"fn foo() {} fn f() {foo(1, 2);}\", &[\"foo(1, 2)\"]);\n+    assert_matches(\"Foo{$a, $b,}\", \"struct Foo {} fn f() {Foo{1, 2};}\", &[\"Foo{1, 2}\"]);\n }\n \n #[test]\n fn match_type() {\n     assert_matches(\"i32\", \"fn f() -> i32 {1  +  2}\", &[\"i32\"]);\n-    assert_matches(\"Option<$a>\", \"fn f() -> Option<i32> {42}\", &[\"Option<i32>\"]);\n-    assert_no_match(\"Option<$a>\", \"fn f() -> Result<i32, ()> {42}\");\n+    assert_matches(\n+        \"Option<$a>\",\n+        \"struct Option<T> {} fn f() -> Option<i32> {42}\",\n+        &[\"Option<i32>\"],\n+    );\n+    assert_no_match(\n+        \"Option<$a>\",\n+        \"struct Option<T> {} struct Result<T, E> {} fn f() -> Result<i32, ()> {42}\",\n+    );\n }\n \n #[test]\n fn match_struct_instantiation() {\n-    assert_matches(\n-        \"Foo {bar: 1, baz: 2}\",\n-        \"fn f() {Foo {bar: 1, baz: 2}}\",\n-        &[\"Foo {bar: 1, baz: 2}\"],\n-    );\n+    let code = r#\"\n+        struct Foo {bar: i32, baz: i32}\n+        fn f() {Foo {bar: 1, baz: 2}}\"#;\n+    assert_matches(\"Foo {bar: 1, baz: 2}\", code, &[\"Foo {bar: 1, baz: 2}\"]);\n     // Now with placeholders for all parts of the struct.\n-    assert_matches(\n-        \"Foo {$a: $b, $c: $d}\",\n-        \"fn f() {Foo {bar: 1, baz: 2}}\",\n-        &[\"Foo {bar: 1, baz: 2}\"],\n-    );\n-    assert_matches(\"Foo {}\", \"fn f() {Foo {}}\", &[\"Foo {}\"]);\n+    assert_matches(\"Foo {$a: $b, $c: $d}\", code, &[\"Foo {bar: 1, baz: 2}\"]);\n+    assert_matches(\"Foo {}\", \"struct Foo {} fn f() {Foo {}}\", &[\"Foo {}\"]);\n }\n \n #[test]\n fn match_path() {\n-    assert_matches(\"foo::bar\", \"fn f() {foo::bar(42)}\", &[\"foo::bar\"]);\n-    assert_matches(\"$a::bar\", \"fn f() {foo::bar(42)}\", &[\"foo::bar\"]);\n-    assert_matches(\"foo::$b\", \"fn f() {foo::bar(42)}\", &[\"foo::bar\"]);\n+    let code = r#\"\n+        mod foo {\n+            fn bar() {}\n+        }\n+        fn f() {foo::bar(42)}\"#;\n+    assert_matches(\"foo::bar\", code, &[\"foo::bar\"]);\n+    assert_matches(\"$a::bar\", code, &[\"foo::bar\"]);\n+    assert_matches(\"foo::$b\", code, &[\"foo::bar\"]);\n }\n \n #[test]\n fn match_pattern() {\n-    assert_matches(\"Some($a)\", \"fn f() {if let Some(x) = foo() {}}\", &[\"Some(x)\"]);\n+    assert_matches(\"Some($a)\", \"struct Some(); fn f() {if let Some(x) = foo() {}}\", &[\"Some(x)\"]);\n }\n \n #[test]\n fn literal_constraint() {\n     mark::check!(literal_constraint);\n     let code = r#\"\n+        enum Option<T> { Some(T), None }\n+        use Option::Some;\n         fn f1() {\n             let x1 = Some(42);\n             let x2 = Some(\"foo\");\n@@ -337,24 +350,36 @@ fn literal_constraint() {\n fn match_reordered_struct_instantiation() {\n     assert_matches(\n         \"Foo {aa: 1, b: 2, ccc: 3}\",\n-        \"fn f() {Foo {b: 2, ccc: 3, aa: 1}}\",\n+        \"struct Foo {} fn f() {Foo {b: 2, ccc: 3, aa: 1}}\",\n         &[\"Foo {b: 2, ccc: 3, aa: 1}\"],\n     );\n-    assert_no_match(\"Foo {a: 1}\", \"fn f() {Foo {b: 1}}\");\n-    assert_no_match(\"Foo {a: 1}\", \"fn f() {Foo {a: 2}}\");\n-    assert_no_match(\"Foo {a: 1, b: 2}\", \"fn f() {Foo {a: 1}}\");\n-    assert_no_match(\"Foo {a: 1, b: 2}\", \"fn f() {Foo {b: 2}}\");\n-    assert_no_match(\"Foo {a: 1, }\", \"fn f() {Foo {a: 1, b: 2}}\");\n-    assert_no_match(\"Foo {a: 1, z: 9}\", \"fn f() {Foo {a: 1}}\");\n+    assert_no_match(\"Foo {a: 1}\", \"struct Foo {} fn f() {Foo {b: 1}}\");\n+    assert_no_match(\"Foo {a: 1}\", \"struct Foo {} fn f() {Foo {a: 2}}\");\n+    assert_no_match(\"Foo {a: 1, b: 2}\", \"struct Foo {} fn f() {Foo {a: 1}}\");\n+    assert_no_match(\"Foo {a: 1, b: 2}\", \"struct Foo {} fn f() {Foo {b: 2}}\");\n+    assert_no_match(\"Foo {a: 1, }\", \"struct Foo {} fn f() {Foo {a: 1, b: 2}}\");\n+    assert_no_match(\"Foo {a: 1, z: 9}\", \"struct Foo {} fn f() {Foo {a: 1}}\");\n }\n \n #[test]\n fn match_macro_invocation() {\n-    assert_matches(\"foo!($a)\", \"fn() {foo(foo!(foo()))}\", &[\"foo!(foo())\"]);\n-    assert_matches(\"foo!(41, $a, 43)\", \"fn() {foo!(41, 42, 43)}\", &[\"foo!(41, 42, 43)\"]);\n-    assert_no_match(\"foo!(50, $a, 43)\", \"fn() {foo!(41, 42, 43}\");\n-    assert_no_match(\"foo!(41, $a, 50)\", \"fn() {foo!(41, 42, 43}\");\n-    assert_matches(\"foo!($a())\", \"fn() {foo!(bar())}\", &[\"foo!(bar())\"]);\n+    assert_matches(\n+        \"foo!($a)\",\n+        \"macro_rules! foo {() => {}} fn() {foo(foo!(foo()))}\",\n+        &[\"foo!(foo())\"],\n+    );\n+    assert_matches(\n+        \"foo!(41, $a, 43)\",\n+        \"macro_rules! foo {() => {}} fn() {foo!(41, 42, 43)}\",\n+        &[\"foo!(41, 42, 43)\"],\n+    );\n+    assert_no_match(\"foo!(50, $a, 43)\", \"macro_rules! foo {() => {}} fn() {foo!(41, 42, 43}\");\n+    assert_no_match(\"foo!(41, $a, 50)\", \"macro_rules! foo {() => {}} fn() {foo!(41, 42, 43}\");\n+    assert_matches(\n+        \"foo!($a())\",\n+        \"macro_rules! foo {() => {}} fn() {foo!(bar())}\",\n+        &[\"foo!(bar())\"],\n+    );\n }\n \n // When matching within a macro expansion, we only allow matches of nodes that originated from\n@@ -389,56 +414,60 @@ fn no_match_split_expression() {\n \n #[test]\n fn replace_function_call() {\n-    assert_ssr_transform(\"foo() ==>> bar()\", \"fn f1() {foo(); foo();}\", \"fn f1() {bar(); bar();}\");\n+    assert_ssr_transform(\n+        \"foo() ==>> bar()\",\n+        \"fn foo() {} fn f1() {foo(); foo();}\",\n+        \"fn foo() {} fn f1() {bar(); bar();}\",\n+    );\n }\n \n #[test]\n fn replace_function_call_with_placeholders() {\n     assert_ssr_transform(\n         \"foo($a, $b) ==>> bar($b, $a)\",\n-        \"fn f1() {foo(5, 42)}\",\n-        \"fn f1() {bar(42, 5)}\",\n+        \"fn foo() {} fn f1() {foo(5, 42)}\",\n+        \"fn foo() {} fn f1() {bar(42, 5)}\",\n     );\n }\n \n #[test]\n fn replace_nested_function_calls() {\n     assert_ssr_transform(\n         \"foo($a) ==>> bar($a)\",\n-        \"fn f1() {foo(foo(42))}\",\n-        \"fn f1() {bar(bar(42))}\",\n+        \"fn foo() {} fn f1() {foo(foo(42))}\",\n+        \"fn foo() {} fn f1() {bar(bar(42))}\",\n     );\n }\n \n #[test]\n fn replace_type() {\n     assert_ssr_transform(\n         \"Result<(), $a> ==>> Option<$a>\",\n-        \"fn f1() -> Result<(), Vec<Error>> {foo()}\",\n-        \"fn f1() -> Option<Vec<Error>> {foo()}\",\n+        \"struct Result<T, E> {} fn f1() -> Result<(), Vec<Error>> {foo()}\",\n+        \"struct Result<T, E> {} fn f1() -> Option<Vec<Error>> {foo()}\",\n     );\n }\n \n #[test]\n fn replace_struct_init() {\n     assert_ssr_transform(\n         \"Foo {a: $a, b: $b} ==>> Foo::new($a, $b)\",\n-        \"fn f1() {Foo{b: 1, a: 2}}\",\n-        \"fn f1() {Foo::new(2, 1)}\",\n+        \"struct Foo {} fn f1() {Foo{b: 1, a: 2}}\",\n+        \"struct Foo {} fn f1() {Foo::new(2, 1)}\",\n     );\n }\n \n #[test]\n fn replace_macro_invocations() {\n     assert_ssr_transform(\n         \"try!($a) ==>> $a?\",\n-        \"fn f1() -> Result<(), E> {bar(try!(foo()));}\",\n-        \"fn f1() -> Result<(), E> {bar(foo()?);}\",\n+        \"macro_rules! try {() => {}} fn f1() -> Result<(), E> {bar(try!(foo()));}\",\n+        \"macro_rules! try {() => {}} fn f1() -> Result<(), E> {bar(foo()?);}\",\n     );\n     assert_ssr_transform(\n         \"foo!($a($b)) ==>> foo($b, $a)\",\n-        \"fn f1() {foo!(abc(def() + 2));}\",\n-        \"fn f1() {foo(def() + 2, abc);}\",\n+        \"macro_rules! foo {() => {}} fn f1() {foo!(abc(def() + 2));}\",\n+        \"macro_rules! foo {() => {}} fn f1() {foo(def() + 2, abc);}\",\n     );\n }\n \n@@ -527,6 +556,7 @@ fn preserves_whitespace_within_macro_expansion() {\n #[test]\n fn match_failure_reasons() {\n     let code = r#\"\n+        fn bar() {}\n         macro_rules! foo {\n             ($a:expr) => {\n                 1 + $a + 2"}]}