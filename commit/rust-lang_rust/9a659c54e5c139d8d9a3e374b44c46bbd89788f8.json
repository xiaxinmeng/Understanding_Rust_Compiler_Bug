{"sha": "9a659c54e5c139d8d9a3e374b44c46bbd89788f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNjU5YzU0ZTVjMTM5ZDhkOWEzZTM3NGI0NGM0NmJiZDg5Nzg4Zjg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-04T00:16:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-04T00:16:56Z"}, "message": "Rollup merge of #73845 - CAD97:weak-as-unsized-ptr, r=RalfJung\n\nUse &raw in A|Rc::as_ptr\n\nThis PR uses `&raw` for offsetting `*mut [A]RcInner<T> -> *mut T`.\n\nAdditionally, this updates the implementation of `Weak::as_ptr` to support unsized `T`, though it does not yet relax the bounds of `Weak::as_ptr`/`into_raw`/`from_raw` to accept unsized `T`.", "tree": {"sha": "62d9c97cad2622a9354e8c9ccf22492c2d089f1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62d9c97cad2622a9354e8c9ccf22492c2d089f1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a659c54e5c139d8d9a3e374b44c46bbd89788f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/8p4CRBK7hj4Ov3rIwAAdHIIAJ5pNJyB+J0hnlDJrvj0TWta\nd1C5IzUEuzJXQRKtoV5QE/LYoHqAuDNGLIwtwMG9m9ApciZiC+YFsK5O2n4PvA6O\n0wrgCXN5/E1sHekZKBKD0PcDcxSeJDo+C/iQT8TbYeT91/mNtv+drevaSC6XRBcf\niVVZBTx2DXW8+ylzokdaSN/l8cW/wsD8K4ctazRRTOvMK0p0ZW4irHMDQS/FWne3\nkWMo1jOqLFlWn9ia6HZdX+9gEPjk4GoXki501QnZ5xtFCn8v4dPysFAeGD8pSKkb\nULxQZpGw0yHJ/jQtPUj+e6SZhKaghWB1Ldc70R0jSzcwXWPbp3SuiiK6D0SUEVc=\n=9kSq\n-----END PGP SIGNATURE-----\n", "payload": "tree 62d9c97cad2622a9354e8c9ccf22492c2d089f1c\nparent 50dcefca7813a2985c0f1c1863efbe5ce7958815\nparent 1b5ac57bfd4b0cca3bcdd0fa75c0f0e044ebf01e\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593821816 -0700\ncommitter GitHub <noreply@github.com> 1593821816 -0700\n\nRollup merge of #73845 - CAD97:weak-as-unsized-ptr, r=RalfJung\n\nUse &raw in A|Rc::as_ptr\n\nThis PR uses `&raw` for offsetting `*mut [A]RcInner<T> -> *mut T`.\n\nAdditionally, this updates the implementation of `Weak::as_ptr` to support unsized `T`, though it does not yet relax the bounds of `Weak::as_ptr`/`into_raw`/`from_raw` to accept unsized `T`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a659c54e5c139d8d9a3e374b44c46bbd89788f8", "html_url": "https://github.com/rust-lang/rust/commit/9a659c54e5c139d8d9a3e374b44c46bbd89788f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a659c54e5c139d8d9a3e374b44c46bbd89788f8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50dcefca7813a2985c0f1c1863efbe5ce7958815", "url": "https://api.github.com/repos/rust-lang/rust/commits/50dcefca7813a2985c0f1c1863efbe5ce7958815", "html_url": "https://github.com/rust-lang/rust/commit/50dcefca7813a2985c0f1c1863efbe5ce7958815"}, {"sha": "1b5ac57bfd4b0cca3bcdd0fa75c0f0e044ebf01e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b5ac57bfd4b0cca3bcdd0fa75c0f0e044ebf01e", "html_url": "https://github.com/rust-lang/rust/commit/1b5ac57bfd4b0cca3bcdd0fa75c0f0e044ebf01e"}], "stats": {"total": 103, "additions": 59, "deletions": 44}, "files": [{"sha": "79bfd57a00fa9888ca8d6efec923677dced71a54", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a659c54e5c139d8d9a3e374b44c46bbd89788f8/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a659c54e5c139d8d9a3e374b44c46bbd89788f8/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9a659c54e5c139d8d9a3e374b44c46bbd89788f8", "patch": "@@ -100,6 +100,7 @@\n #![feature(fundamental)]\n #![feature(internal_uninit_const)]\n #![feature(lang_items)]\n+#![feature(layout_for_ptr)]\n #![feature(libc)]\n #![feature(negative_impls)]\n #![feature(new_uninit)]\n@@ -109,6 +110,7 @@\n #![feature(pattern)]\n #![feature(ptr_internals)]\n #![feature(ptr_offset_from)]\n+#![feature(raw_ref_op)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n #![feature(min_specialization)]"}, {"sha": "fccdfa0dca92af8e574680a78fac64c43506dba2", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9a659c54e5c139d8d9a3e374b44c46bbd89788f8/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a659c54e5c139d8d9a3e374b44c46bbd89788f8/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=9a659c54e5c139d8d9a3e374b44c46bbd89788f8", "patch": "@@ -245,7 +245,7 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::iter;\n use core::marker::{self, PhantomData, Unpin, Unsize};\n-use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n+use core::mem::{self, align_of_val_raw, forget, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -591,17 +591,11 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n-        let fake_ptr = ptr as *mut T;\n \n-        // SAFETY: This cannot go through Deref::deref.\n-        // Instead, we manually offset the pointer rather than manifesting a reference.\n-        // This is so that the returned pointer retains the same provenance as our pointer.\n-        // This is required so that e.g. `get_mut` can write through the pointer\n-        // after the Rc is recovered through `from_raw`.\n-        unsafe {\n-            let offset = data_offset(&(*ptr).value);\n-            set_data_ptr(fake_ptr, (ptr as *mut u8).offset(offset))\n-        }\n+        // SAFETY: This cannot go through Deref::deref or Rc::inner because\n+        // this is required to retain raw/mut provenance such that e.g. `get_mut` can\n+        // write through the pointer after the Rc is recovered through `from_raw`.\n+        unsafe { &raw const (*ptr).value }\n     }\n \n     /// Constructs an `Rc<T>` from a raw pointer.\n@@ -1647,6 +1641,7 @@ pub struct Weak<T: ?Sized> {\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n     // to allocate space on the heap.  That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n+    // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<RcBox<T>>,\n }\n \n@@ -1708,9 +1703,18 @@ impl<T> Weak<T> {\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n-        let offset = data_offset_sized::<T>();\n-        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n-        ptr as *const T\n+        let ptr: *mut RcBox<T> = NonNull::as_ptr(self.ptr);\n+\n+        // SAFETY: we must offset the pointer manually, and said pointer may be\n+        // a dangling weak (usize::MAX) if T is sized. data_offset is safe to call,\n+        // because we know that a pointer to unsized T was derived from a real\n+        // unsized T, as dangling weaks are only created for sized T. wrapping_offset\n+        // is used so that we can use the same code path for the non-dangling\n+        // unsized case and the potentially dangling sized case.\n+        unsafe {\n+            let offset = data_offset(ptr as *mut T);\n+            set_data_ptr(ptr as *mut T, (ptr as *mut u8).wrapping_offset(offset))\n+        }\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -2113,19 +2117,22 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> {}\n \n+/// Get the offset within an `ArcInner` for\n+/// a payload of type described by a pointer.\n+///\n+/// # Safety\n+///\n+/// This has the same safety requirements as `align_of_val_raw`. In effect:\n+///\n+/// - This function is safe for any argument if `T` is sized, and\n+/// - if `T` is unsized, the pointer must have appropriate pointer metadata\n+///   aquired from the real instance that you are getting this offset for.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `RcBox`.\n     // Because it is ?Sized, it will always be the last field in memory.\n     // Note: This is a detail of the current implementation of the compiler,\n     // and is not a guaranteed language detail. Do not rely on it outside of std.\n-    unsafe { data_offset_align(align_of_val(&*ptr)) }\n-}\n-\n-/// Computes the offset of the data field within `RcBox`.\n-///\n-/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n-fn data_offset_sized<T>() -> isize {\n-    data_offset_align(align_of::<T>())\n+    unsafe { data_offset_align(align_of_val_raw(ptr)) }\n }\n \n #[inline]"}, {"sha": "ac3ce2255c89b6003f3a6f0fc21f1edb5d4e2e9a", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9a659c54e5c139d8d9a3e374b44c46bbd89788f8/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a659c54e5c139d8d9a3e374b44c46bbd89788f8/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=9a659c54e5c139d8d9a3e374b44c46bbd89788f8", "patch": "@@ -16,7 +16,7 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::iter;\n use core::marker::{PhantomData, Unpin, Unsize};\n-use core::mem::{self, align_of, align_of_val, size_of_val};\n+use core::mem::{self, align_of_val, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -267,6 +267,7 @@ pub struct Weak<T: ?Sized> {\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n     // to allocate space on the heap.  That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n+    // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<ArcInner<T>>,\n }\n \n@@ -590,17 +591,11 @@ impl<T: ?Sized> Arc<T> {\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n-        let fake_ptr = ptr as *mut T;\n \n-        // SAFETY: This cannot go through Deref::deref.\n-        // Instead, we manually offset the pointer rather than manifesting a reference.\n-        // This is so that the returned pointer retains the same provenance as our pointer.\n-        // This is required so that e.g. `get_mut` can write through the pointer\n-        // after the Arc is recovered through `from_raw`.\n-        unsafe {\n-            let offset = data_offset(&(*ptr).data);\n-            set_data_ptr(fake_ptr, (ptr as *mut u8).offset(offset))\n-        }\n+        // SAFETY: This cannot go through Deref::deref or RcBoxPtr::inner because\n+        // this is required to retain raw/mut provenance such that e.g. `get_mut` can\n+        // write through the pointer after the Rc is recovered through `from_raw`.\n+        unsafe { &raw const (*ptr).data }\n     }\n \n     /// Constructs an `Arc<T>` from a raw pointer.\n@@ -1476,9 +1471,18 @@ impl<T> Weak<T> {\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n-        let offset = data_offset_sized::<T>();\n-        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n-        ptr as *const T\n+        let ptr: *mut ArcInner<T> = NonNull::as_ptr(self.ptr);\n+\n+        // SAFETY: we must offset the pointer manually, and said pointer may be\n+        // a dangling weak (usize::MAX) if T is sized. data_offset is safe to call,\n+        // because we know that a pointer to unsized T was derived from a real\n+        // unsized T, as dangling weaks are only created for sized T. wrapping_offset\n+        // is used so that we can use the same code path for the non-dangling\n+        // unsized case and the potentially dangling sized case.\n+        unsafe {\n+            let offset = data_offset(ptr as *mut T);\n+            set_data_ptr(ptr as *mut T, (ptr as *mut u8).wrapping_offset(offset))\n+        }\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -2270,7 +2274,16 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> {}\n \n-/// Computes the offset of the data field within `ArcInner`.\n+/// Get the offset within an `ArcInner` for\n+/// a payload of type described by a pointer.\n+///\n+/// # Safety\n+///\n+/// This has the same safety requirements as `align_of_val_raw`. In effect:\n+///\n+/// - This function is safe for any argument if `T` is sized, and\n+/// - if `T` is unsized, the pointer must have appropriate pointer metadata\n+///   aquired from the real instance that you are getting this offset for.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `ArcInner`.\n     // Because it is `?Sized`, it will always be the last field in memory.\n@@ -2279,13 +2292,6 @@ unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     unsafe { data_offset_align(align_of_val(&*ptr)) }\n }\n \n-/// Computes the offset of the data field within `ArcInner`.\n-///\n-/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n-fn data_offset_sized<T>() -> isize {\n-    data_offset_align(align_of::<T>())\n-}\n-\n #[inline]\n fn data_offset_align(align: usize) -> isize {\n     let layout = Layout::new::<ArcInner<()>>();"}]}