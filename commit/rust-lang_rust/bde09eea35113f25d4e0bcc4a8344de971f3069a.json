{"sha": "bde09eea35113f25d4e0bcc4a8344de971f3069a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZTA5ZWVhMzUxMTNmMjVkNGUwYmNjNGE4MzQ0ZGU5NzFmMzA2OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-16T17:02:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-16T17:02:11Z"}, "message": "Auto merge of #23347 - aturon:stab-misc, r=alexcrichton\n\nThis commit deprecates the `count`, `range` and `range_step` functions\r\nin `iter`, in favor of range notation. To recover all existing\r\nfunctionality, a new `step_by` adapter is provided directly on `ops::Range`\r\nand `ops::RangeFrom`.\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton", "tree": {"sha": "91bf41d6d8d7630d193f517d0f22c9fe85e4f967", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91bf41d6d8d7630d193f517d0f22c9fe85e4f967"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bde09eea35113f25d4e0bcc4a8344de971f3069a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bde09eea35113f25d4e0bcc4a8344de971f3069a", "html_url": "https://github.com/rust-lang/rust/commit/bde09eea35113f25d4e0bcc4a8344de971f3069a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bde09eea35113f25d4e0bcc4a8344de971f3069a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc789193e11ab2d864db3186aa1961283b3d4cdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc789193e11ab2d864db3186aa1961283b3d4cdc", "html_url": "https://github.com/rust-lang/rust/commit/cc789193e11ab2d864db3186aa1961283b3d4cdc"}, {"sha": "1d5983aded687149239e8943debd51abdce5d27b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5983aded687149239e8943debd51abdce5d27b", "html_url": "https://github.com/rust-lang/rust/commit/1d5983aded687149239e8943debd51abdce5d27b"}], "stats": {"total": 227, "additions": 134, "deletions": 93}, "files": [{"sha": "e90186d63b4dc050091dd473f9a6bf8bf03cddcc", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -33,6 +33,7 @@\n #![feature(unsafe_destructor)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag)]\n+#![feature(step_by)]\n #![cfg_attr(test, feature(rand, rustc_private, test))]\n #![cfg_attr(test, allow(deprecated))] // rand\n "}, {"sha": "e1c27095b2f43dc0a1194ddb96528a790ebbd527", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -92,7 +92,7 @@ use core::clone::Clone;\n use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n use core::iter::{Iterator, IteratorExt};\n-use core::iter::{range_step, MultiplicativeIterator};\n+use core::iter::MultiplicativeIterator;\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n@@ -1387,7 +1387,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     // We could hardcode the sorting comparisons here, and we could\n     // manipulate/step the pointers themselves, rather than repeatedly\n     // .offset-ing.\n-    for start in range_step(0, len, insertion) {\n+    for start in (0.. len).step_by(insertion) {\n         // start <= i < len;\n         for i in start..cmp::min(start + insertion, len) {\n             // j satisfies: start <= j <= i;\n@@ -1427,7 +1427,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n         // a time, placing the result in `buf_tmp`.\n \n         // 0 <= start <= len.\n-        for start in range_step(0, len, 2 * width) {\n+        for start in (0..len).step_by(2 * width) {\n             // manipulate pointers directly for speed (rather than\n             // using a `for` loop with `range` and `.offset` inside\n             // that loop)."}, {"sha": "8ebedb66851d5fd50cfdaeb94f77a4d267031382", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 113, "deletions": 69, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -65,7 +65,7 @@ use default::Default;\n use marker;\n use mem;\n use num::{ToPrimitive, Int};\n-use ops::{Add, Deref, FnMut};\n+use ops::{Add, Deref, FnMut, RangeFrom};\n use option::Option;\n use option::Option::{Some, None};\n use marker::Sized;\n@@ -2366,34 +2366,101 @@ impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     }\n }\n \n+/// An adapter for stepping range iterators by a custom amount.\n+///\n+/// The resulting iterator handles overflow by stopping. The `A`\n+/// parameter is the type being iterated over, while `R` is the range\n+/// type (usually one of `std::ops::{Range, RangeFrom}`.\n+#[derive(Clone)]\n+#[unstable(feature = \"step_by\", reason = \"recent addition\")]\n+pub struct StepBy<A, R> {\n+    step_by: A,\n+    range: R,\n+}\n+\n+impl<A: Add> RangeFrom<A> {\n+    /// Creates an iterator starting at the same point, but stepping by\n+    /// the given amount at each iteration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// for i in (0u8..).step_by(2) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints all even `u8` values.\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n+impl<A: Int> ::ops::Range<A> {\n+    /// Creates an iterator with the same range, but stepping by the\n+    /// given amount at each iteration.\n+    ///\n+    /// The resulting iterator handles overflow by stopping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(step_by, core)]\n+    /// for i in (0..10).step_by(2) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// 0\n+    /// 2\n+    /// 4\n+    /// 6\n+    /// 8\n+    /// ```\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n-#[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"may be renamed or replaced by range notation adapters\")]\n-pub struct Counter<A> {\n-    /// The current state the counter is at (next value to be yielded)\n-    state: A,\n-    /// The amount that this iterator is stepping by\n-    step: A,\n-}\n+#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation and step_by\")]\n+pub type Counter<A> = StepBy<A, RangeFrom<A>>;\n \n-/// Creates a new counter with the specified start/step\n+/// Deprecated: use `(start..).step_by(step)` instead.\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"may be renamed or replaced by range notation adapters\")]\n+#[deprecated(since = \"1.0.0-beta\", reason = \"use (start..).step_by(step) instead\")]\n+#[allow(deprecated)]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n-    Counter{state: start, step: step}\n+    StepBy {\n+        range: RangeFrom { start: start },\n+        step_by: step,\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n+impl<A: Add<Output=A> + Clone> Iterator for StepBy<A, RangeFrom<A>> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let result = self.state.clone();\n-        self.state = self.state.clone() + self.step.clone();\n+        let result = self.range.start.clone();\n+        self.range.start = result.clone() + self.step_by.clone();\n         Some(result)\n     }\n \n@@ -2404,31 +2471,22 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n }\n \n /// An iterator over the range [start, stop)\n+#[allow(deprecated)]\n #[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n+#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n     one: A,\n }\n \n-/// Returns an iterator over the given range [start, stop) (that is, starting\n-/// at start (inclusive), and ending at stop (exclusive)).\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let array = [0, 1, 2, 3, 4];\n-///\n-/// for i in range(0, 5) {\n-///     println!(\"{}\", i);\n-///     assert_eq!(i,  array[i]);\n-/// }\n-/// ```\n+/// Deprecated: use `(start..stop)` instead.\n #[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by range notation\")]\n+#[unstable(feature = \"core\", reason = \"will be replaced by range notation\")]\n+#[deprecated(since = \"1.0.0-beta\", reason = \"use (start..stop) instead\")]\n+#[allow(deprecated)]\n pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n     Range {\n         state: start,\n@@ -2440,6 +2498,8 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n // FIXME: #10414: Unfortunate type bound\n #[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n+#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n+#[allow(deprecated)]\n impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     type Item = A;\n \n@@ -2491,6 +2551,8 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n /// the direction it is consumed.\n #[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n+#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n+#[allow(deprecated)]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2507,6 +2569,7 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n #[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n+#[allow(deprecated)]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n     done: bool,\n@@ -2516,6 +2579,7 @@ pub struct RangeInclusive<A> {\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n+#[allow(deprecated)]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n         range: range(start, stop),\n@@ -2525,6 +2589,7 @@ pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n \n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n+#[allow(deprecated)]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n@@ -2561,6 +2626,7 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n \n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n+#[allow(deprecated)]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2578,61 +2644,39 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n }\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n-#[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-pub struct RangeStep<A> {\n-    state: A,\n-    stop: A,\n-    step: A,\n-    rev: bool,\n-}\n+#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation and step_by\")]\n+pub type RangeStep<A> = StepBy<A, ::ops::Range<A>>;\n \n-/// Return an iterator over the range [start, stop) by `step`.\n-///\n-/// It handles overflow by stopping.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::iter::range_step;\n-///\n-/// for i in range_step(0, 10, 2) {\n-///     println!(\"{}\", i);\n-/// }\n-/// ```\n-///\n-/// This prints:\n-///\n-/// ```text\n-/// 0\n-/// 2\n-/// 4\n-/// 6\n-/// 8\n-/// ```\n+/// Deprecated: use `(start..stop).step_by(step)` instead.\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n+#[deprecated(since = \"1.0.0-beta\",\n+             reason = \"use `(start..stop).step_by(step)` instead\")]\n+#[allow(deprecated)]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n-    let rev = step < Int::zero();\n-    RangeStep{state: start, stop: stop, step: step, rev: rev}\n+    StepBy {\n+        step_by: step,\n+        range: ::ops::Range { start: start, end: stop },\n+    }\n }\n \n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-impl<A: Int> Iterator for RangeStep<A> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Int> Iterator for StepBy<A, ::ops::Range<A>> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        if (self.rev && self.state > self.stop) || (!self.rev && self.state < self.stop) {\n-            let result = self.state;\n-            match self.state.checked_add(self.step) {\n-                Some(x) => self.state = x,\n-                None => self.state = self.stop.clone()\n+        let rev = self.step_by < Int::zero();\n+        let start = self.range.start;\n+        if (rev && start > self.range.end) || (!rev && start < self.range.end) {\n+            match start.checked_add(self.step_by) {\n+                Some(x) => self.range.start = x,\n+                None => self.range.start = self.range.end.clone()\n             }\n-            Some(result)\n+            Some(start)\n         } else {\n             None\n         }"}, {"sha": "6c79233da68f1c3ae795fe71b3f8181fffd32a06", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -29,6 +29,7 @@ pub use marker::{Copy, Send, Sized, Sync};\n pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // Reexported functions\n+#[allow(deprecated)]\n pub use iter::range;\n pub use mem::drop;\n "}, {"sha": "52cc2519addaaeb13f4465d3ff2f2fbc4c9d8fb4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -775,12 +775,12 @@ fn test_range_inclusive() {\n \n #[test]\n fn test_range_step() {\n-    assert_eq!(range_step(0, 20, 5).collect::<Vec<int>>(), [0, 5, 10, 15]);\n-    assert_eq!(range_step(20, 0, -5).collect::<Vec<int>>(), [20, 15, 10, 5]);\n-    assert_eq!(range_step(20, 0, -6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n-    assert_eq!(range_step(200, 255, 50).collect::<Vec<u8>>(), [200, 250]);\n-    assert_eq!(range_step(200, -5, 1).collect::<Vec<int>>(), []);\n-    assert_eq!(range_step(200, 200, 1).collect::<Vec<int>>(), []);\n+    assert_eq!((0..20).step_by(5).collect::<Vec<int>>(), [0, 5, 10, 15]);\n+    assert_eq!((20..0).step_by(-5).collect::<Vec<int>>(), [20, 15, 10, 5]);\n+    assert_eq!((20..0).step_by(-6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!((200..255).step_by(50).collect::<Vec<u8>>(), [200, 250]);\n+    assert_eq!((200..-5).step_by(1).collect::<Vec<int>>(), []);\n+    assert_eq!((200..200).step_by(1).collect::<Vec<int>>(), []);\n }\n \n #[test]"}, {"sha": "79b176a4ffdcb1152e8a0954fdc5bb3f8a4b0448", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -17,8 +17,6 @@\n //! internally. The `IndependentSample` trait is for generating values\n //! that do not need to record state.\n \n-#![unstable(feature = \"rand\")]\n-\n use core::prelude::*;\n use core::num::{Float, Int};\n use core::marker::PhantomData;"}, {"sha": "9add236d54b188f4c83a80c83a5177b672cfd1df", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -154,7 +154,7 @@ pub trait Combine<'tcx> : Sized {\n                                                                  b_tys.len())));\n             }\n \n-            range(0, a_tys.len()).map(|i| {\n+            (0.. a_tys.len()).map(|i| {\n                 let a_ty = a_tys[i];\n                 let b_ty = b_tys[i];\n                 let v = variances.map_or(ty::Invariant, |v| v[i]);"}, {"sha": "99d24a6013078f90be120d67ffadaf33a0b168bc", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -48,6 +48,7 @@\n #![feature(path_ext)]\n #![feature(std_misc)]\n #![feature(path_relative_from)]\n+#![feature(step_by)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "5aae0e9dbdcf06a2729a338d5624c1a74265b0df", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -48,7 +48,6 @@\n \n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n-use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n \n@@ -103,7 +102,7 @@ impl Svh {\n \n         let hash = state.finish();\n         return Svh {\n-            hash: range_step(0, 64, 4).map(|i| hex(hash >> i)).collect()\n+            hash: (0..64).step_by(4).map(|i| hex(hash >> i)).collect()\n         };\n \n         fn hex(b: u64) -> char {"}, {"sha": "219f48f78dc46342d35883cb824e7a9d682120b3", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -21,7 +21,6 @@ use libc;\n use flate;\n \n use std::ffi::CString;\n-use std::iter;\n use std::mem;\n use std::num::Int;\n \n@@ -62,7 +61,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let file = path.file_name().unwrap().to_str().unwrap();\n         let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n-        for i in iter::count(0, 1) {\n+        for i in 0.. {\n             let bc_encoded = time(sess.time_passes(),\n                                   &format!(\"check for {}.{}.bytecode.deflate\", name, i),\n                                   (),\n@@ -213,4 +212,3 @@ fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n \n     Int::from_le(data)\n }\n-"}, {"sha": "93215090d9562bfa54dc689fe500666e32eabd84", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -16,8 +16,8 @@\n \n use prelude::v1::*;\n \n+use ops::Range;\n use mem;\n-use iter::Range;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n #[unstable(feature = \"std_misc\",\n@@ -270,7 +270,7 @@ pub fn escape_default(c: u8) -> EscapeDefault {\n         _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n     };\n \n-    return EscapeDefault { range: range(0, len), data: data };\n+    return EscapeDefault { range: (0.. len), data: data };\n \n     fn hexify(b: u8) -> u8 {\n         match b {"}, {"sha": "c502a94ba691dfe82bad29026c6cd4727c8c2ea5", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -359,7 +359,7 @@ impl fmt::Display for Ipv6Addr {\n                     let mut cur_span_len = 0;\n                     let mut cur_span_at = 0;\n \n-                    for i in range(0, 8) {\n+                    for i in 0..8 {\n                         if segments[i] == 0 {\n                             if cur_span_len == 0 {\n                                 cur_span_at = i;"}, {"sha": "2dea77a3ccdcefe2be524ed74e325dea7114628f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -587,7 +587,6 @@ pub fn get_exit_status() -> int {\n unsafe fn load_argc_and_argv(argc: int,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use ffi::CStr;\n-    use iter::range;\n \n     (0..argc).map(|i| {\n         CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec()"}, {"sha": "31aac333859cd742bf12bc98349873b25e6a6892", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -57,6 +57,7 @@\n // NB: remove when I/O reform lands\n #[doc(no_inline)] pub use old_io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n // NB: remove when range syntax lands\n+#[allow(deprecated)]\n #[doc(no_inline)] pub use iter::range;\n \n #[doc(no_inline)] pub use num::wrapping::{Wrapping, WrappingOps};"}, {"sha": "75aeafe6e3c90adc4545b5a6fa2dbfe913b4cf06", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -286,7 +286,7 @@ pub fn args() -> Args {\n     let vec = unsafe {\n         let (argc, argv) = (*_NSGetArgc() as isize,\n                             *_NSGetArgv() as *const *const c_char);\n-        range(0, argc as isize).map(|i| {\n+        (0.. argc as isize).map(|i| {\n             let bytes = CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec();\n             OsStringExt::from_vec(bytes)\n         }).collect::<Vec<_>>()"}, {"sha": "f2ada490fad7847a30778188be7a35fdc35a44c8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde09eea35113f25d4e0bcc4a8344de971f3069a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bde09eea35113f25d4e0bcc4a8344de971f3069a", "patch": "@@ -77,7 +77,6 @@ use owned_slice::OwnedSlice;\n \n use std::collections::HashSet;\n use std::io::prelude::*;\n-use std::iter;\n use std::mem;\n use std::num::Float;\n use std::path::{Path, PathBuf};\n@@ -749,7 +748,7 @@ impl<'a> Parser<'a> {\n         // would encounter a `>` and stop. This lets the parser handle trailing\n         // commas in generic parameters, because it can stop either after\n         // parsing a type or after parsing a comma.\n-        for i in iter::count(0, 1) {\n+        for i in 0.. {\n             if self.check(&token::Gt)\n                 || self.token == token::BinOp(token::Shr)\n                 || self.token == token::Ge"}]}