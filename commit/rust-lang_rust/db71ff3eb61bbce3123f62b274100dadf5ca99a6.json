{"sha": "db71ff3eb61bbce3123f62b274100dadf5ca99a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNzFmZjNlYjYxYmJjZTMxMjNmNjJiMjc0MTAwZGFkZjVjYTk5YTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-26T06:13:31Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-26T06:13:50Z"}, "message": "libcore: Add some methods to make working with string slices easier", "tree": {"sha": "ae8187611d896ef029da944b8f98f5cfd741c110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae8187611d896ef029da944b8f98f5cfd741c110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db71ff3eb61bbce3123f62b274100dadf5ca99a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db71ff3eb61bbce3123f62b274100dadf5ca99a6", "html_url": "https://github.com/rust-lang/rust/commit/db71ff3eb61bbce3123f62b274100dadf5ca99a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db71ff3eb61bbce3123f62b274100dadf5ca99a6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80429dd7bdb94cf11aba1fdfd7a149458a5a6f28", "url": "https://api.github.com/repos/rust-lang/rust/commits/80429dd7bdb94cf11aba1fdfd7a149458a5a6f28", "html_url": "https://github.com/rust-lang/rust/commit/80429dd7bdb94cf11aba1fdfd7a149458a5a6f28"}], "stats": {"total": 56, "additions": 56, "deletions": 0}, "files": [{"sha": "cf6d7dc3db6f1189d33d7ce524d31c77fbecbc08", "filename": "src/libcore/str.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/db71ff3eb61bbce3123f62b274100dadf5ca99a6/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db71ff3eb61bbce3123f62b274100dadf5ca99a6/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=db71ff3eb61bbce3123f62b274100dadf5ca99a6", "patch": "@@ -32,6 +32,7 @@ export\n    push_char,\n    pop_char,\n    shift_char,\n+   view_shift_char,\n    unshift_char,\n    trim_left,\n    trim_right,\n@@ -43,6 +44,7 @@ export\n    chars,\n    substr,\n    slice,\n+   view,\n    split, splitn, split_nonempty,\n    split_char, splitn_char, split_char_nonempty,\n    split_str, split_str_nonempty,\n@@ -338,6 +340,22 @@ fn shift_char(&s: ~str) -> char {\n     return ch;\n }\n \n+/**\n+ * Removes the first character from a string slice and returns it. This does\n+ * not allocate a new string; instead, it mutates a slice to point one\n+ * character beyond the character that was shifted.\n+ *\n+ * # Failure\n+ *\n+ * If the string does not contain any characters\n+ */\n+#[inline]\n+fn view_shift_char(s: &a/str) -> (char, &a/str) {\n+    let {ch, next} = char_range_at(s, 0u);\n+    let next_s = unsafe { unsafe::view_bytes(s, next, len(s)) };\n+    return (ch, next_s);\n+}\n+\n /// Prepend a char to a string\n fn unshift_char(&s: ~str, ch: char) { s = from_char(ch) + s; }\n \n@@ -423,6 +441,18 @@ pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n     unsafe { unsafe::slice_bytes(s, begin, end) }\n }\n \n+/**\n+ * Returns a view of the given string from the byte range [`begin`..`end`)\n+ *\n+ * Fails when `begin` and `end` do not point to valid characters or beyond\n+ * the last character of the string\n+ */\n+pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n+    assert is_char_boundary(s, begin);\n+    assert is_char_boundary(s, end);\n+    unsafe { unsafe::view_bytes(s, begin, end) }\n+}\n+\n /// Splits a string into substrings at each occurrence of a given character\n pure fn split_char(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), true)\n@@ -1773,6 +1803,7 @@ mod unsafe {\n       from_c_str_len,\n       from_bytes,\n       slice_bytes,\n+      view_bytes,\n       push_byte,\n       pop_byte,\n       shift_byte,\n@@ -1857,6 +1888,27 @@ mod unsafe {\n        }\n    }\n \n+   /**\n+    * Takes a bytewise (not UTF-8) view from a string.\n+    *\n+    * Returns the substring from [`begin`..`end`).\n+    *\n+    * # Failure\n+    *\n+    * If begin is greater than end.\n+    * If end is greater than the length of the string.\n+    */\n+   #[inline]\n+   unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n+       do as_buf(s) |sbuf, n| {\n+            assert (begin <= end);\n+            assert (end <= n);\n+\n+            let tuple = (ptr::offset(sbuf, begin), end - begin + 1);\n+            ::unsafe::reinterpret_cast(tuple)\n+       }\n+   }\n+\n    /// Appends a byte to a string. (Not UTF-8 safe).\n    unsafe fn push_byte(&s: ~str, b: u8) {\n        rustrt::rust_str_push(s, b);\n@@ -1958,6 +2010,7 @@ trait StrSlice {\n     fn escape_default() -> ~str;\n     fn escape_unicode() -> ~str;\n     pure fn to_unique() -> ~str;\n+    pure fn char_at(i: uint) -> char;\n }\n \n /// Extension methods for strings\n@@ -2067,6 +2120,9 @@ impl &str: StrSlice {\n \n     #[inline]\n     pure fn to_unique() -> ~str { self.slice(0, self.len()) }\n+\n+    #[inline]\n+    pure fn char_at(i: uint) -> char { char_at(self, i) }\n }\n \n #[cfg(test)]"}]}