{"sha": "19fdc6e091af973a378d53c13bb1ea42862171ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZmRjNmUwOTFhZjk3M2EzNzhkNTNjMTNiYjFlYTQyODYyMTcxYWQ=", "commit": {"author": {"name": "Phoebe Bell", "email": "minaphoebebell@gmail.com", "date": "2019-11-20T02:28:32Z"}, "committer": {"name": "Phoebe Bell", "email": "minaphoebebell@gmail.com", "date": "2020-01-17T02:26:14Z"}, "message": "Document unsafe blocks in core::{cell, str, sync}", "tree": {"sha": "8867302236419ac78ae010b682f294f1bb69b43e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8867302236419ac78ae010b682f294f1bb69b43e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19fdc6e091af973a378d53c13bb1ea42862171ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19fdc6e091af973a378d53c13bb1ea42862171ad", "html_url": "https://github.com/rust-lang/rust/commit/19fdc6e091af973a378d53c13bb1ea42862171ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19fdc6e091af973a378d53c13bb1ea42862171ad/comments", "author": {"login": "foeb", "id": 16327576, "node_id": "MDQ6VXNlcjE2MzI3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16327576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/foeb", "html_url": "https://github.com/foeb", "followers_url": "https://api.github.com/users/foeb/followers", "following_url": "https://api.github.com/users/foeb/following{/other_user}", "gists_url": "https://api.github.com/users/foeb/gists{/gist_id}", "starred_url": "https://api.github.com/users/foeb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/foeb/subscriptions", "organizations_url": "https://api.github.com/users/foeb/orgs", "repos_url": "https://api.github.com/users/foeb/repos", "events_url": "https://api.github.com/users/foeb/events{/privacy}", "received_events_url": "https://api.github.com/users/foeb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "foeb", "id": 16327576, "node_id": "MDQ6VXNlcjE2MzI3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16327576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/foeb", "html_url": "https://github.com/foeb", "followers_url": "https://api.github.com/users/foeb/followers", "following_url": "https://api.github.com/users/foeb/following{/other_user}", "gists_url": "https://api.github.com/users/foeb/gists{/gist_id}", "starred_url": "https://api.github.com/users/foeb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/foeb/subscriptions", "organizations_url": "https://api.github.com/users/foeb/orgs", "repos_url": "https://api.github.com/users/foeb/repos", "events_url": "https://api.github.com/users/foeb/events{/privacy}", "received_events_url": "https://api.github.com/users/foeb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "html_url": "https://github.com/rust-lang/rust/commit/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0"}], "stats": {"total": 108, "additions": 91, "deletions": 17}, "files": [{"sha": "c530432f802db21d5cc3cfd30dacd2361b243f2a", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=19fdc6e091af973a378d53c13bb1ea42862171ad", "patch": "@@ -187,8 +187,6 @@\n //! ```\n //!\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering;\n@@ -368,6 +366,7 @@ impl<T> Cell<T> {\n         if ptr::eq(self, other) {\n             return;\n         }\n+        // SAFETY: not threadsafe, but it's OK since we know `Cell` isn't threadsafe\n         unsafe {\n             ptr::swap(self.value.get(), other.value.get());\n         }\n@@ -387,6 +386,7 @@ impl<T> Cell<T> {\n     /// ```\n     #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n     pub fn replace(&self, val: T) -> T {\n+        // SAFETY: not threadsafe, but it's OK since we know `Cell` isn't threadsafe\n         mem::replace(unsafe { &mut *self.value.get() }, val)\n     }\n \n@@ -423,6 +423,7 @@ impl<T: Copy> Cell<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n+        // SAFETY: not threadsafe, but it's OK since we know `Cell` isn't threadsafe\n         unsafe { *self.value.get() }\n     }\n \n@@ -491,6 +492,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: not threadsafe, but it's OK since we know `Cell` isn't threadsafe\n         unsafe { &mut *self.value.get() }\n     }\n \n@@ -510,6 +512,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn from_mut(t: &mut T) -> &Cell<T> {\n+        // SAFETY: `&mut` ensures unique access\n         unsafe { &*(t as *mut T as *const Cell<T>) }\n     }\n }\n@@ -553,6 +556,7 @@ impl<T> Cell<[T]> {\n     /// ```\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn as_slice_of_cells(&self) -> &[Cell<T>] {\n+        // SAFETY: `Cell<T>` has the same memory layout as `T`\n         unsafe { &*(self as *const Cell<[T]> as *const [Cell<T>]) }\n     }\n }\n@@ -816,6 +820,8 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow(&self) -> Result<Ref<'_, T>, BorrowError> {\n         match BorrowRef::new(&self.borrow) {\n+            // SAFETY: `BorrowRef` ensures that there is only immutable access\n+            // to the value while borrowed\n             Some(b) => Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b }),\n             None => Err(BorrowError { _private: () }),\n         }\n@@ -891,6 +897,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow_mut(&self) -> Result<RefMut<'_, T>, BorrowMutError> {\n         match BorrowRefMut::new(&self.borrow) {\n+            // SAFETY: `BorrowRef` gurantees unique access\n             Some(b) => Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b }),\n             None => Err(BorrowMutError { _private: () }),\n         }\n@@ -940,6 +947,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: `&mut` guarantees unique access\n         unsafe { &mut *self.value.get() }\n     }\n "}, {"sha": "9d2e38734ef02cec9ffb7e2b3b200a54683f55f4", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=19fdc6e091af973a378d53c13bb1ea42862171ad", "patch": "@@ -3,8 +3,6 @@ use crate::fmt::{self, Write};\n use crate::mem;\n use crate::str as core_str;\n \n-// ignore-tidy-undocumented-unsafe\n-\n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"none\")]\n pub struct Utf8Lossy {\n@@ -17,6 +15,7 @@ impl Utf8Lossy {\n     }\n \n     pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n+        // SAFETY: both use the same memory layout, and UTF-8 correctness isn't required\n         unsafe { mem::transmute(bytes) }\n     }\n \n@@ -60,6 +59,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         while i < self.source.len() {\n             let i_ = i;\n \n+            // SAFETY: 0 <= i < self.source.len()\n             let byte = unsafe { *self.source.get_unchecked(i) };\n             i += 1;\n \n@@ -69,6 +69,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n                 macro_rules! error {\n                     () => {{\n+                        // SAFETY: we have checked up to `i` that source is valid UTF-8\n                         unsafe {\n                             let r = Utf8LossyChunk {\n                                 valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n@@ -130,6 +131,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         }\n \n         let r = Utf8LossyChunk {\n+            // SAFETY: we have checked that the entire source is valid UTF-8\n             valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n             broken: &[],\n         };"}, {"sha": "3139d6188e27f4ded62b33dd231161887aba6784", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=19fdc6e091af973a378d53c13bb1ea42862171ad", "patch": "@@ -1,5 +1,4 @@\n // ignore-tidy-filelength\n-// ignore-tidy-undocumented-unsafe\n \n //! String manipulation.\n //!\n@@ -341,6 +340,7 @@ impl Utf8Error {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     run_utf8_validation(v)?;\n+    // SAFETY: just ran validation\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n@@ -379,6 +379,7 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n     run_utf8_validation(v)?;\n+    // SAFETY: just ran validation\n     Ok(unsafe { from_utf8_unchecked_mut(v) })\n }\n \n@@ -581,7 +582,7 @@ impl<'a> Iterator for Chars<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         next_code_point(&mut self.iter).map(|ch| {\n-            // str invariant says `ch` is a valid Unicode Scalar Value\n+            // SAFETY: str invariant says `ch` is a valid Unicode Scalar Value\n             unsafe { char::from_u32_unchecked(ch) }\n         })\n     }\n@@ -628,7 +629,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         next_code_point_reverse(&mut self.iter).map(|ch| {\n-            // str invariant says `ch` is a valid Unicode Scalar Value\n+            // SAFETY: str invariant says `ch` is a valid Unicode Scalar Value\n             unsafe { char::from_u32_unchecked(ch) }\n         })\n     }\n@@ -658,6 +659,7 @@ impl<'a> Chars<'a> {\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     #[inline]\n     pub fn as_str(&self) -> &'a str {\n+        // SAFETY: Chars is only made from a str, which guarantees the iter is valid utf8\n         unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n     }\n }\n@@ -1102,6 +1104,7 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     fn get_end(&mut self) -> Option<&'a str> {\n         if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n             self.finished = true;\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries\n             unsafe {\n                 let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n                 Some(string)\n@@ -1119,6 +1122,7 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries\n             Some((a, b)) => unsafe {\n                 let elt = haystack.get_unchecked(self.start..a);\n                 self.start = b;\n@@ -1151,11 +1155,13 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries\n             Some((a, b)) => unsafe {\n                 let elt = haystack.get_unchecked(b..self.end);\n                 self.end = a;\n                 Some(elt)\n             },\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries\n             None => unsafe {\n                 self.finished = true;\n                 Some(haystack.get_unchecked(self.start..self.end))\n@@ -1295,6 +1301,7 @@ where\n impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<(usize, &'a str)> {\n+        // SAFETY: `Searcher` guaratees that `start` and `end` lie on unicode boundaries\n         self.0\n             .next_match()\n             .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n@@ -1305,6 +1312,7 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     where\n         P::Searcher: ReverseSearcher<'a>,\n     {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries\n         self.0\n             .next_match_back()\n             .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n@@ -1348,6 +1356,7 @@ where\n impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries\n         self.0.next_match().map(|(a, b)| unsafe {\n             // Indices are known to be on utf8 boundaries\n             self.0.haystack().get_unchecked(a..b)\n@@ -1359,6 +1368,7 @@ impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     where\n         P::Searcher: ReverseSearcher<'a>,\n     {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries\n         self.0.next_match_back().map(|(a, b)| unsafe {\n             // Indices are known to be on utf8 boundaries\n             self.0.haystack().get_unchecked(a..b)\n@@ -1579,6 +1589,9 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             if align != usize::max_value() && align.wrapping_sub(index) % usize_bytes == 0 {\n                 let ptr = v.as_ptr();\n                 while index < blocks_end {\n+                    // SAFETY: since `align - index` and `ascii_block_size` are multiples of\n+                    // `usize_bytes`, `ptr.add(index)` is always aligned with a `usize` so we\n+                    // may cast directly to a `const` pointer.\n                     unsafe {\n                         let block = ptr.add(index) as *const usize;\n                         // break if there is a nonascii byte\n@@ -1804,6 +1817,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1815,6 +1829,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1845,6 +1860,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, self.end)\n@@ -1873,6 +1889,7 @@ mod traits {\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1881,6 +1898,7 @@ mod traits {\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1903,8 +1921,8 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, 0, self.end)\n@@ -1934,6 +1952,7 @@ mod traits {\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1942,6 +1961,7 @@ mod traits {\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1966,8 +1986,8 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, slice.len())\n@@ -2238,7 +2258,6 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"str_as_bytes\", since = \"1.32.0\")]\n     #[inline(always)]\n-    // SAFETY: const sound because we transmute two types with the same layout\n     #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn as_bytes(&self) -> &[u8] {\n@@ -2247,6 +2266,7 @@ impl str {\n             str: &'a str,\n             slice: &'a [u8],\n         }\n+        // SAFETY: const sound because we transmute two types with the same layout\n         unsafe { Slices { str: self }.slice }\n     }\n \n@@ -2573,6 +2593,7 @@ impl str {\n     pub fn split_at(&self, mid: usize) -> (&str, &str) {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(mid) {\n+            // SAFETY: just checked that `mid` is on a char boundary\n             unsafe { (self.get_unchecked(0..mid), self.get_unchecked(mid..self.len())) }\n         } else {\n             slice_error_fail(self, 0, mid)\n@@ -2617,6 +2638,7 @@ impl str {\n         if self.is_char_boundary(mid) {\n             let len = self.len();\n             let ptr = self.as_mut_ptr();\n+            // SAFETY: just checked that `mid` is on a char boundary\n             unsafe {\n                 (\n                     from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, mid)),\n@@ -3805,8 +3827,8 @@ impl str {\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;\n         }\n+        // SAFETY: `Searcher` is known to return valid indices\n         unsafe {\n-            // Searcher is known to return valid indices\n             self.get_unchecked(i..j)\n         }\n     }\n@@ -3844,8 +3866,8 @@ impl str {\n         if let Some((a, _)) = matcher.next_reject() {\n             i = a;\n         }\n+        // SAFETY: `Searcher` is known to return valid indices\n         unsafe {\n-            // Searcher is known to return valid indices\n             self.get_unchecked(i..self.len())\n         }\n     }\n@@ -3970,8 +3992,8 @@ impl str {\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;\n         }\n+        // SAFETY: `Searcher` is known to return valid indices\n         unsafe {\n-            // Searcher is known to return valid indices\n             self.get_unchecked(0..j)\n         }\n     }\n@@ -4166,6 +4188,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_uppercase(&mut self) {\n+        // SAFETY: safe because we transmute two types with the same layout\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_uppercase()\n     }\n@@ -4191,6 +4214,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_lowercase(&mut self) {\n+        // SAFETY: safe because we transmute two types with the same layout\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n@@ -4356,6 +4380,7 @@ impl Default for &str {\n #[stable(feature = \"default_mut_str\", since = \"1.28.0\")]\n impl Default for &mut str {\n     /// Creates an empty mutable str\n+    // SAFETY: `str` is guranteed to be UTF-8\n     fn default() -> Self {\n         unsafe { from_utf8_unchecked_mut(&mut []) }\n     }\n@@ -4412,6 +4437,7 @@ impl_fn_for_zst! {\n \n     #[derive(Clone)]\n     struct UnsafeBytesToStr impl<'a> Fn = |bytes: &'a [u8]| -> &'a str {\n+        // SAFETY: not safe\n         unsafe { from_utf8_unchecked(bytes) }\n     };\n }"}, {"sha": "ef64d8b0fdf8880883ee168c22a5e0164c72fea7", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=19fdc6e091af973a378d53c13bb1ea42862171ad", "patch": "@@ -3,8 +3,6 @@\n //! For more details, see the traits [`Pattern`], [`Searcher`],\n //! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![unstable(\n     feature = \"pattern\",\n     reason = \"API not fully fleshed out and ready to be stabilized\",\n@@ -271,6 +269,14 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next(&mut self) -> SearchStep {\n         let old_finger = self.finger;\n+        // SAFETY: 1-4 guarantee safety of `get_unchecked`\n+        // 1. `self.finger` and `self.finger_back` are kept on unicode boundaries\n+        //    (this is invariant)\n+        // 2. `self.finger >= 0` since it starts at 0 and only increases\n+        // 3. `self.finger < self.finger_back` because otherwise the char `iter`\n+        //    would return `SearchStep::Done`\n+        // 4. `self.finger` comes before the end of the haystack because `self.finger_back`\n+        //    starts at the end and only decreases\n         let slice = unsafe { self.haystack.get_unchecked(old_finger..self.finger_back) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n@@ -293,6 +299,7 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n             // get the haystack after the last character found\n             let bytes = self.haystack.as_bytes().get(self.finger..self.finger_back)?;\n             // the last byte of the utf8 encoded needle\n+            // SAFETY: we have an invariant that `utf8_size < 5`\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memchr(last_byte, bytes) {\n                 // The new finger is the index of the byte we found,\n@@ -336,6 +343,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next_back(&mut self) -> SearchStep {\n         let old_finger = self.finger_back;\n+        // SAFETY: see the comment for next() above\n         let slice = unsafe { self.haystack.get_unchecked(self.finger..old_finger) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n@@ -363,6 +371,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n                 return None;\n             };\n             // the last byte of the utf8 encoded needle\n+            // SAFETY: we have an invariant that `utf8_size < 5`\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memrchr(last_byte, bytes) {\n                 // we searched a slice that was offset by self.finger,"}, {"sha": "889f182561b63f722093ccaa765d7faca283130a", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fdc6e091af973a378d53c13bb1ea42862171ad/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=19fdc6e091af973a378d53c13bb1ea42862171ad", "patch": "@@ -112,8 +112,6 @@\n //! println!(\"live threads: {}\", old_thread_count + 1);\n //! ```\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n@@ -350,6 +348,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut bool {\n+        // SAFETY: the mutable reference guarantees unique ownership\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n \n@@ -400,6 +399,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe { atomic_load(self.v.get(), order) != 0 }\n     }\n \n@@ -432,6 +432,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe {\n             atomic_store(self.v.get(), val as u8, order);\n         }\n@@ -463,6 +464,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -558,6 +560,7 @@ impl AtomicBool {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<bool, bool> {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         match unsafe {\n             atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n         } {\n@@ -615,6 +618,7 @@ impl AtomicBool {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<bool, bool> {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         match unsafe {\n             atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n         } {\n@@ -661,6 +665,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -756,6 +761,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -797,6 +803,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -872,6 +879,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut *mut T {\n+        // SAFETY: the mutable reference guarantees unique ownership\n         unsafe { &mut *self.p.get() }\n     }\n \n@@ -923,6 +931,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n     }\n \n@@ -957,6 +966,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe {\n             atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n         }\n@@ -990,6 +1000,7 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n@@ -1074,6 +1085,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe {\n             let res = atomic_compare_exchange(\n                 self.p.get() as *mut usize,\n@@ -1137,6 +1149,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        // SAFETY: data races are prevented by atomic intrinsics\n         unsafe {\n             let res = atomic_compare_exchange_weak(\n                 self.p.get() as *mut usize,\n@@ -1290,6 +1303,7 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 #[inline]\n                 #[$stable_access]\n                 pub fn get_mut(&mut self) -> &mut $int_type {\n+                    // SAFETY: the mutable reference guarantees unique ownership\n                     unsafe { &mut *self.v.get() }\n                 }\n             }\n@@ -1344,6 +1358,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 5);\n                 #[inline]\n                 #[$stable]\n                 pub fn load(&self, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_load(self.v.get(), order) }\n                 }\n             }\n@@ -1378,6 +1393,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                 #[inline]\n                 #[$stable]\n                 pub fn store(&self, val: $int_type, order: Ordering) {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_store(self.v.get(), val, order); }\n                 }\n             }\n@@ -1408,6 +1424,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n             }\n@@ -1510,6 +1527,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                                         new: $int_type,\n                                         success: Ordering,\n                                         failure: Ordering) -> Result<$int_type, $int_type> {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n                 }\n             }\n@@ -1562,6 +1580,7 @@ loop {\n                                              new: $int_type,\n                                              success: Ordering,\n                                              failure: Ordering) -> Result<$int_type, $int_type> {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe {\n                         atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n                     }\n@@ -1596,6 +1615,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n             }\n@@ -1628,6 +1648,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n             }\n@@ -1663,6 +1684,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n             }\n@@ -1699,6 +1721,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n                 #[$stable_nand]\n                 #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n             }\n@@ -1734,6 +1757,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n             }\n@@ -1769,6 +1793,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n             }\n@@ -1880,6 +1905,7 @@ assert!(max_foo == 42);\n                        issue = \"48655\")]\n                 #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n             }\n@@ -1932,6 +1958,7 @@ assert_eq!(min_foo, 12);\n                        issue = \"48655\")]\n                 #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n             }\n@@ -2526,6 +2553,7 @@ pub fn fence(order: Ordering) {\n     // https://github.com/WebAssembly/tool-conventions/issues/59. We should\n     // follow that discussion and implement a solution when one comes about!\n     #[cfg(not(target_arch = \"wasm32\"))]\n+    // SAFETY: using an atomic fence is safe\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_fence_acq(),\n@@ -2613,6 +2641,7 @@ pub fn fence(order: Ordering) {\n #[inline]\n #[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n pub fn compiler_fence(order: Ordering) {\n+    // SAFETY: doesn't compile to machine code\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_singlethreadfence_acq(),"}]}