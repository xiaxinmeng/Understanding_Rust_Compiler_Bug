{"sha": "128f2224afa6bf135a674fc14e5c825f2c76c93f", "node_id": "C_kwDOAAsO6NoAKDEyOGYyMjI0YWZhNmJmMTM1YTY3NGZjMTRlNWM4MjVmMmM3NmM5M2Y", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-04T15:16:59Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-04T15:21:21Z"}, "message": "Remove `OnHit` callback from query caches.\n\nThis is not useful now that query results are `Copy`.", "tree": {"sha": "8b52b996cb4953036d581eecb753057214cab25c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b52b996cb4953036d581eecb753057214cab25c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128f2224afa6bf135a674fc14e5c825f2c76c93f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128f2224afa6bf135a674fc14e5c825f2c76c93f", "html_url": "https://github.com/rust-lang/rust/commit/128f2224afa6bf135a674fc14e5c825f2c76c93f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128f2224afa6bf135a674fc14e5c825f2c76c93f/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3126500f25114ba4e0ac3e76694dd45a22de56d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3126500f25114ba4e0ac3e76694dd45a22de56d", "html_url": "https://github.com/rust-lang/rust/commit/f3126500f25114ba4e0ac3e76694dd45a22de56d"}], "stats": {"total": 189, "additions": 65, "deletions": 124}, "files": [{"sha": "7151b79c5ab63f4b4b7ba8a56a4e5cd275320889", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/128f2224afa6bf135a674fc14e5c825f2c76c93f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128f2224afa6bf135a674fc14e5c825f2c76c93f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=128f2224afa6bf135a674fc14e5c825f2c76c93f", "patch": "@@ -106,16 +106,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-/// Helper for `TyCtxtEnsure` to avoid a closure.\n-#[inline(always)]\n-fn noop<T>(_: &T) {}\n-\n-/// Helper to ensure that queries only return `Copy` types.\n-#[inline(always)]\n-fn copy<T: Copy>(x: &T) -> T {\n-    *x\n-}\n-\n macro_rules! query_helper_param_ty {\n     (DefId) => { impl IntoQueryParam<DefId> };\n     (LocalDefId) => { impl IntoQueryParam<LocalDefId> };\n@@ -225,14 +215,10 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, noop);\n-\n-                match cached {\n-                    Ok(()) => return,\n-                    Err(()) => (),\n-                }\n-\n-                self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure);\n+                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                    Some(_) => return,\n+                    None => self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure),\n+                };\n             })*\n         }\n \n@@ -254,14 +240,10 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, copy);\n-\n-                match cached {\n-                    Ok(value) => return value,\n-                    Err(()) => (),\n+                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                    Some(value) => value,\n+                    None => self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap(),\n                 }\n-\n-                self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap()\n             })*\n         }\n \n@@ -353,27 +335,25 @@ macro_rules! define_feedable {\n                 let tcx = self.tcx;\n                 let cache = &tcx.query_caches.$name;\n \n-                let cached = try_get_cached(tcx, cache, &key, copy);\n-\n-                match cached {\n-                    Ok(old) => {\n+                match try_get_cached(tcx, cache, &key) {\n+                    Some(old) => {\n                         bug!(\n                             \"Trying to feed an already recorded value for query {} key={key:?}:\\nold value: {old:?}\\nnew value: {value:?}\",\n                             stringify!($name),\n+                        )\n+                    }\n+                    None => {\n+                        let dep_node = dep_graph::DepNode::construct(tcx, dep_graph::DepKind::$name, &key);\n+                        let dep_node_index = tcx.dep_graph.with_feed_task(\n+                            dep_node,\n+                            tcx,\n+                            key,\n+                            &value,\n+                            hash_result!([$($modifiers)*]),\n                         );\n+                        cache.complete(key, value, dep_node_index)\n                     }\n-                    Err(()) => (),\n                 }\n-\n-                let dep_node = dep_graph::DepNode::construct(tcx, dep_graph::DepKind::$name, &key);\n-                let dep_node_index = tcx.dep_graph.with_feed_task(\n-                    dep_node,\n-                    tcx,\n-                    key,\n-                    &value,\n-                    hash_result!([$($modifiers)*]),\n-                );\n-                cache.complete(key, value, dep_node_index)\n             }\n         })*\n     }"}, {"sha": "21c89cbc4f19da63e3e793815ef71d1e2922fc12", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 17, "deletions": 56, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/128f2224afa6bf135a674fc14e5c825f2c76c93f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128f2224afa6bf135a674fc14e5c825f2c76c93f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=128f2224afa6bf135a674fc14e5c825f2c76c93f", "patch": "@@ -16,13 +16,13 @@ use std::marker::PhantomData;\n pub trait CacheSelector<'tcx, V> {\n     type Cache\n     where\n-        V: Clone;\n+        V: Copy;\n     type ArenaCache;\n }\n \n pub trait QueryStorage {\n     type Value: Debug;\n-    type Stored: Clone;\n+    type Stored: Copy;\n \n     /// Store a value without putting it in the cache.\n     /// This is meant to be used with cycle errors.\n@@ -36,14 +36,7 @@ pub trait QueryCache: QueryStorage + Sized {\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<R, OnHit>(\n-        &self,\n-        key: &Self::Key,\n-        // `on_hit` can be called while holding a lock to the query state shard.\n-        on_hit: OnHit,\n-    ) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R;\n+    fn lookup(&self, key: &Self::Key) -> Option<(Self::Stored, DepNodeIndex)>;\n \n     fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex) -> Self::Stored;\n \n@@ -55,7 +48,7 @@ pub struct DefaultCacheSelector<K>(PhantomData<K>);\n impl<'tcx, K: Eq + Hash, V: 'tcx> CacheSelector<'tcx, V> for DefaultCacheSelector<K> {\n     type Cache = DefaultCache<K, V>\n     where\n-        V: Clone;\n+        V: Copy;\n     type ArenaCache = ArenaCache<'tcx, K, V>;\n }\n \n@@ -72,7 +65,7 @@ impl<K, V> Default for DefaultCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Hash, V: Clone + Debug> QueryStorage for DefaultCache<K, V> {\n+impl<K: Eq + Hash, V: Copy + Debug> QueryStorage for DefaultCache<K, V> {\n     type Value = V;\n     type Stored = V;\n \n@@ -86,28 +79,20 @@ impl<K: Eq + Hash, V: Clone + Debug> QueryStorage for DefaultCache<K, V> {\n impl<K, V> QueryCache for DefaultCache<K, V>\n where\n     K: Eq + Hash + Clone + Debug,\n-    V: Clone + Debug,\n+    V: Copy + Debug,\n {\n     type Key = K;\n \n     #[inline(always)]\n-    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-    {\n+    fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {\n         let key_hash = sharded::make_hash(key);\n         #[cfg(parallel_compiler)]\n         let lock = self.cache.get_shard_by_hash(key_hash).lock();\n         #[cfg(not(parallel_compiler))]\n         let lock = self.cache.lock();\n         let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n \n-        if let Some((_, value)) = result {\n-            let hit_result = on_hit(&value.0, value.1);\n-            Ok(hit_result)\n-        } else {\n-            Err(())\n-        }\n+        if let Some((_, value)) = result { Some(*value) } else { None }\n     }\n \n     #[inline]\n@@ -176,23 +161,15 @@ where\n     type Key = K;\n \n     #[inline(always)]\n-    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n-    {\n+    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n         let key_hash = sharded::make_hash(key);\n         #[cfg(parallel_compiler)]\n         let lock = self.cache.get_shard_by_hash(key_hash).lock();\n         #[cfg(not(parallel_compiler))]\n         let lock = self.cache.lock();\n         let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n \n-        if let Some((_, value)) = result {\n-            let hit_result = on_hit(&&value.0, value.1);\n-            Ok(hit_result)\n-        } else {\n-            Err(())\n-        }\n+        if let Some((_, value)) = result { Some((&value.0, value.1)) } else { None }\n     }\n \n     #[inline]\n@@ -234,7 +211,7 @@ pub struct VecCacheSelector<K>(PhantomData<K>);\n impl<'tcx, K: Idx, V: 'tcx> CacheSelector<'tcx, V> for VecCacheSelector<K> {\n     type Cache = VecCache<K, V>\n     where\n-        V: Clone;\n+        V: Copy;\n     type ArenaCache = VecArenaCache<'tcx, K, V>;\n }\n \n@@ -251,7 +228,7 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Idx, V: Clone + Debug> QueryStorage for VecCache<K, V> {\n+impl<K: Eq + Idx, V: Copy + Debug> QueryStorage for VecCache<K, V> {\n     type Value = V;\n     type Stored = V;\n \n@@ -265,25 +242,17 @@ impl<K: Eq + Idx, V: Clone + Debug> QueryStorage for VecCache<K, V> {\n impl<K, V> QueryCache for VecCache<K, V>\n where\n     K: Eq + Idx + Clone + Debug,\n-    V: Clone + Debug,\n+    V: Copy + Debug,\n {\n     type Key = K;\n \n     #[inline(always)]\n-    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-    {\n+    fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {\n         #[cfg(parallel_compiler)]\n         let lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let lock = self.cache.lock();\n-        if let Some(Some(value)) = lock.get(*key) {\n-            let hit_result = on_hit(&value.0, value.1);\n-            Ok(hit_result)\n-        } else {\n-            Err(())\n-        }\n+        if let Some(Some(value)) = lock.get(*key) { Some(*value) } else { None }\n     }\n \n     #[inline]\n@@ -357,20 +326,12 @@ where\n     type Key = K;\n \n     #[inline(always)]\n-    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n-    {\n+    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n         #[cfg(parallel_compiler)]\n         let lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let lock = self.cache.lock();\n-        if let Some(Some(value)) = lock.get(*key) {\n-            let hit_result = on_hit(&&value.0, value.1);\n-            Ok(hit_result)\n-        } else {\n-            Err(())\n-        }\n+        if let Some(Some(value)) = lock.get(*key) { Some((&value.0, value.1)) } else { None }\n     }\n \n     #[inline]"}, {"sha": "a28e45a5c086dc66805730ad804b22df8dfb38fa", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128f2224afa6bf135a674fc14e5c825f2c76c93f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128f2224afa6bf135a674fc14e5c825f2c76c93f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=128f2224afa6bf135a674fc14e5c825f2c76c93f", "patch": "@@ -21,7 +21,7 @@ pub trait QueryConfig<Qcx: QueryContext> {\n \n     type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Clone + Debug;\n     type Value: Debug;\n-    type Stored: Debug + Clone + std::borrow::Borrow<Self::Value>;\n+    type Stored: Debug + Copy + std::borrow::Borrow<Self::Value>;\n \n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n "}, {"sha": "bf380f6e2d3bbe393d4f3c64eb6352470aa21979", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/128f2224afa6bf135a674fc14e5c825f2c76c93f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128f2224afa6bf135a674fc14e5c825f2c76c93f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=128f2224afa6bf135a674fc14e5c825f2c76c93f", "patch": "@@ -130,7 +130,7 @@ fn mk_cycle<Qcx, V, R, D: DepKind>(\n where\n     Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n     V: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n-    R: Clone,\n+    R: Copy,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n     let value = handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler);\n@@ -339,25 +339,21 @@ where\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<Tcx, C, R, OnHit>(\n-    tcx: Tcx,\n-    cache: &C,\n-    key: &C::Key,\n-    // `on_hit` can be called while holding a lock to the query cache\n-    on_hit: OnHit,\n-) -> Result<R, ()>\n+pub fn try_get_cached<Tcx, C>(tcx: Tcx, cache: &C, key: &C::Key) -> Option<C::Stored>\n where\n     C: QueryCache,\n     Tcx: DepContext,\n-    OnHit: FnOnce(&C::Stored) -> R,\n {\n-    cache.lookup(&key, |value, index| {\n-        if std::intrinsics::unlikely(tcx.profiler().enabled()) {\n-            tcx.profiler().query_cache_hit(index.into());\n+    match cache.lookup(&key) {\n+        Some((value, index)) => {\n+            if std::intrinsics::unlikely(tcx.profiler().enabled()) {\n+                tcx.profiler().query_cache_hit(index.into());\n+            }\n+            tcx.dep_graph().read_index(index);\n+            Some(value)\n         }\n-        tcx.dep_graph().read_index(index);\n-        on_hit(value)\n-    })\n+        None => None,\n+    }\n }\n \n fn try_execute_query<Q, Qcx>(\n@@ -379,17 +375,25 @@ where\n             if Q::FEEDABLE {\n                 // We may have put a value inside the cache from inside the execution.\n                 // Verify that it has the same hash as what we have now, to ensure consistency.\n-                let _ = cache.lookup(&key, |cached_result, _| {\n+                if let Some((cached_result, _)) = cache.lookup(&key) {\n                     let hasher = Q::HASH_RESULT.expect(\"feedable forbids no_hash\");\n \n-                    let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, cached_result.borrow()));\n-                    let new_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n+                    let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n+                        hasher(&mut hcx, cached_result.borrow())\n+                    });\n+                    let new_hash = qcx\n+                        .dep_context()\n+                        .with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n                     debug_assert_eq!(\n-                        old_hash, new_hash,\n+                        old_hash,\n+                        new_hash,\n                         \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\ncomputed={:#?}\\nfed={:#?}\",\n-                        Q::DEP_KIND, key, result, cached_result,\n+                        Q::DEP_KIND,\n+                        key,\n+                        result,\n+                        cached_result,\n                     );\n-                });\n+                }\n             }\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n@@ -771,15 +775,11 @@ where\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n     let cache = Q::query_cache(qcx);\n-    let cached = cache.lookup(&key, |_, index| {\n+    if let Some((_, index)) = cache.lookup(&key) {\n         if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n             qcx.dep_context().profiler().query_cache_hit(index.into());\n         }\n-    });\n-\n-    match cached {\n-        Ok(()) => return,\n-        Err(()) => {}\n+        return;\n     }\n \n     let state = Q::query_state(qcx);"}]}