{"sha": "753b683939f41039ffefe98959faca8dc718c726", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1M2I2ODM5MzlmNDEwMzlmZmVmZTk4OTU5ZmFjYThkYzcxOGM3MjY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-26T00:18:06Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-26T00:19:36Z"}, "message": "More slice use in vec, io, str, ebml, metadata encoder and decoder.", "tree": {"sha": "9f2e7c71e21bd9ad53a78fec0b7b78e40af934e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f2e7c71e21bd9ad53a78fec0b7b78e40af934e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/753b683939f41039ffefe98959faca8dc718c726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/753b683939f41039ffefe98959faca8dc718c726", "html_url": "https://github.com/rust-lang/rust/commit/753b683939f41039ffefe98959faca8dc718c726", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/753b683939f41039ffefe98959faca8dc718c726/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90c1b4645f8972101d22f392c55f2188d9770ef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/90c1b4645f8972101d22f392c55f2188d9770ef7", "html_url": "https://github.com/rust-lang/rust/commit/90c1b4645f8972101d22f392c55f2188d9770ef7"}], "stats": {"total": 338, "additions": 220, "deletions": 118}, "files": [{"sha": "0c723fc8c63ad684106c7b40091e76116a7bd2f0", "filename": "src/libcore/io.rs", "status": "modified", "additions": 111, "deletions": 51, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/753b683939f41039ffefe98959faca8dc718c726/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753b683939f41039ffefe98959faca8dc718c726/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=753b683939f41039ffefe98959faca8dc718c726", "patch": "@@ -297,23 +297,22 @@ enum fileflag { append, create, truncate, no_flag, }\n // FIXME: eventually u64\n // #2004\n iface writer {\n-    fn write([const u8]);\n+    fn write([const u8]/&);\n     fn seek(int, seek_style);\n     fn tell() -> uint;\n     fn flush() -> int;\n }\n \n impl <T: writer, C> of writer for {base: T, cleanup: C} {\n-    fn write(bs: [const u8]) { self.base.write(bs); }\n+    fn write(bs: [const u8]/&) { self.base.write(bs); }\n     fn seek(off: int, style: seek_style) { self.base.seek(off, style); }\n     fn tell() -> uint { self.base.tell() }\n     fn flush() -> int { self.base.flush() }\n }\n \n impl of writer for *libc::FILE {\n-    fn write(v: [const u8]) unsafe {\n-        let len = vec::len(v);\n-        vec::as_buf(v) {|vbuf|\n+    fn write(v: [const u8]/&) unsafe {\n+        vec::unpack_slice(v) {|vbuf, len|\n             let nout = libc::fwrite(vbuf as *c_void, len, 1u, self);\n             if nout < 1 as size_t {\n                 #error(\"error writing buffer\");\n@@ -339,10 +338,9 @@ fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n }\n \n impl of writer for fd_t {\n-    fn write(v: [const u8]) unsafe {\n-        let len = vec::len(v);\n+    fn write(v: [const u8]/&) unsafe {\n         let mut count = 0u;\n-        vec::as_buf(v) {|vbuf|\n+        vec::unpack_slice(v) {|vbuf, len|\n             while count < len {\n                 let vb = ptr::offset(vbuf, count) as *c_void;\n                 let nout = libc::write(self, vb, len);\n@@ -408,26 +406,66 @@ fn mk_file_writer(path: str, flags: [fileflag])\n     }\n }\n \n-fn u64_to_le_bytes(n: u64, size: uint) -> [u8] {\n-    let mut bytes: [u8] = [], i = size, n = n;\n-    while i > 0u {\n-        bytes += [(n & 255_u64) as u8];\n-        n >>= 8_u64;\n-        i -= 1u;\n+fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn([u8]/&) -> T) -> T {\n+    assert size <= 8u;\n+    alt size {\n+      1u { f([n as u8]/&) }\n+      2u { f([n as u8,\n+              (n >> 8) as u8]/&) }\n+      4u { f([n as u8,\n+              (n >> 8) as u8,\n+              (n >> 16) as u8,\n+              (n >> 24) as u8]/&) }\n+      8u { f([n as u8,\n+              (n >> 8) as u8,\n+              (n >> 16) as u8,\n+              (n >> 24) as u8,\n+              (n >> 32) as u8,\n+              (n >> 40) as u8,\n+              (n >> 48) as u8,\n+              (n >> 56) as u8]/&) }\n+      _ {\n+\n+        let mut bytes: [u8] = [], i = size, n = n;\n+        while i > 0u {\n+            bytes += [(n & 255_u64) as u8];\n+            n >>= 8_u64;\n+            i -= 1u;\n+        }\n+        f(bytes)\n+      }\n     }\n-    ret bytes;\n }\n \n-fn u64_to_be_bytes(n: u64, size: uint) -> [u8] {\n+fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn([u8]/&) -> T) -> T {\n     assert size <= 8u;\n-    let mut bytes: [u8] = [];\n-    let mut i = size;\n-    while i > 0u {\n-        let shift = ((i - 1u) * 8u) as u64;\n-        bytes += [(n >> shift) as u8];\n-        i -= 1u;\n+    alt size {\n+      1u { f([n as u8]/&) }\n+      2u { f([(n >> 8) as u8,\n+              n as u8]/&) }\n+      4u { f([(n >> 24) as u8,\n+              (n >> 16) as u8,\n+              (n >> 8) as u8,\n+              n as u8]/&) }\n+      8u { f([(n >> 56) as u8,\n+              (n >> 48) as u8,\n+              (n >> 40) as u8,\n+              (n >> 32) as u8,\n+              (n >> 24) as u8,\n+              (n >> 16) as u8,\n+              (n >> 8) as u8,\n+              n as u8]/&) }\n+      _ {\n+        let mut bytes: [u8] = [];\n+        let mut i = size;\n+        while i > 0u {\n+            let shift = ((i - 1u) * 8u) as u64;\n+            bytes += [(n >> shift) as u8];\n+            i -= 1u;\n+        }\n+        f(bytes)\n+      }\n     }\n-    ret bytes;\n }\n \n fn u64_from_be_bytes(data: [u8], start: uint, size: uint) -> u64 {\n@@ -448,45 +486,67 @@ impl writer_util for writer {\n         if ch as uint < 128u {\n             self.write([ch as u8]);\n         } else {\n-            self.write(str::bytes(str::from_char(ch)));\n+            self.write_str(str::from_char(ch));\n         }\n     }\n-    fn write_str(s: str) { self.write(str::bytes(s)); }\n-    fn write_line(s: str) { self.write(str::bytes(s + \"\\n\")); }\n-    fn write_int(n: int) { self.write(str::bytes(int::to_str(n, 10u))); }\n-    fn write_uint(n: uint) { self.write(str::bytes(uint::to_str(n, 10u))); }\n+    fn write_str(s: str/&) { str::byte_slice(s) {|v| self.write(v); } }\n+    fn write_line(s: str/&) {\n+        self.write_str(s);\n+        self.write_str(\"\\n\"/&);\n+    }\n+    fn write_int(n: int) { self.write_str(int::to_str(n, 10u)); }\n+    fn write_uint(n: uint) { self.write_str(uint::to_str(n, 10u)); }\n \n     fn write_le_uint(n: uint, size: uint) {\n-        self.write(u64_to_le_bytes(n as u64, size));\n+        u64_to_le_bytes(n as u64, size) {|v| self.write(v); }\n     }\n     fn write_le_int(n: int, size: uint) {\n-        self.write(u64_to_le_bytes(n as u64, size));\n+        u64_to_le_bytes(n as u64, size) {|v| self.write(v); }\n     }\n-\n     fn write_be_uint(n: uint, size: uint) {\n-        self.write(u64_to_be_bytes(n as u64, size));\n+        u64_to_be_bytes(n as u64, size) {|v| self.write(v); }\n     }\n     fn write_be_int(n: int, size: uint) {\n-        self.write(u64_to_be_bytes(n as u64, size));\n+        u64_to_be_bytes(n as u64, size) {|v| self.write(v); }\n+    }\n+    fn write_be_u64(n: u64) {\n+        u64_to_be_bytes(n, 8u) {|v| self.write(v); }\n+    }\n+    fn write_be_u32(n: u32) {\n+        u64_to_be_bytes(n as u64, 4u) {|v| self.write(v); }\n+    }\n+    fn write_be_u16(n: u16) {\n+        u64_to_be_bytes(n as u64, 2u) {|v| self.write(v); }\n+    }\n+    fn write_be_i64(n: i64) {\n+        u64_to_be_bytes(n as u64, 8u) {|v| self.write(v); }\n+    }\n+    fn write_be_i32(n: i32) {\n+        u64_to_be_bytes(n as u64, 4u) {|v| self.write(v); }\n+    }\n+    fn write_be_i16(n: i16) {\n+        u64_to_be_bytes(n as u64, 2u) {|v| self.write(v); }\n+    }\n+    fn write_le_u64(n: u64) {\n+        u64_to_le_bytes(n, 8u) {|v| self.write(v); }\n+    }\n+    fn write_le_u32(n: u32) {\n+        u64_to_le_bytes(n as u64, 4u) {|v| self.write(v); }\n+    }\n+    fn write_le_u16(n: u16) {\n+        u64_to_le_bytes(n as u64, 2u) {|v| self.write(v); }\n+    }\n+    fn write_le_i64(n: i64) {\n+        u64_to_le_bytes(n as u64, 8u) {|v| self.write(v); }\n+    }\n+    fn write_le_i32(n: i32) {\n+        u64_to_le_bytes(n as u64, 4u) {|v| self.write(v); }\n+    }\n+    fn write_le_i16(n: i16) {\n+        u64_to_le_bytes(n as u64, 2u) {|v| self.write(v); }\n     }\n \n-    fn write_be_u64(n: u64) { self.write(u64_to_be_bytes(n, 8u)); }\n-    fn write_be_u32(n: u32) { self.write(u64_to_be_bytes(n as u64, 4u)); }\n-    fn write_be_u16(n: u16) { self.write(u64_to_be_bytes(n as u64, 2u)); }\n-\n-    fn write_be_i64(n: i64) { self.write(u64_to_be_bytes(n as u64, 8u)); }\n-    fn write_be_i32(n: i32) { self.write(u64_to_be_bytes(n as u64, 4u)); }\n-    fn write_be_i16(n: i16) { self.write(u64_to_be_bytes(n as u64, 2u)); }\n-\n-    fn write_le_u64(n: u64) { self.write(u64_to_le_bytes(n, 8u)); }\n-    fn write_le_u32(n: u32) { self.write(u64_to_le_bytes(n as u64, 4u)); }\n-    fn write_le_u16(n: u16) { self.write(u64_to_le_bytes(n as u64, 2u)); }\n-\n-    fn write_le_i64(n: i64) { self.write(u64_to_le_bytes(n as u64, 8u)); }\n-    fn write_le_i32(n: i32) { self.write(u64_to_le_bytes(n as u64, 4u)); }\n-    fn write_le_i16(n: i16) { self.write(u64_to_le_bytes(n as u64, 2u)); }\n-\n-    fn write_u8(n: u8) { self.write([n]) }\n+    fn write_u8(n: u8) { self.write([n]/&) }\n }\n \n fn file_writer(path: str, flags: [fileflag]) -> result<writer, str> {\n@@ -518,7 +578,7 @@ type mem_buffer = @{mut buf: [mut u8],\n                     mut pos: uint};\n \n impl of writer for mem_buffer {\n-    fn write(v: [const u8]) {\n+    fn write(v: [const u8]/&) {\n         // Fast path.\n         if self.pos == vec::len(self.buf) {\n             for vec::each(v) {|b| self.buf += [mut b]; }"}, {"sha": "12258f5eb274a53867212bc2bc71d40679bbe924", "filename": "src/libcore/str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/753b683939f41039ffefe98959faca8dc718c726/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753b683939f41039ffefe98959faca8dc718c726/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=753b683939f41039ffefe98959faca8dc718c726", "patch": "@@ -33,6 +33,7 @@ export\n \n    // Transforming strings\n    bytes,\n+   byte_slice,\n    chars,\n    substr,\n    slice,\n@@ -323,6 +324,16 @@ fn bytes(s: str) -> [u8] unsafe {\n     ret v;\n }\n \n+#[doc = \"\n+Work with the string as a byte slice, not including trailing null.\n+\"]\n+#[inline(always)]\n+fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n+    unpack_slice(s) {|p,n|\n+        vec::unsafe::form_slice(p, n-1u, f)\n+    }\n+}\n+\n #[doc = \"Convert a string to a vector of characters\"]\n fn chars(s: str) -> [char] {\n     let mut buf = [], i = 0u;\n@@ -1549,6 +1560,7 @@ length of the string. This is to permit probing the byte past the\n indexable area for a null byte, as is the case in slices pointing\n to full strings, or suffixes of them.\n \"]\n+#[inline(always)]\n fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T unsafe {\n     let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     let (buf,len) = *v;"}, {"sha": "191012e51560fc75893db6296261c696597561b4", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/753b683939f41039ffefe98959faca8dc718c726/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753b683939f41039ffefe98959faca8dc718c726/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=753b683939f41039ffefe98959faca8dc718c726", "patch": "@@ -150,9 +150,8 @@ fn capacity<T>(&&v: [const T]) -> uint unsafe {\n \n #[doc = \"Returns the length of a vector\"]\n #[inline(always)]\n-pure fn len<T>(&&v: [const T]) -> uint unsafe {\n-    let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n-    (**repr).fill / sys::size_of::<T>()\n+pure fn len<T>(&&v: [const T]/&) -> uint unsafe {\n+    unpack_slice(v) {|_p, len| len}\n }\n \n #[doc = \"\n@@ -823,27 +822,31 @@ fn iter_between<T>(v: [const T], start: uint, end: uint, f: fn(T)) {\n Iterates over a vector, with option to break\n \"]\n #[inline(always)]\n-fn each<T>(v: [const T], f: fn(T) -> bool) unsafe {\n-    let mut n = len(v);\n-    let mut p = ptr::offset(unsafe::to_ptr(v), 0u);\n-    while n > 0u {\n-        if !f(*p) { break; }\n-        p = ptr::offset(p, 1u);\n-        n -= 1u;\n+fn each<T>(v: [const T]/&, f: fn(T) -> bool) unsafe {\n+    vec::unpack_slice(v) {|p, n|\n+        let mut n = n;\n+        let mut p = p;\n+        while n > 0u {\n+            if !f(*p) { break; }\n+            p = ptr::offset(p, 1u);\n+            n -= 1u;\n+        }\n     }\n }\n \n #[doc = \"\n Iterates over a vector's elements and indices\n \"]\n #[inline(always)]\n-fn eachi<T>(v: [const T], f: fn(uint, T) -> bool) unsafe {\n-    let mut i = 0u, l = len(v);\n-    let mut p = ptr::offset(unsafe::to_ptr(v), 0u);\n-    while i < l {\n-        if !f(i, *p) { break; }\n-        p = ptr::offset(p, 1u);\n-        i += 1u;\n+fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) unsafe {\n+    vec::unpack_slice(v) {|p, n|\n+        let mut i = 0u;\n+        let mut p = p;\n+        while i < n {\n+            if !f(i, *p) { break; }\n+            p = ptr::offset(p, 1u);\n+            i += 1u;\n+        }\n     }\n }\n \n@@ -958,6 +961,7 @@ fn as_mut_buf<E,T>(v: [mut E], f: fn(*mut E) -> T) -> T unsafe {\n #[doc = \"\n Work with the buffer and length of a slice.\n \"]\n+#[inline(always)]\n fn unpack_slice<T,U>(s: [const T]/&, f: fn(*T, uint) -> U) -> U unsafe {\n     let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     let (buf,len) = *v;\n@@ -1191,6 +1195,17 @@ mod unsafe {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n+\n+\n+    #[doc = \"\n+    Form a slice from a pointer and length (as a number of units, not bytes).\n+    \"]\n+    #[inline(always)]\n+    unsafe fn form_slice<T,U>(p: *T, len: uint, f: fn([T]/&) -> U) -> U {\n+        let pair = (p, len * sys::size_of::<T>());\n+        let v : *([T]/&) = ::unsafe::reinterpret_cast(ptr::addr_of(pair));\n+        f(*v)\n+    }\n }\n \n #[doc = \"Operations on `[u8]`\"]"}, {"sha": "ba7064bd5c46f03c45ed7623d71e4f0a910fc95c", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/753b683939f41039ffefe98959faca8dc718c726/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753b683939f41039ffefe98959faca8dc718c726/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=753b683939f41039ffefe98959faca8dc718c726", "patch": "@@ -39,7 +39,7 @@ type doc = {data: @[u8], start: uint, end: uint};\n \n type tagged_doc = {tag: uint, doc: doc};\n \n-fn vuint_at(data: [u8], start: uint) -> {val: uint, next: uint} {\n+fn vuint_at(data: [u8]/&, start: uint) -> {val: uint, next: uint} {\n     let a = data[start];\n     if a & 0x80u8 != 0u8 {\n         ret {val: (a & 0x7fu8) as uint, next: start + 1u};\n@@ -152,20 +152,23 @@ fn doc_as_i64(d: doc) -> i64 { doc_as_u64(d) as i64 }\n type writer = {writer: io::writer, mut size_positions: [uint]};\n \n fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n-    let buf: [u8] = alt size {\n-      1u { [0x80u8 | (n as u8)] }\n-      2u { [0x40u8 | ((n >> 8_u) as u8), n as u8] }\n+    alt size {\n+      1u {\n+        w.write([0x80u8 | (n as u8)]/&);\n+      }\n+      2u {\n+        w.write([0x40u8 | ((n >> 8_u) as u8), n as u8]/&);\n+      }\n       3u {\n-        [0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n-               n as u8]\n+        w.write([0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+                 n as u8]/&);\n       }\n       4u {\n-        [0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n-               (n >> 8_u) as u8, n as u8]\n+        w.write([0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+                 (n >> 8_u) as u8, n as u8]/&);\n       }\n       _ { fail #fmt(\"vint to write too big: %?\", n); }\n     };\n-    w.write(buf);\n }\n \n fn write_vuint(w: io::writer, n: uint) {\n@@ -191,7 +194,7 @@ impl writer for writer {\n \n         // Write a placeholder four-byte size.\n         self.size_positions += [self.writer.tell()];\n-        let zeroes: [u8] = [0u8, 0u8, 0u8, 0u8];\n+        let zeroes: [u8]/& = [0u8, 0u8, 0u8, 0u8]/&;\n         self.writer.write(zeroes);\n     }\n \n@@ -212,42 +215,54 @@ impl writer for writer {\n         self.end_tag();\n     }\n \n-    fn wr_tagged_bytes(tag_id: uint, b: [u8]) {\n+    fn wr_tagged_bytes(tag_id: uint, b: [u8]/&) {\n         write_vuint(self.writer, tag_id);\n         write_vuint(self.writer, vec::len(b));\n         self.writer.write(b);\n     }\n \n     fn wr_tagged_u64(tag_id: uint, v: u64) {\n-        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v, 8u));\n+        io::u64_to_be_bytes(v, 8u) {|v|\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n     }\n \n     fn wr_tagged_u32(tag_id: uint, v: u32) {\n-        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 4u));\n+        io::u64_to_be_bytes(v as u64, 4u) {|v|\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n     }\n \n     fn wr_tagged_u16(tag_id: uint, v: u16) {\n-        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 2u));\n+        io::u64_to_be_bytes(v as u64, 2u) {|v|\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n     }\n \n     fn wr_tagged_u8(tag_id: uint, v: u8) {\n-        self.wr_tagged_bytes(tag_id, [v]);\n+        self.wr_tagged_bytes(tag_id, [v]/&);\n     }\n \n     fn wr_tagged_i64(tag_id: uint, v: i64) {\n-        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 8u));\n+        io::u64_to_be_bytes(v as u64, 8u) {|v|\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n     }\n \n     fn wr_tagged_i32(tag_id: uint, v: i32) {\n-        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 4u));\n+        io::u64_to_be_bytes(v as u64, 4u) {|v|\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n     }\n \n     fn wr_tagged_i16(tag_id: uint, v: i16) {\n-        self.wr_tagged_bytes(tag_id, io::u64_to_be_bytes(v as u64, 2u));\n+        io::u64_to_be_bytes(v as u64, 2u) {|v|\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n     }\n \n     fn wr_tagged_i8(tag_id: uint, v: i8) {\n-        self.wr_tagged_bytes(tag_id, [v as u8]);\n+        self.wr_tagged_bytes(tag_id, [v as u8]/&);\n     }\n \n     fn wr_tagged_str(tag_id: uint, v: str) {\n@@ -260,7 +275,7 @@ impl writer for writer {\n         self.wr_tagged_bytes(tag_id, str::bytes(v));\n     }\n \n-    fn wr_bytes(b: [u8]) {\n+    fn wr_bytes(b: [u8]/&) {\n         #debug[\"Write %u bytes\", vec::len(b)];\n         self.writer.write(b);\n     }"}, {"sha": "ae3bc4e0a2cec8f558a5d03dafcd5b056f1d030a", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/753b683939f41039ffefe98959faca8dc718c726/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753b683939f41039ffefe98959faca8dc718c726/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=753b683939f41039ffefe98959faca8dc718c726", "patch": "@@ -62,7 +62,7 @@ fn encode_named_def_id(ebml_w: ebml::writer, name: str, id: def_id) {\n fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n     ebml_w.wr_tag(tag_class_mut) {||\n         ebml_w.writer.write([alt mt { class_immutable { 'i' }\n-                class_mutable { 'm' } } as u8]);\n+                class_mutable { 'm' } } as u8]/&);\n         }\n }\n \n@@ -230,7 +230,7 @@ fn encode_reexport_paths(ebml_w: ebml::writer,\n // Item info table encoding\n fn encode_family(ebml_w: ebml::writer, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n-    ebml_w.writer.write([c as u8]);\n+    ebml_w.writer.write([c as u8]/&);\n     ebml_w.end_tag();\n }\n \n@@ -1016,7 +1016,7 @@ fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> [u8] {\n \n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n-    buf_w.write([0u8, 0u8, 0u8, 0u8]);\n+    buf_w.write([0u8, 0u8, 0u8, 0u8]/&);\n     io::mem_buffer_buf(buf)\n }\n "}, {"sha": "763e710b07af770ff919c90ad4d35f97701f2a8f", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/753b683939f41039ffefe98959faca8dc718c726/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753b683939f41039ffefe98959faca8dc718c726/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=753b683939f41039ffefe98959faca8dc718c726", "patch": "@@ -190,45 +190,45 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         alt t {\n           ty_i { w.write_char('i'); }\n           ty_char { w.write_char('c'); }\n-          ty_i8 { w.write_str(\"MB\"); }\n-          ty_i16 { w.write_str(\"MW\"); }\n-          ty_i32 { w.write_str(\"ML\"); }\n-          ty_i64 { w.write_str(\"MD\"); }\n+          ty_i8 { w.write_str(\"MB\"/&); }\n+          ty_i16 { w.write_str(\"MW\"/&); }\n+          ty_i32 { w.write_str(\"ML\"/&); }\n+          ty_i64 { w.write_str(\"MD\"/&); }\n         }\n       }\n       ty::ty_uint(t) {\n         alt t {\n           ty_u { w.write_char('u'); }\n-          ty_u8 { w.write_str(\"Mb\"); }\n-          ty_u16 { w.write_str(\"Mw\"); }\n-          ty_u32 { w.write_str(\"Ml\"); }\n-          ty_u64 { w.write_str(\"Md\"); }\n+          ty_u8 { w.write_str(\"Mb\"/&); }\n+          ty_u16 { w.write_str(\"Mw\"/&); }\n+          ty_u32 { w.write_str(\"Ml\"/&); }\n+          ty_u64 { w.write_str(\"Md\"/&); }\n         }\n       }\n       ty::ty_float(t) {\n         alt t {\n           ty_f { w.write_char('l'); }\n-          ty_f32 { w.write_str(\"Mf\"); }\n-          ty_f64 { w.write_str(\"MF\"); }\n+          ty_f32 { w.write_str(\"Mf\"/&); }\n+          ty_f64 { w.write_str(\"MF\"/&); }\n         }\n       }\n       ty::ty_str { w.write_char('S'); }\n       ty::ty_enum(def, substs) {\n-        w.write_str(\"t[\");\n+        w.write_str(\"t[\"/&);\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n       ty::ty_iface(def, tys) {\n-        w.write_str(\"x[\");\n+        w.write_str(\"x[\"/&);\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         for tys.each {|t| enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) {\n-        w.write_str(\"T[\");\n+        w.write_str(\"T[\"/&);\n         for ts.each {|t| enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n@@ -251,7 +251,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_vec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n-        w.write_str(\"R[\");\n+        w.write_str(\"R[\"/&);\n         for fields.each {|field|\n             w.write_str(field.ident);\n             w.write_char('=');\n@@ -264,7 +264,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         enc_ty_fn(w, cx, f);\n       }\n       ty::ty_res(def, ty, substs) {\n-        w.write_str(\"r[\");\n+        w.write_str(\"r[\"/&);\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_ty(w, cx, ty);\n@@ -282,29 +282,29 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_str(uint::str(id));\n       }\n       ty::ty_self(tps) {\n-        w.write_str(\"s[\");\n+        w.write_str(\"s[\"/&);\n         for tps.each {|t| enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_type { w.write_char('Y'); }\n-      ty::ty_opaque_closure_ptr(ty::ck_block) { w.write_str(\"C&\"); }\n-      ty::ty_opaque_closure_ptr(ty::ck_box) { w.write_str(\"C@\"); }\n-      ty::ty_opaque_closure_ptr(ty::ck_uniq) { w.write_str(\"C~\"); }\n+      ty::ty_opaque_closure_ptr(ty::ck_block) { w.write_str(\"C&\"/&); }\n+      ty::ty_opaque_closure_ptr(ty::ck_box) { w.write_str(\"C@\"/&); }\n+      ty::ty_opaque_closure_ptr(ty::ck_uniq) { w.write_str(\"C~\"/&); }\n       ty::ty_constr(ty, cs) {\n-        w.write_str(\"A[\");\n+        w.write_str(\"A[\"/&);\n         enc_ty(w, cx, ty);\n         for cs.each {|tc| enc_ty_constr(w, cx, tc); }\n         w.write_char(']');\n       }\n       ty::ty_opaque_box { w.write_char('B'); }\n       ty::ty_class(def, substs) {\n           #debug(\"~~~~ %s\", \"a[\");\n-          w.write_str(\"a[\");\n+          w.write_str(\"a[\"/&);\n           let s = cx.ds(def);\n           #debug(\"~~~~ %s\", s);\n           w.write_str(s);\n           #debug(\"~~~~ %s\", \"|\");\n-          w.write_str(\"|\");\n+          w.write_char('|');\n           enc_substs(w, cx, substs);\n           #debug(\"~~~~ %s\", \"]\");\n           w.write_char(']');\n@@ -313,11 +313,11 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n }\n fn enc_proto(w: io::writer, proto: proto) {\n     alt proto {\n-      proto_uniq { w.write_str(\"f~\"); }\n-      proto_box { w.write_str(\"f@\"); }\n+      proto_uniq { w.write_str(\"f~\"/&); }\n+      proto_box { w.write_str(\"f@\"/&); }\n       proto_block { w.write_str(\"f&\"); }\n-      proto_any { w.write_str(\"f*\"); }\n-      proto_bare { w.write_str(\"fn\"); }\n+      proto_any { w.write_str(\"f*\"/&); }\n+      proto_bare { w.write_str(\"fn\"/&); }\n     }\n }\n "}, {"sha": "12067f83cc66b034ec0820a6c02f36b6b25dec97", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753b683939f41039ffefe98959faca8dc718c726/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753b683939f41039ffefe98959faca8dc718c726/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=753b683939f41039ffefe98959faca8dc718c726", "patch": "@@ -80,7 +80,7 @@ fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n type devnull = {dn: int};\n \n impl of io::writer for devnull {\n-    fn write(_b: [const u8]) {}\n+    fn write(_b: [const u8]/&) {}\n     fn seek(_i: int, _s: io::seek_style) {}\n     fn tell() -> uint {0_u}\n     fn flush() -> int {0}"}]}