{"sha": "0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMzdkNGJiMWQxYjhkZjIxZTFlNGM4YTYzNDEyN2NlZTg3MWY3YWI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-14T05:24:30Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-19T22:13:35Z"}, "message": "refactoring", "tree": {"sha": "e6f830d81f641a13c0d34ecf5d3bd37842af13b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6f830d81f641a13c0d34ecf5d3bd37842af13b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "html_url": "https://github.com/rust-lang/rust/commit/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "html_url": "https://github.com/rust-lang/rust/commit/84c3f898f93e294f2e50ceef271bd781b1ff6b9a"}], "stats": {"total": 252, "additions": 111, "deletions": 141}, "files": [{"sha": "c9d93319c03a8a42dc8aceeb6fc1f40c4588fcc4", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 55, "deletions": 60, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "patch": "@@ -70,6 +70,13 @@ impl<'ast> NodeCollector<'ast> {\n         let entry = MapEntry::from_node(self.parent_node, node);\n         self.insert_entry(id, entry);\n     }\n+\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_id: NodeId, f: F) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = parent_id;\n+        f(self);\n+        self.parent_node = parent_node;\n+    }\n }\n \n impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n@@ -86,51 +93,48 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n         self.insert(i.id, NodeItem(i));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = i.id;\n-\n-        match i.node {\n-            ItemEnum(ref enum_definition, _) => {\n-                for v in &enum_definition.variants {\n-                    self.insert(v.node.data.id(), NodeVariant(v));\n+        self.with_parent(i.id, |this| {\n+            match i.node {\n+                ItemEnum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        this.insert(v.node.data.id(), NodeVariant(v));\n+                    }\n                 }\n-            }\n-            ItemStruct(ref struct_def, _) => {\n-                // If this is a tuple-like struct, register the constructor.\n-                if !struct_def.is_struct() {\n-                    self.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                ItemStruct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                    }\n                 }\n-            }\n-            ItemTrait(_, _, ref bounds, _) => {\n-                for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n-                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n+                ItemTrait(_, _, ref bounds, _) => {\n+                    for b in bounds.iter() {\n+                        if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n+                            this.insert(t.trait_ref.ref_id, NodeItem(i));\n+                        }\n                     }\n                 }\n-            }\n-            ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.insert(path.node.id(), NodeItem(i));\n+                ItemUse(ref view_path) => {\n+                    match view_path.node {\n+                        ViewPathList(_, ref paths) => {\n+                            for path in paths {\n+                                this.insert(path.node.id(), NodeItem(i));\n+                            }\n                         }\n+                        _ => ()\n                     }\n-                    _ => ()\n                 }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, i);\n-        self.parent_node = parent_node;\n+            intravisit::walk_item(this, i);\n+        });\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = foreign_item.id;\n-        intravisit::walk_foreign_item(self, foreign_item);\n-        self.parent_node = parent_node;\n+        self.with_parent(foreign_item.id, |this| {\n+            intravisit::walk_foreign_item(this, foreign_item);\n+        });\n     }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n@@ -144,50 +148,42 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n         self.insert(ti.id, NodeTraitItem(ti));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = ti.id;\n-\n-        intravisit::walk_trait_item(self, ti);\n-\n-        self.parent_node = parent_node;\n+        self.with_parent(ti.id, |this| {\n+            intravisit::walk_trait_item(this, ti);\n+        });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n         self.insert(ii.id, NodeImplItem(ii));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = ii.id;\n-\n-        intravisit::walk_impl_item(self, ii);\n-\n-        self.parent_node = parent_node;\n+        self.with_parent(ii.id, |this| {\n+            intravisit::walk_impl_item(this, ii);\n+        });\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         self.insert(pat.id, NodeLocal(pat));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = pat.id;\n-        intravisit::walk_pat(self, pat);\n-        self.parent_node = parent_node;\n+        self.with_parent(pat.id, |this| {\n+            intravisit::walk_pat(this, pat);\n+        });\n     }\n \n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.insert(expr.id, NodeExpr(expr));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = expr.id;\n-        intravisit::walk_expr(self, expr);\n-        self.parent_node = parent_node;\n+        self.with_parent(expr.id, |this| {\n+            intravisit::walk_expr(this, expr);\n+        });\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n         let id = stmt.node.id();\n         self.insert(id, NodeStmt(stmt));\n-        let parent_node = self.parent_node;\n-        self.parent_node = id;\n-        intravisit::walk_stmt(self, stmt);\n-        self.parent_node = parent_node;\n+\n+        self.with_parent(id, |this| {\n+            intravisit::walk_stmt(this, stmt);\n+        });\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n@@ -198,10 +194,9 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_block(&mut self, block: &'ast Block) {\n         self.insert(block.id, NodeBlock(block));\n-        let parent_node = self.parent_node;\n-        self.parent_node = block.id;\n-        intravisit::walk_block(self, block);\n-        self.parent_node = parent_node;\n+        self.with_parent(block.id, |this| {\n+            intravisit::walk_block(this, block);\n+        });\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {"}, {"sha": "9d6027932f6dea9938ca8134001845813cf57658", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 54, "deletions": 78, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "patch": "@@ -16,16 +16,14 @@ use syntax::ast::*;\n use syntax::visit;\n \n /// Creates def ids for nodes in the HIR.\n-pub struct DefCollector<'ast> {\n-    pub krate: &'ast Crate,\n+pub struct DefCollector {\n     pub definitions: Definitions,\n     pub parent_def: Option<DefIndex>,\n }\n \n-impl<'ast> DefCollector<'ast> {\n-    pub fn root(krate: &'ast Crate) -> DefCollector<'ast> {\n+impl DefCollector {\n+    pub fn root() -> DefCollector {\n         let mut collector = DefCollector {\n-            krate: krate,\n             definitions: Definitions::new(),\n             parent_def: None,\n         };\n@@ -37,14 +35,12 @@ impl<'ast> DefCollector<'ast> {\n         collector\n     }\n \n-    pub fn extend(krate: &'ast Crate,\n-                  parent_node: NodeId,\n+    pub fn extend(parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n                   definitions: Definitions)\n-                  -> DefCollector<'ast> {\n+                  -> DefCollector {\n         let mut collector = DefCollector {\n-            krate: krate,\n             parent_def: None,\n             definitions: definitions,\n         };\n@@ -78,9 +74,16 @@ impl<'ast> DefCollector<'ast> {\n                               -> DefIndex {\n         self.definitions.create_def_with_parent(parent, node_id, data)\n     }\n+\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+        let parent = self.parent_def;\n+        self.parent_def = Some(parent_def);\n+        f(self);\n+        self.parent_def = parent;\n+    }\n }\n \n-impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n+impl<'ast> visit::Visitor<'ast> for DefCollector {\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -98,60 +101,55 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n             ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name),\n             ItemKind::Use(..) => DefPathData::Misc,\n         };\n-\n         let def = self.create_def(i.id, def_data);\n \n-        let parent_def = self.parent_def;\n-        self.parent_def = Some(def);\n-\n-        match i.node {\n-            ItemKind::Enum(ref enum_definition, _) => {\n-                for v in &enum_definition.variants {\n-                    let variant_def_index =\n-                        self.create_def(v.node.data.id(),\n-                                        DefPathData::EnumVariant(v.node.name.name));\n-\n-                    for field in v.node.data.fields() {\n-                        if let Some(ident) = field.ident {\n-                            self.create_def_with_parent(Some(variant_def_index),\n-                                                        field.id,\n-                                                        DefPathData::Field(ident.name));\n+        self.with_parent(def, |this| {\n+            match i.node {\n+                ItemKind::Enum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        let variant_def_index =\n+                            this.create_def(v.node.data.id(),\n+                                            DefPathData::EnumVariant(v.node.name.name));\n+\n+                        for field in v.node.data.fields() {\n+                            if let Some(ident) = field.ident {\n+                                this.create_def_with_parent(Some(variant_def_index),\n+                                                            field.id,\n+                                                            DefPathData::Field(ident.name));\n+                            }\n                         }\n                     }\n                 }\n-            }\n-            ItemKind::Struct(ref struct_def, _) => {\n-                // If this is a tuple-like struct, register the constructor.\n-                if !struct_def.is_struct() {\n-                    self.create_def(struct_def.id(),\n-                                    DefPathData::StructCtor);\n-                }\n+                ItemKind::Struct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.create_def(struct_def.id(),\n+                                        DefPathData::StructCtor);\n+                    }\n \n-                for field in struct_def.fields() {\n-                    if let Some(ident) = field.ident {\n-                        self.create_def(field.id, DefPathData::Field(ident.name));\n+                    for field in struct_def.fields() {\n+                        if let Some(ident) = field.ident {\n+                            this.create_def(field.id, DefPathData::Field(ident.name));\n+                        }\n                     }\n                 }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n-        visit::walk_item(self, i);\n-        self.parent_def = parent_def;\n+            visit::walk_item(this, i);\n+        });\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.ident.name));\n \n-        let parent_def = self.parent_def;\n-        self.parent_def = Some(def);\n-        visit::walk_foreign_item(self, foreign_item);\n-        self.parent_def = parent_def;\n+        self.with_parent(def, |this| {\n+            visit::walk_foreign_item(this, foreign_item);\n+        });\n     }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.ident.name));\n+            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name));\n         }\n \n         visit::walk_generics(self, generics);\n@@ -165,20 +163,13 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         };\n \n         let def = self.create_def(ti.id, def_data);\n-\n-        let parent_def = self.parent_def;\n-        self.parent_def = Some(def);\n-\n-        match ti.node {\n-            TraitItemKind::Const(_, Some(ref expr)) => {\n-                self.create_def(expr.id, DefPathData::Initializer);\n+        self.with_parent(def, |this| {\n+            if let TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n             }\n-            _ => { }\n-        }\n-\n-        visit::walk_trait_item(self, ti);\n \n-        self.parent_def = parent_def;\n+            visit::walk_trait_item(this, ti);\n+        });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n@@ -190,20 +181,13 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         };\n \n         let def = self.create_def(ii.id, def_data);\n-\n-        let parent_def = self.parent_def;\n-        self.parent_def = Some(def);\n-\n-        match ii.node {\n-            ImplItemKind::Const(_, ref expr) => {\n-                self.create_def(expr.id, DefPathData::Initializer);\n+        self.with_parent(def, |this| {\n+            if let ImplItemKind::Const(_, ref expr) = ii.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n             }\n-            _ => { }\n-        }\n-\n-        visit::walk_impl_item(self, ii);\n \n-        self.parent_def = parent_def;\n+            visit::walk_impl_item(this, ii);\n+        });\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n@@ -234,14 +218,6 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        visit::walk_stmt(self, stmt);\n-    }\n-\n-    fn visit_block(&mut self, block: &'ast Block) {\n-        visit::walk_block(self, block);\n-    }\n-\n     fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n     }"}, {"sha": "a505ad198896f585b85b11f9a22433575476c80c", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=0c37d4bb1d1b8df21e1e4c8a634127cee871f7ab", "patch": "@@ -784,7 +784,7 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n }\n \n pub fn collect_definitions<'ast>(krate: &'ast ast::Crate) -> Definitions {\n-    let mut def_collector = DefCollector::root(krate);\n+    let mut def_collector = DefCollector::root();\n     visit::walk_crate(&mut def_collector, krate);\n     def_collector.definitions\n }\n@@ -845,8 +845,7 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n \n     // TODO need to save defs in metadata :-(\n     // let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n-    // let mut def_collector = DefCollector::extend(map.krate(),\n-    //                                              ii_parent_id,\n+    // let mut def_collector = DefCollector::extend(ii_parent_id,\n     //                                              parent_def_path.clone(),\n     //                                              parent_def_id,\n     //                                              defs);"}]}