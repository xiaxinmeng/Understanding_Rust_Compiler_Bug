{"sha": "eebf6743d88509412308553e7172e89157f9b981", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYmY2NzQzZDg4NTA5NDEyMzA4NTUzZTcxNzJlODkxNTdmOWI5ODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-09T15:10:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-09T15:10:37Z"}, "message": "Auto merge of #30140 - michaelwoerister:tls-encoding, r=nikomatsakis\n\nWith this commit, metadata encoding and decoding can make use of thread-local encoding and decoding contexts. These allow implementers of `serialize::Encodable` and `Decodable` to access information and\ndatastructures that would otherwise not be available to them. For example, we can automatically translate def-id and span information during decoding because the decoding context knows which crate the data is decoded from. Or it allows to make `ty::Ty` decodable because the context has access to the `ty::ctxt` that is needed for creating `ty::Ty` instances.\n\nSome notes:\n- `tls::with_encoding_context()` and `tls::with_decoding_context()` (as opposed to their unsafe versions) try to prevent the TLS data getting out-of-sync by making sure that the encoder/decoder passed in is actually the same as the one stored in the context. This should prevent accidentally reading from the wrong decoder.\n- There are no real tests in this PR. I had a unit tests for some of the core aspects of the TLS implementation but it was kind of brittle, a lot of code for mocking `ty::ctxt`, `crate_metadata`, etc and did actually test not so much. The code will soon be tested by the first incremental compilation auto-tests that rely on MIR being properly serialized. However, if people think that some tests should be added before this can land, I'll try to provide some that make sense.\n\nr? @nikomatsakis", "tree": {"sha": "50c9ed79e575184605eb0d8fe07cb9d30ab71c84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50c9ed79e575184605eb0d8fe07cb9d30ab71c84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eebf6743d88509412308553e7172e89157f9b981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eebf6743d88509412308553e7172e89157f9b981", "html_url": "https://github.com/rust-lang/rust/commit/eebf6743d88509412308553e7172e89157f9b981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eebf6743d88509412308553e7172e89157f9b981/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e48b593ca613c5deea5503e0dd1d94dce70ab54", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e48b593ca613c5deea5503e0dd1d94dce70ab54", "html_url": "https://github.com/rust-lang/rust/commit/2e48b593ca613c5deea5503e0dd1d94dce70ab54"}, {"sha": "f65823e39cad10c956d57e5242152e0b41326844", "url": "https://api.github.com/repos/rust-lang/rust/commits/f65823e39cad10c956d57e5242152e0b41326844", "html_url": "https://github.com/rust-lang/rust/commit/f65823e39cad10c956d57e5242152e0b41326844"}], "stats": {"total": 558, "additions": 450, "deletions": 108}, "files": [{"sha": "7ad0a99aadae9f1b4cb5b894828d2eef75887368", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -88,7 +88,7 @@ DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n \n DEPS_syntax := std term serialize log fmt_macros arena libc rustc_bitflags\n \n-DEPS_rustc := syntax flate arena serialize getopts rustc_front\\\n+DEPS_rustc := syntax flate arena serialize getopts rbml rustc_front\\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\n DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax"}, {"sha": "3c0c9951613e3db7fcf147f55e79040c601d2abc", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -638,6 +638,14 @@ pub mod reader {\n             self.pos = old_pos;\n             Ok(result)\n         }\n+\n+        pub fn position(&self) -> usize {\n+            self.pos\n+        }\n+\n+        pub fn advance(&mut self, bytes: usize) {\n+            self.pos += bytes;\n+        }\n     }\n \n     impl<'doc> serialize::Decoder for Decoder<'doc> {"}, {"sha": "0890594f2b1163a6f14f727a5a7f3df929b698b6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -59,6 +59,7 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n+extern crate rbml;\n extern crate rustc_llvm;\n extern crate rustc_back;\n extern crate rustc_front;"}, {"sha": "4efa7bfac181368ac54a9c9bc2f07a865437bf55", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -407,3 +407,141 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                        krate: &hir::Crate) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { unimplemented!() }\n }\n+\n+\n+/// Metadata encoding and decoding can make use of thread-local encoding and\n+/// decoding contexts. These allow implementers of serialize::Encodable and\n+/// Decodable to access information and datastructures that would otherwise not\n+/// be available to them. For example, we can automatically translate def-id and\n+/// span information during decoding because the decoding context knows which\n+/// crate the data is decoded from. Or it allows to make ty::Ty decodable\n+/// because the context has access to the ty::ctxt that is needed for creating\n+/// ty::Ty instances.\n+///\n+/// Note, however, that this only works for RBML-based encoding and decoding at\n+/// the moment.\n+pub mod tls {\n+    use rbml::writer::Encoder as RbmlEncoder;\n+    use rbml::reader::Decoder as RbmlDecoder;\n+    use serialize;\n+    use std::mem;\n+    use middle::ty::{self, Ty};\n+    use middle::subst::Substs;\n+    use middle::def_id::DefId;\n+\n+    pub trait EncodingContext<'tcx> {\n+        fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n+        fn encode_ty(&self, rbml_w: &mut RbmlEncoder, t: Ty<'tcx>);\n+        fn encode_substs(&self, rbml_w: &mut RbmlEncoder, substs: &Substs<'tcx>);\n+    }\n+\n+    /// Marker type used for the scoped TLS slot.\n+    /// The type context cannot be used directly because the scoped TLS\n+    /// in libstd doesn't allow types generic over lifetimes.\n+    struct TlsPayload;\n+\n+    scoped_thread_local!(static TLS_ENCODING: TlsPayload);\n+\n+    /// Execute f after pushing the given EncodingContext onto the TLS stack.\n+    pub fn enter_encoding_context<'tcx, F, R>(ecx: &EncodingContext<'tcx>,\n+                                              rbml_w: &mut RbmlEncoder,\n+                                              f: F) -> R\n+        where F: FnOnce(&EncodingContext<'tcx>, &mut RbmlEncoder) -> R\n+    {\n+        let tls_payload = (ecx as *const _, rbml_w as *mut _);\n+        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n+        TLS_ENCODING.set(unsafe { &*tls_ptr }, || f(ecx, rbml_w))\n+    }\n+\n+    /// Execute f with access to the thread-local encoding context and\n+    /// rbml encoder. This function will panic if the encoder passed in and the\n+    /// context encoder are not the same.\n+    ///\n+    /// Note that this method is 'practically' safe due to its checking that the\n+    /// encoder passed in is the same as the one in TLS, but it would still be\n+    /// possible to construct cases where the EncodingContext is exchanged\n+    /// while the same encoder is used, thus working with a wrong context.\n+    pub fn with_encoding_context<'tcx, E, F, R>(encoder: &mut E, f: F) -> R\n+        where F: FnOnce(&EncodingContext<'tcx>, &mut RbmlEncoder) -> R,\n+              E: serialize::Encoder\n+    {\n+        unsafe {\n+            unsafe_with_encoding_context(|ecx, rbml_w| {\n+                assert!(encoder as *mut _ as usize == rbml_w as *mut _ as usize);\n+\n+                let ecx: &EncodingContext<'tcx> = mem::transmute(ecx);\n+\n+                f(ecx, rbml_w)\n+            })\n+        }\n+    }\n+\n+    /// Execute f with access to the thread-local encoding context and\n+    /// rbml encoder.\n+    pub unsafe fn unsafe_with_encoding_context<F, R>(f: F) -> R\n+        where F: FnOnce(&EncodingContext, &mut RbmlEncoder) -> R\n+    {\n+        TLS_ENCODING.with(|tls| {\n+            let tls_payload = (tls as *const TlsPayload)\n+                                   as *mut (&EncodingContext, &mut RbmlEncoder);\n+            f((*tls_payload).0, (*tls_payload).1)\n+        })\n+    }\n+\n+    pub trait DecodingContext<'tcx> {\n+        fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n+        fn decode_ty(&self, rbml_r: &mut RbmlDecoder) -> ty::Ty<'tcx>;\n+        fn decode_substs(&self, rbml_r: &mut RbmlDecoder) -> Substs<'tcx>;\n+        fn translate_def_id(&self, def_id: DefId) -> DefId;\n+    }\n+\n+    scoped_thread_local!(static TLS_DECODING: TlsPayload);\n+\n+    /// Execute f after pushing the given DecodingContext onto the TLS stack.\n+    pub fn enter_decoding_context<'tcx, F, R>(dcx: &DecodingContext<'tcx>,\n+                                              rbml_r: &mut RbmlDecoder,\n+                                              f: F) -> R\n+        where F: FnOnce(&DecodingContext<'tcx>, &mut RbmlDecoder) -> R\n+    {\n+        let tls_payload = (dcx as *const _, rbml_r as *mut _);\n+        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n+        TLS_DECODING.set(unsafe { &*tls_ptr }, || f(dcx, rbml_r))\n+    }\n+\n+    /// Execute f with access to the thread-local decoding context and\n+    /// rbml decoder. This function will panic if the decoder passed in and the\n+    /// context decoder are not the same.\n+    ///\n+    /// Note that this method is 'practically' safe due to its checking that the\n+    /// decoder passed in is the same as the one in TLS, but it would still be\n+    /// possible to construct cases where the DecodingContext is exchanged\n+    /// while the same decoder is used, thus working with a wrong context.\n+    pub fn with_decoding_context<'decoder, 'tcx, D, F, R>(d: &'decoder mut D, f: F) -> R\n+        where D: serialize::Decoder,\n+              F: FnOnce(&DecodingContext<'tcx>,\n+                        &mut RbmlDecoder) -> R,\n+              'tcx: 'decoder\n+    {\n+        unsafe {\n+            unsafe_with_decoding_context(|dcx, rbml_r| {\n+                assert!((d as *mut _ as usize) == (rbml_r as *mut _ as usize));\n+\n+                let dcx: &DecodingContext<'tcx> = mem::transmute(dcx);\n+\n+                f(dcx, rbml_r)\n+            })\n+        }\n+    }\n+\n+    /// Execute f with access to the thread-local decoding context and\n+    /// rbml decoder.\n+    pub unsafe fn unsafe_with_decoding_context<F, R>(f: F) -> R\n+        where F: FnOnce(&DecodingContext, &mut RbmlDecoder) -> R\n+    {\n+        TLS_DECODING.with(|tls| {\n+            let tls_payload = (tls as *const TlsPayload)\n+                                   as *mut (&DecodingContext, &mut RbmlDecoder);\n+            f((*tls_payload).0, (*tls_payload).1)\n+        })\n+    }\n+}"}, {"sha": "aa47b32dc3e4df2113fe26ed26a7dcb63f8ffde6", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -13,9 +13,11 @@\n pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n+use middle::cstore;\n use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n use middle::ty::fold::{TypeFoldable, TypeFolder};\n \n+use serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::fmt;\n use std::iter::IntoIterator;\n use std::slice::Iter;\n@@ -153,6 +155,35 @@ impl<'tcx> Substs<'tcx> {\n     }\n }\n \n+impl<'tcx> Encodable for Substs<'tcx> {\n+\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n+            ecx.encode_substs(rbml_w, self);\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<'tcx> Decodable for Substs<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Substs<'tcx>, D::Error> {\n+        cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n+            Ok(dcx.decode_substs(rbml_r))\n+        })\n+    }\n+}\n+\n+impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error> {\n+        let substs = cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n+            let substs = dcx.decode_substs(rbml_r);\n+            dcx.tcx().mk_substs(substs)\n+        });\n+\n+        Ok(substs)\n+    }\n+}\n+\n impl RegionSubsts {\n     pub fn map<F>(self, op: F) -> RegionSubsts where\n         F: FnOnce(VecPerParamSpace<ty::Region>) -> VecPerParamSpace<ty::Region>,"}, {"sha": "7477c4dead031da5db039ae5a6716992eb72a1bf", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -22,7 +22,7 @@ pub use self::LvaluePreference::*;\n use front::map as ast_map;\n use front::map::LinkedPath;\n use middle;\n-use middle::cstore::{CrateStore, LOCAL_CRATE};\n+use middle::cstore::{self, CrateStore, LOCAL_CRATE};\n use middle::def::{self, ExportMap};\n use middle::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -35,6 +35,7 @@ use util::common::memoized;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n use util::nodemap::FnvHashMap;\n \n+use serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::borrow::{Borrow, Cow};\n use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n@@ -479,6 +480,24 @@ impl<'tcx> Hash for TyS<'tcx> {\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n+impl<'tcx> Encodable for Ty<'tcx> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n+            ecx.encode_ty(rbml_w, *self);\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<'tcx> Decodable for Ty<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Ty<'tcx>, D::Error> {\n+        cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n+            Ok(dcx.decode_ty(rbml_r))\n+        })\n+    }\n+}\n+\n+\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n@@ -1529,6 +1548,23 @@ impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n     }\n }\n \n+impl<'tcx> Encodable for AdtDef<'tcx> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.did.encode(s)\n+    }\n+}\n+\n+impl<'tcx> Decodable for AdtDef<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<AdtDef<'tcx>, D::Error> {\n+        let def_id: DefId = try!{ Decodable::decode(d) };\n+\n+        cstore::tls::with_decoding_context(d, |dcx, _| {\n+            let def_id = dcx.translate_def_id(def_id);\n+            Ok(dcx.tcx().lookup_adt_def(def_id))\n+        })\n+    }\n+}\n+\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Enum }"}, {"sha": "4c47d3ab99063d490ea645ab0f8be8112bd9a280", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 9, "deletions": 58, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -39,7 +39,6 @@ use middle::ty::{self, Ty};\n \n use syntax::{ast, ast_util, codemap};\n use syntax::ast::NodeIdAssigner;\n-use syntax::codemap::Span;\n use syntax::ptr::P;\n \n use std::cell::Cell;\n@@ -116,7 +115,7 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n     fn new_def_id(&self, def_id: DefId) -> DefId {\n         self.tr_def_id(def_id)\n     }\n-    fn new_span(&self, span: Span) -> Span {\n+    fn new_span(&self, span: codemap::Span) -> codemap::Span {\n         self.tr_span(span)\n     }\n }\n@@ -219,60 +218,12 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     }\n \n     /// Translates a `Span` from an extern crate to the corresponding `Span`\n-    /// within the local crate's codemap. `creader::import_codemap()` will\n-    /// already have allocated any additionally needed FileMaps in the local\n-    /// codemap as a side-effect of creating the crate_metadata's\n-    /// `codemap_import_info`.\n-    pub fn tr_span(&self, span: Span) -> Span {\n-        let span = if span.lo > span.hi {\n-            // Currently macro expansion sometimes produces invalid Span values\n-            // where lo > hi. In order not to crash the compiler when trying to\n-            // translate these values, let's transform them into something we\n-            // can handle (and which will produce useful debug locations at\n-            // least some of the time).\n-            // This workaround is only necessary as long as macro expansion is\n-            // not fixed. FIXME(#23480)\n-            codemap::mk_sp(span.lo, span.lo)\n-        } else {\n-            span\n-        };\n-\n-        let imported_filemaps = self.cdata.imported_filemaps(self.tcx.sess.codemap());\n-        let filemap = {\n-            // Optimize for the case that most spans within a translated item\n-            // originate from the same filemap.\n-            let last_filemap_index = self.last_filemap_index.get();\n-            let last_filemap = &imported_filemaps[last_filemap_index];\n-\n-            if span.lo >= last_filemap.original_start_pos &&\n-               span.lo <= last_filemap.original_end_pos &&\n-               span.hi >= last_filemap.original_start_pos &&\n-               span.hi <= last_filemap.original_end_pos {\n-                last_filemap\n-            } else {\n-                let mut a = 0;\n-                let mut b = imported_filemaps.len();\n-\n-                while b - a > 1 {\n-                    let m = (a + b) / 2;\n-                    if imported_filemaps[m].original_start_pos > span.lo {\n-                        b = m;\n-                    } else {\n-                        a = m;\n-                    }\n-                }\n-\n-                self.last_filemap_index.set(a);\n-                &imported_filemaps[a]\n-            }\n-        };\n-\n-        let lo = (span.lo - filemap.original_start_pos) +\n-                  filemap.translated_filemap.start_pos;\n-        let hi = (span.hi - filemap.original_start_pos) +\n-                  filemap.translated_filemap.start_pos;\n-\n-        codemap::mk_sp(lo, hi)\n+    /// within the local crate's codemap.\n+    pub fn tr_span(&self, span: codemap::Span) -> codemap::Span {\n+        decoder::translate_span(self.cdata,\n+                                self.tcx.sess.codemap(),\n+                                &self.last_filemap_index,\n+                                span)\n     }\n }\n \n@@ -288,8 +239,8 @@ impl tr for Option<DefId> {\n     }\n }\n \n-impl tr for Span {\n-    fn tr(&self, dcx: &DecodeContext) -> Span {\n+impl tr for codemap::Span {\n+    fn tr(&self, dcx: &DecodeContext) -> codemap::Span {\n         dcx.tr_span(*self)\n     }\n }"}, {"sha": "c139ec4f62a5e4a370f365049d76892e53ca370a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -1216,6 +1216,64 @@ fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n     None\n }\n \n+/// Translates a `Span` from an extern crate to the corresponding `Span`\n+/// within the local crate's codemap.\n+pub fn translate_span(cdata: Cmd,\n+                      codemap: &codemap::CodeMap,\n+                      last_filemap_index_hint: &Cell<usize>,\n+                      span: codemap::Span)\n+                      -> codemap::Span {\n+    let span = if span.lo > span.hi {\n+        // Currently macro expansion sometimes produces invalid Span values\n+        // where lo > hi. In order not to crash the compiler when trying to\n+        // translate these values, let's transform them into something we\n+        // can handle (and which will produce useful debug locations at\n+        // least some of the time).\n+        // This workaround is only necessary as long as macro expansion is\n+        // not fixed. FIXME(#23480)\n+        codemap::mk_sp(span.lo, span.lo)\n+    } else {\n+        span\n+    };\n+\n+    let imported_filemaps = cdata.imported_filemaps(&codemap);\n+    let filemap = {\n+        // Optimize for the case that most spans within a translated item\n+        // originate from the same filemap.\n+        let last_filemap_index = last_filemap_index_hint.get();\n+        let last_filemap = &imported_filemaps[last_filemap_index];\n+\n+        if span.lo >= last_filemap.original_start_pos &&\n+           span.lo <= last_filemap.original_end_pos &&\n+           span.hi >= last_filemap.original_start_pos &&\n+           span.hi <= last_filemap.original_end_pos {\n+            last_filemap\n+        } else {\n+            let mut a = 0;\n+            let mut b = imported_filemaps.len();\n+\n+            while b - a > 1 {\n+                let m = (a + b) / 2;\n+                if imported_filemaps[m].original_start_pos > span.lo {\n+                    b = m;\n+                } else {\n+                    a = m;\n+                }\n+            }\n+\n+            last_filemap_index_hint.set(a);\n+            &imported_filemaps[a]\n+        }\n+    };\n+\n+    let lo = (span.lo - filemap.original_start_pos) +\n+              filemap.translated_filemap.start_pos;\n+    let hi = (span.hi - filemap.original_start_pos) +\n+              filemap.translated_filemap.start_pos;\n+\n+    codemap::mk_sp(lo, hi)\n+}\n+\n pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n                                                 id: DefIndex,\n                                                 mut callback: F)"}, {"sha": "448a64c93c1c458c35d5f8f8b995f31d4cb53ea3", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -19,7 +19,7 @@ use decoder;\n use tyencode;\n use index::{self, IndexData};\n \n-use middle::cstore::{LOCAL_CRATE, CrateStore, InlinedItemRef, LinkMeta};\n+use middle::cstore::{LOCAL_CRATE, CrateStore, InlinedItemRef, LinkMeta, tls};\n use middle::def;\n use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n@@ -1875,8 +1875,37 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n \n pub fn encode_metadata(parms: EncodeParams, krate: &hir::Crate) -> Vec<u8> {\n+    let EncodeParams {\n+        item_symbols,\n+        diag,\n+        tcx,\n+        reexports,\n+        cstore,\n+        encode_inlined_item,\n+        link_meta,\n+        reachable,\n+        ..\n+    } = parms;\n+    let ecx = EncodeContext {\n+        diag: diag,\n+        tcx: tcx,\n+        reexports: reexports,\n+        item_symbols: item_symbols,\n+        link_meta: link_meta,\n+        cstore: cstore,\n+        encode_inlined_item: RefCell::new(encode_inlined_item),\n+        type_abbrevs: RefCell::new(FnvHashMap()),\n+        reachable: reachable,\n+    };\n+\n     let mut wr = Cursor::new(Vec::new());\n-    encode_metadata_inner(&mut wr, parms, krate);\n+\n+    {\n+        let mut rbml_w = Encoder::new(&mut wr);\n+        tls::enter_encoding_context(&ecx, &mut rbml_w, |_, rbml_w| {\n+            encode_metadata_inner(rbml_w, &ecx, krate)\n+        });\n+    }\n \n     // RBML compacts the encoded bytes whenever appropriate,\n     // so there are some garbages left after the end of the data.\n@@ -1911,8 +1940,8 @@ pub fn encode_metadata(parms: EncodeParams, krate: &hir::Crate) -> Vec<u8> {\n     return v;\n }\n \n-fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n-                         parms: EncodeParams,\n+fn encode_metadata_inner(rbml_w: &mut Encoder,\n+                         ecx: &EncodeContext,\n                          krate: &hir::Crate) {\n     struct Stats {\n         attr_bytes: u64,\n@@ -1946,101 +1975,77 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n         zero_bytes: 0,\n         total_bytes: 0,\n     };\n-    let EncodeParams {\n-        item_symbols,\n-        diag,\n-        tcx,\n-        reexports,\n-        cstore,\n-        encode_inlined_item,\n-        link_meta,\n-        reachable,\n-        ..\n-    } = parms;\n-    let ecx = EncodeContext {\n-        diag: diag,\n-        tcx: tcx,\n-        reexports: reexports,\n-        item_symbols: item_symbols,\n-        link_meta: link_meta,\n-        cstore: cstore,\n-        encode_inlined_item: RefCell::new(encode_inlined_item),\n-        type_abbrevs: RefCell::new(FnvHashMap()),\n-        reachable: reachable,\n-     };\n-\n-    let mut rbml_w = Encoder::new(wr);\n \n-    encode_rustc_version(&mut rbml_w);\n-    encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name);\n-    encode_crate_triple(&mut rbml_w, &tcx.sess.opts.target_triple);\n-    encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n-    encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n+    encode_rustc_version(rbml_w);\n+    encode_crate_name(rbml_w, &ecx.link_meta.crate_name);\n+    encode_crate_triple(rbml_w, &ecx.tcx.sess.opts.target_triple);\n+    encode_hash(rbml_w, &ecx.link_meta.crate_hash);\n+    encode_dylib_dependency_formats(rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_attributes(&mut rbml_w, &krate.attrs);\n+    encode_attributes(rbml_w, &krate.attrs);\n     stats.attr_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_crate_deps(&mut rbml_w, ecx.cstore);\n+    encode_crate_deps(rbml_w, ecx.cstore);\n     stats.dep_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the language items.\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_lang_items(&ecx, &mut rbml_w);\n+    encode_lang_items(&ecx, rbml_w);\n     stats.lang_item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the native libraries used\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_native_libraries(&ecx, &mut rbml_w);\n+    encode_native_libraries(&ecx, rbml_w);\n     stats.native_lib_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the plugin registrar function\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_plugin_registrar_fn(&ecx, &mut rbml_w);\n+    encode_plugin_registrar_fn(&ecx, rbml_w);\n     stats.plugin_registrar_fn_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode codemap\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_codemap(&ecx, &mut rbml_w);\n+    encode_codemap(&ecx, rbml_w);\n     stats.codemap_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode macro definitions\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_macro_defs(&mut rbml_w, krate);\n+    encode_macro_defs(rbml_w, krate);\n     stats.macro_defs_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_impls(&ecx, krate, &mut rbml_w);\n+    encode_impls(&ecx, krate, rbml_w);\n     stats.impl_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode miscellaneous info.\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_misc_info(&ecx, krate, &mut rbml_w);\n-    encode_reachable(&ecx, &mut rbml_w);\n+    encode_misc_info(&ecx, krate, rbml_w);\n+    encode_reachable(&ecx, rbml_w);\n     stats.misc_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode and index the items.\n     rbml_w.start_tag(tag_items);\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    let index = encode_info_for_items(&ecx, &mut rbml_w);\n+    let index = encode_info_for_items(&ecx, rbml_w);\n     stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n     rbml_w.end_tag();\n \n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_item_index(&mut rbml_w, index.items);\n+    encode_item_index(rbml_w, index.items);\n     stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_xrefs(&ecx, &mut rbml_w, index.xrefs);\n+    encode_xrefs(&ecx, rbml_w, index.xrefs);\n     stats.xref_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    encode_struct_field_attrs(&ecx, &mut rbml_w, krate);\n+    encode_struct_field_attrs(&ecx, rbml_w, krate);\n \n     stats.total_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n \n-    if tcx.sess.meta_stats() {\n+    if ecx.tcx.sess.meta_stats() {\n         for e in rbml_w.writer.get_ref() {\n             if *e == 0 {\n                 stats.zero_bytes += 1;"}, {"sha": "c425ba1386e25b2687562f6045e8d8a26b7a0959", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -58,3 +58,4 @@ pub mod cstore;\n pub mod index;\n pub mod loader;\n pub mod macro_import;\n+pub mod tls_context;"}, {"sha": "e368ff3822a1df6b1da451c3d14a8ecd045ab793", "filename": "src/librustc_metadata/tls_context.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This module provides implementations for the thread-local encoding and\n+// decoding context traits in rustc::middle::cstore::tls.\n+\n+use rbml::writer::Encoder as RbmlEncoder;\n+use rbml::reader::Decoder as RbmlDecoder;\n+use rustc::middle::cstore::tls;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::subst::Substs;\n+use rustc::middle::ty::{self, Ty};\n+\n+use decoder::{self, Cmd};\n+use encoder;\n+use tydecode::TyDecoder;\n+use tyencode;\n+\n+\n+impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tcx> {\n+\n+    fn tcx<'s>(&'s self) -> &'s ty::ctxt<'tcx> {\n+        &self.tcx\n+    }\n+\n+    fn encode_ty(&self, rbml_w: &mut RbmlEncoder, t: ty::Ty<'tcx>) {\n+        encoder::write_type(self, rbml_w, t);\n+    }\n+\n+    fn encode_substs(&self, rbml_w: &mut RbmlEncoder, substs: &Substs<'tcx>) {\n+        let ty_str_ctxt = &tyencode::ctxt {\n+            diag: self.diag,\n+            ds: encoder::def_to_string,\n+            tcx: self.tcx,\n+            abbrevs: &self.type_abbrevs\n+        };\n+        tyencode::enc_substs(rbml_w, ty_str_ctxt, substs);\n+    }\n+}\n+\n+pub struct DecodingContext<'a, 'tcx: 'a> {\n+    pub crate_metadata: Cmd<'a>,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n+\n+    fn tcx<'s>(&'s self) -> &'s ty::ctxt<'tcx> {\n+        &self.tcx\n+    }\n+\n+    fn decode_ty(&self, rbml_r: &mut RbmlDecoder) -> ty::Ty<'tcx> {\n+        let def_id_convert = &mut |did| {\n+            decoder::translate_def_id(self.crate_metadata, did)\n+        };\n+\n+        let starting_position = rbml_r.position();\n+\n+        let mut ty_decoder = TyDecoder::new(\n+            self.crate_metadata.data.as_slice(),\n+            self.crate_metadata.cnum,\n+            starting_position,\n+            self.tcx,\n+            def_id_convert);\n+\n+        let ty = ty_decoder.parse_ty();\n+\n+        let end_position = ty_decoder.position();\n+\n+        // We can just reuse the tydecode implementation for parsing types, but\n+        // we have to make sure to leave the rbml reader at the position just\n+        // after the type.\n+        rbml_r.advance(end_position - starting_position);\n+        ty\n+    }\n+\n+    fn decode_substs(&self, rbml_r: &mut RbmlDecoder) -> Substs<'tcx> {\n+        let def_id_convert = &mut |did| {\n+            decoder::translate_def_id(self.crate_metadata, did)\n+        };\n+\n+        let starting_position = rbml_r.position();\n+\n+        let mut ty_decoder = TyDecoder::new(\n+            self.crate_metadata.data.as_slice(),\n+            self.crate_metadata.cnum,\n+            starting_position,\n+            self.tcx,\n+            def_id_convert);\n+\n+        let substs = ty_decoder.parse_substs();\n+\n+        let end_position = ty_decoder.position();\n+\n+        rbml_r.advance(end_position - starting_position);\n+        substs\n+    }\n+\n+    fn translate_def_id(&self, def_id: DefId) -> DefId {\n+        decoder::translate_def_id(self.crate_metadata, def_id)\n+    }\n+}"}, {"sha": "64d634859cd12ff4dbfd21b3f0b02ee0d4f3a837", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf6743d88509412308553e7172e89157f9b981/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=eebf6743d88509412308553e7172e89157f9b981", "patch": "@@ -68,6 +68,10 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n+    pub fn position(&self) -> usize {\n+        self.pos\n+    }\n+\n     fn peek(&self) -> char {\n         self.data[self.pos] as char\n     }"}]}