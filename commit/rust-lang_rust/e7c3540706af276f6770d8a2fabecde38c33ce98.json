{"sha": "e7c3540706af276f6770d8a2fabecde38c33ce98", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YzM1NDA3MDZhZjI3NmY2NzcwZDhhMmZhYmVjZGUzOGMzM2NlOTg=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-11-21T22:46:14Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-12-14T17:28:22Z"}, "message": "Use an enum to differentiate between kinds of structs.", "tree": {"sha": "5433340fb8d852252262a7ba9dbd8488b34edbd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5433340fb8d852252262a7ba9dbd8488b34edbd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7c3540706af276f6770d8a2fabecde38c33ce98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c3540706af276f6770d8a2fabecde38c33ce98", "html_url": "https://github.com/rust-lang/rust/commit/e7c3540706af276f6770d8a2fabecde38c33ce98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7c3540706af276f6770d8a2fabecde38c33ce98/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adae9bc25ecb25b3d0ac03591438bfde72f98291", "url": "https://api.github.com/repos/rust-lang/rust/commits/adae9bc25ecb25b3d0ac03591438bfde72f98291", "html_url": "https://github.com/rust-lang/rust/commit/adae9bc25ecb25b3d0ac03591438bfde72f98291"}], "stats": {"total": 91, "additions": 61, "deletions": 30}, "files": [{"sha": "bc9d32535f2d66b93fcddbd68a918f1943415804", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e7c3540706af276f6770d8a2fabecde38c33ce98/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c3540706af276f6770d8a2fabecde38c33ce98/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e7c3540706af276f6770d8a2fabecde38c33ce98", "patch": "@@ -524,9 +524,20 @@ pub struct Struct {\n     pub min_size: Size,\n }\n \n+// Info required to optimize struct layout.\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n+enum StructKind {\n+    // A tuple, closure, or univariant which cannot be coerced to unsized.\n+    AlwaysSizedUnivariant,\n+    // A univariant, the last field of which may be coerced to unsized.\n+    MaybeUnsizedUnivariant,\n+    // A univariant, but part of an enum.\n+    EnumVariant,\n+}\n+\n impl<'a, 'gcx, 'tcx> Struct {\n-    pub fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n-                  repr: attr::ReprAttr, is_enum_variant: bool,\n+    fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n+                  repr: attr::ReprAttr, kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n         let packed = repr == attr::ReprPacked;\n         let mut ret = Struct {\n@@ -538,38 +549,48 @@ impl<'a, 'gcx, 'tcx> Struct {\n             min_size: Size::from_bytes(0),\n         };\n \n-        if is_enum_variant {\n-            assert!(fields.len() >= 1, \"Enum variants must have at least a discriminant field.\")\n-        }\n+        let (optimize, sort_ascending) = match (repr, kind) {\n+            (attr::ReprAny, StructKind::AlwaysSizedUnivariant) => (true, false),\n+            (attr::ReprAny, StructKind::MaybeUnsizedUnivariant) => (true, true),\n+            (attr::ReprAny, StructKind::EnumVariant) => {\n+                assert!(fields.len() >= 1, \"Enum variants must have discriminants.\");\n+                (true, fields[0].size(dl).bytes() == 1)\n+            }\n+            _ => (false, false)\n+        };\n \n         if fields.len() == 0 {return Ok(ret)};\n \n         ret.offsets = vec![Size::from_bytes(0); fields.len()];\n         let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n-        if repr == attr::ReprAny {\n-            let start = if is_enum_variant {1} else {0};\n-            // FIXME(camlorn): we can't reorder the last field because\n-            // it is possible for structs to be coerced to unsized.\n-            // Example: struct Foo<T: ?Sized> { x: i32, y: T }\n-            // We can coerce &Foo<u8> to &Foo<Trait>.\n-            let end = inverse_memory_index.len()-1;\n+        if optimize {\n+            let start = if let StructKind::EnumVariant = kind {1} else {0};\n+            let end = if let StructKind::MaybeUnsizedUnivariant = kind { fields.len()-1 } else { 0 };\n             if end > start {\n                 let optimizing  = &mut inverse_memory_index[start..end];\n-                optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n-            }\n-            if is_enum_variant {\n-                assert_eq!(inverse_memory_index[0], 0,\n-                  \"Enums must have field 0 as the field with lowest offset.\")\n+                if sort_ascending {\n+                    optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n+                } else {\n+                    optimizing.sort_by(| &a, &b | {\n+                        let a = fields[a as usize].align(dl).abi();\n+                        let b = fields[b as usize].align(dl).abi();\n+                        b.cmp(&a)\n+                    });\n+                }\n             }\n         }\n \n-        // At this point, inverse_memory_index holds field indices by increasing offset.\n         // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n         // We now write field offsets to the corresponding offset slot;\n         // field 5 with offset 0 puts 0 in offsets[5].\n         // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n \n+        if let StructKind::EnumVariant = kind {\n+            assert_eq!(inverse_memory_index[0], 0,\n+              \"Enum variant discriminants must have the lowest offset.\");\n+        }\n+\n         let mut offset = Size::from_bytes(0);\n \n         for i in inverse_memory_index.iter() {\n@@ -606,10 +627,16 @@ impl<'a, 'gcx, 'tcx> Struct {\n         // To invert it, consider:\n         // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n         // Field 5 would be the first element, so memory_index is i:\n-        ret.memory_index = vec![0; inverse_memory_index.len()];\n+        // Note: if we didn't optimize, it's already right.\n+        \n+        if optimize {\n+            ret.memory_index = vec![0; inverse_memory_index.len()];\n \n-        for i in 0..inverse_memory_index.len() {\n-            ret.memory_index[inverse_memory_index[i] as usize]  = i as u32;\n+            for i in 0..inverse_memory_index.len() {\n+                ret.memory_index[inverse_memory_index[i] as usize]  = i as u32;\n+            }\n+        } else {\n+            ret.memory_index = inverse_memory_index;\n         }\n \n         Ok(ret)\n@@ -985,7 +1012,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // The never type.\n             ty::TyNever => Univariant {\n-                variant: Struct::new(dl, &vec![], attr::ReprAny, false, ty)?,\n+                variant: Struct::new(dl, &vec![], attr::ReprAny,\n+                  StructKind::AlwaysSizedUnivariant, ty)?,\n                 non_zero: false\n             },\n \n@@ -1038,12 +1066,13 @@ impl<'a, 'gcx, 'tcx> Layout {\n             // Odd unit types.\n             ty::TyFnDef(..) => {\n                 Univariant {\n-                    variant: Struct::new(dl, &vec![], attr::ReprAny, false, ty)?,\n+                    variant: Struct::new(dl, &vec![], attr::ReprAny, StructKind::AlwaysSizedUnivariant, ty)?,\n                     non_zero: false\n                 }\n             }\n             ty::TyDynamic(_) => {\n-                let mut unit = Struct::new(dl, &vec![], attr::ReprAny, false, ty)?;\n+                let mut unit = Struct::new(dl, &vec![], attr::ReprAny,\n+                  StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }\n             }\n@@ -1055,15 +1084,16 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     &tys.map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     attr::ReprAny,\n-                    false, ty)?;\n+                    StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n             ty::TyTuple(tys) => {\n+                // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked in the same way it is for univariant.\n                 let st = Struct::new(dl,\n                     &tys.iter().map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    attr::ReprAny, false, ty)?;\n+                    attr::ReprAny, StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n@@ -1096,7 +1126,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     assert_eq!(hint, attr::ReprAny);\n \n                     return success(Univariant {\n-                        variant: Struct::new(dl, &vec![], hint, false, ty)?,\n+                        variant: Struct::new(dl, &vec![], hint, StructKind::AlwaysSizedUnivariant, ty)?,\n                         non_zero: false\n                     });\n                 }\n@@ -1134,7 +1164,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n-                        let st = Struct::new(dl, &fields, hint, false, ty)?;\n+                        let st = Struct::new(dl, &fields, hint,\n+                          StructKind::MaybeUnsizedUnivariant, ty)?;\n                         let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n                     };\n@@ -1188,7 +1219,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         let st = Struct::new(dl,\n                             &variants[discr].iter().map(|ty| ty.layout(infcx))\n                               .collect::<Result<Vec<_>, _>>()?,\n-                            hint, false, ty)?;\n+                            hint, StructKind::AlwaysSizedUnivariant, ty)?;\n \n                         // We have to fix the last element of path here.\n                         let mut i = *path.last().unwrap();\n@@ -1226,7 +1257,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     fields.insert(0, &discr);\n                     let st = Struct::new(dl,\n                         &fields,\n-                        hint, false, ty)?;\n+                        hint, StructKind::EnumVariant, ty)?;\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n                     // It is important to skip the first field."}]}