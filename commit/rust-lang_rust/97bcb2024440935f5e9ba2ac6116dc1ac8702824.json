{"sha": "97bcb2024440935f5e9ba2ac6116dc1ac8702824", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YmNiMjAyNDQ0MDkzNWY1ZTliYTJhYzYxMTZkYzFhYzg3MDI4MjQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-14T23:20:01Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-14T23:21:53Z"}, "message": "Avoid some duplicated typechecking work\n\nThere was a FIXME noting that ty::enum_variants and typeck::check::\ncheck_enum_variants both call eval_const_expr. I tried refactoring the\ncode so that check_enum_variants does all the work and enum_variants\njust looks up cached results, but this turned out not to be easy because\nseveral ty functions call enum_variants and it might get invoked on an\nenum before that enum item has been typechecked. Instead, I just made\ncheck_enum_variants update the enum_var_cache so that enum_variants\nwill never call eval_const_expr twice on the same const.", "tree": {"sha": "4bf8f9011c87cdf9891ad11ba569cd8ff85cd30d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bf8f9011c87cdf9891ad11ba569cd8ff85cd30d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97bcb2024440935f5e9ba2ac6116dc1ac8702824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97bcb2024440935f5e9ba2ac6116dc1ac8702824", "html_url": "https://github.com/rust-lang/rust/commit/97bcb2024440935f5e9ba2ac6116dc1ac8702824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97bcb2024440935f5e9ba2ac6116dc1ac8702824/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeb9a2b72cf94ae15624482abf89f2de7a538aed", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb9a2b72cf94ae15624482abf89f2de7a538aed", "html_url": "https://github.com/rust-lang/rust/commit/aeb9a2b72cf94ae15624482abf89f2de7a538aed"}], "stats": {"total": 23, "additions": 18, "deletions": 5}, "files": [{"sha": "a76a8143a89e3f9f8f5bdd02bed3cfc5ec673df0", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97bcb2024440935f5e9ba2ac6116dc1ac8702824/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97bcb2024440935f5e9ba2ac6116dc1ac8702824/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=97bcb2024440935f5e9ba2ac6116dc1ac8702824", "patch": "@@ -2693,9 +2693,11 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n     let result = if ast::local_crate != id.crate {\n         @csearch::get_enum_variants(cx, id)\n     } else {\n-        // FIXME: Now that the variants are run through the type checker (to\n-        // check the disr_expr if it exists), this code should likely be\n-        // moved there to avoid having to call eval_const_expr twice.\n+        /*\n+          Although both this code and check_enum_variants in typeck/check\n+          call eval_const_expr, it should never get called twice for the same\n+          expr, since check_enum_variants also updates the enum_var_cache\n+         */\n         alt cx.items.get(id.node) {\n           ast_map::node_item(@{node: ast::item_enum(variants, _, _), _}, _) {\n             let mut disr_val = -1;"}, {"sha": "6dfa89549e74bd84663ff633197398d703a74a95", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/97bcb2024440935f5e9ba2ac6116dc1ac8702824/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97bcb2024440935f5e9ba2ac6116dc1ac8702824/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=97bcb2024440935f5e9ba2ac6116dc1ac8702824", "patch": "@@ -1200,14 +1200,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               none {\n                 alt sty {\n                   ty::ty_enum(*) {\n-                    tcx.sess.span_fatal(\n+                    tcx.sess.span_err(\n                         expr.span,\n                         \"can only dereference enums \\\n                          with a single variant which has a \\\n                          single argument\");\n                   }\n                   _ {\n-                    tcx.sess.span_fatal(\n+                    tcx.sess.span_err(\n                         expr.span,\n                         #fmt[\"type %s cannot be dereferenced\",\n                              fcx.infcx.ty_to_str(oper_t)]);\n@@ -1892,6 +1892,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     let fcx = blank_fn_ctxt(ccx, rty);\n     let mut disr_vals: [int] = [];\n     let mut disr_val = 0;\n+    let mut variants = [];\n     for vs.each {|v|\n         alt v.node.disr_expr {\n           some(e) {\n@@ -1920,9 +1921,19 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                                   \"discriminator value already exists.\");\n         }\n         disr_vals += [disr_val];\n+        let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n+        let arg_tys = if v.node.args.len() > 0u {\n+            ty::ty_fn_args(ctor_ty).map {|a| a.ty }\n+          } else { [] };\n+        variants += [@{args: arg_tys, ctor_ty: ctor_ty,\n+              name: v.node.name, id: local_def(v.node.id),\n+              disr_val: disr_val}];\n         disr_val += 1;\n     }\n \n+    // cache so that ty::enum_variants won't repeat this work\n+    ccx.tcx.enum_var_cache.insert(local_def(id), @variants);\n+\n     // Check that it is possible to represent this enum:\n     let mut outer = true, did = local_def(id);\n     if ty::type_structurally_contains(ccx.tcx, rty, {|sty|"}]}