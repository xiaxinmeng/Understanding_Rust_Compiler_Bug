{"sha": "01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZWJjMzdmYTE2MDMyOGMyZGM1ODBjZjYyY2Y2YjIxOTRkYzZmMmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-02-03T21:00:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-02-18T10:27:27Z"}, "message": "Change how dep-graph edges are handled in variance to\nbe more fine-grained, fixing the `dep-graph-struct-signature`\ntest.", "tree": {"sha": "a73126e2b14be8687bd9ef53a94c6cfc0651404f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a73126e2b14be8687bd9ef53a94c6cfc0651404f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "html_url": "https://github.com/rust-lang/rust/commit/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daa74082670af4622044f6b1bae1e3e49fa1ef38", "url": "https://api.github.com/repos/rust-lang/rust/commits/daa74082670af4622044f6b1bae1e3e49fa1ef38", "html_url": "https://github.com/rust-lang/rust/commit/daa74082670af4622044f6b1bae1e3e49fa1ef38"}], "stats": {"total": 116, "additions": 94, "deletions": 22}, "files": [{"sha": "94d1ff91c37b5973810b0938ff8590cfec6013d2", "filename": "src/librustc_typeck/variance/README.md", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "patch": "@@ -93,6 +93,54 @@ failure, but rather because the target type `Foo<Y>` is itself just\n not well-formed. Basically we get to assume well-formedness of all\n types involved before considering variance.\n \n+#### Dependency graph management\n+\n+Because variance works in two phases, if we are not careful, we wind\n+up with a muddled mess of a dep-graph. Basically, when gathering up\n+the constraints, things are fairly well-structured, but then we do a\n+fixed-point iteration and write the results back where they\n+belong. You can't give this fixed-point iteration a single task\n+because it reads from (and writes to) the variance of all types in the\n+crate. In principle, we *could* switch the \"current task\" in a very\n+fine-grained way while propagating constraints in the fixed-point\n+iteration and everything would be automatically tracked, but that\n+would add some overhead and isn't really necessary anyway.\n+\n+Instead what we do is to add edges into the dependency graph as we\n+construct the constraint set: so, if computing the constraints for\n+node `X` requires loading the inference variables from node `Y`, then\n+we can add an edge `Y -> X`, since the variance we ultimately infer\n+for `Y` will affect the variance we ultimately infer for `X`.\n+\n+At this point, we've basically mirrored the inference graph in the\n+dependency graph. This means we can just completely ignore the\n+fixed-point iteration, since it is just shuffling values along this\n+graph. In other words, if we added the fine-grained switching of tasks\n+I described earlier, all it would show is that we repeatedly read the\n+values described by the constraints, but those edges were already\n+added when building the constraints in the first place.\n+\n+Here is how this is implemented (at least as of the time of this\n+writing). The associated `DepNode` for the variance map is (at least\n+presently) `Signature(DefId)`. This means that, in `constraints.rs`,\n+when we visit an item to load up its constraints, we set\n+`Signature(DefId)` as the current task (the \"memoization\" pattern\n+described in the `dep-graph` README). Then whenever we find an\n+embedded type or trait, we add a synthetic read of `Signature(DefId)`,\n+which covers the variances we will compute for all of its\n+parameters. This read is synthetic (i.e., we call\n+`variance_map.read()`) because, in fact, the final variance is not yet\n+computed -- the read *will* occur (repeatedly) during the fixed-point\n+iteration phase.\n+\n+In fact, we don't really *need* this synthetic read. That's because we\n+do wind up looking up the `TypeScheme` or `TraitDef` for all\n+references types/traits, and those reads add an edge from\n+`Signature(DefId)` (that is, they share the same dep node as\n+variance). However, I've kept the synthetic reads in place anyway,\n+just for future-proofing (in case we change the dep-nodes in the\n+future), and because it makes the intention a bit clearer I think.\n+\n ### Addendum: Variance on traits\n \n As mentioned above, we used to permit variance on traits. This was\n@@ -250,3 +298,5 @@ validly derived as `&'a ()` for any `'a`:\n This change otoh means that `<'static () as Identity>::Out` is\n always `&'static ()` (which might then be upcast to `'a ()`,\n separately). This was helpful in solving #21750.\n+\n+"}, {"sha": "2f243d0fd0f80cb7c2ffe7acfd3c7c87237461e7", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "patch": "@@ -13,11 +13,13 @@\n //! The second pass over the AST determines the set of constraints.\n //! We walk the set of items and, for each member, generate new constraints.\n \n+use dep_graph::DepTrackingMapConfig;\n use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use middle::subst;\n use middle::subst::ParamSpace;\n use middle::ty::{self, Ty};\n+use middle::ty::maps::ItemVariances;\n use rustc::front::map as hir_map;\n use syntax::ast;\n use rustc_front::hir;\n@@ -48,10 +50,10 @@ pub struct Constraint<'a> {\n     pub variance: &'a VarianceTerm<'a>,\n }\n \n-pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n-                                            krate: &hir::Crate)\n+pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n                                             -> ConstraintContext<'a, 'tcx>\n {\n+    let tcx = terms_cx.tcx;\n     let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n     let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n     let invariant = terms_cx.arena.alloc(ConstantTerm(ty::Invariant));\n@@ -64,7 +66,11 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n         bivariant: bivariant,\n         constraints: Vec::new(),\n     };\n-    krate.visit_all_items(&mut constraint_cx);\n+\n+    // See README.md for a discussion on dep-graph management.\n+    tcx.visit_all_items_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n+                                 &mut constraint_cx);\n+\n     constraint_cx\n }\n \n@@ -289,6 +295,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n \n+        // This edge is actually implied by the call to\n+        // `lookup_trait_def`, but I'm trying to be future-proof. See\n+        // README.md for a discussion on dep-graph management.\n+        self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n+\n         self.add_constraints_from_substs(\n             generics,\n             trait_ref.def_id,\n@@ -345,6 +356,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::TyStruct(def, substs) => {\n                 let item_type = self.tcx().lookup_item_type(def.did);\n \n+                // This edge is actually implied by the call to\n+                // `lookup_trait_def`, but I'm trying to be future-proof. See\n+                // README.md for a discussion on dep-graph management.\n+                self.tcx().dep_graph.read(ItemVariances::to_dep_node(&def.did));\n+\n                 // All type parameters on enums and structs should be\n                 // in the TypeSpace.\n                 assert!(item_type.generics.types.is_empty_in(subst::SelfSpace));\n@@ -364,6 +380,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::TyProjection(ref data) => {\n                 let trait_ref = &data.trait_ref;\n                 let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n+\n+                // This edge is actually implied by the call to\n+                // `lookup_trait_def`, but I'm trying to be future-proof. See\n+                // README.md for a discussion on dep-graph management.\n+                self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n+\n                 self.add_constraints_from_substs(\n                     generics,\n                     trait_ref.def_id,\n@@ -424,7 +446,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n-\n     /// Adds constraints appropriate for a nominal type (enum, struct,\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,"}, {"sha": "3ce3a868f047723c8c16c20e39a399b8829e225e", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "patch": "@@ -12,7 +12,6 @@\n //! parameters. See README.md for details.\n \n use arena;\n-use dep_graph::DepNode;\n use middle::ty;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n@@ -29,11 +28,9 @@ mod solve;\n mod xform;\n \n pub fn infer_variance(tcx: &ty::ctxt) {\n-    let _task = tcx.dep_graph.in_task(DepNode::Variance);\n-    let krate = tcx.map.krate();\n     let mut arena = arena::TypedArena::new();\n-    let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n-    let constraints_cx = constraints::add_constraints_from_crate(terms_cx, krate);\n+    let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n+    let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n     solve::solve_constraints(constraints_cx);\n     tcx.variance_computed.set(true);\n }"}, {"sha": "fd442a4547cf92a360e5d5fce0622c30a7591bd2", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "patch": "@@ -96,6 +96,13 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         // item id).\n \n         let tcx = self.terms_cx.tcx;\n+\n+        // Ignore the writes here because the relevant edges were\n+        // already accounted for in `constraints.rs`. See the section\n+        // on dependency graph management in README.md for more\n+        // information.\n+        let _ignore = tcx.dep_graph.in_ignore();\n+\n         let solutions = &self.solutions;\n         let inferred_infos = &self.terms_cx.inferred_infos;\n         let mut index = 0;"}, {"sha": "aa1e93c3d6b7d678c230478d858638fe0475a6f5", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "patch": "@@ -20,8 +20,10 @@\n // a variable.\n \n use arena::TypedArena;\n+use dep_graph::DepTrackingMapConfig;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n use middle::ty;\n+use middle::ty::maps::ItemVariances;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -97,8 +99,7 @@ pub struct InferredInfo<'a> {\n \n pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n     tcx: &'a ty::ctxt<'tcx>,\n-    arena: &'a mut TypedArena<VarianceTerm<'a>>,\n-    krate: &hir::Crate)\n+    arena: &'a mut TypedArena<VarianceTerm<'a>>)\n     -> TermsContext<'a, 'tcx>\n {\n     let mut terms_cx = TermsContext {\n@@ -117,7 +118,9 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n         })\n     };\n \n-    krate.visit_all_items(&mut terms_cx);\n+    // See README.md for a discussion on dep-graph management.\n+    tcx.visit_all_items_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n+                                 &mut terms_cx);\n \n     terms_cx\n }"}, {"sha": "c16998cd33c644cfdc15d4eaef027359eb5ef2d7", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "patch": "@@ -74,23 +74,17 @@ mod signatures {\n     fn indirect(x: WillChanges) { }\n }\n \n-// these are invalid dependencies, though sometimes we create edges\n-// anyway.\n mod invalid_signatures {\n     use WontChange;\n \n-    // FIXME due to the variance pass having overly conservative edges,\n-    // we incorrectly think changes are needed here\n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n-    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR no path\n     trait A {\n         fn do_something_else_twice(x: WontChange);\n     }\n \n-    // FIXME due to the variance pass having overly conservative edges,\n-    // we incorrectly think changes are needed here\n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n-    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR no path\n     fn b(x: WontChange) { }\n \n     #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path from `WillChange`"}]}