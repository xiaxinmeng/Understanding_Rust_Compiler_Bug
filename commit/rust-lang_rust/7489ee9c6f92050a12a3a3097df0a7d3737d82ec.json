{"sha": "7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ODllZTljNmY5MjA1MGExMmEzYTMwOTdkZjBhN2QzNzM3ZDgyZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-13T12:36:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-13T12:36:13Z"}, "message": "Auto merge of #56461 - oli-obk:alloc_ids, r=RalfJung\n\nSome cleanups around `AllocId` management\n\nr? @eddyb\ncc @RalfJung", "tree": {"sha": "ed427440d561cfc0f7bcd420e7386e86d9f1893f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed427440d561cfc0f7bcd420e7386e86d9f1893f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "html_url": "https://github.com/rust-lang/rust/commit/7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fe5cb5342244a716055fa0162e795deabd4985c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe5cb5342244a716055fa0162e795deabd4985c", "html_url": "https://github.com/rust-lang/rust/commit/9fe5cb5342244a716055fa0162e795deabd4985c"}, {"sha": "7181aa176393d601f43704d886e8e7afa4b14e45", "url": "https://api.github.com/repos/rust-lang/rust/commits/7181aa176393d601f43704d886e8e7afa4b14e45", "html_url": "https://github.com/rust-lang/rust/commit/7181aa176393d601f43704d886e8e7afa4b14e45"}], "stats": {"total": 180, "additions": 101, "deletions": 79}, "files": [{"sha": "56da6b719f4a7287f7b3d749105162a85606cb96", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -338,7 +338,7 @@ impl_stable_hash_for!(\n );\n \n impl_stable_hash_for!(\n-    impl<'tcx, M> for enum mir::interpret::AllocType<'tcx, M> [ mir::interpret::AllocType ] {\n+    impl<'tcx> for enum mir::interpret::AllocKind<'tcx> [ mir::interpret::AllocKind ] {\n         Function(instance),\n         Static(def_id),\n         Memory(mem),"}, {"sha": "d54a1c9bb82f79a65e9e34681db57d6e3dbd3884", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 69, "deletions": 47, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -41,7 +41,6 @@ use ty::{self, TyCtxt, Instance};\n use ty::layout::{self, Size};\n use middle::region;\n use std::io;\n-use std::hash::Hash;\n use rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n@@ -90,7 +89,7 @@ impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n \n #[derive(RustcDecodable, RustcEncodable)]\n-enum AllocKind {\n+enum AllocDiscriminant {\n     Alloc,\n     Fn,\n     Static,\n@@ -104,23 +103,23 @@ pub fn specialized_encode_alloc_id<\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc_type: AllocType<'tcx, &'tcx Allocation> =\n+    let alloc_kind: AllocKind<'tcx> =\n         tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n-    match alloc_type {\n-        AllocType::Memory(alloc) => {\n+    match alloc_kind {\n+        AllocKind::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-            AllocKind::Alloc.encode(encoder)?;\n+            AllocDiscriminant::Alloc.encode(encoder)?;\n             alloc.encode(encoder)?;\n         }\n-        AllocType::Function(fn_instance) => {\n+        AllocKind::Function(fn_instance) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-            AllocKind::Fn.encode(encoder)?;\n+            AllocDiscriminant::Fn.encode(encoder)?;\n             fn_instance.encode(encoder)?;\n         }\n-        AllocType::Static(did) => {\n+        AllocKind::Static(did) => {\n             // referring to statics doesn't need to know about their allocations,\n             // just about its DefId\n-            AllocKind::Static.encode(encoder)?;\n+            AllocDiscriminant::Static.encode(encoder)?;\n             did.encode(encoder)?;\n         }\n     }\n@@ -189,10 +188,10 @@ impl<'s> AllocDecodingSession<'s> {\n         let idx = decoder.read_u32()? as usize;\n         let pos = self.state.data_offsets[idx] as usize;\n \n-        // Decode the AllocKind now so that we know if we have to reserve an\n+        // Decode the AllocDiscriminant now so that we know if we have to reserve an\n         // AllocId.\n         let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n-            let alloc_kind = AllocKind::decode(decoder)?;\n+            let alloc_kind = AllocDiscriminant::decode(decoder)?;\n             Ok((alloc_kind, decoder.position()))\n         })?;\n \n@@ -208,7 +207,7 @@ impl<'s> AllocDecodingSession<'s> {\n                 ref mut entry @ State::Empty => {\n                     // We are allowed to decode\n                     match alloc_kind {\n-                        AllocKind::Alloc => {\n+                        AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // AllocId so we can decode cyclic graphs.\n                             let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n@@ -217,7 +216,7 @@ impl<'s> AllocDecodingSession<'s> {\n                                 alloc_id);\n                             Some(alloc_id)\n                         },\n-                        AllocKind::Fn | AllocKind::Static => {\n+                        AllocDiscriminant::Fn | AllocDiscriminant::Static => {\n                             // Fns and statics cannot be cyclic and their AllocId\n                             // is determined later by interning\n                             *entry = State::InProgressNonAlloc(\n@@ -251,23 +250,23 @@ impl<'s> AllocDecodingSession<'s> {\n         // Now decode the actual data\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n-                AllocKind::Alloc => {\n+                AllocDiscriminant::Alloc => {\n                     let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n                     // We already have a reserved AllocId.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-                    decoder.tcx().alloc_map.lock().set_id_same_memory(alloc_id, allocation);\n+                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, allocation);\n                     Ok(alloc_id)\n                 },\n-                AllocKind::Fn => {\n+                AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc id\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 },\n-                AllocKind::Static => {\n+                AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc id at\");\n                     let did = DefId::decode(decoder)?;\n@@ -292,39 +291,42 @@ impl fmt::Display for AllocId {\n }\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n-pub enum AllocType<'tcx, M> {\n+pub enum AllocKind<'tcx> {\n     /// The alloc id is used as a function pointer\n     Function(Instance<'tcx>),\n     /// The alloc id points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n     /// The alloc id points to memory\n-    Memory(M)\n+    Memory(&'tcx Allocation),\n }\n \n-pub struct AllocMap<'tcx, M> {\n+pub struct AllocMap<'tcx> {\n     /// Lets you know what an AllocId refers to\n-    id_to_type: FxHashMap<AllocId, AllocType<'tcx, M>>,\n+    id_to_kind: FxHashMap<AllocId, AllocKind<'tcx>>,\n \n-    /// Used to ensure that functions and statics only get one associated AllocId\n-    type_interner: FxHashMap<AllocType<'tcx, M>, AllocId>,\n+    /// Used to ensure that statics only get one associated AllocId\n+    type_interner: FxHashMap<AllocKind<'tcx>, AllocId>,\n \n     /// The AllocId to assign to the next requested id.\n     /// Always incremented, never gets smaller.\n     next_id: AllocId,\n }\n \n-impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n+impl<'tcx> AllocMap<'tcx> {\n     pub fn new() -> Self {\n         AllocMap {\n-            id_to_type: Default::default(),\n+            id_to_kind: Default::default(),\n             type_interner: Default::default(),\n             next_id: AllocId(0),\n         }\n     }\n \n-    /// obtains a new allocation ID that can be referenced but does not\n+    /// Obtains a new allocation ID that can be referenced but does not\n     /// yet have an allocation backing it.\n+    ///\n+    /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n+    /// an `AllocId` from a query.\n     pub fn reserve(\n         &mut self,\n     ) -> AllocId {\n@@ -337,53 +339,73 @@ impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n         next\n     }\n \n-    fn intern(&mut self, alloc_type: AllocType<'tcx, M>) -> AllocId {\n-        if let Some(&alloc_id) = self.type_interner.get(&alloc_type) {\n+    fn intern(&mut self, alloc_kind: AllocKind<'tcx>) -> AllocId {\n+        if let Some(&alloc_id) = self.type_interner.get(&alloc_kind) {\n             return alloc_id;\n         }\n         let id = self.reserve();\n-        debug!(\"creating alloc_type {:?} with id {}\", alloc_type, id);\n-        self.id_to_type.insert(id, alloc_type.clone());\n-        self.type_interner.insert(alloc_type, id);\n+        debug!(\"creating alloc_kind {:?} with id {}\", alloc_kind, id);\n+        self.id_to_kind.insert(id, alloc_kind.clone());\n+        self.type_interner.insert(alloc_kind, id);\n         id\n     }\n \n-    // FIXME: Check if functions have identity. If not, we should not intern these,\n-    // but instead create a new id per use.\n-    // Alternatively we could just make comparing function pointers an error.\n+    /// Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n+    /// by the linker and functions can be duplicated across crates.\n+    /// We thus generate a new `AllocId` for every mention of a function. This means that\n+    /// `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n-        self.intern(AllocType::Function(instance))\n+        let id = self.reserve();\n+        self.id_to_kind.insert(id, AllocKind::Function(instance));\n+        id\n     }\n \n-    pub fn get(&self, id: AllocId) -> Option<AllocType<'tcx, M>> {\n-        self.id_to_type.get(&id).cloned()\n+    /// Returns `None` in case the `AllocId` is dangling. An `EvalContext` can still have a\n+    /// local `Allocation` for that `AllocId`, but having such an `AllocId` in a constant is\n+    /// illegal and will likely ICE.\n+    /// This function exists to allow const eval to detect the difference between evaluation-\n+    /// local dangling pointers and allocations in constants/statics.\n+    pub fn get(&self, id: AllocId) -> Option<AllocKind<'tcx>> {\n+        self.id_to_kind.get(&id).cloned()\n     }\n \n-    pub fn unwrap_memory(&self, id: AllocId) -> M {\n+    /// Panics if the `AllocId` does not refer to an `Allocation`\n+    pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n         match self.get(id) {\n-            Some(AllocType::Memory(mem)) => mem,\n+            Some(AllocKind::Memory(mem)) => mem,\n             _ => bug!(\"expected allocation id {} to point to memory\", id),\n         }\n     }\n \n+    /// Generate an `AllocId` for a static or return a cached one in case this function has been\n+    /// called on the same static before.\n     pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n-        self.intern(AllocType::Static(static_id))\n+        self.intern(AllocKind::Static(static_id))\n     }\n \n-    pub fn allocate(&mut self, mem: M) -> AllocId {\n+    /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n+    /// `Allocation` with a different `AllocId`.\n+    // FIXME: is this really necessary? Can we ensure `FOO` and `BAR` being different after codegen\n+    // in `static FOO: u32 = 42; static BAR: u32 = 42;` even if they reuse the same allocation\n+    // inside rustc?\n+    pub fn allocate(&mut self, mem: &'tcx Allocation) -> AllocId {\n         let id = self.reserve();\n-        self.set_id_memory(id, mem);\n+        self.set_alloc_id_memory(id, mem);\n         id\n     }\n \n-    pub fn set_id_memory(&mut self, id: AllocId, mem: M) {\n-        if let Some(old) = self.id_to_type.insert(id, AllocType::Memory(mem)) {\n+    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n+    /// call this function twice, even with the same `Allocation` will ICE the compiler.\n+    pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n+        if let Some(old) = self.id_to_kind.insert(id, AllocKind::Memory(mem)) {\n             bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n-    pub fn set_id_same_memory(&mut self, id: AllocId, mem: M) {\n-       self.id_to_type.insert_same(id, AllocType::Memory(mem));\n+    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n+    /// twice for the same `(AllocId, Allocation)` pair.\n+    fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n+        self.id_to_kind.insert_same(id, AllocKind::Memory(mem));\n     }\n }\n "}, {"sha": "b8d4c5a37511a4947ee86eb18084d05f701f6c8c", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -18,7 +18,7 @@ use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_ex\n /// Represents the result of a raw const operation, pre-validation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub struct RawConst<'tcx> {\n-    // the value lives here, at offset 0, and that allocation definitely is a `AllocType::Memory`\n+    // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n     pub alloc_id: AllocId,\n     pub ty: Ty<'tcx>,"}, {"sha": "68b5c3e2df3224b108145fe1d166e9ca7b4fb6d0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -2637,7 +2637,7 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const<'_>) -> fmt::Resu\n                 if let Ref(_, &ty::TyS { sty: Str, .. }, _) = ty.sty {\n                     return ty::tls::with(|tcx| {\n                         let alloc = tcx.alloc_map.lock().get(ptr.alloc_id);\n-                        if let Some(interpret::AllocType::Memory(alloc)) = alloc {\n+                        if let Some(interpret::AllocKind::Memory(alloc)) = alloc {\n                             assert_eq!(len as usize as u128, len);\n                             let slice =\n                                 &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];"}, {"sha": "e27d7349877fc8e12df51acf45c560b8ce4ae88f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -946,7 +946,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Stores the value of constants (and deduplicates the actual memory)\n     allocation_interner: Lock<FxHashMap<&'tcx Allocation, ()>>,\n \n-    pub alloc_map: Lock<interpret::AllocMap<'tcx, &'tcx Allocation>>,\n+    pub alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n     layout_interner: Lock<FxHashMap<&'tcx LayoutDetails, ()>>,\n "}, {"sha": "ad14ca7caf60a8683dfaf8c4696a44b79e471e60", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -21,7 +21,7 @@ use value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n-use rustc::mir::interpret::{Scalar, AllocType, Allocation};\n+use rustc::mir::interpret::{Scalar, AllocKind, Allocation};\n use consts::const_alloc_to_llvm;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n@@ -316,20 +316,20 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 }\n             },\n             Scalar::Ptr(ptr) => {\n-                let alloc_type = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                let base_addr = match alloc_type {\n-                    Some(AllocType::Memory(alloc)) => {\n+                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                let base_addr = match alloc_kind {\n+                    Some(AllocKind::Memory(alloc)) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         if alloc.mutability == Mutability::Mutable {\n                             self.static_addr_of_mut(init, alloc.align, None)\n                         } else {\n                             self.static_addr_of(init, alloc.align, None)\n                         }\n                     }\n-                    Some(AllocType::Function(fn_instance)) => {\n+                    Some(AllocKind::Function(fn_instance)) => {\n                         self.get_fn(fn_instance)\n                     }\n-                    Some(AllocType::Static(def_id)) => {\n+                    Some(AllocKind::Static(def_id)) => {\n                         assert!(self.tcx.is_static(def_id).is_some());\n                         self.get_static(def_id)\n                     }"}, {"sha": "420fe26426321909d04583b086cb8aee15a3e6ea", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::Mutability;\n \n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n-    EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n+    EvalResult, Scalar, EvalErrorKind, AllocKind, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck,\n };\n \n@@ -204,12 +204,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             None => {\n                 // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(AllocType::Function(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(AllocKind::Function(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n-                    Some(AllocType::Static(..)) |\n-                    Some(AllocType::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(AllocKind::Static(..)) |\n+                    Some(AllocKind::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"static\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n@@ -326,15 +326,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let def_id = match alloc {\n-            Some(AllocType::Memory(mem)) => {\n+            Some(AllocKind::Memory(mem)) => {\n                 // We got tcx memory. Let the machine figure out whether and how to\n                 // turn that into memory with the right pointer tag.\n                 return Ok(M::adjust_static_allocation(mem, memory_extra))\n             }\n-            Some(AllocType::Function(..)) => {\n+            Some(AllocKind::Function(..)) => {\n                 return err!(DerefFunctionPointer)\n             }\n-            Some(AllocType::Static(did)) => {\n+            Some(AllocKind::Static(did)) => {\n                 did\n             }\n             None =>\n@@ -435,8 +435,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         // Could also be a fn ptr or extern static\n         match self.tcx.alloc_map.lock().get(id) {\n-            Some(AllocType::Function(..)) => (Size::ZERO, Align::from_bytes(1).unwrap()),\n-            Some(AllocType::Static(did)) => {\n+            Some(AllocKind::Function(..)) => (Size::ZERO, Align::from_bytes(1).unwrap()),\n+            Some(AllocKind::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n                 // Use size and align of the type\n@@ -459,7 +459,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n         match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-            Some(AllocType::Function(instance)) => Ok(instance),\n+            Some(AllocKind::Function(instance)) => Ok(instance),\n             _ => Err(EvalErrorKind::ExecuteMemory.into()),\n         }\n     }\n@@ -557,16 +557,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Err(()) => {\n                     // static alloc?\n                     match self.tcx.alloc_map.lock().get(id) {\n-                        Some(AllocType::Memory(alloc)) => {\n+                        Some(AllocKind::Memory(alloc)) => {\n                             self.dump_alloc_helper(\n                                 &mut allocs_seen, &mut allocs_to_print,\n                                 msg, alloc, \" (immutable)\".to_owned()\n                             );\n                         }\n-                        Some(AllocType::Function(func)) => {\n+                        Some(AllocKind::Function(func)) => {\n                             trace!(\"{} {}\", msg, func);\n                         }\n-                        Some(AllocType::Static(did)) => {\n+                        Some(AllocKind::Static(did)) => {\n                             trace!(\"{} {:?}\", msg, did);\n                         }\n                         None => {\n@@ -638,7 +638,7 @@ where\n         // ensure llvm knows not to put this into immutable memory\n         alloc.mutability = mutability;\n         let alloc = self.tcx.intern_const_alloc(alloc);\n-        self.tcx.alloc_map.lock().set_id_memory(alloc_id, alloc);\n+        self.tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n         // recurse into inner allocations\n         for &(_, alloc) in alloc.relocations.values() {\n             // FIXME: Reusing the mutability here is likely incorrect.  It is originally"}, {"sha": "c7bfea82a2d31d018bfa0d4cc43bee38b8d84d7d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -17,7 +17,7 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocType, EvalResult, EvalErrorKind,\n+    Scalar, AllocKind, EvalResult, EvalErrorKind,\n };\n \n use super::{\n@@ -388,7 +388,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                             \"integer pointer in non-ZST reference\", self.path);\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                        if let Some(AllocType::Static(did)) = alloc_kind {\n+                        if let Some(AllocKind::Static(did)) = alloc_kind {\n                             // `extern static` cannot be validated as they have no body.\n                             // FIXME: Statics from other crates are also skipped.\n                             // They might be checked at a different type, but for now we"}, {"sha": "a6239a8115a36a6595e301f2cdc9b40fcbb86aae", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7489ee9c6f92050a12a3a3097df0a7d3737d82ec/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=7489ee9c6f92050a12a3a3097df0a7d3737d82ec", "patch": "@@ -197,7 +197,7 @@ use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n-use rustc::mir::interpret::{Scalar, GlobalId, AllocType, ErrorHandled};\n+use rustc::mir::interpret::{Scalar, GlobalId, AllocKind, ErrorHandled};\n \n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -1161,22 +1161,22 @@ fn collect_miri<'a, 'tcx>(\n     alloc_id: AllocId,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    let alloc_type = tcx.alloc_map.lock().get(alloc_id);\n-    match alloc_type {\n-        Some(AllocType::Static(did)) => {\n+    let alloc_kind = tcx.alloc_map.lock().get(alloc_id);\n+    match alloc_kind {\n+        Some(AllocKind::Static(did)) => {\n             let instance = Instance::mono(tcx, did);\n             if should_monomorphize_locally(tcx, &instance) {\n                 trace!(\"collecting static {:?}\", did);\n                 output.push(MonoItem::Static(did));\n             }\n         }\n-        Some(AllocType::Memory(alloc)) => {\n+        Some(AllocKind::Memory(alloc)) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n             for &((), inner) in alloc.relocations.values() {\n                 collect_miri(tcx, inner, output);\n             }\n         },\n-        Some(AllocType::Function(fn_instance)) => {\n+        Some(AllocKind::Function(fn_instance)) => {\n             if should_monomorphize_locally(tcx, &fn_instance) {\n                 trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n                 output.push(create_fn_mono_item(fn_instance));"}]}