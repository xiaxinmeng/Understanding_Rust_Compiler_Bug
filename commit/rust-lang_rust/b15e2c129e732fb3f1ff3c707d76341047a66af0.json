{"sha": "b15e2c129e732fb3f1ff3c707d76341047a66af0", "node_id": "C_kwDOAAsO6NoAKGIxNWUyYzEyOWU3MzJmYjNmMWZmM2M3MDdkNzYzNDEwNDdhNjZhZjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-15T07:36:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-15T07:36:38Z"}, "message": "Auto merge of #101832 - compiler-errors:dyn-star-plus, r=eholk\n\nMake `dyn*` casts into a coercion, allow `dyn*` upcasting\n\nI know that `dyn*` is likely not going to be a feature exposed to surface Rust, but this makes it slightly more ergonomic to write tests for these types anyways. ... and this was just fun to implement anyways.\n\n1. Make `dyn*` into a coercion instead of a cast\n2. Enable `dyn*` upcasting since we basically get it for free\n3. Simplify some of the cast checking code since we're using the coercion path now\n\nr? `@eholk` but feel free to reassign\ncc `@nikomatsakis` and `@tmandry` who might care about making `dyn*` casts into a coercion", "tree": {"sha": "77f9ce52d2d1403fe53d10ef79864c6a95fb48e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77f9ce52d2d1403fe53d10ef79864c6a95fb48e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b15e2c129e732fb3f1ff3c707d76341047a66af0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b15e2c129e732fb3f1ff3c707d76341047a66af0", "html_url": "https://github.com/rust-lang/rust/commit/b15e2c129e732fb3f1ff3c707d76341047a66af0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b15e2c129e732fb3f1ff3c707d76341047a66af0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46244f335b5262ef9bdc34cc564b4dea221948f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/46244f335b5262ef9bdc34cc564b4dea221948f6", "html_url": "https://github.com/rust-lang/rust/commit/46244f335b5262ef9bdc34cc564b4dea221948f6"}, {"sha": "8c7e836abb62331ebb8350c7724c95241ef95a51", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7e836abb62331ebb8350c7724c95241ef95a51", "html_url": "https://github.com/rust-lang/rust/commit/8c7e836abb62331ebb8350c7724c95241ef95a51"}], "stats": {"total": 369, "additions": 233, "deletions": 136}, "files": [{"sha": "0ca6408aab910b96eec1e3df867597d88813c785", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -38,7 +38,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n-use rustc_target::abi::{Align, VariantIdx};\n+use rustc_target::abi::{Align, Size, VariantIdx};\n \n use std::collections::BTreeSet;\n use std::convert::TryFrom;\n@@ -150,7 +150,12 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.eval_usize(cx.tcx(), ty::ParamEnv::reveal_all()))\n         }\n-        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+        (\n+            &ty::Dynamic(ref data_a, _, src_dyn_kind),\n+            &ty::Dynamic(ref data_b, _, target_dyn_kind),\n+        ) => {\n+            assert_eq!(src_dyn_kind, target_dyn_kind);\n+\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n@@ -166,11 +171,7 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             if let Some(entry_idx) = vptr_entry_idx {\n                 let ptr_ty = cx.type_i8p();\n                 let ptr_align = cx.tcx().data_layout.pointer_align.abi;\n-                let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n-                    cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n-                    1,\n-                    true,\n-                );\n+                let vtable_ptr_ty = vtable_ptr_ty(cx, target, target_dyn_kind);\n                 let llvtable = bx.pointercast(old_info, bx.type_ptr_to(ptr_ty));\n                 let gep = bx.inbounds_gep(\n                     ptr_ty,\n@@ -186,18 +187,32 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 old_info\n             }\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n-                cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n-                1,\n-                true,\n-            );\n+        (_, &ty::Dynamic(ref data, _, target_dyn_kind)) => {\n+            let vtable_ptr_ty = vtable_ptr_ty(cx, target, target_dyn_kind);\n             cx.const_ptrcast(meth::get_vtable(cx, source, data.principal()), vtable_ptr_ty)\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n+// Returns the vtable pointer type of a `dyn` or `dyn*` type\n+fn vtable_ptr_ty<'tcx, Cx: CodegenMethods<'tcx>>(\n+    cx: &Cx,\n+    target: Ty<'tcx>,\n+    kind: ty::DynKind,\n+) -> <Cx as BackendTypes>::Type {\n+    cx.scalar_pair_element_backend_type(\n+        cx.layout_of(match kind {\n+            // vtable is the second field of `*mut dyn Trait`\n+            ty::Dyn => cx.tcx().mk_mut_ptr(target),\n+            // vtable is the second field of `dyn* Trait`\n+            ty::DynStar => target,\n+        }),\n+        1,\n+        true,\n+    )\n+}\n+\n /// Coerces `src` to `dst_ty`. `src_ty` must be a pointer.\n pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n@@ -247,6 +262,29 @@ pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n+/// Coerces `src` to `dst_ty` which is guaranteed to be a `dyn*` type.\n+pub fn cast_to_dyn_star<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    src: Bx::Value,\n+    src_ty_and_layout: TyAndLayout<'tcx>,\n+    dst_ty: Ty<'tcx>,\n+    old_info: Option<Bx::Value>,\n+) -> (Bx::Value, Bx::Value) {\n+    debug!(\"cast_to_dyn_star: {:?} => {:?}\", src_ty_and_layout.ty, dst_ty);\n+    assert!(\n+        matches!(dst_ty.kind(), ty::Dynamic(_, _, ty::DynStar)),\n+        \"destination type must be a dyn*\"\n+    );\n+    // FIXME(dyn-star): this is probably not the best way to check if this is\n+    // a pointer, and really we should ensure that the value is a suitable\n+    // pointer earlier in the compilation process.\n+    let src = match src_ty_and_layout.pointee_info_at(bx.cx(), Size::ZERO) {\n+        Some(_) => bx.ptrtoint(src, bx.cx().type_isize()),\n+        None => bx.bitcast(src, bx.type_isize()),\n+    };\n+    (src, unsized_info(bx, src_ty_and_layout.ty, dst_ty, old_info))\n+}\n+\n /// Coerces `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty`, and stores the result in `dst`.\n pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>("}, {"sha": "4aab31fbfe7da71ba31369cb0658b2aaf93cc323", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -4,7 +4,6 @@ use super::{FunctionCx, LocalRef};\n \n use crate::base;\n use crate::common::{self, IntPredicate};\n-use crate::meth::get_vtable;\n use crate::traits::*;\n use crate::MemFlags;\n \n@@ -14,7 +13,6 @@ use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n-use rustc_target::abi::Size;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"trace\", skip(self, bx))]\n@@ -274,27 +272,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::DynStar => {\n-                        let data = match operand.val {\n+                        let (lldata, llextra) = match operand.val {\n                             OperandValue::Ref(_, _, _) => todo!(),\n-                            OperandValue::Immediate(v) => v,\n-                            OperandValue::Pair(_, _) => todo!(),\n-                        };\n-                        let trait_ref =\n-                            if let ty::Dynamic(data, _, ty::DynStar) = cast.ty.kind() {\n-                                data.principal()\n-                            } else {\n-                                bug!(\"Only valid to do a DynStar cast into a DynStar type\")\n-                            };\n-                        let vtable = get_vtable(bx.cx(), source.ty(self.mir, bx.tcx()), trait_ref);\n-                        let vtable = bx.pointercast(vtable, bx.cx().type_ptr_to(bx.cx().type_isize()));\n-                        // FIXME(dyn-star): this is probably not the best way to check if this is\n-                        // a pointer, and really we should ensure that the value is a suitable\n-                        // pointer earlier in the compilation process.\n-                        let data = match operand.layout.pointee_info_at(bx.cx(), Size::ZERO) {\n-                            Some(_) => bx.ptrtoint(data, bx.cx().type_isize()),\n-                            None => data,\n+                            OperandValue::Immediate(v) => (v, None),\n+                            OperandValue::Pair(v, l) => (v, Some(l)),\n                         };\n-                        OperandValue::Pair(data, vtable)\n+                        let (lldata, llextra) =\n+                            base::cast_to_dyn_star(&mut bx, lldata, operand.layout, cast.ty, llextra);\n+                        OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(\n                         PointerCast::MutToConstPointer | PointerCast::ArrayToPointer,"}, {"sha": "51abdd2e059d71b11664d1dbe27968362cb7cf99", "filename": "compiler/rustc_hir_analysis/src/check/cast.rs", "status": "modified", "additions": 3, "deletions": 76, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -35,13 +35,12 @@ use crate::type_error_struct;\n use hir::def_id::LOCAL_CRATE;\n use rustc_errors::{struct_span_err, Applicability, DelayDm, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_infer::traits::{Obligation, ObligationCause, ObligationCauseCode};\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::cast::{CastKind, CastTy};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Binder, Ty, TypeAndMut, TypeVisitable, VariantDef};\n+use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable, VariantDef};\n use rustc_session::lint;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n@@ -204,76 +203,8 @@ fn make_invalid_casting_error<'a, 'tcx>(\n     )\n }\n \n-pub enum CastCheckResult<'tcx> {\n-    Ok,\n-    Deferred(CastCheck<'tcx>),\n-    Err(ErrorGuaranteed),\n-}\n-\n-pub fn check_cast<'tcx>(\n-    fcx: &FnCtxt<'_, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    expr_ty: Ty<'tcx>,\n-    cast_ty: Ty<'tcx>,\n-    cast_span: Span,\n-    span: Span,\n-) -> CastCheckResult<'tcx> {\n-    if cast_ty.is_dyn_star() {\n-        check_dyn_star_cast(fcx, expr, expr_ty, cast_ty)\n-    } else {\n-        match CastCheck::new(fcx, expr, expr_ty, cast_ty, cast_span, span) {\n-            Ok(check) => CastCheckResult::Deferred(check),\n-            Err(e) => CastCheckResult::Err(e),\n-        }\n-    }\n-}\n-\n-fn check_dyn_star_cast<'tcx>(\n-    fcx: &FnCtxt<'_, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    expr_ty: Ty<'tcx>,\n-    cast_ty: Ty<'tcx>,\n-) -> CastCheckResult<'tcx> {\n-    // Find the bounds in the dyn*. For eaxmple, if we have\n-    //\n-    //    let x = 22_usize as dyn* (Clone + Debug + 'static)\n-    //\n-    // this would return `existential_predicates = [?Self: Clone, ?Self: Debug]` and `region = 'static`.\n-    let (existential_predicates, region) = match cast_ty.kind() {\n-        ty::Dynamic(predicates, region, ty::DynStar) => (predicates, region),\n-        _ => panic!(\"Invalid dyn* cast_ty\"),\n-    };\n-\n-    let cause = ObligationCause::new(\n-        expr.span,\n-        fcx.body_id,\n-        // FIXME(dyn-star): Use a better obligation cause code\n-        ObligationCauseCode::MiscObligation,\n-    );\n-\n-    // For each existential predicate (e.g., `?Self: Clone`) substitute\n-    // the type of the expression (e.g., `usize` in our example above)\n-    // and then require that the resulting predicate (e.g., `usize: Clone`)\n-    // holds (it does).\n-    for existential_predicate in existential_predicates.iter() {\n-        let predicate = existential_predicate.with_self_ty(fcx.tcx, expr_ty);\n-        fcx.register_predicate(Obligation::new(cause.clone(), fcx.param_env, predicate));\n-    }\n-\n-    // Enforce the region bound `'static` (e.g., `usize: 'static`, in our example).\n-    fcx.register_predicate(Obligation::new(\n-        cause,\n-        fcx.param_env,\n-        fcx.tcx.mk_predicate(Binder::dummy(ty::PredicateKind::TypeOutlives(\n-            ty::OutlivesPredicate(expr_ty, *region),\n-        ))),\n-    ));\n-\n-    CastCheckResult::Ok\n-}\n-\n impl<'a, 'tcx> CastCheck<'tcx> {\n-    fn new(\n+    pub fn new(\n         fcx: &FnCtxt<'a, 'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n@@ -934,11 +865,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n \n-            // FIXME(dyn-star): this needs more conditions...\n-            (_, DynStar) => Ok(CastKind::DynStarCast),\n-\n-            // FIXME(dyn-star): do we want to allow dyn* upcasting or other casts?\n-            (DynStar, _) => Err(CastError::IllegalCast),\n+            (_, DynStar) | (DynStar, _) => bug!(\"should be handled by `try_coerce`\"),\n         }\n     }\n "}, {"sha": "faa6c6d9356f44e5b6cee08b428a1e953ce3cd91", "filename": "compiler/rustc_hir_analysis/src/check/coercion.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -216,6 +216,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::Ref(r_b, _, mutbl_b) => {\n                 return self.coerce_borrowed_pointer(a, b, r_b, mutbl_b);\n             }\n+            ty::Dynamic(predicates, region, ty::DynStar) if self.tcx.features().dyn_star => {\n+                return self.coerce_dyn_star(a, b, predicates, region);\n+            }\n             _ => {}\n         }\n \n@@ -745,6 +748,63 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(coercion)\n     }\n \n+    fn coerce_dyn_star(\n+        &self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        b_region: ty::Region<'tcx>,\n+    ) -> CoerceResult<'tcx> {\n+        if !self.tcx.features().dyn_star {\n+            return Err(TypeError::Mismatch);\n+        }\n+\n+        if let ty::Dynamic(a_data, _, _) = a.kind()\n+            && let ty::Dynamic(b_data, _, _) = b.kind()\n+        {\n+            if a_data.principal_def_id() == b_data.principal_def_id() {\n+                return self.unify_and(a, b, |_| vec![]);\n+            } else if !self.tcx().features().trait_upcasting {\n+                let mut err = feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::trait_upcasting,\n+                    self.cause.span,\n+                    &format!(\n+                        \"cannot cast `{a}` to `{b}`, trait upcasting coercion is experimental\"\n+                    ),\n+                );\n+                err.emit();\n+            }\n+        }\n+\n+        // Check the obligations of the cast -- for example, when casting\n+        // `usize` to `dyn* Clone + 'static`:\n+        let obligations = predicates\n+            .iter()\n+            .map(|predicate| {\n+                // For each existential predicate (e.g., `?Self: Clone`) substitute\n+                // the type of the expression (e.g., `usize` in our example above)\n+                // and then require that the resulting predicate (e.g., `usize: Clone`)\n+                // holds (it does).\n+                let predicate = predicate.with_self_ty(self.tcx, a);\n+                Obligation::new(self.cause.clone(), self.param_env, predicate)\n+            })\n+            // Enforce the region bound (e.g., `usize: 'static`, in our example).\n+            .chain([Obligation::new(\n+                self.cause.clone(),\n+                self.param_env,\n+                self.tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::TypeOutlives(\n+                    ty::OutlivesPredicate(a, b_region),\n+                ))),\n+            )])\n+            .collect();\n+\n+        Ok(InferOk {\n+            value: (vec![Adjustment { kind: Adjust::DynStar, target: b }], b),\n+            obligations,\n+        })\n+    }\n+\n     fn coerce_from_safe_fn<F, G>(\n         &self,\n         a: Ty<'tcx>,"}, {"sha": "71c6da862c94b6907a4ede11f7c9050a4cc46cfe", "filename": "compiler/rustc_hir_analysis/src/check/expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -3,7 +3,7 @@\n //! See `mod.rs` for more context on type checking in general.\n \n use crate::astconv::AstConv as _;\n-use crate::check::cast::{self, CastCheckResult};\n+use crate::check::cast;\n use crate::check::coercion::CoerceMany;\n use crate::check::fatally_break_rust;\n use crate::check::method::SelfSource;\n@@ -1270,17 +1270,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-            match cast::check_cast(self, e, t_expr, t_cast, t.span, expr.span) {\n-                CastCheckResult::Ok => t_cast,\n-                CastCheckResult::Deferred(cast_check) => {\n+            match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+                Ok(cast_check) => {\n                     debug!(\n                         \"check_expr_cast: deferring cast from {:?} to {:?}: {:?}\",\n                         t_cast, t_expr, cast_check,\n                     );\n                     deferred_cast_checks.push(cast_check);\n                     t_cast\n                 }\n-                CastCheckResult::Err(ErrorGuaranteed { .. }) => self.tcx.ty_error(),\n+                Err(_) => self.tcx.ty_error(),\n             }\n         }\n     }"}, {"sha": "039c653e5bc64de9f55a55eaadee28906bfd37a3", "filename": "compiler/rustc_hir_analysis/src/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -583,7 +583,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n             match adjustment.kind {\n-                adjustment::Adjust::NeverToAny | adjustment::Adjust::Pointer(_) => {\n+                adjustment::Adjust::NeverToAny\n+                | adjustment::Adjust::Pointer(_)\n+                | adjustment::Adjust::DynStar => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n                     self.delegate_consume(&place_with_id, place_with_id.hir_id);"}, {"sha": "362f1c3430041a45e668c263b825e7f790a2fbc9", "filename": "compiler/rustc_hir_analysis/src/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -292,7 +292,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n             adjustment::Adjust::NeverToAny\n             | adjustment::Adjust::Pointer(_)\n-            | adjustment::Adjust::Borrow(_) => {\n+            | adjustment::Adjust::Borrow(_)\n+            | adjustment::Adjust::DynStar => {\n                 // Result is an rvalue.\n                 Ok(self.cat_rvalue(expr.hir_id, expr.span, target))\n             }"}, {"sha": "c022ea9e5b4708597a4b44ef3763cf2ab2e81e41", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -1824,7 +1824,6 @@ impl<'tcx> Rvalue<'tcx> {\n             // While the model is undecided, we should be conservative. See\n             // <https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html>\n             Rvalue::Cast(CastKind::PointerExposeAddress, _, _) => false,\n-            Rvalue::Cast(CastKind::DynStar, _, _) => false,\n \n             Rvalue::Use(_)\n             | Rvalue::CopyForDeref(_)\n@@ -1841,7 +1840,8 @@ impl<'tcx> Rvalue<'tcx> {\n                 | CastKind::FnPtrToPtr\n                 | CastKind::PtrToPtr\n                 | CastKind::Pointer(_)\n-                | CastKind::PointerFromExposedAddress,\n+                | CastKind::PointerFromExposedAddress\n+                | CastKind::DynStar,\n                 _,\n                 _,\n             )"}, {"sha": "4682ac96b5297ba2dde0aff44b4c47a906c606e5", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -101,6 +101,9 @@ pub enum Adjust<'tcx> {\n     Borrow(AutoBorrow<'tcx>),\n \n     Pointer(PointerCast),\n+\n+    /// Cast into a dyn* object.\n+    DynStar,\n }\n \n /// An overloaded autoderef step, representing a `Deref(Mut)::deref(_mut)`"}, {"sha": "c7a7c3e3fa8eefd6f42747e13488e362416d1322", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -159,6 +159,7 @@ impl<'tcx> Cx<'tcx> {\n             Adjust::Borrow(AutoBorrow::RawPtr(mutability)) => {\n                 ExprKind::AddressOf { mutability, arg: self.thir.exprs.push(expr) }\n             }\n+            Adjust::DynStar => ExprKind::Cast { source: self.thir.exprs.push(expr) },\n         };\n \n         Expr { temp_lifetime, ty: adjustment.target, span, kind }"}, {"sha": "7673c793678336a730bb97f0f87002010e1cd433", "filename": "src/test/ui/dyn-star/auxiliary/dyn-star-foreign.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fauxiliary%2Fdyn-star-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fauxiliary%2Fdyn-star-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fauxiliary%2Fdyn-star-foreign.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -0,0 +1,10 @@\n+#![feature(dyn_star)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Display;\n+\n+pub fn require_dyn_star_display(_: dyn* Display) {}\n+\n+fn works_locally() {\n+    require_dyn_star_display(1usize);\n+}"}, {"sha": "67e3ab7ab35f18de488362f40e110101f3489862", "filename": "src/test/ui/dyn-star/const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fconst.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -6,7 +6,7 @@ use std::fmt::Debug;\n \n fn make_dyn_star() {\n     let i = 42usize;\n-    let dyn_i: dyn* Debug = i as dyn* Debug;\n+    let dyn_i: dyn* Debug = i;\n }\n \n fn main() {"}, {"sha": "1478498c0a9f3c5edeabe7943c7f556172258016", "filename": "src/test/ui/dyn-star/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdrop.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -15,7 +15,7 @@ impl Drop for Foo {\n }\n \n fn make_dyn_star(i: Foo) {\n-    let _dyn_i: dyn* Debug = i as dyn* Debug;\n+    let _dyn_i: dyn* Debug = i;\n }\n \n fn main() {"}, {"sha": "d8261387efa9e77fcf957a725a0e04ffefbd8021", "filename": "src/test/ui/dyn-star/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Ferror.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -7,7 +7,7 @@ trait Foo {}\n \n fn make_dyn_star() {\n     let i = 42;\n-    let dyn_i: dyn* Foo = i as dyn* Foo; //~ ERROR trait bound `{integer}: Foo` is not satisfied\n+    let dyn_i: dyn* Foo = i; //~ ERROR trait bound `{integer}: Foo` is not satisfied\n }\n \n fn main() {}"}, {"sha": "ae54b9ca707d0e184e03bf2953682d2806fc46f8", "filename": "src/test/ui/dyn-star/error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Ferror.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Ferror.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Ferror.stderr?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -1,7 +1,7 @@\n error[E0277]: the trait bound `{integer}: Foo` is not satisfied\n   --> $DIR/error.rs:10:27\n    |\n-LL |     let dyn_i: dyn* Foo = i as dyn* Foo;\n+LL |     let dyn_i: dyn* Foo = i;\n    |                           ^ the trait `Foo` is not implemented for `{integer}`\n \n error: aborting due to previous error"}, {"sha": "e5255a64ba119992b5956705ede4b698d7f5ea7e", "filename": "src/test/ui/dyn-star/make-dyn-star.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fmake-dyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fmake-dyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fmake-dyn-star.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -5,9 +5,14 @@\n use std::fmt::Debug;\n \n fn make_dyn_star(i: usize) {\n+    let _dyn_i: dyn* Debug = i;\n+}\n+\n+fn make_dyn_star_explicit(i: usize) {\n     let _dyn_i: dyn* Debug = i as dyn* Debug;\n }\n \n fn main() {\n     make_dyn_star(42);\n+    make_dyn_star_explicit(42);\n }"}, {"sha": "5a77640f0d932f108bada3be5cf9dfb21bc36913", "filename": "src/test/ui/dyn-star/method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fmethod.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+\n #![feature(dyn_star)]\n #![allow(incomplete_features)]\n \n@@ -17,7 +18,7 @@ fn invoke_dyn_star(i: dyn* Foo) -> usize {\n }\n \n fn make_and_invoke_dyn_star(i: usize) -> usize {\n-    let dyn_i: dyn* Foo = i as dyn* Foo;\n+    let dyn_i: dyn* Foo = i;\n     invoke_dyn_star(dyn_i)\n }\n "}, {"sha": "d9470e2841770d2828a39cc5346e0e638d3835e1", "filename": "src/test/ui/dyn-star/no-implicit-dyn-star.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fno-implicit-dyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fno-implicit-dyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fno-implicit-dyn-star.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -0,0 +1,8 @@\n+// aux-build:dyn-star-foreign.rs\n+\n+extern crate dyn_star_foreign;\n+\n+fn main() {\n+    dyn_star_foreign::require_dyn_star_display(1usize);\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "e7c5918629bdc35f71dca040e4138e2af5270043", "filename": "src/test/ui/dyn-star/no-implicit-dyn-star.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fno-implicit-dyn-star.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fno-implicit-dyn-star.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fno-implicit-dyn-star.stderr?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/no-implicit-dyn-star.rs:6:48\n+   |\n+LL |     dyn_star_foreign::require_dyn_star_display(1usize);\n+   |     ------------------------------------------ ^^^^^^ expected trait object `dyn std::fmt::Display`, found `usize`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected trait object `(dyn* std::fmt::Display + 'static)`\n+                      found type `usize`\n+note: function defined here\n+  --> $DIR/auxiliary/dyn-star-foreign.rs:6:8\n+   |\n+LL | pub fn require_dyn_star_display(_: dyn* Display) {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "cee76ada7df3bb445047eb343d00d4814b4808a7", "filename": "src/test/ui/dyn-star/upcast.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -0,0 +1,33 @@\n+// run-pass\n+\n+#![feature(dyn_star, trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo: Bar {\n+    fn hello(&self);\n+}\n+\n+trait Bar {\n+    fn world(&self);\n+}\n+\n+struct W(usize);\n+\n+impl Foo for W {\n+    fn hello(&self) {\n+        println!(\"hello!\");\n+    }\n+}\n+\n+impl Bar for W {\n+    fn world(&self) {\n+        println!(\"world!\");\n+    }\n+}\n+\n+fn main() {\n+    let w: dyn* Foo = W(0);\n+    w.hello();\n+    let w: dyn* Bar = w;\n+    w.world();\n+}"}, {"sha": "102f7541c8ce13853190069a112c8a4ee3e14a9f", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b15e2c129e732fb3f1ff3c707d76341047a66af0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=b15e2c129e732fb3f1ff3c707d76341047a66af0", "patch": "@@ -1,15 +1,16 @@\n use rustc_hir::Expr;\n-use rustc_hir_analysis::check::{\n-    cast::{self, CastCheckResult},\n-    FnCtxt, Inherited,\n-};\n+use rustc_hir_analysis::check::{cast, FnCtxt, Inherited};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;\n \n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment\n-pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n+pub(super) fn is_layout_incompatible<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    from: Ty<'tcx>,\n+    to: Ty<'tcx>,\n+) -> bool {\n     if let Ok(from) = cx.tcx.try_normalize_erasing_regions(cx.param_env, from)\n         && let Ok(to) = cx.tcx.try_normalize_erasing_regions(cx.param_env, to)\n         && let Ok(from_layout) = cx.tcx.layout_of(cx.param_env.and(from))\n@@ -32,7 +33,9 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) -> bool {\n-    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n+    use CastKind::{\n+        AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast,\n+    };\n     matches!(\n         check_cast(cx, e, from_ty, to_ty),\n         Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n@@ -43,20 +46,22 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n /// the cast. In certain cases, including some invalid casts from array references\n /// to pointers, this may cause additional errors to be emitted and/or ICE error\n /// messages. This function will panic if that occurs.\n-fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n+fn check_cast<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) -> Option<CastKind> {\n     let hir_id = e.hir_id;\n     let local_def_id = hir_id.owner.def_id;\n \n     Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n         let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n \n         // If we already have errors, we can't be sure we can pointer cast.\n-        assert!(\n-            !fn_ctxt.errors_reported_since_creation(),\n-            \"Newly created FnCtxt contained errors\"\n-        );\n+        assert!(!fn_ctxt.errors_reported_since_creation(), \"Newly created FnCtxt contained errors\");\n \n-        if let CastCheckResult::Deferred(check) = cast::check_cast(\n+        if let Ok(check) = cast::CastCheck::new(\n             &fn_ctxt, e, from_ty, to_ty,\n             // We won't show any error to the user, so we don't care what the span is here.\n             DUMMY_SP, DUMMY_SP,"}]}