{"sha": "956e2f8348fae25d725adc0058c8156cc9be6ac2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NmUyZjgzNDhmYWUyNWQ3MjVhZGMwMDU4YzgxNTZjYzliZTZhYzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-01T13:59:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-09T15:02:13Z"}, "message": "add some instrumentation", "tree": {"sha": "f453712e22c5b38eb5c7913b88b9263c0606594e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f453712e22c5b38eb5c7913b88b9263c0606594e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/956e2f8348fae25d725adc0058c8156cc9be6ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/956e2f8348fae25d725adc0058c8156cc9be6ac2", "html_url": "https://github.com/rust-lang/rust/commit/956e2f8348fae25d725adc0058c8156cc9be6ac2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/956e2f8348fae25d725adc0058c8156cc9be6ac2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a561ea70833546aa37b8b199dbc4e5399443eee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a561ea70833546aa37b8b199dbc4e5399443eee9", "html_url": "https://github.com/rust-lang/rust/commit/a561ea70833546aa37b8b199dbc4e5399443eee9"}], "stats": {"total": 323, "additions": 189, "deletions": 134}, "files": [{"sha": "92d5a431a61bd0bd9e4ccf7a4d0d25db914e98c5", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 77, "deletions": 63, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/956e2f8348fae25d725adc0058c8156cc9be6ac2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2f8348fae25d725adc0058c8156cc9be6ac2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=956e2f8348fae25d725adc0058c8156cc9be6ac2", "patch": "@@ -21,17 +21,18 @@ use borrow_check::nll::renumber;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferOk;\n-use rustc::ty::Ty;\n-use rustc::ty::subst::Subst;\n-use rustc::mir::*;\n use rustc::mir::visit::TyContext;\n+use rustc::mir::*;\n use rustc::traits::PredicateObligations;\n+use rustc::ty::subst::Subst;\n+use rustc::ty::Ty;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n use super::{Locations, TypeChecker};\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n+    #[inline(never)]\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n         mir: &Mir<'tcx>,\n@@ -56,8 +57,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n \n         assert!(\n-            mir.yield_ty.is_some() && universal_regions.yield_ty.is_some() ||\n-            mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n+            mir.yield_ty.is_some() && universal_regions.yield_ty.is_some()\n+                || mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n         );\n         if let Some(mir_yield_ty) = mir.yield_ty {\n             let ur_yield_ty = universal_regions.yield_ty.unwrap();\n@@ -76,57 +77,66 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             output_ty\n         );\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n-        let anon_type_map = self.fully_perform_op(Locations::All, |cx| {\n-            let mut obligations = ObligationAccumulator::default();\n-\n-            let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n-                mir_def_id,\n-                cx.body_id,\n-                cx.param_env,\n-                &output_ty,\n-            ));\n-            debug!(\n-                \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n-                output_ty\n-            );\n-            debug!(\n-                \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n-                anon_type_map\n-            );\n-\n-            debug!(\n-                \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n-                mir_output_ty\n-            );\n-            obligations.add(infcx\n-                .at(&cx.misc(cx.last_span), cx.param_env)\n-                .eq(output_ty, mir_output_ty)?);\n-\n-            for (&anon_def_id, anon_decl) in &anon_type_map {\n-                let anon_defn_ty = tcx.type_of(anon_def_id);\n-                let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n-                let anon_defn_ty = renumber::renumber_regions(\n-                    cx.infcx,\n-                    TyContext::Location(Location::START),\n-                    &anon_defn_ty,\n-                );\n-                debug!(\n-                    \"equate_inputs_and_outputs: concrete_ty={:?}\",\n-                    anon_decl.concrete_ty\n-                );\n-                debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n-                obligations.add(infcx\n-                    .at(&cx.misc(cx.last_span), cx.param_env)\n-                    .eq(anon_decl.concrete_ty, anon_defn_ty)?);\n-            }\n-\n-            debug!(\"equate_inputs_and_outputs: equated\");\n-\n-            Ok(InferOk {\n-                value: Some(anon_type_map),\n-                obligations: obligations.into_vec(),\n-            })\n-        }).unwrap_or_else(|terr| {\n+        let anon_type_map =\n+            self.fully_perform_op(\n+                Locations::All,\n+                || format!(\"input_output\"),\n+                |cx| {\n+                    let mut obligations = ObligationAccumulator::default();\n+\n+                    let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n+                        mir_def_id,\n+                        cx.body_id,\n+                        cx.param_env,\n+                        &output_ty,\n+                    ));\n+                    debug!(\n+                        \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n+                        output_ty\n+                    );\n+                    debug!(\n+                        \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n+                        anon_type_map\n+                    );\n+\n+                    debug!(\n+                        \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n+                        mir_output_ty\n+                    );\n+                    obligations.add(\n+                        infcx\n+                            .at(&cx.misc(cx.last_span), cx.param_env)\n+                            .eq(output_ty, mir_output_ty)?,\n+                    );\n+\n+                    for (&anon_def_id, anon_decl) in &anon_type_map {\n+                        let anon_defn_ty = tcx.type_of(anon_def_id);\n+                        let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n+                        let anon_defn_ty = renumber::renumber_regions(\n+                            cx.infcx,\n+                            TyContext::Location(Location::START),\n+                            &anon_defn_ty,\n+                        );\n+                        debug!(\n+                            \"equate_inputs_and_outputs: concrete_ty={:?}\",\n+                            anon_decl.concrete_ty\n+                        );\n+                        debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n+                        obligations.add(\n+                            infcx\n+                                .at(&cx.misc(cx.last_span), cx.param_env)\n+                                .eq(anon_decl.concrete_ty, anon_defn_ty)?,\n+                        );\n+                    }\n+\n+                    debug!(\"equate_inputs_and_outputs: equated\");\n+\n+                    Ok(InferOk {\n+                        value: Some(anon_type_map),\n+                        obligations: obligations.into_vec(),\n+                    })\n+                },\n+            ).unwrap_or_else(|terr| {\n                 span_mirbug!(\n                     self,\n                     Location::START,\n@@ -143,13 +153,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(anon_type_map) = anon_type_map {\n-            self.fully_perform_op(Locations::All, |_cx| {\n-                infcx.constrain_anon_types(&anon_type_map, universal_regions);\n-                Ok(InferOk {\n-                    value: (),\n-                    obligations: vec![],\n-                })\n-            }).unwrap();\n+            self.fully_perform_op(\n+                Locations::All,\n+                || format!(\"anon_type_map\"),\n+                |_cx| {\n+                    infcx.constrain_anon_types(&anon_type_map, universal_regions);\n+                    Ok(InferOk {\n+                        value: (),\n+                        obligations: vec![],\n+                    })\n+                },\n+            ).unwrap();\n         }\n     }\n "}, {"sha": "e69eb38350e82a65a72a17486f73d85cbad635c9", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/956e2f8348fae25d725adc0058c8156cc9be6ac2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2f8348fae25d725adc0058c8156cc9be6ac2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=956e2f8348fae25d725adc0058c8156cc9be6ac2", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dataflow::{FlowAtLocation, FlowsAtLocation};\n use borrow_check::nll::region_infer::Cause;\n-use dataflow::MaybeInitializedPlaces;\n+use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n-use rustc::mir::{BasicBlock, Location, Mir};\n+use dataflow::MaybeInitializedPlaces;\n+use dataflow::{FlowAtLocation, FlowsAtLocation};\n+use rustc::infer::InferOk;\n use rustc::mir::Local;\n+use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n-use rustc::infer::InferOk;\n-use borrow_check::nll::type_check::AtLocation;\n use util::liveness::LivenessResults;\n \n use super::TypeChecker;\n@@ -170,6 +170,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     /// the regions in its type must be live at `location`. The\n     /// precise set will depend on the dropck constraints, and in\n     /// particular this takes `#[may_dangle]` into account.\n+    #[inline(never)]\n     fn add_drop_live_constraint(\n         &mut self,\n         dropped_local: Local,\n@@ -191,33 +192,39 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         //\n         // For this reason, we avoid calling TypeChecker.normalize, instead doing all normalization\n         // ourselves in one large 'fully_perform_op' callback.\n-        let kind_constraints = self.cx\n-            .fully_perform_op(location.at_self(), |cx| {\n-                let span = cx.last_span;\n-\n-                let mut final_obligations = Vec::new();\n-                let mut kind_constraints = Vec::new();\n-\n-                let InferOk {\n-                    value: kinds,\n-                    obligations,\n-                } = cx.infcx\n-                    .at(&cx.misc(span), cx.param_env)\n-                    .dropck_outlives(dropped_ty);\n-                for kind in kinds {\n-                    // All things in the `outlives` array may be touched by\n-                    // the destructor and must be live at this point.\n-                    let cause = Cause::DropVar(dropped_local, location);\n-                    kind_constraints.push((kind, location, cause));\n-                }\n-\n-                final_obligations.extend(obligations);\n-\n-                Ok(InferOk {\n-                    value: kind_constraints,\n-                    obligations: final_obligations,\n-                })\n-            })\n+        let kind_constraints = self\n+            .cx\n+            .fully_perform_op(\n+                location.at_self(),\n+                || format!(\"add_drop_live_constraint(dropped_ty={:?})\", dropped_ty),\n+                |cx| {\n+                    let span = cx.last_span;\n+\n+                    let mut final_obligations = Vec::new();\n+                    let mut kind_constraints = Vec::new();\n+\n+                    let InferOk {\n+                        value: kinds,\n+                        obligations,\n+                    } = cx\n+                        .infcx\n+                        .at(&cx.misc(span), cx.param_env)\n+                        .dropck_outlives(dropped_ty);\n+                    for kind in kinds {\n+                        // All things in the `outlives` array may be touched by\n+                        // the destructor and must be live at this point.\n+                        let cause = Cause::DropVar(dropped_local, location);\n+                        kind_constraints.push((kind, location, cause));\n+                    }\n+\n+                    final_obligations.extend(obligations);\n+\n+                    Ok(InferOk {\n+                        value: kind_constraints,\n+                        obligations: final_obligations,\n+                    })\n+                },\n+            )\n             .unwrap();\n \n         for (kind, location, cause) in kind_constraints {"}, {"sha": "060313399cb5c4d60ebff05a57557daed6bb009b", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/956e2f8348fae25d725adc0058c8156cc9be6ac2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956e2f8348fae25d725adc0058c8156cc9be6ac2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=956e2f8348fae25d725adc0058c8156cc9be6ac2", "patch": "@@ -710,14 +710,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         traits::ObligationCause::misc(span, self.body_id)\n     }\n \n+    #[inline(never)]\n     fn fully_perform_op<OP, R>(\n         &mut self,\n         locations: Locations,\n+        describe_op: impl Fn() -> String,\n         op: OP,\n     ) -> Result<R, TypeError<'tcx>>\n     where\n         OP: FnOnce(&mut Self) -> InferResult<'tcx, R>,\n     {\n+        if cfg!(debug_assertions) {\n+            info!(\"fully_perform_op(describe_op={}) at {:?}\", describe_op(), locations);\n+        }\n+\n         let mut fulfill_cx = TraitEngine::new(self.infcx.tcx);\n         let InferOk { value, obligations } = self.infcx.commit_if_ok(|_| op(self))?;\n         fulfill_cx.register_predicate_obligations(self.infcx, obligations);\n@@ -746,25 +752,35 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         Ok(value)\n     }\n \n+    #[inline(never)]\n     fn sub_types(\n         &mut self,\n         sub: Ty<'tcx>,\n         sup: Ty<'tcx>,\n         locations: Locations,\n     ) -> UnitResult<'tcx> {\n-        self.fully_perform_op(locations, |this| {\n-            this.infcx\n-                .at(&this.misc(this.last_span), this.param_env)\n-                .sup(sup, sub)\n-        })\n+        self.fully_perform_op(\n+            locations,\n+            || format!(\"sub_types({:?} <: {:?})\", sub, sup),\n+            |this| {\n+                this.infcx\n+                    .at(&this.misc(this.last_span), this.param_env)\n+                    .sup(sup, sub)\n+            },\n+        )\n     }\n \n+    #[inline(never)]\n     fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> UnitResult<'tcx> {\n-        self.fully_perform_op(locations, |this| {\n-            this.infcx\n-                .at(&this.misc(this.last_span), this.param_env)\n-                .eq(b, a)\n-        })\n+        self.fully_perform_op(\n+            locations,\n+            || format!(\"eq_types({:?} = {:?})\", a, b),\n+            |this| {\n+                this.infcx\n+                    .at(&this.misc(this.last_span), this.param_env)\n+                    .eq(b, a)\n+            },\n+        )\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -1520,29 +1536,42 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         );\n     }\n \n+    #[inline(never)]\n     fn prove_predicates<T>(&mut self, predicates: T, location: Location)\n     where\n-        T: IntoIterator<Item = ty::Predicate<'tcx>>,\n-        T::IntoIter: Clone,\n+        T: IntoIterator<Item = ty::Predicate<'tcx>> + Clone,\n     {\n-        let predicates = predicates.into_iter();\n+        // This intermediate vector is mildly unfortunate, in that we\n+        // sometimes create it even when logging is disabled, but only\n+        // if debug-info is enabled, and I doubt it is actually\n+        // expensive. -nmatsakis\n+        let predicates_vec: Vec<_> = if cfg!(debug_assertions) {\n+            predicates.clone().into_iter().collect()\n+        } else {\n+            Vec::new()\n+        };\n \n         debug!(\n             \"prove_predicates(predicates={:?}, location={:?})\",\n-            predicates.clone().collect::<Vec<_>>(),\n+            predicates_vec,\n             location,\n         );\n-        self.fully_perform_op(location.at_self(), |this| {\n-            let cause = this.misc(this.last_span);\n-            let obligations = predicates\n-                .into_iter()\n-                .map(|p| traits::Obligation::new(cause.clone(), this.param_env, p))\n-                .collect();\n-            Ok(InferOk {\n-                value: (),\n-                obligations,\n-            })\n-        }).unwrap()\n+\n+        self.fully_perform_op(\n+            location.at_self(),\n+            || format!(\"prove_predicates({:?})\", predicates_vec),\n+            |this| {\n+                let cause = this.misc(this.last_span);\n+                let obligations = predicates\n+                    .into_iter()\n+                    .map(|p| traits::Obligation::new(cause.clone(), this.param_env, p))\n+                    .collect();\n+                Ok(InferOk {\n+                    value: (),\n+                    obligations,\n+                })\n+            },\n+        ).unwrap()\n     }\n \n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n@@ -1571,25 +1600,30 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline(never)]\n     fn normalize<T>(&mut self, value: &T, location: impl ToLocations) -> T\n     where\n         T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n-        self.fully_perform_op(location.to_locations(), |this| {\n-            let Normalized { value, obligations } = this.infcx\n-                .at(&this.misc(this.last_span), this.param_env)\n-                .normalize(value)\n-                .unwrap_or_else(|NoSolution| {\n-                    span_bug!(\n-                        this.last_span,\n-                        \"normalization of `{:?}` failed at {:?}\",\n-                        value,\n-                        location,\n-                    );\n-                });\n-            Ok(InferOk { value, obligations })\n-        }).unwrap()\n+        self.fully_perform_op(\n+            location.to_locations(),\n+            || format!(\"normalize(value={:?})\", value),\n+            |this| {\n+                let Normalized { value, obligations } = this.infcx\n+                    .at(&this.misc(this.last_span), this.param_env)\n+                    .normalize(value)\n+                    .unwrap_or_else(|NoSolution| {\n+                        span_bug!(\n+                            this.last_span,\n+                            \"normalization of `{:?}` failed at {:?}\",\n+                            value,\n+                            location,\n+                        );\n+                    });\n+                Ok(InferOk { value, obligations })\n+            },\n+        ).unwrap()\n     }\n }\n "}]}