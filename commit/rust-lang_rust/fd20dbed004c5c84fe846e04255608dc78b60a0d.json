{"sha": "fd20dbed004c5c84fe846e04255608dc78b60a0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMjBkYmVkMDA0YzVjODRmZTg0NmUwNDI1NTYwOGRjNzhiNjBhMGQ=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-10-13T17:48:26Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-10-18T23:16:49Z"}, "message": "Improve comments and structure of `ConstProp::const_prop()`\n\nPer code review feedback", "tree": {"sha": "677720e17c18e91439d27e25be10f7c0a7ac89b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/677720e17c18e91439d27e25be10f7c0a7ac89b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd20dbed004c5c84fe846e04255608dc78b60a0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd20dbed004c5c84fe846e04255608dc78b60a0d", "html_url": "https://github.com/rust-lang/rust/commit/fd20dbed004c5c84fe846e04255608dc78b60a0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd20dbed004c5c84fe846e04255608dc78b60a0d/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b71ea80172136fe4b597aef1001ca72a8588fe15", "url": "https://api.github.com/repos/rust-lang/rust/commits/b71ea80172136fe4b597aef1001ca72a8588fe15", "html_url": "https://github.com/rust-lang/rust/commit/b71ea80172136fe4b597aef1001ca72a8588fe15"}], "stats": {"total": 82, "additions": 50, "deletions": 32}, "files": [{"sha": "f0c0e57344388f8e09d410c118a099e5158a7e82", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fd20dbed004c5c84fe846e04255608dc78b60a0d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd20dbed004c5c84fe846e04255608dc78b60a0d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fd20dbed004c5c84fe846e04255608dc78b60a0d", "patch": "@@ -434,33 +434,41 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     ) -> Option<Const<'tcx>> {\n         let span = source_info.span;\n \n-        // perform any special checking for specific Rvalue types\n+        let overflow_check = self.tcx.sess.overflow_checks();\n+\n+        // Perform any special handling for specific Rvalue types.\n+        // Generally, checks here fall into one of two categories:\n+        //   1. Additional checking to provide useful lints to the user\n+        //        - In this case, we will do some validation and then fall through to the\n+        //          end of the function which evals the assignment.\n+        //   2. Working around bugs in other parts of the compiler\n+        //        - In this case, we'll return `None` from this function to stop evaluation.\n         match rvalue {\n-            Rvalue::UnaryOp(UnOp::Neg, arg) => {\n+            // Additional checking: if overflow checks are disabled (which is usually the case in\n+            // release mode), then we need to do additional checking here to give lints to the user\n+            // if an overflow would occur.\n+            Rvalue::UnaryOp(UnOp::Neg, arg) if !overflow_check => {\n                 trace!(\"checking UnaryOp(op = Neg, arg = {:?})\", arg);\n-                let overflow_check = self.tcx.sess.overflow_checks();\n \n                 self.use_ecx(source_info, |this| {\n-                    // We check overflow in debug mode already\n-                    // so should only check in release mode.\n-                    if !overflow_check {\n-                        let ty = arg.ty(&this.local_decls, this.tcx);\n-\n-                        if ty.is_integral() {\n-                            let arg = this.ecx.eval_operand(arg, None)?;\n-                            let prim = this.ecx.read_immediate(arg)?;\n-                            // Need to do overflow check here: For actual CTFE, MIR\n-                            // generation emits code that does this before calling the op.\n-                            if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                                throw_panic!(OverflowNeg)\n-                            }\n+                    let ty = arg.ty(&this.local_decls, this.tcx);\n+\n+                    if ty.is_integral() {\n+                        let arg = this.ecx.eval_operand(arg, None)?;\n+                        let prim = this.ecx.read_immediate(arg)?;\n+                        // Need to do overflow check here: For actual CTFE, MIR\n+                        // generation emits code that does this before calling the op.\n+                        if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n+                            throw_panic!(OverflowNeg)\n                         }\n                     }\n \n                     Ok(())\n                 })?;\n             }\n \n+            // Additional checking: check for overflows on integer binary operations and report\n+            // them to the user as lints.\n             Rvalue::BinaryOp(op, left, right) => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n \n@@ -490,25 +498,34 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                         return None;\n                     }\n                 }\n-                self.use_ecx(source_info, |this| {\n-                    let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n-                    let (_, overflow, _ty) = this.ecx.overflowing_binary_op(*op, l, r)?;\n-\n-                    // We check overflow in debug mode already\n-                    // so should only check in release mode.\n-                    if !this.tcx.sess.overflow_checks() && overflow {\n-                        let err = err_panic!(Overflow(*op)).into();\n-                        return Err(err);\n-                    }\n \n-                    Ok(())\n-                })?;\n+                // If overflow checking is enabled (like in debug mode by default),\n+                // then we'll already catch overflow when we evaluate the `Assert` statement\n+                // in MIR. However, if overflow checking is disabled, then there won't be any\n+                // `Assert` statement and so we have to do additional checking here.\n+                if !overflow_check {\n+                    self.use_ecx(source_info, |this| {\n+                        let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n+                        let (_, overflow, _ty) = this.ecx.overflowing_binary_op(*op, l, r)?;\n+\n+                        if overflow {\n+                            let err = err_panic!(Overflow(*op)).into();\n+                            return Err(err);\n+                        }\n+\n+                        Ok(())\n+                    })?;\n+                }\n             }\n \n+            // Work around: avoid ICE in miri.\n+            // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n+            // from a function argument that hasn't been assigned to in this function. The main\n+            // issue is if an arg is a fat-pointer, miri `expects()` to be able to read the value\n+            // of that pointer to get size info. However, since this is `ConstProp`, that argument\n+            // doesn't actually have a backing value and so this causes an ICE.\n             Rvalue::Ref(_, _, Place { base: PlaceBase::Local(local), projection: box [] }) => {\n                 trace!(\"checking Ref({:?})\", place);\n-                // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n-                // from a function argument that hasn't been assigned to in this function.\n                 let alive =\n                     if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n                         true\n@@ -520,9 +537,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 }\n             }\n \n+            // Work around: avoid extra unnecessary locals.\n+            // FIXME(wesleywiser): const eval will turn this into a `const Scalar(<ZST>)` that\n+            // `SimplifyLocals` doesn't know it can remove.\n             Rvalue::Aggregate(_, operands) if operands.len() == 0 => {\n-                // FIXME(wesleywiser): const eval will turn this into a `const Scalar(<ZST>)` that\n-                // `SimplifyLocals` doesn't know it can remove.\n                 return None;\n             }\n "}]}