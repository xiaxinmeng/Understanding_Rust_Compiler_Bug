{"sha": "dc9596358ac2fa14a46773bad158603ba5a769e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOTU5NjM1OGFjMmZhMTRhNDY3NzNiYWQxNTg2MDNiYTVhNzY5ZTA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-10T09:09:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-10T09:09:09Z"}, "message": "Merge #5288\n\n5288: Avoid accidently stumping over config values r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9df1537579505c82646c5d156a7f541bf18bd018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9df1537579505c82646c5d156a7f541bf18bd018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc9596358ac2fa14a46773bad158603ba5a769e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfCDA1CRBK7hj4Ov3rIwAAdHIIAAtnBFFWq5zRE9H9nwF12c7u\nno4a6klayyDqZTc+2Y6hL4++vzYvbj4QwvfxX6igLiGcD+FfNzeTisIoUgSEYPBE\nk7Z8GVn3Jl1zJDeZLfWvEumSq77VUULqNXfqWqynsUw39wWxwoy/6EABDjNUu3XU\nCn2F/TGyi1DXBBCSH3CrrozJVfeONJN7UbBd4mJYabGMP32MGsWFVdEPOAfrZVeV\ni0UNXcploVFCUD+5uIJQsNgj/wNyBBEY7Iu+LzUFj1NyT94xBhQk38Q5sOMZLRJO\nUWJujiRMgMHSiaVwnyVr2UPYvOwEQYtZOblMDiQ9Sri9Sh+6vdMgpSapW8thHPo=\n=yD2b\n-----END PGP SIGNATURE-----\n", "payload": "tree 9df1537579505c82646c5d156a7f541bf18bd018\nparent 5fc84f071d8fe1792db1f20bf735ec6b85a51a2f\nparent 17edf50e2c8ce92a6f056e311d68000d64838873\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594372149 +0000\ncommitter GitHub <noreply@github.com> 1594372149 +0000\n\nMerge #5288\n\n5288: Avoid accidently stumping over config values r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc9596358ac2fa14a46773bad158603ba5a769e0", "html_url": "https://github.com/rust-lang/rust/commit/dc9596358ac2fa14a46773bad158603ba5a769e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc9596358ac2fa14a46773bad158603ba5a769e0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fc84f071d8fe1792db1f20bf735ec6b85a51a2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc84f071d8fe1792db1f20bf735ec6b85a51a2f", "html_url": "https://github.com/rust-lang/rust/commit/5fc84f071d8fe1792db1f20bf735ec6b85a51a2f"}, {"sha": "17edf50e2c8ce92a6f056e311d68000d64838873", "url": "https://api.github.com/repos/rust-lang/rust/commits/17edf50e2c8ce92a6f056e311d68000d64838873", "html_url": "https://github.com/rust-lang/rust/commit/17edf50e2c8ce92a6f056e311d68000d64838873"}], "stats": {"total": 303, "additions": 169, "deletions": 134}, "files": [{"sha": "65f1a6d15a7dce3a460d4158ab3be64989c64da0", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc9596358ac2fa14a46773bad158603ba5a769e0/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9596358ac2fa14a46773bad158603ba5a769e0/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=dc9596358ac2fa14a46773bad158603ba5a769e0", "patch": "@@ -120,8 +120,8 @@ fn run_server() -> Result<()> {\n         };\n \n         let mut config = Config::new(root_path);\n-        if let Some(value) = &initialize_params.initialization_options {\n-            config.update(value);\n+        if let Some(json) = initialize_params.initialization_options {\n+            config.update(json);\n         }\n         config.update_caps(&initialize_params.capabilities);\n "}, {"sha": "9dd81b4fc71bbe0d375a669f70afcc3f1b9bd1ff", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 164, "deletions": 129, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/dc9596358ac2fa14a46773bad158603ba5a769e0/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9596358ac2fa14a46773bad158603ba5a769e0/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=dc9596358ac2fa14a46773bad158603ba5a769e0", "patch": "@@ -111,14 +111,8 @@ pub struct NotificationsConfig {\n \n #[derive(Debug, Clone)]\n pub enum RustfmtConfig {\n-    Rustfmt {\n-        extra_args: Vec<String>,\n-    },\n-    #[allow(unused)]\n-    CustomCommand {\n-        command: String,\n-        args: Vec<String>,\n-    },\n+    Rustfmt { extra_args: Vec<String> },\n+    CustomCommand { command: String, args: Vec<String> },\n }\n \n #[derive(Debug, Clone, Default)]\n@@ -178,146 +172,110 @@ impl Config {\n         }\n     }\n \n-    #[rustfmt::skip]\n-    pub fn update(&mut self, value: &serde_json::Value) {\n-        log::info!(\"Config::update({:#})\", value);\n-\n-        let client_caps = self.client_caps.clone();\n-        let linked_projects = self.linked_projects.clone();\n-        *self = Config::new(self.root_path.clone());\n-        self.client_caps = client_caps;\n-        self.linked_projects = linked_projects;\n-\n-        set(value, \"/withSysroot\", &mut self.with_sysroot);\n-        set(value, \"/diagnostics/enable\", &mut self.publish_diagnostics);\n-        set(value, \"/diagnostics/warningsAsInfo\", &mut self.diagnostics.warnings_as_info);\n-        set(value, \"/diagnostics/warningsAsHint\", &mut self.diagnostics.warnings_as_hint);\n-        set(value, \"/lruCapacity\", &mut self.lru_capacity);\n-        self.files.watcher = match get(value, \"/files/watcher\") {\n-            Some(\"client\") => FilesWatcher::Client,\n-            Some(\"notify\") | _ => FilesWatcher::Notify\n+    pub fn update(&mut self, json: serde_json::Value) {\n+        log::info!(\"Config::update({:#})\", json);\n+        let data = ConfigData::from_json(json);\n+\n+        self.with_sysroot = data.withSysroot;\n+        self.publish_diagnostics = data.diagnostics_enable;\n+        self.diagnostics = DiagnosticsConfig {\n+            warnings_as_info: data.diagnostics_warningsAsInfo,\n+            warnings_as_hint: data.diagnostics_warningsAsHint,\n+        };\n+        self.lru_capacity = data.lruCapacity;\n+        self.files.watcher = match data.files_watcher.as_str() {\n+            \"notify\" => FilesWatcher::Notify,\n+            \"client\" | _ => FilesWatcher::Client,\n+        };\n+        self.notifications =\n+            NotificationsConfig { cargo_toml_not_found: data.notifications_cargoTomlNotFound };\n+        self.cargo = CargoConfig {\n+            no_default_features: data.cargo_noDefaultFeatures,\n+            all_features: data.cargo_allFeatures,\n+            features: data.cargo_features.clone(),\n+            load_out_dirs_from_check: data.cargo_loadOutDirsFromCheck,\n+            target: data.cargo_target,\n         };\n-        set(value, \"/notifications/cargoTomlNotFound\", &mut self.notifications.cargo_toml_not_found);\n-\n-        set(value, \"/cargo/noDefaultFeatures\", &mut self.cargo.no_default_features);\n-        set(value, \"/cargo/allFeatures\", &mut self.cargo.all_features);\n-        set(value, \"/cargo/features\", &mut self.cargo.features);\n-        set(value, \"/cargo/loadOutDirsFromCheck\", &mut self.cargo.load_out_dirs_from_check);\n-        set(value, \"/cargo/target\", &mut self.cargo.target);\n-\n-        match get(value, \"/procMacro/enable\") {\n-            Some(true) => {\n-                if let Ok(path) = std::env::current_exe() {\n-                    self.proc_macro_srv = Some((path, vec![\"proc-macro\".into()]));\n-                }\n-            }\n-            _ => self.proc_macro_srv = None,\n-        }\n \n-        match get::<Vec<String>>(value, \"/rustfmt/overrideCommand\") {\n+        self.proc_macro_srv = if data.procMacro_enable {\n+            std::env::current_exe().ok().map(|path| (path, vec![\"proc-macro\".into()]))\n+        } else {\n+            None\n+        };\n+\n+        self.rustfmt = match data.rustfmt_overrideCommand {\n             Some(mut args) if !args.is_empty() => {\n                 let command = args.remove(0);\n-                self.rustfmt = RustfmtConfig::CustomCommand {\n-                    command,\n-                    args,\n-                }\n-            }\n-            _ => {\n-                if let RustfmtConfig::Rustfmt { extra_args } = &mut self.rustfmt {\n-                    set(value, \"/rustfmt/extraArgs\", extra_args);\n-                }\n+                RustfmtConfig::CustomCommand { command, args }\n             }\n+            Some(_) | None => RustfmtConfig::Rustfmt { extra_args: data.rustfmt_extraArgs },\n         };\n \n-        if let Some(false) = get(value, \"/checkOnSave/enable\") {\n-            // check is disabled\n-            self.flycheck = None;\n-        } else {\n-            // check is enabled\n-            match get::<Vec<String>>(value, \"/checkOnSave/overrideCommand\") {\n-                // first see if the user has completely overridden the command\n+        self.flycheck = if data.checkOnSave_enable {\n+            let flycheck_config = match data.checkOnSave_overrideCommand {\n                 Some(mut args) if !args.is_empty() => {\n                     let command = args.remove(0);\n-                    self.flycheck = Some(FlycheckConfig::CustomCommand {\n-                        command,\n-                        args,\n-                    });\n-                }\n-                // otherwise configure command customizations\n-                _ => {\n-                    if let Some(FlycheckConfig::CargoCommand { command, extra_args, all_targets, all_features, features })\n-                        = &mut self.flycheck\n-                    {\n-                        set(value, \"/checkOnSave/extraArgs\", extra_args);\n-                        set(value, \"/checkOnSave/command\", command);\n-                        set(value, \"/checkOnSave/allTargets\", all_targets);\n-                        *all_features = get(value, \"/checkOnSave/allFeatures\").unwrap_or(self.cargo.all_features);\n-                        *features = get(value, \"/checkOnSave/features\").unwrap_or(self.cargo.features.clone());\n-                    }\n+                    FlycheckConfig::CustomCommand { command, args }\n                 }\n+                Some(_) | None => FlycheckConfig::CargoCommand {\n+                    command: data.checkOnSave_command,\n+                    all_targets: data.checkOnSave_allTargets,\n+                    all_features: data.checkOnSave_allFeatures.unwrap_or(data.cargo_allFeatures),\n+                    features: data.checkOnSave_features.unwrap_or(data.cargo_features),\n+                    extra_args: data.checkOnSave_extraArgs,\n+                },\n             };\n-        }\n-\n-        set(value, \"/inlayHints/typeHints\", &mut self.inlay_hints.type_hints);\n-        set(value, \"/inlayHints/parameterHints\", &mut self.inlay_hints.parameter_hints);\n-        set(value, \"/inlayHints/chainingHints\", &mut self.inlay_hints.chaining_hints);\n-        set(value, \"/inlayHints/maxLength\", &mut self.inlay_hints.max_length);\n-        set(value, \"/completion/postfix/enable\", &mut self.completion.enable_postfix_completions);\n-        set(value, \"/completion/addCallParenthesis\", &mut self.completion.add_call_parenthesis);\n-        set(value, \"/completion/addCallArgumentSnippets\", &mut self.completion.add_call_argument_snippets);\n-        set(value, \"/callInfo/full\", &mut self.call_info_full);\n-\n-        let mut lens_enabled = true;\n-        set(value, \"/lens/enable\", &mut lens_enabled);\n-        if lens_enabled {\n-            set(value, \"/lens/run\", &mut self.lens.run);\n-            set(value, \"/lens/debug\", &mut self.lens.debug);\n-            set(value, \"/lens/implementations\", &mut self.lens.implementations);\n+            Some(flycheck_config)\n         } else {\n-            self.lens = LensConfig::NO_LENS;\n-        }\n+            None\n+        };\n \n-        if let Some(linked_projects) = get::<Vec<ManifestOrProjectJson>>(value, \"/linkedProjects\") {\n-            if !linked_projects.is_empty() {\n-                self.linked_projects.clear();\n-                for linked_project in linked_projects {\n-                    let linked_project = match linked_project {\n-                        ManifestOrProjectJson::Manifest(it) => {\n-                            let path = self.root_path.join(it);\n-                            match ProjectManifest::from_manifest_file(path) {\n-                                Ok(it) => it.into(),\n-                                Err(_) => continue,\n-                            }\n-                        }\n-                        ManifestOrProjectJson::ProjectJson(it) => ProjectJson::new(&self.root_path, it).into(),\n-                    };\n-                    self.linked_projects.push(linked_project);\n-                }\n-            }\n-        }\n+        self.inlay_hints = InlayHintsConfig {\n+            type_hints: data.inlayHints_typeHints,\n+            parameter_hints: data.inlayHints_parameterHints,\n+            chaining_hints: data.inlayHints_chainingHints,\n+            max_length: data.inlayHints_maxLength,\n+        };\n \n-        let mut use_hover_actions = false;\n-        set(value, \"/hoverActions/enable\", &mut use_hover_actions);\n-        if use_hover_actions {\n-            set(value, \"/hoverActions/implementations\", &mut self.hover.implementations);\n-            set(value, \"/hoverActions/run\", &mut self.hover.run);\n-            set(value, \"/hoverActions/debug\", &mut self.hover.debug);\n-            set(value, \"/hoverActions/gotoTypeDef\", &mut self.hover.goto_type_def);\n-        } else {\n-            self.hover = HoverConfig::NO_ACTIONS;\n-        }\n+        self.completion.enable_postfix_completions = data.completion_postfix_enable;\n+        self.completion.add_call_parenthesis = data.completion_addCallParenthesis;\n+        self.completion.add_call_argument_snippets = data.completion_addCallArgumentSnippets;\n \n-        log::info!(\"Config::update() = {:#?}\", self);\n+        self.call_info_full = data.callInfo_full;\n \n-        fn get<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str) -> Option<T> {\n-            value.pointer(pointer).and_then(|it| T::deserialize(it).ok())\n-        }\n+        self.lens = LensConfig {\n+            run: data.lens_enable && data.lens_run,\n+            debug: data.lens_enable && data.lens_debug,\n+            implementations: data.lens_enable && data.lens_implementations,\n+        };\n \n-        fn set<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str, slot: &mut T) {\n-            if let Some(new_value) = get(value, pointer) {\n-                *slot = new_value\n+        if !data.linkedProjects.is_empty() {\n+            self.linked_projects.clear();\n+            for linked_project in data.linkedProjects {\n+                let linked_project = match linked_project {\n+                    ManifestOrProjectJson::Manifest(it) => {\n+                        let path = self.root_path.join(it);\n+                        match ProjectManifest::from_manifest_file(path) {\n+                            Ok(it) => it.into(),\n+                            Err(_) => continue,\n+                        }\n+                    }\n+                    ManifestOrProjectJson::ProjectJson(it) => {\n+                        ProjectJson::new(&self.root_path, it).into()\n+                    }\n+                };\n+                self.linked_projects.push(linked_project);\n             }\n         }\n+\n+        self.hover = HoverConfig {\n+            implementations: data.hoverActions_enable && data.hoverActions_implementations,\n+            run: data.hoverActions_enable && data.hoverActions_run,\n+            debug: data.hoverActions_enable && data.hoverActions_debug,\n+            goto_type_def: data.hoverActions_enable && data.hoverActions_gotoTypeDef,\n+        };\n+\n+        log::info!(\"Config::update() = {:#?}\", self);\n     }\n \n     pub fn update_caps(&mut self, caps: &ClientCapabilities) {\n@@ -380,3 +338,80 @@ enum ManifestOrProjectJson {\n     Manifest(PathBuf),\n     ProjectJson(ProjectJsonData),\n }\n+\n+macro_rules! config_data {\n+    (struct $name:ident { $($field:ident: $ty:ty = $default:expr,)*}) => {\n+        #[allow(non_snake_case)]\n+        struct $name { $($field: $ty,)* }\n+        impl $name {\n+            fn from_json(mut json: serde_json::Value) -> $name {\n+                $name {$(\n+                    $field: {\n+                        let pointer = stringify!($field).replace('_', \"/\");\n+                        let pointer = format!(\"/{}\", pointer);\n+                        json.pointer_mut(&pointer)\n+                            .and_then(|it| serde_json::from_value(it.take()).ok())\n+                            .unwrap_or($default)\n+                    },\n+                )*}\n+            }\n+        }\n+\n+    };\n+}\n+\n+config_data! {\n+    struct ConfigData {\n+        callInfo_full: bool = true,\n+\n+        cargo_allFeatures: bool          = false,\n+        cargo_features: Vec<String>      = Vec::new(),\n+        cargo_loadOutDirsFromCheck: bool = false,\n+        cargo_noDefaultFeatures: bool    = false,\n+        cargo_target: Option<String>     = None,\n+\n+        checkOnSave_allFeatures: Option<bool>            = None,\n+        checkOnSave_allTargets: bool                     = true,\n+        checkOnSave_command: String                      = \"check\".into(),\n+        checkOnSave_enable: bool                         = false,\n+        checkOnSave_extraArgs: Vec<String>               = Vec::new(),\n+        checkOnSave_features: Option<Vec<String>>        = None,\n+        checkOnSave_overrideCommand: Option<Vec<String>> = None,\n+\n+        completion_addCallArgumentSnippets: bool = true,\n+        completion_addCallParenthesis: bool      = true,\n+        completion_postfix_enable: bool          = true,\n+\n+        diagnostics_enable: bool                = true,\n+        diagnostics_warningsAsHint: Vec<String> = Vec::new(),\n+        diagnostics_warningsAsInfo: Vec<String> = Vec::new(),\n+\n+        files_watcher: String = \"client\".into(),\n+\n+        hoverActions_debug: bool           = true,\n+        hoverActions_enable: bool          = true,\n+        hoverActions_gotoTypeDef: bool     = true,\n+        hoverActions_implementations: bool = true,\n+        hoverActions_run: bool             = true,\n+\n+        inlayHints_chainingHints: bool      = true,\n+        inlayHints_maxLength: Option<usize> = None,\n+        inlayHints_parameterHints: bool     = true,\n+        inlayHints_typeHints: bool          = true,\n+\n+        lens_debug: bool           = true,\n+        lens_enable: bool          = true,\n+        lens_implementations: bool = true,\n+        lens_run: bool             = true,\n+\n+        linkedProjects: Vec<ManifestOrProjectJson> = Vec::new(),\n+        lruCapacity: Option<usize>                 = None,\n+        notifications_cargoTomlNotFound: bool      = true,\n+        procMacro_enable: bool                     = false,\n+\n+        rustfmt_extraArgs: Vec<String>               = Vec::new(),\n+        rustfmt_overrideCommand: Option<Vec<String>> = None,\n+\n+        withSysroot: bool = true,\n+    }\n+}"}, {"sha": "b48239058742c0781428053af9cd0251c219451c", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc9596358ac2fa14a46773bad158603ba5a769e0/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9596358ac2fa14a46773bad158603ba5a769e0/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=dc9596358ac2fa14a46773bad158603ba5a769e0", "patch": "@@ -467,10 +467,10 @@ impl GlobalState {\n                             (Some(err), _) => {\n                                 log::error!(\"failed to fetch the server settings: {:?}\", err)\n                             }\n-                            (None, Some(configs)) => {\n-                                if let Some(new_config) = configs.get(0) {\n+                            (None, Some(mut configs)) => {\n+                                if let Some(json) = configs.get_mut(0) {\n                                     let mut config = this.config.clone();\n-                                    config.update(&new_config);\n+                                    config.update(json.take());\n                                     this.update_configuration(config);\n                                 }\n                             }"}]}