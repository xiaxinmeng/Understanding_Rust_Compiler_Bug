{"sha": "51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZGNkY2ZkOTQ0NTA4NTFkNjRjNmQ3YzRlZWFiNDFjM2U2MWY1NDY=", "commit": {"author": {"name": "Artyom Pavlov", "email": "newpavlov@gmail.com", "date": "2019-08-17T18:54:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-17T18:54:56Z"}, "message": "Merge branch 'master' into redox_builder", "tree": {"sha": "03736fa623009967fb3371d9d51ddc7240037f41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03736fa623009967fb3371d9d51ddc7240037f41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdWE2ACRBK7hj4Ov3rIwAAdHIIAFOH4hxuck8vmkLnVC6+MQPF\nhBCSzE3dXc9N4xNEUv+siEn0O2eGpxBUAv1UM6CvNZL2V0tEfIw00kE4HriK04Ws\nvq4LUQr9wZjHNyViKZvacyuHLCpTIftzl1tXOxdaHjrbeQPfRSmbhnYPMhVSiZsi\nsw68Ev6vUAOykkKCgVZEpNMU5YDK/abpprK9wuYXdVviWVszIh8S7dy6GMtJufUj\nSAj+KmzMOhfzLNirY+BcvPESvBTRubkmAVNnUjag3Kamh3o/g0wtTsWMJVY11+ZB\nQDakc5lCS0ggwQyUbFiUROYRUjNy5RAYfY+9IrOIqsbwLTIhGI9gn+2OHt633Vg=\n=NWK9\n-----END PGP SIGNATURE-----\n", "payload": "tree 03736fa623009967fb3371d9d51ddc7240037f41\nparent 7b8273c2e873b814b7c115eabae398d6f11d695b\nparent d65e272a9fe3e61aa5f229c5358e35a909435575\nauthor Artyom Pavlov <newpavlov@gmail.com> 1566068096 +0000\ncommitter GitHub <noreply@github.com> 1566068096 +0000\n\nMerge branch 'master' into redox_builder"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "html_url": "https://github.com/rust-lang/rust/commit/51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b8273c2e873b814b7c115eabae398d6f11d695b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b8273c2e873b814b7c115eabae398d6f11d695b", "html_url": "https://github.com/rust-lang/rust/commit/7b8273c2e873b814b7c115eabae398d6f11d695b"}, {"sha": "d65e272a9fe3e61aa5f229c5358e35a909435575", "url": "https://api.github.com/repos/rust-lang/rust/commits/d65e272a9fe3e61aa5f229c5358e35a909435575", "html_url": "https://github.com/rust-lang/rust/commit/d65e272a9fe3e61aa5f229c5358e35a909435575"}], "stats": {"total": 10372, "additions": 6913, "deletions": 3459}, "files": [{"sha": "59571bc7f6d54942d7988294f16de23eb4ff6ea9", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -106,7 +106,7 @@ dependencies = [\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.61 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n \n@@ -1138,19 +1138,12 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-alloc 1.0.0\",\n  \"rustc-std-workspace-core 1.0.0\",\n-]\n-\n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n  \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2736,7 +2729,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2894,7 +2887,7 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"punycode 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_target 0.0.0\",\n@@ -3534,8 +3527,9 @@ dependencies = [\n  \"core 0.0.0\",\n  \"dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"hashbrown 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hashbrown 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.61 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hashbrown 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n  \"profiler_builtins 0.0.0\",\n@@ -4450,7 +4444,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum globset 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef4feaabe24a0a658fd9cf4a9acf6ed284f045c77df0f49020ba3245cfb7b454\"\n \"checksum h2 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a539b63339fbbb00e081e84b6e11bd1d9634a82d91da2984a18ac74a8823f392\"\n \"checksum handlebars 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n-\"checksum hashbrown 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9529213c67695ca2d146e6f263b7b72df8fa973368beadf767e8ed80c03f2f36\"\n \"checksum hashbrown 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1de41fb8dba9714efd92241565cdff73f78508c95697dd56787d3cba27e2353\"\n \"checksum heck 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea04fa3ead4e05e51a7c806fc07271fdbde4e246a6c6d1efd52e72230b771b82\"\n \"checksum hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n@@ -4600,7 +4593,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-serialize 546.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"61673783f2089e01033ffa82d1988f55175402071b31253a358292e1624d4602\"\n \"checksum rustc-ap-syntax 546.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28f3dd1346d5b0269c07a4a78855e309a298ab569c9c1302d4d4f57f8eee4e84\"\n \"checksum rustc-ap-syntax_pos 546.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"45e67b526dbda3a0c7dab91c8947d43685e7697f52686a4949da3c179cd7c979\"\n-\"checksum rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7f4dccf6f4891ebcc0c39f9b6eb1a83b9bf5d747cb439ec6fba4f3b977038af\"\n+\"checksum rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d2e07e19601f21c59aad953c2632172ba70cb27e685771514ea66e4062b3363\"\n \"checksum rustc-rayon-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"79d38ca7cbc22fa59f09d8534ea4b27f67b0facf0cbe274433aceea227a02543\""}, {"sha": "724bc36ecc6fb7fd2bb6b9783416528c7554b9ae", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -144,7 +144,7 @@ then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```batch\n-> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n+> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n > python x.py build\n ```\n "}, {"sha": "f26f6e6c888eda387ced2872b2e6eb3dc9074f75", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -22,7 +22,7 @@ Language\n - [You can now use `_` as an identifier for consts.][61347] e.g. You can write\n   `const _: u32 = 5;`.\n - [You can now use `#[repr(align(X)]` on enums.][61229]\n-- [The  `?`/_\"Kleene\"_ macro operator is now available in the\n+- [The  `?` Kleene macro operator is now available in the\n   2015 edition.][60932]\n \n Compiler"}, {"sha": "a3ec4f2044cbd720fe469e89d744d0294a6f42cd", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -141,10 +141,10 @@\n # library and facade crates.\n #compiler-docs = false\n \n-# Indicate whether submodules are managed and updated automatically.\n+# Indicate whether git submodules are managed and updated automatically.\n #submodules = true\n \n-# Update submodules only when the checked out commit in the submodules differs\n+# Update git submodules only when the checked out commit in the submodules differs\n # from what is committed in the main rustc repo.\n #fast-submodules = true\n "}, {"sha": "ce92ce026967117016ab27620dafaad86770e207", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -37,26 +37,14 @@ fn main() {\n             let mut new = None;\n             if let Some(current_as_str) = args[i].to_str() {\n                 if (&*args[i - 1] == \"-C\" && current_as_str.starts_with(\"metadata\")) ||\n-                   current_as_str.starts_with(\"-Cmetadata\") {\n+                    current_as_str.starts_with(\"-Cmetadata\") {\n                     new = Some(format!(\"{}-{}\", current_as_str, s));\n                 }\n             }\n             if let Some(new) = new { args[i] = new.into(); }\n         }\n     }\n \n-    // Drop `--error-format json` because despite our desire for json messages\n-    // from Cargo we don't want any from rustc itself.\n-    if let Some(n) = args.iter().position(|n| n == \"--error-format\") {\n-        args.remove(n);\n-        args.remove(n);\n-    }\n-\n-    if let Some(s) = env::var_os(\"RUSTC_ERROR_FORMAT\") {\n-        args.push(\"--error-format\".into());\n-        args.push(s);\n-    }\n-\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n     let target = args.windows(2)\n@@ -101,7 +89,7 @@ fn main() {\n     if let Some(crate_name) = crate_name {\n         if let Some(target) = env::var_os(\"RUSTC_TIME\") {\n             if target == \"all\" ||\n-               target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n+                target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n             {\n                 cmd.arg(\"-Ztime\");\n             }\n@@ -110,8 +98,17 @@ fn main() {\n \n     // Non-zero stages must all be treated uniformly to avoid problems when attempting to uplift\n     // compiler libraries and such from stage 1 to 2.\n+    //\n+    // FIXME: the fact that core here is excluded is due to core_arch from our stdarch submodule\n+    // being broken on the beta compiler with bootstrap passed, so this is a temporary workaround\n+    // (we've just snapped, so there are no cfg(bootstrap) related annotations in core).\n     if stage == \"0\" {\n-        cmd.arg(\"--cfg\").arg(\"bootstrap\");\n+        if crate_name != Some(\"core\") {\n+            cmd.arg(\"--cfg\").arg(\"bootstrap\");\n+        } else {\n+            // NOTE(eddyb) see FIXME above, except now we need annotations again in core.\n+            cmd.arg(\"--cfg\").arg(\"boostrap_stdarch_ignore_this\");\n+        }\n     }\n \n     // Print backtrace in case of ICE\n@@ -132,10 +129,7 @@ fn main() {\n         cmd.arg(\"-Dwarnings\");\n         cmd.arg(\"-Drust_2018_idioms\");\n         cmd.arg(\"-Dunused_lifetimes\");\n-        // cfg(not(bootstrap)): Remove this during the next stage 0 compiler update.\n-        // `-Drustc::internal` is a new feature and `rustc_version` mis-reports the `stage`.\n-        let cfg_not_bootstrap = stage != \"0\" && crate_name != Some(\"rustc_version\");\n-        if cfg_not_bootstrap && use_internal_lints(crate_name) {\n+        if use_internal_lints(crate_name) {\n             cmd.arg(\"-Zunstable-options\");\n             cmd.arg(\"-Drustc::internal\");\n         }\n@@ -287,10 +281,6 @@ fn main() {\n                 cmd.arg(\"-C\").arg(\"target-feature=-crt-static\");\n             }\n         }\n-\n-        if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n-            cmd.arg(\"--remap-path-prefix\").arg(&map);\n-        }\n     } else {\n         // Override linker if necessary.\n         if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n@@ -307,6 +297,10 @@ fn main() {\n         }\n     }\n \n+    if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n+        cmd.arg(\"--remap-path-prefix\").arg(&map);\n+    }\n+\n     // Force all crates compiled by this compiler to (a) be unstable and (b)\n     // allow the `rustc_private` feature to link to other unstable crates\n     // also in the sysroot. We also do this for host crates, since those"}, {"sha": "f0054c36c0c886da0ea0f22d27c03c57cd56cccd", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 23, "deletions": 69, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -145,7 +145,7 @@ impl StepDescription {\n             only_hosts: S::ONLY_HOSTS,\n             should_run: S::should_run,\n             make_run: S::make_run,\n-            name: unsafe { ::std::intrinsics::type_name::<S>() },\n+            name: std::any::type_name::<S>(),\n         }\n     }\n \n@@ -754,76 +754,20 @@ impl<'a> Builder<'a> {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n \n-        // command specific path, we call clear_if_dirty with this\n-        let mut my_out = match cmd {\n-            \"build\" => self.cargo_out(compiler, mode, target),\n-\n-            // This is the intended out directory for crate documentation.\n-            \"doc\" | \"rustdoc\" =>  self.crate_doc_out(target),\n-\n-            _ => self.stage_out(compiler, mode),\n-        };\n-\n-        // This is for the original compiler, but if we're forced to use stage 1, then\n-        // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n-        // we copy the libs forward.\n-        let cmp = self.compiler_for(compiler.stage, compiler.host, target);\n-\n-        let libstd_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::libstd_stamp(self, cmp, target),\n-            _ => compile::libstd_stamp(self, cmp, target),\n-        };\n-\n-        let libtest_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::libtest_stamp(self, cmp, target),\n-            _ => compile::libtest_stamp(self, cmp, target),\n-        };\n-\n-        let librustc_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::librustc_stamp(self, cmp, target),\n-            _ => compile::librustc_stamp(self, cmp, target),\n-        };\n+        // Codegen backends are not yet tracked by -Zbinary-dep-depinfo,\n+        // so we need to explicitly clear out if they've been updated.\n+        for backend in self.codegen_backends(compiler) {\n+            self.clear_if_dirty(&out_dir, &backend);\n+        }\n \n         if cmd == \"doc\" || cmd == \"rustdoc\" {\n-            if mode == Mode::Rustc || mode == Mode::ToolRustc || mode == Mode::Codegen {\n+            let my_out = match mode {\n                 // This is the intended out directory for compiler documentation.\n-                my_out = self.compiler_doc_out(target);\n-            }\n+                Mode::Rustc | Mode::ToolRustc | Mode::Codegen => self.compiler_doc_out(target),\n+                _ => self.crate_doc_out(target),\n+            };\n             let rustdoc = self.rustdoc(compiler);\n             self.clear_if_dirty(&my_out, &rustdoc);\n-        } else if cmd != \"test\" {\n-            match mode {\n-                Mode::Std => {\n-                    self.clear_if_dirty(&my_out, &self.rustc(compiler));\n-                    for backend in self.codegen_backends(compiler) {\n-                        self.clear_if_dirty(&my_out, &backend);\n-                    }\n-                },\n-                Mode::Test => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                },\n-                Mode::Rustc => {\n-                    self.clear_if_dirty(&my_out, &self.rustc(compiler));\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                },\n-                Mode::Codegen => {\n-                    self.clear_if_dirty(&my_out, &librustc_stamp);\n-                },\n-                Mode::ToolBootstrap => { },\n-                Mode::ToolStd => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                },\n-                Mode::ToolTest => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                },\n-                Mode::ToolRustc => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                    self.clear_if_dirty(&my_out, &librustc_stamp);\n-                },\n-            }\n         }\n \n         cargo\n@@ -861,6 +805,19 @@ impl<'a> Builder<'a> {\n             },\n         }\n \n+        // This tells Cargo (and in turn, rustc) to output more complete\n+        // dependency information.  Most importantly for rustbuild, this\n+        // includes sysroot artifacts, like libstd, which means that we don't\n+        // need to track those in rustbuild (an error prone process!). This\n+        // feature is currently unstable as there may be some bugs and such, but\n+        // it represents a big improvement in rustbuild's reliability on\n+        // rebuilds, so we're using it here.\n+        //\n+        // For some additional context, see #63470 (the PR originally adding\n+        // this), as well as #63012 which is the tracking issue for this\n+        // feature on the rustc side.\n+        cargo.arg(\"-Zbinary-dep-depinfo\");\n+\n         cargo.arg(\"-j\").arg(self.jobs().to_string());\n         // Remove make-related flags to ensure Cargo can correctly set things up\n         cargo.env_remove(\"MAKEFLAGS\");\n@@ -980,9 +937,6 @@ impl<'a> Builder<'a> {\n         if let Some(target_linker) = self.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n-        if let Some(ref error_format) = self.config.rustc_error_format {\n-            cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n-        }\n         if !([\"build\", \"check\", \"clippy\", \"fix\", \"rustc\"].contains(&cmd)) && want_rustdoc {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(compiler));\n         }"}, {"sha": "a4cb81d3d1b1b02716417c3c26752f7284b3a2f5", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -46,7 +46,7 @@ fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n     } else if target.contains(\"openbsd\") {\n         Some(PathBuf::from(\"ar\"))\n     } else if target.contains(\"vxworks\") {\n-        Some(PathBuf::from(\"vx-ar\"))\n+        Some(PathBuf::from(\"wr-ar\"))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();"}, {"sha": "caa4843da4d369a1230c5be822be02329a889475", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.38.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.39.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "6e6fea6b831a7507f3835fa21c3032d6f9459b71", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -245,7 +245,6 @@ impl Step for Rustdoc {\n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n         add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n-        builder.cargo(compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n "}, {"sha": "96987d081594f019bfe6350da04d338014777f25", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -15,7 +15,7 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio, exit};\n use std::str;\n \n-use build_helper::{output, mtime, t, up_to_date};\n+use build_helper::{output, t, up_to_date};\n use filetime::FileTime;\n use serde::Deserialize;\n use serde_json;\n@@ -274,8 +274,6 @@ impl Step for StdLink {\n             // for reason why the sanitizers are not built in stage0.\n             copy_apple_sanitizer_dylibs(builder, &builder.native_dir(target), \"osx\", &libdir);\n         }\n-\n-        builder.cargo(target_compiler, Mode::ToolStd, target, \"clean\");\n     }\n }\n \n@@ -480,8 +478,6 @@ impl Step for TestLink {\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n             &libtest_stamp(builder, compiler, target)\n         );\n-\n-        builder.cargo(target_compiler, Mode::ToolTest, target, \"clean\");\n     }\n }\n \n@@ -639,7 +635,6 @@ impl Step for RustcLink {\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n             &librustc_stamp(builder, compiler, target)\n         );\n-        builder.cargo(target_compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n \n@@ -795,6 +790,9 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n             if builder.config.llvm_use_libcxx {\n                 cargo.env(\"LLVM_USE_LIBCXX\", \"1\");\n             }\n+            if builder.config.llvm_optimize && !builder.config.llvm_release_debuginfo {\n+                cargo.env(\"LLVM_NDEBUG\", \"1\");\n+            }\n         }\n         _ => panic!(\"unknown backend: {}\", backend),\n     }\n@@ -1116,10 +1114,6 @@ pub fn run_cargo(builder: &Builder<'_>,\n                 },\n                 ..\n             } => (filenames, crate_types),\n-            CargoMessage::CompilerMessage { message } => {\n-                eprintln!(\"{}\", message.rendered);\n-                return;\n-            }\n             _ => return,\n         };\n         for filename in filenames {\n@@ -1206,41 +1200,13 @@ pub fn run_cargo(builder: &Builder<'_>,\n         deps.push((path_to_add.into(), false));\n     }\n \n-    // Now we want to update the contents of the stamp file, if necessary. First\n-    // we read off the previous contents along with its mtime. If our new\n-    // contents (the list of files to copy) is different or if any dep's mtime\n-    // is newer then we rewrite the stamp file.\n     deps.sort();\n-    let stamp_contents = fs::read(stamp);\n-    let stamp_mtime = mtime(&stamp);\n     let mut new_contents = Vec::new();\n-    let mut max = None;\n-    let mut max_path = None;\n     for (dep, proc_macro) in deps.iter() {\n-        let mtime = mtime(dep);\n-        if Some(mtime) > max {\n-            max = Some(mtime);\n-            max_path = Some(dep.clone());\n-        }\n         new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }\n-    let max = max.unwrap();\n-    let max_path = max_path.unwrap();\n-    let contents_equal = stamp_contents\n-        .map(|contents| contents == new_contents)\n-        .unwrap_or_default();\n-    if contents_equal && max <= stamp_mtime {\n-        builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n-                stamp, max, stamp_mtime));\n-        return deps.into_iter().map(|(d, _)| d).collect()\n-    }\n-    if max > stamp_mtime {\n-        builder.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n-    } else {\n-        builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n-    }\n     t!(fs::write(&stamp, &new_contents));\n     deps.into_iter().map(|(d, _)| d).collect()\n }\n@@ -1256,8 +1222,12 @@ pub fn stream_cargo(\n     }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n-    cargo.arg(\"--message-format\").arg(\"json\")\n-         .stdout(Stdio::piped());\n+    let mut message_format = String::from(\"json-render-diagnostics\");\n+    if let Some(s) = &builder.config.rustc_error_format  {\n+        message_format.push_str(\",json-diagnostic-\");\n+        message_format.push_str(s);\n+    }\n+    cargo.arg(\"--message-format\").arg(message_format).stdout(Stdio::piped());\n \n     for arg in tail_args {\n         cargo.arg(arg);\n@@ -1310,12 +1280,4 @@ pub enum CargoMessage<'a> {\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,\n     },\n-    CompilerMessage {\n-        message: ClippyMessage<'a>\n-    }\n-}\n-\n-#[derive(Deserialize)]\n-pub struct ClippyMessage<'a> {\n-    rendered: Cow<'a, str>,\n }"}, {"sha": "e0a1f46078d32295977e3b6f7832de077d2d21c9", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -81,5 +81,14 @@ ci-subset-1:\n ci-subset-2:\n \t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2)\n \n+TESTS_IN_MINGW_2 := \\\n+\tsrc/test/ui \\\n+\tsrc/test/compile-fail\n+\n+ci-mingw-subset-1:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_MINGW_2:%=--exclude %)\n+ci-mingw-subset-2:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_MINGW_2)\n+\n \n .PHONY: dist"}, {"sha": "bffe748f37cc16270661c756ffa9b0099bb61be7", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -202,10 +202,6 @@ pub fn check(build: &mut Build) {\n                         panic!(\"couldn't find libc.a in musl dir: {}\",\n                                root.join(\"lib\").display());\n                     }\n-                    if fs::metadata(root.join(\"lib/libunwind.a\")).is_err() {\n-                        panic!(\"couldn't find libunwind.a in musl dir: {}\",\n-                               root.join(\"lib\").display());\n-                    }\n                 }\n                 None => {\n                     panic!(\"when targeting MUSL either the rust.musl-root \\"}, {"sha": "77c9cda58b8e6d8312ed9a9c7c8fdb4f9d92d344", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -272,8 +272,8 @@ jobs:\n       i686-mingw-1:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-        SCRIPT: make ci-subset-1\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        SCRIPT: make ci-mingw-subset-1\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n         # FIXME(#59637)\n@@ -282,25 +282,25 @@ jobs:\n       i686-mingw-2:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-        SCRIPT: make ci-subset-2\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        SCRIPT: make ci-mingw-subset-2\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n       x86_64-mingw-1:\n         MSYS_BITS: 64\n-        SCRIPT: make ci-subset-1\n+        SCRIPT: make ci-mingw-subset-1\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n       x86_64-mingw-2:\n         MSYS_BITS: 64\n-        SCRIPT: make ci-subset-2\n+        SCRIPT: make ci-mingw-subset-2\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n \n@@ -327,7 +327,7 @@ jobs:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n         SCRIPT: python x.py dist\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n         DIST_REQUIRE_ALL_TOOLS: 1\n@@ -336,7 +336,7 @@ jobs:\n         MSYS_BITS: 64\n         SCRIPT: python x.py dist\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n-        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n         DIST_REQUIRE_ALL_TOOLS: 1"}, {"sha": "14daf81b430755cda020c104ec9da8a8cc138f2c", "filename": "src/ci/azure-pipelines/steps/install-clang.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -36,7 +36,7 @@ steps:\n     set -e\n     mkdir -p citools\n     cd citools\n-    curl -f https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/LLVM-7.0.0-win64.tar.gz | tar xzf -\n+    curl -f https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/LLVM-7.0.0-win64.tar.gz | tar xzf -\n     echo \"##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]$RUST_CONFIGURE_ARGS --set llvm.clang-cl=`pwd`/clang-rust/bin/clang-cl.exe\"\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n   displayName: Install clang (Windows)"}, {"sha": "d4679c1c6733e50807df5f8c61dec675a15e031c", "filename": "src/ci/azure-pipelines/steps/install-sccache.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -2,14 +2,14 @@ steps:\n \n - bash: |\n     set -e\n-    curl -fo /usr/local/bin/sccache https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin\n+    curl -fo /usr/local/bin/sccache https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-02-sccache-x86_64-apple-darwin\n     chmod +x /usr/local/bin/sccache\n   displayName: Install sccache (OSX)\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n \n - script: |\n     md sccache\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n     echo ##vso[task.prependpath]%CD%\\sccache\n   displayName: Install sccache (Windows)\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))"}, {"sha": "9aaeb4b79d63410ff36f91d64185ca4f6c6e5c75", "filename": "src/ci/azure-pipelines/steps/install-windows-build-deps.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -4,7 +4,7 @@ steps:\n # https://github.com/wixtoolset/wix3 originally\n - bash: |\n     set -e\n-    curl -O https://rust-lang-ci2.s3-us-west-1.amazonaws.com/rust-ci-mirror/wix311-binaries.zip\n+    curl -O https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/wix311-binaries.zip\n     echo \"##vso[task.setvariable variable=WIX]`pwd`/wix\"\n     mkdir -p wix/bin\n     cd wix/bin\n@@ -18,7 +18,7 @@ steps:\n # one is MSI installers and one is EXE, but they're not used so frequently at\n # this point anyway so perhaps it's a wash!\n - script: |\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf is-install.exe https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-08-22-is.exe\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf is-install.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-08-22-is.exe\"\n     is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n     echo ##vso[task.prependpath]C:\\Program Files (x86)\\Inno Setup 5\n   displayName: Install InnoSetup\n@@ -109,7 +109,7 @@ steps:\n # Note that this is originally from the github releases patch of Ninja\n - script: |\n     md ninja\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-03-15-ninja-win.zip\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-03-15-ninja-win.zip\"\n     7z x -oninja 2017-03-15-ninja-win.zip\n     del 2017-03-15-ninja-win.zip\n     set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja"}, {"sha": "ac6b344a45e66a8b32433980992bb7b6de6943fa", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -199,7 +199,7 @@ steps:\n # Upload CPU usage statistics that we've been gathering this whole time. Always\n # execute this step in case we want to inspect failed builds, but don't let\n # errors here ever fail the build since this is just informational.\n-- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$SYSTEM_JOBNAME.csv\n+- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$CI_JOB_NAME.csv\n   env:\n     AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n   condition: variables['AWS_SECRET_ACCESS_KEY']"}, {"sha": "9493b33698708b08449d55d4b30ee3b54151c355", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -72,7 +72,7 @@ RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n \n # TODO: What is this?!\n # Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n-RUN curl -O https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/vexpress-v2p-ca15-tc1.dtb\n+RUN curl -O https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/vexpress-v2p-ca15-tc1.dtb\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "29cfb5d96083ef6eabbe39e400d2a939bc60590c", "filename": "src/ci/docker/dist-various-1/install-mips-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mips-linux-musl\n # originally from\n # https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/\n # OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\n-URL=\"https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\"\n+URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n FILE=\"OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mips-linux-musl --strip-components=2\n "}, {"sha": "f04ee78157167104e53c37390677ae6dfa0af131", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -5,7 +5,7 @@\n set -ex\n \n # Originally from https://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-curl https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n+curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n   tar xJf -\n export PATH=`pwd`/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n "}, {"sha": "be8a6c93945e96f7d8c7323b4a917df15e3c8910", "filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -4,7 +4,7 @@ set -ex\n source shared.sh\n \n VERSION=1.0.2k\n-URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/openssl-$VERSION.tar.gz\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/openssl-$VERSION.tar.gz\n \n curl $URL | tar xzf -\n "}, {"sha": "797f674b954f2e54c272cb6b4b2a9bb3f512cc25", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -25,7 +25,7 @@ cd netbsd\n \n mkdir -p /x-tools/x86_64-unknown-netbsd/sysroot\n \n-URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n \n # Originally from ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-$BSD/source/sets/*.tgz\n curl $URL/2018-03-01-netbsd-src.tgz | tar xzf -"}, {"sha": "c9e2961f6eb156ca8de88dd6ee51aff71bc8ff8f", "filename": "src/ci/docker/scripts/android-sdk-manager.py", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -23,8 +23,9 @@\n HOST_OS = \"linux\"\n \n # Mirroring options\n-MIRROR_BUCKET = \"rust-lang-ci2\"\n-MIRROR_BASE_DIR = \"rust-ci-mirror/android/\"\n+MIRROR_BUCKET = \"rust-lang-ci-mirrors\"\n+MIRROR_BUCKET_REGION = \"us-west-1\"\n+MIRROR_BASE_DIR = \"rustc/android/\"\n \n import argparse\n import hashlib\n@@ -144,7 +145,8 @@ def cli_install(args):\n     lockfile = Lockfile(args.lockfile)\n     for package in lockfile.packages.values():\n         # Download the file from the mirror into a temp file\n-        url = \"https://\" + MIRROR_BUCKET + \".s3.amazonaws.com/\" + MIRROR_BASE_DIR\n+        url = \"https://\" + MIRROR_BUCKET + \".s3-\" + MIRROR_BUCKET_REGION + \\\n+              \".amazonaws.com/\" + MIRROR_BASE_DIR\n         downloaded = package.download(url)\n         # Extract the file in a temporary directory\n         extract_dir = tempfile.mkdtemp()"}, {"sha": "70155e770a960281eb90668a7485b8a249889938", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -59,7 +59,7 @@ done\n \n # Originally downloaded from:\n # https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n-URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n curl \"$URL\" | tar xJf - -C \"$sysroot\" --wildcards \"${files_to_extract[@]}\"\n \n # Fix up absolute symlinks from the system image.  This can be removed"}, {"sha": "74ba2f0eadb25602f8718520f1fa08e0ed0e981f", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -54,29 +54,3 @@ if [ \"$REPLACE_CC\" = \"1\" ]; then\n         ln -s $TARGET-g++ /usr/local/bin/$exec\n     done\n fi\n-\n-export CC=$TARGET-gcc\n-export CXX=$TARGET-g++\n-\n-LLVM=70\n-\n-# may have been downloaded in a previous run\n-if [ ! -d libunwind-release_$LLVM ]; then\n-  curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n-  curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n-fi\n-\n-# fixme(mati865): Replace it with https://github.com/rust-lang/rust/pull/59089\n-mkdir libunwind-build\n-cd libunwind-build\n-cmake ../libunwind-release_$LLVM \\\n-          -DLLVM_PATH=/build/llvm-release_$LLVM \\\n-          -DLIBUNWIND_ENABLE_SHARED=0 \\\n-          -DCMAKE_C_COMPILER=$CC \\\n-          -DCMAKE_CXX_COMPILER=$CXX \\\n-          -DCMAKE_C_FLAGS=\"$CFLAGS\" \\\n-          -DCMAKE_CXX_FLAGS=\"$CXXFLAGS\"\n-\n-hide_output make -j$(nproc)\n-cp lib/libunwind.a $OUTPUT/$TARGET/lib\n-cd - && rm -rf libunwind-build"}, {"sha": "d847c407aba679135ca14c7b56cf50b0ca3ed0b3", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -20,6 +20,8 @@ exit 1\n TAG=$1\n shift\n \n+# Ancient binutils versions don't understand debug symbols produced by more recent tools.\n+# Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n MUSL=musl-1.1.22\n@@ -38,27 +40,3 @@ else\n fi\n hide_output make install\n hide_output make clean\n-\n-cd ..\n-\n-LLVM=70\n-\n-# may have been downloaded in a previous run\n-if [ ! -d libunwind-release_$LLVM ]; then\n-  curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n-  curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n-fi\n-\n-mkdir libunwind-build\n-cd libunwind-build\n-cmake ../libunwind-release_$LLVM \\\n-          -DLLVM_PATH=/build/llvm-release_$LLVM \\\n-          -DLIBUNWIND_ENABLE_SHARED=0 \\\n-          -DCMAKE_C_COMPILER=$CC \\\n-          -DCMAKE_CXX_COMPILER=$CXX \\\n-          -DCMAKE_C_FLAGS=\"$CFLAGS\" \\\n-          -DCMAKE_CXX_FLAGS=\"$CXXFLAGS\"\n-\n-hide_output make -j$(nproc)\n-cp lib/libunwind.a /musl-$TAG/lib\n-cd ../ && rm -rf libunwind-build"}, {"sha": "efeb0ed0d72d0f9461f17a4f701039e2f4dee1d7", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,6 +1,6 @@\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n+  https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "69c8d2e3099ab9bdf70e8dc8894495fe011b6d68", "filename": "src/ci/install-awscli.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finstall-awscli.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -16,7 +16,7 @@\n set -euo pipefail\n IFS=$'\\n\\t'\n \n-MIRROR=\"https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2019-07-27-awscli.tar\"\n+MIRROR=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2019-07-27-awscli.tar\"\n DEPS_DIR=\"/tmp/awscli-deps\"\n \n pip=\"pip\""}, {"sha": "457ba9717120710623411d44e7d8afdca1831882", "filename": "src/ci/run.sh", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -78,6 +78,21 @@ if [ \"$RUST_RELEASE_CHANNEL\" = \"nightly\" ] || [ \"$DIST_REQUIRE_ALL_TOOLS\" = \"\" ]\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-missing-tools\"\n fi\n \n+# Print the date from the local machine and the date from an external source to\n+# check for clock drifts. An HTTP URL is used instead of HTTPS since on Azure\n+# Pipelines it happened that the certificates were marked as expired.\n+datecheck() {\n+  echo \"== clock drift check ==\"\n+  echo -n \"  local time: \"\n+  date\n+  echo -n \"  network time: \"\n+  curl -fs --head http://detectportal.firefox.com/success.txt | grep ^Date: \\\n+      | sed 's/Date: //g' || true\n+  echo \"== end clock drift check ==\"\n+}\n+datecheck\n+trap datecheck EXIT\n+\n # We've had problems in the past of shell scripts leaking fds into the sccache\n # server (#48192) which causes Cargo to erroneously think that a build script\n # hasn't finished yet. Try to solve that problem by starting a very long-lived"}, {"sha": "3d04f30e7bde54bf2c8e832bcd4cedb40688fbb8", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1163,6 +1163,9 @@ impl<T> FusedIterator for Drain<'_, T> {}\n \n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n+    /// Converts a `Vec<T>` into a `BinaryHeap<T>`.\n+    ///\n+    /// This conversion happens in-place, and has `O(n)` time complexity.\n     fn from(vec: Vec<T>) -> BinaryHeap<T> {\n         let mut heap = BinaryHeap { data: vec };\n         heap.rebuild();"}, {"sha": "0b5a271dbea956ef032d21c2aed12802b957faf0", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -106,8 +106,8 @@ impl<K, V> LeafNode<K, V> {\n         LeafNode {\n             // As a general policy, we leave fields uninitialized if they can be, as this should\n             // be both slightly faster and easier to track in Valgrind.\n-            keys: uninit_array![_; CAPACITY],\n-            vals: uninit_array![_; CAPACITY],\n+            keys: [MaybeUninit::UNINIT; CAPACITY],\n+            vals: [MaybeUninit::UNINIT; CAPACITY],\n             parent: ptr::null(),\n             parent_idx: MaybeUninit::uninit(),\n             len: 0\n@@ -159,7 +159,7 @@ impl<K, V> InternalNode<K, V> {\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n-            edges: uninit_array![_; 2*B],\n+            edges: [MaybeUninit::UNINIT; 2*B]\n         }\n     }\n }"}, {"sha": "f1f22fe48c58ab0c4343a82dbd7ecfd26708c9c3", "filename": "src/liballoc/collections/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -41,32 +41,35 @@ pub use linked_list::LinkedList;\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;\n \n-use crate::alloc::{AllocErr, LayoutErr};\n+use crate::alloc::{Layout, LayoutErr};\n \n-/// Augments `AllocErr` with a CapacityOverflow variant.\n+/// The error type for `try_reserve` methods.\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub enum CollectionAllocErr {\n+pub enum TryReserveError {\n     /// Error due to the computed capacity exceeding the collection's maximum\n     /// (usually `isize::MAX` bytes).\n     CapacityOverflow,\n-    /// Error due to the allocator (see the `AllocErr` type's docs).\n-    AllocErr,\n-}\n \n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<AllocErr> for CollectionAllocErr {\n-    #[inline]\n-    fn from(AllocErr: AllocErr) -> Self {\n-        CollectionAllocErr::AllocErr\n-    }\n+    /// The memory allocator returned an error\n+    AllocError {\n+        /// The layout of allocation request that failed\n+        layout: Layout,\n+\n+        #[doc(hidden)]\n+        #[unstable(feature = \"container_error_extra\", issue = \"0\", reason = \"\\\n+            Enable exposing the allocator\u2019s custom error value \\\n+            if an associated type is added in the future: \\\n+            https://github.com/rust-lang/wg-allocators/issues/23\")]\n+        non_exhaustive: (),\n+    },\n }\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<LayoutErr> for CollectionAllocErr {\n+impl From<LayoutErr> for TryReserveError {\n     #[inline]\n     fn from(_: LayoutErr) -> Self {\n-        CollectionAllocErr::CapacityOverflow\n+        TryReserveError::CapacityOverflow\n     }\n }\n "}, {"sha": "2fc87413367adddc5b3cd212c4db4046c2825005", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -18,7 +18,7 @@ use core::ptr::{self, NonNull};\n use core::slice;\n use core::hash::{Hash, Hasher};\n \n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n@@ -576,10 +576,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     /// use std::collections::VecDeque;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     ///     let mut output = VecDeque::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -595,7 +595,7 @@ impl<T> VecDeque<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.try_reserve(additional)\n     }\n \n@@ -614,10 +614,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     /// use std::collections::VecDeque;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     ///     let mut output = VecDeque::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -633,12 +633,12 @@ impl<T> VecDeque<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n         let new_cap = used_cap.checked_add(additional)\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+            .ok_or(TryReserveError::CapacityOverflow)?;\n \n         if new_cap > old_cap {\n             self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;"}, {"sha": "4a48945adc37a4bf313a00fe38cd06fce4296d0f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -69,7 +69,7 @@\n #![warn(missing_debug_implementations)]\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n-#![cfg_attr(not(bootstrap), allow(incomplete_features))]\n+#![allow(incomplete_features)]\n \n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n@@ -84,9 +84,10 @@\n #![feature(coerce_unsized)]\n #![feature(const_generic_impls_guard)]\n #![feature(const_generics)]\n-#![cfg_attr(not(bootstrap), feature(const_in_array_repeat_expressions))]\n+#![feature(const_in_array_repeat_expressions)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n+#![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n@@ -118,7 +119,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit_extra, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n #![feature(mem_take)]"}, {"sha": "0b5e186d4c77b17c5ae683437df783fea53bd320", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -98,5 +98,5 @@ macro_rules! vec {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::fmt::format(::core::format_args!($($arg)*)))\n }"}, {"sha": "bc8a38f6b3aad530a9a0eb95d826f1696cd9d8e5", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -7,8 +7,8 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n-use crate::collections::CollectionAllocErr::{self, *};\n+use crate::alloc::{Alloc, Layout, Global, AllocErr, handle_alloc_error};\n+use crate::collections::TryReserveError::{self, *};\n use crate::boxed::Box;\n \n #[cfg(test)]\n@@ -385,7 +385,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n-           -> Result<(), CollectionAllocErr> {\n+           -> Result<(), TryReserveError> {\n \n         self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n     }\n@@ -413,7 +413,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n@@ -422,7 +422,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n     fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n-        -> Result<usize, CollectionAllocErr> {\n+        -> Result<usize, TryReserveError> {\n \n         // Nothing we can really do about these checks :(\n         let required_cap = used_capacity.checked_add(needed_extra_capacity)\n@@ -435,7 +435,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n-        -> Result<(), CollectionAllocErr> {\n+        -> Result<(), TryReserveError> {\n         self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n     }\n \n@@ -494,7 +494,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n         }\n     }\n@@ -640,10 +640,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n         needed_extra_capacity: usize,\n         fallibility: Fallibility,\n         strategy: ReserveStrategy,\n-    ) -> Result<(), CollectionAllocErr> {\n+    ) -> Result<(), TryReserveError> {\n         unsafe {\n-            use crate::alloc::AllocErr;\n-\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -672,12 +670,16 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => self.a.alloc(new_layout),\n             };\n \n-            match (&res, fallibility) {\n+            let ptr = match (res, fallibility) {\n                 (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n-                _ => {}\n-            }\n+                (Err(AllocErr), Fallible) => return Err(TryReserveError::AllocError {\n+                    layout: new_layout,\n+                    non_exhaustive: (),\n+                }),\n+                (Ok(ptr), _) => ptr,\n+            };\n \n-            self.ptr = res?.cast().into();\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n \n             Ok(())\n@@ -737,7 +739,7 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // all 4GB in user-space. e.g., PAE or x32\n \n #[inline]\n-fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n+fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n     if mem::size_of::<usize>() < 8 && alloc_size > core::isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {"}, {"sha": "b65f191836e9dcc9548bac74f9894520f5df463a", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -56,7 +56,7 @@ use core::ptr;\n use core::str::{pattern::Pattern, lossy};\n \n use crate::borrow::{Cow, ToOwned};\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::boxed::Box;\n use crate::str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use crate::vec::Vec;\n@@ -937,9 +937,9 @@ impl String {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n     ///     let mut output = String::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -953,7 +953,7 @@ impl String {\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.vec.try_reserve(additional)\n     }\n \n@@ -975,9 +975,9 @@ impl String {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n     ///     let mut output = String::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -991,7 +991,7 @@ impl String {\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.vec.try_reserve_exact(additional)\n     }\n "}, {"sha": "55edf56345b59a4cb270129610b0318a9f2163dd", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,5 +1,5 @@\n use std::borrow::Cow;\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n@@ -566,11 +566,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -590,7 +590,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -629,10 +629,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -651,7 +651,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {"}, {"sha": "29a22aa0315b048199497108d04b2bb1eac04e46", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -2,7 +2,7 @@ use std::borrow::Cow;\n use std::mem::size_of;\n use std::{usize, isize};\n use std::vec::{Drain, IntoIter};\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -1121,11 +1121,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1145,7 +1145,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1168,7 +1168,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1209,10 +1209,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1231,7 +1231,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1252,7 +1252,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "d49b553fc0217a5161e9493220d25003b2221856", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,6 +1,6 @@\n use std::fmt::Debug;\n use std::collections::{VecDeque, vec_deque::Drain};\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n@@ -1168,7 +1168,7 @@ fn test_try_reserve() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1188,7 +1188,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1211,7 +1211,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1256,7 +1256,7 @@ fn test_try_reserve_exact() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1275,7 +1275,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1296,7 +1296,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "d2798955c46a97105cec55fa5e5f3b4de2def63b", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -70,7 +70,7 @@ use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n use crate::borrow::{ToOwned, Cow};\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::boxed::Box;\n use crate::raw_vec::RawVec;\n \n@@ -498,9 +498,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -516,7 +516,7 @@ impl<T> Vec<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.buf.try_reserve(self.len, additional)\n     }\n \n@@ -538,9 +538,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -556,7 +556,7 @@ impl<T> Vec<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.buf.try_reserve_exact(self.len, additional)\n     }\n "}, {"sha": "e8a0a88f12a7e30604ff92702c2d9f0476ad9985", "filename": "src/libcore/any.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -470,10 +470,5 @@ impl TypeId {\n #[stable(feature = \"type_name\", since = \"1.38.0\")]\n #[rustc_const_unstable(feature = \"const_type_name\")]\n pub const fn type_name<T: ?Sized>() -> &'static str {\n-    #[cfg(bootstrap)]\n-    unsafe {\n-        intrinsics::type_name::<T>()\n-    }\n-    #[cfg(not(bootstrap))]\n     intrinsics::type_name::<T>()\n }"}, {"sha": "4087333e2cf6dc39f530508663edf84af1b8d75a", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -14,6 +14,7 @@\n use crate::fmt;\n use crate::ops::Range;\n use crate::iter::FusedIterator;\n+use crate::str::from_utf8_unchecked;\n \n /// An iterator over the escaped version of a byte.\n ///\n@@ -22,6 +23,7 @@ use crate::iter::FusedIterator;\n ///\n /// [`escape_default`]: fn.escape_default.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n pub struct EscapeDefault {\n     range: Range<usize>,\n     data: [u8; 4],\n@@ -130,6 +132,13 @@ impl ExactSizeIterator for EscapeDefault {}\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDefault {}\n \n+#[stable(feature = \"ascii_escape_display\", since = \"1.39.0\")]\n+impl fmt::Display for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(unsafe { from_utf8_unchecked(&self.data[self.range.clone()]) })\n+    }\n+}\n+\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for EscapeDefault {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "e91bf53c5b418c40a2237350581b3db16966477b", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -553,12 +553,7 @@ impl char {\n     /// `XID_Start` is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to `ID_Start` but modified for closure under `NFKx`.\n-    #[cfg_attr(bootstrap,\n-               unstable(feature = \"rustc_private\",\n-                        reason = \"mainly needed for compiler internals\",\n-                        issue = \"27812\"))]\n-    #[cfg_attr(not(bootstrap),\n-               unstable(feature = \"unicode_internals\", issue = \"0\"))]\n+    #[unstable(feature = \"unicode_internals\", issue = \"0\")]\n     pub fn is_xid_start(self) -> bool {\n         derived_property::XID_Start(self)\n     }\n@@ -569,12 +564,7 @@ impl char {\n     /// `XID_Continue` is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to `ID_Continue` but modified for closure under NFKx.\n-    #[cfg_attr(bootstrap,\n-               unstable(feature = \"rustc_private\",\n-                        reason = \"mainly needed for compiler internals\",\n-                        issue = \"27812\"))]\n-    #[cfg_attr(not(bootstrap),\n-               unstable(feature = \"unicode_internals\", issue = \"0\"))]\n+    #[unstable(feature = \"unicode_internals\", issue = \"0\")]\n     #[inline]\n     pub fn is_xid_continue(self) -> bool {\n         derived_property::XID_Continue(self)"}, {"sha": "ec70d396e966d586fcdb1ff2893de24943f85353", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -134,9 +134,8 @@ pub trait Clone : Sized {\n }\n \n /// Derive macro generating an impl of the trait `Clone`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n pub macro Clone($item:item) { /* compiler built-in */ }"}, {"sha": "cb9feb074dd70d58d51c1b95da226ce662ea16eb", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -201,9 +201,8 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n }\n \n /// Derive macro generating an impl of the trait `PartialEq`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro PartialEq($item:item) { /* compiler built-in */ }\n@@ -265,9 +264,8 @@ pub trait Eq: PartialEq<Self> {\n }\n \n /// Derive macro generating an impl of the trait `Eq`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_eq)]\n pub macro Eq($item:item) { /* compiler built-in */ }\n@@ -617,9 +615,8 @@ pub trait Ord: Eq + PartialOrd<Self> {\n }\n \n /// Derive macro generating an impl of the trait `Ord`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro Ord($item:item) { /* compiler built-in */ }\n@@ -867,9 +864,8 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n }\n \n /// Derive macro generating an impl of the trait `PartialOrd`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro PartialOrd($item:item) { /* compiler built-in */ }"}, {"sha": "66acc5165fc5b9ad9b2fa3714225a664da3c71cd", "filename": "src/libcore/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -116,9 +116,8 @@ pub trait Default: Sized {\n }\n \n /// Derive macro generating an impl of the trait `Default`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro Default($item:item) { /* compiler built-in */ }"}, {"sha": "15ce2277fa00d9188aad74dc7043f72faa149a3e", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -98,7 +98,7 @@ pub struct DebugStruct<'a, 'b: 'a> {\n     has_fields: bool,\n }\n \n-pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n+pub(super) fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n                                 name: &str)\n                                 -> DebugStruct<'a, 'b> {\n     let result = fmt.write_str(name);\n@@ -251,7 +251,10 @@ pub struct DebugTuple<'a, 'b: 'a> {\n     empty_name: bool,\n }\n \n-pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> {\n+pub(super) fn debug_tuple_new<'a, 'b>(\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    name: &str,\n+) -> DebugTuple<'a, 'b> {\n     let result = fmt.write_str(name);\n     DebugTuple {\n         fmt,\n@@ -418,7 +421,7 @@ pub struct DebugSet<'a, 'b: 'a> {\n     inner: DebugInner<'a, 'b>,\n }\n \n-pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> {\n+pub(super) fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> {\n     let result = fmt.write_str(\"{\");\n     DebugSet {\n         inner: DebugInner {\n@@ -555,7 +558,7 @@ pub struct DebugList<'a, 'b: 'a> {\n     inner: DebugInner<'a, 'b>,\n }\n \n-pub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> {\n+pub(super) fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> {\n     let result = fmt.write_str(\"[\");\n     DebugList {\n         inner: DebugInner {\n@@ -697,7 +700,7 @@ pub struct DebugMap<'a, 'b: 'a> {\n     state: PadAdapterState,\n }\n \n-pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n+pub(super) fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n     let result = fmt.write_str(\"{\");\n     DebugMap {\n         fmt,"}, {"sha": "bd31d25dd034b2063c33b665e9e3d63e50e159cd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -546,16 +546,14 @@ pub trait Debug {\n }\n \n // Separate module to reexport the macro `Debug` from prelude without the trait `Debug`.\n-#[cfg(not(bootstrap))]\n pub(crate) mod macros {\n     /// Derive macro generating an impl of the trait `Debug`.\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro Debug($item:item) { /* compiler built-in */ }\n }\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n pub use macros::Debug;"}, {"sha": "bf3daa32840d85cb598ee4e0d1ec6ad34be98e1a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -199,16 +199,14 @@ pub trait Hash {\n }\n \n // Separate module to reexport the macro `Hash` from prelude without the trait `Hash`.\n-#[cfg(not(bootstrap))]\n pub(crate) mod macros {\n     /// Derive macro generating an impl of the trait `Hash`.\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro Hash($item:item) { /* compiler built-in */ }\n }\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n pub use macros::Hash;\n@@ -553,8 +551,6 @@ impl<H> PartialEq for BuildHasherDefault<H> {\n #[stable(since = \"1.29.0\", feature = \"build_hasher_eq\")]\n impl<H> Eq for BuildHasherDefault<H> {}\n \n-//////////////////////////////////////////////////////////////////////////////\n-\n mod impls {\n     use crate::mem;\n     use crate::slice;"}, {"sha": "d145f2212f93a639e2c4ab50dff24b5b6b64ef57", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1293,18 +1293,40 @@ extern \"rust-intrinsic\" {\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_add<T>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n+    #[cfg(boostrap_stdarch_ignore_this)]\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n \n+    /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_add` method. For example,\n+    /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_add<T>(a: T, b: T) -> T;\n+    /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_sub` method. For example,\n+    /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_sub<T>(a: T, b: T) -> T;\n+    /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n+    /// The stabilized versions of this intrinsic are available on the integer\n+    /// primitives via the `wrapping_mul` method. For example,\n+    /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n+    #[cfg(not(boostrap_stdarch_ignore_this))]\n+    pub fn wrapping_mul<T>(a: T, b: T) -> T;\n+\n     /// Computes `a + b`, while saturating at numeric bounds.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,"}, {"sha": "0b9f7f6b609e7cee770fca3167c5417fc9816613", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -207,6 +207,29 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n         }\n     }\n \n+    #[inline]\n+    fn nth_back(&mut self, mut n: usize) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                for x in self.b.by_ref().rev() {\n+                    if n == 0 {\n+                        return Some(x)\n+                    }\n+                    n -= 1;\n+                }\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Front;\n+                }\n+            }\n+            ChainState::Front => {}\n+        }\n+        if let ChainState::Front = self.state {\n+            self.a.nth_back(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n         Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {"}, {"sha": "a45173f614ded742bec4edbb59566bc065f6d569", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -72,8 +72,7 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n where\n     F: FnMut(I::Item) -> U,\n-    U: IntoIterator,\n-    U::IntoIter: DoubleEndedIterator,\n+    U: IntoIterator<IntoIter: DoubleEndedIterator>,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n@@ -107,10 +106,7 @@ impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n /// [`Iterator`]: trait.Iterator.html\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-pub struct Flatten<I: Iterator>\n-where\n-    I::Item: IntoIterator,\n-{\n+pub struct Flatten<I: Iterator<Item: IntoIterator>> {\n     inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n }\n \n@@ -229,16 +225,16 @@ where\n                 if let elt@Some(_) = inner.next() { return elt }\n             }\n             match self.iter.next() {\n-                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                None => return self.backiter.as_mut()?.next(),\n                 Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), U::size_hint);\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), U::size_hint);\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n             ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n@@ -250,20 +246,25 @@ where\n     fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n+        #[inline]\n+        fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n+            frontiter: &'a mut Option<T::IntoIter>,\n+            fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_fold(acc, &mut *fold);\n+                *frontiter = Some(mid);\n+                r\n+            }\n+        }\n+\n         if let Some(ref mut front) = self.frontiter {\n             init = front.try_fold(init, &mut fold)?;\n         }\n         self.frontiter = None;\n \n-        {\n-            let frontiter = &mut self.frontiter;\n-            init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_fold(acc, &mut fold);\n-                *frontiter = Some(mid);\n-                r\n-            })?;\n-        }\n+        init = self.iter.try_fold(init, flatten(&mut self.frontiter, &mut fold))?;\n         self.frontiter = None;\n \n         if let Some(ref mut back) = self.backiter {\n@@ -275,13 +276,20 @@ where\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        #[inline]\n+        fn flatten<U: Iterator, Acc>(\n+            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n+        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n+            move |acc, iter| iter.fold(acc, &mut *fold)\n+        }\n+\n         self.frontiter.into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n-            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n+            .fold(init, flatten(fold))\n     }\n }\n \n@@ -297,7 +305,7 @@ where\n                 if let elt@Some(_) = inner.next_back() { return elt }\n             }\n             match self.iter.next_back() {\n-                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                None => return self.frontiter.as_mut()?.next_back(),\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }\n         }\n@@ -307,22 +315,29 @@ where\n     fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_rfold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n+        #[inline]\n+        fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n+            backiter: &'a mut Option<T::IntoIter>,\n+            fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n+        ) -> impl FnMut(Acc, T) -> R + 'a where\n+            T::IntoIter: DoubleEndedIterator,\n         {\n-            let backiter = &mut self.backiter;\n-            init = self.iter.try_rfold(init, |acc, x| {\n+            move |acc, x| {\n                 let mut mid = x.into_iter();\n-                let r = mid.try_rfold(acc, &mut fold);\n+                let r = mid.try_rfold(acc, &mut *fold);\n                 *backiter = Some(mid);\n                 r\n-            })?;\n+            }\n+        }\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n         }\n         self.backiter = None;\n \n+        init = self.iter.try_rfold(init, flatten(&mut self.backiter, &mut fold))?;\n+        self.backiter = None;\n+\n         if let Some(ref mut front) = self.frontiter {\n             init = front.try_rfold(init, &mut fold)?;\n         }\n@@ -332,12 +347,19 @@ where\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        #[inline]\n+        fn flatten<U: DoubleEndedIterator, Acc>(\n+            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n+        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n+            move |acc, iter| iter.rfold(acc, &mut *fold)\n+        }\n+\n         self.frontiter.into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n-            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+            .rfold(init, flatten(fold))\n     }\n }"}, {"sha": "a63434abd6c9fc172532d5a27f92c3f0cba96c30", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 361, "deletions": 205, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,6 +1,6 @@\n use crate::cmp;\n use crate::fmt;\n-use crate::ops::Try;\n+use crate::ops::{Add, AddAssign, Try};\n use crate::usize;\n use crate::intrinsics;\n \n@@ -143,6 +143,18 @@ impl<I> Copied<I> {\n     }\n }\n \n+fn copy_fold<T: Copy, Acc>(\n+    mut f: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, &T) -> Acc {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+fn copy_try_fold<T: Copy, Acc, R>(\n+    mut f: impl FnMut(Acc, T) -> R,\n+) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n impl<'a, I, T: 'a> Iterator for Copied<I>\n     where I: Iterator<Item=&'a T>, T: Copy\n@@ -157,16 +169,16 @@ impl<'a, I, T: 'a> Iterator for Copied<I>\n         self.it.size_hint()\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n+        self.it.try_fold(init, copy_try_fold(f))\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.fold(init, move |acc, &elt| f(acc, elt))\n+        self.it.fold(init, copy_fold(f))\n     }\n }\n \n@@ -178,16 +190,16 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n         self.it.next_back().copied()\n     }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_rfold(init, move |acc, &elt| f(acc, elt))\n+        self.it.try_rfold(init, copy_try_fold(f))\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.rfold(init, move |acc, &elt| f(acc, elt))\n+        self.it.rfold(init, copy_fold(f))\n     }\n }\n \n@@ -248,6 +260,12 @@ impl<I> Cloned<I> {\n     }\n }\n \n+fn clone_try_fold<T: Clone, Acc, R>(\n+    mut f: impl FnMut(Acc, T) -> R,\n+) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, elt| f(acc, elt.clone())\n+}\n+\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> Iterator for Cloned<I>\n     where I: Iterator<Item=&'a T>, T: Clone\n@@ -262,16 +280,16 @@ impl<'a, I, T: 'a> Iterator for Cloned<I>\n         self.it.size_hint()\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.try_fold(init, clone_try_fold(f))\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.map(T::clone).fold(init, f)\n     }\n }\n \n@@ -283,16 +301,16 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n         self.it.next_back().cloned()\n     }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.try_rfold(init, clone_try_fold(f))\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.map(T::clone).rfold(init, f)\n     }\n }\n \n@@ -387,6 +405,36 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n             _ => (usize::MAX, None)\n         }\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        // fully iterate the current iterator. this is necessary because\n+        // `self.iter` may be empty even when `self.orig` isn't\n+        acc = self.iter.try_fold(acc, &mut f)?;\n+        self.iter = self.orig.clone();\n+\n+        // complete a full cycle, keeping track of whether the cycled\n+        // iterator is empty or not. we need to return early in case\n+        // of an empty iterator to prevent an infinite loop\n+        let mut is_empty = true;\n+        acc = self.iter.try_fold(acc, |acc, x| {\n+            is_empty = false;\n+            f(acc, x)\n+        })?;\n+\n+        if is_empty {\n+            return Try::from_ok(acc);\n+        }\n+\n+        loop {\n+            self.iter = self.orig.clone();\n+            acc = self.iter.try_fold(acc, &mut f)?;\n+        }\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -430,14 +478,24 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let inner_hint = self.iter.size_hint();\n+        #[inline]\n+        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n+        }\n+\n+        #[inline]\n+        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| n / (step + 1)\n+        }\n+\n+        let (low, high) = self.iter.size_hint();\n \n         if self.first_take {\n-            let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) };\n-            (f(inner_hint.0), inner_hint.1.map(f))\n+            let f = first_size(self.step);\n+            (f(low), high.map(f))\n         } else {\n-            let f = |n| n / (self.step+1);\n-            (f(inner_hint.0), inner_hint.1.map(f))\n+            let f = other_size(self.step);\n+            (f(low), high.map(f))\n         }\n     }\n \n@@ -594,6 +652,20 @@ impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n     }\n }\n \n+fn map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+fn map_try_fold<'a, T, B, Acc, R>(\n+    f: &'a mut impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n     type Item = B;\n@@ -608,18 +680,16 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n         self.iter.size_hint()\n     }\n \n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R where\n         Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n     }\n \n-    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.fold(init, map_fold(self.f, g))\n     }\n }\n \n@@ -632,18 +702,16 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n         self.iter.next_back().map(&mut self.f)\n     }\n \n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R where\n         Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n     }\n \n-    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.rfold(init, map_fold(self.f, g))\n     }\n }\n \n@@ -710,13 +778,27 @@ impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n     }\n }\n \n+fn filter_fold<T, Acc>(\n+    mut predicate: impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}\n+\n+fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n+    predicate: &'a mut impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { R::from_ok(acc) }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n     type Item = I::Item;\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        self.try_for_each(Err).err()\n+        self.iter.find(&mut self.predicate)\n     }\n \n     #[inline]\n@@ -738,32 +820,26 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n     // leaving more budget for LLVM optimizations.\n     #[inline]\n     fn count(self) -> usize {\n-        let mut predicate = self.predicate;\n-        self.iter.map(|x| predicate(&x) as usize).sum()\n+        #[inline]\n+        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n+            move |x| predicate(&x) as usize\n+        }\n+\n+        self.iter.map(to_usize(self.predicate)).sum()\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n+        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut predicate = self.predicate;\n-        self.iter.fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n+        self.iter.fold(init, filter_fold(self.predicate, fold))\n     }\n }\n \n@@ -773,31 +849,21 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<I::Item> {\n-        self.try_rfold((), |_, x| Err(x)).err()\n+        self.iter.rfind(&mut self.predicate)\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n+        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut predicate = self.predicate;\n-        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n+        self.iter.rfold(init, filter_fold(self.predicate, fold))\n     }\n }\n \n@@ -834,6 +900,26 @@ impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n     }\n }\n \n+fn filter_map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => acc,\n+    }\n+}\n+\n+fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n+    f: &'a mut impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => R::from_ok(acc),\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     where F: FnMut(I::Item) -> Option<B>,\n@@ -842,7 +928,7 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.try_for_each(Err).err()\n+        self.iter.find_map(&mut self.f)\n     }\n \n     #[inline]\n@@ -852,25 +938,17 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n+        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n+        self.iter.fold(init, filter_map_fold(self.f, fold))\n     }\n }\n \n@@ -880,29 +958,31 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n-        self.try_rfold((), |_, x| Err(x)).err()\n+        #[inline]\n+        fn find<T, B>(\n+            f: &mut impl FnMut(T) -> Option<B>\n+        ) -> impl FnMut((), T) -> LoopState<(), B> + '_ {\n+            move |(), x| match f(x) {\n+                Some(x) => LoopState::Break(x),\n+                None => LoopState::Continue(()),\n+            }\n+        }\n+\n+        self.iter.try_rfold((), find(&mut self.f)).break_value()\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n+        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n+        self.iter.rfold(init, filter_map_fold(self.f, fold))\n     }\n }\n \n@@ -944,14 +1024,12 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     ///\n     /// Might panic if the index of the element overflows a `usize`.\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next().map(|a| {\n-            let ret = (self.count, a);\n-            // Possible undefined overflow.\n-            self.count += 1;\n-            ret\n-        })\n+        let a = self.iter.next()?;\n+        let i = self.count;\n+        // Possible undefined overflow.\n+        AddAssign::add_assign(&mut self.count, 1);\n+        Some((i, a))\n     }\n \n     #[inline]\n@@ -960,13 +1038,12 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n-        self.iter.nth(n).map(|a| {\n-            let i = self.count + n;\n-            self.count = i + 1;\n-            (i, a)\n-        })\n+        let a = self.iter.nth(n)?;\n+        // Possible undefined overflow.\n+        let i = Add::add(self.count, n);\n+        self.count = Add::add(i, 1);\n+        Some((i, a))\n     }\n \n     #[inline]\n@@ -975,29 +1052,43 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let count = &mut self.count;\n-        self.iter.try_fold(init, move |acc, item| {\n-            let acc = fold(acc, (*count, item));\n-            *count += 1;\n-            acc\n-        })\n+        #[inline]\n+        fn enumerate<'a, T, Acc, R>(\n+            count: &'a mut usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, item| {\n+                let acc = fold(acc, (*count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut count = self.count;\n-        self.iter.fold(init, move |acc, item| {\n-            let acc = fold(acc, (count, item));\n-            count += 1;\n-            acc\n-        })\n+        #[inline]\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                let acc = fold(acc, (count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(&mut count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.fold(init, enumerate(self.count, fold))\n     }\n }\n \n@@ -1007,48 +1098,60 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next_back().map(|a| {\n-            let len = self.iter.len();\n-            // Can safely add, `ExactSizeIterator` promises that the number of\n-            // elements fits into a `usize`.\n-            (self.count + len, a)\n-        })\n+        let a = self.iter.next_back()?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.nth_back(n).map(|a| {\n-            let len = self.iter.len();\n-            // Can safely add, `ExactSizeIterator` promises that the number of\n-            // elements fits into a `usize`.\n-            (self.count + len, a)\n-        })\n+        let a = self.iter.nth_back(n)?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n         // Can safely add and subtract the count, as `ExactSizeIterator` promises\n         // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.try_rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n+        fn enumerate<T, Acc, R>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n+        ) -> impl FnMut(Acc, T) -> R {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, enumerate(count, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         // Can safely add and subtract the count, as `ExactSizeIterator` promises\n         // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.rfold(init, enumerate(count, fold))\n     }\n }\n \n@@ -1162,7 +1265,10 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         };\n         let (lo, hi) = self.iter.size_hint();\n         let lo = lo.saturating_add(peek_len);\n-        let hi = hi.and_then(|x| x.checked_add(peek_len));\n+        let hi = match hi {\n+            Some(x) => x.checked_add(peek_len),\n+            None => None,\n+        };\n         (lo, hi)\n     }\n \n@@ -1321,16 +1427,23 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n+        fn check<'a, T>(\n+            flag: &'a mut bool,\n+            pred: &'a mut impl FnMut(&T) -> bool,\n+        ) -> impl FnMut(&T) -> bool + 'a {\n+            move |x| {\n+                if *flag || !pred(x) {\n+                    *flag = true;\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+\n         let flag = &mut self.flag;\n         let pred = &mut self.predicate;\n-        self.iter.find(move |x| {\n-            if *flag || !pred(x) {\n-                *flag = true;\n-                true\n-            } else {\n-                false\n-            }\n-        })\n+        self.iter.find(check(flag, pred))\n     }\n \n     #[inline]\n@@ -1412,14 +1525,13 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n         if self.flag {\n             None\n         } else {\n-            self.iter.next().and_then(|x| {\n-                if (self.predicate)(&x) {\n-                    Some(x)\n-                } else {\n-                    self.flag = true;\n-                    None\n-                }\n-            })\n+            let x = self.iter.next()?;\n+            if (self.predicate)(&x) {\n+                Some(x)\n+            } else {\n+                self.flag = true;\n+                None\n+            }\n         }\n     }\n \n@@ -1434,22 +1546,30 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if self.flag {\n-            Try::from_ok(init)\n-        } else {\n-            let flag = &mut self.flag;\n-            let p = &mut self.predicate;\n-            self.iter.try_fold(init, move |acc, x|{\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(&T) -> bool,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n                 if p(&x) {\n                     LoopState::from_try(fold(acc, x))\n                 } else {\n                     *flag = true;\n                     LoopState::Break(Try::from_ok(acc))\n                 }\n-            }).into_try()\n+            }\n+        }\n+\n+        if self.flag {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n         }\n     }\n }\n@@ -1534,7 +1654,10 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = lower.saturating_sub(self.n);\n-        let upper = upper.map(|x| x.saturating_sub(self.n));\n+        let upper = match upper {\n+            Some(x) => Some(x.saturating_sub(self.n)),\n+            None => None,\n+        };\n \n         (lower, upper)\n     }\n@@ -1595,19 +1718,26 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n         }\n     }\n \n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let mut n = self.len();\n-        if n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            self.iter.try_rfold(init, move |acc, x| {\n+        fn check<T, Acc, R: Try<Ok = Acc>>(\n+            mut n: usize,\n+            mut fold: impl FnMut(Acc, T) -> R,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> {\n+            move |acc, x| {\n                 n -= 1;\n                 let r = fold(acc, x);\n                 if n == 0 { LoopState::Break(r) }\n                 else { LoopState::from_try(r) }\n-            }).into_try()\n+            }\n+        }\n+\n+        let n = self.len();\n+        if n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            self.iter.try_rfold(init, check(n, fold)).into_try()\n         }\n     }\n }\n@@ -1682,19 +1812,26 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if self.n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            let n = &mut self.n;\n-            self.iter.try_fold(init, move |acc, x| {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            n: &'a mut usize,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n                 *n -= 1;\n                 let r = fold(acc, x);\n                 if *n == 0 { LoopState::Break(r) }\n                 else { LoopState::from_try(r) }\n-            }).into_try()\n+            }\n+        }\n+\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, check(n, fold)).into_try()\n         }\n     }\n }\n@@ -1793,7 +1930,8 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n+        let a = self.iter.next()?;\n+        (self.f)(&mut self.state, a)\n     }\n \n     #[inline]\n@@ -1803,17 +1941,25 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n+        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n+            state: &'a mut St,\n+            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n+                match f(state, x) {\n+                    None => LoopState::Break(Try::from_ok(acc)),\n+                    Some(x) => LoopState::from_try(fold(acc, x)),\n+                }\n+            }\n+        }\n+\n         let state = &mut self.state;\n         let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, x| {\n-            match f(state, x) {\n-                None => LoopState::Break(Try::from_ok(acc)),\n-                Some(x) => LoopState::from_try(fold(acc, x)),\n-            }\n-        }).into_try()\n+        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n     }\n }\n \n@@ -2104,6 +2250,20 @@ impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n     }\n }\n \n+fn inspect_fold<T, Acc>(\n+    mut f: impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| { f(&item); fold(acc, item) }\n+}\n+\n+fn inspect_try_fold<'a, T, Acc, R>(\n+    f: &'a mut impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| { f(&item); fold(acc, item) }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     type Item = I::Item;\n@@ -2120,19 +2280,17 @@ impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.fold(init, inspect_fold(self.f, fold))\n     }\n }\n \n@@ -2147,19 +2305,17 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.rfold(init, inspect_fold(self.f, fold))\n     }\n }\n "}, {"sha": "430ceacdd9fab674aad4b958263f1326c2c0b099", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -94,11 +94,9 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n \n     #[inline]\n     default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        self.a.next().and_then(|x| {\n-            self.b.next().and_then(|y| {\n-                Some((x, y))\n-            })\n-        })\n+        let x = self.a.next()?;\n+        let y = self.b.next()?;\n+        Some((x, y))\n     }\n \n     #[inline]"}, {"sha": "183176005ede9605ba289c018d6adbe18f6d69c5", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -394,7 +394,8 @@ impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        self.gen.take().map(|f| f())\n+        let f = self.gen.take()?;\n+        Some(f())\n     }\n \n     #[inline]\n@@ -608,10 +609,9 @@ impl<T, F> Iterator for Successors<T, F>\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        self.next.take().map(|item| {\n-            self.next = (self.succ)(&item);\n-            item\n-        })\n+        let item = self.next.take()?;\n+        self.next = (self.succ)(&item);\n+        Some(item)\n     }\n \n     #[inline]"}, {"sha": "818f03303298f7b250d50486ca144b629f0a9954", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -85,28 +85,28 @@ macro_rules! float_sum_product {\n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Sum for $a {\n             fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + b)\n+                iter.fold(0.0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Product for $a {\n             fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * b)\n+                iter.fold(1.0, Mul::mul)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Sum<&'a $a> for $a {\n             fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + *b)\n+                iter.fold(0.0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Product<&'a $a> for $a {\n             fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * *b)\n+                iter.fold(1.0, Mul::mul)\n             }\n         }\n     )*)"}, {"sha": "006b243ca42aa8c328060987edbf9c90013c2ff4", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -69,7 +69,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Returns the `n`th element from the end of the iterator.\n     ///\n     /// This is essentially the reversed version of [`nth`]. Although like most indexing\n-    /// operations, the count starts from zero, so `nth_back(0)` returns the first value fro\n+    /// operations, the count starts from zero, so `nth_back(0)` returns the first value from\n     /// the end, `nth_back(1)` the second, and so on.\n     ///\n     /// Note that all elements between the end and the returned element will be\n@@ -219,12 +219,17 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n+    fn rfold<B, F>(mut self, accum: B, f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(accum, ok(f)).unwrap()\n     }\n \n     /// Searches for an element of an iterator from the back that satisfies a predicate.\n@@ -271,15 +276,21 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n-    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n-        self.try_rfold((), move |(), x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(&T) -> bool,\n+        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+            move |(), x| {\n+                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_rfold((), check(predicate)).break_value()\n     }\n }\n "}, {"sha": "d644787d2c462678e9af0b4ad494d34dc170730c", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 177, "deletions": 72, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,5 +1,5 @@\n use crate::cmp::Ordering;\n-use crate::ops::Try;\n+use crate::ops::{Add, Try};\n \n use super::super::LoopState;\n use super::super::{Chain, Cycle, Copied, Cloned, Enumerate, Filter, FilterMap, Fuse};\n@@ -234,11 +234,15 @@ pub trait Iterator {\n     /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> usize where Self: Sized {\n-        // Might overflow.\n-        self.fold(0, |cnt, _| cnt + 1)\n+        #[inline]\n+        fn add1<T>(count: usize, _: T) -> usize {\n+            // Might overflow.\n+            Add::add(count, 1)\n+        }\n+\n+        self.fold(0, add1)\n     }\n \n     /// Consumes the iterator, returning the last element.\n@@ -263,7 +267,12 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(self) -> Option<Self::Item> where Self: Sized {\n-        self.fold(None, |_, x| Some(x))\n+        #[inline]\n+        fn some<T>(_: Option<T>, x: T) -> Option<T> {\n+            Some(x)\n+        }\n+\n+        self.fold(None, some)\n     }\n \n     /// Returns the `n`th element of the iterator.\n@@ -596,10 +605,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_for_each\", since = \"1.21.0\")]\n-    fn for_each<F>(self, mut f: F) where\n+    fn for_each<F>(self, f: F) where\n         Self: Sized, F: FnMut(Self::Item),\n     {\n-        self.fold((), move |(), item| f(item));\n+        #[inline]\n+        fn call<T>(mut f: impl FnMut(T)) -> impl FnMut((), T) {\n+            move |(), item| f(item)\n+        }\n+\n+        self.fold((), call(f));\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element\n@@ -1490,21 +1504,30 @@ pub trait Iterator {\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn partition<B, F>(self, mut f: F) -> (B, B) where\n+    fn partition<B, F>(self, f: F) -> (B, B) where\n         Self: Sized,\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n     {\n+        #[inline]\n+        fn extend<'a, T, B: Extend<T>>(\n+            mut f: impl FnMut(&T) -> bool + 'a,\n+            left: &'a mut B,\n+            right: &'a mut B,\n+        ) -> impl FnMut(T) + 'a {\n+            move |x| {\n+                if f(&x) {\n+                    left.extend(Some(x));\n+                } else {\n+                    right.extend(Some(x));\n+                }\n+            }\n+        }\n+\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n \n-        self.for_each(|x| {\n-            if f(&x) {\n-                left.extend(Some(x))\n-            } else {\n-                right.extend(Some(x))\n-            }\n-        });\n+        self.for_each(extend(f, &mut left, &mut right));\n \n         (left, right)\n     }\n@@ -1702,10 +1725,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_for_each<F, R>(&mut self, mut f: F) -> R where\n+    fn try_for_each<F, R>(&mut self, f: F) -> R where\n         Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n     {\n-        self.try_fold((), move |(), x| f(x))\n+        #[inline]\n+        fn call<T, R>(mut f: impl FnMut(T) -> R) -> impl FnMut((), T) -> R {\n+            move |(), x| f(x)\n+        }\n+\n+        self.try_fold((), call(f))\n     }\n \n     /// An iterator method that applies a function, producing a single, final value.\n@@ -1777,10 +1805,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n+    fn fold<B, F>(mut self, init: B, f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_fold(init, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(f)).unwrap()\n     }\n \n     /// Tests if every element of the iterator matches a predicate.\n@@ -1822,13 +1855,18 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn all<F>(&mut self, mut f: F) -> bool where\n+    fn all<F>(&mut self, f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        self.try_for_each(move |x| {\n-            if f(x) { LoopState::Continue(()) }\n-            else { LoopState::Break(()) }\n-        }) == LoopState::Continue(())\n+        #[inline]\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n+            move |x| {\n+                if f(x) { LoopState::Continue(()) }\n+                else { LoopState::Break(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(f)) == LoopState::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -1870,14 +1908,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn any<F>(&mut self, mut f: F) -> bool where\n+    fn any<F>(&mut self, f: F) -> bool where\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        self.try_for_each(move |x| {\n-            if f(x) { LoopState::Break(()) }\n-            else { LoopState::Continue(()) }\n-        }) == LoopState::Break(())\n+        #[inline]\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n+            move |x| {\n+                if f(x) { LoopState::Break(()) }\n+                else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(f)) == LoopState::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -1924,14 +1967,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        self.try_for_each(move |x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> LoopState<(), T> {\n+            move |x| {\n+                if predicate(&x) { LoopState::Break(x) }\n+                else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(predicate)).break_value()\n     }\n \n     /// Applies function to the elements of iterator and returns\n@@ -1951,16 +1999,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_find_map\", since = \"1.30.0\")]\n-    fn find_map<B, F>(&mut self, mut f: F) -> Option<B> where\n+    fn find_map<B, F>(&mut self, f: F) -> Option<B> where\n         Self: Sized,\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n-        self.try_for_each(move |x| {\n-            match f(x) {\n+        #[inline]\n+        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut(T) -> LoopState<(), B> {\n+            move |x| match f(x) {\n                 Some(x) => LoopState::Break(x),\n                 None => LoopState::Continue(()),\n             }\n-        }).break_value()\n+        }\n+\n+        self.try_for_each(check(f)).break_value()\n     }\n \n     /// Searches for an element in an iterator, returning its index.\n@@ -2018,17 +2069,23 @@ pub trait Iterator {\n     ///\n     /// ```\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n+    fn position<P>(&mut self, predicate: P) -> Option<usize> where\n         Self: Sized,\n         P: FnMut(Self::Item) -> bool,\n     {\n-        // The addition might panic on overflow\n-        self.try_fold(0, move |i, x| {\n-            if predicate(x) { LoopState::Break(i) }\n-            else { LoopState::Continue(i + 1) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(T) -> bool,\n+        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+            // The addition might panic on overflow\n+            move |i, x| {\n+                if predicate(x) { LoopState::Break(i) }\n+                else { LoopState::Continue(Add::add(i, 1)) }\n+            }\n+        }\n+\n+        self.try_fold(0, check(predicate)).break_value()\n     }\n \n     /// Searches for an element in an iterator from the right, returning its\n@@ -2071,18 +2128,25 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n         Self: Sized + ExactSizeIterator + DoubleEndedIterator\n     {\n         // No need for an overflow check here, because `ExactSizeIterator`\n         // implies that the number of elements fits into a `usize`.\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(T) -> bool,\n+        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+            move |i, x| {\n+                let i = i - 1;\n+                if predicate(x) { LoopState::Break(i) }\n+                else { LoopState::Continue(i) }\n+            }\n+        }\n+\n         let n = self.len();\n-        self.try_rfold(n, move |i, x| {\n-            let i = i - 1;\n-            if predicate(x) { LoopState::Break(i) }\n-            else { LoopState::Continue(i) }\n-        }).break_value()\n+        self.try_rfold(n, check(predicate)).break_value()\n     }\n \n     /// Returns the maximum element of an iterator.\n@@ -2151,11 +2215,22 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn max_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n+    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n+        #[inline]\n+        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n+            move |x| (f(&x), x)\n+        }\n+\n         // switch to y even if it is only equal, to preserve stability.\n-        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p <= y_p).map(|(_, x)| x)\n+        #[inline]\n+        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n+            x_p <= y_p\n+        }\n+\n+        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        Some(x)\n     }\n \n     /// Returns the element that gives the maximum value with respect to the\n@@ -2174,11 +2249,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_max_by\", since = \"1.15.0\")]\n-    fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n+    fn max_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         // switch to y even if it is only equal, to preserve stability.\n-        select_fold1(self, |x, y| compare(x, y) != Ordering::Greater)\n+        #[inline]\n+        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n+            move |x, y| compare(x, y) != Ordering::Greater\n+        }\n+\n+        select_fold1(self, select(compare))\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2195,12 +2275,24 @@ pub trait Iterator {\n     /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn min_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n+    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n+        #[inline]\n+        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n+            move |x| (f(&x), x)\n+        }\n+\n         // only switch to y if it is strictly smaller, to preserve stability.\n-        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p > y_p).map(|(_, x)| x)\n+        #[inline]\n+        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n+            x_p > y_p\n+        }\n+\n+        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        Some(x)\n     }\n \n     /// Returns the element that gives the minimum value with respect to the\n@@ -2219,11 +2311,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_min_by\", since = \"1.15.0\")]\n-    fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n+    fn min_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         // only switch to y if it is strictly smaller, to preserve stability.\n-        select_fold1(self, |x, y| compare(x, y) == Ordering::Greater)\n+        #[inline]\n+        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n+            move |x, y| compare(x, y) == Ordering::Greater\n+        }\n+\n+        select_fold1(self, select(compare))\n     }\n \n \n@@ -2284,13 +2381,20 @@ pub trait Iterator {\n         FromB: Default + Extend<B>,\n         Self: Sized + Iterator<Item=(A, B)>,\n     {\n+        fn extend<'a, A, B>(\n+            ts: &'a mut impl Extend<A>,\n+            us: &'a mut impl Extend<B>,\n+        ) -> impl FnMut((A, B)) + 'a {\n+            move |(t, u)| {\n+                ts.extend(Some(t));\n+                us.extend(Some(u));\n+            }\n+        }\n+\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        self.for_each(|(t, u)| {\n-            ts.extend(Some(t));\n-            us.extend(Some(u));\n-        });\n+        self.for_each(extend(&mut ts, &mut us));\n \n         (ts, us)\n     }\n@@ -2617,7 +2721,7 @@ pub trait Iterator {\n         Self: Sized,\n         Self::Item: PartialOrd,\n     {\n-        self.is_sorted_by(|a, b| a.partial_cmp(b))\n+        self.is_sorted_by(PartialOrd::partial_cmp)\n     }\n \n     /// Checks if the elements of this iterator are sorted using the given comparator function.\n@@ -2639,10 +2743,7 @@ pub trait Iterator {\n         };\n \n         while let Some(curr) = self.next() {\n-            if compare(&last, &curr)\n-                .map(|o| o == Ordering::Greater)\n-                .unwrap_or(true)\n-            {\n+            if let Some(Ordering::Greater) | None = compare(&last, &curr) {\n                 return false;\n             }\n             last = curr;\n@@ -2687,17 +2788,21 @@ pub trait Iterator {\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n /// having to implement optimizations several times.\n #[inline]\n-fn select_fold1<I, F>(mut it: I, mut f: F) -> Option<I::Item>\n+fn select_fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n     where\n         I: Iterator,\n         F: FnMut(&I::Item, &I::Item) -> bool,\n {\n+    #[inline]\n+    fn select<T>(mut f: impl FnMut(&T, &T) -> bool) -> impl FnMut(T, T) -> T {\n+        move |sel, x| if f(&sel, &x) { x } else { sel }\n+    }\n+\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n-    it.next().map(|first| {\n-        it.fold(first, |sel, x| if f(&sel, &x) { x } else { sel })\n-    })\n+    let first = it.next()?;\n+    Some(it.fold(first, select(f)))\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c168d5c8a2eac9e58752c2cb6d4ddedd08bc2ec6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -63,7 +63,7 @@\n #![warn(missing_debug_implementations)]\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n-#![cfg_attr(not(bootstrap), allow(incomplete_features))]\n+#![allow(incomplete_features)]\n \n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n@@ -129,7 +129,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_slice)]\n #![feature(external_doc)]\n #![feature(mem_take)]\n #![feature(associated_type_bounds)]"}, {"sha": "6c88a766a2f10eb39eb7c5096b81bd2e78e1f936", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 16, "deletions": 58, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -2,21 +2,21 @@\n ///\n /// For details, see `std::macros`.\n #[macro_export]\n-#[allow_internal_unstable(core_panic, __rust_unstable_column)]\n+#[allow_internal_unstable(core_panic)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n         $crate::panic!(\"explicit panic\")\n     );\n     ($msg:expr) => ({\n-        $crate::panicking::panic(&($msg, file!(), line!(), __rust_unstable_column!()))\n+        $crate::panicking::panic(&($msg, $crate::file!(), $crate::line!(), $crate::column!()))\n     });\n     ($msg:expr,) => (\n         $crate::panic!($msg)\n     );\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)+),\n-                                     &(file!(), line!(), __rust_unstable_column!()))\n+        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+),\n+                                     &($crate::file!(), $crate::line!(), $crate::column!()))\n     });\n }\n \n@@ -70,7 +70,7 @@ macro_rules! assert_eq {\n                     panic!(r#\"assertion failed: `(left == right)`\n   left: `{:?}`,\n  right: `{:?}`: {}\"#, &*left_val, &*right_val,\n-                           format_args!($($arg)+))\n+                           $crate::format_args!($($arg)+))\n                 }\n             }\n         }\n@@ -127,7 +127,7 @@ macro_rules! assert_ne {\n                     panic!(r#\"assertion failed: `(left != right)`\n   left: `{:?}`,\n  right: `{:?}`: {}\"#, &*left_val, &*right_val,\n-                           format_args!($($arg)+))\n+                           $crate::format_args!($($arg)+))\n                 }\n             }\n         }\n@@ -181,7 +181,7 @@ macro_rules! assert_ne {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert!($($arg)*); })\n+    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert!($($arg)*); })\n }\n \n /// Asserts that two expressions are equal to each other.\n@@ -208,7 +208,7 @@ macro_rules! debug_assert {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! debug_assert_eq {\n-    ($($arg:tt)*) => (if cfg!(debug_assertions) { $crate::assert_eq!($($arg)*); })\n+    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_eq!($($arg)*); })\n }\n \n /// Asserts that two expressions are not equal to each other.\n@@ -235,7 +235,7 @@ macro_rules! debug_assert_eq {\n #[macro_export]\n #[stable(feature = \"assert_ne\", since = \"1.13.0\")]\n macro_rules! debug_assert_ne {\n-    ($($arg:tt)*) => (if cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n+    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n }\n \n /// Unwraps a result or propagates its error.\n@@ -386,7 +386,7 @@ macro_rules! r#try {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt(format_args!($($arg)*)))\n+    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt($crate::format_args!($($arg)*)))\n }\n \n /// Write formatted data into a buffer, with a newline appended.\n@@ -446,7 +446,7 @@ macro_rules! writeln {\n         $crate::writeln!($dst)\n     );\n     ($dst:expr, $($arg:tt)*) => (\n-        $dst.write_fmt(format_args_nl!($($arg)*))\n+        $dst.write_fmt($crate::format_args_nl!($($arg)*))\n     );\n }\n \n@@ -515,7 +515,7 @@ macro_rules! unreachable {\n         $crate::unreachable!($msg)\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n-        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n+        panic!($crate::concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n     });\n }\n \n@@ -573,7 +573,7 @@ macro_rules! unreachable {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"));\n-    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)+)));\n+    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));\n }\n \n /// Indicates unfinished code.\n@@ -632,49 +632,14 @@ macro_rules! unimplemented {\n #[unstable(feature = \"todo_macro\", issue = \"59277\")]\n macro_rules! todo {\n     () => (panic!(\"not yet implemented\"));\n-    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)+)));\n-}\n-\n-/// Creates an array of [`MaybeUninit`].\n-///\n-/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n-/// It exists solely because bootstrap does not yet support const array-init expressions.\n-///\n-/// [`MaybeUninit`]: mem/union.MaybeUninit.html\n-// FIXME: Remove both versions of this macro once bootstrap is 1.38.\n-#[macro_export]\n-#[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n-#[cfg(bootstrap)]\n-macro_rules! uninit_array {\n-    // This `assume_init` is safe because an array of `MaybeUninit` does not\n-    // require initialization.\n-    ($t:ty; $size:expr) => (unsafe {\n-        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninit().assume_init()\n-    });\n-}\n-\n-/// Creates an array of [`MaybeUninit`].\n-///\n-/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n-/// It exists solely because bootstrap does not yet support const array-init expressions.\n-///\n-/// [`MaybeUninit`]: mem/union.MaybeUninit.html\n-// FIXME: Just inline this version of the macro once bootstrap is 1.38.\n-#[macro_export]\n-#[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n-#[cfg(not(bootstrap))]\n-macro_rules! uninit_array {\n-    ($t:ty; $size:expr) => (\n-        [MaybeUninit::<$t>::UNINIT; $size]\n-    );\n+    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));\n }\n \n /// Definitions of built-in macros.\n ///\n /// Most of the macro properties (stability, visibility, etc.) are taken from the source code here,\n /// with exception of expansion functions transforming macro inputs into outputs,\n /// those functions are provided by the compiler.\n-#[cfg(not(bootstrap))]\n pub(crate) mod builtin {\n \n     /// Causes compilation to fail with the given error message when encountered.\n@@ -962,13 +927,6 @@ pub(crate) mod builtin {\n     #[macro_export]\n     macro_rules! column { () => { /* compiler built-in */ } }\n \n-    /// Same as `column`, but less likely to be shadowed.\n-    #[unstable(feature = \"__rust_unstable_column\", issue = \"0\",\n-               reason = \"internal implementation detail of the `panic` macro\")]\n-    #[rustc_builtin_macro]\n-    #[macro_export]\n-    macro_rules! __rust_unstable_column { () => { /* compiler built-in */ } }\n-\n     /// Expands to the file name in which it was invoked.\n     ///\n     /// With [`line!`] and [`column!`], these macros provide debugging information for\n@@ -1305,14 +1263,14 @@ pub(crate) mod builtin {\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n     pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro RustcEncodable($item:item) { /* compiler built-in */ }"}, {"sha": "89af2528c052a2dea2b2e8834ccca0c9bc191714", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -289,9 +289,8 @@ pub trait Copy : Clone {\n }\n \n /// Derive macro generating an impl of the trait `Copy`.\n-#[cfg(not(bootstrap))]\n #[rustc_builtin_macro]\n-#[rustc_macro_transparency = \"semitransparent\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n pub macro Copy($item:item) { /* compiler built-in */ }"}, {"sha": "9e9e901c76d3ff0d02213e27f5677873c6eabe02", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -213,7 +213,7 @@ use crate::mem::ManuallyDrop;\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n // Lang item so we can wrap other types in it. This is useful for generators.\n-#[cfg_attr(not(bootstrap), lang = \"maybe_uninit\")]\n+#[lang = \"maybe_uninit\"]\n #[derive(Copy)]\n #[repr(transparent)]\n pub union MaybeUninit<T> {\n@@ -312,7 +312,7 @@ impl<T> MaybeUninit<T> {\n     /// without dropping it, so be careful not to use this twice unless you want to\n     /// skip running the destructor. For your convenience, this also returns a mutable\n     /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n@@ -502,7 +502,7 @@ impl<T> MaybeUninit<T> {\n     /// // We now created two copies of the same vector, leading to a double-free when\n     /// // they both get dropped!\n     /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n@@ -516,7 +516,7 @@ impl<T> MaybeUninit<T> {\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n         &*self.value\n@@ -532,21 +532,21 @@ impl<T> MaybeUninit<T> {\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut *self.value\n     }\n \n     /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n     /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this as *mut [MaybeUninit<T>] as *mut T"}, {"sha": "87ec05a243d3619c468ae2615772eb00f3f1d07d", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -453,7 +453,7 @@ pub const fn needs_drop<T>() -> bool {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(bootstrap, allow(deprecated_in_future))]\n+#[allow(deprecated_in_future)]\n #[allow(deprecated)]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n@@ -481,7 +481,7 @@ pub unsafe fn zeroed<T>() -> T {\n #[inline]\n #[rustc_deprecated(since = \"1.39.0\", reason = \"use `mem::MaybeUninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(bootstrap, allow(deprecated_in_future))]\n+#[allow(deprecated_in_future)]\n #[allow(deprecated)]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();"}, {"sha": "b46e06f8d8ada93b5c8089cef11cfa14dac22e71", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1112,7 +1112,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_add(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_add(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_add(self, rhs)\n+                }\n             }\n         }\n \n@@ -1135,7 +1141,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_sub(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_sub(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_sub(self, rhs)\n+                }\n             }\n         }\n \n@@ -1157,7 +1169,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_mul(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_mul(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_mul(self, rhs)\n+                }\n             }\n         }\n \n@@ -3031,7 +3049,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_add(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_add(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_add(self, rhs)\n+                }\n             }\n         }\n \n@@ -3053,7 +3077,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                intrinsics::overflowing_sub(self, rhs)\n+                #[cfg(boostrap_stdarch_ignore_this)] {\n+                    intrinsics::overflowing_sub(self, rhs)\n+                }\n+\n+                #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                    intrinsics::wrapping_sub(self, rhs)\n+                }\n             }\n         }\n \n@@ -3076,7 +3106,13 @@ $EndFeature, \"\n                           without modifying the original\"]\n         #[inline]\n         pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-            intrinsics::overflowing_mul(self, rhs)\n+            #[cfg(boostrap_stdarch_ignore_this)] {\n+                intrinsics::overflowing_mul(self, rhs)\n+            }\n+\n+            #[cfg(not(boostrap_stdarch_ignore_this))] {\n+                intrinsics::wrapping_mul(self, rhs)\n+            }\n         }\n \n         doc_comment! {"}, {"sha": "7cc279a9ef2ecb83ce3ac3916b6f0b9273617861", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -46,20 +46,16 @@ pub use crate::option::Option::{self, Some, None};\n pub use crate::result::Result::{self, Ok, Err};\n \n // Re-exported built-in macros\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::fmt::macros::Debug;\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::hash::macros::Hash;\n \n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::{\n-    __rust_unstable_column,\n     asm,\n     assert,\n     cfg,\n@@ -83,7 +79,6 @@ pub use crate::{\n     trace_macros,\n };\n \n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n #[doc(no_inline)]"}, {"sha": "fec17c4d1a4df7b111a5ab90b38cd6a956945868", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -81,6 +81,34 @@ impl<T, E> Poll<Result<T, E>> {\n     }\n }\n \n+impl<T, E> Poll<Option<Result<T, E>>> {\n+    /// Changes the success value of this `Poll` with the closure provided.\n+    #[unstable(feature = \"poll_map\", issue = \"63514\")]\n+    pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n+        where F: FnOnce(T) -> U\n+    {\n+        match self {\n+            Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(f(t)))),\n+            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(e))),\n+            Poll::Ready(None) => Poll::Ready(None),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+\n+    /// Changes the error value of this `Poll` with the closure provided.\n+    #[unstable(feature = \"poll_map\", issue = \"63514\")]\n+    pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n+        where F: FnOnce(E) -> U\n+    {\n+        match self {\n+            Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(t))),\n+            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(f(e)))),\n+            Poll::Ready(None) => Poll::Ready(None),\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+}\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<T> From<T> for Poll<T> {\n     fn from(t: T) -> Poll<T> {"}, {"sha": "a1a27e1d5380ff50f4487ede0e7e08aa24f7ed79", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -103,6 +103,22 @@ fn test_iterator_chain_nth() {\n     assert_eq!(it.next(), None);\n }\n \n+#[test]\n+fn test_iterator_chain_nth_back() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    for (i, x) in expected.iter().rev().enumerate() {\n+        assert_eq!(Some(x), xs.iter().chain(&ys).nth_back(i));\n+    }\n+    assert_eq!(zs.iter().chain(&xs).nth_back(0), Some(&5));\n+\n+    let mut it = xs.iter().chain(&zs);\n+    assert_eq!(it.nth_back(5), Some(&0));\n+    assert_eq!(it.next(), None);\n+}\n+\n #[test]\n fn test_iterator_chain_last() {\n     let xs = [0, 1, 2, 3, 4, 5];\n@@ -1136,6 +1152,18 @@ fn test_cycle() {\n     assert_eq!(empty::<i32>().cycle().fold(0, |acc, x| acc + x), 0);\n \n     assert_eq!(once(1).cycle().skip(1).take(4).fold(0, |acc, x| acc + x), 4);\n+\n+    assert_eq!((0..10).cycle().take(5).sum::<i32>(), 10);\n+    assert_eq!((0..10).cycle().take(15).sum::<i32>(), 55);\n+    assert_eq!((0..10).cycle().take(25).sum::<i32>(), 100);\n+\n+    let mut iter = (0..10).cycle();\n+    iter.nth(14);\n+    assert_eq!(iter.take(8).sum::<i32>(), 38);\n+\n+    let mut iter = (0..10).cycle();\n+    iter.nth(9);\n+    assert_eq!(iter.take(3).sum::<i32>(), 3);\n }\n \n #[test]"}, {"sha": "7ada56cfa76116411cf17a42dcd4efe044daa392", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             PatKind::Struct(_, ref subpats, _) => {\n-                let pats_exit = self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n+                let pats_exit = self.pats_all(subpats.iter().map(|f| &f.pat), pred);\n                 self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n "}, {"sha": "eae956c978a8e08823b46cc2c1b98c1b8e769175", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -336,7 +336,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n fn is_c_like_enum(item: &hir::Item) -> bool {\n     if let hir::ItemKind::Enum(ref def, _) = item.node {\n         for variant in &def.variants {\n-            match variant.node.data {\n+            match variant.data {\n                 hir::VariantData::Unit(..) => { /* continue */ }\n                 _ => { return false; }\n             }"}, {"sha": "99fe9f1682f163656c807d1313f29c962ddb0fa1", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -577,15 +577,15 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n                                         generics: &'v Generics,\n                                         parent_item_id: HirId) {\n-    visitor.visit_ident(variant.node.ident);\n-    visitor.visit_id(variant.node.id);\n-    visitor.visit_variant_data(&variant.node.data,\n-                               variant.node.ident.name,\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_id(variant.id);\n+    visitor.visit_variant_data(&variant.data,\n+                               variant.ident.name,\n                                generics,\n                                parent_item_id,\n                                variant.span);\n-    walk_list!(visitor, visit_anon_const, &variant.node.disr_expr);\n-    walk_list!(visitor, visit_attribute, &variant.node.attrs);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n@@ -704,9 +704,9 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Struct(ref qpath, ref fields, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n             for field in fields {\n-                visitor.visit_id(field.node.hir_id);\n-                visitor.visit_ident(field.node.ident);\n-                visitor.visit_pat(&field.node.pat)\n+                visitor.visit_id(field.hir_id);\n+                visitor.visit_ident(field.ident);\n+                visitor.visit_pat(&field.pat)\n             }\n         }\n         PatKind::Tuple(ref tuple_elements, _) => {"}, {"sha": "0f6e834ca26df730518044e7c615e0ed91808b86", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 126, "deletions": 147, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -67,7 +67,7 @@ use syntax::errors;\n use syntax::ext::base::SpecialDerives;\n use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n-use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n+use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n@@ -136,7 +136,10 @@ pub struct LoweringContext<'a> {\n     /// When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n     /// against this list to see if it is already in-scope, or if a definition\n     /// needs to be created for it.\n-    in_scope_lifetimes: Vec<Ident>,\n+    ///\n+    /// We always store a `modern()` version of the param-name in this\n+    /// vector.\n+    in_scope_lifetimes: Vec<ParamName>,\n \n     current_module: NodeId,\n \n@@ -337,49 +340,6 @@ enum AnonymousLifetimeMode {\n \n     /// Pass responsibility to `resolve_lifetime` code for all cases.\n     PassThrough,\n-\n-    /// Used in the return types of `async fn` where there exists\n-    /// exactly one argument-position elided lifetime.\n-    ///\n-    /// In `async fn`, we lower the arguments types using the `CreateParameter`\n-    /// mode, meaning that non-`dyn` elided lifetimes are assigned a fresh name.\n-    /// If any corresponding elided lifetimes appear in the output, we need to\n-    /// replace them with references to the fresh name assigned to the corresponding\n-    /// elided lifetime in the arguments.\n-    ///\n-    /// For **Modern cases**, replace the anonymous parameter with a\n-    /// reference to a specific freshly-named lifetime that was\n-    /// introduced in argument\n-    ///\n-    /// For **Dyn Bound** cases, pass responsibility to\n-    /// `resole_lifetime` code.\n-    Replace(LtReplacement),\n-}\n-\n-/// The type of elided lifetime replacement to perform on `async fn` return types.\n-#[derive(Copy, Clone)]\n-enum LtReplacement {\n-    /// Fresh name introduced by the single non-dyn elided lifetime\n-    /// in the arguments of the async fn.\n-    Some(ParamName),\n-\n-    /// There is no single non-dyn elided lifetime because no lifetimes\n-    /// appeared in the arguments.\n-    NoLifetimes,\n-\n-    /// There is no single non-dyn elided lifetime because multiple\n-    /// lifetimes appeared in the arguments.\n-    MultipleLifetimes,\n-}\n-\n-/// Calculates the `LtReplacement` to use for elided lifetimes in the return\n-/// type based on the fresh elided lifetimes introduced in argument position.\n-fn get_elided_lt_replacement(arg_position_lifetimes: &[(Span, ParamName)]) -> LtReplacement {\n-    match arg_position_lifetimes {\n-        [] => LtReplacement::NoLifetimes,\n-        [(_span, param)] => LtReplacement::Some(*param),\n-        _ => LtReplacement::MultipleLifetimes,\n-    }\n }\n \n struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n@@ -744,10 +704,9 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        span.fresh_expansion(ExpnId::root(), ExpnInfo {\n-            def_site: span,\n+        span.fresh_expansion(ExpnData {\n             allow_internal_unstable,\n-            ..ExpnInfo::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n+            ..ExpnData::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n         })\n     }\n \n@@ -865,7 +824,7 @@ impl<'a> LoweringContext<'a> {\n             return;\n         }\n \n-        if self.in_scope_lifetimes.contains(&ident.modern()) {\n+        if self.in_scope_lifetimes.contains(&ParamName::Plain(ident.modern())) {\n             return;\n         }\n \n@@ -899,7 +858,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => Some(param.ident.modern()),\n+            GenericParamKind::Lifetime { .. } => Some(ParamName::Plain(param.ident.modern())),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -1264,7 +1223,7 @@ impl<'a> LoweringContext<'a> {\n                     P(hir::Path {\n                         res,\n                         segments: hir_vec![hir::PathSegment::from_ident(\n-                            Ident::with_empty_ctxt(kw::SelfUpper)\n+                            Ident::with_dummy_span(kw::SelfUpper)\n                         )],\n                         span: t.span,\n                     }),\n@@ -1598,7 +1557,7 @@ impl<'a> LoweringContext<'a> {\n \n                     let (name, kind) = match name {\n                         hir::LifetimeName::Underscore => (\n-                            hir::ParamName::Plain(Ident::with_empty_ctxt(kw::UnderscoreLifetime)),\n+                            hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n                             hir::LifetimeParamKind::Elided,\n                         ),\n                         hir::LifetimeName::Param(param_name) => (\n@@ -1953,8 +1912,7 @@ impl<'a> LoweringContext<'a> {\n                         err.emit();\n                     }\n                     AnonymousLifetimeMode::PassThrough |\n-                    AnonymousLifetimeMode::ReportError |\n-                    AnonymousLifetimeMode::Replace(_) => {\n+                    AnonymousLifetimeMode::ReportError => {\n                         self.sess.buffer_lint_with_diagnostic(\n                             ELIDED_LIFETIMES_IN_PATHS,\n                             CRATE_NODE_ID,\n@@ -2043,7 +2001,7 @@ impl<'a> LoweringContext<'a> {\n                         bindings: hir_vec![\n                             hir::TypeBinding {\n                                 hir_id: this.next_id(),\n-                                ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                                 kind: hir::TypeBindingKind::Equality {\n                                     ty: output\n                                         .as_ref()\n@@ -2141,7 +2099,6 @@ impl<'a> LoweringContext<'a> {\n \n         // Remember how many lifetimes were already around so that we can\n         // only look at the lifetime parameters introduced by the arguments.\n-        let lifetime_count_before_args = self.lifetimes_to_define.len();\n         let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n             decl.inputs\n                 .iter()\n@@ -2156,16 +2113,10 @@ impl<'a> LoweringContext<'a> {\n         });\n \n         let output = if let Some(ret_id) = make_ret_async {\n-            // Calculate the `LtReplacement` to use for any return-position elided\n-            // lifetimes based on the elided lifetime parameters introduced in the args.\n-            let lt_replacement = get_elided_lt_replacement(\n-                &self.lifetimes_to_define[lifetime_count_before_args..]\n-            );\n             self.lower_async_fn_ret_ty(\n                 &decl.output,\n                 in_band_ty_params.expect(\"`make_ret_async` but no `fn_def_id`\").0,\n                 ret_id,\n-                lt_replacement,\n             )\n         } else {\n             match decl.output {\n@@ -2230,7 +2181,6 @@ impl<'a> LoweringContext<'a> {\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n         opaque_ty_node_id: NodeId,\n-        elided_lt_replacement: LtReplacement,\n     ) -> hir::FunctionRetTy {\n         let span = output.span();\n \n@@ -2248,9 +2198,65 @@ impl<'a> LoweringContext<'a> {\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n+        // When we create the opaque type for this async fn, it is going to have\n+        // to capture all the lifetimes involved in the signature (including in the\n+        // return type). This is done by introducing lifetime parameters for:\n+        //\n+        // - all the explicitly declared lifetimes from the impl and function itself;\n+        // - all the elided lifetimes in the fn arguments;\n+        // - all the elided lifetimes in the return type.\n+        //\n+        // So for example in this snippet:\n+        //\n+        // ```rust\n+        // impl<'a> Foo<'a> {\n+        //   async fn bar<'b>(&self, x: &'b Vec<f64>, y: &str) -> &u32 {\n+        //   //               ^ '0                       ^ '1     ^ '2\n+        //   // elided lifetimes used below\n+        //   }\n+        // }\n+        // ```\n+        //\n+        // we would create an opaque type like:\n+        //\n+        // ```\n+        // type Bar<'a, 'b, '0, '1, '2> = impl Future<Output = &'2 u32>;\n+        // ```\n+        //\n+        // and we would then desugar `bar` to the equivalent of:\n+        //\n+        // ```rust\n+        // impl<'a> Foo<'a> {\n+        //   fn bar<'b, '0, '1>(&'0 self, x: &'b Vec<f64>, y: &'1 str) -> Bar<'a, 'b, '0, '1, '_>\n+        // }\n+        // ```\n+        //\n+        // Note that the final parameter to `Bar` is `'_`, not `'2` --\n+        // this is because the elided lifetimes from the return type\n+        // should be figured out using the ordinary elision rules, and\n+        // this desugaring achieves that.\n+        //\n+        // The variable `input_lifetimes_count` tracks the number of\n+        // lifetime parameters to the opaque type *not counting* those\n+        // lifetimes elided in the return type. This includes those\n+        // that are explicitly declared (`in_scope_lifetimes`) and\n+        // those elided lifetimes we found in the arguments (current\n+        // content of `lifetimes_to_define`). Next, we will process\n+        // the return type, which will cause `lifetimes_to_define` to\n+        // grow.\n+        let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n+\n         let (opaque_ty_id, lifetime_params) = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+            // We have to be careful to get elision right here. The\n+            // idea is that we create a lifetime parameter for each\n+            // lifetime in the return type.  So, given a return type\n+            // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n+            // Future<Output = &'1 [ &'2 u32 ]>`.\n+            //\n+            // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n+            // hence the elision takes place at the fn site.\n             let future_bound = this.with_anonymous_lifetime_mode(\n-                AnonymousLifetimeMode::Replace(elided_lt_replacement),\n+                AnonymousLifetimeMode::CreateParameter,\n                 |this| this.lower_async_fn_output_type_to_future_bound(\n                     output,\n                     fn_def_id,\n@@ -2267,10 +2273,14 @@ impl<'a> LoweringContext<'a> {\n             let lifetime_params: Vec<(Span, ParamName)> =\n                 this.in_scope_lifetimes\n                     .iter().cloned()\n-                    .map(|ident| (ident.span, ParamName::Plain(ident)))\n+                    .map(|name| (name.ident().span, name))\n                     .chain(this.lifetimes_to_define.iter().cloned())\n                     .collect();\n \n+            debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", this.in_scope_lifetimes);\n+            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n+            debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n+\n             let generic_params =\n                 lifetime_params\n                     .iter().cloned()\n@@ -2304,19 +2314,52 @@ impl<'a> LoweringContext<'a> {\n             (opaque_ty_id, lifetime_params)\n         });\n \n-        let generic_args =\n-            lifetime_params\n-                .iter().cloned()\n-                .map(|(span, hir_name)| {\n-                    GenericArg::Lifetime(hir::Lifetime {\n-                        hir_id: self.next_id(),\n-                        span,\n-                        name: hir::LifetimeName::Param(hir_name),\n-                    })\n+        // As documented above on the variable\n+        // `input_lifetimes_count`, we need to create the lifetime\n+        // arguments to our opaque type. Continuing with our example,\n+        // we're creating the type arguments for the return type:\n+        //\n+        // ```\n+        // Bar<'a, 'b, '0, '1, '_>\n+        // ```\n+        //\n+        // For the \"input\" lifetime parameters, we wish to create\n+        // references to the parameters themselves, including the\n+        // \"implicit\" ones created from parameter types (`'a`, `'b`,\n+        // '`0`, `'1`).\n+        //\n+        // For the \"output\" lifetime parameters, we just want to\n+        // generate `'_`.\n+        let mut generic_args: Vec<_> =\n+            lifetime_params[..input_lifetimes_count]\n+            .iter()\n+            .map(|&(span, hir_name)| {\n+                // Input lifetime like `'a` or `'1`:\n+                GenericArg::Lifetime(hir::Lifetime {\n+                    hir_id: self.next_id(),\n+                    span,\n+                    name: hir::LifetimeName::Param(hir_name),\n                 })\n-                .collect();\n+            })\n+            .collect();\n+        generic_args.extend(\n+            lifetime_params[input_lifetimes_count..]\n+            .iter()\n+            .map(|&(span, _)| {\n+                // Output lifetime like `'_`.\n+                GenericArg::Lifetime(hir::Lifetime {\n+                    hir_id: self.next_id(),\n+                    span,\n+                    name: hir::LifetimeName::Implicit,\n+                })\n+            })\n+        );\n \n-        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n+        // Create the `Foo<...>` refernece itself. Note that the `type\n+        // Foo = impl Trait` is, internally, created as a child of the\n+        // async fn, so the *type parameters* are inherited.  It's\n+        // only the lifetime parameters that we must supply.\n+        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args.into());\n \n         hir::FunctionRetTy::Return(P(hir::Ty {\n             node: opaque_ty_ref,\n@@ -2350,7 +2393,7 @@ impl<'a> LoweringContext<'a> {\n         let future_params = P(hir::GenericArgs {\n             args: hir_vec![],\n             bindings: hir_vec![hir::TypeBinding {\n-                ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 kind: hir::TypeBindingKind::Equality {\n                     ty: output_ty,\n                 },\n@@ -2412,11 +2455,6 @@ impl<'a> LoweringContext<'a> {\n                     }\n \n                     AnonymousLifetimeMode::ReportError => self.new_error_lifetime(Some(l.id), span),\n-\n-                    AnonymousLifetimeMode::Replace(replacement) => {\n-                        let hir_id = self.lower_node_id(l.id);\n-                        self.replace_elided_lifetime(hir_id, span, replacement)\n-                    }\n                 },\n             ident => {\n                 self.maybe_collect_in_band_lifetime(ident);\n@@ -2439,39 +2477,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    /// Replace a return-position elided lifetime with the elided lifetime\n-    /// from the arguments.\n-    fn replace_elided_lifetime(\n-        &mut self,\n-        hir_id: hir::HirId,\n-        span: Span,\n-        replacement: LtReplacement,\n-    ) -> hir::Lifetime {\n-        let multiple_or_none = match replacement {\n-            LtReplacement::Some(name) => {\n-                return hir::Lifetime {\n-                    hir_id,\n-                    span,\n-                    name: hir::LifetimeName::Param(name),\n-                };\n-            }\n-            LtReplacement::MultipleLifetimes => \"multiple\",\n-            LtReplacement::NoLifetimes => \"none\",\n-        };\n-\n-        let mut err = crate::middle::resolve_lifetime::report_missing_lifetime_specifiers(\n-            self.sess,\n-            span,\n-            1,\n-        );\n-        err.note(&format!(\n-            \"return-position elided lifetimes require exactly one \\\n-             input-position elided lifetime, found {}.\", multiple_or_none));\n-        err.emit();\n-\n-        hir::Lifetime { hir_id, span, name: hir::LifetimeName::Error }\n-    }\n-\n     fn lower_generic_params(\n         &mut self,\n         params: &[GenericParam],\n@@ -2685,16 +2690,12 @@ impl<'a> LoweringContext<'a> {\n \n                 let fs = fields\n                     .iter()\n-                    .map(|f| {\n-                        Spanned {\n-                            span: f.span,\n-                            node: hir::FieldPat {\n-                                hir_id: self.next_id(),\n-                                ident: f.node.ident,\n-                                pat: self.lower_pat(&f.node.pat),\n-                                is_shorthand: f.node.is_shorthand,\n-                            },\n-                        }\n+                    .map(|f| hir::FieldPat {\n+                        hir_id: self.next_id(),\n+                        ident: f.ident,\n+                        pat: self.lower_pat(&f.pat),\n+                        is_shorthand: f.is_shorthand,\n+                        span: f.span,\n                     })\n                     .collect();\n                 hir::PatKind::Struct(qpath, fs, etc)\n@@ -3174,10 +3175,6 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n \n             AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n-\n-            AnonymousLifetimeMode::Replace(replacement) => {\n-                self.new_replacement_lifetime(replacement, span)\n-            }\n         }\n     }\n \n@@ -3231,10 +3228,6 @@ impl<'a> LoweringContext<'a> {\n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n \n-            AnonymousLifetimeMode::Replace(replacement) => {\n-                self.new_replacement_lifetime(replacement, span)\n-            }\n-\n             AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n         }\n     }\n@@ -3266,25 +3259,11 @@ impl<'a> LoweringContext<'a> {\n \n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => {}\n-\n-            // We don't need to do any replacement here as this lifetime\n-            // doesn't refer to an elided lifetime elsewhere in the function\n-            // signature.\n-            AnonymousLifetimeMode::Replace(_) => {}\n         }\n \n         self.new_implicit_lifetime(span)\n     }\n \n-    fn new_replacement_lifetime(\n-        &mut self,\n-        replacement: LtReplacement,\n-        span: Span,\n-    ) -> hir::Lifetime {\n-        let hir_id = self.next_id();\n-        self.replace_elided_lifetime(hir_id, span, replacement)\n-    }\n-\n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         hir::Lifetime {\n             hir_id: self.next_id(),"}, {"sha": "ff0c44a23874bfa96bd824625fc1e162583416de", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -552,7 +552,7 @@ impl LoweringContext<'_> {\n \n         // let mut pinned = <expr>;\n         let expr = P(self.lower_expr(expr));\n-        let pinned_ident = Ident::with_empty_ctxt(sym::pinned);\n+        let pinned_ident = Ident::with_dummy_span(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n             span,\n             pinned_ident,\n@@ -593,7 +593,7 @@ impl LoweringContext<'_> {\n         let loop_node_id = self.sess.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n-            let x_ident = Ident::with_empty_ctxt(sym::result);\n+            let x_ident = Ident::with_dummy_span(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n             let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n             let ready_pat = self.pat_std_enum(\n@@ -677,6 +677,7 @@ impl LoweringContext<'_> {\n         let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n         self.with_new_scopes(|this| {\n+            let prev = this.current_item;\n             this.current_item = Some(fn_decl_span);\n             let mut generator_kind = None;\n             let body_id = this.lower_fn_body(decl, |this| {\n@@ -690,8 +691,10 @@ impl LoweringContext<'_> {\n                 generator_kind,\n                 movability,\n             );\n+            let capture_clause = this.lower_capture_clause(capture_clause);\n+            this.current_item = prev;\n             hir::ExprKind::Closure(\n-                this.lower_capture_clause(capture_clause),\n+                capture_clause,\n                 fn_decl,\n                 body_id,\n                 fn_decl_span,\n@@ -981,7 +984,6 @@ impl LoweringContext<'_> {\n             volatile: asm.volatile,\n             alignstack: asm.alignstack,\n             dialect: asm.dialect,\n-            ctxt: asm.ctxt,\n         };\n \n         let outputs = asm.outputs\n@@ -1067,9 +1069,9 @@ impl LoweringContext<'_> {\n         );\n         head.span = desugared_span;\n \n-        let iter = Ident::with_empty_ctxt(sym::iter);\n+        let iter = Ident::with_dummy_span(sym::iter);\n \n-        let next_ident = Ident::with_empty_ctxt(sym::__next);\n+        let next_ident = Ident::with_dummy_span(sym::__next);\n         let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n             desugared_span,\n             next_ident,\n@@ -1078,7 +1080,7 @@ impl LoweringContext<'_> {\n \n         // `::std::option::Option::Some(val) => __next = val`\n         let pat_arm = {\n-            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n             let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n             let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n@@ -1244,7 +1246,7 @@ impl LoweringContext<'_> {\n \n         // `Ok(val) => #[allow(unreachable_code)] val,`\n         let ok_arm = {\n-            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n             let val_expr = P(self.expr_ident_with_attrs(\n                 span,\n@@ -1260,7 +1262,7 @@ impl LoweringContext<'_> {\n         // `Err(err) => #[allow(unreachable_code)]\n         //              return Try::from_error(From::from(err)),`\n         let err_arm = {\n-            let err_ident = Ident::with_empty_ctxt(sym::err);\n+            let err_ident = Ident::with_dummy_span(sym::err);\n             let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n             let from_expr = {\n                 let from_path = &[sym::convert, sym::From, sym::from];"}, {"sha": "4f9a9ed5673c7acc83d363e43d27943ecae58291", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -60,10 +60,12 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n         let mut item_hir_id = None;\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            if let Some(hir_item) = lctx.lower_item(item) {\n-                item_hir_id = Some(hir_item.hir_id);\n-                lctx.insert_item(hir_item);\n-            }\n+            lctx.without_in_scope_lifetime_defs(|lctx| {\n+                if let Some(hir_item) = lctx.lower_item(item) {\n+                    item_hir_id = Some(hir_item.hir_id);\n+                    lctx.insert_item(hir_item);\n+                }\n+            })\n         });\n \n         if let Some(hir_id) = item_hir_id {\n@@ -123,7 +125,7 @@ impl LoweringContext<'_> {\n             _ => &[],\n         };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.ident().modern()),\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.modern()),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -134,6 +136,28 @@ impl LoweringContext<'_> {\n         res\n     }\n \n+    // Clears (and restores) the `in_scope_lifetimes` field. Used when\n+    // visiting nested items, which never inherit in-scope lifetimes\n+    // from their surrounding environment.\n+    fn without_in_scope_lifetime_defs<T>(\n+        &mut self,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> T,\n+    ) -> T {\n+        let old_in_scope_lifetimes = std::mem::replace(&mut self.in_scope_lifetimes, vec![]);\n+\n+        // this vector is only used when walking over impl headers,\n+        // input types, and the like, and should not be non-empty in\n+        // between items\n+        assert!(self.lifetimes_to_define.is_empty());\n+\n+        let res = f(self);\n+\n+        assert!(self.in_scope_lifetimes.is_empty());\n+        self.in_scope_lifetimes = old_in_scope_lifetimes;\n+\n+        res\n+    }\n+\n     pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n         hir::Mod {\n             inner: m.inner,\n@@ -726,21 +750,16 @@ impl LoweringContext<'_> {\n     }\n \n     fn lower_global_asm(&mut self, ga: &GlobalAsm) -> P<hir::GlobalAsm> {\n-        P(hir::GlobalAsm {\n-            asm: ga.asm,\n-            ctxt: ga.ctxt,\n-        })\n+        P(hir::GlobalAsm { asm: ga.asm })\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n-        Spanned {\n-            node: hir::VariantKind {\n-                ident: v.node.ident,\n-                id: self.lower_node_id(v.node.id),\n-                attrs: self.lower_attrs(&v.node.attrs),\n-                data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n-            },\n+        hir::Variant {\n+            attrs: self.lower_attrs(&v.attrs),\n+            data: self.lower_variant_data(&v.data),\n+            disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n+            id: self.lower_node_id(v.id),\n+            ident: v.ident,\n             span: v.span,\n         }\n     }"}, {"sha": "effe2c0cc6a76f1dde4be58fa7b145fbc3fdad90", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -544,11 +544,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: HirId) {\n-        self.insert(v.span, v.node.id, Node::Variant(v));\n-        self.with_parent(v.node.id, |this| {\n+        self.insert(v.span, v.id, Node::Variant(v));\n+        self.with_parent(v.id, |this| {\n             // Register the constructor of this variant.\n-            if let Some(ctor_hir_id) = v.node.data.ctor_hir_id() {\n-                this.insert(v.span, ctor_hir_id, Node::Ctor(&v.node.data));\n+            if let Some(ctor_hir_id) = v.data.ctor_hir_id() {\n+                this.insert(v.span, ctor_hir_id, Node::Ctor(&v.data));\n             }\n             intravisit::walk_variant(this, v, g, item_id);\n         });"}, {"sha": "df9bd3a35a6219db4aca1c4e778cfd12f2b07023", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -155,11 +155,11 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-        let def = self.create_def(v.node.id,\n-                                  DefPathData::TypeNs(v.node.ident.as_interned_str()),\n+        let def = self.create_def(v.id,\n+                                  DefPathData::TypeNs(v.ident.as_interned_str()),\n                                   v.span);\n         self.with_parent(def, |this| {\n-            if let Some(ctor_hir_id) = v.node.data.ctor_id() {\n+            if let Some(ctor_hir_id) = v.data.ctor_id() {\n                 this.create_def(ctor_hir_id, DefPathData::Ctor, v.span);\n             }\n             visit::walk_variant(this, v, g, item_id)"}, {"sha": "7292428ec378c62be57090a7e2d7e2532d80e265", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -649,12 +649,34 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn is_const_scope(&self, hir_id: HirId) -> bool {\n-        self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(Item { node: ItemKind::Const(_, _), .. }) => true,\n-            Node::Item(Item { node: ItemKind::Fn(_, header, _, _), .. }) => header.is_const(),\n+    /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n+    /// Used exclusively for diagnostics, to avoid suggestion function calls.\n+    pub fn is_const_context(&self, hir_id: HirId) -> bool {\n+        let parent_id = self.get_parent_item(hir_id);\n+        match self.get(parent_id) {\n+            Node::Item(&Item {\n+                node: ItemKind::Const(..),\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                node: TraitItemKind::Const(..),\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                node: ImplItemKind::Const(..),\n+                ..\n+            })\n+            | Node::AnonConst(_)\n+            | Node::Item(&Item {\n+                node: ItemKind::Static(..),\n+                ..\n+            }) => true,\n+            Node::Item(&Item {\n+                node: ItemKind::Fn(_, header, ..),\n+                ..\n+            }) => header.constness == Constness::Const,\n             _ => false,\n-        }, |_| false).map(|id| id != CRATE_HIR_ID).unwrap_or(false)\n+        }\n     }\n \n     /// If there is some error when walking the parents (e.g., a node does not\n@@ -885,7 +907,7 @@ impl<'hir> Map<'hir> {\n                     _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n                 }\n             }\n-            Some(Node::Variant(variant)) => &variant.node.data,\n+            Some(Node::Variant(variant)) => &variant.data,\n             Some(Node::Ctor(data)) => data,\n             _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id))\n         }\n@@ -918,7 +940,7 @@ impl<'hir> Map<'hir> {\n             Node::ForeignItem(fi) => fi.ident.name,\n             Node::ImplItem(ii) => ii.ident.name,\n             Node::TraitItem(ti) => ti.ident.name,\n-            Node::Variant(v) => v.node.ident.name,\n+            Node::Variant(v) => v.ident.name,\n             Node::Field(f) => f.ident.name,\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n@@ -939,7 +961,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n             Some(Node::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(Node::ImplItem(ref ii)) => Some(&ii.attrs[..]),\n-            Some(Node::Variant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(Node::Variant(ref v)) => Some(&v.attrs[..]),\n             Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n             Some(Node::Expr(ref e)) => Some(&*e.attrs),\n             Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n@@ -1133,7 +1155,7 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n \n impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n-impl Named for VariantKind { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Variant { fn name(&self) -> Name { self.ident.name } }\n impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n@@ -1310,7 +1332,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         }\n         Some(Node::Variant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n-                    variant.node.ident,\n+                    variant.ident,\n                     path_str(), id_str)\n         }\n         Some(Node::Field(ref field)) => {"}, {"sha": "e5ada1fb9aec4b5df22ee3f76bdb654026242c8f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -23,7 +23,6 @@ use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n-use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n@@ -202,7 +201,7 @@ impl ParamName {\n         match *self {\n             ParamName::Plain(ident) => ident,\n             ParamName::Fresh(_) |\n-            ParamName::Error => Ident::with_empty_ctxt(kw::UnderscoreLifetime),\n+            ParamName::Error => Ident::with_dummy_span(kw::UnderscoreLifetime),\n         }\n     }\n \n@@ -237,8 +236,8 @@ impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             LifetimeName::Implicit | LifetimeName::Error => Ident::invalid(),\n-            LifetimeName::Underscore => Ident::with_empty_ctxt(kw::UnderscoreLifetime),\n-            LifetimeName::Static => Ident::with_empty_ctxt(kw::StaticLifetime),\n+            LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n+            LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n             LifetimeName::Param(param_name) => param_name.ident(),\n         }\n     }\n@@ -877,7 +876,7 @@ impl Pat {\n         match self.node {\n             PatKind::Binding(.., Some(ref p)) => p.walk_(it),\n             PatKind::Struct(_, ref fields, _) => {\n-                fields.iter().all(|field| field.node.pat.walk_(it))\n+                fields.iter().all(|field| field.pat.walk_(it))\n             }\n             PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk_(it))\n@@ -923,6 +922,7 @@ pub struct FieldPat {\n     /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n+    pub span: Span,\n }\n \n /// Explicit binding annotations given in the HIR for a binding. Note\n@@ -968,7 +968,7 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n+    Struct(QPath, HirVec<FieldPat>, bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n@@ -1541,7 +1541,7 @@ pub enum ExprKind {\n     Match(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n-    /// The final span is the span of the argument block `|...|`.\n+    /// The `Span` is the argument block `|...|`.\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<GeneratorMovability>`.\n@@ -2003,8 +2003,6 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n-    #[stable_hasher(ignore)] // This is used for error reporting\n-    pub ctxt: SyntaxContext,\n }\n \n /// Represents an argument in a function header.\n@@ -2183,8 +2181,6 @@ pub struct ForeignMod {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n-    #[stable_hasher(ignore)] // This is used for error reporting\n-    pub ctxt: SyntaxContext,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2193,7 +2189,7 @@ pub struct EnumDef {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct VariantKind {\n+pub struct Variant {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -2205,10 +2201,10 @@ pub struct VariantKind {\n     pub data: VariantData,\n     /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n+    /// Span\n+    pub span: Span\n }\n \n-pub type Variant = Spanned<VariantKind>;\n-\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`."}, {"sha": "2fd683ed83c54917def6d4ab97fad3f14c34537f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -737,7 +737,7 @@ impl<'a> State<'a> {\n         for v in variants {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.node.attrs);\n+            self.print_outer_attributes(&v.attrs);\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n@@ -829,8 +829,8 @@ impl<'a> State<'a> {\n     pub fn print_variant(&mut self, v: &hir::Variant) {\n         self.head(\"\");\n         let generics = hir::Generics::empty();\n-        self.print_struct(&v.node.data, &generics, v.node.ident.name, v.span, false);\n-        if let Some(ref d) = v.node.disr_expr {\n+        self.print_struct(&v.data, &generics, v.ident.name, v.span, false);\n+        if let Some(ref d) = v.disr_expr {\n             self.s.space();\n             self.word_space(\"=\");\n             self.print_anon_const(d);\n@@ -1457,7 +1457,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) {\n-        self.print_ident(ast::Ident::with_empty_ctxt(name))\n+        self.print_ident(ast::Ident::with_dummy_span(name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) {\n@@ -1670,14 +1670,14 @@ impl<'a> State<'a> {\n                                    &fields[..],\n                                    |s, f| {\n                                        s.cbox(INDENT_UNIT);\n-                                       if !f.node.is_shorthand {\n-                                           s.print_ident(f.node.ident);\n+                                       if !f.is_shorthand {\n+                                           s.print_ident(f.ident);\n                                            s.word_nbsp(\":\");\n                                        }\n-                                       s.print_pat(&f.node.pat);\n+                                       s.print_pat(&f.pat);\n                                        s.end()\n                                    },\n-                                   |f| f.node.pat.span);\n+                                   |f| f.pat.span);\n                 if etc {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");"}, {"sha": "e77faea1e4c5855989ae6bf152c21b0af25510a3", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -350,7 +350,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         let line_col_len = col | line | len;\n         std_hash::Hash::hash(&line_col_len, hasher);\n \n-        if span.ctxt == SyntaxContext::empty() {\n+        if span.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPANSION.hash_stable(hcx, hasher);\n         } else {\n             TAG_EXPANSION.hash_stable(hcx, hasher);\n@@ -370,7 +370,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n                 }\n \n                 let mut hasher = StableHasher::new();\n-                expn_id.expn_info().hash_stable(hcx, &mut hasher);\n+                expn_id.expn_data().hash_stable(hcx, &mut hasher);\n                 let sub_hash: Fingerprint = hasher.finish();\n                 let sub_hash = sub_hash.to_smaller_hash();\n                 cache.borrow_mut().insert(expn_id, sub_hash);"}, {"sha": "60b338010b0db8a729117a2a1365968aad45c16b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -153,8 +153,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     }\n }\n \n-impl_stable_hash_for_spanned!(hir::FieldPat);\n-\n impl_stable_hash_for_spanned!(hir::BinOpKind);\n \n impl_stable_hash_for!(struct hir::Stmt {\n@@ -187,8 +185,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n \n impl_stable_hash_for_spanned!(usize);\n \n-impl_stable_hash_for_spanned!(ast::Ident);\n-\n impl_stable_hash_for!(struct ast::Ident {\n     name,\n     span,\n@@ -304,7 +300,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     }\n }\n \n-impl_stable_hash_for_spanned!(hir::VariantKind);\n+impl_stable_hash_for_spanned!(hir::Variant);\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {"}, {"sha": "7003f71c8baa06ae1e02e8f3946b9d4d141d6e80", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -397,9 +397,10 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::Transparency {\n     Opaque,\n });\n \n-impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n-    call_site,\n+impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     kind,\n+    parent -> _,\n+    call_site,\n     def_site,\n     default_transparency,\n     allow_internal_unstable,"}, {"sha": "3267505708b8100dfcee4e45cf7fc2423828e423", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 161, "deletions": 51, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,13 +1,13 @@\n use crate::hir::def::Namespace;\n-use crate::hir::{self, Local, Pat, Body, HirId};\n+use crate::hir::{self, Body, FunctionRetTy, Expr, ExprKind, HirId, Local, Pat};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::ty::{self, Ty, Infer, TyVar};\n use crate::ty::print::Print;\n use syntax::source_map::DesugaringKind;\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use errors::{Applicability, DiagnosticBuilder};\n \n struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -16,9 +16,26 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     found_local_pattern: Option<&'tcx Pat>,\n     found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n+    found_closure: Option<&'tcx ExprKind>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        target_ty: Ty<'tcx>,\n+        hir_map: &'a hir::map::Map<'tcx>,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            target_ty,\n+            hir_map,\n+            found_local_pattern: None,\n+            found_arg_pattern: None,\n+            found_ty: None,\n+            found_closure: None,\n+        }\n+    }\n+\n     fn node_matches_type(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_type_opt(hir_id)\n@@ -72,6 +89,60 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_body(self, body);\n     }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n+            &expr.node,\n+            self.node_matches_type(expr.hir_id),\n+        ) {\n+            self.found_closure = Some(&expr.node);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// Suggest giving an appropriate return type to a closure expression.\n+fn closure_return_type_suggestion(\n+    span: Span,\n+    err: &mut DiagnosticBuilder<'_>,\n+    output: &FunctionRetTy,\n+    body: &Body,\n+    name: &str,\n+    ret: &str,\n+) {\n+    let (arrow, post) = match output {\n+        FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+        _ => (\"\", \"\"),\n+    };\n+    let suggestion = match body.value.node {\n+        ExprKind::Block(..) => {\n+            vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n+        }\n+        _ => {\n+            vec![\n+                (output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n+                (body.value.span.shrink_to_hi(), \" }\".to_string()),\n+            ]\n+        }\n+    };\n+    err.multipart_suggestion(\n+        \"give this closure an explicit return type without `_` placeholders\",\n+        suggestion,\n+        Applicability::HasPlaceholders,\n+    );\n+    err.span_label(span, InferCtxt::missing_type_msg(&name));\n+}\n+\n+/// Given a closure signature, return a `String` containing a list of all its argument types.\n+fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n+    fn_sig.inputs()\n+        .skip_binder()\n+        .iter()\n+        .next()\n+        .map(|args| args.tuple_fields()\n+            .map(|arg| arg.to_string())\n+            .collect::<Vec<_>>().join(\", \"))\n+        .unwrap_or_default()\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -106,16 +177,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n-        let mut err_span = span;\n-\n-        let mut local_visitor = FindLocalByTypeVisitor {\n-            infcx: &self,\n-            target_ty: ty,\n-            hir_map: &self.tcx.hir(),\n-            found_local_pattern: None,\n-            found_arg_pattern: None,\n-            found_ty: None,\n-        };\n+        let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -136,6 +198,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n+        let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n+            pattern.span\n+        } else {\n+            span\n+        };\n+\n+        let is_named_and_not_impl_trait = |ty: Ty<'_>| {\n+            &ty.to_string() != \"_\" &&\n+                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n+                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n+        };\n+\n+        let ty_msg = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let args = closure_args(&fn_sig);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+                format!(\" for the closure `fn({}) -> {}`\", args, ret)\n+            }\n+            Some(ty) if is_named_and_not_impl_trait(ty) => {\n+                let ty = ty_to_string(ty);\n+                format!(\" for `{}`\", ty)\n+            }\n+            _ => String::new(),\n+        };\n \n         // When `name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n@@ -150,27 +237,58 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n         //   |         the type parameter `E` is specified\n         // ```\n-        let (ty_msg, suffix) = match &local_visitor.found_ty {\n-            Some(ty) if &ty.to_string() != \"_\" && name == \"_\" => {\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            err_span,\n+            E0282,\n+            \"type annotations needed{}\",\n+            ty_msg,\n+        );\n+\n+        let suffix = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+\n+                if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {\n+                    if let Some(body) = self.tcx.hir().krate().bodies.get(body_id) {\n+                        closure_return_type_suggestion(\n+                            span,\n+                            &mut err,\n+                            &decl.output,\n+                            &body,\n+                            &name,\n+                            &ret,\n+                        );\n+                        // We don't want to give the other suggestions when the problem is the\n+                        // closure return type.\n+                        return err;\n+                    }\n+                }\n+\n+                // This shouldn't be reachable, but just in case we leave a reasonable fallback.\n+                let args = closure_args(&fn_sig);\n+                // This suggestion is incomplete, as the user will get further type inference\n+                // errors due to the `_` placeholders and the introduction of `Box`, but it does\n+                // nudge them in the right direction.\n+                format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n+            }\n+            Some(ty) if is_named_and_not_impl_trait(ty) && name == \"_\" => {\n                 let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\"the explicit type `{}`, with the type parameters specified\", ty))\n+                format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            Some(ty) if &ty.to_string() != \"_\" && ty.to_string() != name => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != name => {\n                 let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\n-                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n+                format!(\n+                    \"the explicit type `{}`, where the type parameter `{}` is specified\",\n                     ty,\n                     name,\n-                 ))\n+                )\n             }\n-            _ => (String::new(), \"a type\".to_owned()),\n+            _ => \"a type\".to_string(),\n         };\n-        let mut labels = vec![(span, InferCtxt::missing_type_msg(&name))];\n \n         if let Some(pattern) = local_visitor.found_arg_pattern {\n-            err_span = pattern.span;\n             // We don't want to show the default label for closures.\n             //\n             // So, before clearing, the output would look something like this:\n@@ -187,39 +305,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             //          ^ consider giving this closure parameter the type `[_; 0]`\n             //            with the type parameter `_` specified\n             // ```\n-            labels.clear();\n-            labels.push((\n+            err.span_label(\n                 pattern.span,\n                 format!(\"consider giving this closure parameter {}\", suffix),\n-            ));\n+            );\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n-            if let Some(simple_ident) = pattern.simple_ident() {\n+            let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n-                    None => labels.push((\n-                        pattern.span,\n-                        format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    )),\n-                    Some(DesugaringKind::ForLoop) => labels.push((\n-                        pattern.span,\n-                        \"the element type for this iterator is not specified\".to_owned(),\n-                    )),\n-                    _ => {}\n+                    None => {\n+                        format!(\"consider giving `{}` {}\", simple_ident, suffix)\n+                    }\n+                    Some(DesugaringKind::ForLoop) => {\n+                        \"the element type for this iterator is not specified\".to_string()\n+                    }\n+                    _ => format!(\"this needs {}\", suffix),\n                 }\n             } else {\n-                labels.push((pattern.span, format!(\"consider giving this pattern {}\", suffix)));\n-            }\n-        };\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            err_span,\n-            E0282,\n-            \"type annotations needed{}\",\n-            ty_msg,\n-        );\n-\n-        for (target_span, label_message) in labels {\n-            err.span_label(target_span, label_message);\n+                format!(\"consider giving this pattern {}\", suffix)\n+            };\n+            err.span_label(pattern.span, msg);\n+        }\n+        if !err.span.span_labels().iter().any(|span_label| {\n+                span_label.label.is_some() && span_label.span == span\n+            }) && local_visitor.found_arg_pattern.is_none()\n+        { // Avoid multiple labels pointing at `span`.\n+            err.span_label(span, InferCtxt::missing_type_msg(&name));\n         }\n \n         err"}, {"sha": "6801fa8d8dbe5b0099ebc53e04fd73ec3ba4406d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1060,7 +1060,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.id, &v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n             lint_callback!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             lint_callback!(cx, check_variant_post, v, g);\n@@ -1236,7 +1236,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(item_id, &v.node.attrs, |cx| {\n+        self.with_lint_attrs(item_id, &v.attrs, |cx| {\n             run_early_pass!(cx, check_variant, v, g);\n             ast_visit::walk_variant(cx, v, g, item_id);\n             run_early_pass!(cx, check_variant_post, v, g);\n@@ -1345,7 +1345,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         // part of `walk_mac`, and (b) we should be calling\n         // `visit_path`, *but* that would require a `NodeId`, and I\n         // want to get #53686 fixed quickly. -nmatsakis\n-        ast_visit::walk_path(self, &mac.node.path);\n+        ast_visit::walk_path(self, &mac.path);\n \n         run_early_pass!(self, check_mac, mac);\n     }\n@@ -1355,7 +1355,7 @@ struct LateLintPassObjects<'a> {\n     lints: &'a mut [LateLintPassObject],\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::lint_pass_impl_without_macro))]\n+#[allow(rustc::lint_pass_impl_without_macro)]\n impl LintPass for LateLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()\n@@ -1525,7 +1525,7 @@ struct EarlyLintPassObjects<'a> {\n     lints: &'a mut [EarlyLintPassObject],\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::lint_pass_impl_without_macro))]\n+#[allow(rustc::lint_pass_impl_without_macro)]\n impl LintPass for EarlyLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()"}, {"sha": "be73b305e2c50bd56d68f1c8b2cf9a1143e0556c", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -9,7 +9,6 @@ use errors::Applicability;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Ident, Item, ItemKind};\n use syntax::symbol::{sym, Symbol};\n-use syntax_pos::ExpnInfo;\n \n declare_tool_lint! {\n     pub rustc::DEFAULT_HASH_TYPES,\n@@ -23,7 +22,7 @@ pub struct DefaultHashTypes {\n \n impl DefaultHashTypes {\n     // we are allowed to use `HashMap` and `HashSet` as identifiers for implementing the lint itself\n-    #[cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n+    #[allow(rustc::default_hash_types)]\n     pub fn new() -> Self {\n         let mut map = FxHashMap::default();\n         map.insert(sym::HashMap, sym::FxHashMap);\n@@ -108,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                             .help(\"try using `Ty` instead\")\n                             .emit();\n                         } else {\n-                            if ty.span.ctxt().outer_expn_info().is_some() {\n+                            if ty.span.from_expansion() {\n                                 return;\n                             }\n                             if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n@@ -228,30 +227,20 @@ impl EarlyLintPass for LintPassImpl {\n         if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.node {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n-                    match &lint_pass.path.span.ctxt().outer_expn_info() {\n-                        Some(info) if is_lint_pass_expansion(info) => {}\n-                        _ => {\n-                            cx.struct_span_lint(\n-                                LINT_PASS_IMPL_WITHOUT_MACRO,\n-                                lint_pass.path.span,\n-                                \"implementing `LintPass` by hand\",\n-                            )\n-                            .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n-                            .emit();\n-                        }\n+                    let expn_data = lint_pass.path.span.ctxt().outer_expn_data();\n+                    let call_site = expn_data.call_site;\n+                    if expn_data.kind.descr() != sym::impl_lint_pass &&\n+                       call_site.ctxt().outer_expn_data().kind.descr() != sym::declare_lint_pass {\n+                        cx.struct_span_lint(\n+                            LINT_PASS_IMPL_WITHOUT_MACRO,\n+                            lint_pass.path.span,\n+                            \"implementing `LintPass` by hand\",\n+                        )\n+                        .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n+                        .emit();\n                     }\n                 }\n             }\n         }\n     }\n }\n-\n-fn is_lint_pass_expansion(expn_info: &ExpnInfo) -> bool {\n-    if expn_info.kind.descr() == sym::impl_lint_pass {\n-        true\n-    } else if let Some(info) = expn_info.call_site.ctxt().outer_expn_info() {\n-        info.kind.descr() == sym::declare_lint_pass\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "2b58627cdea563544c5d24a958ea88dd74a0aa28", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -846,7 +846,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.id, &v.node.attrs, |builder| {\n+        self.with_lint_attrs(v.id, &v.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }\n@@ -885,21 +885,16 @@ pub fn provide(providers: &mut Providers<'_>) {\n /// This is used to test whether a lint should not even begin to figure out whether it should\n /// be reported on the current node.\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n-    let info = match span.ctxt().outer_expn_info() {\n-        Some(info) => info,\n-        // no ExpnInfo means this span doesn't come from a macro\n-        None => return false,\n-    };\n-\n-    match info.kind {\n+    let expn_data = span.ctxt().outer_expn_data();\n+    match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n         ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n-            if info.def_site.is_dummy() {\n+            if expn_data.def_site.is_dummy() {\n                 // dummy span for the def_site means it's an external macro\n                 return true;\n             }\n-            match sess.source_map().span_to_snippet(info.def_site) {\n+            match sess.source_map().span_to_snippet(expn_data.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n                 // no snippet = external macro or compiler-builtin expansion\n                 Err(_) => true,\n@@ -911,10 +906,8 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n \n /// Returns whether `span` originates in a derive macro's expansion\n pub fn in_derive_expansion(span: Span) -> bool {\n-    if let Some(info) = span.ctxt().outer_expn_info() {\n-        if let ExpnKind::Macro(MacroKind::Derive, _) = info.kind {\n-            return true;\n-        }\n+    if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_data().kind {\n+        return true;\n     }\n     false\n }"}, {"sha": "de84fcd7160dffd729e8a27f0cb0307006e21ad3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -178,8 +178,7 @@ pub trait MetadataLoader {\n                           -> Result<MetadataRef, String>;\n }\n \n-/// A store of Rust crates, through with their metadata\n-/// can be accessed.\n+/// A store of Rust crates, through which their metadata can be accessed.\n ///\n /// Note that this trait should probably not be expanding today. All new\n /// functionality should be driven through queries instead!"}, {"sha": "8ce8bb52566c6118a7b7adcf281300ba63200589", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -17,8 +17,7 @@ use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::fx::FxHashMap;\n \n-use syntax::{ast, source_map};\n-use syntax::attr;\n+use syntax::{ast, attr};\n use syntax::symbol::sym;\n use syntax_pos;\n \n@@ -119,17 +118,16 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, res: Res,\n-                                  pats: &[source_map::Spanned<hir::FieldPat>]) {\n+    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, res: Res, pats: &[hir::FieldPat]) {\n         let variant = match self.tables.node_type(lhs.hir_id).sty {\n             ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n-            if let PatKind::Wild = pat.node.pat.node {\n+            if let PatKind::Wild = pat.pat.node {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.node.hir_id, self.tables);\n+            let index = self.tcx.field_index(pat.hir_id, self.tables);\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -366,12 +364,12 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n         match item.node {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n                 if allow_dead_code {\n-                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n+                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.id));\n                 }\n \n                 for variant in &enum_def.variants {\n-                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n-                        self.struct_constructors.insert(ctor_hir_id, variant.node.id);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n+                        self.struct_constructors.insert(ctor_hir_id, variant.id);\n                     }\n                 }\n             }\n@@ -497,7 +495,7 @@ impl DeadVisitor<'tcx> {\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id, &field.attrs)\n     }\n \n-    fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n+    fn should_warn_about_variant(&mut self, variant: &hir::Variant) -> bool {\n         !self.symbol_is_live(variant.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n                                                  variant.id,\n@@ -596,8 +594,8 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                      variant: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n-        if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.id, variant.span, variant.node.ident.name,\n+        if self.should_warn_about_variant(&variant) {\n+            self.warn_dead_code(variant.id, variant.span, variant.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);"}, {"sha": "9c9e8c0bca3b8f10a2e9d55a02a02686f98ccc05", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -418,8 +418,8 @@ fn add_from_pat<'tcx>(ir: &mut IrMaps<'tcx>, pat: &P<hir::Pat>) {\n             }\n             Struct(_, ref fields, _) => {\n                 for field in fields {\n-                    if field.node.is_shorthand {\n-                        shorthand_field_ids.insert(field.node.pat.hir_id);\n+                    if field.is_shorthand {\n+                        shorthand_field_ids.insert(field.pat.hir_id);\n                     }\n                 }\n             }"}, {"sha": "a55803e255bf6ee8e9ead4a77cad770fd4db36ca", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1282,11 +1282,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 };\n \n                 for fp in field_pats {\n-                    let field_ty = self.pat_ty_adjusted(&fp.node.pat)?; // see (*2)\n-                    let f_index = self.tcx.field_index(fp.node.hir_id, self.tables);\n+                    let field_ty = self.pat_ty_adjusted(&fp.pat)?; // see (*2)\n+                    let f_index = self.tcx.field_index(fp.hir_id, self.tables);\n                     let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n-                                                           fp.node.ident, field_ty));\n-                    self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n+                                                           fp.ident, field_ty));\n+                    self.cat_pattern_(cmt_field, &fp.pat, op)?;\n                 }\n             }\n "}, {"sha": "c2bcd46216324b24c0f0992ec36494b5d829b0d4", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -33,6 +33,9 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAt\n     }\n \n     match item.node {\n+        hir::ItemKind::Fn(_, header, ..) if header.is_const() => {\n+            return true;\n+        }\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n@@ -52,6 +55,11 @@ fn method_might_be_inlined(\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n+    if let hir::ImplItemKind::Method(method_sig, _) = &impl_item.node {\n+        if method_sig.header.is_const() {\n+            return true\n+        }\n+    }\n     if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src) {\n         match tcx.hir().find(impl_hir_id) {\n             Some(Node::Item(item)) =>"}, {"sha": "3d100d2fbf8331c007bd82e0fd86e4f4cff22b68", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1207,7 +1207,7 @@ fn resolve_local<'tcx>(\n             PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n-                field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))\n+                field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n             }\n \n             PatKind::Slice(ref pats1, ref pats2, ref pats3) => {"}, {"sha": "d02259bf3010b48bd002bbc38555424878b79195", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -290,10 +290,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.annotate(var.node.id, &var.node.attrs, var.span, AnnotationKind::Required,\n+        self.annotate(var.id, &var.attrs, var.span, AnnotationKind::Required,\n             |v| {\n-                if let Some(ctor_hir_id) = var.node.data.ctor_hir_id() {\n-                    v.annotate(ctor_hir_id, &var.node.attrs, var.span, AnnotationKind::Required,\n+                if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n+                    v.annotate(ctor_hir_id, &var.attrs, var.span, AnnotationKind::Required,\n                                |_| {});\n                 }\n \n@@ -372,7 +372,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.check_missing_stability(var.node.id, var.span, \"variant\");\n+        self.check_missing_stability(var.id, var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n "}, {"sha": "b55e6bc54bc5ff25b0576695a41c82ac3afed240", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -189,8 +189,11 @@ impl<'tcx, Tag> Pointer<Tag> {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }\n \n+    /// Test if the pointer is \"inbounds\" of an allocation of the given size.\n+    /// A pointer is \"inbounds\" even if its offset is equal to the size; this is\n+    /// a \"one-past-the-end\" pointer.\n     #[inline(always)]\n-    pub fn check_in_alloc(\n+    pub fn check_inbounds_alloc(\n         self,\n         allocation_size: Size,\n         msg: CheckInAllocMsg,"}, {"sha": "11701a66377442f60f640bf1e01556df179c7ebd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -2197,7 +2197,6 @@ impl<'tcx> Operand<'tcx> {\n         let ty = tcx.type_of(def_id).subst(tcx, substs);\n         Operand::Constant(box Constant {\n             span,\n-            ty,\n             user_ty: None,\n             literal: ty::Const::zero_sized(tcx, ty),\n         })\n@@ -2476,7 +2475,6 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n-    pub ty: Ty<'tcx>,\n \n     /// Optional user-given type: for something like\n     /// `collect::<Vec<_>>`, this would be present and would\n@@ -3385,12 +3383,11 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Constant {\n             span: self.span.clone(),\n-            ty: self.ty.fold_with(folder),\n             user_ty: self.user_ty.fold_with(folder),\n             literal: self.literal.fold_with(folder),\n         }\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor) || self.literal.visit_with(visitor)\n+        self.literal.visit_with(visitor)\n     }\n }"}, {"sha": "e9f7636ba85ae72b92bd730e0cfd51c1d9c22058", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -252,7 +252,7 @@ impl<'tcx> Operand<'tcx> {\n         match self {\n             &Operand::Copy(ref l) |\n             &Operand::Move(ref l) => l.ty(local_decls, tcx).ty,\n-            &Operand::Constant(ref c) => c.ty,\n+            &Operand::Constant(ref c) => c.literal.ty,\n         }\n     }\n }"}, {"sha": "2d16e7bcc83716aae59408ad7eb39434aec7e84b", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -782,13 +782,11 @@ macro_rules! make_mir_visitor {\n                               location: Location) {\n                 let Constant {\n                     span,\n-                    ty,\n                     user_ty,\n                     literal,\n                 } = constant;\n \n                 self.visit_span(span);\n-                self.visit_ty(ty, TyContext::Location(location));\n                 drop(user_ty); // no visit method for this\n                 self.visit_const(literal, location);\n             }"}, {"sha": "8e3b910e0da3a89a0b8c8c56baa192f4adbc4d63", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -395,7 +395,7 @@ top_level_options!(\n         output_types: OutputTypes [TRACKED],\n         search_paths: Vec<SearchPath> [UNTRACKED],\n         libs: Vec<(String, Option<String>, Option<cstore::NativeLibraryKind>)> [TRACKED],\n-        maybe_sysroot: Option<PathBuf> [TRACKED],\n+        maybe_sysroot: Option<PathBuf> [UNTRACKED],\n \n         target_triple: TargetTriple [TRACKED],\n "}, {"sha": "ba92e851141a655cd929964c0a9d8b29096f39b8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -36,7 +36,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnKind};\n+use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n@@ -61,9 +61,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // We want to ignore desugarings here: spans are equivalent even\n             // if one is the result of a desugaring and the other is not.\n             let mut span = error.obligation.cause.span;\n-            if let Some(ExpnInfo { kind: ExpnKind::Desugaring(_), def_site, .. })\n-                    = span.ctxt().outer_expn_info() {\n-                span = def_site;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n             }\n \n             error_map.entry(span).or_default().push("}, {"sha": "72df45df92314247f82063c386da1010c980301e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1417,7 +1417,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n                 projection_ty: ty::ProjectionTy::from_ref_and_name(\n                     tcx,\n                     trait_ref,\n-                    Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n+                    Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 ),\n                 ty: ret_type\n             }"}, {"sha": "1ddc6780aca890dadf3a07c0b77620aa1c663f84", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -27,7 +27,7 @@ pub trait EncodableWithShorthand: Clone + Eq + Hash {\n     fn variant(&self) -> &Self::Variant;\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n@@ -160,7 +160,7 @@ where\n     Ok(decoder.map_encoded_cnum_to_current(cnum))\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#[allow(rustc::usage_of_ty_tykind)]\n #[inline]\n pub fn decode_ty<D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n where"}, {"sha": "d504ba4dfe086d490820686758623f539ff1b239", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -130,7 +130,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     }\n \n     /// Intern a type\n-    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+    #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n     fn intern_ty(&self,\n         st: TyKind<'tcx>\n@@ -2076,7 +2076,7 @@ impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     }\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n         &self.0.sty\n@@ -2291,7 +2291,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(converted_sig)\n     }\n \n-    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+    #[allow(rustc::usage_of_ty_tykind)]\n     #[inline]\n     pub fn mk_ty(&self, st: TyKind<'tcx>) -> Ty<'tcx> {\n         self.interners.intern_ty(st)"}, {"sha": "9119505acd1743d9a7cc9bd353e2680649f6f8ba", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -18,7 +18,7 @@ impl FlagComputation {\n         }\n     }\n \n-    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+    #[allow(rustc::usage_of_ty_tykind)]\n     pub fn for_sty(st: &ty::TyKind<'_>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_sty(st);\n@@ -62,7 +62,7 @@ impl FlagComputation {\n         } // otherwise, this binder captures nothing\n     }\n \n-    #[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+    #[allow(rustc::usage_of_ty_tykind)]\n     fn add_sty(&mut self, st: &ty::TyKind<'_>) {\n         match st {\n             &ty::Bool |"}, {"sha": "a8ff36a3946573c4b6c5f3b18b687d6408be5e3a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -483,7 +483,7 @@ bitflags! {\n     }\n }\n \n-#[cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#[allow(rustc::usage_of_ty_tykind)]\n pub struct TyS<'tcx> {\n     pub sty: TyKind<'tcx>,\n     pub flags: TypeFlags,"}, {"sha": "8bf01970eb592f13464fd43efc6a3f8c6e788ee1", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -23,16 +23,16 @@ use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnInfo};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n-const TAG_NO_EXPANSION_INFO: u8 = 0;\n-const TAG_EXPANSION_INFO_SHORTHAND: u8 = 1;\n-const TAG_EXPANSION_INFO_INLINE: u8 = 2;\n+const TAG_NO_EXPN_DATA: u8 = 0;\n+const TAG_EXPN_DATA_SHORTHAND: u8 = 1;\n+const TAG_EXPN_DATA_INLINE: u8 = 2;\n \n const TAG_VALID_SPAN: u8 = 0;\n const TAG_INVALID_SPAN: u8 = 1;\n@@ -58,7 +58,7 @@ pub struct OnDiskCache<'sess> {\n \n     // These two fields caches that are populated lazily during decoding.\n     file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n-    synthetic_expansion_infos: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    synthetic_syntax_contexts: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n     // `serialized_data`.\n@@ -135,7 +135,7 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: Default::default(),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n-            synthetic_expansion_infos: Default::default(),\n+            synthetic_syntax_contexts: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n         }\n     }\n@@ -151,7 +151,7 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: Default::default(),\n             query_result_index: Default::default(),\n             prev_diagnostics_index: Default::default(),\n-            synthetic_expansion_infos: Default::default(),\n+            synthetic_syntax_contexts: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n         }\n     }\n@@ -185,7 +185,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 encoder,\n                 type_shorthands: Default::default(),\n                 predicate_shorthands: Default::default(),\n-                expn_info_shorthands: Default::default(),\n+                expn_data_shorthands: Default::default(),\n                 interpret_allocs: Default::default(),\n                 interpret_allocs_inverse: Vec::new(),\n                 source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n@@ -383,7 +383,7 @@ impl<'sess> OnDiskCache<'sess> {\n             cnum_map: self.cnum_map.get(),\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_expansion_infos: &self.synthetic_expansion_infos,\n+            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n@@ -440,7 +440,7 @@ struct CacheDecoder<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n     cnum_map: &'a IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    synthetic_syntax_contexts: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, StableSourceFileId>,\n     alloc_decoding_session: AllocDecodingSession<'a>,\n@@ -586,37 +586,37 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n-        let expn_info_tag = u8::decode(self)?;\n+        let expn_data_tag = u8::decode(self)?;\n \n-        // FIXME(mw): This method does not restore `InternalExpnData::parent` or\n+        // FIXME(mw): This method does not restore `ExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that.\n-        let location = || Span::new(lo, hi, SyntaxContext::empty());\n-        let recover_from_expn_info = |this: &Self, expn_info, pos| {\n-            let span = location().fresh_expansion(ExpnId::root(), expn_info);\n-            this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n+        let location = || Span::with_root_ctxt(lo, hi);\n+        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n+            let span = location().fresh_expansion(expn_data);\n+            this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n-        Ok(match expn_info_tag {\n-            TAG_NO_EXPANSION_INFO => {\n+        Ok(match expn_data_tag {\n+            TAG_NO_EXPN_DATA => {\n                 location()\n             }\n-            TAG_EXPANSION_INFO_INLINE => {\n-                let expn_info = Decodable::decode(self)?;\n-                recover_from_expn_info(\n-                    self, expn_info, AbsoluteBytePos::new(self.opaque.position())\n+            TAG_EXPN_DATA_INLINE => {\n+                let expn_data = Decodable::decode(self)?;\n+                recover_from_expn_data(\n+                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n-            TAG_EXPANSION_INFO_SHORTHAND => {\n+            TAG_EXPN_DATA_SHORTHAND => {\n                 let pos = AbsoluteBytePos::decode(self)?;\n-                let cached_ctxt = self.synthetic_expansion_infos.borrow().get(&pos).cloned();\n+                let cached_ctxt = self.synthetic_syntax_contexts.borrow().get(&pos).cloned();\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_info =\n-                        self.with_position(pos.to_usize(), |this| ExpnInfo::decode(this))?;\n-                    recover_from_expn_info(self, expn_info, pos)\n+                    let expn_data =\n+                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, pos)\n                 }\n             }\n             _ => {\n@@ -725,7 +725,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    expn_info_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n+    expn_data_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,\n@@ -816,22 +816,18 @@ where\n         col_lo.encode(self)?;\n         len.encode(self)?;\n \n-        if span_data.ctxt == SyntaxContext::empty() {\n-            TAG_NO_EXPANSION_INFO.encode(self)\n+        if span_data.ctxt == SyntaxContext::root() {\n+            TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_info) = span_data.ctxt.outer_expn_with_info();\n-            if let Some(expn_info) = expn_info {\n-                if let Some(pos) = self.expn_info_shorthands.get(&expn_id).cloned() {\n-                    TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n-                    pos.encode(self)\n-                } else {\n-                    TAG_EXPANSION_INFO_INLINE.encode(self)?;\n-                    let pos = AbsoluteBytePos::new(self.position());\n-                    self.expn_info_shorthands.insert(expn_id, pos);\n-                    expn_info.encode(self)\n-                }\n+            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n+                TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n+                pos.encode(self)\n             } else {\n-                TAG_NO_EXPANSION_INFO.encode(self)\n+                TAG_EXPN_DATA_INLINE.encode(self)?;\n+                let pos = AbsoluteBytePos::new(self.position());\n+                self.expn_data_shorthands.insert(expn_id, pos);\n+                expn_data.encode(self)\n             }\n         }\n     }"}, {"sha": "42390c209d60897c5aa7291a85df8be9d59a7b54", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,6 +1,6 @@\n //! This module contains `TyKind` and its major components.\n \n-#![cfg_attr(not(bootstrap), allow(rustc::usage_of_ty_tykind))]\n+#![allow(rustc::usage_of_ty_tykind)]\n \n use crate::hir;\n use crate::hir::def_id::DefId;\n@@ -2068,6 +2068,9 @@ impl<'tcx> TyS<'tcx> {\n             Error => {  // ignore errors (#54954)\n                 ty::Binder::dummy(FnSig::fake())\n             }\n+            Closure(..) => bug!(\n+                \"to get the signature of a closure, use `closure_sig()` not `fn_sig()`\",\n+            ),\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }"}, {"sha": "b68ee2cb44d4bcb9cf02a5bab742f596bff1cdcf", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -6,9 +6,9 @@ use crate::value::Value;\n \n use rustc::hir;\n use rustc_codegen_ssa::traits::*;\n-\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n+use syntax_pos::Span;\n \n use std::ffi::{CStr, CString};\n use libc::{c_uint, c_char};\n@@ -19,7 +19,8 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self,\n         ia: &hir::InlineAsm,\n         outputs: Vec<PlaceRef<'tcx, &'ll Value>>,\n-        mut inputs: Vec<&'ll Value>\n+        mut inputs: Vec<&'ll Value>,\n+        span: Span,\n     ) -> bool {\n         let mut ext_constraints = vec![];\n         let mut output_types = vec![];\n@@ -102,7 +103,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             let kind = llvm::LLVMGetMDKindIDInContext(self.llcx,\n                 key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-            let val: &'ll Value = self.const_i32(ia.ctxt.outer_expn().as_u32() as i32);\n+            let val: &'ll Value = self.const_i32(span.ctxt().outer_expn().as_u32() as i32);\n \n             llvm::LLVMSetMetadata(r, kind,\n                 llvm::LLVMMDNodeInContext(self.llcx, &val, 1));"}, {"sha": "9483ffca448e3daec91450dee6055194490874a4", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -328,7 +328,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             },\n             \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n             \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n-            \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+            \"mul_with_overflow\" | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" |\n             \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" |\n             \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" | \"exact_div\" |\n             \"rotate_left\" | \"rotate_right\" | \"saturating_add\" | \"saturating_sub\" => {\n@@ -398,9 +398,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n                                 return;\n                             },\n-                            \"overflowing_add\" => self.add(args[0].immediate(), args[1].immediate()),\n-                            \"overflowing_sub\" => self.sub(args[0].immediate(), args[1].immediate()),\n-                            \"overflowing_mul\" => self.mul(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_add\" => self.add(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_sub\" => self.sub(args[0].immediate(), args[1].immediate()),\n+                            \"wrapping_mul\" => self.mul(args[0].immediate(), args[1].immediate()),\n                             \"exact_div\" =>\n                                 if signed {\n                                     self.exactsdiv(args[0].immediate(), args[1].immediate())"}, {"sha": "8603d61fb5453f83cf70e0ba9dc10eb33b358978", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -32,6 +32,7 @@ use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio, ExitStatus};\n use std::str;\n use std::env;\n+use std::ffi::OsString;\n \n pub use rustc_codegen_utils::link::*;\n \n@@ -158,6 +159,36 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n         }\n     };\n \n+    // UWP apps have API restrictions enforced during Store submissions.\n+    // To comply with the Windows App Certification Kit,\n+    // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n+    let t = &sess.target.target;\n+    if flavor == LinkerFlavor::Msvc && t.target_vendor == \"uwp\" {\n+        if let Some(ref tool) = msvc_tool {\n+            let original_path = tool.path();\n+            if let Some(ref root_lib_path) = original_path.ancestors().skip(4).next() {\n+                let arch = match t.arch.as_str() {\n+                    \"x86_64\" => Some(\"x64\".to_string()),\n+                    \"x86\" => Some(\"x86\".to_string()),\n+                    \"aarch64\" => Some(\"arm64\".to_string()),\n+                    _ => None,\n+                };\n+                if let Some(ref a) = arch {\n+                    let mut arg = OsString::from(\"/LIBPATH:\");\n+                    arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a.to_string()));\n+                    cmd.arg(&arg);\n+                }\n+                else {\n+                    warn!(\"arch is not supported\");\n+                }\n+            } else {\n+                warn!(\"MSVC root path lib location not found\");\n+            }\n+        } else {\n+            warn!(\"link.exe not found\");\n+        }\n+    }\n+\n     // The compiler's sysroot often has some bundled tools, so add it to the\n     // PATH for the child.\n     let mut new_path = sess.host_filesearch(PathKind::All)\n@@ -1027,6 +1058,7 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n     let t = &sess.target.target;\n \n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+\n     for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n         cmd.add_object(obj);\n     }"}, {"sha": "eec098426239c4550301a065bc5e3ad0d41aac7b", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1775,10 +1775,7 @@ impl SharedEmitterMain {\n                     }\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    match ExpnId::from_u32(cookie).expn_info() {\n-                        Some(ei) => sess.span_err(ei.call_site, &msg),\n-                        None     => sess.err(&msg),\n-                    }\n+                    sess.span_err(ExpnId::from_u32(cookie).expn_data().call_site, &msg)\n                 }\n                 Ok(SharedEmitterMessage::AbortIfErrors) => {\n                     sess.abort_if_errors();"}, {"sha": "e63f1b91dd7d51d48d38b53ae615232d3487b6df", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -221,7 +221,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(ref c),\n                 ref args, ..\n-            } => match c.ty.sty {\n+            } => match c.literal.ty.sty {\n                 ty::FnDef(did, _) => Some((did, args)),\n                 _ => None,\n             },"}, {"sha": "dbce5ce4896a718f72e6ac17fd630262b807712a", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -651,7 +651,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             let (llval, ty) = self.simd_shuffle_indices(\n                                 &bx,\n                                 constant.span,\n-                                constant.ty,\n+                                constant.literal.ty,\n                                 c,\n                             );\n                             return OperandRef {"}, {"sha": "32bcdebc1c46787f963ac9bd67d3c38a9b912275", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -8,7 +8,7 @@ use crate::base;\n use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n \n-use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n+use syntax_pos::{DUMMY_SP, BytePos, Span};\n use syntax::symbol::kw;\n \n use std::iter;\n@@ -120,7 +120,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n-        if source_info.span.ctxt() == NO_EXPANSION ||\n+        if !source_info.span.from_expansion() ||\n            self.cx.sess().opts.debugging_opts.debug_macros {\n             let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n             (scope, source_info.span)"}, {"sha": "254b73da44261bd349b5f639e7c32fec6854c800", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -466,7 +466,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let ty = self.monomorphize(&constant.ty);\n                 self.eval_mir_constant(constant)\n                     .map(|c| OperandRef::from_const(bx, c))\n                     .unwrap_or_else(|err| {\n@@ -481,6 +480,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // the above error (or silence it under some conditions) will not cause UB\n                         bx.abort();\n                         // We've errored, so we don't have to produce working code.\n+                        let ty = self.monomorphize(&constant.literal.ty);\n                         let layout = bx.cx().layout_of(ty);\n                         bx.load_operand(PlaceRef::new_sized(\n                             bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout))),"}, {"sha": "3617f3afaae4148a37224672b6b9374f35e7ec00", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -89,7 +89,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 });\n \n                 if input_vals.len() == asm.inputs.len() {\n-                    let res = bx.codegen_inline_asm(&asm.asm, outputs, input_vals);\n+                    let res = bx.codegen_inline_asm(\n+                        &asm.asm,\n+                        outputs,\n+                        input_vals,\n+                        statement.source_info.span,\n+                    );\n                     if !res {\n                         span_err!(bx.sess(), statement.source_info.span, E0668,\n                                   \"malformed inline assembly\");"}, {"sha": "c9e1ed86e97e0ff37159fc8c746be8bc3e837950", "filename": "src/librustc_codegen_ssa/traits/asm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,6 +1,7 @@\n use super::BackendTypes;\n use crate::mir::place::PlaceRef;\n use rustc::hir::{GlobalAsm, InlineAsm};\n+use syntax_pos::Span;\n \n pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n     /// Take an inline assembly expression and splat it out via LLVM\n@@ -9,6 +10,7 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n         ia: &InlineAsm,\n         outputs: Vec<PlaceRef<'tcx, Self::Value>>,\n         inputs: Vec<Self::Value>,\n+        span: Span,\n     ) -> bool;\n }\n "}, {"sha": "89b50c5daccaeac6d1b81184e1fa94c03b50d8a1", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -13,7 +13,7 @@ test = false\n flate2 = \"1.0\"\n log = \"0.4\"\n punycode = \"0.4.0\"\n-rustc-demangle = \"0.1.15\"\n+rustc-demangle = \"0.1.16\"\n \n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "8d6a1d757e014977420ea636bcf74b73b9e2a139", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -198,10 +198,14 @@ impl SymbolMangler<'tcx> {\n \n         let lifetimes = regions.into_iter().map(|br| {\n             match br {\n-                ty::BrAnon(i) => i + 1,\n+                ty::BrAnon(i) => {\n+                    // FIXME(eddyb) for some reason, `anonymize_late_bound_regions` starts at `1`.\n+                    assert_ne!(i, 0);\n+                    i - 1\n+                },\n                 _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n             }\n-        }).max().unwrap_or(0);\n+        }).max().map_or(0, |max| max + 1);\n \n         self.push_opt_integer_62(\"G\", lifetimes as u64);\n         lifetime_depths.end += lifetimes;\n@@ -297,6 +301,10 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             // Late-bound lifetimes use indices starting at 1,\n             // see `BinderLevel` for more details.\n             ty::ReLateBound(debruijn, ty::BrAnon(i)) => {\n+                // FIXME(eddyb) for some reason, `anonymize_late_bound_regions` starts at `1`.\n+                assert_ne!(i, 0);\n+                let i = i - 1;\n+\n                 let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n                 let depth = binder.lifetime_depths.start + i;\n "}, {"sha": "f7593501959c78c4b8e2bd132fe52b58dda8ab25", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -27,7 +27,7 @@\n \n #![cfg_attr(unix, feature(libc))]\n \n-#![cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n+#![allow(rustc::default_hash_types)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "fdd0773b73ae2066dc0232b47cb2a2a529cd9625", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -678,7 +678,7 @@ impl RustcDefaultCalls {\n \n                     let mut cfgs = sess.parse_sess.config.iter().filter_map(|&(name, ref value)| {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            path: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n+                            path: ast::Path::from_ident(ast::Ident::with_dummy_span(name)),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "255af3122e70cb1430cc1ebf0d32c2886876bfa5", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -148,7 +148,7 @@ impl<'a>  DiagnosticConverter<'a> {\n     /// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n     fn annotation_type_for_level(level: Level) -> AnnotationType {\n         match level {\n-            Level::Bug | Level::Fatal | Level::PhaseFatal | Level::Error => AnnotationType::Error,\n+            Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n             Level::Warning => AnnotationType::Warning,\n             Level::Note => AnnotationType::Note,\n             Level::Help => AnnotationType::Help,"}, {"sha": "3f1b91256c46811c5d3e7653155395ff80c966ef", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -94,7 +94,6 @@ impl Diagnostic {\n         match self.level {\n             Level::Bug |\n             Level::Fatal |\n-            Level::PhaseFatal |\n             Level::Error |\n             Level::FailureNote => {\n                 true\n@@ -120,6 +119,9 @@ impl Diagnostic {\n     }\n \n     /// Adds a span/label to be included in the resulting snippet.\n+    /// This label will be shown together with the original span/label used when creating the\n+    /// diagnostic, *not* a span added by one of the `span_*` methods.\n+    ///\n     /// This is pushed onto the `MultiSpan` that was created when the\n     /// diagnostic was first built. If you don't call this function at\n     /// all, and you just supplied a `Span` to create the diagnostic,\n@@ -196,6 +198,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Prints the span with a note above it.\n     pub fn span_note<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n@@ -209,6 +212,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Prints the span with a warn above it.\n     pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n@@ -222,6 +226,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Prints the span with some help above it.\n     pub fn span_help<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)"}, {"sha": "4018a667bf26497ac9e88c4850538dae7558fe03", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -43,8 +43,7 @@ use syntax_pos::{BytePos,\n                  SourceFile,\n                  FileName,\n                  MultiSpan,\n-                 Span,\n-                 NO_EXPANSION};\n+                 Span};\n \n /// Indicates the confidence in the correctness of a suggestion.\n ///\n@@ -189,7 +188,7 @@ impl CodeSuggestion {\n             // Find the bounding span.\n             let lo = substitution.parts.iter().map(|part| part.span.lo()).min().unwrap();\n             let hi = substitution.parts.iter().map(|part| part.span.hi()).min().unwrap();\n-            let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n+            let bounding_span = Span::with_root_ctxt(lo, hi);\n             let lines = cm.span_to_lines(bounding_span).unwrap();\n             assert!(!lines.lines.is_empty());\n \n@@ -787,9 +786,6 @@ impl Handler {\n pub enum Level {\n     Bug,\n     Fatal,\n-    // An error which while not immediately fatal, should stop the compiler\n-    // progressing beyond the current phase.\n-    PhaseFatal,\n     Error,\n     Warning,\n     Note,\n@@ -808,7 +804,7 @@ impl Level {\n     fn color(self) -> ColorSpec {\n         let mut spec = ColorSpec::new();\n         match self {\n-            Bug | Fatal | PhaseFatal | Error => {\n+            Bug | Fatal | Error => {\n                 spec.set_fg(Some(Color::Red))\n                     .set_intense(true);\n             }\n@@ -833,7 +829,7 @@ impl Level {\n     pub fn to_str(self) -> &'static str {\n         match self {\n             Bug => \"error: internal compiler error\",\n-            Fatal | PhaseFatal | Error => \"error\",\n+            Fatal | Error => \"error\",\n             Warning => \"warning\",\n             Note => \"note\",\n             Help => \"help\","}, {"sha": "82160080a44d4c09bb6ff4f7959a005c169365b5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -42,7 +42,7 @@ use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n use syntax::feature_gate::{self, AttributeGate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n-use syntax_pos::{BytePos, Span, SyntaxContext};\n+use syntax_pos::{BytePos, Span};\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n@@ -78,7 +78,7 @@ impl EarlyLintPass for WhileTrue {\n         if let ast::ExprKind::While(cond, ..) = &e.node {\n             if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n-                    if lit.span.ctxt() == SyntaxContext::empty() {\n+                    if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = cx.sess.source_map().def_span(e.span);\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, msg)\n@@ -164,18 +164,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                                    .expect(\"struct pattern type is not an ADT\")\n                                    .variant_of_res(cx.tables.qpath_res(qpath, pat.hir_id));\n             for fieldpat in field_pats {\n-                if fieldpat.node.is_shorthand {\n+                if fieldpat.is_shorthand {\n                     continue;\n                 }\n-                if fieldpat.span.ctxt().outer_expn_info().is_some() {\n+                if fieldpat.span.from_expansion() {\n                     // Don't lint if this is a macro expansion: macro authors\n                     // shouldn't have to worry about this kind of style issue\n                     // (Issue #49588)\n                     continue;\n                 }\n-                if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Binding(_, _, ident, None) = fieldpat.pat.node {\n                     if cx.tcx.find_field_index(ident, &variant) ==\n-                       Some(cx.tcx.field_index(fieldpat.node.hir_id, cx.tables)) {\n+                       Some(cx.tcx.field_index(fieldpat.hir_id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\", ident));\n@@ -484,8 +484,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n-                                      Some(v.node.id),\n-                                      &v.node.attrs,\n+                                      Some(v.id),\n+                                      &v.attrs,\n                                       v.span,\n                                       \"a variant\");\n     }\n@@ -1012,7 +1012,7 @@ impl UnreachablePub {\n         let mut applicability = Applicability::MachineApplicable;\n         match vis.node {\n             hir::VisibilityKind::Public if !cx.access_levels.is_reachable(id) => {\n-                if span.ctxt().outer_expn_info().is_some() {\n+                if span.from_expansion() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n                 let def_span = cx.tcx.sess.source_map().def_span(span);\n@@ -1493,7 +1493,7 @@ impl EarlyLintPass for KeywordIdents {\n         self.check_tokens(cx, mac_def.stream());\n     }\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::Mac) {\n-        self.check_tokens(cx, mac.node.tts.clone().into());\n+        self.check_tokens(cx, mac.tts.clone().into());\n     }\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);"}, {"sha": "fc416be8eeb504a6a7a582e15f9fe1d0c28d46e6", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -24,6 +24,7 @@ extern crate rustc;\n \n mod error_codes;\n mod nonstandard_style;\n+mod redundant_semicolon;\n pub mod builtin;\n mod types;\n mod unused;\n@@ -55,6 +56,7 @@ use session::Session;\n use lint::LintId;\n use lint::FutureIncompatibleInfo;\n \n+use redundant_semicolon::*;\n use nonstandard_style::*;\n use builtin::*;\n use types::*;\n@@ -98,6 +100,7 @@ macro_rules! early_lint_passes {\n             WhileTrue: WhileTrue,\n             NonAsciiIdents: NonAsciiIdents,\n             IncompleteFeatures: IncompleteFeatures,\n+            RedundantSemicolon: RedundantSemicolon,\n         ]);\n     )\n }"}, {"sha": "acd17f766323419cfe0c8efe6c514d91d62138df", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -147,7 +147,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n     }\n \n     fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_case(cx, \"variant\", &v.node.ident);\n+        self.check_case(cx, \"variant\", &v.ident);\n     }\n \n     fn check_generic_param(&mut self, cx: &EarlyContext<'_>, param: &ast::GenericParam) {"}, {"sha": "7c9df3578b59cd22a168821e94261d6eb8003bb1", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -0,0 +1,52 @@\n+use crate::lint::{EarlyLintPass, LintPass, EarlyContext, LintArray, LintContext};\n+use syntax::ast::{Stmt, StmtKind, ExprKind};\n+use syntax::errors::Applicability;\n+\n+declare_lint! {\n+    pub REDUNDANT_SEMICOLON,\n+    Warn,\n+    \"detects unnecessary trailing semicolons\"\n+}\n+\n+declare_lint_pass!(RedundantSemicolon => [REDUNDANT_SEMICOLON]);\n+\n+impl EarlyLintPass for RedundantSemicolon {\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &Stmt) {\n+        if let StmtKind::Semi(expr) = &stmt.node {\n+            if let ExprKind::Tup(ref v) = &expr.node {\n+                if v.is_empty() {\n+                    // Strings of excess semicolons are encoded as empty tuple expressions\n+                    // during the parsing stage, so we check for empty tuple expressions\n+                    // which span only semicolons\n+                    if let Ok(source_str) = cx.sess().source_map().span_to_snippet(stmt.span) {\n+                        if source_str.chars().all(|c| c == ';') {\n+                            let multiple = (stmt.span.hi() - stmt.span.lo()).0 > 1;\n+                            let msg = if multiple {\n+                                \"unnecessary trailing semicolons\"\n+                            } else {\n+                                \"unnecessary trailing semicolon\"\n+                            };\n+                            let mut err = cx.struct_span_lint(\n+                                REDUNDANT_SEMICOLON,\n+                                stmt.span,\n+                                &msg\n+                            );\n+                            let suggest_msg = if multiple {\n+                                \"remove these semicolons\"\n+                            } else {\n+                                \"remove this semicolon\"\n+                            };\n+                            err.span_suggestion(\n+                                stmt.span,\n+                                &suggest_msg,\n+                                String::new(),\n+                                Applicability::MaybeIncorrect\n+                            );\n+                            err.emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "217e10ab24f552696be203b2c7a45789cdd341e2", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -976,7 +976,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n \n                     debug!(\"- variant `{}` is {} bytes large\",\n-                           variant.node.ident,\n+                           variant.ident,\n                            bytes);\n                     bytes\n                 })"}, {"sha": "90e467713968bd07fdfc31f47ec2239453deebaa", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -517,9 +517,8 @@ impl EarlyLintPass for UnusedParens {\n                 // trigger in situations that macro authors shouldn't have to care about, e.g.,\n                 // when a parenthesized token tree matched in one macro expansion is matched as\n                 // an expression in another and used as a fn/method argument (Issue #47775)\n-                if e.span.ctxt().outer_expn_info()\n-                    .map_or(false, |info| info.call_site.ctxt().outer_expn_info().is_some()) {\n-                        return;\n+                if e.span.ctxt().outer_expn_data().call_site.from_expansion() {\n+                    return;\n                 }\n                 let msg = format!(\"{} argument\", call_kind);\n                 for arg in args_to_check {"}, {"sha": "40ddd6516429068d293ada9328b3ca24b76f5a83", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -151,6 +151,10 @@ fn main() {\n         cfg.define(\"LLVM_RUSTLLVM\", None);\n     }\n \n+    if env::var_os(\"LLVM_NDEBUG\").is_some() {\n+        cfg.define(\"NDEBUG\", None);\n+    }\n+\n     build_helper::rerun_if_changed_anything_in_dir(Path::new(\"../rustllvm\"));\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n@@ -250,8 +254,11 @@ fn main() {\n     let llvm_use_libcxx = env::var_os(\"LLVM_USE_LIBCXX\");\n \n     let stdcppname = if target.contains(\"openbsd\") {\n-        // llvm-config on OpenBSD doesn't mention stdlib=libc++\n-        \"c++\"\n+        if target.contains(\"sparc64\") {\n+            \"estdc++\"\n+        } else {\n+            \"c++\"\n+        }\n     } else if target.contains(\"freebsd\") {\n         \"c++\"\n     } else if target.contains(\"darwin\") {"}, {"sha": "3d3a020ef0c8e71b60ea893c07bcf0819e09af6d", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,5 +1,5 @@\n #![feature(proc_macro_hygiene)]\n-#![cfg_attr(not(bootstrap), allow(rustc::default_hash_types))]\n+#![allow(rustc::default_hash_types)]\n \n #![recursion_limit=\"128\"]\n "}, {"sha": "4ac0a5b94c0d897c0cd2e1144afec5e202a43d76", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -70,7 +70,7 @@ pub struct CrateMetadata {\n     // whichever `TyCtxt` is being used to decode those values.\n     pub root: schema::CrateRoot<'static>,\n \n-    /// For each public item in this crate, we encode a key. When the\n+    /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental"}, {"sha": "b46758abb5f2c31439bfc71e645f0cc44c8106bb", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -35,7 +35,7 @@ use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n-use syntax_pos::{Span, NO_EXPANSION, FileName};\n+use syntax_pos::{Span, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n macro_rules! provide {\n@@ -443,7 +443,7 @@ impl cstore::CStore {\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n-        let local_span = Span::new(source_file.start_pos, source_file.end_pos, NO_EXPANSION);\n+        let local_span = Span::with_root_ctxt(source_file.start_pos, source_file.end_pos);\n         let (body, mut errors) = source_file_to_stream(&sess.parse_sess, source_file, None);\n         emit_unclosed_delims(&mut errors, &sess.diagnostic());\n "}, {"sha": "772b2d3ec4d85264d3dea721a7b56b1ba70f1c4e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -32,7 +32,7 @@ use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::ExpnId;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n use log::debug;\n \n pub struct DecodeContext<'a, 'tcx> {\n@@ -344,7 +344,15 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let hi = (hi + source_file.translated_source_file.start_pos)\n                  - source_file.original_start_pos;\n \n-        Ok(Span::new(lo, hi, NO_EXPANSION))\n+        Ok(Span::with_root_ctxt(lo, hi))\n+    }\n+}\n+\n+impl SpecializedDecoder<Ident> for DecodeContext<'_, '_> {\n+    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n+        // FIXME(jseyfried): intercrate hygiene\n+\n+        Ok(Ident::with_dummy_span(Symbol::decode(self)?))\n     }\n }\n \n@@ -569,15 +577,15 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::VariantDef::new(\n             tcx,\n-            Ident::with_empty_ctxt(self.item_name(index)),\n+            Ident::with_dummy_span(self.item_name(index)),\n             variant_did,\n             ctor_did,\n             data.discr,\n             item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    ident: Ident::with_empty_ctxt(self.item_name(index)),\n+                    ident: Ident::with_dummy_span(self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n@@ -741,7 +749,7 @@ impl<'a, 'tcx> CrateMetadata {\n                         DefKind::Macro(ext.macro_kind()),\n                         self.local_def_id(DefIndex::from_proc_macro_index(id)),\n                     );\n-                    let ident = Ident::with_empty_ctxt(name);\n+                    let ident = Ident::with_dummy_span(name);\n                     callback(def::Export {\n                         ident: ident,\n                         res: res,\n@@ -783,7 +791,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n-                                    ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n+                                    ident: Ident::with_dummy_span(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n                                 });"}, {"sha": "e2de0552cd651d6a2e26482d0724adf8d1aea553", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -31,7 +31,7 @@ use std::u32;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::{kw, sym, Ident};\n use syntax_pos::{self, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n@@ -173,6 +173,13 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n     }\n }\n \n+impl SpecializedEncoder<Ident> for EncodeContext<'tcx> {\n+    fn specialized_encode(&mut self, ident: &Ident) -> Result<(), Self::Error> {\n+        // FIXME(jseyfried): intercrate hygiene\n+        ident.name.encode(self)\n+    }\n+}\n+\n impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -1676,7 +1683,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n                      id: hir::HirId) {\n         intravisit::walk_variant(self, v, g, id);\n \n-        if let Some(ref discr) = v.node.disr_expr {\n+        if let Some(ref discr) = v.disr_expr {\n             let def_id = self.tcx.hir().local_def_id(discr.hir_id);\n             self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n         }"}, {"sha": "9ff0c6ca6a546b6566e036c3f736d703a7e0560d", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -272,12 +272,11 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n-        self.sanitize_constant(constant, location);\n-        self.sanitize_type(constant, constant.ty);\n+        self.sanitize_type(constant, constant.literal.ty);\n \n         if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n-                constant.ty,\n+                constant.literal.ty,\n                 ty::Variance::Invariant,\n                 &UserTypeProjection { base: annotation_index, projs: vec![], },\n                 location.to_locations(),\n@@ -289,7 +288,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     constant,\n                     \"bad constant user type {:?} vs {:?}: {:?}\",\n                     annotation,\n-                    constant.ty,\n+                    constant.literal.ty,\n                     terr,\n                 );\n             }\n@@ -299,7 +298,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     location.to_locations(),\n                     ConstraintCategory::Boring,\n                     self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                        constant.ty, def_id, UserSubsts { substs, user_self_ty: None },\n+                        constant.literal.ty, def_id, UserSubsts { substs, user_self_ty: None },\n                     )),\n                 ) {\n                     span_mirbug!(\n@@ -403,41 +402,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    /// Checks that the constant's `ty` field matches up with what would be\n-    /// expected from its literal. Unevaluated constants and well-formed\n-    /// constraints are checked by `visit_constant`.\n-    fn sanitize_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n-        debug!(\n-            \"sanitize_constant(constant={:?}, location={:?})\",\n-            constant, location\n-        );\n-\n-        let literal = constant.literal;\n-\n-        if let ConstValue::Unevaluated(..) = literal.val {\n-            return;\n-        }\n-\n-        debug!(\"sanitize_constant: expected_ty={:?}\", literal.ty);\n-\n-        if let Err(terr) = self.cx.eq_types(\n-            literal.ty,\n-            constant.ty,\n-            location.to_locations(),\n-            ConstraintCategory::Boring,\n-        ) {\n-            span_mirbug!(\n-                self,\n-                constant,\n-                \"constant {:?} should have type {:?} but has {:?} ({:?})\",\n-                constant,\n-                literal.ty,\n-                constant.ty,\n-                terr,\n-            );\n-        }\n-    }\n-\n     /// Checks that the types internal to the `place` match up with\n     /// what would be expected.\n     fn sanitize_place("}, {"sha": "39bdc871d83c6deed23df26d770f9dd5eed88716", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -38,9 +38,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         inferred_ty: ty,\n                     })\n                 });\n+                assert_eq!(literal.ty, ty);\n                 Constant {\n                     span,\n-                    ty,\n                     user_ty,\n                     literal,\n                 }"}, {"sha": "1a186fa932ddb116e8a40556fbfc18999a6b0d3e", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -591,7 +591,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let n = (!0u128) >> (128 - bits);\n         let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n \n-        self.literal_operand(span, ty, literal)\n+        self.literal_operand(span, literal)\n     }\n \n     // Helper to get the minimum value of the appropriate type\n@@ -602,6 +602,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let n = 1 << (bits - 1);\n         let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n \n-        self.literal_operand(span, ty, literal)\n+        self.literal_operand(span, literal)\n     }\n }"}, {"sha": "889861b85674861b2d4caf181d900c081494da0a", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -114,7 +114,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     destination,\n                     Constant {\n                         span: expr_span,\n-                        ty: this.hir.bool_ty(),\n                         user_ty: None,\n                         literal: this.hir.true_literal(),\n                     },\n@@ -126,7 +125,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     destination,\n                     Constant {\n                         span: expr_span,\n-                        ty: this.hir.bool_ty(),\n                         user_ty: None,\n                         literal: this.hir.false_literal(),\n                     },"}, {"sha": "3473155a3ea3ed8c82a4b0861499b6e3e2aff182", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -108,8 +108,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Range(PatternRange { lo, hi, ty, end }) => {\n-                let (range, bias) = match ty.sty {\n+            PatternKind::Range(PatternRange { lo, hi, end }) => {\n+                let (range, bias) = match lo.ty.sty {\n                     ty::Char => {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n                     }"}, {"sha": "65e92d422b0222202f340b75a39c60bddd2ab541", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -63,7 +63,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatternKind::Range(range) => {\n-                assert!(range.ty == match_pair.pattern.ty);\n+                assert_eq!(range.lo.ty, match_pair.pattern.ty);\n+                assert_eq!(range.hi.ty, match_pair.pattern.ty);\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range(range),\n@@ -270,22 +271,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n                 } else {\n                     if let [success, fail] = *make_target_blocks(self) {\n+                        assert_eq!(value.ty, ty);\n+                        let expect = self.literal_operand(test.span, value);\n                         let val = Operand::Copy(place.clone());\n-                        let expect = self.literal_operand(test.span, ty, value);\n                         self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n                     } else {\n                         bug!(\"`TestKind::Eq` should have two target blocks\");\n                     }\n                 }\n             }\n \n-            TestKind::Range(PatternRange { ref lo, ref hi, ty, ref end }) => {\n+            TestKind::Range(PatternRange { ref lo, ref hi, ref end }) => {\n                 let lower_bound_success = self.cfg.start_new_block();\n                 let target_blocks = make_target_blocks(self);\n \n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n-                let lo = self.literal_operand(test.span, ty, lo);\n-                let hi = self.literal_operand(test.span, ty, hi);\n+                let lo = self.literal_operand(test.span, lo);\n+                let hi = self.literal_operand(test.span, hi);\n                 let val = Operand::Copy(place.clone());\n \n                 if let [success, fail] = *target_blocks {\n@@ -387,7 +389,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         use rustc::middle::lang_items::EqTraitLangItem;\n \n-        let mut expect = self.literal_operand(source_info.span, value.ty, value);\n+        let mut expect = self.literal_operand(source_info.span, value);\n         let mut val = Operand::Copy(place.clone());\n \n         // If we're using `b\"...\"` as a pattern, we need to insert an\n@@ -440,7 +442,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         let eq_def_id = self.hir.tcx().require_lang_item(EqTraitLangItem);\n-        let (mty, method) = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n+        let method = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n \n         let bool_ty = self.hir.bool_ty();\n         let eq_result = self.temp(bool_ty, source_info.span);\n@@ -449,7 +451,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.terminate(block, source_info, TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n                 span: source_info.span,\n-                ty: mty,\n \n                 // FIXME(#54571): This constant comes from user input (a\n                 // constant in a pattern).  Are there forms where users can add\n@@ -656,8 +657,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     let tcx = self.hir.tcx();\n \n-                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.hir.param_env, test.ty)?;\n-                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.hir.param_env, test.ty)?;\n+                    let test_ty = test.lo.ty;\n+                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.hir.param_env, test_ty)?;\n+                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.hir.param_env, test_ty)?;\n \n                     match (test.end, pat.end, lo, hi) {\n                         // pat < test\n@@ -774,8 +776,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let tcx = self.hir.tcx();\n \n-        let a = compare_const_vals(tcx, range.lo, value, self.hir.param_env, range.ty)?;\n-        let b = compare_const_vals(tcx, value, range.hi, self.hir.param_env, range.ty)?;\n+        let a = compare_const_vals(tcx, range.lo, value, self.hir.param_env, range.lo.ty)?;\n+        let b = compare_const_vals(tcx, value, range.hi, self.hir.param_env, range.lo.ty)?;\n \n         match (b, range.end) {\n             (Less, _) |"}, {"sha": "d038310dd4454cadd4cbe432befcd97c791f2fc9", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -26,12 +26,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// without any user type annotation.\n     pub fn literal_operand(&mut self,\n                            span: Span,\n-                           ty: Ty<'tcx>,\n                            literal: &'tcx ty::Const<'tcx>)\n                            -> Operand<'tcx> {\n         let constant = box Constant {\n             span,\n-            ty,\n             user_ty: None,\n             literal,\n         };\n@@ -47,7 +45,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty));\n \n-        self.literal_operand(span, ty, literal)\n+        self.literal_operand(span, literal)\n     }\n \n     pub fn push_usize(&mut self,\n@@ -61,7 +59,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block, source_info, &temp,\n             Constant {\n                 span: source_info.span,\n-                ty: self.hir.usize_ty(),\n                 user_ty: None,\n                 literal: self.hir.usize_literal(value),\n             });"}, {"sha": "52225ea8f024f2ac1d8fed47603398a188309a81", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -540,6 +540,12 @@ pub fn error_to_const_error<'mir, 'tcx>(\n     ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n }\n \n+pub fn note_on_undefined_behavior_error() -> &'static str {\n+    \"The rules on what exactly is undefined behavior aren't clear, \\\n+    so this check might be overzealous. Please open an issue on the rust compiler \\\n+    repository if you believe it should not be considered undefined behavior\"\n+}\n+\n fn validate_and_turn_into_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: RawConst<'tcx>,\n@@ -579,10 +585,7 @@ fn validate_and_turn_into_const<'tcx>(\n         let err = error_to_const_error(&ecx, error);\n         match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n             Ok(mut diag) => {\n-                diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n-                    so this check might be overzealous. Please open an issue on the rust compiler \\\n-                    repository if you believe it should not be considered undefined behavior\",\n-                );\n+                diag.note(note_on_undefined_behavior_error());\n                 diag.emit();\n                 ErrorHandled::Reported\n             }"}, {"sha": "a33d7207ed4e1453d2917f966b7f59e278b63dad", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -927,7 +927,7 @@ fn convert_path_expr<'a, 'tcx>(\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const(ty::Const {\n                     val: ConstValue::Unevaluated(def_id, substs),\n-                    ty: cx.tcx.type_of(def_id),\n+                    ty: cx.tables().node_type(expr.hir_id),\n                 }),\n                 user_ty,\n             }"}, {"sha": "740dc2011cab1cddd65cea770aac1f777b53e540", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -170,13 +170,13 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n                         method_name: Symbol,\n                         self_ty: Ty<'tcx>,\n                         params: &[Kind<'tcx>])\n-                        -> (Ty<'tcx>, &'tcx ty::Const<'tcx>) {\n+                        -> &'tcx ty::Const<'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssocKind::Method && item.ident.name == method_name {\n                 let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty, ty::Const::zero_sized(self.tcx, method_ty));\n+                return ty::Const::zero_sized(self.tcx, method_ty);\n             }\n         }\n "}, {"sha": "1833ee30624bb798293d1d50c51164500b197175", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -609,7 +609,6 @@ impl<'tcx> Witness<'tcx> {\n                         ConstantRange(lo, hi, ty, end) => PatternKind::Range(PatternRange {\n                             lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n                             hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                            ty,\n                             end,\n                         }),\n                         _ => PatternKind::Wild,\n@@ -880,10 +879,10 @@ impl<'tcx> IntRange<'tcx> {\n         let range = loop {\n             match pat.kind {\n                 box PatternKind::Constant { value } => break ConstantValue(value),\n-                box PatternKind::Range(PatternRange { lo, hi, ty, end }) => break ConstantRange(\n-                    lo.eval_bits(tcx, param_env, ty),\n-                    hi.eval_bits(tcx, param_env, ty),\n-                    ty,\n+                box PatternKind::Range(PatternRange { lo, hi, end }) => break ConstantRange(\n+                    lo.eval_bits(tcx, param_env, lo.ty),\n+                    hi.eval_bits(tcx, param_env, hi.ty),\n+                    lo.ty,\n                     end,\n                 ),\n                 box PatternKind::AscribeUserType { ref subpattern, .. } => {\n@@ -1339,11 +1338,11 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n-        PatternKind::Range(PatternRange { lo, hi, ty, end }) =>\n+        PatternKind::Range(PatternRange { lo, hi, end }) =>\n             Some(vec![ConstantRange(\n-                lo.eval_bits(cx.tcx, cx.param_env, ty),\n-                hi.eval_bits(cx.tcx, cx.param_env, ty),\n-                ty,\n+                lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n+                hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n+                lo.ty,\n                 end,\n             )]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n@@ -1656,7 +1655,7 @@ fn constructor_covered_by_range<'tcx>(\n ) -> Result<bool, ErrorReported> {\n     let (from, to, end, ty) = match pat.kind {\n         box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        box PatternKind::Range(PatternRange { lo, hi, end, ty }) => (lo, hi, end, ty),\n+        box PatternKind::Range(PatternRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);"}, {"sha": "bebb0719af8081336752daf1ecaa2f2be77de04f", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -181,7 +181,6 @@ pub enum PatternKind<'tcx> {\n pub struct PatternRange<'tcx> {\n     pub lo: &'tcx ty::Const<'tcx>,\n     pub hi: &'tcx ty::Const<'tcx>,\n-    pub ty: Ty<'tcx>,\n     pub end: RangeEnd,\n }\n \n@@ -296,7 +295,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             PatternKind::Constant { value } => {\n                 write!(f, \"{}\", value)\n             }\n-            PatternKind::Range(PatternRange { lo, hi, ty: _, end }) => {\n+            PatternKind::Range(PatternRange { lo, hi, end }) => {\n                 write!(f, \"{}\", lo)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"..=\")?,\n@@ -442,6 +441,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n                 let mut kind = match (lo, hi) {\n                     (PatternKind::Constant { value: lo }, PatternKind::Constant { value: hi }) => {\n+                        assert_eq!(lo.ty, ty);\n+                        assert_eq!(hi.ty, ty);\n                         let cmp = compare_const_vals(\n                             self.tcx,\n                             lo,\n@@ -451,7 +452,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         match (end, cmp) {\n                             (RangeEnd::Excluded, Some(Ordering::Less)) =>\n-                                PatternKind::Range(PatternRange { lo, hi, ty, end }),\n+                                PatternKind::Range(PatternRange { lo, hi, end }),\n                             (RangeEnd::Excluded, _) => {\n                                 span_err!(\n                                     self.tcx.sess,\n@@ -465,7 +466,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 PatternKind::Constant { value: lo }\n                             }\n                             (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatternKind::Range(PatternRange { lo, hi, ty, end })\n+                                PatternKind::Range(PatternRange { lo, hi, end })\n                             }\n                             (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n@@ -645,9 +646,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     fields.iter()\n                           .map(|field| {\n                               FieldPattern {\n-                                  field: Field::new(self.tcx.field_index(field.node.hir_id,\n+                                  field: Field::new(self.tcx.field_index(field.hir_id,\n                                                                          self.tables)),\n-                                  pattern: self.lower_pattern(&field.node.pat),\n+                                  pattern: self.lower_pattern(&field.pat),\n                               }\n                           })\n                           .collect();\n@@ -1416,17 +1417,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             } => PatternKind::Constant {\n                 value,\n             },\n-            PatternKind::Range(PatternRange {\n-                lo,\n-                hi,\n-                ty,\n-                end,\n-            }) => PatternKind::Range(PatternRange {\n-                lo,\n-                hi,\n-                ty: ty.fold_with(folder),\n-                end,\n-            }),\n+            PatternKind::Range(range) => PatternKind::Range(range),\n             PatternKind::Slice {\n                 ref prefix,\n                 ref slice,"}, {"sha": "32ba70a81c99792cedd200c305dff2d8623e42ec", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -296,11 +296,7 @@ pub fn intern_const_alloc_recursive(\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n                 match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n                     Ok(mut diag) => {\n-                        diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n-                            so this check might be overzealous. Please open an issue on the rust \\\n-                            compiler repository if you believe it should not be considered \\\n-                            undefined behavior\",\n-                        );\n+                        diag.note(crate::const_eval::note_on_undefined_behavior_error());\n                         diag.emit();\n                     }\n                     Err(ErrorHandled::TooGeneric) |"}, {"sha": "ee105fed1a324aadf7dd68ccbf33cc5f25623071", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -110,18 +110,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 self.write_scalar(out_val, dest)?;\n             }\n-            | \"overflowing_add\"\n-            | \"overflowing_sub\"\n-            | \"overflowing_mul\"\n+            | \"wrapping_add\"\n+            | \"wrapping_sub\"\n+            | \"wrapping_mul\"\n             | \"add_with_overflow\"\n             | \"sub_with_overflow\"\n             | \"mul_with_overflow\" => {\n                 let lhs = self.read_immediate(args[0])?;\n                 let rhs = self.read_immediate(args[1])?;\n                 let (bin_op, ignore_overflow) = match intrinsic_name {\n-                    \"overflowing_add\" => (BinOp::Add, true),\n-                    \"overflowing_sub\" => (BinOp::Sub, true),\n-                    \"overflowing_mul\" => (BinOp::Mul, true),\n+                    \"wrapping_add\" => (BinOp::Add, true),\n+                    \"wrapping_sub\" => (BinOp::Sub, true),\n+                    \"wrapping_mul\" => (BinOp::Mul, true),\n                     \"add_with_overflow\" => (BinOp::Add, false),\n                     \"sub_with_overflow\" => (BinOp::Sub, false),\n                     \"mul_with_overflow\" => (BinOp::Mul, false),"}, {"sha": "6771d7661e3a4cf54e8893aed2554f9b9e349f64", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -368,7 +368,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n-                end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n+                end_ptr.check_inbounds_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n@@ -400,7 +400,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> bool {\n         let (size, _align) = self.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n             .expect(\"alloc info with MaybeDead cannot fail\");\n-        ptr.check_in_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n+        ptr.check_inbounds_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n     }\n }\n "}, {"sha": "139a92c7b11908af303d47b5471a2adf909a212d", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -246,7 +246,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let ptr = match self.check_mplace_access(mplace, None)? {\n+        let ptr = match self.check_mplace_access(mplace, None)\n+            .expect(\"places should be checked on creation\")\n+        {\n             Some(ptr) => ptr,\n             None => return Ok(Some(ImmTy { // zero-sized type\n                 imm: Scalar::zst().into(),"}, {"sha": "16686c3800f87d95972c7a7855060e3a16200621", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -277,6 +277,10 @@ where\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n+    ///\n+    /// Only call this if you are sure the place is \"valid\" (aligned and inbounds), or do not\n+    /// want to ever use the place for memory access!\n+    /// Generally prefer `deref_operand`.\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n@@ -304,7 +308,8 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        self.ref_to_mplace(val)\n+        let place = self.ref_to_mplace(val)?;\n+        self.mplace_access_checked(place)\n     }\n \n     /// Check if the given place is good for memory access with the given\n@@ -327,6 +332,23 @@ where\n         self.memory.check_ptr_access(place.ptr, size, place.align)\n     }\n \n+    /// Return the \"access-checked\" version of this `MPlace`, where for non-ZST\n+    /// this is definitely a `Pointer`.\n+    pub fn mplace_access_checked(\n+        &self,\n+        mut place: MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let (size, align) = self.size_and_align_of_mplace(place)?\n+            .unwrap_or((place.layout.size, place.layout.align.abi));\n+        assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n+        place.mplace.align = align; // maximally strict checking\n+        // When dereferencing a pointer, it must be non-NULL, aligned, and live.\n+        if let Some(ptr) = self.check_mplace_access(place, Some(size))? {\n+            place.mplace.ptr = ptr.into();\n+        }\n+        Ok(place)\n+    }\n+\n     /// Force `place.ptr` to a `Pointer`.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n     pub fn force_mplace_ptr(\n@@ -750,7 +772,9 @@ where\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n \n-        let ptr = match self.check_mplace_access(dest, None)? {\n+        let ptr = match self.check_mplace_access(dest, None)\n+            .expect(\"places should be checked on creation\")\n+        {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n         };\n@@ -853,8 +877,10 @@ where\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n-        let src = self.check_mplace_access(src, Some(size))?;\n-        let dest = self.check_mplace_access(dest, Some(size))?;\n+        let src = self.check_mplace_access(src, Some(size))\n+            .expect(\"places should be checked on creation\");\n+        let dest = self.check_mplace_access(dest, Some(size))\n+            .expect(\"places should be checked on creation\");\n         let (src_ptr, dest_ptr) = match (src, dest) {\n             (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n             (None, None) => return Ok(()), // zero-sized copy"}, {"sha": "e55827837fa1ec0515da4386be3a909e2053ec03", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -240,8 +240,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n-                let val = self.force_allocation(src)?;\n-                self.write_immediate(val.to_ref(), dest)?;\n+                let place = self.force_allocation(src)?;\n+                if place.layout.size.bytes() > 0 {\n+                    // definitely not a ZST\n+                    assert!(place.ptr.is_ptr(), \"non-ZST places should be normalized to `Pointer`\");\n+                }\n+                self.write_immediate(place.to_ref(), dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {"}, {"sha": "063e7796371580306d3e30277b70bbcdeaf2fd39", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -445,7 +445,6 @@ impl CloneShimBuilder<'tcx> {\n         let func_ty = tcx.mk_fn_def(self.def_id, substs);\n         let func = Operand::Constant(box Constant {\n             span: self.span,\n-            ty: func_ty,\n             user_ty: None,\n             literal: ty::Const::zero_sized(tcx, func_ty),\n         });\n@@ -505,7 +504,6 @@ impl CloneShimBuilder<'tcx> {\n     fn make_usize(&self, value: u64) -> Box<Constant<'tcx>> {\n         box Constant {\n             span: self.span,\n-            ty: self.tcx.types.usize,\n             user_ty: None,\n             literal: ty::Const::from_usize(self.tcx, value),\n         }\n@@ -745,7 +743,6 @@ fn build_call_shim<'tcx>(\n             let ty = tcx.type_of(def_id);\n             (Operand::Constant(box Constant {\n                 span,\n-                ty,\n                 user_ty: None,\n                 literal: ty::Const::zero_sized(tcx, ty),\n              }),"}, {"sha": "524a19e3434f3c8f3f8b0ace4862113517db23b1", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -42,9 +42,8 @@ fn is_stable(\n     }\n }\n \n-/// Determine whether this type may have a reference in it, recursing below compound types but\n-/// not below references.\n-fn may_have_reference<'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n+/// Determine whether this type may be a reference (or box), and thus needs retagging.\n+fn may_be_reference<'tcx>(ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // Primitive types that are not references\n         ty::Bool | ty::Char |\n@@ -55,15 +54,12 @@ fn may_have_reference<'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n         // References\n         ty::Ref(..) => true,\n         ty::Adt(..) if ty.is_box() => true,\n-        // Compound types\n-        ty::Array(ty, ..) | ty::Slice(ty) =>\n-            may_have_reference(ty, tcx),\n-        ty::Tuple(tys) =>\n-            tys.iter().any(|ty| may_have_reference(ty.expect_ty(), tcx)),\n-        ty::Adt(adt, substs) =>\n-            adt.variants.iter().any(|v| v.fields.iter().any(|f|\n-                may_have_reference(f.ty(tcx, substs), tcx)\n-            )),\n+        // Compound types are not references\n+        ty::Array(..) |\n+        ty::Slice(..) |\n+        ty::Tuple(..) |\n+        ty::Adt(..) =>\n+            false,\n         // Conservative fallback\n         _ => true,\n     }\n@@ -80,7 +76,7 @@ impl MirPass for AddRetag {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that.\n             is_stable(place.as_ref())\n-                && may_have_reference(place.ty(&*local_decls, tcx).ty, tcx)\n+                && may_be_reference(place.ty(&*local_decls, tcx).ty)\n         };\n \n         // PART 1"}, {"sha": "c3c432d606644ed77a4a3bf53ce98c0b749313fa", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -539,7 +539,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Operand::Constant(Box::new(\n             Constant {\n                 span,\n-                ty,\n                 user_ty: None,\n                 literal: self.tcx.mk_const(*ty::Const::from_scalar(\n                     self.tcx,"}, {"sha": "4480d1e0a05b85ce882bc1dc27171552739a5cc2", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -527,7 +527,6 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn constant_bool(&self, span: Span, val: bool) -> Rvalue<'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n-            ty: self.tcx.types.bool,\n             user_ty: None,\n             literal: ty::Const::from_bool(self.tcx, val),\n         })))"}, {"sha": "f6941880240316ad55507409437844938fb52828", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -975,7 +975,6 @@ fn insert_panic_block<'tcx>(\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n             span: body.span,\n-            ty: tcx.types.bool,\n             user_ty: None,\n             literal: ty::Const::from_bool(tcx, false),\n         }),"}, {"sha": "bc7bd39be488e35684356634eb789a289607f23c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -328,7 +328,7 @@ impl Inliner<'tcx> {\n                 }\n \n                 TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n-                    if let ty::FnDef(def_id, _) = f.ty.sty {\n+                    if let ty::FnDef(def_id, _) = f.literal.ty.sty {\n                         // Don't give intrinsics the extra penalty for calls\n                         let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {"}, {"sha": "b2d063a1f4e10392291c04ca0f3d3dbaa7f47954", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -97,8 +97,7 @@ impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n             let place_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n             if let ty::Array(_, len) = place_ty.sty {\n                 let span = self.body.source_info(location).span;\n-                let ty = self.tcx.types.usize;\n-                let constant = Constant { span, ty, literal: len, user_ty: None };\n+                let constant = Constant { span, literal: len, user_ty: None };\n                 self.optimizations.arrays_lengths.insert(location, constant);\n             }\n         }"}, {"sha": "649cccc36c346e88c9542912250db9762bdd9c02", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -249,7 +249,7 @@ trait Qualif {\n                 if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n                     // Don't peek inside trait associated constants.\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n-                        Self::in_any_value_of_ty(cx, constant.ty).unwrap_or(false)\n+                        Self::in_any_value_of_ty(cx, constant.literal.ty).unwrap_or(false)\n                     } else {\n                         let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n@@ -258,7 +258,7 @@ trait Qualif {\n                         // Just in case the type is more specific than\n                         // the definition, e.g., impl associated const\n                         // with type parameters, take it into account.\n-                        qualif && Self::mask_for_ty(cx, constant.ty)\n+                        qualif && Self::mask_for_ty(cx, constant.literal.ty)\n                     }\n                 } else {\n                     false\n@@ -537,9 +537,9 @@ impl Qualif for IsNotPromotable {\n                             | \"cttz_nonzero\"\n                             | \"ctlz\"\n                             | \"ctlz_nonzero\"\n-                            | \"overflowing_add\"\n-                            | \"overflowing_sub\"\n-                            | \"overflowing_mul\"\n+                            | \"wrapping_add\"\n+                            | \"wrapping_sub\"\n+                            | \"wrapping_mul\"\n                             | \"unchecked_shl\"\n                             | \"unchecked_shr\"\n                             | \"rotate_left\""}, {"sha": "334d0cee9fbe7412a7e401c9e8afbf963c151f61", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -379,9 +379,9 @@ fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n         | \"add_with_overflow\" // ~> .overflowing_add\n         | \"sub_with_overflow\" // ~> .overflowing_sub\n         | \"mul_with_overflow\" // ~> .overflowing_mul\n-        | \"overflowing_add\" // ~> .wrapping_add\n-        | \"overflowing_sub\" // ~> .wrapping_sub\n-        | \"overflowing_mul\" // ~> .wrapping_mul\n+        | \"wrapping_add\" // ~> .wrapping_add\n+        | \"wrapping_sub\" // ~> .wrapping_sub\n+        | \"wrapping_mul\" // ~> .wrapping_mul\n         | \"saturating_add\" // ~> .saturating_add\n         | \"saturating_sub\" // ~> .saturating_sub\n         | \"unchecked_shl\" // ~> .wrapping_shl"}, {"sha": "598de3a77e61c22ce6745325bc62b45b5aba46b9", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -224,7 +224,7 @@ fn is_rustc_peek<'a, 'tcx>(\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n             if let mir::Operand::Constant(ref func) = *oper {\n-                if let ty::FnDef(def_id, _) = func.ty.sty {\n+                if let ty::FnDef(def_id, _) = func.literal.ty.sty {\n                     let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic && name == sym::rustc_peek {"}, {"sha": "c5561a1ae0d1548215fc2d803078f95bbeb689fc", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -970,7 +970,6 @@ where\n     fn constant_usize(&self, val: u16) -> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n-            ty: self.tcx().types.usize,\n             user_ty: None,\n             literal: ty::Const::from_usize(self.tcx(), val.into()),\n         })"}, {"sha": "ac2701971dfd55e369228d51ea08812c3f0b54e0", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -397,10 +397,9 @@ impl ExtraComments<'tcx> {\n impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n-        let Constant { span, ty, user_ty, literal } = constant;\n+        let Constant { span, user_ty, literal } = constant;\n         self.push(\"mir::Constant\");\n         self.push(&format!(\"+ span: {:?}\", span));\n-        self.push(&format!(\"+ ty: {:?}\", ty));\n         if let Some(user_ty) = user_ty {\n             self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n         }"}, {"sha": "bd46ca4779a430fb56bc5a9bbfae1e9499bfa275", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -602,7 +602,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.invalid_visibility(&field.vis, None);\n                     }\n                 }\n@@ -824,7 +824,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             |this| visit::walk_enum_def(this, enum_definition, generics, item_id))\n     }\n \n-    fn visit_mac(&mut self, mac: &Spanned<Mac_>) {\n+    fn visit_mac(&mut self, mac: &Mac) {\n         // when a new macro kind is added but the author forgets to set it up for expansion\n         // because that's the only part that won't cause a compiler error\n         self.session.diagnostic()"}, {"sha": "bca77621e553ed304bce307b2e90ed9e5045bb73", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -687,11 +687,11 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         match item.node {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    let variant_level = self.update(variant.node.id, item_level);\n-                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+                    let variant_level = self.update(variant.id, item_level);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n                         self.update(ctor_hir_id, item_level);\n                     }\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.update(field.hir_id, variant_level);\n                     }\n                 }\n@@ -810,9 +810,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    let variant_level = self.get(variant.node.id);\n+                    let variant_level = self.get(variant.id);\n                     if variant_level.is_some() {\n-                        for field in variant.node.data.fields() {\n+                        for field in variant.data.fields() {\n                             self.reach(field.hir_id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n@@ -1075,8 +1075,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_res(res);\n                 for field in fields {\n-                    let use_ctxt = field.node.ident.span;\n-                    let index = self.tcx.field_index(field.node.hir_id, self.tables);\n+                    let use_ctxt = field.ident.span;\n+                    let index = self.tcx.field_index(field.hir_id, self.tables);\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                 }\n             }\n@@ -1647,7 +1647,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        if self.access_levels.is_reachable(v.node.id) {\n+        if self.access_levels.is_reachable(v.id) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n@@ -1898,7 +1898,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.check(field.hir_id, item_visibility).ty();\n                     }\n                 }"}, {"sha": "1510d74babb6d8b17abe6213e2f4eb5a4f2385e1", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 92, "deletions": 105, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,9 +1,11 @@\n-//! Reduced graph building.\n+//! After we obtain a fresh AST fragment from a macro, code in this module helps to integrate\n+//! that fragment into the module structures that are already partially built.\n //!\n-//! Here we build the \"reduced graph\": the graph of the module tree without\n-//! any imports resolved.\n+//! Items from the fragment are placed into modules,\n+//! unexpanded macros in the fragment are visited and registered.\n+//! Imports are also considered items and placed into modules here, but not resolved yet.\n \n-use crate::macros::{InvocationData, LegacyBinding, LegacyScope};\n+use crate::macros::{LegacyBinding, LegacyScope};\n use crate::resolve_imports::ImportDirective;\n use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n@@ -14,6 +16,7 @@ use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n use rustc::bug;\n use rustc::hir::def::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::map::DefCollector;\n use rustc::ty;\n use rustc::middle::cstore::CrateStore;\n use rustc_metadata::cstore::LoadedMacro;\n@@ -30,6 +33,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::expand::AstFragment;\n use syntax::ext::hygiene::ExpnId;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n@@ -67,7 +71,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId) {\n     }\n }\n \n-pub(crate) struct IsMacroExport;\n+struct IsMacroExport;\n \n impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n@@ -84,7 +88,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, ExpnId, IsMacroExport\n impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    pub fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+    crate fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n         where T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n@@ -93,7 +97,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+    crate fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n         if def_id.krate == LOCAL_CRATE {\n             return self.module_map[&def_id]\n         }\n@@ -119,7 +123,7 @@ impl<'a> Resolver<'a> {\n         module\n     }\n \n-    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+    crate fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n         let def_id = match self.macro_defs.get(&expn_id) {\n             Some(def_id) => *def_id,\n             None => return self.graph_root,\n@@ -141,7 +145,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+    fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return Some(ext.clone());\n         }\n@@ -156,23 +160,32 @@ impl<'a> Resolver<'a> {\n         Some(ext)\n     }\n \n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n-        if module.populated.get() { return }\n-        let def_id = module.def_id().unwrap();\n+    crate fn build_reduced_graph(\n+        &mut self, fragment: &AstFragment, parent_scope: ParentScope<'a>\n+    ) -> LegacyScope<'a> {\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, parent_scope.expansion));\n+        let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n+        fragment.visit_with(&mut visitor);\n+        visitor.parent_scope.legacy\n+    }\n+\n+    crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n+        let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n         for child in self.cstore.item_children_untracked(def_id, self.session) {\n             let child = child.map_id(|_| panic!(\"unexpected id\"));\n-            BuildReducedGraphVisitor { parent_scope: self.dummy_parent_scope(), r: self }\n-                .build_reduced_graph_for_external_crate_res(module, child);\n+            BuildReducedGraphVisitor { r: self, parent_scope: ParentScope::module(module) }\n+                .build_reduced_graph_for_external_crate_res(child);\n         }\n-        module.populated.set(true)\n     }\n }\n \n-pub struct BuildReducedGraphVisitor<'a, 'b> {\n-    pub r: &'b mut Resolver<'a>,\n-    pub parent_scope: ParentScope<'a>,\n+struct BuildReducedGraphVisitor<'a, 'b> {\n+    r: &'b mut Resolver<'a>,\n+    parent_scope: ParentScope<'a>,\n+}\n+\n+impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a> { self.r }\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n@@ -300,10 +313,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         root_id: NodeId,\n         vis: ty::Visibility,\n     ) {\n-        let parent_scope = &self.parent_scope;\n-        let current_module = parent_scope.module;\n+        let current_module = self.parent_scope.module;\n         let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n-            parent_scope: parent_scope.clone(),\n+            parent_scope: self.parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n             subclass,\n@@ -593,15 +605,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                self.r.populate_module_if_necessary(module);\n-\n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n                 let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent_scope: self.parent_scope.clone(),\n+                    parent_scope: self.parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -706,7 +716,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n-                    self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n+                    self.build_reduced_graph_for_variant(variant, module, vis);\n                 }\n             }\n \n@@ -797,19 +807,19 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        parent: Module<'a>,\n-                                       vis: ty::Visibility,\n-                                       expn_id: ExpnId) {\n-        let ident = variant.node.ident;\n+                                       vis: ty::Visibility) {\n+        let expn_id = self.parent_scope.expansion;\n+        let ident = variant.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.r.definitions.local_def_id(variant.node.id);\n+        let def_id = self.r.definitions.local_def_id(variant.id);\n         let res = Res::Def(DefKind::Variant, def_id);\n         self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n         let mut ctor_vis = vis;\n-        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, sym::non_exhaustive);\n+        let has_non_exhaustive = attr::contains_name(&variant.attrs, sym::non_exhaustive);\n         if has_non_exhaustive && vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n@@ -819,9 +829,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         // value namespace, they are reserved for possible future use.\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n-        let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n+        let ctor_node_id = variant.data.ctor_id().unwrap_or(variant.id);\n         let ctor_def_id = self.r.definitions.local_def_id(ctor_node_id);\n-        let ctor_kind = CtorKind::from_ast(&variant.node.data);\n+        let ctor_kind = CtorKind::from_ast(&variant.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n         self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n     }\n@@ -861,91 +871,75 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_res(\n-        &mut self,\n-        parent: Module<'a>,\n-        child: Export<ast::NodeId>,\n-    ) {\n+    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<ast::NodeId>) {\n+        let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n         // FIXME: We shouldn't create the gensym here, it should come from metadata,\n         // but metadata cannot encode gensyms currently, so we create it here.\n         // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n         let ident = ident.gensym_if_underscore();\n         let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n+        // Record primary definitions.\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n-            | Res::Def(kind @ DefKind::Enum, def_id) => {\n+            | Res::Def(kind @ DefKind::Enum, def_id)\n+            | Res::Def(kind @ DefKind::Trait, def_id) => {\n                 let module = self.r.new_module(parent,\n                                              ModuleKind::Def(kind, def_id, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n                 self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Res::Def(DefKind::Variant, _)\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::Variant, _)\n             | Res::Def(DefKind::TyAlias, _)\n             | Res::Def(DefKind::ForeignTy, _)\n             | Res::Def(DefKind::OpaqueTy, _)\n             | Res::Def(DefKind::TraitAlias, _)\n+            | Res::Def(DefKind::AssocTy, _)\n+            | Res::Def(DefKind::AssocOpaqueTy, _)\n             | Res::PrimTy(..)\n-            | Res::ToolMod => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-            }\n+            | Res::ToolMod =>\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion)),\n             Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::Method, _)\n             | Res::Def(DefKind::Static, _)\n             | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-            }\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-\n-                if let Some(struct_def_id) =\n-                        self.r.cstore.def_key(def_id).parent\n-                            .map(|index| DefId { krate: def_id.krate, index: index }) {\n-                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n-                }\n-            }\n-            Res::Def(DefKind::Trait, def_id) => {\n-                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.r.new_module(parent,\n-                                             module_kind,\n-                                             parent.normal_ancestor_id,\n-                                             expansion,\n-                                             span);\n-                self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n-\n-                for child in self.r.cstore.item_children_untracked(def_id, self.r.session) {\n-                    let res = child.res.map_id(|_| panic!(\"unexpected id\"));\n-                    let ns = if let Res::Def(DefKind::AssocTy, _) = res {\n-                        TypeNS\n-                    } else { ValueNS };\n-                    self.r.define(module, child.ident, ns,\n-                                (res, ty::Visibility::Public, DUMMY_SP, expansion));\n-\n-                    if self.r.cstore.associated_item_cloned_untracked(child.res.def_id())\n-                           .method_has_self_argument {\n-                        self.r.has_self.insert(res.def_id());\n-                    }\n-                }\n-                module.populated.set(true);\n-            }\n+            | Res::Def(DefKind::AssocConst, _)\n+            | Res::Def(DefKind::Ctor(..), _) =>\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::Macro(..), _)\n+            | Res::NonMacroAttr(..) =>\n+                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::TyParam, _) | Res::Def(DefKind::ConstParam, _)\n+            | Res::Local(..) | Res::SelfTy(..) | Res::SelfCtor(..) | Res::Err =>\n+                bug!(\"unexpected resolution: {:?}\", res)\n+        }\n+        // Record some extra data for better diagnostics.\n+        match res {\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-\n-                // Record field names for error reporting.\n                 let field_names = self.r.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n-            Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Method, def_id) => {\n+                if self.r.cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                    self.r.has_self.insert(def_id);\n+                }\n             }\n-            _ => bug!(\"unexpected resolution: {:?}\", res)\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n+                let parent = self.r.cstore.def_key(def_id).parent;\n+                if let Some(struct_def_id) = parent.map(|index| DefId { index, ..def_id }) {\n+                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n+                }\n+            }\n+            _ => {}\n         }\n     }\n \n     fn legacy_import_macro(&mut self,\n-                           name: Name,\n+                           name: ast::Name,\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n@@ -997,7 +991,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 |this: &Self, span| this.r.arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n-            parent_scope: this.parent_scope.clone(),\n+            parent_scope: this.parent_scope,\n             imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             use_span_with_attributes: item.span_with_attributes(),\n@@ -1014,9 +1008,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         if let Some(span) = import_all {\n             let directive = macro_use_directive(self, span);\n             self.r.potentially_unused_imports.push(directive);\n-            module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n-                let imported_binding = self.r.import(binding, directive);\n-                self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n+            module.for_each_child(self, |this, ident, ns, binding| if ns == MacroNS {\n+                let imported_binding = this.r.import(binding, directive);\n+                this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {\n@@ -1066,20 +1060,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: ast::NodeId) -> &'a InvocationData<'a> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n         self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n \n-        let invocation_data = self.r.arenas.alloc_invocation_data(InvocationData {\n-            module: self.parent_scope.module,\n-            parent_legacy_scope: self.parent_scope.legacy,\n-            output_legacy_scope: Cell::new(None),\n-        });\n-        let old_invocation_data = self.r.invocations.insert(invoc_id, invocation_data);\n-        assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n+        let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n+        assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        invocation_data\n+        LegacyScope::Invocation(invoc_id)\n     }\n \n     fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n@@ -1180,7 +1169,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(item.id));\n+                self.parent_scope.legacy = self.visit_invoc(item.id);\n                 return\n             }\n             ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n@@ -1199,7 +1188,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n+            self.parent_scope.legacy = self.visit_invoc(stmt.id);\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1267,9 +1256,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            self.parent_scope.module.builtin_attrs.borrow_mut().push((\n-                attr.path.segments[0].ident, self.parent_scope.clone()\n-            ));\n+            self.r.builtin_attrs.push((attr.path.segments[0].ident, self.parent_scope));\n         }\n         visit::walk_attribute(self, attr);\n     }"}, {"sha": "b79e0c2bd3b2672257f12aacd1cbc652b7a86fad", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -73,20 +73,23 @@ crate fn add_typo_suggestion(\n     false\n }\n \n-crate fn add_module_candidates(\n-    module: Module<'_>, names: &mut Vec<TypoSuggestion>, filter_fn: &impl Fn(Res) -> bool\n-) {\n-    for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n-        if let Some(binding) = resolution.borrow().binding {\n-            let res = binding.res();\n-            if filter_fn(res) {\n-                names.push(TypoSuggestion::from_res(ident.name, res));\n+impl<'a> Resolver<'a> {\n+    crate fn add_module_candidates(\n+        &mut self,\n+        module: Module<'a>,\n+        names: &mut Vec<TypoSuggestion>,\n+        filter_fn: &impl Fn(Res) -> bool,\n+    ) {\n+        for (&(ident, _), resolution) in self.resolutions(module).borrow().iter() {\n+            if let Some(binding) = resolution.borrow().binding {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    names.push(TypoSuggestion::from_res(ident.name, res));\n+                }\n             }\n         }\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     /// Combines an error with provided span and emits it.\n     ///\n     /// This takes the error provided, combines it with the span and any additional spans inside the\n@@ -166,12 +169,14 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => {\n-                let mut err = struct_span_err!(self.session,\n-                                                span,\n-                                                E0403,\n-                                                \"the name `{}` is already used for a generic \\\n-                                                parameter in this list of generic parameters\",\n-                                                name);\n+                let mut err = struct_span_err!(\n+                    self.session,\n+                    span,\n+                    E0403,\n+                    \"the name `{}` is already used for a generic \\\n+                     parameter in this item's generic parameters\",\n+                    name,\n+                );\n                 err.span_label(span, \"already used\");\n                 err.span_label(first_use_span, format!(\"first use of `{}`\", name));\n                 err\n@@ -376,9 +381,9 @@ impl<'a> Resolver<'a> {\n                 Scope::DeriveHelpers => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                     if filter_fn(res) {\n-                        for derive in &parent_scope.derives {\n+                        for derive in parent_scope.derives {\n                             let parent_scope =\n-                                &ParentScope { derives: Vec::new(), ..*parent_scope };\n+                                &ParentScope { derives: &[], ..*parent_scope };\n                             if let Ok((Some(ext), _)) = this.resolve_macro_path(\n                                 derive, Some(MacroKind::Derive), parent_scope, false, false\n                             ) {\n@@ -402,10 +407,10 @@ impl<'a> Resolver<'a> {\n                 Scope::CrateRoot => {\n                     let root_ident = Ident::new(kw::PathRoot, ident.span);\n                     let root_module = this.resolve_crate_root(root_ident);\n-                    add_module_candidates(root_module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(root_module, &mut suggestions, filter_fn);\n                 }\n                 Scope::Module(module) => {\n-                    add_module_candidates(module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(module, &mut suggestions, filter_fn);\n                 }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(|(name, binding)| {\n@@ -453,9 +458,9 @@ impl<'a> Resolver<'a> {\n                 Scope::StdLibPrelude => {\n                     if let Some(prelude) = this.prelude {\n                         let mut tmp_suggestions = Vec::new();\n-                        add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n+                        this.add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n                         suggestions.extend(tmp_suggestions.into_iter().filter(|s| {\n-                            use_prelude || this.is_builtin_macro(s.res.opt_def_id())\n+                            use_prelude || this.is_builtin_macro(s.res)\n                         }));\n                     }\n                 }\n@@ -509,11 +514,9 @@ impl<'a> Resolver<'a> {\n         while let Some((in_module,\n                         path_segments,\n                         in_module_is_extern)) = worklist.pop() {\n-            self.populate_module_if_necessary(in_module);\n-\n             // We have to visit module children in deterministic order to avoid\n             // instabilities in reported imports (#43552).\n-            in_module.for_each_child_stable(|ident, ns, name_binding| {\n+            in_module.for_each_child_stable(self, |this, ident, ns, name_binding| {\n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n                 // avoid non-importable candidates as well\n@@ -547,7 +550,7 @@ impl<'a> Resolver<'a> {\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             let did = match res {\n-                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n+                                Res::Def(DefKind::Ctor(..), did) => this.parent(did),\n                                 _ => res.opt_def_id(),\n                             };\n                             candidates.push(ImportSuggestion { did, path });\n@@ -595,7 +598,7 @@ impl<'a> Resolver<'a> {\n         where FilterFn: Fn(Res) -> bool\n     {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n-            lookup_ident, namespace, self.graph_root, Ident::with_empty_ctxt(kw::Crate), &filter_fn\n+            lookup_ident, namespace, self.graph_root, Ident::with_dummy_span(kw::Crate), &filter_fn\n         );\n \n         if lookup_ident.span.rust_2018() {\n@@ -607,8 +610,6 @@ impl<'a> Resolver<'a> {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n                     });\n-                    self.populate_module_if_necessary(&crate_root);\n-\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident, namespace, crate_root, ident, &filter_fn));\n                 }\n@@ -805,7 +806,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ///            at the root of the crate instead of the module where it is defined\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n-        &self,\n+        &mut self,\n         directive: &'b ImportDirective<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n@@ -826,7 +827,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return None;\n         }\n \n-        let resolutions = crate_module.resolutions.borrow();\n+        let resolutions = self.r.resolutions(crate_module).borrow();\n         let resolution = resolutions.get(&(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {"}, {"sha": "1faaf97e981c14fed761bb802019e1098eb264b4", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -526,15 +526,25 @@ Some type parameters have the same name.\n Erroneous code example:\n \n ```compile_fail,E0403\n-fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type\n-                            //        parameter in this type parameter list\n+fn f<T, T>(s: T, u: T) {} // error: the name `T` is already used for a generic\n+                          //        parameter in this item's generic parameters\n ```\n \n Please verify that none of the type parameters are misspelled, and rename any\n clashing parameters. Example:\n \n ```\n-fn foo<T, Y>(s: T, u: Y) {} // ok!\n+fn f<T, Y>(s: T, u: Y) {} // ok!\n+```\n+\n+Type parameters in an associated item also cannot shadow parameters from the\n+containing item:\n+\n+```compile_fail,E0403\n+trait Foo<T> {\n+    fn do_something(&self) -> T;\n+    fn do_something_else<T: Clone>(&self, bar: T);\n+}\n ```\n \"##,\n "}, {"sha": "e15d02a9f7ec7abcd69bc082aaf9a6ecd9b64a0b", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,3 +1,10 @@\n+//! \"Late resolution\" is the pass that resolves most of names in a crate beside imports and macros.\n+//! It runs when the crate is fully expanded and its module structure is fully built.\n+//! So it just walks through the crate and resolves all the expressions, types, etc.\n+//!\n+//! If you wonder why there's no `early.rs`, that's because it's split into three files -\n+//! `build_reduced_graph.rs`, `macros.rs` and `resolve_imports.rs`.\n+\n use GenericParameters::*;\n use RibKind::*;\n \n@@ -104,6 +111,24 @@ crate enum RibKind<'a> {\n     TyParamAsConstParamTy,\n }\n \n+impl RibKind<'_> {\n+    // Whether this rib kind contains generic parameters, as opposed to local\n+    // variables.\n+    crate fn contains_params(&self) -> bool {\n+        match self {\n+            NormalRibKind\n+            | FnItemRibKind\n+            | ConstantItemRibKind\n+            | ModuleRibKind(_)\n+            | MacroDefinition(_) => false,\n+            AssocItemRibKind\n+            | ItemRibKind\n+            | ForwardTyParamBanRibKind\n+            | TyParamAsConstParamTy => true,\n+        }\n+    }\n+}\n+\n /// A single local scope.\n ///\n /// A rib represents a scope names can live in. Note that these appear in many places, not just\n@@ -352,7 +377,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }\n             TyKind::ImplicitSelf => {\n-                let self_ty = Ident::with_empty_ctxt(kw::SelfUpper);\n+                let self_ty = Ident::with_dummy_span(kw::SelfUpper);\n                 let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n@@ -442,7 +467,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 GenericParamKind::Type { ref default, .. } => {\n                     found_default |= default.is_some();\n                     if found_default {\n-                        Some((Ident::with_empty_ctxt(param.ident.name), Res::Err))\n+                        Some((Ident::with_dummy_span(param.ident.name), Res::Err))\n                     } else {\n                         None\n                     }\n@@ -459,7 +484,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     false\n                 }\n             })\n-            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Res::Err)));\n+            .map(|param| (Ident::with_dummy_span(param.ident.name), Res::Err)));\n \n         for param in &generics.params {\n             match param.kind {\n@@ -476,7 +501,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     }\n \n                     // Allow all following defaults to refer to this type parameter.\n-                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n+                    default_ban_rib.bindings.remove(&Ident::with_dummy_span(param.ident.name));\n                 }\n                 GenericParamKind::Const { ref ty } => {\n                     self.ribs[TypeNS].push(const_ty_param_ban_rib);\n@@ -501,8 +526,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n         // During late resolution we only track the module component of the parent scope,\n         // although it may be useful to track other components as well for diagnostics.\n-        let parent_scope = resolver.dummy_parent_scope();\n         let graph_root = resolver.graph_root;\n+        let parent_scope = ParentScope::module(graph_root);\n         LateResolutionVisitor {\n             r: resolver,\n             parent_scope,\n@@ -574,7 +599,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n-            self.r.finalize_current_module_macro_resolutions(module);\n             let ret = f(self);\n \n             self.parent_scope.module = orig_module;\n@@ -792,6 +816,19 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut function_value_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap::default();\n+                // We also can't shadow bindings from the parent item\n+                if let AssocItemRibKind = rib_kind {\n+                    let mut add_bindings_for_ns = |ns| {\n+                        let parent_rib = self.ribs[ns].iter()\n+                            .rfind(|rib| if let ItemRibKind = rib.kind { true } else { false })\n+                            .expect(\"associated item outside of an item\");\n+                        seen_bindings.extend(\n+                            parent_rib.bindings.iter().map(|(ident, _)| (*ident, ident.span)),\n+                        );\n+                    };\n+                    add_bindings_for_ns(ValueNS);\n+                    add_bindings_for_ns(TypeNS);\n+                }\n                 for param in &generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {}\n@@ -965,7 +1002,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n-        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n         self.ribs[TypeNS].pop();\n@@ -976,7 +1013,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     {\n         let self_res = Res::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n         self.ribs[ValueNS].push(self_type_rib);\n         f(self);\n         self.ribs[ValueNS].pop();\n@@ -1227,7 +1264,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.parent_scope.module = anonymous_module;\n-            self.r.finalize_current_module_macro_resolutions(anonymous_module);\n         } else {\n             self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n@@ -1476,7 +1512,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     self.r.trait_map.insert(id, traits);\n                 }\n \n-                let mut std_path = vec![Segment::from_ident(Ident::with_empty_ctxt(sym::std))];\n+                let mut std_path = vec![Segment::from_ident(Ident::with_dummy_span(sym::std))];\n                 std_path.extend(path);\n                 if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n                     let cl = CrateLint::No;\n@@ -1507,7 +1543,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n         let binding = self.resolve_ident_in_lexical_scope(\n-            Ident::with_empty_ctxt(kw::SelfUpper),\n+            Ident::with_dummy_span(kw::SelfUpper),\n             TypeNS,\n             None,\n             span,\n@@ -1924,7 +1960,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut traits = module.traits.borrow_mut();\n         if traits.is_none() {\n             let mut collected_traits = Vec::new();\n-            module.for_each_child(|name, ns, binding| {\n+            module.for_each_child(self.r, |_, name, ns, binding| {\n                 if ns != TypeNS { return }\n                 match binding.res() {\n                     Res::Def(DefKind::Trait, _) |\n@@ -1984,7 +2020,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n-        self.finalize_current_module_macro_resolutions(self.graph_root);\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.unused_labels.iter() {"}, {"sha": "a822fa049ca1c5467175d881af0110230c7d1b4c", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,8 +1,7 @@\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n use crate::path_names_to_string;\n-use crate::diagnostics::{add_typo_suggestion, add_module_candidates};\n-use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n+use crate::diagnostics::{add_typo_suggestion, ImportSuggestion, TypoSuggestion};\n use crate::late::{LateResolutionVisitor, RibKind};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -548,7 +547,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 // Items in scope\n                 if let RibKind::ModuleRibKind(module) = rib.kind {\n                     // Items from this module\n-                    add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n \n                     if let ModuleKind::Block(..) = module.kind {\n                         // We can see through blocks\n@@ -577,7 +576,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {\n-                                add_module_candidates(prelude, &mut names, &filter_fn);\n+                                self.r.add_module_candidates(prelude, &mut names, &filter_fn);\n                             }\n                         }\n                         break;\n@@ -599,7 +598,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n                 }\n             }\n         }\n@@ -717,9 +716,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             // abort if the module is already found\n             if result.is_some() { break; }\n \n-            self.r.populate_module_if_necessary(in_module);\n-\n-            in_module.for_each_child_stable(|ident, _, name_binding| {\n+            in_module.for_each_child_stable(self.r, |_, ident, _, name_binding| {\n                 // abort if the module is already found or if name_binding is private external\n                 if result.is_some() || !name_binding.vis.is_visible_locally() {\n                     return\n@@ -750,10 +747,8 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n     fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n         self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.r.populate_module_if_necessary(enum_module);\n-\n             let mut variants = Vec::new();\n-            enum_module.for_each_child_stable(|ident, _, name_binding| {\n+            enum_module.for_each_child_stable(self.r, |_, ident, _, name_binding| {\n                 if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n                     segms.push(ast::PathSegment::from_ident(ident));"}, {"sha": "984473d781e62c0355611f1685d9932a8f6ab173", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 112, "deletions": 62, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,3 +1,12 @@\n+//! This crate is responsible for the part of name resolution that doesn't require type checker.\n+//!\n+//! Module structure of the crate is built here.\n+//! Paths in macros, imports, expressions, types, patterns are resolved here.\n+//! Label names are resolved here as well.\n+//!\n+//! Type-relative name resolution (methods, fields, associated items) happens in `librustc_typeck`.\n+//! Lifetime names are resolved in `librustc/middle/resolve_lifetime.rs`.\n+\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(crate_visibility_modifier)]\n@@ -54,7 +63,7 @@ use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use late::{PathSource, Rib, RibKind::*};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, LegacyScope};\n+use macros::{LegacyBinding, LegacyScope};\n \n type Res = def::Res<NodeId>;\n \n@@ -122,12 +131,25 @@ enum ScopeSet {\n /// Serves as a starting point for the scope visitor.\n /// This struct is currently used only for early resolution (imports and macros),\n /// but not for late resolution yet.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n     expansion: ExpnId,\n     legacy: LegacyScope<'a>,\n-    derives: Vec<ast::Path>,\n+    derives: &'a [ast::Path],\n+}\n+\n+impl<'a> ParentScope<'a> {\n+    /// Creates a parent scope with the passed argument used as the module scope component,\n+    /// and other scope components set to default empty values.\n+    pub fn module(module: Module<'a>) -> ParentScope<'a> {\n+        ParentScope {\n+            module,\n+            expansion: ExpnId::root(),\n+            legacy: LegacyScope::Empty,\n+            derives: &[],\n+        }\n+    }\n }\n \n #[derive(Eq)]\n@@ -274,7 +296,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n@@ -284,7 +306,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         // don't insert between attributes and an item\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());\n@@ -409,6 +431,8 @@ impl ModuleKind {\n     }\n }\n \n+type Resolutions<'a> = RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>;\n+\n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n@@ -417,12 +441,11 @@ pub struct ModuleData<'a> {\n     // The def id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: DefId,\n \n-    resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    single_segment_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n-                                                   Option<&'a NameBinding<'a>>)>>,\n-    multi_segment_macro_resolutions: RefCell<Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n-                                                  Option<Res>)>>,\n-    builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n+    // Mapping between names and their (possibly in-progress) resolutions in this module.\n+    // Resolutions in modules from other crates are not populated until accessed.\n+    lazy_resolutions: Resolutions<'a>,\n+    // True if this is a module from other crate that needs to be populated on access.\n+    populate_on_access: Cell<bool>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n@@ -435,11 +458,6 @@ pub struct ModuleData<'a> {\n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n     traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n \n-    // Whether this module is populated. If not populated, any attempt to\n-    // access the children must be preceded with a\n-    // `populate_module_if_necessary` call.\n-    populated: Cell<bool>,\n-\n     /// Span of the module itself. Used for error reporting.\n     span: Span,\n \n@@ -458,33 +476,34 @@ impl<'a> ModuleData<'a> {\n             parent,\n             kind,\n             normal_ancestor_id,\n-            resolutions: Default::default(),\n-            single_segment_macro_resolutions: RefCell::new(Vec::new()),\n-            multi_segment_macro_resolutions: RefCell::new(Vec::new()),\n-            builtin_attrs: RefCell::new(Vec::new()),\n+            lazy_resolutions: Default::default(),\n+            populate_on_access: Cell::new(!normal_ancestor_id.is_local()),\n             unresolved_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),\n             traits: RefCell::new(None),\n-            populated: Cell::new(normal_ancestor_id.is_local()),\n             span,\n             expansion,\n         }\n     }\n \n-    fn for_each_child<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(ident, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+    fn for_each_child<R, F>(&'a self, resolver: &mut R, mut f: F)\n+        where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n+    {\n+        for (&(ident, ns), name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n         }\n     }\n \n-    fn for_each_child_stable<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        let resolutions = self.resolutions.borrow();\n+    fn for_each_child_stable<R, F>(&'a self, resolver: &mut R, mut f: F)\n+        where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n+    {\n+        let resolutions = resolver.as_mut().resolutions(self).borrow();\n         let mut resolutions = resolutions.iter().collect::<Vec<_>>();\n         resolutions.sort_by_cached_key(|&(&(ident, ns), _)| (ident.as_str(), ns));\n         for &(&(ident, ns), &resolution) in resolutions.iter() {\n-            resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+            resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n         }\n     }\n \n@@ -807,7 +826,7 @@ pub struct Resolver<'a> {\n \n     pub definitions: Definitions,\n \n-    graph_root: Module<'a>,\n+    pub graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n     pub extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n@@ -896,15 +915,24 @@ pub struct Resolver<'a> {\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n     proc_macro_stubs: NodeSet,\n+    /// Traces collected during macro resolution and validated when it's complete.\n+    single_segment_macro_resolutions: Vec<(Ident, MacroKind, ParentScope<'a>,\n+                                           Option<&'a NameBinding<'a>>)>,\n+    multi_segment_macro_resolutions: Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n+                                          Option<Res>)>,\n+    builtin_attrs: Vec<(Ident, ParentScope<'a>)>,\n     /// Some built-in derives mark items they are applied to so they are treated specially later.\n     /// Derive macros cannot modify the item themselves and have to store the markers in the global\n     /// context, so they attach the markers to derive container IDs using this resolver table.\n     /// FIXME: Find a way for `PartialEq` and `Eq` to emulate `#[structural_match]`\n     /// by marking the produced impls rather than the original items.\n     special_derives: FxHashMap<ExpnId, SpecialDerives>,\n-\n-    /// Maps the `ExpnId` of an expansion to its containing module or block.\n-    invocations: FxHashMap<ExpnId, &'a InvocationData<'a>>,\n+    /// Parent scopes in which the macros were invoked.\n+    /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n+    invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n+    /// Legacy scopes *produced* by expanding the macro invocations,\n+    /// include all the `macro_rules` items and other invocations generated by them.\n+    output_legacy_scopes: FxHashMap<ExpnId, LegacyScope<'a>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n@@ -927,8 +955,8 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n-    invocation_data: arena::TypedArena<InvocationData<'a>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n+    ast_paths: arena::TypedArena<ast::Path>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -952,13 +980,16 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n-    fn alloc_invocation_data(&'a self, expansion_data: InvocationData<'a>)\n-                             -> &'a InvocationData<'a> {\n-        self.invocation_data.alloc(expansion_data)\n-    }\n     fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n         self.legacy_bindings.alloc(binding)\n     }\n+    fn alloc_ast_paths(&'a self, paths: &[ast::Path]) -> &'a [ast::Path] {\n+        self.ast_paths.alloc_from_iter(paths.iter().cloned())\n+    }\n+}\n+\n+impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a> { self }\n }\n \n impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n@@ -985,19 +1016,19 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         } else {\n             kw::Crate\n         };\n-        let segments = iter::once(Ident::with_empty_ctxt(root))\n+        let segments = iter::once(Ident::with_dummy_span(root))\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n-                    .map(Ident::with_empty_ctxt)\n+                    .map(Ident::with_dummy_span)\n             ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n         let path = ast::Path {\n             span,\n             segments,\n         };\n \n-        let parent_scope = &self.dummy_parent_scope();\n+        let parent_scope = &ParentScope::module(self.graph_root);\n         let res = match self.resolve_ast_path(&path, ns, parent_scope) {\n             Ok(res) => res,\n             Err((span, error)) => {\n@@ -1060,18 +1091,17 @@ impl<'a> Resolver<'a> {\n                                        .collect();\n \n         if !attr::contains_name(&krate.attrs, sym::no_core) {\n-            extern_prelude.insert(Ident::with_empty_ctxt(sym::core), Default::default());\n+            extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n             if !attr::contains_name(&krate.attrs, sym::no_std) {\n-                extern_prelude.insert(Ident::with_empty_ctxt(sym::std), Default::default());\n+                extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n                 if session.rust_2018() {\n-                    extern_prelude.insert(Ident::with_empty_ctxt(sym::meta), Default::default());\n+                    extern_prelude.insert(Ident::with_dummy_span(sym::meta), Default::default());\n                 }\n             }\n         }\n \n-        let mut invocations = FxHashMap::default();\n-        invocations.insert(ExpnId::root(),\n-                           arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n+        let mut invocation_parent_scopes = FxHashMap::default();\n+        invocation_parent_scopes.insert(ExpnId::root(), ParentScope::module(graph_root));\n \n         let mut macro_defs = FxHashMap::default();\n         macro_defs.insert(ExpnId::root(), root_def_id);\n@@ -1143,14 +1173,18 @@ impl<'a> Resolver<'a> {\n             dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n-            invocations,\n+            invocation_parent_scopes,\n+            output_legacy_scopes: Default::default(),\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: Default::default(),\n             unused_macros: Default::default(),\n             proc_macro_stubs: Default::default(),\n+            single_segment_macro_resolutions: Default::default(),\n+            multi_segment_macro_resolutions: Default::default(),\n+            builtin_attrs: Default::default(),\n             special_derives: Default::default(),\n             active_features:\n                 features.declared_lib_features.iter().map(|(feat, ..)| *feat)\n@@ -1182,9 +1216,8 @@ impl<'a> Resolver<'a> {\n         f(self, MacroNS);\n     }\n \n-    fn is_builtin_macro(&mut self, def_id: Option<DefId>) -> bool {\n-        def_id.and_then(|def_id| self.get_macro_by_def_id(def_id))\n-              .map_or(false, |ext| ext.is_builtin)\n+    fn is_builtin_macro(&mut self, res: Res) -> bool {\n+        self.get_macro(res).map_or(false, |ext| ext.is_builtin)\n     }\n \n     fn macro_def(&self, mut ctxt: SyntaxContext) -> DefId {\n@@ -1203,6 +1236,7 @@ impl<'a> Resolver<'a> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         ImportResolver { r: self }.finalize_imports();\n+        self.finalize_macro_resolutions();\n \n         self.late_resolve_crate(krate);\n \n@@ -1223,6 +1257,20 @@ impl<'a> Resolver<'a> {\n         self.arenas.alloc_module(module)\n     }\n \n+    fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n+        if module.populate_on_access.get() {\n+            module.populate_on_access.set(false);\n+            self.build_reduced_graph_external(module);\n+        }\n+        &module.lazy_resolutions\n+    }\n+\n+    fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n+                  -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n+               .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n     fn record_use(&mut self, ident: Ident, ns: Namespace,\n                   used_binding: &'a NameBinding<'a>, is_lexical_scope: bool) {\n         if let Some((b2, kind)) = used_binding.ambiguity {\n@@ -1319,13 +1367,15 @@ impl<'a> Resolver<'a> {\n             ScopeSet::AbsolutePath(ns) => (ns, true),\n             ScopeSet::Macro(_) => (MacroNS, false),\n         };\n+        // Jump out of trait or enum modules, they do not act as scopes.\n+        let module = parent_scope.module.nearest_item_scope();\n         let mut scope = match ns {\n             _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(parent_scope.module),\n+            TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers,\n         };\n         let mut ident = ident.modern();\n-        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n+        let mut use_prelude = !module.no_implicit_prelude;\n \n         loop {\n             let visit = match scope {\n@@ -1355,10 +1405,11 @@ impl<'a> Resolver<'a> {\n                     LegacyScope::Binding(binding) => Scope::MacroRules(\n                         binding.parent_legacy_scope\n                     ),\n-                    LegacyScope::Invocation(invoc) => Scope::MacroRules(\n-                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n+                    LegacyScope::Invocation(invoc_id) => Scope::MacroRules(\n+                        self.output_legacy_scopes.get(&invoc_id).cloned()\n+                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].legacy)\n                     ),\n-                    LegacyScope::Empty => Scope::Module(parent_scope.module),\n+                    LegacyScope::Empty => Scope::Module(module),\n                 }\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -1430,7 +1481,7 @@ impl<'a> Resolver<'a> {\n         }\n         let (general_span, modern_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n-            let empty_span = ident.span.with_ctxt(SyntaxContext::empty());\n+            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n             (empty_span, empty_span)\n         } else if ns == TypeNS {\n             let modern_span = ident.span.modern();\n@@ -1448,7 +1499,7 @@ impl<'a> Resolver<'a> {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n             // Use the rib kind to determine whether we are resolving parameters\n             // (modern hygiene) or local variables (legacy hygiene).\n-            let rib_ident = if let AssocItemRibKind | ItemRibKind = ribs[i].kind {\n+            let rib_ident = if ribs[i].kind.contains_params() {\n                 modern_ident\n             } else {\n                 ident\n@@ -1501,7 +1552,7 @@ impl<'a> Resolver<'a> {\n                 self.hygienic_lexical_parent(module, &mut ident.span)\n             };\n             module = unwrap_or!(opt_module, break);\n-            let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n+            let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n             let result = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n@@ -1637,7 +1688,7 @@ impl<'a> Resolver<'a> {\n             ModuleOrUniformRoot::Module(m) => {\n                 if let Some(def) = ident.span.modernize_and_adjust(m.expansion) {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }\n@@ -2606,7 +2657,6 @@ impl<'a> Resolver<'a> {\n                     return None;\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n-                self.populate_module_if_necessary(&crate_root);\n                 Some((crate_root, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                     .to_name_binding(self.arenas))\n             }\n@@ -2624,7 +2674,7 @@ impl<'a> Resolver<'a> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n-                segments: iter::once(Ident::with_empty_ctxt(kw::PathRoot))\n+                segments: iter::once(Ident::with_dummy_span(kw::PathRoot))\n                     .chain({\n                         path_str.split(\"::\").skip(1).map(Ident::from_str)\n                     })\n@@ -2645,7 +2695,7 @@ impl<'a> Resolver<'a> {\n             let def_id = self.definitions.local_def_id(module_id);\n             self.module_map.get(&def_id).copied().unwrap_or(self.graph_root)\n         });\n-        let parent_scope = &ParentScope { module, ..self.dummy_parent_scope() };\n+        let parent_scope = &ParentScope::module(module);\n         let res = self.resolve_ast_path(&path, ns, parent_scope).map_err(|_| ())?;\n         Ok((path, res))\n     }\n@@ -2713,7 +2763,7 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n     fn collect_mod(names: &mut Vec<Ident>, module: Module<'_>) {\n         if let ModuleKind::Def(.., name) = module.kind {\n             if let Some(parent) = module.parent {\n-                names.push(Ident::with_empty_ctxt(name));\n+                names.push(Ident::with_dummy_span(name));\n                 collect_mod(names, parent);\n             }\n         } else {"}, {"sha": "6f49377c187aa91a8103159d65c7c41cedb0a80f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 50, "deletions": 98, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,12 +1,13 @@\n+//! A bunch of methods and structures more or less related to resolving macros and\n+//! interface provided by `Resolver` to macro expander.\n+\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n-use crate::{Module, ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n+use crate::{ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n-use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n-use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident};\n@@ -15,43 +16,18 @@ use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, ExpnId, ExpnInfo, ExpnKind};\n+use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::cell::Cell;\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n type Res = def::Res<ast::NodeId>;\n \n-// FIXME: Merge this with `ParentScope`.\n-#[derive(Clone, Debug)]\n-pub struct InvocationData<'a> {\n-    /// The module in which the macro was invoked.\n-    crate module: Module<'a>,\n-    /// The legacy scope in which the macro was invoked.\n-    /// The invocation path is resolved in this scope.\n-    crate parent_legacy_scope: LegacyScope<'a>,\n-    /// The legacy scope *produced* by expanding this macro invocation,\n-    /// includes all the macro_rules items, other invocations, etc generated by it.\n-    /// `None` if the macro is not expanded yet.\n-    crate output_legacy_scope: Cell<Option<LegacyScope<'a>>>,\n-}\n-\n-impl<'a> InvocationData<'a> {\n-    pub fn root(graph_root: Module<'a>) -> Self {\n-        InvocationData {\n-            module: graph_root,\n-            parent_legacy_scope: LegacyScope::Empty,\n-            output_legacy_scope: Cell::new(None),\n-        }\n-    }\n-}\n-\n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n #[derive(Debug)]\n@@ -75,7 +51,7 @@ pub enum LegacyScope<'a> {\n     Binding(&'a LegacyBinding<'a>),\n     /// The scope introduced by a macro invocation that can potentially\n     /// create a `macro_rules!` macro definition.\n-    Invocation(&'a InvocationData<'a>),\n+    Invocation(ExpnId),\n }\n \n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n@@ -120,17 +96,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n-        let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::default(\n+        let expn_id = ExpnId::fresh(Some(ExpnData::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n-        ));\n-        let expn_id = span.ctxt().outer_expn();\n+        )));\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n+        self.invocation_parent_scopes.insert(expn_id, ParentScope::module(module));\n         self.definitions.set_invocation_parent(expn_id, module.def_id().unwrap().index);\n-        self.invocations.insert(expn_id, self.arenas.alloc_invocation_data(InvocationData {\n-            module,\n-            parent_legacy_scope: LegacyScope::Empty,\n-            output_legacy_scope: Cell::new(None),\n-        }));\n         expn_id\n     }\n \n@@ -144,29 +115,23 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-    fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]) {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expn_id));\n-\n-        let invocation = self.invocations[&expn_id];\n-        invocation.module.unresolved_invocations.borrow_mut().remove(&expn_id);\n-        invocation.module.unresolved_invocations.borrow_mut().extend(derives);\n-        let parent_def = self.definitions.invocation_parent(expn_id);\n+    fn visit_ast_fragment_with_placeholders(\n+        &mut self, expansion: ExpnId, fragment: &AstFragment, derives: &[ExpnId]\n+    ) {\n+        // Fill in some data for derives if the fragment is from a derive container.\n+        // We are inside the `expansion` now, but other parent scope components are still the same.\n+        let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n+        let parent_def = self.definitions.invocation_parent(expansion);\n+        self.invocation_parent_scopes.extend(derives.iter().map(|&derive| (derive, parent_scope)));\n         for &derive_invoc_id in derives {\n             self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n         }\n-        self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n-        let mut visitor = BuildReducedGraphVisitor {\n-            r: self,\n-            parent_scope: ParentScope {\n-                module: invocation.module,\n-                expansion: expn_id,\n-                legacy: invocation.parent_legacy_scope,\n-                derives: Vec::new(),\n-            },\n-        };\n-        fragment.visit_with(&mut visitor);\n-        invocation.output_legacy_scope.set(Some(visitor.parent_scope.legacy));\n+        parent_scope.module.unresolved_invocations.borrow_mut().remove(&expansion);\n+        parent_scope.module.unresolved_invocations.borrow_mut().extend(derives);\n+\n+        // Integrate the new AST fragment into all the definition and module structures.\n+        let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n+        self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -182,24 +147,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n-        let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n+        let parent_scope = self.invocation_parent_scopes[&invoc_id];\n+        let (path, kind, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n-                (&attr.path, MacroKind::Attr, derives.clone(), after_derive),\n+                (&attr.path, MacroKind::Attr, self.arenas.alloc_ast_paths(derives), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n-                (&mac.node.path, MacroKind::Bang, Vec::new(), false),\n+                (&mac.path, MacroKind::Bang, &[][..], false),\n             InvocationKind::Derive { ref path, .. } =>\n-                (path, MacroKind::Derive, Vec::new(), false),\n+                (path, MacroKind::Derive, &[][..], false),\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n                 // Block expansion of derives in the container until we know whether one of them\n                 // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n                 // it's not a `Copy` and we don't need to do anything, or it's a `Copy` and it\n                 // will automatically knows about itself.\n                 let mut result = Ok(None);\n                 if derives.len() > 1 {\n-                    let parent_scope = &self.invoc_parent_scope(invoc_id, Vec::new());\n                     for path in derives {\n                         match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      parent_scope, true, force) {\n+                                                      &parent_scope, true, force) {\n                             Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n                                 self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n                                 return Ok(None);\n@@ -213,11 +178,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         };\n \n-        let parent_scope = &self.invoc_parent_scope(invoc_id, derives_in_scope);\n+        // Derives are not included when `invocations` are collected, so we have to add them here.\n+        let parent_scope = &ParentScope { derives, ..parent_scope };\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc.expansion_data.id.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n+        invoc.expansion_data.id.set_expn_data(\n+            ext.expn_data(parent_scope.expansion, span, fast_print_path(path))\n+        );\n \n         if let Res::Def(_, def_id) = res {\n             if after_derive {\n@@ -251,20 +219,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn dummy_parent_scope(&self) -> ParentScope<'a> {\n-        self.invoc_parent_scope(ExpnId::root(), Vec::new())\n-    }\n-\n-    fn invoc_parent_scope(&self, invoc_id: ExpnId, derives: Vec<ast::Path>) -> ParentScope<'a> {\n-        let invoc = self.invocations[&invoc_id];\n-        ParentScope {\n-            module: invoc.module.nearest_item_scope(),\n-            expansion: invoc_id.parent(),\n-            legacy: invoc.parent_legacy_scope,\n-            derives,\n-        }\n-    }\n-\n     /// Resolve macro path with error reporting and recovery.\n     fn smart_resolve_macro_path(\n         &mut self,\n@@ -346,8 +300,7 @@ impl<'a> Resolver<'a> {\n \n         // Possibly apply the macro helper hack\n         if kind == Some(MacroKind::Bang) && path.len() == 1 &&\n-           path[0].ident.span.ctxt().outer_expn_info()\n-               .map_or(false, |info| info.local_inner_macros) {\n+           path[0].ident.span.ctxt().outer_expn_data().local_inner_macros {\n             let root = Ident::new(kw::DollarCrate, path[0].ident.span);\n             path.insert(0, Segment::from_ident(root));\n         }\n@@ -367,8 +320,8 @@ impl<'a> Resolver<'a> {\n \n             if trace {\n                 let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n-                parent_scope.module.multi_segment_macro_resolutions.borrow_mut()\n-                    .push((path, path_span, kind, parent_scope.clone(), res.ok()));\n+                self.multi_segment_macro_resolutions\n+                    .push((path, path_span, kind, *parent_scope, res.ok()));\n             }\n \n             self.prohibit_imported_non_macro_attrs(None, res.ok(), path_span);\n@@ -384,8 +337,8 @@ impl<'a> Resolver<'a> {\n \n             if trace {\n                 let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n-                parent_scope.module.single_segment_macro_resolutions.borrow_mut()\n-                    .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n+                self.single_segment_macro_resolutions\n+                    .push((path[0].ident, kind, *parent_scope, binding.ok()));\n             }\n \n             let res = binding.map(|binding| binding.res());\n@@ -454,8 +407,8 @@ impl<'a> Resolver<'a> {\n             let result = match scope {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n-                    for derive in &parent_scope.derives {\n-                        let parent_scope = &ParentScope { derives: Vec::new(), ..*parent_scope };\n+                    for derive in parent_scope.derives {\n+                        let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n                         match this.resolve_macro_path(derive, Some(MacroKind::Derive),\n                                                       parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n@@ -475,8 +428,9 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n                         Ok((legacy_binding.binding, Flags::MACRO_RULES)),\n-                    LegacyScope::Invocation(invoc) if invoc.output_legacy_scope.get().is_none() =>\n-                        Err(Determinacy::Undetermined),\n+                    LegacyScope::Invocation(invoc_id)\n+                        if !this.output_legacy_scopes.contains_key(&invoc_id) =>\n+                            Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n                 Scope::CrateRoot => {\n@@ -500,7 +454,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::Module(module) => {\n-                    let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n+                    let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n                     let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n@@ -575,7 +529,7 @@ impl<'a> Resolver<'a> {\n                             false,\n                             path_span,\n                         ) {\n-                            if use_prelude || this.is_builtin_macro(binding.res().opt_def_id()) {\n+                            if use_prelude || this.is_builtin_macro(binding.res()) {\n                                 result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n                             }\n                         }\n@@ -694,7 +648,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn finalize_current_module_macro_resolutions(&mut self, module: Module<'a>) {\n+    crate fn finalize_macro_resolutions(&mut self) {\n         let check_consistency = |this: &mut Self, path: &[Segment], span, kind: MacroKind,\n                                  initial_res: Option<Res>, res: Res| {\n             if let Some(initial_res) = initial_res {\n@@ -730,8 +684,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let macro_resolutions =\n-            mem::take(&mut *module.multi_segment_macro_resolutions.borrow_mut());\n+        let macro_resolutions = mem::take(&mut self.multi_segment_macro_resolutions);\n         for (mut path, path_span, kind, parent_scope, initial_res) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n@@ -758,8 +711,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let macro_resolutions =\n-            mem::take(&mut *module.single_segment_macro_resolutions.borrow_mut());\n+        let macro_resolutions = mem::take(&mut self.single_segment_macro_resolutions);\n         for (ident, kind, parent_scope, initial_binding) in macro_resolutions {\n             match self.early_resolve_ident_in_lexical_scope(ident, ScopeSet::Macro(kind),\n                                                             &parent_scope, true, true, ident.span) {\n@@ -784,7 +736,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let builtin_attrs = mem::take(&mut *module.builtin_attrs.borrow_mut());\n+        let builtin_attrs = mem::take(&mut self.builtin_attrs);\n         for (ident, parent_scope) in builtin_attrs {\n             let _ = self.early_resolve_ident_in_lexical_scope(\n                 ident, ScopeSet::Macro(MacroKind::Attr), &parent_scope, true, true, ident.span"}, {"sha": "b49f1868706695674667f097f10563e96b2bf7e0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,13 +1,14 @@\n+//! A bunch of methods and structures more or less related to resolving imports.\n+\n use ImportDirectiveSubclass::*;\n \n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope, Weak};\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, ResolutionError, Segment};\n+use crate::{Resolver, ResolutionError, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n-use crate::ModuleKind;\n use crate::diagnostics::Suggestion;\n \n use errors::Applicability;\n@@ -35,7 +36,7 @@ use syntax_pos::{MultiSpan, Span};\n \n use log::*;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::{mem, ptr};\n \n type Res = def::Res<NodeId>;\n@@ -159,12 +160,6 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n-                  -> &'a RefCell<NameResolution<'a>> {\n-        *module.resolutions.borrow_mut().entry((ident.modern(), ns))\n-               .or_insert_with(|| self.arenas.alloc_name_resolution())\n-    }\n-\n     crate fn resolve_ident_in_module_unadjusted(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n@@ -240,8 +235,6 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        self.populate_module_if_necessary(module);\n-\n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n@@ -394,7 +387,7 @@ impl<'a> Resolver<'a> {\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n                 Some(None) => {}\n@@ -848,7 +841,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         directive.vis.set(orig_vis);\n         let module = match path_res {\n             PathResult::Module(module) => {\n-                // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                // Consistency checks, analogous to `finalize_macro_resolutions`.\n                 if let Some(initial_module) = directive.imported_module.get() {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n                         span_bug!(directive.span, \"inconsistent resolution for an import\");\n@@ -973,7 +966,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             match binding {\n                 Ok(binding) => {\n-                    // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                    // Consistency checks, analogous to `finalize_macro_resolutions`.\n                     let initial_res = source_bindings[ns].get().map(|initial_binding| {\n                         all_ns_err = false;\n                         if let Some(target_binding) = target_bindings[ns].get() {\n@@ -1025,7 +1018,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) => Some(module.resolutions.borrow()),\n+                    ModuleOrUniformRoot::Module(module) =>\n+                        Some(self.r.resolutions(module).borrow()),\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n@@ -1263,8 +1257,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n         };\n \n-        self.r.populate_module_if_necessary(module);\n-\n         if module.is_trait() {\n             self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n@@ -1280,8 +1272,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n-            resolution.borrow().binding().map(|binding| (ident, binding))\n+        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (*ident, binding))\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n@@ -1308,7 +1300,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n \n-        for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {\n+        for (&(ident, ns), resolution) in self.r.resolutions(module).borrow().iter() {\n             let resolution = &mut *resolution.borrow_mut();\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n@@ -1367,8 +1359,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n                             _ => bug!(\"module should exist\"),\n                         };\n-                        let resolutions = imported_module.parent.expect(\"parent should exist\")\n-                            .resolutions.borrow();\n+                        let parent_module = imported_module.parent.expect(\"parent should exist\");\n+                        let resolutions = self.r.resolutions(parent_module).borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n                         let enum_ident = directive.module_path[enum_path_segment_index].ident;\n "}, {"sha": "9068605b0753c4f09fc2ebfe2101d038a067d126", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -32,7 +32,7 @@ use syntax::print::pprust::{\n     ty_to_string\n };\n use syntax::ptr::P;\n-use syntax::source_map::{Spanned, DUMMY_SP, respan};\n+use syntax::source_map::{DUMMY_SP, respan};\n use syntax::walk_list;\n use syntax_pos::*;\n \n@@ -557,11 +557,11 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n         for variant in &enum_definition.variants {\n-            let name = variant.node.ident.name.to_string();\n+            let name = variant.ident.name.to_string();\n             let qualname = format!(\"{}::{}\", enum_data.qualname, name);\n-            let name_span = variant.node.ident.span;\n+            let name_span = variant.ident.span;\n \n-            match variant.node.data {\n+            match variant.data {\n                 ast::VariantData::Struct(ref fields, ..) => {\n                     let fields_str = fields\n                         .iter()\n@@ -574,7 +574,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n+                        let id = id_from_node_id(variant.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -589,10 +589,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                                 parent,\n                                 children: vec![],\n                                 decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n+                                docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n                                 attributes: lower_attributes(\n-                                    variant.node.attrs.clone(),\n+                                    variant.attrs.clone(),\n                                     &self.save_ctxt,\n                                 ),\n                             },\n@@ -612,7 +612,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     }\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n+                        let id = id_from_node_id(variant.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -627,10 +627,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                                 parent,\n                                 children: vec![],\n                                 decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n+                                docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n                                 attributes: lower_attributes(\n-                                    variant.node.attrs.clone(),\n+                                    variant.attrs.clone(),\n                                     &self.save_ctxt,\n                                 ),\n                             },\n@@ -640,8 +640,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             }\n \n \n-            for field in variant.node.data.fields() {\n-                self.process_struct_field_def(field, variant.node.id);\n+            for field in variant.data.fields() {\n+                self.process_struct_field_def(field, variant.id);\n                 self.visit_ty(&field.ty);\n             }\n         }\n@@ -879,7 +879,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 };\n                 let variant = adt.variant_of_res(self.save_ctxt.get_path_res(p.id));\n \n-                for &Spanned { node: ref field, .. } in fields {\n+                for field in fields {\n                     if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n                         if !self.span.filter_generated(field.ident.span) {\n                             let span = self.span_from_span(field.ident.span);"}, {"sha": "0bbbbb8249c207c7b284e7d53dc4d4b41a340a40", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -277,7 +277,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 filter!(self.span_utils, item.ident.span);\n                 let variants_str = def.variants\n                     .iter()\n-                    .map(|v| v.node.ident.to_string())\n+                    .map(|v| v.ident.to_string())\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n                 let value = format!(\"{}::{{{}}}\", name, variants_str);\n@@ -291,7 +291,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     parent: None,\n                     children: def.variants\n                         .iter()\n-                        .map(|v| id_from_node_id(v.node.id, self))\n+                        .map(|v| id_from_node_id(v.id, self))\n                         .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n@@ -1156,7 +1156,7 @@ fn escape(s: String) -> String {\n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n fn generated_code(span: Span) -> bool {\n-    span.ctxt() != NO_EXPANSION || span.is_dummy()\n+    span.from_expansion() || span.is_dummy()\n }\n \n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore"}, {"sha": "b34506a4f1d371747b80dc2a48bd87786aa5b6ae", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -65,7 +65,7 @@ pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext<'_, '_>) -> O\n     if !scx.config.signatures {\n         return None;\n     }\n-    variant.node.make(0, None, scx).ok()\n+    variant.make(0, None, scx).ok()\n }\n \n pub fn method_signature(\n@@ -699,7 +699,7 @@ impl Sig for ast::StructField {\n }\n \n \n-impl Sig for ast::Variant_ {\n+impl Sig for ast::Variant {\n     fn make(&self, offset: usize, parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let mut text = self.ident.to_string();\n         match self.data {"}, {"sha": "dafa866117681df8c2d2016a27a8b7587bad0355", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -114,26 +114,20 @@ impl TargetDataLayout {\n                 [p] if p.starts_with(\"P\") => {\n                     dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n                 }\n-                // FIXME: Ping cfg(bootstrap) -- Use `ref a @ ..` with new bootstrap compiler.\n-                [\"a\", ..] => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [\"a\", ref a @ ..] => {\n                     dl.aggregate_align = align(a, \"a\")?\n                 }\n-                [\"f32\", ..] => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [\"f32\", ref a @ ..] => {\n                     dl.f32_align = align(a, \"f32\")?\n                 }\n-                [\"f64\", ..] => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [\"f64\", ref a @ ..] => {\n                     dl.f64_align = align(a, \"f64\")?\n                 }\n-                [p @ \"p\", s, ..] | [p @ \"p0\", s, ..] => {\n-                    let a = &spec_parts[2..]; // FIXME inline into pattern.\n+                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n                     dl.pointer_size = size(s, p)?;\n                     dl.pointer_align = align(a, p)?;\n                 }\n-                [s, ..] if s.starts_with(\"i\") => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [s, ref a @ ..] if s.starts_with(\"i\") => {\n                     let bits = match s[1..].parse::<u64>() {\n                         Ok(bits) => bits,\n                         Err(_) => {\n@@ -157,8 +151,7 @@ impl TargetDataLayout {\n                         dl.i128_align = a;\n                     }\n                 }\n-                [s, ..] if s.starts_with(\"v\") => {\n-                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                [s, ref a @ ..] if s.starts_with(\"v\") => {\n                     let v_size = size(&s[1..], \"v\")?;\n                     let a = align(a, s)?;\n                     if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {"}, {"sha": "5d8b829f2ab711c9ee25ed7ab0ebe399de205946", "filename": "src/librustc_target/spec/aarch64_uwp_windows_msvc.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Faarch64_uwp_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Faarch64_uwp_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_uwp_windows_msvc.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult, PanicStrategy};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::windows_uwp_msvc_base::opts();\n+    base.max_atomic_width = Some(64);\n+    base.has_elf_tls = true;\n+\n+    // FIXME: this shouldn't be panic=abort, it should be panic=unwind\n+    base.panic_strategy = PanicStrategy::Abort;\n+\n+    Ok(Target {\n+        llvm_target: \"aarch64-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:w-p:64:64-i32:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"msvc\".to_string(),\n+        target_vendor: \"uwp\".to_string(),\n+        linker_flavor: LinkerFlavor::Msvc,\n+        options: base,\n+    })\n+}"}, {"sha": "65caeac5ed1adca7bb7cba28e93a691e4b6303e2", "filename": "src/librustc_target/spec/aarch64_wrs_vxworks.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Faarch64_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Faarch64_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_wrs_vxworks.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -9,15 +9,14 @@ pub fn target() -> TargetResult {\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n         target_c_int_width: \"32\".to_string(),\n-        target_env: \"gnu\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"vxworks\".to_string(),\n-        target_vendor: \"unknown\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n             abi_blacklist: super::arm_base::abi_blacklist(),\n-            target_mcount: \"\\u{1}_mcount\".to_string(),\n             .. base\n         },\n     })"}, {"sha": "6d3900c0b203f372fe64112322a29d73d7cca658", "filename": "src/librustc_target/spec/apple_ios_base.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -13,7 +13,8 @@ pub enum Arch {\n     Armv7s,\n     Arm64,\n     I386,\n-    X86_64\n+    X86_64,\n+    X86_64_macabi,\n }\n \n impl Arch {\n@@ -23,7 +24,8 @@ impl Arch {\n             Armv7s => \"armv7s\",\n             Arm64 => \"arm64\",\n             I386 => \"i386\",\n-            X86_64 => \"x86_64\"\n+            X86_64 => \"x86_64\",\n+            X86_64_macabi => \"x86_64\"\n         }\n     }\n }\n@@ -67,7 +69,8 @@ pub fn get_sdk_root(sdk_name: &str) -> Result<String, String> {\n fn build_pre_link_args(arch: Arch) -> Result<LinkArgs, String> {\n     let sdk_name = match arch {\n         Armv7 | Armv7s | Arm64 => \"iphoneos\",\n-        I386 | X86_64 => \"iphonesimulator\"\n+        I386 | X86_64 => \"iphonesimulator\",\n+        X86_64_macabi => \"macosx10.15\",\n     };\n \n     let arch_name = arch.to_string();\n@@ -93,6 +96,7 @@ fn target_cpu(arch: Arch) -> String {\n         Arm64 => \"cyclone\",\n         I386 => \"yonah\",\n         X86_64 => \"core2\",\n+        X86_64_macabi => \"core2\",\n     }.to_string()\n }\n "}, {"sha": "bde903de102212370bff818009362b10a427688c", "filename": "src/librustc_target/spec/arm_wrs_vxworks_sf.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks_sf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks_sf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks_sf.rs?ref=7b8273c2e873b814b7c115eabae398d6f11d695b", "patch": "@@ -1,25 +0,0 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n-\n-pub fn target() -> TargetResult {\n-    let mut base = super::vxworks_base::opts();\n-    base.max_atomic_width = Some(64);\n-    Ok(Target {\n-        llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n-        target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n-        target_c_int_width: \"32\".to_string(),\n-        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n-        arch: \"arm\".to_string(),\n-        target_os: \"vxworks\".to_string(),\n-        target_env: \"gnu\".to_string(),\n-        target_vendor: \"unknown\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n-\n-        options: TargetOptions {\n-            features: \"+strict-align,+v6\".to_string(),\n-            abi_blacklist: super::arm_base::abi_blacklist(),\n-            target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n-            .. base\n-        },\n-    })\n-}"}, {"sha": "06c51ae61068f3ef83db158cba14cae036d7016c", "filename": "src/librustc_target/spec/armv7_wrs_vxworks.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks.rs?ref=7b8273c2e873b814b7c115eabae398d6f11d695b", "patch": "@@ -1,31 +0,0 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n-\n-// This target is for glibc Linux on ARMv7 without NEON or\n-// thumb-mode. See the thumbv7neon variant for enabling both.\n-\n-pub fn target() -> TargetResult {\n-    let base = super::vxworks_base::opts();\n-    Ok(Target {\n-        llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n-        target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n-        target_c_int_width: \"32\".to_string(),\n-        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n-        arch: \"arm\".to_string(),\n-        target_os: \"vxworks\".to_string(),\n-        target_env: \"gnu\".to_string(),\n-        target_vendor: \"unknown\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n-\n-        options: TargetOptions {\n-            // Info about features at https://wiki.debian.org/ArmHardFloatPort\n-            features: \"+v7,+vfp3,-d32,+thumb2,-neon\".to_string(),\n-            cpu: \"generic\".to_string(),\n-            max_atomic_width: Some(64),\n-            abi_blacklist: super::arm_base::abi_blacklist(),\n-            target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n-            position_independent_executables: false,\n-            .. base\n-        }\n-    })\n-}"}, {"sha": "9e3b24dd327dcf4630c3a5b06bd89ddd88a431d2", "filename": "src/librustc_target/spec/armv7_wrs_vxworks_eabihf.rs", "status": "renamed", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks_eabihf.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,8 +1,5 @@\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n-// This target is for glibc Linux on ARMv7 without NEON or\n-// thumb-mode. See the thumbv7neon variant for enabling both.\n-\n pub fn target() -> TargetResult {\n     let base = super::vxworks_base::opts();\n     Ok(Target {\n@@ -14,17 +11,14 @@ pub fn target() -> TargetResult {\n         arch: \"arm\".to_string(),\n         target_os: \"vxworks\".to_string(),\n         target_env: \"gnu\".to_string(),\n-        target_vendor: \"unknown\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n-\n         options: TargetOptions {\n             // Info about features at https://wiki.debian.org/ArmHardFloatPort\n             features: \"+v7,+vfp3,-d32,+thumb2,-neon\".to_string(),\n             cpu: \"generic\".to_string(),\n             max_atomic_width: Some(64),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n-            target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n-            position_independent_executables: false,\n             .. base\n         }\n     })", "previous_filename": "src/librustc_target/spec/arm_wrs_vxworks.rs"}, {"sha": "355250e6eca7f152fe03701c8dc8dd277cf9bf2c", "filename": "src/librustc_target/spec/i586_wrs_vxworks.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Fi586_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Fi586_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi586_wrs_vxworks.rs?ref=7b8273c2e873b814b7c115eabae398d6f11d695b", "patch": "@@ -1,8 +0,0 @@\n-use crate::spec::TargetResult;\n-\n-pub fn target() -> TargetResult {\n-    let mut base = super::i686_wrs_vxworks::target()?;\n-    base.options.cpu = \"pentium\".to_string();\n-    base.llvm_target = \"i586-unknown-linux-gnu\".to_string();\n-    Ok(base)\n-}"}, {"sha": "5e8e8c2a4149c6eb242bb254686dfe8f5b8106e7", "filename": "src/librustc_target/spec/i686_uwp_windows_msvc.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_msvc.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -0,0 +1,22 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::windows_uwp_msvc_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.has_elf_tls = true;\n+\n+    Ok(Target {\n+        llvm_target: \"i686-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"msvc\".to_string(),\n+        target_vendor: \"uwp\".to_string(),\n+        linker_flavor: LinkerFlavor::Msvc,\n+        options: base,\n+    })\n+}"}, {"sha": "c5f9583a358563b2e27c9e26e2d8cbefe30c1f79", "filename": "src/librustc_target/spec/i686_wrs_vxworks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> TargetResult {\n         arch: \"x86\".to_string(),\n         target_os: \"vxworks\".to_string(),\n         target_env: \"gnu\".to_string(),\n-        target_vendor: \"unknown\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n     })"}, {"sha": "4b1ff5ccbe8aa238d4cdbab86ea4cbc6e666779b", "filename": "src/librustc_target/spec/i686_wrs_vxworks_gnu.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks_gnu.rs?ref=7b8273c2e873b814b7c115eabae398d6f11d695b", "patch": "@@ -1,23 +0,0 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n-\n-pub fn target() -> TargetResult {\n-    let mut base = super::vxworks_base::opts();\n-    base.cpu = \"pentium4\".to_string();\n-    base.max_atomic_width = Some(64);\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n-    base.stack_probes = true;\n-\n-    Ok(Target {\n-        llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n-        target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n-        target_c_int_width: \"32\".to_string(),\n-        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n-        arch: \"x86\".to_string(),\n-        target_os: \"vxworks\".to_string(),\n-        target_env: \"gnu\".to_string(),\n-        target_vendor: \"unknown\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n-        options: base,\n-    })\n-}"}, {"sha": "75f3efa49c4f04557da497a29b008dc21c79b411", "filename": "src/librustc_target/spec/mips64_unknown_linux_muslabi64.rs", "status": "renamed", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_muslabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_muslabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_muslabi64.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,24 +1,23 @@\n use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let mut base = super::vxworks_base::opts();\n-    base.cpu = \"ppc64\".to_string();\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    let mut base = super::linux_musl_base::opts();\n+    base.cpu = \"mips64r2\".to_string();\n+    base.features = \"+mips64r2\".to_string();\n     base.max_atomic_width = Some(64);\n-\n     Ok(Target {\n-        llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n+        // LLVM doesn't recognize \"muslabi64\" yet.\n+        llvm_target: \"mips64-unknown-linux-musl\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n         target_c_int_width: \"32\".to_string(),\n-        data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n-        arch: \"powerpc64\".to_string(),\n-        target_os: \"vxworks\".to_string(),\n-        target_env: \"gnu\".to_string(),\n+        data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n-            features: \"-hard-float\".to_string(),\n             target_mcount: \"_mcount\".to_string(),\n             .. base\n         },", "previous_filename": "src/librustc_target/spec/powerpc64_wrs_vxworks_gnusf.rs"}, {"sha": "a6aad3ddd3d797e2766e6b11ec5f366c7e45053d", "filename": "src/librustc_target/spec/mips64el_unknown_linux_muslabi64.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -0,0 +1,25 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+    base.cpu = \"mips64r2\".to_string();\n+    base.features = \"+mips64r2\".to_string();\n+    base.max_atomic_width = Some(64);\n+    Ok(Target {\n+        // LLVM doesn't recognize \"muslabi64\" yet.\n+        llvm_target: \"mips64el-unknown-linux-musl\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "539e28f7088e354188441f1ba88ef8c6e866f308", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -61,6 +61,7 @@ mod uefi_base;\n mod windows_base;\n mod windows_msvc_base;\n mod windows_uwp_base;\n+mod windows_uwp_msvc_base;\n mod thumb_base;\n mod l4re_base;\n mod fuchsia_base;\n@@ -371,6 +372,8 @@ supported_targets! {\n     (\"i586-unknown-linux-musl\", i586_unknown_linux_musl),\n     (\"mips-unknown-linux-musl\", mips_unknown_linux_musl),\n     (\"mipsel-unknown-linux-musl\", mipsel_unknown_linux_musl),\n+    (\"mips64-unknown-linux-muslabi64\", mips64_unknown_linux_muslabi64),\n+    (\"mips64el-unknown-linux-muslabi64\", mips64el_unknown_linux_muslabi64),\n     (\"hexagon-unknown-linux-musl\", hexagon_unknown_linux_musl),\n \n     (\"mips-unknown-linux-uclibc\", mips_unknown_linux_uclibc),\n@@ -395,6 +398,7 @@ supported_targets! {\n \n     (\"aarch64-unknown-openbsd\", aarch64_unknown_openbsd),\n     (\"i686-unknown-openbsd\", i686_unknown_openbsd),\n+    (\"sparc64-unknown-openbsd\", sparc64_unknown_openbsd),\n     (\"x86_64-unknown-openbsd\", x86_64_unknown_openbsd),\n \n     (\"aarch64-unknown-netbsd\", aarch64_unknown_netbsd),\n@@ -425,6 +429,7 @@ supported_targets! {\n     (\"aarch64-apple-ios\", aarch64_apple_ios),\n     (\"armv7-apple-ios\", armv7_apple_ios),\n     (\"armv7s-apple-ios\", armv7s_apple_ios),\n+    (\"x86_64-apple-ios-macabi\", x86_64_apple_ios_macabi),\n \n     (\"armebv7r-none-eabi\", armebv7r_none_eabi),\n     (\"armebv7r-none-eabihf\", armebv7r_none_eabihf),\n@@ -442,8 +447,11 @@ supported_targets! {\n     (\"x86_64-uwp-windows-gnu\", x86_64_uwp_windows_gnu),\n \n     (\"aarch64-pc-windows-msvc\", aarch64_pc_windows_msvc),\n+    (\"aarch64-uwp-windows-msvc\", aarch64_uwp_windows_msvc),\n     (\"x86_64-pc-windows-msvc\", x86_64_pc_windows_msvc),\n+    (\"x86_64-uwp-windows-msvc\", x86_64_uwp_windows_msvc),\n     (\"i686-pc-windows-msvc\", i686_pc_windows_msvc),\n+    (\"i686-uwp-windows-msvc\", i686_uwp_windows_msvc),\n     (\"i586-pc-windows-msvc\", i586_pc_windows_msvc),\n     (\"thumbv7a-pc-windows-msvc\", thumbv7a_pc_windows_msvc),\n \n@@ -485,10 +493,9 @@ supported_targets! {\n \n     (\"nvptx64-nvidia-cuda\", nvptx64_nvidia_cuda),\n \n-    (\"x86_64-wrs-vxworks\", x86_64_wrs_vxworks),\n     (\"i686-wrs-vxworks\", i686_wrs_vxworks),\n-    (\"i586-wrs-vxworks\", i586_wrs_vxworks),\n-    (\"armv7-wrs-vxworks\", armv7_wrs_vxworks),\n+    (\"x86_64-wrs-vxworks\", x86_64_wrs_vxworks),\n+    (\"armv7-wrs-vxworks-eabihf\", armv7_wrs_vxworks_eabihf),\n     (\"aarch64-wrs-vxworks\", aarch64_wrs_vxworks),\n     (\"powerpc-wrs-vxworks\", powerpc_wrs_vxworks),\n     (\"powerpc-wrs-vxworks-spe\", powerpc_wrs_vxworks_spe),"}, {"sha": "27a84b953dd07453749392326243eb3229bb7116", "filename": "src/librustc_target/spec/powerpc64_wrs_vxworks.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -15,10 +15,9 @@ pub fn target() -> TargetResult {\n         arch: \"powerpc64\".to_string(),\n         target_os: \"vxworks\".to_string(),\n         target_env: \"gnu\".to_string(),\n-        target_vendor: \"unknown\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n-            target_mcount: \"_mcount\".to_string(),\n             .. base\n         },\n     })"}, {"sha": "a4d2897f892282ec3a8547bff3f647fd94888cc1", "filename": "src/librustc_target/spec/powerpc_wrs_vxworks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -19,7 +19,6 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n             features: \"+secure-plt\".to_string(),\n-            target_mcount: \"_mcount\".to_string(),\n             .. base\n         },\n     })"}, {"sha": "43723ea7c0cc8404c0a3a93fe89d97c24a270c32", "filename": "src/librustc_target/spec/powerpc_wrs_vxworks_gnusf.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnusf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnusf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnusf.rs?ref=7b8273c2e873b814b7c115eabae398d6f11d695b", "patch": "@@ -1,26 +0,0 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n-\n-pub fn target() -> TargetResult {\n-    let mut base = super::vxworks_base::opts();\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"--secure-plt\".to_string());\n-    base.max_atomic_width = Some(32);\n-\n-    Ok(Target {\n-        llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),\n-        target_endian: \"big\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n-        target_c_int_width: \"32\".to_string(),\n-        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n-        arch: \"powerpc\".to_string(),\n-        target_os: \"vxworks\".to_string(),\n-        target_env: \"gnu\".to_string(),\n-        target_vendor: \"wrs\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n-        options: TargetOptions {\n-            features: \"+secure-plt,-hard-float\".to_string(),\n-            target_mcount: \"_mcount\".to_string(),\n-            .. base\n-        },\n-    })\n-}"}, {"sha": "8f236235867e57bba34a2ed93c893d541065ee80", "filename": "src/librustc_target/spec/powerpc_wrs_vxworks_gnuspesf.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnuspesf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8273c2e873b814b7c115eabae398d6f11d695b/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnuspesf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnuspesf.rs?ref=7b8273c2e873b814b7c115eabae398d6f11d695b", "patch": "@@ -1,27 +0,0 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n-\n-pub fn target() -> TargetResult {\n-    let mut base = super::vxworks_base::opts();\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mspe\".to_string());\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"--secure-plt\".to_string());\n-    base.max_atomic_width = Some(32);\n-\n-    Ok(Target {\n-        llvm_target: \"powerpc-unknown-linux-gnuspe\".to_string(),\n-        target_endian: \"big\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n-        target_c_int_width: \"32\".to_string(),\n-        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n-        arch: \"powerpc\".to_string(),\n-        target_os: \"vxworks\".to_string(),\n-        target_env: \"gnu\".to_string(),\n-        target_vendor: \"wrs\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n-        options: TargetOptions {\n-            // feature msync would disable instruction 'fsync' which is not supported by fsl_p1p2\n-            features: \"+secure-plt,+msync,-hard-float\".to_string(),\n-            target_mcount: \"_mcount\".to_string(),\n-            .. base\n-        },\n-    })\n-}"}, {"sha": "90118a148524236648edd3978aefd53d70fe8785", "filename": "src/librustc_target/spec/powerpc_wrs_vxworks_spe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_spe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_spe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_spe.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -20,7 +20,6 @@ pub fn target() -> TargetResult {\n         options: TargetOptions {\n             // feature msync would disable instruction 'fsync' which is not supported by fsl_p1p2\n             features: \"+secure-plt,+msync\".to_string(),\n-            target_mcount: \"_mcount\".to_string(),\n             .. base\n         },\n     })"}, {"sha": "229e0621e0dc1cef92bc52cf3e2ca415685d3d20", "filename": "src/librustc_target/spec/sparc64_unknown_openbsd.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_openbsd.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -0,0 +1,22 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::openbsd_base::opts();\n+    base.cpu = \"v9\".to_string();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"sparc64-unknown-openbsd\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i64:64-n32:64-S128\".to_string(),\n+        arch: \"sparc64\".to_string(),\n+        target_os: \"openbsd\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "16acd411dca8177c9f51039147a03d8e08f37238", "filename": "src/librustc_target/spec/vxworks_base.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,7 +1,11 @@\n-use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions, RelroLevel};\n+use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n use std::default::Default;\n \n pub fn opts() -> TargetOptions {\n+    let mut args_crt = LinkArgs::new();\n+    args_crt.insert(LinkerFlavor::Gcc, vec![\n+        \"--static-crt\".to_string(),\n+    ]);\n     let mut args = LinkArgs::new();\n     args.insert(LinkerFlavor::Gcc, vec![\n         // We want to be able to strip as much executable code as possible\n@@ -12,30 +16,25 @@ pub fn opts() -> TargetOptions {\n         // following libraries so we're sure to pass it as one of the first\n         // arguments.\n         \"-Wl,--as-needed\".to_string(),\n-\n-        // Always enable NX protection when it is available\n-        \"-Wl,-z,noexecstack\".to_string(),\n-    ]);\n-\n-    let mut late_lk_args = LinkArgs::new();\n-    late_lk_args.insert(LinkerFlavor::Gcc, vec![\n-        \"-lnet\".to_string(),\n-        \"-lunix\".to_string(),\n     ]);\n \n     TargetOptions {\n-        linker: Some(\"vx-cxx\".to_string()),\n+        linker: Some(\"wr-c++\".to_string()),\n         exe_suffix: \".vxe\".to_string(),\n-        late_link_args: late_lk_args,\n         dynamic_linking: true,\n         executables: true,\n         target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: args,\n-        position_independent_executables: true,\n-        relro_level: RelroLevel::Full,\n+        position_independent_executables: false,\n         has_elf_tls: true,\n+        pre_link_args_crt: args_crt,\n+        crt_static_default: true,\n+        crt_static_respected: true,\n+        crt_static_allows_dylibs: true,\n+        // VxWorks needs to implement this to support profiling\n+        target_mcount: \"_mcount\".to_string(),\n         .. Default::default()\n     }\n }"}, {"sha": "1121916e68f5130b675a5d3badb63b84ccdd3566", "filename": "src/librustc_target/spec/windows_uwp_msvc_base.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_msvc_base.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -0,0 +1,33 @@\n+use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut args = LinkArgs::new();\n+    args.insert(LinkerFlavor::Msvc,\n+                vec![\"/NOLOGO\".to_string(),\n+                     \"/NXCOMPAT\".to_string(),\n+                     \"/APPCONTAINER\".to_string(),\n+                     \"mincore.lib\".to_string()]);\n+\n+    TargetOptions {\n+        function_sections: true,\n+        dynamic_linking: true,\n+        executables: true,\n+        dll_prefix: String::new(),\n+        dll_suffix: \".dll\".to_string(),\n+        exe_suffix: \".exe\".to_string(),\n+        staticlib_prefix: String::new(),\n+        staticlib_suffix: \".lib\".to_string(),\n+        target_family: Some(\"windows\".to_string()),\n+        is_like_windows: true,\n+        is_like_msvc: true,\n+        pre_link_args: args,\n+        crt_static_allows_dylibs: true,\n+        crt_static_respected: true,\n+        abi_return_struct_as_int: true,\n+        emit_debug_gdb_scripts: false,\n+        requires_uwtable: true,\n+\n+        .. Default::default()\n+    }\n+}"}, {"sha": "2ce77282e90222ce27903e167cab919e513a059f", "filename": "src/librustc_target/spec/x86_64_apple_ios_macabi.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_apple_ios_macabi.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -0,0 +1,23 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use super::apple_ios_base::{opts, Arch};\n+\n+pub fn target() -> TargetResult {\n+    let base = opts(Arch::X86_64_macabi)?;\n+    Ok(Target {\n+        llvm_target: \"x86_64-apple-ios13.0-macabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"ios\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: \"apple\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            max_atomic_width: Some(64),\n+            stack_probes: true,\n+            .. base\n+        }\n+    })\n+}"}, {"sha": "40dd52c159151f5c4484fedd6dfa5dfe244b6112", "filename": "src/librustc_target/spec/x86_64_uwp_windows_msvc.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_msvc.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -0,0 +1,22 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::windows_uwp_msvc_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.has_elf_tls = true;\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:w-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"msvc\".to_string(),\n+        target_vendor: \"uwp\".to_string(),\n+        linker_flavor: LinkerFlavor::Msvc,\n+        options: base,\n+    })\n+}"}, {"sha": "1ab2f3a47c481abc55db7a07d7047e216d80fb9b", "filename": "src/librustc_target/spec/x86_64_wrs_vxworks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fx86_64_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_target%2Fspec%2Fx86_64_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_wrs_vxworks.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -6,6 +6,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.stack_probes = true;\n+    base.disable_redzone = true;\n \n     Ok(Target {\n         llvm_target: \"x86_64-unknown-linux-gnu\".to_string(),"}, {"sha": "99ae777bb631bd5b890d8ccba4e23c4c43923dcf", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -12,7 +12,6 @@ use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n use syntax::ast;\n-use syntax::source_map::Spanned;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n use syntax_pos::hygiene::DesugaringKind;\n@@ -1036,7 +1035,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         &self,\n         pat: &'tcx hir::Pat,\n         qpath: &hir::QPath,\n-        fields: &'tcx [Spanned<hir::FieldPat>],\n+        fields: &'tcx [hir::FieldPat],\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: ty::BindingMode,\n@@ -1048,7 +1047,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat_walk(&field.node.pat, self.tcx.types.err, def_bm, discrim_span);\n+                self.check_pat_walk(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n             }\n             return self.tcx.types.err;\n         };\n@@ -1206,7 +1205,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         pat_id: hir::HirId,\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n-        fields: &'tcx [Spanned<hir::FieldPat>],\n+        fields: &'tcx [hir::FieldPat],\n         etc: bool,\n         def_bm: ty::BindingMode,\n     ) -> bool {\n@@ -1231,7 +1230,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n-        for &Spanned { node: ref field, span } in fields {\n+        for field in fields {\n+            let span = field.span;\n             let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {"}, {"sha": "de5ba8bc8eb42418d181cfebfd457809460b99e1", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -127,6 +127,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n+        self.suggest_boxing_when_appropriate(&mut err, expr, expected, expr_ty);\n         self.suggest_missing_await(&mut err, expr, expected, expr_ty);\n \n         (expected, Some(err))\n@@ -346,9 +347,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sp,\n         );\n \n-        // Check the `expn_info()` to see if this is a macro; if so, it's hard to\n-        // extract the text and make a good suggestion, so don't bother.\n-        let is_macro = sp.ctxt().outer_expn_info().is_some();\n+        // If the span is from a macro, then it's hard to extract the text\n+        // and make a good suggestion, so don't bother.\n+        let is_macro = sp.from_expansion();\n \n         match (&expr.node, &expected.sty, &checked_ty.sty) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n@@ -548,11 +549,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        if self.tcx.hir().is_const_scope(expr.hir_id) {\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n             // Shouldn't suggest `.into()` on `const`s.\n             // FIXME(estebank): modify once we decide to suggest `as` casts\n             return false;\n         }\n+        if !self.tcx.sess.source_map().span_to_filename(expr.span).is_real() {\n+            // Ignore if span is from within a macro.\n+            return false;\n+        }\n \n         // If casting this expression to a given numeric type would be appropriate in case of a type\n         // mismatch."}, {"sha": "d139cd4264c86f707c9f5cfddcf53f7bd518a30e", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 168, "deletions": 101, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -24,6 +24,7 @@ use syntax::source_map::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n use rustc::hir;\n use rustc::hir::{ExprKind, QPath};\n+use rustc::hir::def_id::DefId;\n use rustc::hir::def::{CtorKind, Res, DefKind};\n use rustc::hir::ptr::P;\n use rustc::infer;\n@@ -1336,116 +1337,182 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         autoderef.unambiguous_final_ty(self);\n \n         if let Some((did, field_ty)) = private_candidate {\n-            let struct_path = self.tcx().def_path_str(did);\n-            let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n-                                           \"field `{}` of struct `{}` is private\",\n-                                           field, struct_path);\n-            // Also check if an accessible method exists, which is often what is meant.\n-            if self.method_exists(field, expr_t, expr.hir_id, false)\n-                && !self.expr_in_place(expr.hir_id)\n-            {\n-                self.suggest_method_call(\n-                    &mut err,\n-                    &format!(\"a method `{}` also exists, call it with parentheses\", field),\n-                    field,\n-                    expr_t,\n-                    expr.hir_id,\n-                );\n-            }\n-            err.emit();\n-            field_ty\n-        } else if field.name == kw::Invalid {\n-            self.tcx().types.err\n+            self.ban_private_field_access(expr, expr_t, field, did);\n+            return field_ty;\n+        }\n+\n+        if field.name == kw::Invalid {\n         } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n-            let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n-                               \"attempted to take value of method `{}` on type `{}`\",\n-                               field, expr_t);\n-\n-            if !self.expr_in_place(expr.hir_id) {\n-                self.suggest_method_call(\n-                    &mut err,\n-                    \"use parentheses to call the method\",\n-                    field,\n-                    expr_t,\n-                    expr.hir_id\n-                );\n-            } else {\n-                err.help(\"methods are immutable and cannot be assigned to\");\n+            self.ban_take_value_of_method(expr, expr_t, field);\n+        } else if !expr_t.is_primitive_ty() {\n+            let mut err = self.no_such_field_err(field.span, field, expr_t);\n+\n+            match expr_t.sty {\n+                ty::Adt(def, _) if !def.is_enum() => {\n+                    self.suggest_fields_on_recordish(&mut err, def, field);\n+                }\n+                ty::Array(_, len) => {\n+                    self.maybe_suggest_array_indexing(&mut err, expr, base, field, len);\n+                }\n+                ty::RawPtr(..) => {\n+                    self.suggest_first_deref_field(&mut err, expr, base, field);\n+                }\n+                _ => {}\n+            }\n+\n+            if field.name == kw::Await {\n+                // We know by construction that `<expr>.await` is either on Rust 2015\n+                // or results in `ExprKind::Await`. Suggest switching the edition to 2018.\n+                err.note(\"to `.await` a `Future`, switch to Rust 2018\");\n+                err.help(\"set `edition = \\\"2018\\\"` in `Cargo.toml`\");\n+                err.note(\"for more on editions, read https://doc.rust-lang.org/edition-guide\");\n             }\n \n             err.emit();\n-            self.tcx().types.err\n         } else {\n-            if !expr_t.is_primitive_ty() {\n-                let mut err = self.no_such_field_err(field.span, field, expr_t);\n-\n-                match expr_t.sty {\n-                    ty::Adt(def, _) if !def.is_enum() => {\n-                        if let Some(suggested_field_name) =\n-                            Self::suggest_field_name(def.non_enum_variant(),\n-                                                     &field.as_str(), vec![]) {\n-                                err.span_suggestion(\n-                                    field.span,\n-                                    \"a field with a similar name exists\",\n-                                    suggested_field_name.to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_label(field.span, \"unknown field\");\n-                                let struct_variant_def = def.non_enum_variant();\n-                                let field_names = self.available_field_names(struct_variant_def);\n-                                if !field_names.is_empty() {\n-                                    err.note(&format!(\"available fields are: {}\",\n-                                                      self.name_series_display(field_names)));\n-                                }\n-                            };\n-                    }\n-                    ty::Array(_, len) => {\n-                        if let (Some(len), Ok(user_index)) = (\n-                            len.try_eval_usize(self.tcx, self.param_env),\n-                            field.as_str().parse::<u64>()\n-                        ) {\n-                            let base = self.tcx.sess.source_map()\n-                                .span_to_snippet(base.span)\n-                                .unwrap_or_else(|_|\n-                                    self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-                            let help = \"instead of using tuple indexing, use array indexing\";\n-                            let suggestion = format!(\"{}[{}]\", base, field);\n-                            let applicability = if len < user_index {\n-                                Applicability::MachineApplicable\n-                            } else {\n-                                Applicability::MaybeIncorrect\n-                            };\n-                            err.span_suggestion(\n-                                expr.span, help, suggestion, applicability\n-                            );\n-                        }\n-                    }\n-                    ty::RawPtr(..) => {\n-                        let base = self.tcx.sess.source_map()\n-                            .span_to_snippet(base.span)\n-                            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-                        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n-                        let suggestion = format!(\"(*{}).{}\", base, field);\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &msg,\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {}\n-                }\n-                err\n+            type_error_struct!(\n+                self.tcx().sess,\n+                field.span,\n+                expr_t,\n+                E0610,\n+                \"`{}` is a primitive type and therefore doesn't have fields\",\n+                expr_t\n+            )\n+            .emit();\n+        }\n+\n+        self.tcx().types.err\n+    }\n+\n+    fn ban_private_field_access(\n+        &self,\n+        expr: &hir::Expr,\n+        expr_t: Ty<'tcx>,\n+        field: ast::Ident,\n+        base_did: DefId,\n+    ) {\n+        let struct_path = self.tcx().def_path_str(base_did);\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            expr.span,\n+            E0616,\n+            \"field `{}` of struct `{}` is private\",\n+            field,\n+            struct_path\n+        );\n+        // Also check if an accessible method exists, which is often what is meant.\n+        if self.method_exists(field, expr_t, expr.hir_id, false)\n+            && !self.expr_in_place(expr.hir_id)\n+        {\n+            self.suggest_method_call(\n+                &mut err,\n+                &format!(\"a method `{}` also exists, call it with parentheses\", field),\n+                field,\n+                expr_t,\n+                expr.hir_id,\n+            );\n+        }\n+        err.emit();\n+    }\n+\n+    fn ban_take_value_of_method(&self, expr: &hir::Expr, expr_t: Ty<'tcx>, field: ast::Ident) {\n+        let mut err = type_error_struct!(\n+            self.tcx().sess,\n+            field.span,\n+            expr_t,\n+            E0615,\n+            \"attempted to take value of method `{}` on type `{}`\",\n+            field,\n+            expr_t\n+        );\n+\n+        if !self.expr_in_place(expr.hir_id) {\n+            self.suggest_method_call(\n+                &mut err,\n+                \"use parentheses to call the method\",\n+                field,\n+                expr_t,\n+                expr.hir_id\n+            );\n+        } else {\n+            err.help(\"methods are immutable and cannot be assigned to\");\n+        }\n+\n+        err.emit();\n+    }\n+\n+    fn suggest_fields_on_recordish(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        def: &'tcx ty::AdtDef,\n+        field: ast::Ident,\n+    ) {\n+        if let Some(suggested_field_name) =\n+            Self::suggest_field_name(def.non_enum_variant(), &field.as_str(), vec![])\n+        {\n+            err.span_suggestion(\n+                field.span,\n+                \"a field with a similar name exists\",\n+                suggested_field_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(field.span, \"unknown field\");\n+            let struct_variant_def = def.non_enum_variant();\n+            let field_names = self.available_field_names(struct_variant_def);\n+            if !field_names.is_empty() {\n+                err.note(&format!(\"available fields are: {}\",\n+                                    self.name_series_display(field_names)));\n+            }\n+        }\n+    }\n+\n+    fn maybe_suggest_array_indexing(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr,\n+        base: &hir::Expr,\n+        field: ast::Ident,\n+        len: &ty::Const<'tcx>,\n+    ) {\n+        if let (Some(len), Ok(user_index)) = (\n+            len.try_eval_usize(self.tcx, self.param_env),\n+            field.as_str().parse::<u64>()\n+        ) {\n+            let base = self.tcx.sess.source_map()\n+                .span_to_snippet(base.span)\n+                .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n+            let help = \"instead of using tuple indexing, use array indexing\";\n+            let suggestion = format!(\"{}[{}]\", base, field);\n+            let applicability = if len < user_index {\n+                Applicability::MachineApplicable\n             } else {\n-                type_error_struct!(self.tcx().sess, field.span, expr_t, E0610,\n-                                   \"`{}` is a primitive type and therefore doesn't have fields\",\n-                                   expr_t)\n-            }.emit();\n-            self.tcx().types.err\n+                Applicability::MaybeIncorrect\n+            };\n+            err.span_suggestion(expr.span, help, suggestion, applicability);\n         }\n     }\n \n+    fn suggest_first_deref_field(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr,\n+        base: &hir::Expr,\n+        field: ast::Ident,\n+    ) {\n+        let base = self.tcx.sess.source_map()\n+            .span_to_snippet(base.span)\n+            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n+        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n+        let suggestion = format!(\"(*{}).{}\", base, field);\n+        err.span_suggestion(\n+            expr.span,\n+            &msg,\n+            suggestion,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS<'_>)\n         -> DiagnosticBuilder<'_> {\n         type_error_struct!(self.tcx().sess, span, expr_t, E0609,"}, {"sha": "dfbf8bcd0f60fcdf26d583f381480ea469b3cc02", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -67,7 +67,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n     match intrinsic {\n         \"size_of\" | \"min_align_of\" | \"needs_drop\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n-        \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+        \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" |\n         \"saturating_add\" | \"saturating_sub\" |\n         \"rotate_left\" | \"rotate_right\" |\n         \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" | \"bitreverse\" |\n@@ -314,7 +314,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                 (1, vec![param(0), param(0)], param(0)),\n             \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n-            \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n+            \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n             \"saturating_add\" | \"saturating_sub\" =>\n                 (1, vec![param(0), param(0)], param(0)),"}, {"sha": "53024d97c3b134eb04581257bb55cddab50950b9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -985,7 +985,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude\n                     // import or other generated ones.\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n@@ -995,7 +995,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n                 hir::ItemKind::ExternCrate(_) => {}\n                 // ...but do place them before the first other item.\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    if item.span.ctxt().outer_expn_info().is_none() {\n+                    if !item.span.from_expansion() {\n                         // Don't insert between attributes and an item.\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());"}, {"sha": "fc1ee649e287f7d64d3deba68e29ce998843f55e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 126, "deletions": 10, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1325,12 +1325,94 @@ fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def_id);\n }\n \n+/// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n+/// projections that would result in \"inheriting lifetimes\".\n fn check_opaque<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     substs: SubstsRef<'tcx>,\n     span: Span,\n-    origin: &hir::OpaqueTyOrigin\n+    origin: &hir::OpaqueTyOrigin,\n+) {\n+    check_opaque_for_inheriting_lifetimes(tcx, def_id, span);\n+    check_opaque_for_cycles(tcx, def_id, substs, span, origin);\n+}\n+\n+/// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n+/// in \"inheriting lifetimes\".\n+fn check_opaque_for_inheriting_lifetimes(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    span: Span,\n+) {\n+    let item = tcx.hir().expect_item(\n+        tcx.hir().as_local_hir_id(def_id).expect(\"opaque type is not local\"));\n+    debug!(\"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n+           def_id, span, item);\n+\n+    #[derive(Debug)]\n+    struct ProhibitOpaqueVisitor<'tcx> {\n+        opaque_identity_ty: Ty<'tcx>,\n+        generics: &'tcx ty::Generics,\n+    };\n+\n+    impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n+            if t == self.opaque_identity_ty { false } else { t.super_visit_with(self) }\n+        }\n+\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_region) r={:?}\", r);\n+            if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n+                return *index < self.generics.parent_count as u32;\n+            }\n+\n+            r.super_visit_with(self)\n+        }\n+    }\n+\n+    let prohibit_opaque = match item.node {\n+        ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::AsyncFn, .. }) |\n+        ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn, .. }) => {\n+            let mut visitor = ProhibitOpaqueVisitor {\n+                opaque_identity_ty: tcx.mk_opaque(\n+                    def_id, InternalSubsts::identity_for_item(tcx, def_id)),\n+                generics: tcx.generics_of(def_id),\n+            };\n+            debug!(\"check_opaque_for_inheriting_lifetimes: visitor={:?}\", visitor);\n+\n+            tcx.predicates_of(def_id).predicates.iter().any(\n+                |(predicate, _)| predicate.visit_with(&mut visitor))\n+        },\n+        _ => false,\n+    };\n+\n+    debug!(\"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}\", prohibit_opaque);\n+    if prohibit_opaque {\n+        let is_async = match item.node {\n+            ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n+                hir::OpaqueTyOrigin::AsyncFn => true,\n+                _ => false,\n+            },\n+            _ => unreachable!(),\n+        };\n+\n+        tcx.sess.span_err(span, &format!(\n+            \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n+             a parent scope\",\n+            if is_async { \"async fn\" } else { \"impl Trait\" },\n+        ));\n+    }\n+}\n+\n+/// Checks that an opaque type does not contain cycles.\n+fn check_opaque_for_cycles<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+    span: Span,\n+    origin: &hir::OpaqueTyOrigin,\n ) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n         if let hir::OpaqueTyOrigin::AsyncFn = origin {\n@@ -1834,9 +1916,7 @@ fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, d\n     );\n     let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n     err.span_label(sp, &msg);\n-    if let &[.., ref end] = &variant_spans[..] {\n-        // FIXME: Ping cfg(bootstrap) -- Use `ref start @ ..` with new bootstrap compiler.\n-        let start = &variant_spans[..variant_spans.len() - 1];\n+    if let &[ref start @ .., ref end] = &variant_spans[..] {\n         for variant_span in start {\n             err.span_label(*variant_span, \"\");\n         }\n@@ -1968,19 +2048,19 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n     }\n \n     for v in vs {\n-        if let Some(ref e) = v.node.disr_expr {\n+        if let Some(ref e) = v.disr_expr {\n             tcx.typeck_tables_of(tcx.hir().local_def_id(e.hir_id));\n         }\n     }\n \n     if tcx.adt_def(def_id).repr.int.is_none() && tcx.features().arbitrary_enum_discriminant {\n         let is_unit =\n-            |var: &hir::Variant| match var.node.data {\n+            |var: &hir::Variant| match var.data {\n                 hir::VariantData::Unit(..) => true,\n                 _ => false\n             };\n \n-        let has_disr = |var: &hir::Variant| var.node.disr_expr.is_some();\n+        let has_disr = |var: &hir::Variant| var.disr_expr.is_some();\n         let has_non_units = vs.iter().any(|var| !is_unit(var));\n         let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n         let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n@@ -1999,11 +2079,11 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n             let variant_did = def.variants[VariantIdx::new(i)].def_id;\n             let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n-            let i_span = match variant_i.node.disr_expr {\n+            let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => tcx.hir().span(variant_i_hir_id)\n             };\n-            let span = match v.node.disr_expr {\n+            let span = match v.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => v.span\n             };\n@@ -2863,7 +2943,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n             (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n         };\n-        (tr, ast::Ident::with_empty_ctxt(name))\n+        (tr, ast::Ident::with_dummy_span(name))\n     }\n \n     fn try_overloaded_place_op(&self,\n@@ -3820,6 +3900,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err, &fn_decl, expected, found, can_suggest);\n         }\n         self.suggest_ref_or_into(err, expression, expected, found);\n+        self.suggest_boxing_when_appropriate(err, expression, expected, found);\n         pointing_at_return_type\n     }\n \n@@ -3980,6 +4061,41 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n+    /// in the heap by calling `Box::new()`.\n+    fn suggest_boxing_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return;\n+        }\n+        if !expected.is_box() || found.is_box() {\n+            return;\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(boxed_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            err.span_suggestion(\n+                expr.span,\n+                \"store this in the heap by calling `Box::new`\",\n+                format!(\"Box::new({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(\"for more on the distinction between the stack and the \\\n+                        heap, read https://doc.rust-lang.org/book/ch15-01-box.html, \\\n+                        https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n+                        https://doc.rust-lang.org/std/boxed/index.html\");\n+        }\n+    }\n+\n+\n     /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n     ///\n     /// ```"}, {"sha": "28a1ccda4d84187f334fb4c3facbddbba8c8ea86", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -203,7 +203,6 @@ fn check_associated_item(\n                 fcx.register_wf_obligation(ty, span, code.clone());\n             }\n             ty::AssocKind::Method => {\n-                reject_shadowing_parameters(fcx.tcx, item.def_id);\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n                 let sig = fcx.normalize_associated_types_in(span, &sig);\n                 check_fn_or_method(tcx, fcx, span, sig,\n@@ -998,34 +997,6 @@ fn report_bivariance(tcx: TyCtxt<'_>, span: Span, param_name: ast::Name) {\n     err.emit();\n }\n \n-fn reject_shadowing_parameters(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let generics = tcx.generics_of(def_id);\n-    let parent = tcx.generics_of(generics.parent.unwrap());\n-    let impl_params: FxHashMap<_, _> = parent.params.iter().flat_map(|param| match param.kind {\n-        GenericParamDefKind::Lifetime => None,\n-        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n-            Some((param.name, param.def_id))\n-        }\n-    }).collect();\n-\n-    for method_param in &generics.params {\n-        // Shadowing is checked in `resolve_lifetime`.\n-        if let GenericParamDefKind::Lifetime = method_param.kind {\n-            continue\n-        }\n-        if impl_params.contains_key(&method_param.name) {\n-            // Tighten up the span to focus on only the shadowing type.\n-            let type_span = tcx.def_span(method_param.def_id);\n-\n-            // The expectation here is that the original trait declaration is\n-            // local so it should be okay to just unwrap everything.\n-            let trait_def_id = impl_params[&method_param.name];\n-            let trait_decl_span = tcx.def_span(trait_def_id);\n-            error_194(tcx, type_span, trait_decl_span, &method_param.name.as_str()[..]);\n-        }\n-    }\n-}\n-\n /// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n /// aren't true.\n fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n@@ -1119,7 +1090,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn enum_variants(&self, enum_def: &hir::EnumDef) -> Vec<AdtVariant<'tcx>> {\n         enum_def.variants.iter()\n-            .map(|variant| self.non_enum_variant(&variant.node.data))\n+            .map(|variant| self.non_enum_variant(&variant.data))\n             .collect()\n     }\n \n@@ -1152,12 +1123,3 @@ fn error_392(\n     err.span_label(span, \"unused parameter\");\n     err\n }\n-\n-fn error_194(tcx: TyCtxt<'_>, span: Span, trait_decl_span: Span, name: &str) {\n-    struct_span_err!(tcx.sess, span, E0194,\n-                     \"type parameter `{}` shadows another type parameter of the same name\",\n-                     name)\n-        .span_label(span, \"shadows another type parameter\")\n-        .span_label(trait_decl_span, format!(\"first `{}` declared here\", name))\n-        .emit();\n-}"}, {"sha": "a88e32eb34dcd51011beaca14c1275b3879d80f6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -283,7 +283,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n-                    self.visit_field_id(field.node.hir_id);\n+                    self.visit_field_id(field.hir_id);\n                 }\n             }\n             _ => {}"}, {"sha": "5ff64224c5aa04eaf3bcc3890416b6e0ba05b2ab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -35,7 +35,6 @@ use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n-use syntax::source_map::Spanned;\n use syntax::feature_gate;\n use syntax::symbol::{InternedString, kw, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -520,7 +519,11 @@ fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants: &[hir::Variant]) {\n+fn convert_enum_variant_types<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    variants: &[hir::Variant]\n+) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n@@ -530,7 +533,7 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n     for variant in variants {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n-            if let Some(ref e) = variant.node.disr_expr {\n+            if let Some(ref e) = variant.disr_expr {\n                 let expr_did = tcx.hir().local_def_id(e.hir_id);\n                 def.eval_explicit_discr(tcx, expr_did)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n@@ -546,14 +549,14 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n                     format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n                 ).note(&format!(\n                     \"explicitly set `{} = {}` if that is desired outcome\",\n-                    variant.node.ident, wrapped_discr\n+                    variant.ident, wrapped_discr\n                 ))\n                 .emit();\n                 None\n             }.unwrap_or(wrapped_discr),\n         );\n \n-        for f in variant.node.data.fields() {\n+        for f in variant.data.fields() {\n             let def_id = tcx.hir().local_def_id(f.hir_id);\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n@@ -562,7 +565,7 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+        if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n             convert_variant_ctor(tcx, ctor_hir_id);\n         }\n     }\n@@ -641,20 +644,20 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n             let variants = def.variants\n                 .iter()\n                 .map(|v| {\n-                    let variant_did = Some(tcx.hir().local_def_id(v.node.id));\n-                    let ctor_did = v.node.data.ctor_hir_id()\n+                    let variant_did = Some(tcx.hir().local_def_id(v.id));\n+                    let ctor_did = v.data.ctor_hir_id()\n                         .map(|hir_id| tcx.hir().local_def_id(hir_id));\n \n-                    let discr = if let Some(ref e) = v.node.disr_expr {\n+                    let discr = if let Some(ref e) = v.disr_expr {\n                         distance_from_explicit = 0;\n                         ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.hir_id))\n                     } else {\n                         ty::VariantDiscr::Relative(distance_from_explicit)\n                     };\n                     distance_from_explicit += 1;\n \n-                    convert_variant(tcx, variant_did, ctor_did, v.node.ident, discr,\n-                                    &v.node.data, AdtKind::Enum, def_id)\n+                    convert_variant(tcx, variant_did, ctor_did, v.ident, discr,\n+                                    &v.data, AdtKind::Enum, def_id)\n                 })\n                 .collect();\n \n@@ -1314,10 +1317,9 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             ForeignItemKind::Type => tcx.mk_foreign(def_id),\n         },\n \n-        Node::Ctor(&ref def) | Node::Variant(&Spanned {\n-            node: hir::VariantKind { data: ref def, .. },\n-            ..\n-        }) => match *def {\n+        Node::Ctor(&ref def) | Node::Variant(\n+            hir::Variant { data: ref def, .. }\n+        ) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n                 tcx.type_of(tcx.hir().get_parent_did(hir_id))\n             }\n@@ -1363,12 +1365,8 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     tcx.types.usize\n                 }\n \n-                Node::Variant(&Spanned {\n-                    node:\n-                        VariantKind {\n-                            disr_expr: Some(ref e),\n-                            ..\n-                        },\n+                Node::Variant(Variant {\n+                    disr_expr: Some(ref e),\n                     ..\n                 }) if e.hir_id == hir_id =>\n                 {\n@@ -1809,10 +1807,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        Ctor(data) | Variant(Spanned {\n-            node: hir::VariantKind { data, ..  },\n-            ..\n-        }) if data.ctor_hir_id().is_some() => {\n+        Ctor(data) | Variant(\n+            hir::Variant { data, ..  }\n+        ) if data.ctor_hir_id().is_some() => {\n             let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id));\n             let inputs = data.fields()\n                 .iter()"}, {"sha": "ca9ce3d22b5cb0dcb2c3858412dcc0386147dab2", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1718,22 +1718,6 @@ Since we know for certain that `Wrapper<u32>` implements `Clone`, there's no\n reason to also specify it in a `where` clause.\n \"##,\n \n-E0194: r##\"\n-A type parameter was declared which shadows an existing one. An example of this\n-error:\n-\n-```compile_fail,E0194\n-trait Foo<T> {\n-    fn do_something(&self) -> T;\n-    fn do_something_else<T: Clone>(&self, bar: T);\n-}\n-```\n-\n-In this example, the trait `Foo` and the trait method `do_something_else` both\n-define a type parameter `T`. This is not allowed: if the method wishes to\n-define a type parameter, it must use a different name for it.\n-\"##,\n-\n E0195: r##\"\n Your method's lifetime parameters do not match the trait declaration.\n Erroneous code example:\n@@ -4837,6 +4821,7 @@ register_diagnostics! {\n //  E0188, // can not cast an immutable reference to a mutable pointer\n //  E0189, // deprecated: can only cast a boxed pointer to a boxed object\n //  E0190, // deprecated: can only cast a &-pointer to an &-object\n+//  E0194, // merged into E0403\n //  E0196, // cannot determine a type for this closure\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported"}, {"sha": "7ed9d6606f646fed672be8e8ae60e0d6d3937f92", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -82,8 +82,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 self.visit_node_helper(item.hir_id);\n \n                 for variant in &enum_def.variants {\n-                    if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.visit_node_helper(variant.node.data.ctor_hir_id().unwrap());\n+                    if let hir::VariantData::Tuple(..) = variant.data {\n+                        self.visit_node_helper(variant.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "e10837e52ad0407e76cb82405fea59d8963bd7ce", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -145,8 +145,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                 self.add_inferreds_for_item(item.hir_id);\n \n                 for variant in &enum_def.variants {\n-                    if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.add_inferreds_for_item(variant.node.data.ctor_hir_id().unwrap());\n+                    if let hir::VariantData::Tuple(..) = variant.data {\n+                        self.add_inferreds_for_item(variant.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "ec5d86b2c611da4076610301e4ee3c9f7b0512a9", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -3,7 +3,6 @@ use super::*;\n use syntax_pos::DUMMY_SP;\n use syntax::ast::*;\n use syntax::attr;\n-use syntax::source_map::dummy_spanned;\n use syntax::symbol::Symbol;\n use syntax::with_default_globals;\n \n@@ -181,7 +180,8 @@ fn test_parse_ok() {\n \n         let mi = attr::mk_name_value_item_str(\n             Ident::from_str(\"all\"),\n-            dummy_spanned(Symbol::intern(\"done\"))\n+            Symbol::intern(\"done\"),\n+            DUMMY_SP,\n         );\n         assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n "}, {"sha": "fede9e930101215768d6139c8ead06e35bd875a0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -29,7 +29,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n-use syntax::source_map::{dummy_spanned, Spanned};\n+use syntax::source_map::DUMMY_SP;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n@@ -930,8 +930,8 @@ impl Attributes {\n             if attr.check_name(sym::enable) {\n                 if let Some(feat) = attr.value_str() {\n                     let meta = attr::mk_name_value_item_str(\n-                        Ident::with_empty_ctxt(sym::target_feature),\n-                        dummy_spanned(feat));\n+                        Ident::with_dummy_span(sym::target_feature), feat, DUMMY_SP\n+                    );\n                     if let Ok(feat_cfg) = Cfg::parse(&meta) {\n                         cfg &= feat_cfg;\n                     }\n@@ -4102,8 +4102,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n         PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n-                fields.iter().map(|&Spanned { node: ref fp, .. }|\n-                                  format!(\"{}: {}\", fp.ident, name_from_pat(&*fp.pat)))\n+                fields.iter().map(|fp| format!(\"{}: {}\", fp.ident, name_from_pat(&fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ..\" } else { \"\" }\n             )"}, {"sha": "c73c46472d804aeeb0fbf1c2e03dc343ab4ca8fa", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -4,6 +4,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint as lint;\n use rustc::ty;\n+use rustc_resolve::ParentScope;\n use syntax;\n use syntax::ast::{self, Ident};\n use syntax::ext::base::SyntaxExtensionKind;\n@@ -431,7 +432,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     let path = ast::Path::from_ident(Ident::from_str(path_str));\n     cx.enter_resolver(|resolver| {\n         if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path, None, &resolver.dummy_parent_scope(), false, false\n+            &path, None, &ParentScope::module(resolver.graph_root), false, false\n         ) {\n             if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n                 return Some(res.map_id(|_| panic!(\"unexpected id\")));"}, {"sha": "83a8d3fc109994d008510c0538b670133b0dd72c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -951,7 +951,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n                      v: &'hir hir::Variant,\n                      g: &'hir hir::Generics,\n                      item_id: hir::HirId) {\n-        self.visit_testable(v.node.ident.to_string(), &v.node.attrs, |this| {\n+        self.visit_testable(v.ident.to_string(), &v.attrs, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }"}, {"sha": "903ed3aae147016e8173e54a798296fa2c639ebc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -130,10 +130,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         Enum {\n             name,\n             variants: def.variants.iter().map(|v| Variant {\n-                name: v.node.ident.name,\n-                id: v.node.id,\n-                attrs: &v.node.attrs,\n-                def: &v.node.data,\n+                name: v.ident.name,\n+                id: v.id,\n+                attrs: &v.attrs,\n+                def: &v.data,\n                 whence: v.span,\n             }).collect(),\n             vis: &it.vis,"}, {"sha": "3288d0b4df2ee48683752d947483eb2f57eefec0", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -23,7 +23,7 @@ libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.16\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n-hashbrown = { version = \"0.4.0\", features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace]\n version = \"0.3.34\""}, {"sha": "a0538986a22421b4fc0cc1cac02738b006f036ef", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -6,7 +6,7 @@ use hashbrown::hash_map as base;\n \n use crate::borrow::Borrow;\n use crate::cell::Cell;\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::fmt::{self, Debug};\n #[allow(deprecated)]\n use crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\n@@ -588,7 +588,7 @@ where\n     /// ```\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.base\n             .try_reserve(additional)\n             .map_err(map_collection_alloc_err)\n@@ -2542,10 +2542,13 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n }\n \n #[inline]\n-fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> CollectionAllocErr {\n+fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> TryReserveError {\n     match err {\n-        hashbrown::CollectionAllocErr::CapacityOverflow => CollectionAllocErr::CapacityOverflow,\n-        hashbrown::CollectionAllocErr::AllocErr => CollectionAllocErr::AllocErr,\n+        hashbrown::CollectionAllocErr::CapacityOverflow => TryReserveError::CapacityOverflow,\n+        hashbrown::CollectionAllocErr::AllocErr { layout } => TryReserveError::AllocError {\n+            layout,\n+            non_exhaustive: (),\n+        },\n     }\n }\n \n@@ -2605,7 +2608,7 @@ mod test_map {\n     use super::RandomState;\n     use crate::cell::RefCell;\n     use rand::{thread_rng, Rng};\n-    use realstd::collections::CollectionAllocErr::*;\n+    use realstd::collections::TryReserveError::*;\n     use realstd::usize;\n \n     // https://github.com/rust-lang/rust/issues/62301\n@@ -3405,7 +3408,7 @@ mod test_map {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n \n-        if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n+        if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n         } else {\n             panic!(\"usize::MAX / 8 should trigger an OOM!\")\n         }"}, {"sha": "26db651ef8911d8194532f0f71a4a870586f3373", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,5 +1,5 @@\n use crate::borrow::Borrow;\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::fmt;\n use crate::hash::{Hash, BuildHasher};\n use crate::iter::{Chain, FromIterator, FusedIterator};\n@@ -383,7 +383,7 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.map.try_reserve(additional)\n     }\n "}, {"sha": "f5957466be841009683e087023f5527bd8951e3a", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -427,7 +427,7 @@ pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub use alloc_crate::collections::CollectionAllocErr;\n+pub use alloc_crate::collections::TryReserveError;\n \n mod hash;\n "}, {"sha": "c3882bacf87eb0bcdbadcc9eb6a144772cac95a6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -228,7 +228,6 @@\n // std is implemented with unstable features, many of which are internal\n // compiler details that will never be stable\n // NB: the following list is sorted to minimize merge conflicts.\n-#![cfg_attr(not(bootstrap), feature(__rust_unstable_column))]\n #![feature(alloc_error_handler)]\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]\n@@ -251,6 +250,7 @@\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]\n #![feature(const_raw_ptr_deref)]\n+#![feature(container_error_extra)]\n #![feature(core_intrinsics)]\n #![feature(custom_test_frameworks)]\n #![feature(doc_alias)]\n@@ -513,7 +513,7 @@ pub use std_detect::detect;\n \n // Re-export macros defined in libcore.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated_in_future)]\n+#[allow(deprecated, deprecated_in_future)]\n pub use core::{\n     // Stable\n     assert_eq,\n@@ -531,7 +531,6 @@ pub use core::{\n };\n \n // Re-export built-in macros defined through libcore.\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use core::{\n     // Stable\n@@ -551,7 +550,6 @@ pub use core::{\n     option_env,\n     stringify,\n     // Unstable\n-    __rust_unstable_column,\n     asm,\n     concat_idents,\n     format_args_nl,"}, {"sha": "cbeaf20b13adc923fc5a913e378fdb76a56a316b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -53,20 +53,20 @@\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable(__rust_unstable_column, libstd_sys_internals)]\n+#[allow_internal_unstable(libstd_sys_internals)]\n macro_rules! panic {\n     () => ({\n         $crate::panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n-        $crate::rt::begin_panic($msg, &(file!(), line!(), __rust_unstable_column!()))\n+        $crate::rt::begin_panic($msg, &($crate::file!(), $crate::line!(), $crate::column!()))\n     });\n     ($msg:expr,) => ({\n         $crate::panic!($msg)\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::rt::begin_panic_fmt(&format_args!($fmt, $($arg)+),\n-                                    &(file!(), line!(), __rust_unstable_column!()))\n+        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+),\n+                                    &($crate::file!(), $crate::line!(), $crate::column!()))\n     });\n }\n \n@@ -113,7 +113,7 @@ macro_rules! panic {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable(print_internals)]\n macro_rules! print {\n-    ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));\n+    ($($arg:tt)*) => ($crate::io::_print($crate::format_args!($($arg)*)));\n }\n \n /// Prints to the standard output, with a newline.\n@@ -147,7 +147,7 @@ macro_rules! print {\n macro_rules! println {\n     () => ($crate::print!(\"\\n\"));\n     ($($arg:tt)*) => ({\n-        $crate::io::_print(format_args_nl!($($arg)*));\n+        $crate::io::_print($crate::format_args_nl!($($arg)*));\n     })\n }\n \n@@ -176,7 +176,7 @@ macro_rules! println {\n #[stable(feature = \"eprint\", since = \"1.19.0\")]\n #[allow_internal_unstable(print_internals)]\n macro_rules! eprint {\n-    ($($arg:tt)*) => ($crate::io::_eprint(format_args!($($arg)*)));\n+    ($($arg:tt)*) => ($crate::io::_eprint($crate::format_args!($($arg)*)));\n }\n \n /// Prints to the standard error, with a newline.\n@@ -206,7 +206,7 @@ macro_rules! eprint {\n macro_rules! eprintln {\n     () => ($crate::eprint!(\"\\n\"));\n     ($($arg:tt)*) => ({\n-        $crate::io::_eprint(format_args_nl!($($arg)*));\n+        $crate::io::_eprint($crate::format_args_nl!($($arg)*));\n     })\n }\n \n@@ -337,15 +337,15 @@ macro_rules! eprintln {\n #[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\n macro_rules! dbg {\n     () => {\n-        $crate::eprintln!(\"[{}:{}]\", file!(), line!());\n+        $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n     };\n     ($val:expr) => {\n         // Use of `match` here is intentional because it affects the lifetimes\n         // of temporaries - https://stackoverflow.com/a/48732525/1063961\n         match $val {\n             tmp => {\n                 $crate::eprintln!(\"[{}:{}] {} = {:#?}\",\n-                    file!(), line!(), stringify!($val), &tmp);\n+                    $crate::file!(), $crate::line!(), $crate::stringify!($val), &tmp);\n                 tmp\n             }\n         }"}, {"sha": "611a1709c8d91c688fc5014ecad786eec9c5baea", "filename": "src/libstd/os/raw/mod.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -8,8 +8,7 @@\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n-#[cfg_attr(bootstrap, doc(include = \"os/raw/char.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"char.md\"))]\n+#[doc(include = \"char.md\")]\n #[cfg(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                        target_arch = \"arm\",\n                                        target_arch = \"hexagon\",\n@@ -33,8 +32,7 @@\n                                          target_arch = \"powerpc\")),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/char.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"char.md\"))]\n+#[doc(include = \"char.md\")]\n #[cfg(not(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                            target_arch = \"arm\",\n                                            target_arch = \"hexagon\",\n@@ -58,51 +56,37 @@\n                                              target_arch = \"powerpc\")),\n               all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/schar.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"schar.md\"))]\n+#[doc(include = \"schar.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/uchar.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"uchar.md\"))]\n+#[doc(include = \"uchar.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/short.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"short.md\"))]\n+#[doc(include = \"short.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_short = i16;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/ushort.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"ushort.md\"))]\n+#[doc(include = \"ushort.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ushort = u16;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/int.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"int.md\"))]\n+#[doc(include = \"int.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_int = i32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/uint.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"uint.md\"))]\n+#[doc(include = \"uint.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uint = u32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/long.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"long.md\"))]\n+#[doc(include = \"long.md\")]\n #[cfg(any(target_pointer_width = \"32\", windows))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_long = i32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/ulong.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"ulong.md\"))]\n+#[doc(include = \"ulong.md\")]\n #[cfg(any(target_pointer_width = \"32\", windows))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulong = u32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/long.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"long.md\"))]\n+#[doc(include = \"long.md\")]\n #[cfg(all(target_pointer_width = \"64\", not(windows)))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_long = i64;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/ulong.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"ulong.md\"))]\n+#[doc(include = \"ulong.md\")]\n #[cfg(all(target_pointer_width = \"64\", not(windows)))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulong = u64;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/longlong.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"longlong.md\"))]\n+#[doc(include = \"longlong.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_longlong = i64;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/ulonglong.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"ulonglong.md\"))]\n+#[doc(include = \"ulonglong.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulonglong = u64;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/float.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"float.md\"))]\n+#[doc(include = \"float.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_float = f32;\n-#[cfg_attr(bootstrap, doc(include = \"os/raw/double.md\"))]\n-#[cfg_attr(not(bootstrap), doc(include = \"double.md\"))]\n+#[doc(include = \"double.md\")]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_double = f64;\n \n #[stable(feature = \"raw_os\", since = \"1.1.0\")]"}, {"sha": "3e4cf91127fc5b87ad1d99594260f1f3c327466e", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -7,10 +7,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Re-exported core operators\n-#[cfg(bootstrap)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n-pub use crate::marker::Copy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::marker::{Send, Sized, Sync, Unpin};\n@@ -24,21 +20,9 @@ pub use crate::ops::{Drop, Fn, FnMut, FnOnce};\n pub use crate::mem::drop;\n \n // Re-exported types and traits\n-#[cfg(bootstrap)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n-pub use crate::clone::Clone;\n-#[cfg(bootstrap)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n-pub use crate::cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::convert::{AsRef, AsMut, Into, From};\n-#[cfg(bootstrap)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n-pub use crate::default::Default;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::iter::{Iterator, Extend, IntoIterator};\n@@ -53,11 +37,9 @@ pub use crate::option::Option::{self, Some, None};\n pub use crate::result::Result::{self, Ok, Err};\n \n // Re-exported built-in macros\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use core::prelude::v1::{\n-    __rust_unstable_column,\n     asm,\n     assert,\n     cfg,\n@@ -83,7 +65,6 @@ pub use core::prelude::v1::{\n \n // FIXME: Attribute and derive macros are not documented because for them rustdoc generates\n // dead links which fail link checker testing.\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n #[doc(hidden)]"}, {"sha": "fd6e46fd61dc581d7c331de0aecba4c16a6ece5f", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -163,7 +163,6 @@ pub use self::condvar::{Condvar, WaitTimeoutResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::mutex::{Mutex, MutexGuard};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(bootstrap, allow(deprecated_in_future))]\n #[allow(deprecated)]\n pub use self::once::{Once, OnceState, ONCE_INIT};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "38db4dd51657a10a864d4ab85e4ed3a9e63988d9", "filename": "src/libstd/sys/cloudabi/abi/cloudabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -115,6 +115,7 @@\n \n #![no_std]\n #![allow(non_camel_case_types)]\n+#![allow(deprecated)] // FIXME: using `mem::uninitialized()`\n \n include!(\"bitflags.rs\");\n "}, {"sha": "2fb10cc370add607dade6387b5008fae03fc310f", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,5 +1,3 @@\n-#![allow(deprecated_in_future)] // mem::uninitialized; becomes `deprecated` when nightly is 1.39\n-\n use crate::io::ErrorKind;\n use crate::mem;\n "}, {"sha": "0e30d3a1c6cf124989c40c642db5cece663622d6", "filename": "src/libstd/sys/cloudabi/mutex.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -104,10 +104,11 @@ impl ReentrantMutex {\n                 },\n                 ..mem::zeroed()\n             };\n-            let mut event: abi::event = mem::uninitialized();\n-            let mut nevents: usize = mem::uninitialized();\n-            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            let mut event = MaybeUninit::<abi::event>::uninit();\n+            let mut nevents = MaybeUninit::<usize>::uninit();\n+            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n+            let event = event.assume_init();\n             assert_eq!(event.error, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n         }\n     }"}, {"sha": "73499d65a067fa46e637facecd3997444be33c79", "filename": "src/libstd/sys/cloudabi/rwlock.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,5 +1,6 @@\n use crate::cell::UnsafeCell;\n use crate::mem;\n+use crate::mem::MaybeUninit;\n use crate::sync::atomic::{AtomicU32, Ordering};\n use crate::sys::cloudabi::abi;\n \n@@ -73,10 +74,11 @@ impl RWLock {\n                 },\n                 ..mem::zeroed()\n             };\n-            let mut event: abi::event = mem::uninitialized();\n-            let mut nevents: usize = mem::uninitialized();\n-            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            let mut event = MaybeUninit::<abi::event>::uninit();\n+            let mut nevents = MaybeUninit::<usize>::uninit();\n+            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire read lock\");\n+            let event = event.assume_init();\n             assert_eq!(\n                 event.error,\n                 abi::errno::SUCCESS,\n@@ -182,10 +184,11 @@ impl RWLock {\n                 },\n                 ..mem::zeroed()\n             };\n-            let mut event: abi::event = mem::uninitialized();\n-            let mut nevents: usize = mem::uninitialized();\n-            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            let mut event = MaybeUninit::<abi::event>::uninit();\n+            let mut nevents = MaybeUninit::<usize>::uninit();\n+            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire write lock\");\n+            let event = event.assume_init();\n             assert_eq!(\n                 event.error,\n                 abi::errno::SUCCESS,"}, {"sha": "240b6ea9e57f8ede0d75755e1eca01a6d7b7737b", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -72,10 +72,11 @@ impl Thread {\n                 },\n                 ..mem::zeroed()\n             };\n-            let mut event: abi::event = mem::uninitialized();\n-            let mut nevents: usize = mem::uninitialized();\n-            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            let mut event = mem::MaybeUninit::<abi::event>::uninit();\n+            let mut nevents = mem::MaybeUninit::<usize>::uninit();\n+            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n             assert_eq!(ret, abi::errno::SUCCESS);\n+            let event = event.assume_init();\n             assert_eq!(event.error, abi::errno::SUCCESS);\n         }\n     }"}, {"sha": "b1f9d9766f7055ff17079704420d8782c98a24cb", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -714,7 +714,7 @@ if #[cfg(target_vendor = \"uwp\")] {\n     pub struct FILE_STANDARD_INFO {\n         pub AllocationSize: LARGE_INTEGER,\n         pub EndOfFile: LARGE_INTEGER,\n-        pub NumberOfLink: DWORD,\n+        pub NumberOfLinks: DWORD,\n         pub DeletePending: BOOLEAN,\n         pub Directory: BOOLEAN,\n     }"}, {"sha": "204f6af5fc1a0432788922315838da2deb70b86e", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -357,7 +357,7 @@ impl File {\n                                                 size as c::DWORD))?;\n             attr.file_size = info.AllocationSize as u64;\n             attr.number_of_links = Some(info.NumberOfLinks);\n-            if attr.is_reparse_point() {\n+            if attr.file_type().is_reparse_point() {\n                 let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n                     attr.reparse_tag = buf.ReparseTag;"}, {"sha": "9091607629e0fabae7c1938ff9c8c1b8e2a4f926", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -5,7 +5,7 @@ pub use UnsafeSource::*;\n pub use crate::symbol::{Ident, Symbol as Name};\n pub use crate::util::parser::ExprPrecedence;\n \n-use crate::ext::hygiene::{ExpnId, SyntaxContext};\n+use crate::ext::hygiene::ExpnId;\n use crate::parse::token::{self, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n@@ -571,7 +571,7 @@ impl Pat {\n \n         match &self.node {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n-            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.node.pat.walk(it)),\n+            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk(it)),\n             PatKind::TupleStruct(_, s) | PatKind::Tuple(s) | PatKind::Slice(s) => {\n                 s.iter().all(|p| p.walk(it))\n             }\n@@ -608,6 +608,8 @@ pub struct FieldPat {\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n     pub attrs: ThinVec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n@@ -641,7 +643,7 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Path, Vec<Spanned<FieldPat>>, /* recovered */ bool),\n+    Struct(Path, Vec<FieldPat>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n     TupleStruct(Path, Vec<P<Pat>>),\n@@ -925,6 +927,7 @@ pub struct Arm {\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n     pub span: Span,\n+    pub id: NodeId,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -934,10 +937,9 @@ pub struct Field {\n     pub span: Span,\n     pub is_shorthand: bool,\n     pub attrs: ThinVec<Attribute>,\n+    pub id: NodeId,\n }\n \n-pub type SpannedIdent = Spanned<Ident>;\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BlockCheckMode {\n     Default,\n@@ -1284,19 +1286,18 @@ pub enum Movability {\n     Movable,\n }\n \n-pub type Mac = Spanned<Mac_>;\n-\n /// Represents a macro invocation. The `Path` indicates which macro\n /// is being invoked, and the vector of token-trees contains the source\n /// of the macro invocation.\n ///\n /// N.B., the additional ident for a `macro_rules`-style macro is actually\n /// stored in the enclosing item.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Mac_ {\n+pub struct Mac {\n     pub path: Path,\n     pub delim: MacDelimiter,\n     pub tts: TokenStream,\n+    pub span: Span,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n@@ -1307,7 +1308,7 @@ pub enum MacDelimiter {\n     Brace,\n }\n \n-impl Mac_ {\n+impl Mac {\n     pub fn stream(&self) -> TokenStream {\n         self.tts.clone()\n     }\n@@ -1781,7 +1782,6 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n-    pub ctxt: SyntaxContext,\n }\n \n /// An argument in a function header.\n@@ -2029,7 +2029,6 @@ pub struct ForeignMod {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n-    pub ctxt: SyntaxContext,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2038,7 +2037,7 @@ pub struct EnumDef {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Variant_ {\n+pub struct Variant {\n     /// Name of the variant.\n     pub ident: Ident,\n     /// Attributes of the variant.\n@@ -2049,10 +2048,10 @@ pub struct Variant_ {\n     pub data: VariantData,\n     /// Explicit discriminant, e.g., `Foo = 1`.\n     pub disr_expr: Option<AnonConst>,\n+    /// Span\n+    pub span: Span,\n }\n \n-pub type Variant = Spanned<Variant_>;\n-\n /// Part of `use` item to the right of its prefix.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum UseTreeKind {"}, {"sha": "bcf03b5237a8d1a33c73b0ee66b5ea2caa702d6e", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -13,7 +13,7 @@ use crate::ast::{AttrId, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n-use crate::source_map::{BytePos, Spanned, dummy_spanned};\n+use crate::source_map::{BytePos, Spanned, DUMMY_SP};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::parser::Parser;\n use crate::parse::{self, ParseSess, PResult};\n@@ -327,8 +327,10 @@ impl Attribute {\n         if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                Ident::with_empty_ctxt(sym::doc),\n-                dummy_spanned(Symbol::intern(&strip_doc_comment_decoration(&comment.as_str()))));\n+                Ident::with_dummy_span(sym::doc),\n+                Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())),\n+                DUMMY_SP,\n+            );\n             f(&Attribute {\n                 id: self.id,\n                 style: self.style,\n@@ -345,9 +347,9 @@ impl Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem {\n-    let lit_kind = LitKind::Str(value.node, ast::StrStyle::Cooked);\n-    mk_name_value_item(ident, lit_kind, value.span)\n+pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n+    let lit_kind = LitKind::Str(str, ast::StrStyle::Cooked);\n+    mk_name_value_item(ident, lit_kind, str_span)\n }\n \n pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n@@ -410,7 +412,7 @@ pub fn mk_sugared_doc_attr(text: Symbol, span: Span) -> Attribute {\n     Attribute {\n         id: mk_attr_id(),\n         style,\n-        path: Path::from_ident(Ident::with_empty_ctxt(sym::doc).with_span_pos(span)),\n+        path: Path::from_ident(Ident::with_dummy_span(sym::doc).with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,\n@@ -712,7 +714,7 @@ macro_rules! derive_has_attrs {\n \n derive_has_attrs! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm,\n-    ast::Field, ast::FieldPat, ast::Variant_, ast::Arg\n+    ast::Field, ast::FieldPat, ast::Variant, ast::Arg\n }\n \n pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {"}, {"sha": "7eeea4e7bdfe191d92ea850bce252ac62cbbd69f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -260,7 +260,7 @@ impl<'a> StripUnconfigured<'a> {\n             ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n                 variants.flat_map_in_place(|variant| self.configure(variant));\n                 for variant in variants {\n-                    self.configure_variant_data(&mut variant.node.data);\n+                    self.configure_variant_data(&mut variant.data);\n                 }\n             }\n             _ => {}"}, {"sha": "9618b5acfb0f18d8b72d8e07b385a265398507c9", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -172,7 +172,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n             (descriptions.len(), ecx.expr_vec(span, descriptions))\n         });\n \n-    let static_ = ecx.lifetime(span, Ident::with_empty_ctxt(kw::StaticLifetime));\n+    let static_ = ecx.lifetime(span, Ident::with_dummy_span(kw::StaticLifetime));\n     let ty_str = ecx.ty_rptr(\n         span,\n         ecx.ty_ident(span, ecx.ident_of(\"str\")),"}, {"sha": "fb1bf4d7160e7e2ed7e576fa808a3d8699ee1e69", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 35, "deletions": 62, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,6 +1,6 @@\n use crate::ast::{self, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n-use crate::source_map::{SourceMap, Spanned, respan};\n+use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n@@ -15,7 +15,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{FileName, Span, MultiSpan, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -405,7 +405,6 @@ impl MacResult for MacEager {\n /// after hitting errors.\n #[derive(Copy, Clone)]\n pub struct DummyResult {\n-    expr_only: bool,\n     is_error: bool,\n     span: Span,\n }\n@@ -416,21 +415,12 @@ impl DummyResult {\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n     pub fn any(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: false, is_error: true, span })\n+        Box::new(DummyResult { is_error: true, span })\n     }\n \n     /// Same as `any`, but must be a valid fragment, not error.\n     pub fn any_valid(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: false, is_error: false, span })\n-    }\n-\n-    /// Creates a default MacResult that can only be an expression.\n-    ///\n-    /// Use this for macros that must expand to an expression, so even\n-    /// if an error is encountered internally, the user will receive\n-    /// an error that they also used it in the wrong place.\n-    pub fn expr(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: true, is_error: true, span })\n+        Box::new(DummyResult { is_error: false, span })\n     }\n \n     /// A plain dummy expression.\n@@ -472,36 +462,19 @@ impl MacResult for DummyResult {\n     }\n \n     fn make_items(self: Box<DummyResult>) -> Option<SmallVec<[P<ast::Item>; 1]>> {\n-        // this code needs a comment... why not always just return the Some() ?\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::ImplItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::TraitItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_foreign_items(self: Box<Self>) -> Option<SmallVec<[ast::ForeignItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVec<[ast::Stmt; 1]>> {\n@@ -667,10 +640,11 @@ impl SyntaxExtension {\n         SyntaxExtension::default(SyntaxExtensionKind::NonMacroAttr { mark_used }, edition)\n     }\n \n-    pub fn expn_info(&self, call_site: Span, descr: Symbol) -> ExpnInfo {\n-        ExpnInfo {\n-            call_site,\n+    pub fn expn_data(&self, parent: ExpnId, call_site: Span, descr: Symbol) -> ExpnData {\n+        ExpnData {\n             kind: ExpnKind::Macro(self.macro_kind(), descr),\n+            parent,\n+            call_site,\n             def_site: self.span,\n             default_transparency: self.default_transparency,\n             allow_internal_unstable: self.allow_internal_unstable.clone(),\n@@ -734,7 +708,7 @@ pub struct ExpansionData {\n \n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n-/// -> expn_info` of their expansion context stored into their span.\n+/// -> expn_data` of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n@@ -783,13 +757,10 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        match self.current_expansion.id.expn_info() {\n-            Some(expn_info) => expn_info.call_site,\n-            None => DUMMY_SP,\n-        }\n+        self.current_expansion.id.expn_data().call_site\n     }\n     pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::empty().apply_mark(self.current_expansion.id)\n+        SyntaxContext::root().apply_mark(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n@@ -799,17 +770,13 @@ impl<'a> ExtCtxt<'a> {\n         let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n-            if ctxt.outer_expn_info().map_or(None, |info| {\n-                if info.kind.descr() == sym::include {\n-                    // Stop going up the backtrace once include! is encountered\n-                    return None;\n-                }\n-                ctxt = info.call_site.ctxt();\n-                last_macro = Some(info.call_site);\n-                Some(())\n-            }).is_none() {\n-                break\n+            let expn_data = ctxt.outer_expn_data();\n+            // Stop going up the backtrace once include! is encountered\n+            if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n+                break;\n             }\n+            ctxt = expn_data.call_site.ctxt();\n+            last_macro = Some(expn_data.call_site);\n         }\n         last_macro\n     }\n@@ -899,7 +866,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n         let def_site = DUMMY_SP.apply_mark(self.current_expansion.id);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n-            .chain(components.iter().map(|&s| Ident::with_empty_ctxt(s)))\n+            .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n     }\n     pub fn name_of(&self, st: &str) -> ast::Name {\n@@ -943,15 +910,17 @@ pub fn expr_to_spanned_string<'a>(\n     cx: &'a mut ExtCtxt<'_>,\n     mut expr: P<ast::Expr>,\n     err_msg: &str,\n-) -> Result<Spanned<(Symbol, ast::StrStyle)>, Option<DiagnosticBuilder<'a>>> {\n+) -> Result<(Symbol, ast::StrStyle, Span), Option<DiagnosticBuilder<'a>>> {\n     // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n     expr.span = expr.span.apply_mark(cx.current_expansion.id);\n \n-    // we want to be able to handle e.g., `concat!(\"foo\", \"bar\")`\n-    cx.expander().visit_expr(&mut expr);\n+    // Perform eager expansion on the expression.\n+    // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n+    let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n+\n     Err(match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n-            ast::LitKind::Str(s, style) => return Ok(respan(expr.span, (s, style))),\n+            ast::LitKind::Str(s, style) => return Ok((s, style, expr.span)),\n             ast::LitKind::Err(_) => None,\n             _ => Some(cx.struct_span_err(l.span, err_msg))\n         },\n@@ -965,7 +934,7 @@ pub fn expr_to_string(cx: &mut ExtCtxt<'_>, expr: P<ast::Expr>, err_msg: &str)\n     expr_to_spanned_string(cx, expr, err_msg)\n         .map_err(|err| err.map(|mut err| err.emit()))\n         .ok()\n-        .map(|s| s.node)\n+        .map(|(symbol, style, _)| (symbol, style))\n }\n \n /// Non-fatally assert that `tts` is empty. Note that this function\n@@ -1013,8 +982,12 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>,\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n-        let mut expr = panictry!(p.parse_expr());\n-        cx.expander().visit_expr(&mut expr);\n+        let expr = panictry!(p.parse_expr());\n+\n+        // Perform eager expansion on the expression.\n+        // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n+        let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n+\n         es.push(expr);\n         if p.eat(&token::Comma) {\n             continue;"}, {"sha": "e2ac4d573a1e0adde3c0892dd2d48557948727e9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -340,7 +340,7 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     pub fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, Ident::with_empty_ctxt(kw::SelfLower))\n+        self.expr_ident(span, Ident::with_dummy_span(kw::SelfLower))\n     }\n \n     pub fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n@@ -403,6 +403,7 @@ impl<'a> ExtCtxt<'a> {\n             span,\n             is_shorthand: false,\n             attrs: ThinVec::new(),\n+            id: ast::DUMMY_NODE_ID,\n         }\n     }\n     pub fn expr_struct(\n@@ -574,7 +575,7 @@ impl<'a> ExtCtxt<'a> {\n         self.pat(span, PatKind::TupleStruct(path, subpats))\n     }\n     pub fn pat_struct(&self, span: Span, path: ast::Path,\n-                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n+                      field_pats: Vec<ast::FieldPat>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Struct(path, field_pats, false))\n     }\n     pub fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n@@ -612,6 +613,7 @@ impl<'a> ExtCtxt<'a> {\n             guard: None,\n             body: expr,\n             span,\n+            id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n@@ -781,14 +783,14 @@ impl<'a> ExtCtxt<'a> {\n             ast::VariantData::Tuple(fields, ast::DUMMY_NODE_ID)\n         };\n \n-        respan(span,\n-               ast::Variant_ {\n-                   ident,\n-                   id: ast::DUMMY_NODE_ID,\n-                   attrs: Vec::new(),\n-                   data: vdata,\n-                   disr_expr: None,\n-               })\n+        ast::Variant {\n+            attrs: Vec::new(),\n+            data: vdata,\n+            disr_expr: None,\n+            id: ast::DUMMY_NODE_ID,\n+            ident,\n+            span,\n+        }\n     }\n \n     pub fn item_enum_poly(&self, span: Span, name: Ident,"}, {"sha": "dac402921b95c2b0ac379d8796e2cc77e96abe24", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,11 +1,11 @@\n use crate::ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n use crate::ast::{MacStmtStyle, StmtKind, ItemKind};\n use crate::attr::{self, HasAttrs};\n-use crate::source_map::{dummy_spanned, respan};\n+use crate::source_map::respan;\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::proc_macro::collect_derives;\n-use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n@@ -25,7 +25,6 @@ use syntax_pos::{Span, DUMMY_SP, FileName};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use std::fs;\n use std::io::ErrorKind;\n use std::{iter, mem};\n use std::ops::DerefMut;\n@@ -116,18 +115,6 @@ macro_rules! ast_fragments {\n             }\n         }\n \n-        impl<'a, 'b> MutVisitor for MacroExpander<'a, 'b> {\n-            fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-                self.expand_fragment(AstFragment::OptExpr(Some(expr))).make_opt_expr()\n-            }\n-            $($(fn $mut_visit_ast(&mut self, ast: &mut $AstTy) {\n-                visit_clobber(ast, |ast| self.expand_fragment(AstFragment::$Kind(ast)).$make_ast());\n-            })?)*\n-            $($(fn $flat_map_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n-                self.expand_fragment(AstFragment::$Kind(smallvec![ast_elt])).$make_ast()\n-            })?)*\n-        }\n-\n         impl<'a> MacResult for crate::ext::tt::macro_rules::ParserAnyMacro<'a> {\n             $(fn $make_ast(self: Box<crate::ext::tt::macro_rules::ParserAnyMacro<'a>>)\n                            -> Option<$AstTy> {\n@@ -265,7 +252,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             tokens: None,\n         })]);\n \n-        match self.expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n+        match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n             Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n@@ -285,8 +272,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         krate\n     }\n \n-    // Fully expand all macro invocations in this AST fragment.\n-    fn expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n+    // Recursively expand all macro invocations in this AST fragment.\n+    pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         self.cx.current_expansion.depth = 0;\n \n@@ -365,7 +352,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 derives.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n-                    let expn_id = ExpnId::fresh(self.cx.current_expansion.id, None);\n+                    let expn_id = ExpnId::fresh(None);\n                     derives.push(expn_id);\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive { path, item: item.clone() },\n@@ -487,11 +474,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let info = self.cx.current_expansion.id.expn_info().unwrap();\n+            let expn_data = self.cx.current_expansion.id.expn_data();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n-            let mut err = self.cx.struct_span_err(info.call_site,\n+            let mut err = self.cx.struct_span_err(expn_data.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                         info.kind.descr()));\n+                         expn_data.kind.descr()));\n             err.help(&format!(\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                 suggested_limit));\n@@ -504,22 +491,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n-                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                    let tok_result = expander.expand(self.cx, span, mac.stream());\n                     let result =\n-                        self.parse_ast_fragment(tok_result, fragment_kind, &mac.node.path, span);\n+                        self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n                     result\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n                     let prev = self.cx.current_expansion.prior_type_ascription;\n-                    self.cx.current_expansion.prior_type_ascription =\n-                        mac.node.prior_type_ascription;\n-                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                    self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n+                    let tok_result = expander.expand(self.cx, span, mac.stream());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n                         let msg = format!(\"non-{kind} macro in {kind} position: {path}\",\n-                                          kind = fragment_kind.name(), path = mac.node.path);\n+                                          kind = fragment_kind.name(), path = mac.path);\n                         self.cx.span_err(span, &msg);\n                         self.cx.trace_macros_diag();\n                         fragment_kind.dummy(span)\n@@ -772,7 +758,7 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"macro expansion ignores token `{}` and any following\",\n                               self.this_token_to_string());\n             // Avoid emitting backtrace info twice.\n-            let def_site_span = self.token.span.with_ctxt(SyntaxContext::empty());\n+            let def_site_span = self.token.span.with_ctxt(SyntaxContext::root());\n             let mut err = self.diagnostic().struct_span_err(def_site_span, &msg);\n             err.span_label(span, \"caused by the macro expansion here\");\n             let msg = format!(\n@@ -809,17 +795,20 @@ struct InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        // Expansion info for all the collected invocations is set upon their resolution,\n+        // Expansion data for all the collected invocations is set upon their resolution,\n         // with exception of the derive container case which is not resolved and can get\n-        // its expansion info immediately.\n-        let expn_info = match &kind {\n-            InvocationKind::DeriveContainer { item, .. } => Some(ExpnInfo::default(\n-                ExpnKind::Macro(MacroKind::Attr, sym::derive),\n-                item.span(), self.cx.parse_sess.edition,\n-            )),\n+        // its expansion data immediately.\n+        let expn_data = match &kind {\n+            InvocationKind::DeriveContainer { item, .. } => Some(ExpnData {\n+                parent: self.cx.current_expansion.id,\n+                ..ExpnData::default(\n+                    ExpnKind::Macro(MacroKind::Attr, sym::derive),\n+                    item.span(), self.cx.parse_sess.edition,\n+                )\n+            }),\n             _ => None,\n         };\n-        let expn_id = ExpnId::fresh(self.cx.current_expansion.id, expn_info);\n+        let expn_id = ExpnId::fresh(expn_data);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,\n@@ -1251,30 +1240,30 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     }\n \n                     let filename = self.cx.resolve_path(&*file.as_str(), it.span());\n-                    match fs::read_to_string(&filename) {\n-                        Ok(src) => {\n-                            let src_interned = Symbol::intern(&src);\n-\n-                            // Add this input file to the code map to make it available as\n-                            // dependency information\n-                            self.cx.source_map().new_source_file(filename.into(), src);\n+                    match self.cx.source_map().load_file(&filename) {\n+                        Ok(source_file) => {\n+                            let src = source_file.src.as_ref()\n+                                .expect(\"freshly loaded file should have a source\");\n+                            let src_interned = Symbol::intern(src.as_str());\n \n                             let include_info = vec![\n                                 ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n-                                        Ident::with_empty_ctxt(sym::file),\n-                                        dummy_spanned(file),\n+                                        Ident::with_dummy_span(sym::file),\n+                                        file,\n+                                        DUMMY_SP,\n                                     ),\n                                 ),\n                                 ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n-                                        Ident::with_empty_ctxt(sym::contents),\n-                                        dummy_spanned(src_interned),\n+                                        Ident::with_dummy_span(sym::contents),\n+                                        src_interned,\n+                                        DUMMY_SP,\n                                     ),\n                                 ),\n                             ];\n \n-                            let include_ident = Ident::with_empty_ctxt(sym::include);\n+                            let include_ident = Ident::with_dummy_span(sym::include);\n                             let item = attr::mk_list_item(include_ident, include_info);\n                             items.push(ast::NestedMetaItem::MetaItem(item));\n                         }\n@@ -1336,7 +1325,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 }\n             }\n \n-            let meta = attr::mk_list_item(Ident::with_empty_ctxt(sym::doc), items);\n+            let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n             *at = attr::Attribute {\n                 span: at.span,\n                 id: at.id,"}, {"sha": "2d05f8f0b00478b8a35f65851f097c7c9057af8c", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -14,12 +14,13 @@ use rustc_data_structures::fx::FxHashMap;\n \n pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     fn mac_placeholder() -> ast::Mac {\n-        dummy_spanned(ast::Mac_ {\n+        ast::Mac {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n             tts: TokenStream::empty().into(),\n             delim: ast::MacDelimiter::Brace,\n+            span: DUMMY_SP,\n             prior_type_ascription: None,\n-        })\n+        }\n     }\n \n     let ident = ast::Ident::invalid();"}, {"sha": "1619fa6994198efb139dcd6d3c9981b3ce7be439", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -362,10 +362,10 @@ pub(crate) struct Rustc<'a> {\n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.id.expn_info().unwrap().call_site;\n+        let location = cx.current_expansion.id.expn_data().call_site;\n         let to_span = |transparency| {\n             location.with_ctxt(\n-                SyntaxContext::empty()\n+                SyntaxContext::root()\n                     .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n             )\n         };\n@@ -677,7 +677,7 @@ impl server::Span for Rustc<'_> {\n         self.sess.source_map().lookup_char_pos(span.lo()).file\n     }\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n-        span.ctxt().outer_expn_info().map(|i| i.call_site)\n+        span.parent()\n     }\n     fn source(&mut self, span: Self::Span) -> Self::Span {\n         span.source_callsite()"}, {"sha": "1a87a903156d2482c93db88f7d85ec9232b83932", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -30,7 +30,6 @@ use crate::tokenstream::TokenTree;\n \n use errors::{Applicability, DiagnosticBuilder, Handler};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use log::debug;\n@@ -1956,7 +1955,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n             ast::ItemKind::Enum(ast::EnumDef{ref variants, ..}, ..) => {\n                 for variant in variants {\n-                    match (&variant.node.data, &variant.node.disr_expr) {\n+                    match (&variant.data, &variant.disr_expr) {\n                         (ast::VariantData::Unit(..), _) => {},\n                         (_, Some(disr_expr)) =>\n                             gate_feature_post!(\n@@ -2088,11 +2087,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                        \"type ascription is experimental\");\n                 }\n             }\n-            ast::ExprKind::Yield(..) => {\n-                gate_feature_post!(&self, generators,\n-                                  e.span,\n-                                  \"yield syntax is experimental\");\n-            }\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n@@ -2427,10 +2421,6 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     features\n }\n \n-fn for_each_in_lock<T>(vec: &Lock<Vec<T>>, f: impl Fn(&T)) {\n-    vec.borrow().iter().for_each(f);\n-}\n-\n pub fn check_crate(krate: &ast::Crate,\n                    sess: &ParseSess,\n                    features: &Features,\n@@ -2443,26 +2433,16 @@ pub fn check_crate(krate: &ast::Crate,\n         plugin_attributes,\n     };\n \n-    for_each_in_lock(&sess.param_attr_spans, |span| gate_feature!(\n-        &ctx,\n-        param_attrs,\n-        *span,\n-        \"attributes on function parameters are unstable\"\n-    ));\n-\n-    for_each_in_lock(&sess.let_chains_spans, |span| gate_feature!(\n-        &ctx,\n-        let_chains,\n-        *span,\n-        \"`let` expressions in this position are experimental\"\n-    ));\n-\n-    for_each_in_lock(&sess.async_closure_spans, |span| gate_feature!(\n-        &ctx,\n-        async_closure,\n-        *span,\n-        \"async closures are unstable\"\n-    ));\n+    macro_rules! gate_all {\n+        ($spans:ident, $gate:ident, $msg:literal) => {\n+            for span in &*sess.$spans.borrow() { gate_feature!(&ctx, $gate, *span, $msg); }\n+        }\n+    }\n+\n+    gate_all!(param_attr_spans, param_attrs, \"attributes on function parameters are unstable\");\n+    gate_all!(let_chains_spans, let_chains, \"`let` expressions in this position are experimental\");\n+    gate_all!(async_closure_spans, async_closure, \"async closures are unstable\");\n+    gate_all!(yield_spans, generators, \"yield syntax is experimental\");\n \n     let visitor = &mut PostExpansionVisitor {\n         context: &ctx,"}, {"sha": "18d4a6463558d6114041ba2b3802a8f88c6ada90", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -383,10 +383,11 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n }\n \n pub fn noop_visit_arm<T: MutVisitor>(\n-    Arm { attrs, pats, guard, body, span }: &mut Arm,\n+    Arm { attrs, pats, guard, body, span, id }: &mut Arm,\n     vis: &mut T,\n ) {\n     visit_attrs(attrs, vis);\n+    vis.visit_id(id);\n     visit_vec(pats, |pat| vis.visit_pat(pat));\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n     vis.visit_expr(body);\n@@ -455,7 +456,7 @@ pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis:\n }\n \n pub fn noop_visit_variant<T: MutVisitor>(variant: &mut Variant, vis: &mut T) {\n-    let Spanned { node: Variant_ { ident, attrs, id, data, disr_expr }, span } = variant;\n+    let Variant { ident, attrs, id, data, disr_expr, span } = variant;\n     vis.visit_ident(ident);\n     visit_attrs(attrs, vis);\n     vis.visit_id(id);\n@@ -532,8 +533,8 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_mac<T: MutVisitor>(Spanned { node, span }: &mut Mac, vis: &mut T) {\n-    let Mac_ { path, delim: _, tts, .. } = node;\n+pub fn noop_visit_mac<T: MutVisitor>(mac: &mut Mac, vis: &mut T) {\n+    let Mac { path, delim: _, tts, span, prior_type_ascription: _ } = mac;\n     vis.visit_path(path);\n     vis.visit_tts(tts);\n     vis.visit_span(span);\n@@ -808,9 +809,10 @@ pub fn noop_visit_struct_field<T: MutVisitor>(f: &mut StructField, visitor: &mut\n }\n \n pub fn noop_visit_field<T: MutVisitor>(f: &mut Field, vis: &mut T) {\n-    let Field { ident, expr, span, is_shorthand: _, attrs } = f;\n+    let Field { ident, expr, span, is_shorthand: _, attrs, id } = f;\n     vis.visit_ident(ident);\n     vis.visit_expr(expr);\n+    vis.visit_id(id);\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n }\n@@ -1040,8 +1042,9 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         }\n         PatKind::Struct(path, fields, _etc) => {\n             vis.visit_path(path);\n-            for Spanned { node: FieldPat { ident, pat, is_shorthand: _, attrs }, span } in fields {\n+            for FieldPat { ident, pat, is_shorthand: _, attrs, id, span } in fields {\n                 vis.visit_ident(ident);\n+                vis.visit_id(id);\n                 vis.visit_pat(pat);\n                 visit_thin_attrs(attrs, vis);\n                 vis.visit_span(span);\n@@ -1179,7 +1182,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n         }\n         ExprKind::InlineAsm(asm) => {\n             let InlineAsm { asm: _, asm_str_style: _, outputs, inputs, clobbers: _, volatile: _,\n-                            alignstack: _, dialect: _, ctxt: _ } = asm.deref_mut();\n+                            alignstack: _, dialect: _ } = asm.deref_mut();\n             for out in outputs {\n                 let InlineAsmOutput { constraint: _, expr, is_rw: _, is_indirect: _ } = out;\n                 vis.visit_expr(expr);"}, {"sha": "1fbf28fb83016059d76952556e0510db3ad4feee", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -8,7 +8,6 @@ use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, Token\n use crate::parse::token::{self, TokenKind};\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::source_map::Spanned;\n use crate::symbol::{kw, sym};\n use crate::ThinVec;\n use crate::util::parser::AssocOp;\n@@ -592,18 +591,18 @@ impl<'a> Parser<'a> {\n \n     crate fn maybe_report_invalid_custom_discriminants(\n         sess: &ParseSess,\n-        variants: &[Spanned<ast::Variant_>],\n+        variants: &[ast::Variant],\n     ) {\n-        let has_fields = variants.iter().any(|variant| match variant.node.data {\n+        let has_fields = variants.iter().any(|variant| match variant.data {\n             VariantData::Tuple(..) | VariantData::Struct(..) => true,\n             VariantData::Unit(..) => false,\n         });\n \n-        let discriminant_spans = variants.iter().filter(|variant| match variant.node.data {\n+        let discriminant_spans = variants.iter().filter(|variant| match variant.data {\n             VariantData::Tuple(..) | VariantData::Struct(..) => false,\n             VariantData::Unit(..) => true,\n         })\n-        .filter_map(|variant| variant.node.disr_expr.as_ref().map(|c| c.value.span))\n+        .filter_map(|variant| variant.disr_expr.as_ref().map(|c| c.value.span))\n         .collect::<Vec<_>>();\n \n         if !discriminant_spans.is_empty() && has_fields {\n@@ -618,7 +617,7 @@ impl<'a> Parser<'a> {\n                 err.span_label(sp, \"disallowed custom discriminant\");\n             }\n             for variant in variants.iter() {\n-                match &variant.node.data {\n+                match &variant.data {\n                     VariantData::Struct(..) => {\n                         err.span_label(\n                             variant.span,"}, {"sha": "17629d392cd3d25acc18079c88ee8ac19045ee8c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -4,7 +4,7 @@ use crate::symbol::{sym, Symbol};\n use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n use errors::{FatalError, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION};\n+use syntax_pos::{BytePos, Pos, Span};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n \n@@ -84,7 +84,7 @@ impl<'a> StringReader<'a> {\n \n \n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n-        self.override_span.unwrap_or_else(|| Span::new(lo, hi, NO_EXPANSION))\n+        self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))\n     }\n \n     /// Returns the next token, including trivia like whitespace or comments."}, {"sha": "94570140996f1480400dff15dec2172ea894a18f", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,41 +1,17 @@\n use super::*;\n \n-use crate::ast::CrateConfig;\n use crate::symbol::Symbol;\n use crate::source_map::{SourceMap, FilePathMapping};\n-use crate::feature_gate::UnstableFeatures;\n use crate::parse::token;\n-use crate::diagnostics::plugin::ErrorMap;\n use crate::with_default_globals;\n use std::io;\n use std::path::PathBuf;\n-use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc_data_structures::sync::{Lock, Once};\n+use errors::{Handler, emitter::EmitterWriter};\n+use syntax_pos::{BytePos, Span};\n \n fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n-    let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n-                                                        Some(sm.clone()),\n-                                                        false,\n-                                                        false,\n-                                                        false);\n-    ParseSess {\n-        span_diagnostic: errors::Handler::with_emitter(true, None, Box::new(emitter)),\n-        unstable_features: UnstableFeatures::from_environment(),\n-        config: CrateConfig::default(),\n-        included_mod_stack: Lock::new(Vec::new()),\n-        source_map: sm,\n-        missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n-        raw_identifier_spans: Lock::new(Vec::new()),\n-        registered_diagnostics: Lock::new(ErrorMap::new()),\n-        buffered_lints: Lock::new(vec![]),\n-        edition: Edition::from_session(),\n-        ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-        param_attr_spans: Lock::new(Vec::new()),\n-        let_chains_spans: Lock::new(Vec::new()),\n-        async_closure_spans: Lock::new(Vec::new()),\n-        injected_crate_name: Once::new(),\n-    }\n+    let emitter = EmitterWriter::new(Box::new(io::sink()), Some(sm.clone()), false, false, false);\n+    ParseSess::with_span_handler(Handler::with_emitter(true, None, Box::new(emitter)), sm)\n }\n \n // open a string reader for the given string\n@@ -61,7 +37,7 @@ fn t1() {\n         let tok1 = string_reader.next_token();\n         let tok2 = Token::new(\n             mk_ident(\"fn\"),\n-            Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n+            Span::with_root_ctxt(BytePos(21), BytePos(23)),\n         );\n         assert_eq!(tok1.kind, tok2.kind);\n         assert_eq!(tok1.span, tok2.span);\n@@ -71,7 +47,7 @@ fn t1() {\n         assert_eq!(string_reader.pos.clone(), BytePos(28));\n         let tok4 = Token::new(\n             mk_ident(\"main\"),\n-            Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n+            Span::with_root_ctxt(BytePos(24), BytePos(28)),\n         );\n         assert_eq!(tok3.kind, tok4.kind);\n         assert_eq!(tok3.span, tok4.span);"}, {"sha": "525b4215affb180c710009c4d2c8ac1383628c90", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -3,7 +3,7 @@\n \n use super::StringReader;\n use errors::{Applicability, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION, symbol::kw};\n+use syntax_pos::{BytePos, Pos, Span, symbol::kw};\n use crate::parse::token;\n \n #[rustfmt::skip] // for line breaks\n@@ -343,7 +343,7 @@ crate fn check_for_substitution<'a>(\n         None => return None,\n     };\n \n-    let span = Span::new(pos, pos + Pos::from_usize(ch.len_utf8()), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8()));\n \n     let (ascii_name, token) = match ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) {\n         Some((_ascii_char, ascii_name, token)) => (ascii_name, token),\n@@ -362,10 +362,9 @@ crate fn check_for_substitution<'a>(\n             ascii_char, ascii_name\n         );\n         err.span_suggestion(\n-            Span::new(\n+            Span::with_root_ctxt(\n                 pos,\n                 pos + Pos::from_usize('\u201c'.len_utf8() + s.len() + '\u201d'.len_utf8()),\n-                NO_EXPANSION,\n             ),\n             &msg,\n             format!(\"\\\"{}\\\"\", s),"}, {"sha": "9088f929372c999737844fbc147189a6dc34c9ef", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -16,6 +16,7 @@ use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic,\n use rustc_data_structures::sync::{Lrc, Lock, Once};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use syntax_pos::edition::Edition;\n+use syntax_pos::hygiene::ExpnId;\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use std::borrow::Cow;\n@@ -62,6 +63,8 @@ pub struct ParseSess {\n     pub let_chains_spans: Lock<Vec<Span>>,\n     // Places where `async || ..` exprs were used and should be feature gated.\n     pub async_closure_spans: Lock<Vec<Span>>,\n+    // Places where `yield e?` exprs were used and should be feature gated.\n+    pub yield_spans: Lock<Vec<Span>>,\n     pub injected_crate_name: Once<Symbol>,\n }\n \n@@ -86,11 +89,12 @@ impl ParseSess {\n             included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n-            edition: Edition::from_session(),\n+            edition: ExpnId::root().expn_data().edition,\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),\n             async_closure_spans: Lock::new(Vec::new()),\n+            yield_spans: Lock::new(Vec::new()),\n             injected_crate_name: Once::new(),\n         }\n     }"}, {"sha": "89725d8b3395c8ab5dde64f80a705a0bac695c6c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -13,7 +13,6 @@ mod generics;\n use crate::ast::{self, AttrStyle, Attribute, Arg, BindingMode, StrStyle, SelfKind};\n use crate::ast::{FnDecl, Ident, IsAsync, MacDelimiter, Mutability, TyKind};\n use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n-use crate::ext::hygiene::SyntaxContext;\n use crate::source_map::{self, respan};\n use crate::parse::{SeqSep, literal, token};\n use crate::parse::lexer::UnmatchedBrace;\n@@ -1101,7 +1100,7 @@ impl<'a> Parser<'a> {\n \n     crate fn process_potential_macro_variable(&mut self) {\n         self.token = match self.token.kind {\n-            token::Dollar if self.token.span.ctxt() != SyntaxContext::empty() &&\n+            token::Dollar if self.token.span.from_expansion() &&\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n                 let name = match self.token.kind {\n@@ -1236,7 +1235,7 @@ impl<'a> Parser<'a> {\n \n         let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n \n-        if c_variadic && args.is_empty() {\n+        if c_variadic && args.len() <= 1 {\n             self.span_err(sp,\n                           \"C-variadic function must be declared with at least one named argument\");\n         }"}, {"sha": "ccc6bd1506709155920216bfc0c00842d3ce522a", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -8,13 +8,13 @@ use crate::ast::{self, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode};\n use crate::ast::{Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm};\n use crate::ast::{Ty, TyKind, FunctionRetTy, Arg, FnDecl};\n use crate::ast::{BinOpKind, BinOp, UnOp};\n-use crate::ast::{Mac_, AnonConst, Field};\n+use crate::ast::{Mac, AnonConst, Field};\n \n use crate::parse::classify;\n use crate::parse::token::{self, Token};\n use crate::parse::diagnostics::{Error};\n use crate::print::pprust;\n-use crate::source_map::{self, respan, Span};\n+use crate::source_map::{self, Span};\n use crate::symbol::{kw, sym};\n use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n \n@@ -224,6 +224,10 @@ impl<'a> Parser<'a> {\n                 self.err_dotdotdot_syntax(self.token.span);\n             }\n \n+            if self.token == token::LArrow {\n+                self.err_larrow_operator(self.token.span);\n+            }\n+\n             self.bump();\n             if op.is_comparison() {\n                 self.check_no_chained_comparison(&lhs, &op);\n@@ -993,6 +997,9 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ex = ExprKind::Yield(None);\n                     }\n+\n+                    let span = lo.to(hi);\n+                    self.sess.yield_spans.borrow_mut().push(span);\n                 } else if self.eat_keyword(kw::Let) {\n                     return self.parse_let_expr(attrs);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n@@ -1007,12 +1014,13 @@ impl<'a> Parser<'a> {\n                         // MACRO INVOCATION expression\n                         let (delim, tts) = self.expect_delimited_token_tree()?;\n                         hi = self.prev_span;\n-                        ex = ExprKind::Mac(respan(lo.to(hi), Mac_ {\n+                        ex = ExprKind::Mac(Mac {\n                             path,\n                             tts,\n                             delim,\n+                            span: lo.to(hi),\n                             prior_type_ascription: self.last_type_ascription,\n-                        }));\n+                        });\n                     } else if self.check(&token::OpenDelim(token::Brace)) {\n                         if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n                             return expr;\n@@ -1199,7 +1207,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(kw::Else) || !cond.returns() {\n             let sp = self.sess.source_map().next_point(lo);\n             let mut err = self.diagnostic()\n-                .struct_span_err(sp, \"missing condition for `if` statemement\");\n+                .struct_span_err(sp, \"missing condition for `if` expression\");\n             err.span_label(sp, \"expected if condition here\");\n             return Err(err)\n         }\n@@ -1444,6 +1452,7 @@ impl<'a> Parser<'a> {\n             guard,\n             body: expr,\n             span: lo.to(hi),\n+            id: ast::DUMMY_NODE_ID,\n         })\n     }\n \n@@ -1599,6 +1608,7 @@ impl<'a> Parser<'a> {\n                         expr: self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()),\n                         is_shorthand: false,\n                         attrs: ThinVec::new(),\n+                        id: ast::DUMMY_NODE_ID,\n                     });\n                 }\n             }\n@@ -1684,6 +1694,7 @@ impl<'a> Parser<'a> {\n             expr,\n             is_shorthand,\n             attrs: attrs.into(),\n+            id: ast::DUMMY_NODE_ID,\n         })\n     }\n \n@@ -1702,6 +1713,19 @@ impl<'a> Parser<'a> {\n             .emit();\n     }\n \n+    fn err_larrow_operator(&self, span: Span) {\n+        self.struct_span_err(\n+            span,\n+            \"unexpected token: `<-`\"\n+        ).span_suggestion(\n+            span,\n+            \"if you meant to write a comparison against a negative value, add a \\\n+             space in between `<` and `-`\",\n+            \"< -\".to_string(),\n+            Applicability::MaybeIncorrect\n+        ).emit();\n+    }\n+\n     fn mk_assign_op(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {\n         ExprKind::AssignOp(binop, lhs, rhs)\n     }"}, {"sha": "72819c9966035223fe24121f7c081470176dd6fe", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -10,7 +10,7 @@ use crate::ast::{Visibility, VisibilityKind, Mutability, FnDecl, FnHeader};\n use crate::ast::{ForeignItem, ForeignItemKind};\n use crate::ast::{Ty, TyKind, GenericBounds, TraitRef};\n use crate::ast::{EnumDef, VariantData, StructField, AnonConst};\n-use crate::ast::{Mac, Mac_, MacDelimiter};\n+use crate::ast::{Mac, MacDelimiter};\n use crate::ext::base::DummyResult;\n use crate::parse::token;\n use crate::parse::parser::maybe_append;\n@@ -530,12 +530,13 @@ impl<'a> Parser<'a> {\n             }\n \n             let hi = self.prev_span;\n-            let mac = respan(mac_lo.to(hi), Mac_ {\n+            let mac = Mac {\n                 path,\n                 tts,\n                 delim,\n+                span: mac_lo.to(hi),\n                 prior_type_ascription: self.last_type_ascription,\n-            });\n+            };\n             let item =\n                 self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n@@ -604,12 +605,13 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?;\n             }\n \n-            Ok(Some(respan(lo.to(self.prev_span), Mac_ {\n+            Ok(Some(Mac {\n                 path,\n                 tts,\n                 delim,\n+                span: lo.to(self.prev_span),\n                 prior_type_ascription: self.last_type_ascription,\n-            })))\n+            }))\n         } else {\n             Ok(None)\n         }\n@@ -1564,14 +1566,15 @@ impl<'a> Parser<'a> {\n                 None\n             };\n \n-            let vr = ast::Variant_ {\n+            let vr = ast::Variant {\n                 ident,\n                 id: ast::DUMMY_NODE_ID,\n                 attrs: variant_attrs,\n                 data: struct_def,\n                 disr_expr,\n+                span: vlo.to(self.prev_span),\n             };\n-            variants.push(respan(vlo.to(self.prev_span), vr));\n+            variants.push(vr);\n \n             if !self.eat(&token::Comma) {\n                 if self.token.is_ident() && !self.token.is_reserved_ident() {"}, {"sha": "3f6f87b1c44b612cd41ecd84d3af728e1b5050ab", "filename": "src/libsyntax/parse/parser/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -60,7 +60,7 @@ impl<'a> Parser<'a> {\n                 // Record that we fetched the mod from an external file\n                 if warn {\n                     let attr = attr::mk_attr_outer(\n-                        attr::mk_word_item(Ident::with_empty_ctxt(sym::warn_directory_ownership)));\n+                        attr::mk_word_item(Ident::with_dummy_span(sym::warn_directory_ownership)));\n                     attr::mark_known(&attr);\n                     attrs.push(attr);\n                 }"}, {"sha": "c3079d2da0ce7ed9efbd80f6de663d69f9d52e7e", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 245, "deletions": 204, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -2,8 +2,8 @@ use super::{Parser, PResult, PathStyle};\n \n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use crate::ptr::P;\n-use crate::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac_};\n-use crate::ast::{BindingMode, Ident, Mutability, Expr, ExprKind};\n+use crate::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac};\n+use crate::ast::{BindingMode, Ident, Mutability, Path, QSelf, Expr, ExprKind};\n use crate::parse::token::{self};\n use crate::print::pprust;\n use crate::source_map::{respan, Span, Spanned};\n@@ -108,93 +108,52 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtPat, |x| x);\n \n         let lo = self.token.span;\n-        let pat;\n-        match self.token.kind {\n-            token::BinOp(token::And) | token::AndAnd => {\n-                // Parse &pat / &mut pat\n-                self.expect_and()?;\n-                let mutbl = self.parse_mutability();\n-                if let token::Lifetime(name) = self.token.kind {\n-                    let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n-                    err.span_label(self.token.span, \"unexpected lifetime\");\n-                    return Err(err);\n-                }\n-                let subpat = self.parse_pat_with_range_pat(false, expected)?;\n-                pat = PatKind::Ref(subpat, mutbl);\n-            }\n-            token::OpenDelim(token::Paren) => {\n-                // Parse a tuple or parenthesis pattern.\n-                let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-\n-                // Here, `(pat,)` is a tuple pattern.\n-                // For backward compatibility, `(..)` is a tuple pattern as well.\n-                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n-                    PatKind::Paren(fields.into_iter().nth(0).unwrap())\n-                } else {\n-                    PatKind::Tuple(fields)\n-                };\n-            }\n+        let pat = match self.token.kind {\n+            token::BinOp(token::And) | token::AndAnd => self.parse_pat_deref(expected)?,\n+            token::OpenDelim(token::Paren) => self.parse_pat_tuple_or_parens()?,\n             token::OpenDelim(token::Bracket) => {\n                 // Parse `[pat, pat,...]` as a slice pattern.\n-                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n-                pat = PatKind::Slice(slice);\n+                PatKind::Slice(self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?.0)\n             }\n             token::DotDot => {\n                 self.bump();\n-                pat = if self.is_pat_range_end_start() {\n+                if self.is_pat_range_end_start() {\n                     // Parse `..42` for recovery.\n                     self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n                 } else {\n                     // A rest pattern `..`.\n                     PatKind::Rest\n-                };\n+                }\n             }\n             token::DotDotEq => {\n                 // Parse `..=42` for recovery.\n                 self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n+                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?\n             }\n             token::DotDotDot => {\n                 // Parse `...42` for recovery.\n                 self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n+                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?\n             }\n             // At this point, token != &, &&, (, [\n             _ => if self.eat_keyword(kw::Underscore) {\n                 // Parse _\n-                pat = PatKind::Wild;\n+                PatKind::Wild\n             } else if self.eat_keyword(kw::Mut) {\n-                // Parse mut ident @ pat / mut ref ident @ pat\n-                let mutref_span = self.prev_span.to(self.token.span);\n-                let binding_mode = if self.eat_keyword(kw::Ref) {\n-                    self.diagnostic()\n-                        .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n-                        .span_suggestion(\n-                            mutref_span,\n-                            \"try switching the order\",\n-                            \"ref mut\".into(),\n-                            Applicability::MachineApplicable\n-                        ).emit();\n-                    BindingMode::ByRef(Mutability::Mutable)\n-                } else {\n-                    BindingMode::ByValue(Mutability::Mutable)\n-                };\n-                pat = self.parse_pat_ident(binding_mode)?;\n+                self.recover_pat_ident_mut_first()?\n             } else if self.eat_keyword(kw::Ref) {\n                 // Parse ref ident @ pat / ref mut ident @ pat\n                 let mutbl = self.parse_mutability();\n-                pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n+                self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n             } else if self.eat_keyword(kw::Box) {\n-                // Parse box pat\n-                let subpat = self.parse_pat_with_range_pat(false, None)?;\n-                pat = PatKind::Box(subpat);\n+                // Parse `box pat`\n+                PatKind::Box(self.parse_pat_with_range_pat(false, None)?)\n             } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n                       self.parse_as_ident() {\n-                // Parse ident @ pat\n+                // Parse `ident @ pat`\n                 // This can give false positives and parse nullary enums,\n-                // they are dealt with later in resolve\n-                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                pat = self.parse_pat_ident(binding_mode)?;\n+                // they are dealt with later in resolve.\n+                self.parse_pat_ident(BindingMode::ByValue(Mutability::Immutable))?\n             } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n                 let (qself, path) = if self.eat_lt() {\n@@ -206,136 +165,187 @@ impl<'a> Parser<'a> {\n                     (None, self.parse_path(PathStyle::Expr)?)\n                 };\n                 match self.token.kind {\n-                    token::Not if qself.is_none() => {\n-                        // Parse macro invocation\n-                        self.bump();\n-                        let (delim, tts) = self.expect_delimited_token_tree()?;\n-                        let mac = respan(lo.to(self.prev_span), Mac_ {\n-                            path,\n-                            tts,\n-                            delim,\n-                            prior_type_ascription: self.last_type_ascription,\n-                        });\n-                        pat = PatKind::Mac(mac);\n-                    }\n+                    token::Not if qself.is_none() => self.parse_pat_mac_invoc(lo, path)?,\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n-                        let (end_kind, form) = match self.token.kind {\n-                            token::DotDot => (RangeEnd::Excluded, \"..\"),\n-                            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n-                            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n-                            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n-                                         (checked above)\"),\n-                        };\n-                        let op_span = self.token.span;\n-                        // Parse range\n-                        let span = lo.to(self.prev_span);\n-                        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n-                        self.bump();\n-                        let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n-                    }\n-                    token::OpenDelim(token::Brace) => {\n-                        if qself.is_some() {\n-                            let msg = \"unexpected `{` after qualified path\";\n-                            let mut err = self.fatal(msg);\n-                            err.span_label(self.token.span, msg);\n-                            return Err(err);\n-                        }\n-                        // Parse struct pattern\n-                        self.bump();\n-                        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n-                            e.emit();\n-                            self.recover_stmt();\n-                            (vec![], true)\n-                        });\n-                        self.bump();\n-                        pat = PatKind::Struct(path, fields, etc);\n-                    }\n-                    token::OpenDelim(token::Paren) => {\n-                        if qself.is_some() {\n-                            let msg = \"unexpected `(` after qualified path\";\n-                            let mut err = self.fatal(msg);\n-                            err.span_label(self.token.span, msg);\n-                            return Err(err);\n-                        }\n-                        // Parse tuple struct or enum pattern\n-                        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-                        pat = PatKind::TupleStruct(path, fields)\n+                        self.parse_pat_range_starting_with_path(lo, qself, path)?\n                     }\n-                    _ => pat = PatKind::Path(qself, path),\n+                    token::OpenDelim(token::Brace) => self.parse_pat_struct(qself, path)?,\n+                    token::OpenDelim(token::Paren) => self.parse_pat_tuple_struct(qself, path)?,\n+                    _ => PatKind::Path(qself, path),\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n                 match self.parse_literal_maybe_minus() {\n-                    Ok(begin) => {\n-                        let op_span = self.token.span;\n-                        if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n-                                self.check(&token::DotDotDot) {\n-                            let (end_kind, form) = if self.eat(&token::DotDotDot) {\n-                                (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n-                            } else if self.eat(&token::DotDotEq) {\n-                                (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n-                            } else if self.eat(&token::DotDot) {\n-                                (RangeEnd::Excluded, \"..\")\n-                            } else {\n-                                panic!(\"impossible case: we already matched \\\n-                                        on a range-operator token\")\n-                            };\n-                            let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n-                        } else {\n-                            pat = PatKind::Lit(begin);\n-                        }\n-                    }\n-                    Err(mut err) => {\n-                        self.cancel(&mut err);\n-                        let expected = expected.unwrap_or(\"pattern\");\n-                        let msg = format!(\n-                            \"expected {}, found {}\",\n-                            expected,\n-                            self.this_token_descr(),\n-                        );\n-                        let mut err = self.fatal(&msg);\n-                        err.span_label(self.token.span, format!(\"expected {}\", expected));\n-                        let sp = self.sess.source_map().start_point(self.token.span);\n-                        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n-                            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n-                        }\n-                        return Err(err);\n+                    Ok(begin)\n+                        if self.check(&token::DotDot)\n+                            || self.check(&token::DotDotEq)\n+                            || self.check(&token::DotDotDot) =>\n+                    {\n+                        self.parse_pat_range_starting_with_lit(begin)?\n                     }\n+                    Ok(begin) => PatKind::Lit(begin),\n+                    Err(err) => return self.fatal_unexpected_non_pat(err, expected),\n                 }\n             }\n-        }\n+        };\n \n         let pat = self.mk_pat(lo.to(self.prev_span), pat);\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n \n         if !allow_range_pat {\n-            match pat.node {\n-                PatKind::Range(\n-                    _, _, Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n-                ) => {},\n-                PatKind::Range(..) => {\n-                    let mut err = self.struct_span_err(\n-                        pat.span,\n-                        \"the range pattern here has ambiguous interpretation\",\n-                    );\n-                    err.span_suggestion(\n-                        pat.span,\n-                        \"add parentheses to clarify the precedence\",\n-                        format!(\"({})\", pprust::pat_to_string(&pat)),\n-                        // \"ambiguous interpretation\" implies that we have to be guessing\n-                        Applicability::MaybeIncorrect\n-                    );\n-                    return Err(err);\n-                }\n-                _ => {}\n-            }\n+            self.ban_pat_range_if_ambiguous(&pat)?\n         }\n \n         Ok(pat)\n     }\n \n+    /// Ban a range pattern if it has an ambiguous interpretation.\n+    fn ban_pat_range_if_ambiguous(&self, pat: &Pat) -> PResult<'a, ()> {\n+        match pat.node {\n+            PatKind::Range(\n+                .., Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n+            ) => return Ok(()),\n+            PatKind::Range(..) => {}\n+            _ => return Ok(()),\n+        }\n+\n+        let mut err = self.struct_span_err(\n+            pat.span,\n+            \"the range pattern here has ambiguous interpretation\",\n+        );\n+        err.span_suggestion(\n+            pat.span,\n+            \"add parentheses to clarify the precedence\",\n+            format!(\"({})\", pprust::pat_to_string(&pat)),\n+            // \"ambiguous interpretation\" implies that we have to be guessing\n+            Applicability::MaybeIncorrect\n+        );\n+        Err(err)\n+    }\n+\n+    /// Parse `&pat` / `&mut pat`.\n+    fn parse_pat_deref(&mut self, expected: Option<&'static str>) -> PResult<'a, PatKind> {\n+        self.expect_and()?;\n+        let mutbl = self.parse_mutability();\n+\n+        if let token::Lifetime(name) = self.token.kind {\n+            let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n+            err.span_label(self.token.span, \"unexpected lifetime\");\n+            return Err(err);\n+        }\n+\n+        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n+        Ok(PatKind::Ref(subpat, mutbl))\n+    }\n+\n+    /// Parse a tuple or parenthesis pattern.\n+    fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n+        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+\n+        // Here, `(pat,)` is a tuple pattern.\n+        // For backward compatibility, `(..)` is a tuple pattern as well.\n+        Ok(if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n+            PatKind::Paren(fields.into_iter().nth(0).unwrap())\n+        } else {\n+            PatKind::Tuple(fields)\n+        })\n+    }\n+\n+    /// Recover on `mut ref? ident @ pat` and suggest\n+    /// that the order of `mut` and `ref` is incorrect.\n+    fn recover_pat_ident_mut_first(&mut self) -> PResult<'a, PatKind> {\n+        let mutref_span = self.prev_span.to(self.token.span);\n+        let binding_mode = if self.eat_keyword(kw::Ref) {\n+            self.struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n+                .span_suggestion(\n+                    mutref_span,\n+                    \"try switching the order\",\n+                    \"ref mut\".into(),\n+                    Applicability::MachineApplicable\n+                )\n+                .emit();\n+            BindingMode::ByRef(Mutability::Mutable)\n+        } else {\n+            BindingMode::ByValue(Mutability::Mutable)\n+        };\n+        self.parse_pat_ident(binding_mode)\n+    }\n+\n+    /// Parse macro invocation\n+    fn parse_pat_mac_invoc(&mut self, lo: Span, path: Path) -> PResult<'a, PatKind> {\n+        self.bump();\n+        let (delim, tts) = self.expect_delimited_token_tree()?;\n+        let mac = Mac {\n+            path,\n+            tts,\n+            delim,\n+            span: lo.to(self.prev_span),\n+            prior_type_ascription: self.last_type_ascription,\n+        };\n+        Ok(PatKind::Mac(mac))\n+    }\n+\n+    /// Parse a range pattern `$path $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n+    /// The `$path` has already been parsed and the next token is the `$form`.\n+    fn parse_pat_range_starting_with_path(\n+        &mut self,\n+        lo: Span,\n+        qself: Option<QSelf>,\n+        path: Path\n+    ) -> PResult<'a, PatKind> {\n+        let (end_kind, form) = match self.token.kind {\n+            token::DotDot => (RangeEnd::Excluded, \"..\"),\n+            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n+            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n+            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges (checked above)\"),\n+        };\n+        let op_span = self.token.span;\n+        // Parse range\n+        let span = lo.to(self.prev_span);\n+        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n+        self.bump();\n+        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+        Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n+    }\n+\n+    /// Parse a range pattern `$literal $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n+    /// The `$path` has already been parsed and the next token is the `$form`.\n+    fn parse_pat_range_starting_with_lit(&mut self, begin: P<Expr>) -> PResult<'a, PatKind> {\n+        let op_span = self.token.span;\n+        let (end_kind, form) = if self.eat(&token::DotDotDot) {\n+            (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n+        } else if self.eat(&token::DotDotEq) {\n+            (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n+        } else if self.eat(&token::DotDot) {\n+            (RangeEnd::Excluded, \"..\")\n+        } else {\n+            panic!(\"impossible case: we already matched on a range-operator token\")\n+        };\n+        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+        Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n+    }\n+\n+    fn fatal_unexpected_non_pat(\n+        &mut self,\n+        mut err: DiagnosticBuilder<'a>,\n+        expected: Option<&'static str>,\n+    ) -> PResult<'a, P<Pat>> {\n+        self.cancel(&mut err);\n+\n+        let expected = expected.unwrap_or(\"pattern\");\n+        let msg = format!(\"expected {}, found {}\", expected, self.this_token_descr());\n+\n+        let mut err = self.fatal(&msg);\n+        err.span_label(self.token.span, format!(\"expected {}\", expected));\n+\n+        let sp = self.sess.source_map().start_point(self.token.span);\n+        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n+        }\n+\n+        Err(err)\n+    }\n+\n     // Helper function to decide whether to parse as ident binding\n     // or to try to do something more complex like range patterns.\n     fn parse_as_ident(&mut self) -> bool {\n@@ -421,35 +431,64 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `ident` or `ident @ pat`.\n-    /// used by the copy foo and ref foo patterns to give a good\n+    /// Used by the copy foo and ref foo patterns to give a good\n     /// error message when parsing mistakes like `ref foo(a, b)`.\n-    fn parse_pat_ident(&mut self,\n-                       binding_mode: ast::BindingMode)\n-                       -> PResult<'a, PatKind> {\n+    fn parse_pat_ident(&mut self, binding_mode: BindingMode) -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat(Some(\"binding pattern\"))?)\n         } else {\n             None\n         };\n \n-        // just to be friendly, if they write something like\n-        //   ref Some(i)\n-        // we end up here with ( as the current token.  This shortly\n-        // leads to a parse error.  Note that if there is no explicit\n+        // Just to be friendly, if they write something like `ref Some(i)`,\n+        // we end up here with `(` as the current token.\n+        // This shortly leads to a parse error. Note that if there is no explicit\n         // binding mode then we do not end up here, because the lookahead\n-        // will direct us over to parse_enum_variant()\n+        // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(token::Paren) {\n             return Err(self.span_fatal(\n                 self.prev_span,\n-                \"expected identifier, found enum pattern\"))\n+                \"expected identifier, found enum pattern\",\n+            ))\n         }\n \n         Ok(PatKind::Ident(binding_mode, ident, sub))\n     }\n \n+    /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n+    fn parse_pat_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n+        if qself.is_some() {\n+            let msg = \"unexpected `{` after qualified path\";\n+            let mut err = self.fatal(msg);\n+            err.span_label(self.token.span, msg);\n+            return Err(err);\n+        }\n+\n+        self.bump();\n+        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n+            e.emit();\n+            self.recover_stmt();\n+            (vec![], true)\n+        });\n+        self.bump();\n+        Ok(PatKind::Struct(path, fields, etc))\n+    }\n+\n+    /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n+    fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n+        if qself.is_some() {\n+            let msg = \"unexpected `(` after qualified path\";\n+            let mut err = self.fatal(msg);\n+            err.span_label(self.token.span, msg);\n+            return Err(err);\n+        }\n+        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+        Ok(PatKind::TupleStruct(path, fields))\n+    }\n+\n     /// Parses the fields of a struct-like pattern.\n-    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<Spanned<FieldPat>>, bool)> {\n+    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<FieldPat>, bool)> {\n         let mut fields = Vec::new();\n         let mut etc = false;\n         let mut ate_comma = true;\n@@ -482,17 +521,7 @@ impl<'a> Parser<'a> {\n                 etc = true;\n                 let mut etc_sp = self.token.span;\n \n-                if self.token == token::DotDotDot { // Issue #46718\n-                    // Accept `...` as if it were `..` to avoid further errors\n-                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n-                        .span_suggestion(\n-                            self.token.span,\n-                            \"to omit remaining fields, use one fewer `.`\",\n-                            \"..\".to_owned(),\n-                            Applicability::MachineApplicable\n-                        )\n-                        .emit();\n-                }\n+                self.recover_one_fewer_dotdot();\n                 self.bump();  // `..` || `...`\n \n                 if self.token == token::CloseDelim(token::Brace) {\n@@ -574,11 +603,24 @@ impl<'a> Parser<'a> {\n         return Ok((fields, etc));\n     }\n \n-    fn parse_pat_field(\n-        &mut self,\n-        lo: Span,\n-        attrs: Vec<Attribute>\n-    ) -> PResult<'a, Spanned<FieldPat>> {\n+    /// Recover on `...` as if it were `..` to avoid further errors.\n+    /// See issue #46718.\n+    fn recover_one_fewer_dotdot(&self) {\n+        if self.token != token::DotDotDot {\n+            return;\n+        }\n+\n+        self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n+            .span_suggestion(\n+                self.token.span,\n+                \"to omit remaining fields, use one fewer `.`\",\n+                \"..\".to_owned(),\n+                Applicability::MachineApplicable\n+            )\n+            .emit();\n+    }\n+\n+    fn parse_pat_field(&mut self, lo: Span, attrs: Vec<Attribute>) -> PResult<'a, FieldPat> {\n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n         let hi;\n         let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n@@ -613,14 +655,13 @@ impl<'a> Parser<'a> {\n             (subpat, fieldname, true)\n         };\n \n-        Ok(Spanned {\n+        Ok(FieldPat {\n+            ident: fieldname,\n+            pat: subpat,\n+            is_shorthand,\n+            attrs: attrs.into(),\n+            id: ast::DUMMY_NODE_ID,\n             span: lo.to(hi),\n-            node: FieldPat {\n-                ident: fieldname,\n-                pat: subpat,\n-                is_shorthand,\n-                attrs: attrs.into(),\n-           }\n         })\n     }\n "}, {"sha": "c911caba4cd414605f26d901afa47408dd9ce6d5", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -5,7 +5,7 @@ use super::path::PathStyle;\n use crate::ptr::P;\n use crate::{maybe_whole, ThinVec};\n use crate::ast::{self, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n-use crate::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac_, MacDelimiter};\n+use crate::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac, MacDelimiter};\n use crate::ext::base::DummyResult;\n use crate::parse::{classify, DirectoryOwnership};\n use crate::parse::diagnostics::Error;\n@@ -99,12 +99,13 @@ impl<'a> Parser<'a> {\n                 MacStmtStyle::NoBraces\n             };\n \n-            let mac = respan(lo.to(hi), Mac_ {\n+            let mac = Mac {\n                 path,\n                 tts,\n                 delim,\n+                span: lo.to(hi),\n                 prior_type_ascription: self.last_type_ascription,\n-            });\n+            };\n             let node = if delim == MacDelimiter::Brace ||\n                           self.token == token::Semi || self.token == token::Eof {\n                 StmtKind::Mac(P((mac, style, attrs.into())))\n@@ -167,7 +168,22 @@ impl<'a> Parser<'a> {\n                     if self.token == token::Semi {\n                         unused_attrs(&attrs, self);\n                         self.bump();\n-                        return Ok(None);\n+                        let mut last_semi = lo;\n+                        while self.token == token::Semi {\n+                            last_semi = self.token.span;\n+                            self.bump();\n+                        }\n+                        // We are encoding a string of semicolons as an\n+                        // an empty tuple that spans the excess semicolons\n+                        // to preserve this info until the lint stage\n+                        return Ok(Some(Stmt {\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: lo.to(last_semi),\n+                            node: StmtKind::Semi(self.mk_expr(lo.to(last_semi),\n+                                ExprKind::Tup(Vec::new()),\n+                                ThinVec::new()\n+                            )),\n+                        }));\n                     }\n \n                     if self.token == token::CloseDelim(token::Brace) {"}, {"sha": "337702b8d30c57bae465d51907c28d4f09bdc3e7", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -4,9 +4,9 @@ use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n use crate::ptr::P;\n use crate::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam, Lifetime, Ident};\n use crate::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n-use crate::ast::{Mutability, AnonConst, FnDecl, Mac_};\n+use crate::ast::{Mutability, AnonConst, FnDecl, Mac};\n use crate::parse::token::{self, Token};\n-use crate::source_map::{respan, Span};\n+use crate::source_map::Span;\n use crate::symbol::{kw};\n \n use rustc_target::spec::abi::Abi;\n@@ -175,13 +175,14 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::Not) {\n                 // Macro invocation in type position\n                 let (delim, tts) = self.expect_delimited_token_tree()?;\n-                let node = Mac_ {\n+                let mac = Mac {\n                     path,\n                     tts,\n                     delim,\n+                    span: lo.to(self.prev_span),\n                     prior_type_ascription: self.last_type_ascription,\n                 };\n-                TyKind::Mac(respan(lo.to(self.prev_span), node))\n+                TyKind::Mac(mac)\n             } else {\n                 // Just a type path or bound list (trait object type) starting with a trait.\n                 //   `Type`"}, {"sha": "6a789ef99d672c3d21655325382a56402b1283b8", "filename": "src/libsyntax/parse/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -12,7 +12,7 @@ use crate::symbol::{kw, sym};\n use crate::tests::{matches_codepattern, string_to_stream, with_error_checking_parse};\n use crate::tokenstream::{DelimSpan, TokenTree, TokenStream};\n use crate::with_default_globals;\n-use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n+use syntax_pos::{Span, BytePos, Pos};\n \n use std::path::PathBuf;\n \n@@ -27,7 +27,7 @@ fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n \n // produce a syntax_pos::span\n fn sp(a: u32, b: u32) -> Span {\n-    Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n /// Parse a string, return an expr\n@@ -172,8 +172,8 @@ fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n     impl<'a> crate::visit::Visitor<'a> for PatIdentVisitor {\n         fn visit_pat(&mut self, p: &'a ast::Pat) {\n             match p.node {\n-                PatKind::Ident(_ , ref spannedident, _) => {\n-                    self.spans.push(spannedident.span.clone());\n+                PatKind::Ident(_ , ref ident, _) => {\n+                    self.spans.push(ident.span.clone());\n                 }\n                 _ => {\n                     crate::visit::walk_pat(self, p);\n@@ -273,7 +273,7 @@ fn ttdelim_span() {\n             \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n         let tts: Vec<_> = match expr.node {\n-            ast::ExprKind::Mac(ref mac) => mac.node.stream().trees().collect(),\n+            ast::ExprKind::Mac(ref mac) => mac.stream().trees().collect(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "8a7009828bc44e15e765910e3e7fdc5c733de2c7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -123,13 +123,13 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let pi_nested = attr::mk_nested_word_item(ast::Ident::with_empty_ctxt(sym::prelude_import));\n-        let list = attr::mk_list_item(ast::Ident::with_empty_ctxt(sym::feature), vec![pi_nested]);\n+        let pi_nested = attr::mk_nested_word_item(ast::Ident::with_dummy_span(sym::prelude_import));\n+        let list = attr::mk_list_item(ast::Ident::with_dummy_span(sym::feature), vec![pi_nested]);\n         let fake_attr = attr::mk_attr_inner(list);\n         s.print_attribute(&fake_attr);\n \n         // #![no_std]\n-        let no_std_meta = attr::mk_word_item(ast::Ident::with_empty_ctxt(sym::no_std));\n+        let no_std_meta = attr::mk_word_item(ast::Ident::with_dummy_span(sym::no_std));\n         let fake_attr = attr::mk_attr_inner(no_std_meta);\n         s.print_attribute(&fake_attr);\n     }\n@@ -1067,7 +1067,7 @@ impl<'a> State<'a> {\n             }\n             ast::ForeignItemKind::Macro(ref m) => {\n                 self.print_mac(m);\n-                match m.node.delim {\n+                match m.delim {\n                     MacDelimiter::Brace => {},\n                     _ => self.s.word(\";\")\n                 }\n@@ -1341,7 +1341,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Mac(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.node.delim {\n+                match mac.delim {\n                     MacDelimiter::Brace => {}\n                     _ => self.s.word(\";\"),\n                 }\n@@ -1402,7 +1402,7 @@ impl<'a> State<'a> {\n         for v in variants {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.node.attrs);\n+            self.print_outer_attributes(&v.attrs);\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n@@ -1492,8 +1492,8 @@ impl<'a> State<'a> {\n     crate fn print_variant(&mut self, v: &ast::Variant) {\n         self.head(\"\");\n         let generics = ast::Generics::default();\n-        self.print_struct(&v.node.data, &generics, v.node.ident, v.span, false);\n-        match v.node.disr_expr {\n+        self.print_struct(&v.data, &generics, v.ident, v.span, false);\n+        match v.disr_expr {\n             Some(ref d) => {\n                 self.s.space();\n                 self.word_space(\"=\");\n@@ -1554,7 +1554,7 @@ impl<'a> State<'a> {\n             }\n             ast::TraitItemKind::Macro(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.node.delim {\n+                match mac.delim {\n                     MacDelimiter::Brace => {}\n                     _ => self.s.word(\";\"),\n                 }\n@@ -1591,7 +1591,7 @@ impl<'a> State<'a> {\n             }\n             ast::ImplItemKind::Macro(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.node.delim {\n+                match mac.delim {\n                     MacDelimiter::Brace => {}\n                     _ => self.s.word(\";\"),\n                 }\n@@ -1749,11 +1749,11 @@ impl<'a> State<'a> {\n \n     crate fn print_mac(&mut self, m: &ast::Mac) {\n         self.print_mac_common(\n-            Some(MacHeader::Path(&m.node.path)),\n+            Some(MacHeader::Path(&m.path)),\n             true,\n             None,\n-            m.node.delim.to_token(),\n-            m.node.stream(),\n+            m.delim.to_token(),\n+            m.stream(),\n             true,\n             m.span,\n         );\n@@ -2367,14 +2367,14 @@ impl<'a> State<'a> {\n                     Consistent, &fields[..],\n                     |s, f| {\n                         s.cbox(INDENT_UNIT);\n-                        if !f.node.is_shorthand {\n-                            s.print_ident(f.node.ident);\n+                        if !f.is_shorthand {\n+                            s.print_ident(f.ident);\n                             s.word_nbsp(\":\");\n                         }\n-                        s.print_pat(&f.node.pat);\n+                        s.print_pat(&f.pat);\n                         s.end();\n                     },\n-                    |f| f.node.pat.span);\n+                    |f| f.pat.span);\n                 if etc {\n                     if !fields.is_empty() { self.word_space(\",\"); }\n                     self.s.word(\"..\");"}, {"sha": "25214673e69355b8b6f04424fabb0a77946b8692", "filename": "src/libsyntax/print/pprust/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -54,14 +54,15 @@ fn test_variant_to_string() {\n     with_default_globals(|| {\n         let ident = ast::Ident::from_str(\"principal_skinner\");\n \n-        let var = source_map::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n+        let var = ast::Variant {\n             ident,\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n             // making this up as I go.... ?\n             data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),\n             disr_expr: None,\n-        });\n+            span: syntax_pos::DUMMY_SP,\n+        };\n \n         let varstr = variant_to_string(&var);\n         assert_eq!(varstr, \"principal_skinner\");"}, {"sha": "7190cfd72a959af92d34022f04d7cea89c0817e4", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -8,7 +8,7 @@\n //! information, source code snippets, etc.\n \n pub use syntax_pos::*;\n-pub use syntax_pos::hygiene::{ExpnKind, ExpnInfo};\n+pub use syntax_pos::hygiene::{ExpnKind, ExpnData};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -29,14 +29,15 @@ mod tests;\n \n /// Returns the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n-/// following the `expn_info` chain.\n+/// following the `expn_data` chain.\n pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    let call_site1 = sp.ctxt().outer_expn_info().map(|ei| ei.call_site);\n-    let call_site2 = enclosing_sp.ctxt().outer_expn_info().map(|ei| ei.call_site);\n-    match (call_site1, call_site2) {\n-        (None, _) => sp,\n-        (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n-        (Some(call_site1), _) => original_sp(call_site1, enclosing_sp),\n+    let expn_data1 = sp.ctxt().outer_expn_data();\n+    let expn_data2 = enclosing_sp.ctxt().outer_expn_data();\n+    if expn_data1.is_root() ||\n+       !expn_data2.is_root() && expn_data1.call_site == expn_data2.call_site {\n+        sp\n+    } else {\n+        original_sp(expn_data1.call_site, enclosing_sp)\n     }\n }\n \n@@ -170,6 +171,26 @@ impl SourceMap {\n         Ok(self.new_source_file(filename, src))\n     }\n \n+    /// Loads source file as a binary blob.\n+    ///\n+    /// Unlike `load_file`, guarantees that no normalization like BOM-removal\n+    /// takes place.\n+    pub fn load_binary_file(&self, path: &Path) -> io::Result<Vec<u8>> {\n+        // Ideally, this should use `self.file_loader`, but it can't\n+        // deal with binary files yet.\n+        let bytes = fs::read(path)?;\n+\n+        // We need to add file to the `SourceMap`, so that it is present\n+        // in dep-info. There's also an edge case that file might be both\n+        // loaded as a binary via `include_bytes!` and as proper `SourceFile`\n+        // via `mod`, so we try to use real file contents and not just an\n+        // empty string.\n+        let text = std::str::from_utf8(&bytes).unwrap_or(\"\")\n+            .to_string();\n+        self.new_source_file(path.to_owned().into(), text);\n+        Ok(bytes)\n+    }\n+\n     pub fn files(&self) -> MappedLockGuard<'_, Vec<Lrc<SourceFile>>> {\n         LockGuard::map(self.files.borrow(), |files| &mut files.source_files)\n     }\n@@ -519,7 +540,7 @@ impl SourceMap {\n     /// extract function takes three arguments: a string slice containing the source, an index in\n     /// the slice for the beginning of the span and an index in the slice for the end of the span.\n     fn span_to_source<F>(&self, sp: Span, extract_source: F) -> Result<String, SpanSnippetError>\n-        where F: Fn(&str, usize, usize) -> String\n+        where F: Fn(&str, usize, usize) -> Result<String, SpanSnippetError>\n     {\n         if sp.lo() > sp.hi() {\n             return Err(SpanSnippetError::IllFormedSpan(sp));\n@@ -554,9 +575,9 @@ impl SourceMap {\n             }\n \n             if let Some(ref src) = local_begin.sf.src {\n-                return Ok(extract_source(src, start_index, end_index));\n+                return extract_source(src, start_index, end_index);\n             } else if let Some(src) = local_begin.sf.external_src.borrow().get_source() {\n-                return Ok(extract_source(src, start_index, end_index));\n+                return extract_source(src, start_index, end_index);\n             } else {\n                 return Err(SpanSnippetError::SourceNotAvailable {\n                     filename: local_begin.sf.name.clone()\n@@ -567,8 +588,9 @@ impl SourceMap {\n \n     /// Returns the source snippet as `String` corresponding to the given `Span`\n     pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n-        self.span_to_source(sp, |src, start_index, end_index| src[start_index..end_index]\n-                                                                .to_string())\n+        self.span_to_source(sp, |src, start_index, end_index| src.get(start_index..end_index)\n+            .map(|s| s.to_string())\n+            .ok_or_else(|| SpanSnippetError::IllFormedSpan(sp)))\n     }\n \n     pub fn span_to_margin(&self, sp: Span) -> Option<usize> {\n@@ -582,7 +604,9 @@ impl SourceMap {\n \n     /// Returns the source snippet as `String` before the given `Span`\n     pub fn span_to_prev_source(&self, sp: Span) -> Result<String, SpanSnippetError> {\n-        self.span_to_source(sp, |src, start_index, _| src[..start_index].to_string())\n+        self.span_to_source(sp, |src, start_index, _| src.get(..start_index)\n+            .map(|s| s.to_string())\n+            .ok_or_else(|| SpanSnippetError::IllFormedSpan(sp)))\n     }\n \n     /// Extend the given `Span` to just after the previous occurrence of `c`. Return the same span"}, {"sha": "c7b8332c53ef721eec7decfd282a2391e9d5be64", "filename": "src/libsyntax/source_map/tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map%2Ftests.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -91,7 +91,7 @@ fn t6() {\n fn t7() {\n     // Test span_to_lines for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let file_lines = sm.span_to_lines(span).unwrap();\n \n     assert_eq!(file_lines.file.name, PathBuf::from(\"blork.rs\").into());\n@@ -107,7 +107,7 @@ fn span_from_selection(input: &str, selection: &str) -> Span {\n     assert_eq!(input.len(), selection.len());\n     let left_index = selection.find('~').unwrap() as u32;\n     let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-    Span::new(BytePos(left_index), BytePos(right_index + 1), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(left_index), BytePos(right_index + 1))\n }\n \n /// Tests span_to_snippet and span_to_lines for a span converting 3\n@@ -137,7 +137,7 @@ fn span_to_snippet_and_lines_spanning_multiple_lines() {\n fn t8() {\n     // Test span_to_snippet for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let snippet = sm.span_to_snippet(span);\n \n     assert_eq!(snippet, Ok(\"second line\".to_string()));\n@@ -147,7 +147,7 @@ fn t8() {\n fn t9() {\n     // Test span_to_str for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let sstr =  sm.span_to_string(span);\n \n     assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n@@ -198,10 +198,9 @@ impl SourceMapExtension for SourceMap {\n             let lo = hi + offset;\n             hi = lo + substring.len();\n             if i == n {\n-                let span = Span::new(\n+                let span = Span::with_root_ctxt(\n                     BytePos(lo as u32 + file.start_pos.0),\n                     BytePos(hi as u32 + file.start_pos.0),\n-                    NO_EXPANSION,\n                 );\n                 assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n                         substring);"}, {"sha": "4c0e1e3704dffa9df5b758fe68edd9440a5c527f", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -9,7 +9,7 @@ use crate::with_default_globals;\n use errors::emitter::EmitterWriter;\n use errors::Handler;\n use rustc_data_structures::sync::Lrc;\n-use syntax_pos::{BytePos, NO_EXPANSION, Span, MultiSpan};\n+use syntax_pos::{BytePos, Span, MultiSpan};\n \n use std::io;\n use std::io::prelude::*;\n@@ -169,7 +169,7 @@ fn make_span(file_text: &str, start: &Position, end: &Position) -> Span {\n     let start = make_pos(file_text, start);\n     let end = make_pos(file_text, end) + end.string.len(); // just after matching thing ends\n     assert!(start <= end);\n-    Span::new(BytePos(start as u32), BytePos(end as u32), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(start as u32), BytePos(end as u32))\n }\n \n fn make_pos(file_text: &str, pos: &Position) -> usize {"}, {"sha": "5017e5f5424c10fa78a172e3059133e4f8bce23b", "filename": "src/libsyntax/tokenstream/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream%2Ftests.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -3,14 +3,14 @@ use super::*;\n use crate::ast::Name;\n use crate::with_default_globals;\n use crate::tests::string_to_stream;\n-use syntax_pos::{Span, BytePos, NO_EXPANSION};\n+use syntax_pos::{Span, BytePos};\n \n fn string_to_ts(string: &str) -> TokenStream {\n     string_to_stream(string.to_owned())\n }\n \n fn sp(a: u32, b: u32) -> Span {\n-    Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n #[test]"}, {"sha": "a501541c95909c5e37158602ab222744f477cbcf", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -97,6 +97,8 @@ impl AssocOp {\n             // DotDotDot is no longer supported, but we need some way to display the error\n             token::DotDotDot => Some(DotDotEq),\n             token::Colon => Some(Colon),\n+            // `<-` should probably be `< -`\n+            token::LArrow => Some(Less),\n             _ if t.is_keyword(kw::As) => Some(As),\n             _ => None\n         }"}, {"sha": "6648347d4aef543aba90e9ebcb1c9794c19da6bb", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -311,11 +311,11 @@ pub fn walk_variant<'a, V>(visitor: &mut V,\n                            item_id: NodeId)\n     where V: Visitor<'a>,\n {\n-    visitor.visit_ident(variant.node.ident);\n-    visitor.visit_variant_data(&variant.node.data, variant.node.ident,\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_variant_data(&variant.data, variant.ident,\n                              generics, item_id, variant.span);\n-    walk_list!(visitor, visit_anon_const, &variant.node.disr_expr);\n-    walk_list!(visitor, visit_attribute, &variant.node.attrs);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n \n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n@@ -442,9 +442,9 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n         PatKind::Struct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n-                walk_list!(visitor, visit_attribute, field.node.attrs.iter());\n-                visitor.visit_ident(field.node.ident);\n-                visitor.visit_pat(&field.node.pat)\n+                walk_list!(visitor, visit_attribute, field.attrs.iter());\n+                visitor.visit_ident(field.ident);\n+                visitor.visit_pat(&field.pat)\n             }\n         }\n         PatKind::Tuple(ref elems) => {\n@@ -663,7 +663,7 @@ pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n }\n \n pub fn walk_mac<'a, V: Visitor<'a>>(visitor: &mut V, mac: &'a Mac) {\n-    visitor.visit_path(&mac.node.path, DUMMY_NODE_ID);\n+    visitor.visit_path(&mac.path, DUMMY_NODE_ID);\n }\n \n pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonConst) {"}, {"sha": "644a44f1989dbd5d6e75b2628cf80dfd20116f3f", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -47,10 +47,10 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        -> Box<dyn base::MacResult + 'cx> {\n     let mut inline_asm = match parse_inline_asm(cx, sp, tts) {\n         Ok(Some(inline_asm)) => inline_asm,\n-        Ok(None) => return DummyResult::expr(sp),\n+        Ok(None) => return DummyResult::any(sp),\n         Err(mut err) => {\n             err.emit();\n-            return DummyResult::expr(sp);\n+            return DummyResult::any(sp);\n         }\n     };\n \n@@ -63,7 +63,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(inline_asm)),\n-        span: sp,\n+        span: sp.with_ctxt(cx.backtrace()),\n         attrs: ThinVec::new(),\n     }))\n }\n@@ -277,6 +277,5 @@ fn parse_inline_asm<'a>(\n         volatile,\n         alignstack,\n         dialect,\n-        ctxt: cx.backtrace(),\n     }))\n }"}, {"sha": "6301283460ac7460a333fb0bbb16c6abee796ed2", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,7 +1,6 @@\n use errors::{Applicability, DiagnosticBuilder};\n \n use syntax::ast::{self, *};\n-use syntax::source_map::Spanned;\n use syntax::ext::base::*;\n use syntax::parse::token::{self, TokenKind};\n use syntax::parse::parser::Parser;\n@@ -20,12 +19,12 @@ pub fn expand_assert<'cx>(\n         Ok(assert) => assert,\n         Err(mut err) => {\n             err.emit();\n-            return DummyResult::expr(sp);\n+            return DummyResult::any(sp);\n         }\n     };\n \n     let sp = sp.apply_mark(cx.current_expansion.id);\n-    let panic_call = Mac_ {\n+    let panic_call = Mac {\n         path: Path::from_ident(Ident::new(sym::panic, sp)),\n         tts: custom_message.unwrap_or_else(|| {\n             TokenStream::from(TokenTree::token(\n@@ -37,17 +36,15 @@ pub fn expand_assert<'cx>(\n             ))\n         }).into(),\n         delim: MacDelimiter::Parenthesis,\n+        span: sp,\n         prior_type_ascription: None,\n     };\n     let if_expr = cx.expr_if(\n         sp,\n         cx.expr(sp, ExprKind::Unary(UnOp::Not, cond_expr)),\n         cx.expr(\n             sp,\n-            ExprKind::Mac(Spanned {\n-                span: sp,\n-                node: panic_call,\n-            }),\n+            ExprKind::Mac(panic_call),\n         ),\n         None,\n     );"}, {"sha": "0e52c1af9086f019edcbd572a18f878b4d4d2895", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -25,7 +25,7 @@ pub fn expand_cfg(\n         }\n         Err(mut err) => {\n             err.emit();\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n     }\n }"}, {"sha": "4cd17531a4500ba8dfbbfb3781d47f16d0c70905", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,5 +1,5 @@\n use syntax::ast;\n-use syntax::ext::base;\n+use syntax::ext::base::{self, DummyResult};\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n \n@@ -12,7 +12,7 @@ pub fn expand_syntax_ext(\n ) -> Box<dyn base::MacResult + 'static> {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n-        None => return base::DummyResult::expr(sp),\n+        None => return DummyResult::any(sp),\n     };\n     let mut accumulator = String::new();\n     let mut missing_literal = vec![];\n@@ -55,9 +55,9 @@ pub fn expand_syntax_ext(\n         let mut err = cx.struct_span_err(missing_literal, \"expected a literal\");\n         err.note(\"only literals (like `\\\"foo\\\"`, `42` and `3.14`) can be passed to `concat!()`\");\n         err.emit();\n-        return base::DummyResult::expr(sp);\n+        return DummyResult::any(sp);\n     } else if has_errors {\n-        return base::DummyResult::expr(sp);\n+        return DummyResult::any(sp);\n     }\n     let sp = sp.apply_mark(cx.current_expansion.id);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))"}, {"sha": "d030ea4a56ebb8b49ca4657a9a5fd6b0029db336", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -35,7 +35,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n-                    let container_id = cx.current_expansion.id.parent();\n+                    let container_id = cx.current_expansion.id.expn_data().parent;\n                     if cx.resolver.has_derives(container_id, SpecialDerives::COPY) &&\n                         !params.iter().any(|param| match param.kind {\n                             ast::GenericParamKind::Type { .. } => true,\n@@ -129,7 +129,7 @@ fn cs_clone_shallow(name: &str,\n     if is_union {\n         // let _: AssertParamIsCopy<Self>;\n         let self_ty =\n-            cx.ty_path(cx.path_ident(trait_span, ast::Ident::with_empty_ctxt(kw::SelfUpper)));\n+            cx.ty_path(cx.path_ident(trait_span, ast::Ident::with_dummy_span(kw::SelfUpper)));\n         assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n     } else {\n         match *substr.fields {\n@@ -138,7 +138,7 @@ fn cs_clone_shallow(name: &str,\n             }\n             StaticEnum(enum_def, ..) => {\n                 for variant in &enum_def.variants {\n-                    process_variant(cx, &mut stmts, &variant.node.data);\n+                    process_variant(cx, &mut stmts, &variant.data);\n                 }\n             }\n             _ => cx.span_bug(trait_span, &format!(\"unexpected substructure in \\\n@@ -170,9 +170,9 @@ fn cs_clone(name: &str,\n             vdata = vdata_;\n         }\n         EnumMatching(.., variant, ref af) => {\n-            ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.node.ident]);\n+            ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.ident]);\n             all_fields = af;\n-            vdata = &variant.node.data;\n+            vdata = &variant.data;\n         }\n         EnumNonMatchingCollapsed(..) => {\n             cx.span_bug(trait_span,"}, {"sha": "54027c600b4cd714202ff9a6e39b5e1b6d07bf0b", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -13,7 +13,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut dyn FnMut(Annotatable)) {\n-    cx.resolver.add_derives(cx.current_expansion.id.parent(), SpecialDerives::EQ);\n+    cx.resolver.add_derives(cx.current_expansion.id.expn_data().parent, SpecialDerives::EQ);\n \n     let inline = cx.meta_word(span, sym::inline);\n     let hidden = cx.meta_list_item_word(span, sym::hidden);\n@@ -75,7 +75,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt<'_>,\n         }\n         StaticEnum(enum_def, ..) => {\n             for variant in &enum_def.variants {\n-                process_variant(cx, &mut stmts, &variant.node.data);\n+                process_variant(cx, &mut stmts, &variant.data);\n             }\n         }\n         _ => cx.span_bug(trait_span, \"unexpected substructure in `derive(Eq)`\")"}, {"sha": "55687c3175b9dbfe83f82a5fd4945eb1341522b4", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -43,17 +43,18 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt<'_>,\n }\n \n \n-pub fn ordering_collapsed(cx: &mut ExtCtxt<'_>,\n-                          span: Span,\n-                          self_arg_tags: &[ast::Ident])\n-                          -> P<ast::Expr> {\n+pub fn ordering_collapsed(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    self_arg_tags: &[ast::Ident],\n+) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n+    cx.expr_method_call(span, lft, ast::Ident::new(sym::cmp, span), vec![rgt])\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let test_id = cx.ident_of(\"cmp\").gensym();\n+    let test_id = ast::Ident::new(sym::cmp, span);\n     let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n \n     let cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n@@ -75,34 +76,34 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n             // as the outermost one, and the last as the innermost.\n             false,\n             |cx, span, old, self_f, other_fs| {\n-        // match new {\n-        //     ::std::cmp::Ordering::Equal => old,\n-        //     cmp => cmp\n-        // }\n+                // match new {\n+                //     ::std::cmp::Ordering::Equal => old,\n+                //     cmp => cmp\n+                // }\n \n-        let new = {\n-            let other_f = match other_fs {\n-                [o_f] => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n-            };\n+                let new = {\n+                    let other_f = match other_fs {\n+                        [o_f] => o_f,\n+                        _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n+                    };\n \n-            let args = vec![\n-                    cx.expr_addr_of(span, self_f),\n-                    cx.expr_addr_of(span, other_f.clone()),\n-                ];\n+                    let args = vec![\n+                            cx.expr_addr_of(span, self_f),\n+                            cx.expr_addr_of(span, other_f.clone()),\n+                        ];\n \n-            cx.expr_call_global(span, cmp_path.clone(), args)\n-        };\n+                    cx.expr_call_global(span, cmp_path.clone(), args)\n+                };\n \n-        let eq_arm = cx.arm(span,\n-                            vec![cx.pat_path(span, equals_path.clone())],\n-                            old);\n-        let neq_arm = cx.arm(span,\n-                             vec![cx.pat_ident(span, test_id)],\n-                             cx.expr_ident(span, test_id));\n+                let eq_arm = cx.arm(span,\n+                                    vec![cx.pat_path(span, equals_path.clone())],\n+                                    old);\n+                let neq_arm = cx.arm(span,\n+                                     vec![cx.pat_ident(span, test_id)],\n+                                     cx.expr_ident(span, test_id));\n \n-        cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-    },\n+                cx.expr_match(span, new, vec![eq_arm, neq_arm])\n+            },\n             cx.expr_path(equals_path.clone()),\n             Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n         if self_args.len() != 2 {"}, {"sha": "91e1e80e4fbfa1347da4ee6a009eefbd76f66f18", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -13,7 +13,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n                                   mitem: &MetaItem,\n                                   item: &Annotatable,\n                                   push: &mut dyn FnMut(Annotatable)) {\n-    cx.resolver.add_derives(cx.current_expansion.id.parent(), SpecialDerives::PARTIAL_EQ);\n+    cx.resolver.add_derives(cx.current_expansion.id.expn_data().parent, SpecialDerives::PARTIAL_EQ);\n \n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different"}, {"sha": "740b92a9b7978bbf9ac21a122bcbf0524450de17", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -94,11 +94,12 @@ pub enum OrderingOp {\n     GeOp,\n }\n \n-pub fn some_ordering_collapsed(cx: &mut ExtCtxt<'_>,\n-                               span: Span,\n-                               op: OrderingOp,\n-                               self_arg_tags: &[ast::Ident])\n-                               -> P<ast::Expr> {\n+pub fn some_ordering_collapsed(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    op: OrderingOp,\n+    self_arg_tags: &[ast::Ident],\n+) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n     let op_str = match op {\n@@ -108,11 +109,11 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt<'_>,\n         GtOp => \"gt\",\n         GeOp => \"ge\",\n     };\n-    cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n+    cx.expr_method_call(span, lft, ast::Ident::from_str_and_span(op_str, span), vec![rgt])\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let test_id = cx.ident_of(\"cmp\").gensym();\n+    let test_id = ast::Ident::new(sym::cmp, span);\n     let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n     let equals_expr = cx.expr_some(span, ordering_expr);"}, {"sha": "441535410480b678593f9025868dd0e1c2d84924", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -53,7 +53,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // based on the \"shape\".\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n-        EnumMatching(_, _, v, fields) => (v.node.ident, &v.node.data, fields),\n+        EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n         EnumNonMatchingCollapsed(..) |\n         StaticStruct(..) |\n         StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),\n@@ -62,7 +62,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = span.with_ctxt(cx.backtrace());\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let builder = Ident::from_str(\"debug_trait_builder\").gensym();\n+    let builder = Ident::from_str_and_span(\"debug_trait_builder\", span);\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -73,7 +73,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             // tuple struct/\"normal\" variant\n             let expr =\n                 cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n-            stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n+            stmts.push(cx.stmt_let(span, true, builder, expr));\n \n             for field in fields {\n                 // Use double indirection to make sure this works for unsized types\n@@ -82,7 +82,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n \n                 let expr = cx.expr_method_call(span,\n                                                 builder_expr.clone(),\n-                                                Ident::with_empty_ctxt(sym::field),\n+                                                Ident::new(sym::field, span),\n                                                 vec![field]);\n \n                 // Use `let _ = expr;` to avoid triggering the\n@@ -106,7 +106,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 let field = cx.expr_addr_of(field.span, field);\n                 let expr = cx.expr_method_call(span,\n                                                 builder_expr.clone(),\n-                                                Ident::with_empty_ctxt(sym::field),\n+                                                Ident::new(sym::field, span),\n                                                 vec![name, field]);\n                 stmts.push(stmt_let_undescore(cx, span, expr));\n             }"}, {"sha": "9b6f8518de046dc16e2049aa593150d06ed5909f", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,6 +1,6 @@\n-//! The compiler code necessary for `#[derive(Decodable)]`. See encodable.rs for more.\n+//! The compiler code necessary for `#[derive(RustcDecodable)]`. See encodable.rs for more.\n \n-use crate::deriving::{self, pathvec_std};\n+use crate::deriving::pathvec_std;\n use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n@@ -17,7 +17,7 @@ pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt<'_>,\n                                        item: &Annotatable,\n                                        push: &mut dyn FnMut(Annotatable)) {\n     let krate = \"rustc_serialize\";\n-    let typaram = &*deriving::hygienic_type_parameter(item, \"__D\");\n+    let typaram = \"__D\";\n \n     let trait_def = TraitDef {\n         span,"}, {"sha": "8b18fb25e90c121e7bea4120927c5f5111d3f483", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,11 +1,12 @@\n-//! The compiler code necessary to implement the `#[derive(Encodable)]`\n-//! (and `Decodable`, in `decodable.rs`) extension. The idea here is that\n-//! type-defining items may be tagged with `#[derive(Encodable, Decodable)]`.\n+//! The compiler code necessary to implement the `#[derive(RustcEncodable)]`\n+//! (and `RustcDecodable`, in `decodable.rs`) extension. The idea here is that\n+//! type-defining items may be tagged with\n+//! `#[derive(RustcEncodable, RustcDecodable)]`.\n //!\n //! For example, a type like:\n //!\n //! ```\n-//! #[derive(Encodable, Decodable)]\n+//! #[derive(RustcEncodable, RustcDecodable)]\n //! struct Node { id: usize }\n //! ```\n //!\n@@ -40,15 +41,17 @@\n //! references other non-built-in types. A type definition like:\n //!\n //! ```\n-//! # #[derive(Encodable, Decodable)] struct Span;\n-//! #[derive(Encodable, Decodable)]\n+//! # #[derive(RustcEncodable, RustcDecodable)]\n+//! # struct Span;\n+//! #[derive(RustcEncodable, RustcDecodable)]\n //! struct Spanned<T> { node: T, span: Span }\n //! ```\n //!\n //! would yield functions like:\n //!\n //! ```\n-//! # #[derive(Encodable, Decodable)] struct Span;\n+//! # #[derive(RustcEncodable, RustcDecodable)]\n+//! # struct Span;\n //! # struct Spanned<T> { node: T, span: Span }\n //! impl<\n //!     S: Encoder<E>,\n@@ -82,7 +85,7 @@\n //! }\n //! ```\n \n-use crate::deriving::{self, pathvec_std};\n+use crate::deriving::pathvec_std;\n use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n@@ -98,7 +101,7 @@ pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt<'_>,\n                                        item: &Annotatable,\n                                        push: &mut dyn FnMut(Annotatable)) {\n     let krate = \"rustc_serialize\";\n-    let typaram = &*deriving::hygienic_type_parameter(item, \"__S\");\n+    let typaram = \"__S\";\n \n     let trait_def = TraitDef {\n         span,\n@@ -238,7 +241,7 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, variant.node.ident.name);\n+            let name = cx.expr_str(trait_span, variant.ident.name);\n             let call = cx.expr_method_call(trait_span,\n                                            blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),"}, {"sha": "1475bac0688460444c50fe5f7688048251c813b8", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -187,7 +187,7 @@ use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt, SpecialDerives};\n-use syntax::source_map::{self, respan};\n+use syntax::source_map::respan;\n use syntax::util::map_in_place::MapInPlace;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, kw, sym};\n@@ -425,7 +425,7 @@ impl<'a> TraitDef<'a> {\n                         return;\n                     }\n                 };\n-                let container_id = cx.current_expansion.id.parent();\n+                let container_id = cx.current_expansion.id.expn_data().parent;\n                 let is_always_copy =\n                     cx.resolver.has_derives(container_id, SpecialDerives::COPY) &&\n                     has_no_type_params;\n@@ -758,7 +758,7 @@ impl<'a> TraitDef<'a> {\n         let mut field_tys = Vec::new();\n \n         for variant in &enum_def.variants {\n-            field_tys.extend(variant.node\n+            field_tys.extend(variant\n                 .data\n                 .fields()\n                 .iter()\n@@ -890,7 +890,7 @@ impl<'a> MethodDef<'a> {\n \n         for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(name).gensym();\n+            let ident = ast::Ident::from_str_and_span(name, trait_.span);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -928,7 +928,7 @@ impl<'a> MethodDef<'a> {\n \n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n-                let ident = Ident::with_empty_ctxt(kw::SelfLower).with_span_pos(trait_.span);\n+                let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(trait_.span);\n                 ast::Arg::from_self(ThinVec::default(), explicit_self, ident)\n             });\n             let nonself_args = arg_types.into_iter()\n@@ -1210,7 +1210,7 @@ impl<'a> MethodDef<'a> {\n         let vi_idents = self_arg_names.iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                cx.ident_of(&vi_suffix[..]).gensym()\n+                ast::Ident::from_str_and_span(&vi_suffix[..], trait_.span)\n             })\n             .collect::<Vec<ast::Ident>>();\n \n@@ -1220,7 +1220,7 @@ impl<'a> MethodDef<'a> {\n         let catch_all_substructure =\n             EnumNonMatchingCollapsed(self_arg_idents, &variants[..], &vi_idents[..]);\n \n-        let first_fieldless = variants.iter().find(|v| v.node.data.fields().is_empty());\n+        let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n \n         // These arms are of the form:\n         // (Variant1, Variant1, ...) => Body1\n@@ -1229,7 +1229,7 @@ impl<'a> MethodDef<'a> {\n         // where each tuple has length = self_args.len()\n         let mut match_arms: Vec<ast::Arm> = variants.iter()\n             .enumerate()\n-            .filter(|&(_, v)| !(self.unify_fieldless_variants && v.node.data.fields().is_empty()))\n+            .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n                 let mk_self_pat = |cx: &mut ExtCtxt<'_>, self_arg_name: &str| {\n                     let (p, idents) = trait_.create_enum_variant_pattern(cx,\n@@ -1387,7 +1387,10 @@ impl<'a> MethodDef<'a> {\n                 let variant_value =\n                     deriving::call_intrinsic(cx, sp, \"discriminant_value\", vec![self_addr]);\n \n-                let target_ty = cx.ty_ident(sp, cx.ident_of(target_type_name));\n+                let target_ty = cx.ty_ident(\n+                    sp,\n+                    ast::Ident::from_str_and_span(target_type_name, sp),\n+                );\n                 let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n                 index_let_stmts.push(let_stmt);\n@@ -1513,8 +1516,8 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|v| {\n                 let sp = v.span.with_ctxt(trait_.span.ctxt());\n-                let summary = trait_.summarise_struct(cx, &v.node.data);\n-                (v.node.ident, sp, summary)\n+                let summary = trait_.summarise_struct(cx, &v.data);\n+                (v.ident, sp, summary)\n             })\n             .collect();\n         self.call_substructure_method(cx,\n@@ -1588,7 +1591,7 @@ impl<'a> TraitDef<'a> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)).gensym();\n+            let ident = ast::Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries {\n@@ -1610,14 +1613,13 @@ impl<'a> TraitDef<'a> {\n                         if ident.is_none() {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n                         }\n-                        source_map::Spanned {\n+                        ast::FieldPat {\n+                            ident: ident.unwrap(),\n+                            is_shorthand: false,\n+                            attrs: ThinVec::new(),\n+                            id: ast::DUMMY_NODE_ID,\n                             span: pat.span.with_ctxt(self.span.ctxt()),\n-                            node: ast::FieldPat {\n-                                ident: ident.unwrap(),\n-                                pat,\n-                                is_shorthand: false,\n-                                attrs: ThinVec::new(),\n-                            },\n+                            pat,\n                         }\n                     })\n                     .collect();\n@@ -1643,9 +1645,9 @@ impl<'a> TraitDef<'a> {\n          mutbl: ast::Mutability)\n          -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let sp = variant.span.with_ctxt(self.span.ctxt());\n-        let variant_path = cx.path(sp, vec![enum_ident, variant.node.ident]);\n+        let variant_path = cx.path(sp, vec![enum_ident, variant.ident]);\n         let use_temporaries = false; // enums can't be repr(packed)\n-        self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl,\n+        self.create_struct_pattern(cx, variant_path, &variant.data, prefix, mutbl,\n                                    use_temporaries)\n     }\n }\n@@ -1776,7 +1778,7 @@ pub fn is_type_without_fields(item: &Annotatable) -> bool {\n     if let Annotatable::Item(ref item) = *item {\n         match item.node {\n             ast::ItemKind::Enum(ref enum_def, _) => {\n-                enum_def.variants.iter().all(|v| v.node.data.fields().is_empty())\n+                enum_def.variants.iter().all(|v| v.data.fields().is_empty())\n             }\n             ast::ItemKind::Struct(ref variant_data, _) => variant_data.fields().is_empty(),\n             _ => false,"}, {"sha": "7fcf036fc817690de2c57b082cd317dc8ae68918", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -72,7 +72,7 @@ impl<'a> Path<'a> {\n                    self_ty: Ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n-        let mut idents = self.path.iter().map(|s| cx.ident_of(*s)).collect();\n+        let mut idents = self.path.iter().map(|s| Ident::from_str_and_span(*s, span)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys: Vec<P<ast::Ty>> =\n             self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n@@ -209,7 +209,7 @@ fn mk_ty_param(cx: &ExtCtxt<'_>,\n             cx.trait_bound(path)\n         })\n         .collect();\n-    cx.typaram(span, cx.ident_of(name), attrs.to_owned(), bounds, None)\n+    cx.typaram(span, ast::Ident::from_str_and_span(name, span), attrs.to_owned(), bounds, None)\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {"}, {"sha": "2fc594abd705e38290571dbc5a4a3b1fb6e27b21", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -16,7 +16,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n \n     let path = Path::new_(pathvec_std!(cx, hash::Hash), None, vec![], PathKind::Std);\n \n-    let typaram = &*deriving::hygienic_type_parameter(item, \"__H\");\n+    let typaram = \"__H\";\n \n     let arg = Path::new_local(typaram);\n     let hash_trait_def = TraitDef {"}, {"sha": "da68eea0c50e72606f7f845eb8c036749b5163ed", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -54,33 +54,6 @@ impl MultiItemModifier for BuiltinDerive {\n     }\n }\n \n-/// Construct a name for the inner type parameter that can't collide with any type parameters of\n-/// the item. This is achieved by starting with a base and then concatenating the names of all\n-/// other type parameters.\n-// FIXME(aburka): use real hygiene when that becomes possible\n-fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n-    let mut typaram = String::from(base);\n-    if let Annotatable::Item(ref item) = *item {\n-        match item.node {\n-            ast::ItemKind::Struct(_, ast::Generics { ref params, .. }) |\n-            ast::ItemKind::Enum(_, ast::Generics { ref params, .. }) => {\n-                for param in params {\n-                    match param.kind {\n-                        ast::GenericParamKind::Type { .. } => {\n-                            typaram.push_str(&param.ident.as_str());\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-    }\n-\n-    typaram\n-}\n-\n /// Constructs an expression that calls an intrinsic\n fn call_intrinsic(cx: &ExtCtxt<'_>,\n                   span: Span,"}, {"sha": "9834130fa23f0871b44145e187ab492d97945bfa", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -16,20 +16,20 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               tts: &[tokenstream::TokenTree])\n                               -> Box<dyn base::MacResult + 'cx> {\n     let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n-        None => return DummyResult::expr(sp),\n+        None => return DummyResult::any(sp),\n         Some(v) => v,\n     };\n \n     let sp = sp.apply_mark(cx.current_expansion.id);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n-            let lt = cx.lifetime(sp, Ident::with_empty_ctxt(kw::StaticLifetime));\n+            let lt = cx.lifetime(sp, Ident::with_dummy_span(kw::StaticLifetime));\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n                                      cx.std_path(&[sym::option, sym::Option, sym::None]),\n                                      vec![GenericArg::Type(cx.ty_rptr(sp,\n                                                      cx.ty_ident(sp,\n-                                                                 Ident::with_empty_ctxt(sym::str)),\n+                                                                 Ident::with_dummy_span(sym::str)),\n                                                      Some(lt),\n                                                      ast::Mutability::Immutable))],\n                                      vec![]))\n@@ -50,35 +50,35 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-            return DummyResult::expr(sp);\n+            return DummyResult::any(sp);\n         }\n-        None => return DummyResult::expr(sp),\n+        None => return DummyResult::any(sp),\n         Some(exprs) => exprs.into_iter(),\n     };\n \n     let var = match expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") {\n-        None => return DummyResult::expr(sp),\n+        None => return DummyResult::any(sp),\n         Some((v, _style)) => v,\n     };\n     let msg = match exprs.next() {\n         None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n-                None => return DummyResult::expr(sp),\n+                None => return DummyResult::any(sp),\n                 Some((s, _style)) => s,\n             }\n         }\n     };\n \n     if exprs.next().is_some() {\n         cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-        return DummyResult::expr(sp);\n+        return DummyResult::any(sp);\n     }\n \n     let e = match env::var(&*var.as_str()) {\n         Err(_) => {\n             cx.span_err(sp, &msg.as_str());\n-            return DummyResult::expr(sp);\n+            return DummyResult::any(sp);\n         }\n         Ok(s) => cx.expr_str(sp, Symbol::intern(&s)),\n     };"}, {"sha": "83764205a198e340aa0717e90d0454f561d67e5b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -805,7 +805,7 @@ fn expand_format_args_impl<'cx>(\n         }\n         Err(mut err) => {\n             err.emit();\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n     }\n }\n@@ -846,9 +846,9 @@ pub fn expand_preparsed_format_args(\n \n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;\n-    let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n+    let (fmt_str, fmt_style, fmt_span) = match expr_to_spanned_string(ecx, efmt, msg) {\n         Ok(mut fmt) if append_newline => {\n-            fmt.node.0 = Symbol::intern(&format!(\"{}\\n\", fmt.node.0));\n+            fmt.0 = Symbol::intern(&format!(\"{}\\n\", fmt.0));\n             fmt\n         }\n         Ok(fmt) => fmt,\n@@ -875,7 +875,7 @@ pub fn expand_preparsed_format_args(\n         _ => (false, None),\n     };\n \n-    let str_style = match fmt.node.1 {\n+    let str_style = match fmt_style {\n         ast::StrStyle::Cooked => None,\n         ast::StrStyle::Raw(raw) => {\n             Some(raw as usize)\n@@ -981,7 +981,7 @@ pub fn expand_preparsed_format_args(\n         vec![]\n     };\n \n-    let fmt_str = &*fmt.node.0.as_str();  // for the suggestions below\n+    let fmt_str = &*fmt_str.as_str();  // for the suggestions below\n     let mut parser = parse::Parser::new(fmt_str, str_style, skips, append_newline);\n \n     let mut unverified_pieces = Vec::new();\n@@ -995,23 +995,23 @@ pub fn expand_preparsed_format_args(\n \n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = fmt.span.from_inner(err.span);\n+        let sp = fmt_span.from_inner(err.span);\n         let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n                                                      err.description));\n         e.span_label(sp, err.label + \" in format string\");\n         if let Some(note) = err.note {\n             e.note(&note);\n         }\n         if let Some((label, span)) = err.secondary_label {\n-            let sp = fmt.span.from_inner(span);\n+            let sp = fmt_span.from_inner(span);\n             e.span_label(sp, label);\n         }\n         e.emit();\n         return DummyResult::raw_expr(sp, true);\n     }\n \n     let arg_spans = parser.arg_places.iter()\n-        .map(|span| fmt.span.from_inner(*span))\n+        .map(|span| fmt_span.from_inner(*span))\n         .collect();\n \n     let named_pos: FxHashSet<usize> = names.values().cloned().collect();\n@@ -1034,7 +1034,7 @@ pub fn expand_preparsed_format_args(\n         str_pieces: Vec::with_capacity(unverified_pieces.len()),\n         all_pieces_simple: true,\n         macsp,\n-        fmtsp: fmt.span,\n+        fmtsp: fmt_span,\n         invalid_refs: Vec::new(),\n         arg_spans,\n         arg_with_formatting: Vec::new(),"}, {"sha": "d2121abe3b466b5313938138017597fc1f20de53", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -29,7 +29,7 @@ pub fn expand(\n     };\n \n     // Generate a bunch of new items using the AllocFnFactory\n-    let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let span = item.span.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n     let f = AllocFnFactory {\n         span,\n         kind: AllocatorKind::Global,\n@@ -44,7 +44,7 @@ pub fn expand(\n     let const_ty = ecx.ty(span, TyKind::Tup(Vec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item =\n-        ecx.item_const(span, Ident::with_empty_ctxt(kw::Underscore), const_ty, const_body);\n+        ecx.item_const(span, Ident::with_dummy_span(kw::Underscore), const_ty, const_body);\n \n     // Return the original item and the new methods.\n     vec![Annotatable::Item(item), Annotatable::Item(const_item)]\n@@ -120,7 +120,7 @@ impl AllocFnFactory<'_, '_> {\n     ) -> P<Expr> {\n         match *ty {\n             AllocatorTy::Layout => {\n-                let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n+                let usize = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::usize));\n                 let ty_usize = self.cx.ty_path(usize);\n                 let size = ident();\n                 let align = ident();\n@@ -178,12 +178,12 @@ impl AllocFnFactory<'_, '_> {\n     }\n \n     fn usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n+        let usize = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::usize));\n         self.cx.ty_path(usize)\n     }\n \n     fn ptr_u8(&self) -> P<Ty> {\n-        let u8 = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::u8));\n+        let u8 = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::u8));\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }"}, {"sha": "73ebeaec454975c9e17b237c8c6185c63c41fe6d", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -30,7 +30,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ItemKind::GlobalAsm(P(global_asm)),\n                 vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-                span: sp,\n+                span: sp.with_ctxt(cx.backtrace()),\n                 tokens: None,\n             })])\n         }\n@@ -61,8 +61,5 @@ fn parse_global_asm<'a>(\n         None => return Ok(None),\n     };\n \n-    Ok(Some(ast::GlobalAsm {\n-        asm,\n-        ctxt: cx.backtrace(),\n-    }))\n+    Ok(Some(ast::GlobalAsm { asm }))\n }"}, {"sha": "4add2261c6cda1f4605b97f22b3022f7adb7fa88", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -42,7 +42,7 @@ pub mod test_harness;\n \n pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, edition: Edition) {\n     let mut register = |name, kind| resolver.register_builtin_macro(\n-        Ident::with_empty_ctxt(name), SyntaxExtension {\n+        Ident::with_dummy_span(name), SyntaxExtension {\n             is_builtin: true, ..SyntaxExtension::default(kind, edition)\n         },\n     );\n@@ -57,7 +57,6 @@ pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, e\n     }\n \n     register_bang! {\n-        __rust_unstable_column: source_util::expand_column,\n         asm: asm::expand_asm,\n         assert: assert::expand_assert,\n         cfg: cfg::expand_cfg,"}, {"sha": "dbfd8fe98f38999c582f1d935de57a54fcc85cd0", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -11,7 +11,7 @@ use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax::tokenstream::*;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnId, ExpnInfo, ExpnKind, MacroKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind, MacroKind};\n \n use std::mem;\n \n@@ -43,12 +43,12 @@ pub fn inject(\n ) {\n     if !named_exts.is_empty() {\n         let mut extra_items = Vec::new();\n-        let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+        let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n             ExpnKind::Macro(MacroKind::Attr, sym::plugin), DUMMY_SP, edition,\n             [sym::rustc_attrs][..].into(),\n         ));\n         for (name, ext) in named_exts {\n-            resolver.register_builtin_macro(Ident::with_empty_ctxt(name), ext);\n+            resolver.register_builtin_macro(Ident::with_dummy_span(name), ext);\n             extra_items.push(plugin_macro_def(name, span));\n         }\n         // The `macro_rules` items must be inserted before any other items."}, {"sha": "e772eaf834964359b8870fb081390517c48cf262", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,18 +1,16 @@\n use std::mem;\n \n+use smallvec::smallvec;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n+use syntax::source_map::{ExpnData, ExpnKind, respan};\n use syntax::ext::base::{ExtCtxt, MacroKind};\n-use syntax::ext::expand::ExpansionConfig;\n-use syntax::ext::hygiene::ExpnId;\n+use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::proc_macro::is_proc_macro_attr;\n-use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n-\n use syntax_pos::{Span, DUMMY_SP};\n \n struct ProcMacroDerive {\n@@ -329,7 +327,7 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n         [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n     ));\n@@ -338,7 +336,7 @@ fn mk_decls(\n     let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n     let doc_hidden = cx.attribute(doc);\n \n-    let proc_macro = Ident::with_empty_ctxt(sym::proc_macro);\n+    let proc_macro = Ident::with_dummy_span(sym::proc_macro);\n     let krate = cx.item(span,\n                         proc_macro,\n                         Vec::new(),\n@@ -350,7 +348,7 @@ fn mk_decls(\n     let custom_derive = Ident::from_str(\"custom_derive\");\n     let attr = Ident::from_str(\"attr\");\n     let bang = Ident::from_str(\"bang\");\n-    let crate_kw = Ident::with_empty_ctxt(kw::Crate);\n+    let crate_kw = Ident::with_dummy_span(kw::Crate);\n \n     let decls = {\n         let local_path = |sp: Span, name| {\n@@ -409,5 +407,7 @@ fn mk_decls(\n         i\n     });\n \n-    cx.monotonic_expander().flat_map_item(module).pop().unwrap()\n+    // Integrate the new module into existing module structures.\n+    let module = AstFragment::Items(smallvec![module]);\n+    cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap()\n }"}, {"sha": "e008ed710e4d07e1ea270bb1aa67d4fe26170705", "filename": "src/libsyntax_ext/source_util.rs", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -9,8 +9,6 @@ use syntax::tokenstream;\n use smallvec::SmallVec;\n use syntax_pos::{self, Pos, Span};\n \n-use std::fs;\n-use std::io::ErrorKind;\n use rustc_data_structures::sync::Lrc;\n \n // These macros all relate to the file system; they either return\n@@ -111,26 +109,23 @@ pub fn expand_include_str(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::To\n                           -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n-        None => return DummyResult::expr(sp)\n+        None => return DummyResult::any(sp)\n     };\n     let file = cx.resolve_path(file, sp);\n-    match fs::read_to_string(&file) {\n-        Ok(src) => {\n-            let interned_src = Symbol::intern(&src);\n-\n-            // Add this input file to the code map to make it available as\n-            // dependency information\n-            cx.source_map().new_source_file(file.into(), src);\n-\n-            base::MacEager::expr(cx.expr_str(sp, interned_src))\n+    match cx.source_map().load_binary_file(&file) {\n+        Ok(bytes) => match std::str::from_utf8(&bytes) {\n+            Ok(src) => {\n+                let interned_src = Symbol::intern(&src);\n+                base::MacEager::expr(cx.expr_str(sp, interned_src))\n+            }\n+            Err(_) => {\n+                cx.span_err(sp, &format!(\"{} wasn't a utf-8 file\", file.display()));\n+                DummyResult::any(sp)\n+            }\n         },\n-        Err(ref e) if e.kind() == ErrorKind::InvalidData => {\n-            cx.span_err(sp, &format!(\"{} wasn't a utf-8 file\", file.display()));\n-            DummyResult::expr(sp)\n-        }\n         Err(e) => {\n             cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n     }\n }\n@@ -139,26 +134,16 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::\n                             -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {\n         Some(f) => f,\n-        None => return DummyResult::expr(sp)\n+        None => return DummyResult::any(sp)\n     };\n     let file = cx.resolve_path(file, sp);\n-    match fs::read(&file) {\n+    match cx.source_map().load_binary_file(&file) {\n         Ok(bytes) => {\n-            // Add the contents to the source map if it contains UTF-8.\n-            let (contents, bytes) = match String::from_utf8(bytes) {\n-                Ok(s) => {\n-                    let bytes = s.as_bytes().to_owned();\n-                    (s, bytes)\n-                },\n-                Err(e) => (String::new(), e.into_bytes()),\n-            };\n-            cx.source_map().new_source_file(file.into(), contents);\n-\n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Lrc::new(bytes))))\n         },\n         Err(e) => {\n             cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n     }\n }"}, {"sha": "8ca376341fcdb7b72f6016c6ddbfa93bfe101f83", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,8 +1,8 @@\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n-use syntax::ext::hygiene::{ExpnId, MacroKind};\n+use syntax::ext::hygiene::MacroKind;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n+use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned, respan};\n use syntax::symbol::{Ident, Symbol, kw, sym};\n use syntax_pos::DUMMY_SP;\n \n@@ -32,15 +32,15 @@ pub fn inject(\n         // HACK(eddyb) gensym the injected crates on the Rust 2018 edition,\n         // so they don't accidentally interfere with the new import paths.\n         let orig_name_sym = Symbol::intern(orig_name_str);\n-        let orig_name_ident = Ident::with_empty_ctxt(orig_name_sym);\n+        let orig_name_ident = Ident::with_dummy_span(orig_name_sym);\n         let (rename, orig_name) = if rust_2018 {\n             (orig_name_ident.gensym(), Some(orig_name_sym))\n         } else {\n             (orig_name_ident, None)\n         };\n         krate.module.items.insert(0, P(ast::Item {\n             attrs: vec![attr::mk_attr_outer(\n-                attr::mk_word_item(ast::Ident::with_empty_ctxt(sym::macro_use))\n+                attr::mk_word_item(ast::Ident::with_dummy_span(sym::macro_use))\n             )],\n             vis: dummy_spanned(ast::VisibilityKind::Inherited),\n             node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n@@ -55,7 +55,7 @@ pub fn inject(\n     // the prelude.\n     let name = names[0];\n \n-    let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n         [sym::prelude_import][..].into(),\n     ));\n@@ -66,7 +66,7 @@ pub fn inject(\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: iter::once(ast::Ident::with_empty_ctxt(kw::PathRoot))\n+                segments: iter::once(ast::Ident::with_dummy_span(kw::PathRoot))\n                     .chain(\n                         [name, \"prelude\", \"v1\"].iter().cloned()\n                             .map(ast::Ident::from_str)"}, {"sha": "08582e714ccb26aba0bb51c4b627740b8451af0e", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -29,7 +29,7 @@ pub fn expand_test_case(\n \n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let sp = attr_sp.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n@@ -93,7 +93,7 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let ctxt = SyntaxContext::empty().apply_mark(cx.current_expansion.id);\n+    let ctxt = SyntaxContext::root().apply_mark(cx.current_expansion.id);\n     let (sp, attr_sp) = (item.span.with_ctxt(ctxt), attr_sp.with_ctxt(ctxt));\n \n     // Gensym \"test\" so we can extern crate without conflicting with any local names"}, {"sha": "4a6ea0ebf85e5b6fc5c0f215c754ee16a06b2419", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -5,14 +5,13 @@ use smallvec::{smallvec, SmallVec};\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n-use syntax::ext::base::{ExtCtxt, Resolver};\n-use syntax::ext::expand::ExpansionConfig;\n-use syntax::ext::hygiene::{ExpnId, MacroKind};\n+use syntax::ext::base::{ExtCtxt, MacroKind, Resolver};\n+use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::feature_gate::Features;\n use syntax::mut_visit::{*, ExpectOne};\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned};\n+use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -74,12 +73,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n         noop_visit_crate(c, self);\n \n         // Create a main function to run our tests\n-        let test_main = {\n-            let unresolved = mk_main(&mut self.cx);\n-            self.cx.ext_cx.monotonic_expander().flat_map_item(unresolved).pop().unwrap()\n-        };\n-\n-        c.module.items.push(test_main);\n+        c.module.items.push(mk_main(&mut self.cx));\n     }\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -155,7 +149,7 @@ impl MutVisitor for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n-                    let allow_ident = Ident::with_empty_ctxt(sym::allow);\n+                    let allow_ident = Ident::with_dummy_span(sym::allow);\n                     let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n                     let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n@@ -196,7 +190,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n                    tests: Vec<Ident>,\n                    tested_submods: Vec<(Ident, Ident)>)\n                    -> (P<ast::Item>, Ident) {\n-    let super_ = Ident::with_empty_ctxt(kw::Super);\n+    let super_ = Ident::with_dummy_span(kw::Super);\n \n     let items = tests.into_iter().map(|r| {\n         cx.ext_cx.item_use_simple(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n@@ -216,17 +210,22 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n     let name = Ident::from_str(\"__test_reexports\").gensym();\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.id = cx.ext_cx.resolver.get_module_scope(parent);\n-    let it = cx.ext_cx.monotonic_expander().flat_map_item(P(ast::Item {\n+    let module = P(ast::Item {\n         ident: name,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n         vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: DUMMY_SP,\n         tokens: None,\n-    })).pop().unwrap();\n+    });\n \n-    (it, name)\n+    // Integrate the new module into existing module structures.\n+    let module = AstFragment::Items(smallvec![module]);\n+    let module =\n+        cx.ext_cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap();\n+\n+    (module, name)\n }\n \n /// Crawl over the crate, inserting test reexports and the test main function\n@@ -269,12 +268,12 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+    let sp = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n         [sym::main, sym::test, sym::rustc_attrs][..].into(),\n     ));\n     let ecx = &cx.ext_cx;\n-    let test_id = Ident::with_empty_ctxt(sym::test);\n+    let test_id = Ident::with_dummy_span(sym::test);\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n@@ -321,16 +320,19 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n         None => Ident::from_str_and_span(\"main\", sp).gensym(),\n     };\n \n-    P(ast::Item {\n+    let main = P(ast::Item {\n         ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n         vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n-    })\n+    });\n \n+    // Integrate the new item into existing module structures.\n+    let main = AstFragment::Items(smallvec![main]);\n+    cx.ext_cx.monotonic_expander().fully_expand_fragment(main).make_items().pop().unwrap()\n }\n \n fn path_name_i(idents: &[Ident]) -> String {"}, {"sha": "00cd00f2837849b10cbe646f4b7fcfc28796fada", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -1,7 +1,6 @@\n use crate::symbol::{Symbol, sym};\n use std::fmt;\n use std::str::FromStr;\n-use crate::GLOBALS;\n \n /// The edition of the compiler (RFC 2052)\n #[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable, Eq)]\n@@ -39,10 +38,6 @@ impl fmt::Display for Edition {\n }\n \n impl Edition {\n-    pub fn from_session() -> Edition {\n-        GLOBALS.with(|globals| globals.edition)\n-    }\n-\n     pub fn lint_name(&self) -> &'static str {\n         match *self {\n             Edition::Edition2015 => \"rust_2015_compatibility\","}, {"sha": "ebfb0764fa2b2c684f8b8c7db216b686d44f85e1", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 72, "deletions": 100, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -13,8 +13,8 @@\n //\n // This explains why `HygieneData`, `SyntaxContext` and `ExpnId` have interfaces\n // with a certain amount of redundancy in them. For example,\n-// `SyntaxContext::outer_expn_info` combines `SyntaxContext::outer` and\n-// `ExpnId::expn_info` so that two `HygieneData` accesses can be performed within\n+// `SyntaxContext::outer_expn_data` combines `SyntaxContext::outer` and\n+// `ExpnId::expn_data` so that two `HygieneData` accesses can be performed within\n // a single `HygieneData::with` call.\n //\n // It also explains why many functions appear in `HygieneData` and again in\n@@ -56,16 +56,6 @@ struct SyntaxContextData {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct ExpnId(u32);\n \n-// FIXME: Find a way to merge this with `ExpnInfo`.\n-#[derive(Debug)]\n-struct InternalExpnData {\n-    parent: ExpnId,\n-    /// Each expansion should have an associated expansion info, but sometimes there's a delay\n-    /// between creation of an expansion ID and obtaining its info (e.g. macros are collected\n-    /// first and then resolved later), so we use an `Option` here.\n-    expn_info: Option<ExpnInfo>,\n-}\n-\n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n@@ -86,8 +76,8 @@ pub enum Transparency {\n }\n \n impl ExpnId {\n-    pub fn fresh(parent: ExpnId, expn_info: Option<ExpnInfo>) -> Self {\n-        HygieneData::with(|data| data.fresh_expn(parent, expn_info))\n+    pub fn fresh(expn_data: Option<ExpnData>) -> Self {\n+        HygieneData::with(|data| data.fresh_expn(expn_data))\n     }\n \n     /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n@@ -107,21 +97,16 @@ impl ExpnId {\n     }\n \n     #[inline]\n-    pub fn parent(self) -> ExpnId {\n-        HygieneData::with(|data| data.parent_expn(self))\n-    }\n-\n-    #[inline]\n-    pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(self).cloned())\n+    pub fn expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.expn_data(self).clone())\n     }\n \n     #[inline]\n-    pub fn set_expn_info(self, info: ExpnInfo) {\n+    pub fn set_expn_data(self, expn_data: ExpnData) {\n         HygieneData::with(|data| {\n-            let old_info = &mut data.expn_data[self.0 as usize].expn_info;\n-            assert!(old_info.is_none(), \"expansion info is reset for an expansion ID\");\n-            *old_info = Some(info);\n+            let old_expn_data = &mut data.expn_data[self.0 as usize];\n+            assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n+            *old_expn_data = Some(expn_data);\n         })\n     }\n \n@@ -139,12 +124,9 @@ impl ExpnId {\n     #[inline]\n     pub fn looks_like_proc_macro_derive(self) -> bool {\n         HygieneData::with(|data| {\n-            if data.default_transparency(self) == Transparency::Opaque {\n-                if let Some(expn_info) = data.expn_info(self) {\n-                    if let ExpnKind::Macro(MacroKind::Derive, _) = expn_info.kind {\n-                        return true;\n-                    }\n-                }\n+            let expn_data = data.expn_data(self);\n+            if let ExpnKind::Macro(MacroKind::Derive, _) = expn_data.kind {\n+                return expn_data.default_transparency == Transparency::Opaque;\n             }\n             false\n         })\n@@ -153,18 +135,18 @@ impl ExpnId {\n \n #[derive(Debug)]\n crate struct HygieneData {\n-    expn_data: Vec<InternalExpnData>,\n+    /// Each expansion should have an associated expansion data, but sometimes there's a delay\n+    /// between creation of an expansion ID and obtaining its data (e.g. macros are collected\n+    /// first and then resolved later), so we use an `Option` here.\n+    expn_data: Vec<Option<ExpnData>>,\n     syntax_context_data: Vec<SyntaxContextData>,\n     syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n }\n \n impl HygieneData {\n     crate fn new(edition: Edition) -> Self {\n         HygieneData {\n-            expn_data: vec![InternalExpnData {\n-                parent: ExpnId::root(),\n-                expn_info: Some(ExpnInfo::default(ExpnKind::Root, DUMMY_SP, edition)),\n-            }],\n+            expn_data: vec![Some(ExpnData::default(ExpnKind::Root, DUMMY_SP, edition))],\n             syntax_context_data: vec![SyntaxContextData {\n                 outer_expn: ExpnId::root(),\n                 outer_transparency: Transparency::Opaque,\n@@ -181,43 +163,26 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn fresh_expn(&mut self, parent: ExpnId, expn_info: Option<ExpnInfo>) -> ExpnId {\n-        self.expn_data.push(InternalExpnData { parent, expn_info });\n+    fn fresh_expn(&mut self, expn_data: Option<ExpnData>) -> ExpnId {\n+        self.expn_data.push(expn_data);\n         ExpnId(self.expn_data.len() as u32 - 1)\n     }\n \n-    fn parent_expn(&self, expn_id: ExpnId) -> ExpnId {\n-        self.expn_data[expn_id.0 as usize].parent\n-    }\n-\n-    fn expn_info(&self, expn_id: ExpnId) -> Option<&ExpnInfo> {\n-        if expn_id != ExpnId::root() {\n-            Some(self.expn_data[expn_id.0 as usize].expn_info.as_ref()\n-                     .expect(\"no expansion info for an expansion ID\"))\n-        } else {\n-            // FIXME: Some code relies on `expn_info().is_none()` meaning \"no expansion\".\n-            // Introduce a method for checking for \"no expansion\" instead and always return\n-            // `ExpnInfo` from this function instead of the `Option`.\n-            None\n-        }\n+    fn expn_data(&self, expn_id: ExpnId) -> &ExpnData {\n+        self.expn_data[expn_id.0 as usize].as_ref()\n+            .expect(\"no expansion data for an expansion ID\")\n     }\n \n     fn is_descendant_of(&self, mut expn_id: ExpnId, ancestor: ExpnId) -> bool {\n         while expn_id != ancestor {\n             if expn_id == ExpnId::root() {\n                 return false;\n             }\n-            expn_id = self.parent_expn(expn_id);\n+            expn_id = self.expn_data(expn_id).parent;\n         }\n         true\n     }\n \n-    fn default_transparency(&self, expn_id: ExpnId) -> Transparency {\n-        self.expn_info(expn_id).map_or(\n-            Transparency::SemiTransparent, |einfo| einfo.default_transparency\n-        )\n-    }\n-\n     fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque\n     }\n@@ -246,7 +211,7 @@ impl HygieneData {\n \n     fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n         let mut marks = Vec::new();\n-        while ctxt != SyntaxContext::empty() {\n+        while ctxt != SyntaxContext::root() {\n             marks.push((self.outer_expn(ctxt), self.outer_transparency(ctxt)));\n             ctxt = self.parent_ctxt(ctxt);\n         }\n@@ -255,12 +220,8 @@ impl HygieneData {\n     }\n \n     fn walk_chain(&self, mut span: Span, to: SyntaxContext) -> Span {\n-        while span.ctxt() != crate::NO_EXPANSION && span.ctxt() != to {\n-            if let Some(info) = self.expn_info(self.outer_expn(span.ctxt())) {\n-                span = info.call_site;\n-            } else {\n-                break;\n-            }\n+        while span.from_expansion() && span.ctxt() != to {\n+            span = self.expn_data(self.outer_expn(span.ctxt())).call_site;\n         }\n         span\n     }\n@@ -275,7 +236,9 @@ impl HygieneData {\n \n     fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n         assert_ne!(expn_id, ExpnId::root());\n-        self.apply_mark_with_transparency(ctxt, expn_id, self.default_transparency(expn_id))\n+        self.apply_mark_with_transparency(\n+            ctxt, expn_id, self.expn_data(expn_id).default_transparency\n+        )\n     }\n \n     fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, expn_id: ExpnId,\n@@ -285,15 +248,14 @@ impl HygieneData {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n-        let call_site_ctxt =\n-            self.expn_info(expn_id).map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n+        let call_site_ctxt = self.expn_data(expn_id).call_site.ctxt();\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             self.modern(call_site_ctxt)\n         } else {\n             self.modern_and_legacy(call_site_ctxt)\n         };\n \n-        if call_site_ctxt == SyntaxContext::empty() {\n+        if call_site_ctxt == SyntaxContext::root() {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n@@ -400,7 +362,7 @@ pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symb\n \n impl SyntaxContext {\n     #[inline]\n-    pub const fn empty() -> Self {\n+    pub const fn root() -> Self {\n         SyntaxContext(0)\n     }\n \n@@ -578,20 +540,20 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.outer_expn(self))\n     }\n \n-    /// `ctxt.outer_expn_info()` is equivalent to but faster than\n-    /// `ctxt.outer_expn().expn_info()`.\n+    /// `ctxt.outer_expn_data()` is equivalent to but faster than\n+    /// `ctxt.outer_expn().expn_data()`.\n     #[inline]\n-    pub fn outer_expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(data.outer_expn(self)).cloned())\n+    pub fn outer_expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.expn_data(data.outer_expn(self)).clone())\n     }\n \n-    /// `ctxt.outer_expn_with_info()` is equivalent to but faster than\n-    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_info()) }`.\n+    /// `ctxt.outer_expn_with_data()` is equivalent to but faster than\n+    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_data()) }`.\n     #[inline]\n-    pub fn outer_expn_with_info(self) -> (ExpnId, Option<ExpnInfo>) {\n+    pub fn outer_expn_with_data(self) -> (ExpnId, ExpnData) {\n         HygieneData::with(|data| {\n             let outer = data.outer_expn(self);\n-            (outer, data.expn_info(outer).cloned())\n+            (outer, data.expn_data(outer).clone())\n         })\n     }\n \n@@ -612,38 +574,42 @@ impl Span {\n     /// other compiler-generated code to set per-span properties like allowed unstable features.\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n-    pub fn fresh_expansion(self, parent: ExpnId, expn_info: ExpnInfo) -> Span {\n+    pub fn fresh_expansion(self, expn_data: ExpnData) -> Span {\n         HygieneData::with(|data| {\n-            let expn_id = data.fresh_expn(parent, Some(expn_info));\n-            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), expn_id))\n+            let expn_id = data.fresh_expn(Some(expn_data));\n+            self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id))\n         })\n     }\n }\n \n /// A subset of properties from both macro definition and macro call available through global data.\n /// Avoid using this if you have access to the original definition or call structures.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct ExpnInfo {\n+pub struct ExpnData {\n     // --- The part unique to each expansion.\n+    /// The kind of this expansion - macro or compiler desugaring.\n+    pub kind: ExpnKind,\n+    /// The expansion that produced this expansion.\n+    pub parent: ExpnId,\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`\n     ///\n     /// This may recursively refer to other macro invocations, e.g., if\n     /// `foo!()` invoked `bar!()` internally, and there was an\n     /// expression inside `bar!`; the call_site of the expression in\n     /// the expansion would point to the `bar!` invocation; that\n-    /// call_site span would have its own ExpnInfo, with the call_site\n+    /// call_site span would have its own ExpnData, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n-    /// The kind of this expansion - macro or compiler desugaring.\n-    pub kind: ExpnKind,\n \n     // --- The part specific to the macro/desugaring definition.\n-    // --- FIXME: Share it between expansions with the same definition.\n+    // --- It may be reasonable to share this part between expansions with the same definition,\n+    // --- but such sharing is known to bring some minor inconveniences without also bringing\n+    // --- noticeable perf improvements (PR #62898).\n     /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Span,\n-    /// Transparency used by `apply_mark` for the expansion with this expansion info by default.\n+    /// Transparency used by `apply_mark` for the expansion with this expansion data by default.\n     pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n@@ -659,12 +625,13 @@ pub struct ExpnInfo {\n     pub edition: Edition,\n }\n \n-impl ExpnInfo {\n-    /// Constructs an expansion info with default properties.\n-    pub fn default(kind: ExpnKind, call_site: Span, edition: Edition) -> ExpnInfo {\n-        ExpnInfo {\n-            call_site,\n+impl ExpnData {\n+    /// Constructs expansion data with default properties.\n+    pub fn default(kind: ExpnKind, call_site: Span, edition: Edition) -> ExpnData {\n+        ExpnData {\n             kind,\n+            parent: ExpnId::root(),\n+            call_site,\n             def_site: DUMMY_SP,\n             default_transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n@@ -675,12 +642,17 @@ impl ExpnInfo {\n     }\n \n     pub fn allow_unstable(kind: ExpnKind, call_site: Span, edition: Edition,\n-                          allow_internal_unstable: Lrc<[Symbol]>) -> ExpnInfo {\n-        ExpnInfo {\n+                          allow_internal_unstable: Lrc<[Symbol]>) -> ExpnData {\n+        ExpnData {\n             allow_internal_unstable: Some(allow_internal_unstable),\n-            ..ExpnInfo::default(kind, call_site, edition)\n+            ..ExpnData::default(kind, call_site, edition)\n         }\n     }\n+\n+    #[inline]\n+    pub fn is_root(&self) -> bool {\n+        if let ExpnKind::Root = self.kind { true } else { false }\n+    }\n }\n \n /// Expansion kind.\n@@ -767,14 +739,14 @@ impl DesugaringKind {\n     }\n }\n \n-impl Encodable for SyntaxContext {\n+impl Encodable for ExpnId {\n     fn encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n         Ok(()) // FIXME(jseyfried) intercrate hygiene\n     }\n }\n \n-impl Decodable for SyntaxContext {\n-    fn decode<D: Decoder>(_: &mut D) -> Result<SyntaxContext, D::Error> {\n-        Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n+impl Decodable for ExpnId {\n+    fn decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n+        Ok(ExpnId::root()) // FIXME(jseyfried) intercrate hygiene\n     }\n }"}, {"sha": "aa36fe27d8ec4dddd786884a44cf6467cce6bae3", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -21,7 +21,7 @@ use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n-pub use hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind, MacroKind, DesugaringKind};\n+pub use hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind, MacroKind, DesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -49,7 +49,6 @@ pub struct Globals {\n     symbol_interner: Lock<symbol::Interner>,\n     span_interner: Lock<span_encoding::SpanInterner>,\n     hygiene_data: Lock<hygiene::HygieneData>,\n-    edition: Edition,\n }\n \n impl Globals {\n@@ -58,7 +57,6 @@ impl Globals {\n             symbol_interner: Lock::new(symbol::Interner::fresh()),\n             span_interner: Lock::new(span_encoding::SpanInterner::default()),\n             hygiene_data: Lock::new(hygiene::HygieneData::new(edition)),\n-            edition,\n         }\n     }\n }\n@@ -288,6 +286,17 @@ impl Span {\n         span.lo.0 == 0 && span.hi.0 == 0\n     }\n \n+    /// Returns `true` if this span comes from a macro or desugaring.\n+    #[inline]\n+    pub fn from_expansion(self) -> bool {\n+        self.ctxt() != SyntaxContext::root()\n+    }\n+\n+    #[inline]\n+    pub fn with_root_ctxt(lo: BytePos, hi: BytePos) -> Span {\n+        Span::new(lo, hi, SyntaxContext::root())\n+    }\n+\n     /// Returns a new span representing an empty span at the beginning of this span\n     #[inline]\n     pub fn shrink_to_lo(self) -> Span {\n@@ -344,20 +353,20 @@ impl Span {\n     /// Returns the source span -- this is either the supplied span, or the span for\n     /// the macro callsite that expanded to it.\n     pub fn source_callsite(self) -> Span {\n-        self.ctxt().outer_expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { expn_data.call_site.source_callsite() } else { self }\n     }\n \n     /// The `Span` for the tokens in the previous macro expansion from which `self` was generated,\n     /// if any.\n     pub fn parent(self) -> Option<Span> {\n-        self.ctxt().outer_expn_info().map(|i| i.call_site)\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { Some(expn_data.call_site) } else { None }\n     }\n \n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n-        self.ctxt().outer_expn_info().map_or_else(|| {\n-            Edition::from_session()\n-        }, |einfo| einfo.edition)\n+        self.ctxt().outer_expn_data().edition\n     }\n \n     #[inline]\n@@ -373,72 +382,63 @@ impl Span {\n     /// Returns the source callee.\n     ///\n     /// Returns `None` if the supplied span has no expansion trace,\n-    /// else returns the `ExpnInfo` for the macro definition\n+    /// else returns the `ExpnData` for the macro definition\n     /// corresponding to the source callsite.\n-    pub fn source_callee(self) -> Option<ExpnInfo> {\n-        fn source_callee(info: ExpnInfo) -> ExpnInfo {\n-            match info.call_site.ctxt().outer_expn_info() {\n-                Some(info) => source_callee(info),\n-                None => info,\n-            }\n+    pub fn source_callee(self) -> Option<ExpnData> {\n+        fn source_callee(expn_data: ExpnData) -> ExpnData {\n+            let next_expn_data = expn_data.call_site.ctxt().outer_expn_data();\n+            if !next_expn_data.is_root() { source_callee(next_expn_data) } else { expn_data }\n         }\n-        self.ctxt().outer_expn_info().map(source_callee)\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { Some(source_callee(expn_data)) } else { None }\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n     pub fn allows_unstable(&self, feature: Symbol) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => info\n-                .allow_internal_unstable\n-                .map_or(false, |features| features.iter().any(|&f|\n-                    f == feature || f == sym::allow_internal_unstable_backcompat_hack\n-                )),\n-            None => false,\n-        }\n+        self.ctxt().outer_expn_data().allow_internal_unstable.map_or(false, |features| {\n+            features.iter().any(|&f| {\n+                f == feature || f == sym::allow_internal_unstable_backcompat_hack\n+            })\n+        })\n     }\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`.\n     pub fn is_desugaring(&self, kind: DesugaringKind) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => match info.kind {\n-                ExpnKind::Desugaring(k) => k == kind,\n-                _ => false,\n-            },\n-            None => false,\n+        match self.ctxt().outer_expn_data().kind {\n+            ExpnKind::Desugaring(k) => k == kind,\n+            _ => false,\n         }\n     }\n \n     /// Returns the compiler desugaring that created this span, or `None`\n     /// if this span is not from a desugaring.\n     pub fn desugaring_kind(&self) -> Option<DesugaringKind> {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => match info.kind {\n-                ExpnKind::Desugaring(k) => Some(k),\n-                _ => None\n-            },\n-            None => None\n+        match self.ctxt().outer_expn_data().kind {\n+            ExpnKind::Desugaring(k) => Some(k),\n+            _ => None\n         }\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `unsafe`\n     /// can be used without triggering the `unsafe_code` lint\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(&self) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => info.allow_internal_unsafe,\n-            None => false,\n-        }\n+        self.ctxt().outer_expn_data().allow_internal_unsafe\n     }\n \n     pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];\n-        while let Some(info) = self.ctxt().outer_expn_info() {\n+        loop {\n+            let expn_data = self.ctxt().outer_expn_data();\n+            if expn_data.is_root() {\n+                break;\n+            }\n             // Don't print recursive invocations.\n-            if !info.call_site.source_equal(&prev_span) {\n-                let (pre, post) = match info.kind {\n+            if !expn_data.call_site.source_equal(&prev_span) {\n+                let (pre, post) = match expn_data.kind {\n                     ExpnKind::Root => break,\n                     ExpnKind::Desugaring(..) => (\"desugaring of \", \"\"),\n                     ExpnKind::Macro(macro_kind, _) => match macro_kind {\n@@ -448,14 +448,14 @@ impl Span {\n                     }\n                 };\n                 result.push(MacroBacktrace {\n-                    call_site: info.call_site,\n-                    macro_decl_name: format!(\"{}{}{}\", pre, info.kind.descr(), post),\n-                    def_site_span: info.def_site,\n+                    call_site: expn_data.call_site,\n+                    macro_decl_name: format!(\"{}{}{}\", pre, expn_data.kind.descr(), post),\n+                    def_site_span: expn_data.def_site,\n                 });\n             }\n \n             prev_span = self;\n-            self = info.call_site;\n+            self = expn_data.call_site;\n         }\n         result\n     }\n@@ -468,9 +468,9 @@ impl Span {\n         // Return the macro span on its own to avoid weird diagnostic output. It is preferable to\n         // have an incomplete span than a completely nonsensical one.\n         if span_data.ctxt != end_data.ctxt {\n-            if span_data.ctxt == SyntaxContext::empty() {\n+            if span_data.ctxt == SyntaxContext::root() {\n                 return end;\n-            } else if end_data.ctxt == SyntaxContext::empty() {\n+            } else if end_data.ctxt == SyntaxContext::root() {\n                 return self;\n             }\n             // Both spans fall within a macro.\n@@ -479,7 +479,7 @@ impl Span {\n         Span::new(\n             cmp::min(span_data.lo, end_data.lo),\n             cmp::max(span_data.hi, end_data.hi),\n-            if span_data.ctxt == SyntaxContext::empty() { end_data.ctxt } else { span_data.ctxt },\n+            if span_data.ctxt == SyntaxContext::root() { end_data.ctxt } else { span_data.ctxt },\n         )\n     }\n \n@@ -490,7 +490,7 @@ impl Span {\n         Span::new(\n             span.hi,\n             end.lo,\n-            if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n+            if end.ctxt == SyntaxContext::root() { end.ctxt } else { span.ctxt },\n         )\n     }\n \n@@ -501,7 +501,7 @@ impl Span {\n         Span::new(\n             span.lo,\n             end.lo,\n-            if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n+            if end.ctxt == SyntaxContext::root() { end.ctxt } else { span.ctxt },\n         )\n     }\n \n@@ -611,7 +611,7 @@ impl rustc_serialize::UseSpecializedDecodable for Span {\n         d.read_struct(\"Span\", 2, |d| {\n             let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n             let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n-            Ok(Span::new(lo, hi, NO_EXPANSION))\n+            Ok(Span::with_root_ctxt(lo, hi))\n         })\n     }\n }\n@@ -755,8 +755,6 @@ impl From<Vec<Span>> for MultiSpan {\n     }\n }\n \n-pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n-\n /// Identifies an offset of a multi-byte character in a `SourceFile`.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {"}, {"sha": "bed898f10b432ee64e301b8c09231d2cb99298da", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -8,13 +8,13 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::newtype_index;\n use rustc_macros::symbols;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n \n use std::cmp::{PartialEq, Ordering, PartialOrd, Ord};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::str;\n \n-use crate::hygiene::SyntaxContext;\n use crate::{Span, DUMMY_SP, GLOBALS};\n \n #[cfg(test)]\n@@ -610,7 +610,6 @@ symbols! {\n         rust_eh_personality,\n         rust_eh_unwind_resume,\n         rust_oom,\n-        __rust_unstable_column,\n         rvalue_static_promotion,\n         sanitizer_runtime,\n         _Self,\n@@ -745,25 +744,25 @@ impl Ident {\n         Ident { name, span }\n     }\n \n-    /// Constructs a new identifier with an empty syntax context.\n+    /// Constructs a new identifier with a dummy span.\n     #[inline]\n-    pub const fn with_empty_ctxt(name: Symbol) -> Ident {\n+    pub const fn with_dummy_span(name: Symbol) -> Ident {\n         Ident::new(name, DUMMY_SP)\n     }\n \n     #[inline]\n     pub fn invalid() -> Ident {\n-        Ident::with_empty_ctxt(kw::Invalid)\n+        Ident::with_dummy_span(kw::Invalid)\n     }\n \n     /// Maps an interned string to an identifier with an empty syntax context.\n     pub fn from_interned_str(string: InternedString) -> Ident {\n-        Ident::with_empty_ctxt(string.as_symbol())\n+        Ident::with_dummy_span(string.as_symbol())\n     }\n \n     /// Maps a string to an identifier with an empty span.\n     pub fn from_str(string: &str) -> Ident {\n-        Ident::with_empty_ctxt(Symbol::intern(string))\n+        Ident::with_dummy_span(Symbol::intern(string))\n     }\n \n     /// Maps a string and a span to an identifier.\n@@ -849,28 +848,9 @@ impl fmt::Display for Ident {\n     }\n }\n \n-impl Encodable for Ident {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        if self.span.ctxt().modern() == SyntaxContext::empty() {\n-            s.emit_str(&self.as_str())\n-        } else { // FIXME(jseyfried): intercrate hygiene\n-            let mut string = \"#\".to_owned();\n-            string.push_str(&self.as_str());\n-            s.emit_str(&string)\n-        }\n-    }\n-}\n+impl UseSpecializedEncodable for Ident {}\n \n-impl Decodable for Ident {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        let string = d.read_str()?;\n-        Ok(if !string.starts_with('#') {\n-            Ident::from_str(&string)\n-        } else { // FIXME(jseyfried): intercrate hygiene\n-            Ident::from_str(&string[1..]).gensym()\n-        })\n-    }\n-}\n+impl UseSpecializedDecodable for Ident {}\n \n /// A symbol is an interned or gensymed string. A gensym is a symbol that is\n /// never equal to any other symbol."}, {"sha": "f10df8c85ba0a66e85acdd72d65b1b3a7e54ec0f", "filename": "src/libunwind/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibunwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/51dcdcfd94450851d64c6d7c4eeab41c3e61f546/src%2Flibunwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2FCargo.toml?ref=51dcdcfd94450851d64c6d7c4eeab41c3e61f546", "patch": "@@ -22,7 +22,7 @@ compiler_builtins = \"0.1.0\"\n cfg-if = \"0.1.8\"\n \n [build-dependencies]\n-cc = { optional = true, version = \"1.0.1\" }\n+cc = { version = \"1.0.1\" }\n \n [features]\n-llvm-libunwind = [\"cc\"]\n+llvm-libunwind = []"}]}