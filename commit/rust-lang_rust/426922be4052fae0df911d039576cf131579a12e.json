{"sha": "426922be4052fae0df911d039576cf131579a12e", "node_id": "C_kwDOAAsO6NoAKDQyNjkyMmJlNDA1MmZhZTBkZjkxMWQwMzk1NzZjZjEzMTU3OWExMmU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-13T19:35:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-13T19:35:55Z"}, "message": "Rollup merge of #97960 - RalfJung:offset-from, r=oli-obk\n\ninterpret: unify offset_from check with offset check\n\n`offset` does the check with a single `check_ptr_access` call while `offset_from` used two calls. Make them both just one one call.\n\nI originally intended to actually factor this into a common function, but I am no longer sure if that makes a lot of sense... the two functions start with pretty different precondition (e.g. `offset` *knows* that the 2nd pointer has the same provenance).\n\nI also reworded the UB messages a little. Saying it \"cannot\" do something is not how we usually phrase UB (as far as I know). Instead it's not *allowed* to do that.\n\nr? ``````@oli-obk``````", "tree": {"sha": "0280d5cd265a5ecc943ef0c5dfead65994a8863e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0280d5cd265a5ecc943ef0c5dfead65994a8863e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/426922be4052fae0df911d039576cf131579a12e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJip5GbCRBK7hj4Ov3rIwAAu+UIAGGYyalOqIrFTqses5kCAH26\npOoYzo94/XeOpK34e51IYmdSrBOUQjP8Nc1qfSrz6HR+0YHEendpKEgKKc6f3GHf\nBcJ82vjemlShIZCnLX8EcJWQz7tKbF7+dgIAF7VWfgQauYGAOQR/B4Apg0NFvJhP\nr46P0kAQMNvmytL5PXYFtohVtBcq/maZQ0LYy0ljfrpc4k9tiULArFX8gD6h6vEA\noGk1Nit35FYVofyNSbSOz7mWHTOWyixM0EwNkjwrMtg+jFRqMvfS57uvABwbJRCc\nUkK/SxNg8QZMTlUMpUGmSdrzvGWny2IQ+wA5LU3LjILLdpblsdOzfoHcOZLCqKM=\n=nuOn\n-----END PGP SIGNATURE-----\n", "payload": "tree 0280d5cd265a5ecc943ef0c5dfead65994a8863e\nparent 89249b199edb8454fa566d9cd12e1ae770112a29\nparent e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1655148955 +0200\ncommitter GitHub <noreply@github.com> 1655148955 +0200\n\nRollup merge of #97960 - RalfJung:offset-from, r=oli-obk\n\ninterpret: unify offset_from check with offset check\n\n`offset` does the check with a single `check_ptr_access` call while `offset_from` used two calls. Make them both just one one call.\n\nI originally intended to actually factor this into a common function, but I am no longer sure if that makes a lot of sense... the two functions start with pretty different precondition (e.g. `offset` *knows* that the 2nd pointer has the same provenance).\n\nI also reworded the UB messages a little. Saying it \"cannot\" do something is not how we usually phrase UB (as far as I know). Instead it's not *allowed* to do that.\n\nr? ``````@oli-obk``````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/426922be4052fae0df911d039576cf131579a12e", "html_url": "https://github.com/rust-lang/rust/commit/426922be4052fae0df911d039576cf131579a12e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/426922be4052fae0df911d039576cf131579a12e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89249b199edb8454fa566d9cd12e1ae770112a29", "url": "https://api.github.com/repos/rust-lang/rust/commits/89249b199edb8454fa566d9cd12e1ae770112a29", "html_url": "https://github.com/rust-lang/rust/commit/89249b199edb8454fa566d9cd12e1ae770112a29"}, {"sha": "e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01", "html_url": "https://github.com/rust-lang/rust/commit/e5245ef1eb2bacb07f7e2473b845d86c3bdd1b01"}], "stats": {"total": 171, "additions": 87, "deletions": 84}, "files": [{"sha": "e51c51cf45e5ec25cd6fea7db0b632ed55ee3db6", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/426922be4052fae0df911d039576cf131579a12e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426922be4052fae0df911d039576cf131579a12e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=426922be4052fae0df911d039576cf131579a12e", "patch": "@@ -313,78 +313,82 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let a = self.read_pointer(&args[0])?;\n                 let b = self.read_pointer(&args[1])?;\n \n-                // Special case: if both scalars are *equal integers*\n-                // and not null, we pretend there is an allocation of size 0 right there,\n-                // and their offset is 0. (There's never a valid object at null, making it an\n-                // exception from the exception.)\n-                // This is the dual to the special exception for offset-by-0\n-                // in the inbounds pointer offset operation (see `ptr_offset_inbounds` below).\n-                match (self.ptr_try_get_alloc_id(a), self.ptr_try_get_alloc_id(b)) {\n-                    (Err(a), Err(b)) if a == b && a != 0 => {\n-                        // Both are the same non-null integer.\n-                        self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;\n-                    }\n-                    (Err(offset), _) | (_, Err(offset)) => {\n-                        throw_ub!(DanglingIntPointer(offset, CheckInAllocMsg::OffsetFromTest));\n-                    }\n-                    (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n-                        // Both are pointers. They must be into the same allocation.\n-                        if a_alloc_id != b_alloc_id {\n-                            throw_ub_format!(\n-                                \"{} cannot compute offset of pointers into different allocations.\",\n-                                intrinsic_name,\n-                            );\n+                let usize_layout = self.layout_of(self.tcx.types.usize)?;\n+                let isize_layout = self.layout_of(self.tcx.types.isize)?;\n+\n+                // Get offsets for both that are at least relative to the same base.\n+                let (a_offset, b_offset) =\n+                    match (self.ptr_try_get_alloc_id(a), self.ptr_try_get_alloc_id(b)) {\n+                        (Err(a), Err(b)) => {\n+                            // Neither poiner points to an allocation.\n+                            // If these are inequal or null, this *will* fail the deref check below.\n+                            (a, b)\n                         }\n-                        // And they must both be valid for zero-sized accesses (\"in-bounds or one past the end\").\n-                        self.check_ptr_access_align(\n-                            a,\n-                            Size::ZERO,\n-                            Align::ONE,\n-                            CheckInAllocMsg::OffsetFromTest,\n-                        )?;\n-                        self.check_ptr_access_align(\n-                            b,\n-                            Size::ZERO,\n-                            Align::ONE,\n-                            CheckInAllocMsg::OffsetFromTest,\n-                        )?;\n-\n-                        if intrinsic_name == sym::ptr_offset_from_unsigned && a_offset < b_offset {\n+                        (Err(_), _) | (_, Err(_)) => {\n+                            // We managed to find a valid allocation for one pointer, but not the other.\n+                            // That means they are definitely not pointing to the same allocation.\n                             throw_ub_format!(\n-                                \"{} cannot compute a negative offset, but {} < {}\",\n-                                intrinsic_name,\n-                                a_offset.bytes(),\n-                                b_offset.bytes(),\n+                                \"{} called on pointers into different allocations\",\n+                                intrinsic_name\n                             );\n                         }\n-\n-                        // Compute offset.\n-                        let usize_layout = self.layout_of(self.tcx.types.usize)?;\n-                        let isize_layout = self.layout_of(self.tcx.types.isize)?;\n-                        let ret_layout = if intrinsic_name == sym::ptr_offset_from {\n-                            isize_layout\n-                        } else {\n-                            usize_layout\n-                        };\n-\n-                        // The subtraction is always done in `isize` to enforce\n-                        // the \"no more than `isize::MAX` apart\" requirement.\n-                        let a_offset = ImmTy::from_uint(a_offset.bytes(), isize_layout);\n-                        let b_offset = ImmTy::from_uint(b_offset.bytes(), isize_layout);\n-                        let (val, overflowed, _ty) =\n-                            self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n-                        if overflowed {\n-                            throw_ub_format!(\"Pointers were too far apart for {}\", intrinsic_name);\n+                        (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n+                            // Found allocation for both. They must be into the same allocation.\n+                            if a_alloc_id != b_alloc_id {\n+                                throw_ub_format!(\n+                                    \"{} called on pointers into different allocations\",\n+                                    intrinsic_name\n+                                );\n+                            }\n+                            // Use these offsets for distance calculation.\n+                            (a_offset.bytes(), b_offset.bytes())\n                         }\n-\n-                        let pointee_layout = self.layout_of(substs.type_at(0))?;\n-                        // This re-interprets an isize at ret_layout, but we already checked\n-                        // that if ret_layout is usize, then the result must be non-negative.\n-                        let val = ImmTy::from_scalar(val, ret_layout);\n-                        let size = ImmTy::from_int(pointee_layout.size.bytes(), ret_layout);\n-                        self.exact_div(&val, &size, dest)?;\n+                    };\n+\n+                // Compute distance.\n+                let distance = {\n+                    // The subtraction is always done in `isize` to enforce\n+                    // the \"no more than `isize::MAX` apart\" requirement.\n+                    let a_offset = ImmTy::from_uint(a_offset, isize_layout);\n+                    let b_offset = ImmTy::from_uint(b_offset, isize_layout);\n+                    let (val, overflowed, _ty) =\n+                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n+                    if overflowed {\n+                        throw_ub_format!(\"pointers were too far apart for {}\", intrinsic_name);\n                     }\n+                    val.to_machine_isize(self)?\n+                };\n+\n+                // Check that the range between them is dereferenceable (\"in-bounds or one past the\n+                // end of the same allocation\"). This is like the check in ptr_offset_inbounds.\n+                let min_ptr = if distance >= 0 { b } else { a };\n+                self.check_ptr_access_align(\n+                    min_ptr,\n+                    Size::from_bytes(distance.unsigned_abs()),\n+                    Align::ONE,\n+                    CheckInAllocMsg::OffsetFromTest,\n+                )?;\n+\n+                if intrinsic_name == sym::ptr_offset_from_unsigned && distance < 0 {\n+                    throw_ub_format!(\n+                        \"{} called when first pointer has smaller offset than second: {} < {}\",\n+                        intrinsic_name,\n+                        a_offset,\n+                        b_offset,\n+                    );\n                 }\n+\n+                // Perform division by size to compute return value.\n+                let ret_layout = if intrinsic_name == sym::ptr_offset_from_unsigned {\n+                    usize_layout\n+                } else {\n+                    isize_layout\n+                };\n+                let pointee_layout = self.layout_of(substs.type_at(0))?;\n+                // If ret_layout is unsigned, we checked that so is the distance, so we are good.\n+                let val = ImmTy::from_int(distance, ret_layout);\n+                let size = ImmTy::from_int(pointee_layout.size.bytes(), ret_layout);\n+                self.exact_div(&val, &size, dest)?;\n             }\n \n             sym::transmute => {\n@@ -575,11 +579,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // memory between these pointers must be accessible. Note that we do not require the\n         // pointers to be properly aligned (unlike a read/write operation).\n         let min_ptr = if offset_bytes >= 0 { ptr } else { offset_ptr };\n-        let size = offset_bytes.unsigned_abs();\n         // This call handles checking for integer/null pointers.\n         self.check_ptr_access_align(\n             min_ptr,\n-            Size::from_bytes(size),\n+            Size::from_bytes(offset_bytes.unsigned_abs()),\n             Align::ONE,\n             CheckInAllocMsg::PointerArithmeticTest,\n         )?;"}, {"sha": "023d5ea34d871ef4bcee985752798d9e14af152f", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/426922be4052fae0df911d039576cf131579a12e/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426922be4052fae0df911d039576cf131579a12e/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=426922be4052fae0df911d039576cf131579a12e", "patch": "@@ -243,7 +243,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  ptr_offset_from_unsigned called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -262,7 +262,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  ptr_offset_from_unsigned called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL"}, {"sha": "ed89c253d532c6edb184275f30464aa993d0b667", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/426922be4052fae0df911d039576cf131579a12e/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426922be4052fae0df911d039576cf131579a12e/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=426922be4052fae0df911d039576cf131579a12e", "patch": "@@ -243,7 +243,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  ptr_offset_from_unsigned called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -262,7 +262,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  ptr_offset_from_unsigned called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL"}, {"sha": "10e368ba13396ce486a875ac9ebeb6e11e07f5ee", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/426922be4052fae0df911d039576cf131579a12e/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426922be4052fae0df911d039576cf131579a12e/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=426922be4052fae0df911d039576cf131579a12e", "patch": "@@ -15,7 +15,7 @@ pub const DIFFERENT_ALLOC: usize = {\n     let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n     let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) }; //~ERROR evaluation of constant value failed\n-    //~| ptr_offset_from cannot compute offset of pointers into different allocations.\n+    //~| pointers into different allocations\n     offset as usize\n };\n \n@@ -41,7 +41,7 @@ pub const DIFFERENT_INT: isize = { // offset_from with two different integers: l\n     let ptr1 = 8 as *const u8;\n     let ptr2 = 16 as *const u8;\n     unsafe { ptr_offset_from(ptr2, ptr1) } //~ERROR evaluation of constant value failed\n-    //~| 0x10 is not a valid pointer\n+    //~| 0x8 is not a valid pointer\n };\n \n const OUT_OF_BOUNDS_1: isize = {\n@@ -50,7 +50,7 @@ const OUT_OF_BOUNDS_1: isize = {\n     let end_ptr = (start_ptr).wrapping_add(length);\n     // First ptr is out of bounds\n     unsafe { ptr_offset_from(end_ptr, start_ptr) } //~ERROR evaluation of constant value failed\n-    //~| pointer at offset 10 is out-of-bounds\n+    //~| pointer to 10 bytes starting at offset 0 is out-of-bounds\n };\n \n const OUT_OF_BOUNDS_2: isize = {\n@@ -59,7 +59,7 @@ const OUT_OF_BOUNDS_2: isize = {\n     let end_ptr = (start_ptr).wrapping_add(length);\n     // Second ptr is out of bounds\n     unsafe { ptr_offset_from(start_ptr, end_ptr) } //~ERROR evaluation of constant value failed\n-    //~| pointer at offset 10 is out-of-bounds\n+    //~| pointer to 10 bytes starting at offset 0 is out-of-bounds\n };\n \n const OUT_OF_BOUNDS_SAME: isize = {\n@@ -76,15 +76,15 @@ pub const DIFFERENT_ALLOC_UNSIGNED: usize = {\n     let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n     let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n     let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) }; //~ERROR evaluation of constant value failed\n-    //~| ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+    //~| pointers into different allocations\n     offset as usize\n };\n \n const WRONG_ORDER_UNSIGNED: usize = {\n     let a = ['a', 'b', 'c'];\n     let p = a.as_ptr();\n     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) } //~ERROR evaluation of constant value failed\n-    //~| cannot compute a negative offset, but 0 < 8\n+    //~| first pointer has smaller offset than second: 0 < 8\n };\n \n fn main() {}"}, {"sha": "eb7f1d7a6b25283cf4e036912fe7c0ad9b11681e", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/426922be4052fae0df911d039576cf131579a12e/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/426922be4052fae0df911d039576cf131579a12e/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=426922be4052fae0df911d039576cf131579a12e", "patch": "@@ -2,15 +2,15 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:17:27\n    |\n LL |     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from cannot compute offset of pointers into different allocations.\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from called on pointers into different allocations\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  out-of-bounds offset_from: 0x2a is not a valid pointer\n+   |                  ptr_offset_from called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $DIR/offset_from_ub.rs:23:14\n@@ -34,19 +34,19 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:43:14\n    |\n LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x10 is not a valid pointer\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x8 is not a valid pointer\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:52:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:61:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:69:14\n@@ -58,13 +58,13 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:78:27\n    |\n LL |     let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned called on pointers into different allocations\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:86:14\n    |\n LL |     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned cannot compute a negative offset, but 0 < 8\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned called when first pointer has smaller offset than second: 0 < 8\n \n error: aborting due to 10 previous errors\n "}]}