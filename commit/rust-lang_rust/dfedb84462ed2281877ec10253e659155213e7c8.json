{"sha": "dfedb84462ed2281877ec10253e659155213e7c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZWRiODQ0NjJlZDIyODE4NzdlYzEwMjUzZTY1OTE1NTIxM2U3Yzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-24T17:01:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-24T17:01:28Z"}, "message": "Rollup merge of #72954 - hermitcore:rwlock, r=dtolnay\n\nrevise RwLock for HermitCore\n\n- current version is derived from the wasm implementation\n- increasing the readability of `Condvar`\n- simplify the interface to the libos", "tree": {"sha": "da580062a33dd98d20dd91fc40537236fe4d1edb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da580062a33dd98d20dd91fc40537236fe4d1edb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfedb84462ed2281877ec10253e659155213e7c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGxPoCRBK7hj4Ov3rIwAAdHIIAIqOoaawWnywXBQb0LKRhHmV\nEp72ejHRhF+HG9JJ+VBeyE/KYaWmU4Ix9Rn9cKMn6qzr8diYddY1Ahcat05xEvjL\nXlAtKtm09jrnCKeGBrkA2eveNT6fLa5tZFcwFW4fbVbUU/VURSizyyIxqnnJKOtc\nYKMzcqDhTLdVvt1pl1Lk56MEGIBfSCnbIDYzSi7CY5dDpXW/CmU91OarWqqUR9W1\nXKbonp9GW+4mPT2myRCyUmUUaLhqZexD4/MbgMBrZCXUwIvtNTMnJcLzTsJo+/dW\ngieCL27FguvY5EFtjbkHn8Cv/qG7rS9fAibQMqG2gzaYaLeR1kTc6ZGsXp9Fmfg=\n=RHqd\n-----END PGP SIGNATURE-----\n", "payload": "tree da580062a33dd98d20dd91fc40537236fe4d1edb\nparent cfb6114b2a20e04e3212ed030bc68d23faf8048f\nparent 6925ebdd6051b3827c2978b8b285e49743306ccc\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595610088 -0700\ncommitter GitHub <noreply@github.com> 1595610088 -0700\n\nRollup merge of #72954 - hermitcore:rwlock, r=dtolnay\n\nrevise RwLock for HermitCore\n\n- current version is derived from the wasm implementation\n- increasing the readability of `Condvar`\n- simplify the interface to the libos\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfedb84462ed2281877ec10253e659155213e7c8", "html_url": "https://github.com/rust-lang/rust/commit/dfedb84462ed2281877ec10253e659155213e7c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfedb84462ed2281877ec10253e659155213e7c8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfb6114b2a20e04e3212ed030bc68d23faf8048f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfb6114b2a20e04e3212ed030bc68d23faf8048f", "html_url": "https://github.com/rust-lang/rust/commit/cfb6114b2a20e04e3212ed030bc68d23faf8048f"}, {"sha": "6925ebdd6051b3827c2978b8b285e49743306ccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6925ebdd6051b3827c2978b8b285e49743306ccc", "html_url": "https://github.com/rust-lang/rust/commit/6925ebdd6051b3827c2978b8b285e49743306ccc"}], "stats": {"total": 185, "additions": 142, "deletions": 43}, "files": [{"sha": "d6fb659178764e2e21b736cc74194f9d57cd481e", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfedb84462ed2281877ec10253e659155213e7c8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dfedb84462ed2281877ec10253e659155213e7c8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dfedb84462ed2281877ec10253e659155213e7c8", "patch": "@@ -1242,9 +1242,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.14\"\n+version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9586eedd4ce6b3c498bc3b4dd92fc9f11166aa908a914071953768066c67909\"\n+checksum = \"3deed196b6e7f9e44a2ae8d94225d80302d81208b1bb673fd21fe634645c85a9\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\","}, {"sha": "2c1e71c64c4e5a4d01d7d02890790397d247b0e2", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfedb84462ed2281877ec10253e659155213e7c8/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dfedb84462ed2281877ec10253e659155213e7c8/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=dfedb84462ed2281877ec10253e659155213e7c8", "patch": "@@ -40,7 +40,7 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n-hermit-abi = { version = \"0.1.14\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.1.15\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "52c8c3b17e8262571775b4a41b1ab543fbd78b39", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dfedb84462ed2281877ec10253e659155213e7c8/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfedb84462ed2281877ec10253e659155213e7c8/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=dfedb84462ed2281877ec10253e659155213e7c8", "patch": "@@ -1,60 +1,64 @@\n-use crate::cmp;\n+use crate::ffi::c_void;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sys::hermit::abi;\n use crate::sys::mutex::Mutex;\n use crate::time::Duration;\n \n+// The implementation is inspired by Andrew D. Birrell's paper\n+// \"Implementing Condition Variables with Semaphores\"\n+\n pub struct Condvar {\n-    identifier: usize,\n+    counter: AtomicUsize,\n+    sem1: *const c_void,\n+    sem2: *const c_void,\n }\n \n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n impl Condvar {\n     pub const fn new() -> Condvar {\n-        Condvar { identifier: 0 }\n+        Condvar { counter: AtomicUsize::new(0), sem1: ptr::null(), sem2: ptr::null() }\n     }\n \n     pub unsafe fn init(&mut self) {\n-        let _ = abi::init_queue(self.id());\n+        let _ = abi::sem_init(&mut self.sem1 as *mut *const c_void, 0);\n+        let _ = abi::sem_init(&mut self.sem2 as *mut *const c_void, 0);\n     }\n \n     pub unsafe fn notify_one(&self) {\n-        let _ = abi::notify(self.id(), 1);\n+        if self.counter.load(SeqCst) > 0 {\n+            self.counter.fetch_sub(1, SeqCst);\n+            abi::sem_post(self.sem1);\n+            abi::sem_timedwait(self.sem2, 0);\n+        }\n     }\n \n-    #[inline]\n     pub unsafe fn notify_all(&self) {\n-        let _ = abi::notify(self.id(), -1 /* =all */);\n+        let counter = self.counter.swap(0, SeqCst);\n+        for _ in 0..counter {\n+            abi::sem_post(self.sem1);\n+        }\n+        for _ in 0..counter {\n+            abi::sem_timedwait(self.sem2, 0);\n+        }\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        // add current task to the wait queue\n-        let _ = abi::add_queue(self.id(), -1 /* no timeout */);\n+        self.counter.fetch_add(1, SeqCst);\n         mutex.unlock();\n-        let _ = abi::wait(self.id());\n+        abi::sem_timedwait(self.sem1, 0);\n+        abi::sem_post(self.sem2);\n         mutex.lock();\n     }\n \n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let nanos = dur.as_nanos();\n-        let nanos = cmp::min(i64::MAX as u128, nanos);\n-\n-        // add current task to the wait queue\n-        let _ = abi::add_queue(self.id(), nanos as i64);\n-\n-        mutex.unlock();\n-        // If the return value is !0 then a timeout happened, so we return\n-        // `false` as we weren't actually notified.\n-        let ret = abi::wait(self.id()) == 0;\n-        mutex.lock();\n-\n-        ret\n+    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        panic!(\"wait_timeout not supported on hermit\");\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let _ = abi::destroy_queue(self.id());\n-    }\n-\n-    #[inline]\n-    fn id(&self) -> usize {\n-        &self.identifier as *const usize as usize\n+        let _ = abi::sem_destroy(self.sem1);\n+        let _ = abi::sem_destroy(self.sem2);\n     }\n }"}, {"sha": "06442e925f4c8710d33caf6fff3e18a54e495081", "filename": "src/libstd/sys/hermit/rwlock.rs", "status": "modified", "additions": 105, "deletions": 10, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/dfedb84462ed2281877ec10253e659155213e7c8/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfedb84462ed2281877ec10253e659155213e7c8/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs?ref=dfedb84462ed2281877ec10253e659155213e7c8", "patch": "@@ -1,49 +1,144 @@\n-use super::mutex::Mutex;\n+use crate::cell::UnsafeCell;\n+use crate::sys::condvar::Condvar;\n+use crate::sys::mutex::Mutex;\n \n pub struct RWLock {\n-    mutex: Mutex,\n+    lock: Mutex,\n+    cond: Condvar,\n+    state: UnsafeCell<State>,\n+}\n+\n+enum State {\n+    Unlocked,\n+    Reading(usize),\n+    Writing,\n }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n+// This rwlock implementation is a relatively simple implementation which has a\n+// condition variable for readers/writers as well as a mutex protecting the\n+// internal state of the lock. A current downside of the implementation is that\n+// unlocking the lock will notify *all* waiters rather than just readers or just\n+// writers. This can cause lots of \"thundering stampede\" problems. While\n+// hopefully correct this implementation is very likely to want to be changed in\n+// the future.\n+\n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock { mutex: Mutex::new() }\n+        RWLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n     }\n \n     #[inline]\n     pub unsafe fn read(&self) {\n-        self.mutex.lock();\n+        self.lock.lock();\n+        while !(*self.state.get()).inc_readers() {\n+            self.cond.wait(&self.lock);\n+        }\n+        self.lock.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        self.mutex.try_lock()\n+        self.lock.lock();\n+        let ok = (*self.state.get()).inc_readers();\n+        self.lock.unlock();\n+        return ok;\n     }\n \n     #[inline]\n     pub unsafe fn write(&self) {\n-        self.mutex.lock();\n+        self.lock.lock();\n+        while !(*self.state.get()).inc_writers() {\n+            self.cond.wait(&self.lock);\n+        }\n+        self.lock.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        self.mutex.try_lock()\n+        self.lock.lock();\n+        let ok = (*self.state.get()).inc_writers();\n+        self.lock.unlock();\n+        return ok;\n     }\n \n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        self.mutex.unlock();\n+        self.lock.lock();\n+        let notify = (*self.state.get()).dec_readers();\n+        self.lock.unlock();\n+        if notify {\n+            // FIXME: should only wake up one of these some of the time\n+            self.cond.notify_all();\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        self.mutex.unlock();\n+        self.lock.lock();\n+        (*self.state.get()).dec_writers();\n+        self.lock.unlock();\n+        // FIXME: should only wake up one of these some of the time\n+        self.cond.notify_all();\n     }\n \n     #[inline]\n     pub unsafe fn destroy(&self) {\n-        self.mutex.destroy();\n+        self.lock.destroy();\n+        self.cond.destroy();\n+    }\n+}\n+\n+impl State {\n+    fn inc_readers(&mut self) -> bool {\n+        match *self {\n+            State::Unlocked => {\n+                *self = State::Reading(1);\n+                true\n+            }\n+            State::Reading(ref mut cnt) => {\n+                *cnt += 1;\n+                true\n+            }\n+            State::Writing => false,\n+        }\n+    }\n+\n+    fn inc_writers(&mut self) -> bool {\n+        match *self {\n+            State::Unlocked => {\n+                *self = State::Writing;\n+                true\n+            }\n+            State::Reading(_) | State::Writing => false,\n+        }\n+    }\n+\n+    fn dec_readers(&mut self) -> bool {\n+        let zero = match *self {\n+            State::Reading(ref mut cnt) => {\n+                *cnt -= 1;\n+                *cnt == 0\n+            }\n+            State::Unlocked | State::Writing => invalid(),\n+        };\n+        if zero {\n+            *self = State::Unlocked;\n+        }\n+        zero\n     }\n+\n+    fn dec_writers(&mut self) {\n+        match *self {\n+            State::Writing => {}\n+            State::Unlocked | State::Reading(_) => invalid(),\n+        }\n+        *self = State::Unlocked;\n+    }\n+}\n+\n+fn invalid() -> ! {\n+    panic!(\"inconsistent rwlock\");\n }"}]}