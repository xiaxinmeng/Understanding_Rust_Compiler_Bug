{"sha": "e7a247dba431d6fa505ca0393ffcab5bfc65e9cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YTI0N2RiYTQzMWQ2ZmE1MDVjYTAzOTNmZmNhYjViZmM2NWU5Y2I=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-08-31T15:54:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-31T15:54:52Z"}, "message": "Rollup merge of #85017 - clarfonthey:carrying_widening, r=m-ou-se\n\nAdd carrying_add, borrowing_sub, widening_mul, carrying_mul methods to integers\n\nThis comes in part from my own attempts to make (crude) big integer implementations, and also due to the stalled discussion in [RFC 2417](https://github.com/rust-lang/rfcs/pull/2417). My understanding is that changes like these are best offered directly as code and then an RFC can be opened if there needs to be more discussion before stabilisation. Since all of these methods are unstable from the start, I figured I might as well offer them now.\n\nI tried looking into intrinsics, messed around with a few different implementations, and ultimately concluded that these are \"good enough\" implementations for now to at least put up some code and maybe start bikeshedding on a proper API for these.\n\nFor the `carrying_add` and `borrowing_sub`, I tried looking into potential architecture-specific code and realised that even using the LLVM intrinsics for `addcarry` and `subborrow` on x86 specifically, I was getting exactly the same assembly as the naive implementation using `overflowing_add` and `overflowing_sub`, although the LLVM IR did differ because of the architecture-specific code. Longer-term I think that they would be best suited to specific intrinsics as that would make optimisations easier (instructions like add-carry tend to use implicit flags, and thus can only be optimised if they're done one-after-another, and thus it would make the most sense to have compact intrinsics that can be merged together easily).\n\nFor `widening_mul` and `carrying_mul`, for now at least, I simply cast to the larger type and perform arithmetic that way, since we currently have no intrinsic that would work better for 128-bit integers. In the future, I also think that some form of intrinsic would work best to cover that case, but for now at least, I think that they're \"good enough\" for now.\n\nThe main reasoning for offering these directly to the standard library even though they're relatively niche optimisations is to help ensure that the code generated for them is optimal. Plus, these operations alone aren't enough to create big integer implementations, although they could help simplify the code required to do so and make it a bit more accessible for the average implementor.\n\nThat said, I 100% understand if any or all of these methods are not desired simply because of how niche they are. Up to you. \ud83e\udd37\ud83c\udffb", "tree": {"sha": "e8808a25e900f48cfb286b2fa4bc315b4588ac18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8808a25e900f48cfb286b2fa4bc315b4588ac18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhLlDMCRBK7hj4Ov3rIwAAiI0IABVlvo0y9I/fSaKb+mVdEzL9\nosrXDoQSex8mXlnHTyIzy706ZkNruZcoFTM5vSVjQCKcJiBn7cht/WgPx4QCWKbA\nPbPLKjEkicYr2wF9I+Sx/GbDHZa8Q7GPujxpZ2sdfmvD3A6tYaii9HO4hjXWj4Oq\n8cmtV8weITWYB9OdQ7uNtbT3fgHPsg1zccEi5yQv+y5Ti9yanWLJm3z6g/J+RKTg\n4d7F0onk+C4k86C0obYb9oioLk86Ql2/wuoUsc95RUQAsOyF0t5YGpOh2xo1KIAh\njTv+RlkwIsMJCxHZJ3/XacijZvhnZNjQe13wzPU0IHh7G9v5yRgVwFkR7ZL98yc=\n=1LRY\n-----END PGP SIGNATURE-----\n", "payload": "tree e8808a25e900f48cfb286b2fa4bc315b4588ac18\nparent 76d18cfb8945f824c8777e04981e930d2037954e\nparent cc15047d505c2cb6bba7475b18450f9785a78d7e\nauthor Mara Bos <m-ou.se@m-ou.se> 1630425292 +0200\ncommitter GitHub <noreply@github.com> 1630425292 +0200\n\nRollup merge of #85017 - clarfonthey:carrying_widening, r=m-ou-se\n\nAdd carrying_add, borrowing_sub, widening_mul, carrying_mul methods to integers\n\nThis comes in part from my own attempts to make (crude) big integer implementations, and also due to the stalled discussion in [RFC 2417](https://github.com/rust-lang/rfcs/pull/2417). My understanding is that changes like these are best offered directly as code and then an RFC can be opened if there needs to be more discussion before stabilisation. Since all of these methods are unstable from the start, I figured I might as well offer them now.\n\nI tried looking into intrinsics, messed around with a few different implementations, and ultimately concluded that these are \"good enough\" implementations for now to at least put up some code and maybe start bikeshedding on a proper API for these.\n\nFor the `carrying_add` and `borrowing_sub`, I tried looking into potential architecture-specific code and realised that even using the LLVM intrinsics for `addcarry` and `subborrow` on x86 specifically, I was getting exactly the same assembly as the naive implementation using `overflowing_add` and `overflowing_sub`, although the LLVM IR did differ because of the architecture-specific code. Longer-term I think that they would be best suited to specific intrinsics as that would make optimisations easier (instructions like add-carry tend to use implicit flags, and thus can only be optimised if they're done one-after-another, and thus it would make the most sense to have compact intrinsics that can be merged together easily).\n\nFor `widening_mul` and `carrying_mul`, for now at least, I simply cast to the larger type and perform arithmetic that way, since we currently have no intrinsic that would work better for 128-bit integers. In the future, I also think that some form of intrinsic would work best to cover that case, but for now at least, I think that they're \"good enough\" for now.\n\nThe main reasoning for offering these directly to the standard library even though they're relatively niche optimisations is to help ensure that the code generated for them is optimal. Plus, these operations alone aren't enough to create big integer implementations, although they could help simplify the code required to do so and make it a bit more accessible for the average implementor.\n\nThat said, I 100% understand if any or all of these methods are not desired simply because of how niche they are. Up to you. \ud83e\udd37\ud83c\udffb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb", "html_url": "https://github.com/rust-lang/rust/commit/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76d18cfb8945f824c8777e04981e930d2037954e", "url": "https://api.github.com/repos/rust-lang/rust/commits/76d18cfb8945f824c8777e04981e930d2037954e", "html_url": "https://github.com/rust-lang/rust/commit/76d18cfb8945f824c8777e04981e930d2037954e"}, {"sha": "cc15047d505c2cb6bba7475b18450f9785a78d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc15047d505c2cb6bba7475b18450f9785a78d7e", "html_url": "https://github.com/rust-lang/rust/commit/cc15047d505c2cb6bba7475b18450f9785a78d7e"}], "stats": {"total": 202, "additions": 202, "deletions": 0}, "files": [{"sha": "d667fff4b81ee8bf4c2c091906515c35e66bd360", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=e7a247dba431d6fa505ca0393ffcab5bfc65e9cb", "patch": "@@ -76,6 +76,7 @@\n #![feature(const_alloc_layout)]\n #![feature(const_arguments_as_str)]\n #![feature(const_assert_type)]\n+#![feature(const_bigint_helper_methods)]\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_discriminant)]"}, {"sha": "1a310917fdfc4fd00e2fc18c133350f615fbc48a", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=e7a247dba431d6fa505ca0393ffcab5bfc65e9cb", "patch": "@@ -1341,6 +1341,33 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self + rhs + carry` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary addition\" which takes in an extra bit to add, and may return an\n+        /// additional bit of overflow. This allows for chaining together multiple additions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (\", stringify!($SelfT), \"::MIN, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (\", stringify!($SelfT), \"::MIN + 1, false));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n+            let (sum, carry) = (self as $UnsignedT).carrying_add(rhs as $UnsignedT, carry);\n+            (sum as $SelfT, carry)\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n@@ -1365,6 +1392,33 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self - rhs - borrow` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary subtraction\" which takes in an extra bit to subtract, and may return\n+        /// an additional bit of overflow. This allows for chaining together multiple subtractions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, false), (\", stringify!($SelfT), \"::MAX, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, false));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n+            let (sum, borrow) = (self as $UnsignedT).borrowing_sub(rhs as $UnsignedT, borrow);\n+            (sum as $SelfT, borrow)\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow"}, {"sha": "59b68cbe9c0ceb318af73074de99c0959aae936d", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=e7a247dba431d6fa505ca0393ffcab5bfc65e9cb", "patch": "@@ -93,27 +93,104 @@ depending on the target pointer size.\n     };\n }\n \n+macro_rules! widening_impl {\n+    ($SelfT:ty, $WideT:ty, $BITS:literal) => {\n+        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n+        ///\n+        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n+        /// of the result as two separate values, in that order.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u32` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n+        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n+            // note: longer-term this should be done via an intrinsic,\n+            //   but for now we can deal without an impl for u128/i128\n+            // SAFETY: overflow will be contained within the wider types\n+            let wide = unsafe { (self as $WideT).unchecked_mul(rhs as $WideT) };\n+            (wide as $SelfT, (wide >> $BITS) as $SelfT)\n+        }\n+\n+        /// Calculates the \"full multiplication\" `self * rhs + carry`\n+        /// without the possibility to overflow.\n+        ///\n+        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n+        /// of the result as two separate values, in that order.\n+        ///\n+        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n+        /// additional amount of overflow. This allows for chaining together multiple\n+        /// multiplications to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u32` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n+        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n+        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n+        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n+            // note: longer-term this should be done via an intrinsic,\n+            //   but for now we can deal without an impl for u128/i128\n+            // SAFETY: overflow will be contained within the wider types\n+            let wide = unsafe {\n+                (self as $WideT).unchecked_mul(rhs as $WideT).unchecked_add(carry as $WideT)\n+            };\n+            (wide as $SelfT, (wide >> $BITS) as $SelfT)\n+        }\n+    };\n+}\n+\n #[lang = \"i8\"]\n impl i8 {\n+    widening_impl! { i8, i16, 8 }\n     int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n     \"[0x12]\", \"[0x12]\", \"\", \"\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n+    widening_impl! { i16, i32, 16 }\n     int_impl! { i16, i16, u16, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n     \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n+    widening_impl! { i32, i64, 32 }\n     int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n+    widening_impl! { i64, i128, 64 }\n     int_impl! { i64, i64, u64, 64, 63, -9223372036854775808, 9223372036854775807, 12,\n     \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -135,6 +212,7 @@ impl i128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i32, 16 }\n     int_impl! { isize, i16, usize, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n     \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n@@ -143,6 +221,7 @@ impl isize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i64, 32 }\n     int_impl! { isize, i32, usize, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\",\n@@ -152,6 +231,7 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i128, 64 }\n     int_impl! { isize, i64, usize, 64, 63, -9223372036854775808, 9223372036854775807,\n     12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n      \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -164,6 +244,7 @@ const ASCII_CASE_MASK: u8 = 0b0010_0000;\n \n #[lang = \"u8\"]\n impl u8 {\n+    widening_impl! { u8, u16, 8 }\n     uint_impl! { u8, u8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n     \"[0x12]\", \"\", \"\" }\n \n@@ -697,18 +778,21 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n+    widening_impl! { u16, u32, 16 }\n     uint_impl! { u16, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n+    widening_impl! { u32, u64, 32 }\n     uint_impl! { u32, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n+    widening_impl! { u64, u128, 64 }\n     uint_impl! { u64, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -731,13 +815,15 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u32, 16 }\n     uint_impl! { usize, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u64, 32 }\n     uint_impl! { usize, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n@@ -746,6 +832,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u128, 64 }\n     uint_impl! { usize, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\","}, {"sha": "9366efb32bcf9e8ecb767e85a294b0970e78fb74", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a247dba431d6fa505ca0393ffcab5bfc65e9cb/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=e7a247dba431d6fa505ca0393ffcab5bfc65e9cb", "patch": "@@ -1408,6 +1408,36 @@ macro_rules! uint_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self + rhs + carry` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary addition\" which takes in an extra bit to add, and may return an\n+        /// additional bit of overflow. This allows for chaining together multiple additions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (0, true));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (1, true));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n+            // note: longer-term this should be done via an intrinsic, but this has been shown\n+            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n+            let (a, b) = self.overflowing_add(rhs);\n+            let (c, d) = a.overflowing_add(carry as $SelfT);\n+            (c, b | d)\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating\n@@ -1433,6 +1463,36 @@ macro_rules! uint_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self - rhs - borrow` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary subtraction\" which takes in an extra bit to subtract, and may return\n+        /// an additional bit of overflow. This allows for chaining together multiple subtractions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, false), (\", stringify!($SelfT), \"::MAX, true));\")]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, true));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n+            // note: longer-term this should be done via an intrinsic, but this has been shown\n+            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n+            let (a, b) = self.overflowing_sub(rhs);\n+            let (c, d) = a.overflowing_sub(borrow as $SelfT);\n+            (c, b | d)\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean"}]}