{"sha": "9146bb09a14a66044206119366231a5296612d8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNDZiYjA5YTE0YTY2MDQ0MjA2MTE5MzY2MjMxYTUyOTY2MTJkOGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-10-14T23:45:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-02T21:14:19Z"}, "message": "work on making the size of ints depend on the target arch", "tree": {"sha": "aeed7d3d95a1b9ef8351b6f37fe84652a88591e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeed7d3d95a1b9ef8351b6f37fe84652a88591e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9146bb09a14a66044206119366231a5296612d8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9146bb09a14a66044206119366231a5296612d8d", "html_url": "https://github.com/rust-lang/rust/commit/9146bb09a14a66044206119366231a5296612d8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9146bb09a14a66044206119366231a5296612d8d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0887996e58c480c981f693df00ffcf183701b9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0887996e58c480c981f693df00ffcf183701b9d", "html_url": "https://github.com/rust-lang/rust/commit/d0887996e58c480c981f693df00ffcf183701b9d"}], "stats": {"total": 505, "additions": 295, "deletions": 210}, "files": [{"sha": "4c49634e68b2a1931027ab718420b112ad9838e8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 221, "deletions": 150, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/9146bb09a14a66044206119366231a5296612d8d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146bb09a14a66044206119366231a5296612d8d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9146bb09a14a66044206119366231a5296612d8d", "patch": "@@ -95,7 +95,7 @@ fn type_of_fn(cx: @crate_ctxt, sp: span,\n     // Arg 1: Env (closure-bindings / self-obj)\n     if is_method {\n         atys += [T_ptr(cx.rust_object_type)];\n-    } else { atys += [T_opaque_closure_ptr(*cx)]; }\n+    } else { atys += [T_opaque_closure_ptr(cx)]; }\n \n     // Args >2: ty params, if not acquired via capture...\n     if !is_method {\n@@ -134,9 +134,9 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         T_nil() /* ...I guess? */\n       }\n       ty::ty_bool. { T_bool() }\n-      ty::ty_int. { T_int() }\n-      ty::ty_float. { T_float() }\n-      ty::ty_uint. { T_int() }\n+      ty::ty_int. { T_int(cx) }\n+      ty::ty_float. { T_float(cx) }\n+      ty::ty_uint. { T_int(cx) }\n       ty::ty_machine(tm) {\n         alt tm {\n           ast::ty_i8. | ast::ty_u8. { T_i8() }\n@@ -148,24 +148,24 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         }\n       }\n       ty::ty_char. { T_char() }\n-      ty::ty_str. { T_ptr(T_vec(T_i8())) }\n+      ty::ty_str. { T_ptr(T_vec(cx, T_i8())) }\n       ty::ty_tag(did, _) { type_of_tag(cx, sp, did, t) }\n       ty::ty_box(mt) {\n         let mt_ty = mt.ty;\n         check non_ty_var(cx, mt_ty);\n-        T_ptr(T_box(type_of_inner(cx, sp, mt_ty))) }\n+        T_ptr(T_box(cx, type_of_inner(cx, sp, mt_ty))) }\n       ty::ty_uniq(mt) {\n         let mt_ty = mt.ty;\n         check non_ty_var(cx, mt_ty);\n         T_ptr(type_of_inner(cx, sp, mt_ty)) }\n       ty::ty_vec(mt) {\n         let mt_ty = mt.ty;\n         if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n-            T_ptr(T_opaque_vec())\n+            T_ptr(T_opaque_vec(cx))\n         } else {\n             // should be unnecessary\n             check non_ty_var(cx, mt_ty);\n-            T_ptr(T_vec(type_of_inner(cx, sp, mt_ty))) }\n+            T_ptr(T_vec(cx, type_of_inner(cx, sp, mt_ty))) }\n       }\n       ty::ty_ptr(mt) {\n         let mt_ty = mt.ty;\n@@ -183,12 +183,12 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n       ty::ty_fn(_, _, _, _, _) {\n         // FIXME: could be a constraint on ty_fn\n         check returns_non_ty_var(cx, t);\n-        T_fn_pair(*cx, type_of_fn_from_ty(cx, sp, t, 0u))\n+        T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, 0u))\n       }\n       ty::ty_native_fn(abi, args, out) {\n         if native_abi_requires_pair(abi) {\n             let nft = native_fn_wrapper_type(cx, sp, 0u, t);\n-            T_fn_pair(*cx, nft)\n+            T_fn_pair(cx, nft)\n         } else {\n             raw_native_fn_type(cx, sp, args, out)\n         }\n@@ -340,10 +340,13 @@ fn get_extern_const(externs: hashmap<str, ValueRef>, llmod: ModuleRef,\n     ret c;\n }\n \n-fn get_simple_extern_fn(externs: hashmap<str, ValueRef>, llmod: ModuleRef,\n+fn get_simple_extern_fn(cx: @block_ctxt,\n+                        externs: hashmap<str, ValueRef>,\n+                        llmod: ModuleRef,\n                         name: str, n_args: int) -> ValueRef {\n-    let inputs = std::vec::init_elt::<TypeRef>(T_int(), n_args as uint);\n-    let output = T_int();\n+    let ccx = cx.fcx.lcx.ccx;\n+    let inputs = std::vec::init_elt::<TypeRef>(T_int(ccx), n_args as uint);\n+    let output = T_int(ccx);\n     let t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n }\n@@ -352,15 +355,19 @@ fn trans_native_call(cx: @block_ctxt, externs: hashmap<str, ValueRef>,\n                      llmod: ModuleRef, name: str, args: [ValueRef]) ->\n    ValueRef {\n     let n: int = std::vec::len::<ValueRef>(args) as int;\n-    let llnative: ValueRef = get_simple_extern_fn(externs, llmod, name, n);\n+    let llnative: ValueRef =\n+        get_simple_extern_fn(cx, externs, llmod, name, n);\n     let call_args: [ValueRef] = [];\n-    for a: ValueRef in args { call_args += [ZExtOrBitCast(cx, a, T_int())]; }\n+    for a: ValueRef in args {\n+        call_args += [ZExtOrBitCast(cx, a, T_int(bcx_ccx(cx)))];\n+    }\n     ret Call(cx, llnative, call_args);\n }\n \n fn trans_non_gc_free(cx: @block_ctxt, v: ValueRef) -> @block_ctxt {\n     Call(cx, bcx_ccx(cx).upcalls.free,\n-         [PointerCast(cx, v, T_ptr(T_i8())), C_int(0)]);\n+         [PointerCast(cx, v, T_ptr(T_i8())),\n+          C_int(bcx_ccx(cx), 0)]);\n     ret cx;\n }\n \n@@ -381,7 +388,7 @@ fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n }\n \n fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n-    let mask = Sub(cx, align, C_int(1));\n+    let mask = Sub(cx, align, C_int(bcx_ccx(cx), 1));\n     let bumped = Add(cx, off, mask);\n     ret And(cx, bumped, Not(cx, mask));\n }\n@@ -397,13 +404,13 @@ fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t);\n }\n \n-fn llsize_of(t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), T_int(),\n+fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), T_int(cx),\n                                False);\n }\n \n-fn llalign_of(t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), T_int(),\n+fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), T_int(cx),\n                                False);\n }\n \n@@ -420,15 +427,15 @@ fn size_of_(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n         let sp = cx.sp;\n-        rslt(cx, llsize_of(type_of(ccx, sp, t)))\n+        rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n     } else { dynamic_size_of(cx, t, mode) }\n }\n \n fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n         let sp = cx.sp;\n-        rslt(cx, llalign_of(type_of(ccx, sp, t)))\n+        rslt(cx, llalign_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n     } else { dynamic_align_of(cx, t) }\n }\n \n@@ -451,7 +458,9 @@ fn dynastack_alloca(cx: @block_ctxt, t: TypeRef, n: ValueRef, ty: ty::t) ->\n     }\n \n     let dynastack_alloc = bcx_ccx(bcx).upcalls.dynastack_alloc;\n-    let llsz = Mul(dy_cx, C_uint(llsize_of_real(bcx_ccx(bcx), t)), n);\n+    let llsz = Mul(dy_cx,\n+                   C_uint(bcx_ccx(bcx), llsize_of_real(bcx_ccx(bcx), t)),\n+                   n);\n \n     let ti = none;\n     let lltydesc = get_tydesc(cx, ty, false, tps_normal, ti).result.val;\n@@ -545,8 +554,8 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n         //     is aligned to max alignment of interior.\n         //\n \n-        let off = C_int(0);\n-        let max_align = C_int(1);\n+        let off = C_int(bcx_ccx(cx), 0);\n+        let max_align = C_int(bcx_ccx(cx), 1);\n         let bcx = cx;\n         for e: ty::t in elts {\n             let elt_align = align_of(bcx, e);\n@@ -585,10 +594,11 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n       }\n       ty::ty_tag(tid, tps) {\n         let bcx = cx;\n+        let ccx = bcx_ccx(bcx);\n         // Compute max(variant sizes).\n \n-        let max_size: ValueRef = alloca(bcx, T_int());\n-        Store(bcx, C_int(0), max_size);\n+        let max_size: ValueRef = alloca(bcx, T_int(ccx));\n+        Store(bcx, C_int(ccx, 0), max_size);\n         let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n         for variant: ty::variant_info in variants {\n             // Perform type substitution on the raw argument types.\n@@ -608,7 +618,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n         let max_size_val = Load(bcx, max_size);\n         let total_size =\n             if std::vec::len(variants) != 1u {\n-                Add(bcx, max_size_val, llsize_of(T_int()))\n+                Add(bcx, max_size_val, llsize_of(ccx, T_int(ccx)))\n             } else { max_size_val };\n         ret rslt(bcx, total_size);\n       }\n@@ -624,7 +634,7 @@ fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n         ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n       }\n       ty::ty_rec(flds) {\n-        let a = C_int(1);\n+        let a = C_int(bcx_ccx(cx), 1);\n         let bcx = cx;\n         for f: ty::field in flds {\n             let align = align_of(bcx, f.mt.ty);\n@@ -634,10 +644,10 @@ fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n         ret rslt(bcx, a);\n       }\n       ty::ty_tag(_, _) {\n-        ret rslt(cx, C_int(1)); // FIXME: stub\n+        ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n       }\n       ty::ty_tup(elts) {\n-        let a = C_int(1);\n+        let a = C_int(bcx_ccx(cx), 1);\n         let bcx = cx;\n         for e in elts {\n             let align = align_of(bcx, e);\n@@ -653,7 +663,7 @@ fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n // in C_int()\n fn GEPi(cx: @block_ctxt, base: ValueRef, ixs: [int]) -> ValueRef {\n     let v: [ValueRef] = [];\n-    for i: int in ixs { v += [C_int(i)]; }\n+    for i: int in ixs { v += [C_int(bcx_ccx(cx), i)]; }\n     ret InBoundsGEP(cx, base, v);\n }\n \n@@ -874,7 +884,7 @@ fn trans_malloc_boxed(cx: @block_ctxt, t: ty::t) ->\n     let res = trans_malloc_boxed_raw(cx, t);\n     let box = res.val;\n     let rc = GEPi(res.bcx, box, [0, abi::box_rc_field_refcnt]);\n-    Store(res.bcx, C_int(1), rc);\n+    Store(res.bcx, C_int(bcx_ccx(cx), 1), rc);\n     let body = GEPi(res.bcx, box, [0, abi::box_rc_field_body]);\n     ret {bcx: res.bcx, box: res.val, body: body};\n }\n@@ -888,8 +898,10 @@ fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n    result {\n     let ti = none::<@tydesc_info>;\n     let tydesc = get_tydesc(cx, t, escapes, tps_normal, ti).result;\n+    let ccx = bcx_ccx(cx);\n     ret rslt(tydesc.bcx,\n-             GEP(tydesc.bcx, tydesc.val, [C_int(0), C_int(field)]));\n+             GEP(tydesc.bcx, tydesc.val, [C_int(ccx, 0),\n+                                          C_int(ccx, field)]));\n }\n \n \n@@ -931,16 +943,22 @@ fn trans_stack_local_derived_tydesc(cx: @block_ctxt, llsz: ValueRef,\n     Store(cx, llroottydesc, llmyroottydesc);\n \n     // Store a pointer to the rest of the descriptors.\n+    let ccx = bcx_ccx(cx);\n     store_inbounds(cx, llfirstparam, llmyroottydesc,\n-                   [C_int(0), C_int(abi::tydesc_field_first_param)]);\n-    store_inbounds(cx, C_uint(n_params), llmyroottydesc,\n-                   [C_int(0), C_int(abi::tydesc_field_n_params)]);\n+                   [C_int(ccx, 0),\n+                    C_int(ccx, abi::tydesc_field_first_param)]);\n+    store_inbounds(cx, C_uint(ccx, n_params), llmyroottydesc,\n+                   [C_int(ccx, 0),\n+                    C_int(ccx, abi::tydesc_field_n_params)]);\n     store_inbounds(cx, llsz, llmyroottydesc,\n-                   [C_int(0), C_int(abi::tydesc_field_size)]);\n+                   [C_int(ccx, 0),\n+                    C_int(ccx, abi::tydesc_field_size)]);\n     store_inbounds(cx, llalign, llmyroottydesc,\n-                   [C_int(0), C_int(abi::tydesc_field_align)]);\n-    store_inbounds(cx, C_uint(obj_params), llmyroottydesc,\n-                   [C_int(0), C_int(abi::tydesc_field_obj_params)]);\n+                   [C_int(ccx, 0),\n+                    C_int(ccx, abi::tydesc_field_align)]);\n+    store_inbounds(cx, C_uint(ccx, obj_params), llmyroottydesc,\n+                   [C_int(ccx, 0),\n+                    C_int(ccx, abi::tydesc_field_obj_params)]);\n     ret llmyroottydesc;\n }\n \n@@ -1020,11 +1038,12 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n \n     let v;\n     if escapes {\n+        let ccx = bcx_ccx(bcx);\n         let td_val =\n-            Call(bcx, bcx_ccx(bcx).upcalls.get_type_desc,\n+            Call(bcx, ccx.upcalls.get_type_desc,\n                  [C_null(T_ptr(T_nil())), sz.val,\n-                  align.val, C_uint(1u + n_params), llfirstparam,\n-                  C_uint(obj_params)]);\n+                  align.val, C_uint(ccx, 1u + n_params), llfirstparam,\n+                  C_uint(ccx, obj_params)]);\n         v = td_val;\n     } else {\n         v =\n@@ -1134,14 +1153,14 @@ fn declare_tydesc(cx: @local_ctxt, sp: span, t: ty::t, ty_params: [uint],\n     let llalign;\n     if check type_has_static_size(ccx, t) {\n         let llty = type_of(ccx, sp, t);\n-        llsize = llsize_of(llty);\n-        llalign = llalign_of(llty);\n+        llsize = llsize_of(ccx, llty);\n+        llalign = llalign_of(ccx, llty);\n     } else {\n         // These will be overwritten as the derived tydesc is generated, so\n         // we create placeholder values.\n \n-        llsize = C_int(0);\n-        llalign = C_int(0);\n+        llsize = C_int(ccx, 0);\n+        llalign = C_int(ccx, 0);\n     }\n     let name;\n     if cx.ccx.sess.get_opts().debuginfo {\n@@ -1211,7 +1230,7 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n     let lltydescs = [mutable];\n     let p = 0u;\n     while p < ty_param_count {\n-        let llparam = GEP(load_env_bcx, lltyparams, [C_int(p as int)]);\n+        let llparam = GEP(load_env_bcx, lltyparams, [C_int(ccx, p as int)]);\n         llparam = Load(load_env_bcx, llparam);\n         std::vec::grow_set(lltydescs, ty_params[p], 0 as ValueRef, llparam);\n         p += 1u;\n@@ -1255,8 +1274,8 @@ fn make_generic_glue(cx: @local_ctxt, sp: span, t: ty::t, llfn: ValueRef,\n \n fn emit_tydescs(ccx: @crate_ctxt) {\n     ccx.tydescs.items {|key, val|\n-        let glue_fn_ty = T_ptr(T_glue_fn(*ccx));\n-        let cmp_fn_ty = T_ptr(T_cmp_glue_fn(*ccx));\n+        let glue_fn_ty = T_ptr(T_glue_fn(ccx));\n+        let cmp_fn_ty = T_ptr(T_cmp_glue_fn(ccx));\n         let ti = val;\n         let take_glue =\n             alt ti.take_glue {\n@@ -1300,8 +1319,8 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n                             cmp_glue, // cmp_glue\n                             C_shape(ccx, shape), // shape\n                             shape_tables, // shape_tables\n-                            C_int(0), // n_params\n-                            C_int(0)]); // n_obj_params\n+                            C_int(ccx, 0), // n_params\n+                            C_int(ccx, 0)]); // n_obj_params\n \n         let gvar = ti.tydesc;\n         llvm::LLVMSetInitializer(gvar, tydesc);\n@@ -1333,10 +1352,12 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n }\n \n fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n+    let ccx = bcx_ccx(cx);\n     let rc_ptr =\n-        GEP(cx, box_ptr, [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n+        GEP(cx, box_ptr, [C_int(ccx, 0),\n+                          C_int(ccx, abi::box_rc_field_refcnt)]);\n     let rc = Load(cx, rc_ptr);\n-    rc = Add(cx, rc, C_int(1));\n+    rc = Add(cx, rc, C_int(ccx, 1));\n     Store(cx, rc, rc_ptr);\n     ret cx;\n }\n@@ -1348,7 +1369,9 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n     let bcx = alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_box(body_mt) {\n         v = PointerCast(bcx, v, type_of_1(bcx, t));\n-        let body = GEP(bcx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let ccx = bcx_ccx(bcx);\n+        let body = GEP(bcx, v, [C_int(ccx, 0),\n+                                C_int(ccx, abi::box_rc_field_body)]);\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         if !bcx_ccx(bcx).sess.get_opts().do_gc {\n             trans_non_gc_free(bcx, v)\n@@ -1366,11 +1389,13 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         // Call through the obj's own fields-drop glue first.\n         // Then free the body.\n         let ccx = bcx_ccx(bcx);\n-        let llbox_ty = T_opaque_obj_ptr(*ccx);\n+        let llbox_ty = T_opaque_obj_ptr(ccx);\n         let b = PointerCast(bcx, v, llbox_ty);\n-        let body = GEP(bcx, b, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let body = GEP(bcx, b, [C_int(ccx, 0),\n+                                C_int(ccx, abi::box_rc_field_body)]);\n         let tydescptr =\n-            GEP(bcx, body, [C_int(0), C_int(abi::obj_body_elt_tydesc)]);\n+            GEP(bcx, body, [C_int(ccx, 0),\n+                            C_int(ccx, abi::obj_body_elt_tydesc)]);\n         let tydesc = Load(bcx, tydescptr);\n         let ti = none;\n         call_tydesc_glue_full(bcx, body, tydesc,\n@@ -1382,12 +1407,16 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n       ty::ty_fn(_, _, _, _, _) {\n         // Call through the closure's own fields-drop glue first.\n         // Then free the body.\n-        v = PointerCast(bcx, v, T_opaque_closure_ptr(*bcx_ccx(bcx)));\n-        let body = GEP(bcx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let ccx = bcx_ccx(bcx);\n+        v = PointerCast(bcx, v, T_opaque_closure_ptr(ccx));\n+        let body = GEP(bcx, v, [C_int(ccx, 0),\n+                                C_int(ccx, abi::box_rc_field_body)]);\n         let bindings =\n-            GEP(bcx, body, [C_int(0), C_int(abi::closure_elt_bindings)]);\n+            GEP(bcx, body, [C_int(ccx, 0),\n+                            C_int(ccx, abi::closure_elt_bindings)]);\n         let tydescptr =\n-            GEP(bcx, body, [C_int(0), C_int(abi::closure_elt_tydesc)]);\n+            GEP(bcx, body, [C_int(ccx, 0),\n+                            C_int(ccx, abi::closure_elt_tydesc)]);\n         let ti = none;\n         call_tydesc_glue_full(bcx, bindings, Load(bcx, tydescptr),\n                               abi::tydesc_field_drop_glue, ti);\n@@ -1411,14 +1440,16 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n           }\n           ty::ty_obj(_) {\n             let box_cell =\n-                GEP(bcx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n+                GEP(bcx, v0, [C_int(ccx, 0),\n+                              C_int(ccx, abi::obj_field_box)]);\n             decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n           }\n           ty::ty_res(did, inner, tps) {\n             trans_res_drop(bcx, v0, did, inner, tps)\n           }\n           ty::ty_fn(_, _, _, _, _) {\n-            let box_cell = GEP(bcx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n+            let box_cell = GEP(bcx, v0, [C_int(ccx, 0),\n+                                         C_int(ccx, abi::fn_field_box)]);\n             decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n           }\n           _ {\n@@ -1469,7 +1500,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     Call(cx, dtor_addr, args + [val_cast]);\n \n     cx = drop_ty(cx, val.val, inner_t_s);\n-    Store(cx, C_int(0), drop_flag.val);\n+    Store(cx, C_int(ccx, 0), drop_flag.val);\n     Br(cx, next_cx.llbb);\n     ret next_cx;\n }\n@@ -1480,16 +1511,17 @@ fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n     let rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n     let free_cx = new_sub_block_ctxt(cx, \"free\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    let llbox_ty = T_opaque_obj_ptr(*ccx);\n+    let llbox_ty = T_opaque_obj_ptr(ccx);\n     box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n     let null_test = IsNull(cx, box_ptr);\n     CondBr(cx, null_test, next_cx.llbb, rc_adj_cx.llbb);\n     let rc_ptr =\n-        GEP(rc_adj_cx, box_ptr, [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n+        GEP(rc_adj_cx, box_ptr, [C_int(ccx, 0),\n+                                 C_int(ccx, abi::box_rc_field_refcnt)]);\n     let rc = Load(rc_adj_cx, rc_ptr);\n-    rc = Sub(rc_adj_cx, rc, C_int(1));\n+    rc = Sub(rc_adj_cx, rc, C_int(ccx, 1));\n     Store(rc_adj_cx, rc, rc_ptr);\n-    let zero_test = ICmp(rc_adj_cx, lib::llvm::LLVMIntEQ, C_int(0), rc);\n+    let zero_test = ICmp(rc_adj_cx, lib::llvm::LLVMIntEQ, C_int(ccx, 0), rc);\n     CondBr(rc_adj_cx, zero_test, free_cx.llbb, next_cx.llbb);\n     let free_cx = free_ty(free_cx, box_ptr, t);\n     Br(free_cx, next_cx.llbb);\n@@ -1695,10 +1727,11 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n             ret iter_variant(cx, av, variants[0], tps, tid, f);\n         }\n \n-        let lltagty = T_opaque_tag_ptr(bcx_ccx(cx).tn);\n+        let ccx = bcx_ccx(cx);\n+        let lltagty = T_opaque_tag_ptr(ccx);\n         let av_tag = PointerCast(cx, av, lltagty);\n-        let lldiscrim_a_ptr = GEP(cx, av_tag, [C_int(0), C_int(0)]);\n-        let llunion_a_ptr = GEP(cx, av_tag, [C_int(0), C_int(1)]);\n+        let lldiscrim_a_ptr = GEP(cx, av_tag, [C_int(ccx, 0), C_int(ccx, 0)]);\n+        let llunion_a_ptr = GEP(cx, av_tag, [C_int(ccx, 0), C_int(ccx, 1)]);\n         let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n \n         // NB: we must hit the discriminant first so that structural\n@@ -1714,7 +1747,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n                 new_sub_block_ctxt(cx,\n                                    \"tag-iter-variant-\" +\n                                        uint::to_str(i, 10u));\n-            AddCase(llswitch, C_int(i as int), variant_cx.llbb);\n+            AddCase(llswitch, C_int(ccx, i as int), variant_cx.llbb);\n             variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, variant, tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n@@ -1723,11 +1756,15 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         ret next_cx;\n       }\n       ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _, _) {\n-        let box_cell_a = GEP(cx, av, [C_int(0), C_int(abi::fn_field_box)]);\n+        let ccx = bcx_ccx(cx);\n+        let box_cell_a = GEP(cx, av, [C_int(ccx, 0),\n+                                      C_int(ccx, abi::fn_field_box)]);\n         ret iter_boxpp(cx, box_cell_a, f);\n       }\n       ty::ty_obj(_) {\n-        let box_cell_a = GEP(cx, av, [C_int(0), C_int(abi::obj_field_box)]);\n+        let ccx = bcx_ccx(cx);\n+        let box_cell_a = GEP(cx, av, [C_int(ccx, 0),\n+                                      C_int(ccx, abi::obj_field_box)]);\n         ret iter_boxpp(cx, box_cell_a, f);\n       }\n       _ { bcx_ccx(cx).sess.unimpl(\"type in iter_structural_ty\"); }\n@@ -1763,7 +1800,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n-                    declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n+                    declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n                                          \"take\");\n                 ti.take_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n@@ -1781,7 +1818,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n-                    declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n+                    declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n                                          \"drop\");\n                 ti.drop_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n@@ -1799,7 +1836,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n-                    declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n+                    declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n                                          \"free\");\n                 ti.free_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n@@ -1843,15 +1880,18 @@ fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n       }\n     }\n \n+    let ccx = bcx_ccx(cx);\n     let llrawptr = PointerCast(cx, v, T_ptr(T_i8()));\n     let lltydescs =\n-        GEP(cx, tydesc, [C_int(0), C_int(abi::tydesc_field_first_param)]);\n+        GEP(cx, tydesc, [C_int(ccx, 0),\n+                         C_int(ccx, abi::tydesc_field_first_param)]);\n     lltydescs = Load(cx, lltydescs);\n \n     let llfn;\n     alt static_glue_fn {\n       none. {\n-        let llfnptr = GEP(cx, tydesc, [C_int(0), C_int(field)]);\n+        let llfnptr = GEP(cx, tydesc, [C_int(ccx, 0),\n+                                       C_int(ccx, field)]);\n         llfn = Load(cx, llfnptr);\n       }\n       some(sgf) { llfn = sgf; }\n@@ -1890,15 +1930,18 @@ fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     let lltydesc = r.val;\n     bcx = r.bcx;\n     lazily_emit_tydesc_glue(bcx, abi::tydesc_field_cmp_glue, ti);\n+    let ccx = bcx_ccx(bcx);\n     let lltydescs =\n-        GEP(bcx, lltydesc, [C_int(0), C_int(abi::tydesc_field_first_param)]);\n+        GEP(bcx, lltydesc, [C_int(ccx, 0),\n+                            C_int(ccx, abi::tydesc_field_first_param)]);\n     lltydescs = Load(bcx, lltydescs);\n \n     let llfn;\n     alt ti {\n       none. {\n         let llfnptr =\n-            GEP(bcx, lltydesc, [C_int(0), C_int(abi::tydesc_field_cmp_glue)]);\n+            GEP(bcx, lltydesc, [C_int(ccx, 0),\n+                                C_int(ccx, abi::tydesc_field_cmp_glue)]);\n         llfn = Load(bcx, llfnptr);\n       }\n       some(sti) { llfn = option::get(sti.cmp_glue); }\n@@ -1962,13 +2005,14 @@ fn call_memmove(cx: @block_ctxt, dst: ValueRef, src: ValueRef,\n     // is statically known (it must be nothing more than a constant int, or\n     // LLVM complains -- not even a constant element of a tydesc works).\n \n-    let i = bcx_ccx(cx).intrinsics;\n+    let ccx = bcx_ccx(cx);\n+    let i = ccx.intrinsics;\n     assert (i.contains_key(\"llvm.memmove.p0i8.p0i8.i32\"));\n     let memmove = i.get(\"llvm.memmove.p0i8.p0i8.i32\");\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, T_i32());\n-    let align = C_int(1);\n+    let align = C_int(ccx, 1);\n     let volatile = C_bool(false);\n     ret rslt(cx,\n              Call(cx, memmove, [dst_ptr, src_ptr, size, align, volatile]));\n@@ -1977,16 +2021,16 @@ fn call_memmove(cx: @block_ctxt, dst: ValueRef, src: ValueRef,\n fn call_bzero(cx: @block_ctxt, dst: ValueRef, n_bytes: ValueRef,\n               align_bytes: ValueRef) -> result {\n     // FIXME: switch to the 64-bit variant when on such a platform.\n-\n-    let i = bcx_ccx(cx).intrinsics;\n+    let ccx = bcx_ccx(cx);\n+    let i = ccx.intrinsics;\n     assert (i.contains_key(\"llvm.memset.p0i8.i32\"));\n     let memset = i.get(\"llvm.memset.p0i8.i32\");\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, T_i32());\n     let align =\n         if lib::llvm::llvm::LLVMIsConstant(align_bytes) == True {\n             IntCast(cx, align_bytes, T_i32())\n-        } else { IntCast(cx, C_int(0), T_i32()) };\n+        } else { IntCast(cx, C_int(ccx, 0), T_i32()) };\n     let volatile = C_bool(false);\n     ret rslt(cx,\n              Call(cx, memset, [dst_ptr, C_u8(0u), size, align, volatile]));\n@@ -1998,7 +2042,7 @@ fn memmove_ty(cx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     if check type_has_static_size(ccx, t) {\n         if ty::type_is_structural(bcx_tcx(cx), t) {\n             let sp = cx.sp;\n-            let llsz = llsize_of(type_of(ccx, sp, t));\n+            let llsz = llsize_of(ccx, type_of(ccx, sp, t));\n             ret call_memmove(cx, dst, src, llsz).bcx;\n         }\n         Store(cx, Load(cx, src), dst);\n@@ -2110,14 +2154,14 @@ fn store_temp_expr(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n \n fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n     alt lit.node {\n-      ast::lit_int(i) { ret C_int(i); }\n-      ast::lit_uint(u) { ret C_int(u as int); }\n+      ast::lit_int(i) { ret C_int(cx, i); }\n+      ast::lit_uint(u) { ret C_int(cx, u as int); }\n       ast::lit_mach_int(tm, i) {\n         // FIXME: the entire handling of mach types falls apart\n         // if target int width is larger than host, at the moment;\n         // re-do the mach-int types using 'big' when that works.\n \n-        let t = T_int();\n+        let t = T_int(cx);\n         let s = True;\n         alt tm {\n           ast::ty_u8. { t = T_i8(); s = False; }\n@@ -2131,9 +2175,9 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n         }\n         ret C_integral(t, i as uint, s);\n       }\n-      ast::lit_float(fs) { ret C_float(fs); }\n+      ast::lit_float(fs) { ret C_float(cx, fs); }\n       ast::lit_mach_float(tm, s) {\n-        let t = T_float();\n+        let t = T_float(cx);\n         alt tm { ast::ty_f32. { t = T_f32(); } ast::ty_f64. { t = T_f64(); } }\n         ret C_floating(s, t);\n       }\n@@ -2240,7 +2284,7 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n         });\n       }\n       _ {\n-        env = C_null(T_opaque_closure_ptr(*bcx_ccx(bcx)));\n+        env = C_null(T_opaque_closure_ptr(ccx));\n         trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n       }\n     };\n@@ -2367,7 +2411,8 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     while true {\n         alt ty::struct(ccx.tcx, t1) {\n           ty::ty_box(mt) {\n-            let body = GEP(cx, v1, [C_int(0), C_int(abi::box_rc_field_body)]);\n+            let body = GEP(cx, v1, [C_int(ccx, 0),\n+                                    C_int(ccx, abi::box_rc_field_body)]);\n             t1 = mt.ty;\n \n             // Since we're changing levels of box indirection, we may have\n@@ -2387,7 +2432,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n           }\n           ty::ty_res(did, inner, tps) {\n             t1 = ty::substitute_type_params(ccx.tcx, tps, inner);\n-            v1 = GEP(cx, v1, [C_int(0), C_int(1)]);\n+            v1 = GEP(cx, v1, [C_int(ccx, 0), C_int(ccx, 1)]);\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(ccx.tcx, did);\n@@ -2567,13 +2612,14 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n         Br(bcx, next_cx.llbb);\n         ret next_cx;\n     }\n+    let ccx = bcx_ccx(cx);\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let seq_ty = ty::expr_ty(bcx_tcx(cx), seq);\n     let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n-    let seq = PointerCast(bcx, seq, T_ptr(T_opaque_vec()));\n+    let seq = PointerCast(bcx, seq, T_ptr(T_opaque_vec(ccx)));\n     let fill = tvec::get_fill(bcx, seq);\n     if ty::type_is_str(bcx_tcx(bcx), seq_ty) {\n-        fill = Sub(bcx, fill, C_int(1));\n+        fill = Sub(bcx, fill, C_int(ccx, 1));\n     }\n     let bcx = tvec::iter_vec_raw(bcx, seq, seq_ty, fill,\n                                  bind inner(_, local, _, _, body, next_cx));\n@@ -2597,6 +2643,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n                      bound_values: [environment_value],\n                      copying: bool) ->\n    {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+    let ccx = bcx_ccx(bcx);\n     let tcx = bcx_tcx(bcx);\n     // Synthesize a closure type.\n \n@@ -2648,7 +2695,9 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         let r = alloc_ty(bcx, ty);\n         bcx = r.bcx;\n         // Prevent glue from trying to free this.\n-        Store(bcx, C_int(2), GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]));\n+        Store(bcx,\n+              C_int(ccx, 2),\n+              GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]));\n         (GEPi(bcx, r.val, [0, abi::box_rc_field_body]), r.val)\n     };\n \n@@ -2852,7 +2901,7 @@ type lval_maybe_callee = {bcx: @block_ctxt,\n                           generic: option::t<generic_info>};\n \n fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n-    C_null(T_opaque_closure_ptr(*bcx_ccx(bcx)))\n+    C_null(T_opaque_closure_ptr(bcx_ccx(bcx)))\n }\n \n fn lval_owned(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n@@ -2903,15 +2952,16 @@ fn lval_static_fn(bcx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n }\n \n fn lookup_discriminant(lcx: @local_ctxt, vid: ast::def_id) -> ValueRef {\n-    alt lcx.ccx.discrims.find(vid) {\n+    let ccx = lcx.ccx;\n+    alt ccx.discrims.find(vid) {\n       none. {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n         let sym = csearch::get_symbol(lcx.ccx.sess.get_cstore(), vid);\n         let gvar =\n             str::as_buf(sym,\n                         {|buf|\n-                            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n+                            llvm::LLVMAddGlobal(ccx.llmod, T_int(ccx), buf)\n                         });\n         llvm::LLVMSetLinkage(gvar,\n                              lib::llvm::LLVMExternalLinkage as llvm::Linkage);\n@@ -3024,11 +3074,13 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n     let mths = alt ty::struct(tcx, o_ty) { ty::ty_obj(ms) { ms } };\n \n     let ix = ty::method_idx(ccx.sess, bcx.sp, field, mths);\n-    let vtbl = Load(bcx, GEP(bcx, o, [C_int(0), C_int(abi::obj_field_vtbl)]));\n+    let vtbl = Load(bcx, GEP(bcx, o, [C_int(ccx, 0),\n+                                      C_int(ccx, abi::obj_field_vtbl)]));\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n     vtbl = PointerCast(bcx, vtbl, vtbl_type);\n \n-    let v = GEP(bcx, vtbl, [C_int(0), C_int(ix as int)]);\n+    let v = GEP(bcx, vtbl, [C_int(ccx, 0),\n+                            C_int(ccx, ix as int)]);\n     let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, mths[ix]);\n     let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n     let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n@@ -3063,15 +3115,16 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     let ix = trans_temp_expr(lv.bcx, idx);\n     let v = lv.val;\n     let bcx = ix.bcx;\n+    let ccx = bcx_ccx(cx);\n \n     // Cast to an LLVM integer. Rust is less strict than LLVM in this regard.\n     let ix_val;\n     let ix_size = llsize_of_real(bcx_ccx(cx), val_ty(ix.val));\n-    let int_size = llsize_of_real(bcx_ccx(cx), T_int());\n+    let int_size = llsize_of_real(bcx_ccx(cx), T_int(ccx));\n     if ix_size < int_size {\n-        ix_val = ZExt(bcx, ix.val, T_int());\n+        ix_val = ZExt(bcx, ix.val, T_int(ccx));\n     } else if ix_size > int_size {\n-        ix_val = Trunc(bcx, ix.val, T_int());\n+        ix_val = Trunc(bcx, ix.val, T_int(ccx));\n     } else { ix_val = ix.val; }\n \n     let unit_ty = node_id_type(bcx_ccx(cx), id);\n@@ -3172,10 +3225,12 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n             alt ty::struct(ccx.tcx, t) {\n               ty::ty_box(_) {\n                 InBoundsGEP(sub.bcx, sub.val,\n-                            [C_int(0), C_int(abi::box_rc_field_body)])\n+                            [C_int(ccx, 0),\n+                             C_int(ccx, abi::box_rc_field_body)])\n               }\n               ty::ty_res(_, _, _) {\n-                InBoundsGEP(sub.bcx, sub.val, [C_int(0), C_int(1)])\n+                InBoundsGEP(sub.bcx, sub.val, [C_int(ccx, 0),\n+                                               C_int(ccx, 1)])\n               }\n               ty::ty_tag(_, _) {\n                 let ety = ty::expr_ty(ccx.tcx, e);\n@@ -3388,7 +3443,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // out the pointer to the target function from the environment. The\n     // target function lives in the first binding spot.\n     let (lltargetfn, lltargetenv, starting_idx) = alt target_fn {\n-      some(fptr) { (fptr, llvm::LLVMGetUndef(T_opaque_closure_ptr(*ccx)), 0) }\n+      some(fptr) { (fptr, llvm::LLVMGetUndef(T_opaque_closure_ptr(ccx)), 0) }\n       none. {\n         // Silly check\n         check type_is_tup_like(bcx, closure_ty);\n@@ -3397,9 +3452,11 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n                          [0, abi::box_rc_field_body,\n                           abi::closure_elt_bindings, 0]);\n         let lltargetenv =\n-            Load(cx, GEP(cx, pair, [C_int(0), C_int(abi::fn_field_box)]));\n+            Load(cx, GEP(cx, pair, [C_int(ccx, 0),\n+                                    C_int(ccx, abi::fn_field_box)]));\n         let lltargetfn = Load\n-            (cx, GEP(cx, pair, [C_int(0), C_int(abi::fn_field_code)]));\n+            (cx, GEP(cx, pair, [C_int(ccx, 0),\n+                                C_int(ccx, abi::fn_field_code)]));\n         bcx = cx;\n         (lltargetfn, lltargetenv, 1)\n       }\n@@ -3745,6 +3802,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n+    let ccx = bcx_ccx(in_cx);\n     let tcx = bcx_tcx(in_cx);\n     let fn_expr_ty = ty::expr_ty(tcx, f);\n \n@@ -3760,7 +3818,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let llenv;\n     alt f_res.env {\n       null_env. {\n-        llenv = llvm::LLVMGetUndef(T_opaque_closure_ptr(*bcx_ccx(cx)));\n+        llenv = llvm::LLVMGetUndef(T_opaque_closure_ptr(bcx_ccx(cx)));\n       }\n       obj_env(e) { llenv = e; }\n       is_closure. {\n@@ -3769,9 +3827,11 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n             faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n         }\n         let pair = faddr;\n-        faddr = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n+        faddr = GEP(bcx, pair, [C_int(ccx, 0),\n+                                C_int(ccx, abi::fn_field_code)]);\n         faddr = Load(bcx, faddr);\n-        let llclosure = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n+        let llclosure = GEP(bcx, pair, [C_int(ccx, 0),\n+                                        C_int(ccx, abi::fn_field_box)]);\n         llenv = Load(bcx, llclosure);\n       }\n     }\n@@ -3845,7 +3905,7 @@ fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n \n     // Allocate the argument bundle.\n     let llargbundlety = T_struct(vec::map({ |r| r.llty }, llargs));\n-    let llargbundlesz = llsize_of(llargbundlety);\n+    let llargbundlesz = llsize_of(ccx, llargbundlety);\n     let llrawargbundle = Call(bcx, ccx.upcalls.alloc_c_stack,\n                               [llargbundlesz]);\n     let llargbundle = PointerCast(bcx, llrawargbundle, T_ptr(llargbundlety));\n@@ -4351,6 +4411,7 @@ fn load_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n }\n \n fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n+    let ccx = bcx_ccx(cx);\n     let lcx = cx.fcx.lcx;\n     let modname = str::connect(lcx.module_path, \"::\");\n     let global = if lcx.ccx.module_data.contains_key(modname) {\n@@ -4359,10 +4420,10 @@ fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             lcx.ccx, lcx.module_path, \"loglevel\");\n         let global = str::as_buf(s, {|buf|\n-            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n+            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(ccx), buf)\n         });\n         llvm::LLVMSetGlobalConstant(global, False);\n-        llvm::LLVMSetInitializer(global, C_null(T_int()));\n+        llvm::LLVMSetInitializer(global, C_null(T_int(ccx)));\n         llvm::LLVMSetLinkage(global,\n                              lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n         lcx.ccx.module_data.insert(modname, global);\n@@ -4371,7 +4432,7 @@ fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     let log_cx = new_scope_block_ctxt(cx, \"log\");\n     let after_cx = new_sub_block_ctxt(cx, \"after\");\n     let load = Load(cx, global);\n-    let test = ICmp(cx, lib::llvm::LLVMIntSGE, load, C_int(lvl));\n+    let test = ICmp(cx, lib::llvm::LLVMIntSGE, load, C_int(ccx, lvl));\n     CondBr(cx, test, log_cx.llbb, after_cx.llbb);\n     let sub = trans_temp_expr(log_cx, e);\n     let e_ty = ty::expr_ty(bcx_tcx(cx), e);\n@@ -4440,6 +4501,7 @@ fn trans_fail(bcx: @block_ctxt, sp_opt: option::t<span>, fail_str: str) ->\n \n fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n                     V_fail_str: ValueRef) -> @block_ctxt {\n+    let ccx = bcx_ccx(bcx);\n     let V_filename;\n     let V_line;\n     alt sp_opt {\n@@ -4597,7 +4659,7 @@ fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n         let llsz = size_of(bcx, t);\n         // FIXME passing in the align here is correct, but causes issue #843\n         // let llalign = align_of(llsz.bcx, t);\n-        bcx = call_bzero(llsz.bcx, llptr, llsz.val, C_int(0)).bcx;\n+        bcx = call_bzero(llsz.bcx, llptr, llsz.val, C_int(ccx, 0)).bcx;\n     }\n     ret bcx;\n }\n@@ -5024,35 +5086,37 @@ fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n }\n \n fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n+    let ccx = fcx_ccx(fcx);\n     let bcx = llstaticallocas_block_ctxt(fcx);\n     let field_tys: [ty::t] = [];\n     for f: ast::obj_field in bcx.fcx.lcx.obj_fields {\n-        field_tys += [node_id_type(bcx_ccx(bcx), f.id)];\n+        field_tys += [node_id_type(ccx, f.id)];\n     }\n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n \n     let fields_tup_ty = ty::mk_tup(fcx.lcx.ccx.tcx, field_tys);\n     let n_typarams = std::vec::len::<ast::ty_param>(bcx.fcx.lcx.obj_typarams);\n-    let llobj_box_ty: TypeRef = T_obj_ptr(*bcx_ccx(bcx), n_typarams);\n-    let box_cell = GEP(bcx, llself.v, [C_int(0), C_int(abi::obj_field_box)]);\n+    let llobj_box_ty: TypeRef = T_obj_ptr(ccx, n_typarams);\n+    let box_cell = GEP(bcx, llself.v, [C_int(ccx, 0),\n+                                       C_int(ccx, abi::obj_field_box)]);\n     let box_ptr = Load(bcx, box_cell);\n     box_ptr = PointerCast(bcx, box_ptr, llobj_box_ty);\n     let obj_typarams =\n         GEP(bcx, box_ptr,\n-            [C_int(0), C_int(abi::box_rc_field_body),\n-             C_int(abi::obj_body_elt_typarams)]);\n+            [C_int(ccx, 0), C_int(ccx, abi::box_rc_field_body),\n+             C_int(ccx, abi::obj_body_elt_typarams)]);\n \n     // The object fields immediately follow the type parameters, so we skip\n     // over them to get the pointer.\n     let obj_fields =\n-        PointerCast(bcx, GEP(bcx, obj_typarams, [C_int(1)]),\n+        PointerCast(bcx, GEP(bcx, obj_typarams, [C_int(ccx, 1)]),\n                     T_ptr(type_of_or_i8(bcx, fields_tup_ty)));\n \n     let i: int = 0;\n     for p: ast::ty_param in fcx.lcx.obj_typarams {\n         let lltyparam: ValueRef =\n-            GEP(bcx, obj_typarams, [C_int(0), C_int(i)]);\n+            GEP(bcx, obj_typarams, [C_int(ccx, 0), C_int(ccx, i)]);\n         lltyparam = Load(bcx, lltyparam);\n         fcx.lltydescs += [lltyparam];\n         i += 1;\n@@ -5150,27 +5214,29 @@ fn trans_fn(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n \n fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n                   ctor_id: ast::node_id, ty_params: [ast::ty_param]) {\n+    let ccx = cx.ccx;\n+\n     // Create a function for the constructor\n     let llctor_decl;\n-    alt cx.ccx.item_ids.find(ctor_id) {\n+    alt ccx.item_ids.find(ctor_id) {\n       some(x) { llctor_decl = x; }\n-      _ { cx.ccx.sess.span_fatal(sp, \"unbound ctor_id in trans_res_ctor\"); }\n+      _ { ccx.sess.span_fatal(sp, \"unbound ctor_id in trans_res_ctor\"); }\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n     create_llargs_for_fn_args(fcx, none, dtor.decl.inputs, ty_params);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n-    let arg_t = arg_tys_of_fn(cx.ccx, ctor_id)[0].ty;\n-    let tup_t = ty::mk_tup(cx.ccx.tcx, [ty::mk_int(cx.ccx.tcx), arg_t]);\n+    let arg_t = arg_tys_of_fn(ccx, ctor_id)[0].ty;\n+    let tup_t = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), arg_t]);\n     let arg;\n     alt fcx.llargs.find(dtor.decl.inputs[0].id) {\n       some(local_mem(x)) { arg = load_if_immediate(bcx, x, arg_t); }\n       some(local_imm(x)) { arg = x; }\n-      _ { cx.ccx.sess.span_fatal(sp, \"unbound dtor decl in trans_res_ctor\"); }\n+      _ { ccx.sess.span_fatal(sp, \"unbound dtor decl in trans_res_ctor\"); }\n     }\n     let llretptr = fcx.llretptr;\n-    if ty::type_has_dynamic_size(cx.ccx.tcx, ret_t) {\n+    if ty::type_has_dynamic_size(ccx.tcx, ret_t) {\n         let llret_t = T_ptr(T_struct([T_i32(), llvm::LLVMTypeOf(arg)]));\n         llretptr = BitCast(bcx, llretptr, llret_t);\n     }\n@@ -5183,7 +5249,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n     check type_is_tup_like(bcx, tup_t);\n     let flag = GEP_tup_like(bcx, tup_t, llretptr, [0, 0]);\n     bcx = flag.bcx;\n-    Store(bcx, C_int(1), flag.val);\n+    Store(bcx, C_int(ccx, 1), flag.val);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n }\n@@ -5192,6 +5258,8 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n                      variant: ast::variant, index: int, is_degen: bool,\n                      ty_params: [ast::ty_param]) {\n+    let ccx = cx.ccx;\n+\n     if std::vec::len::<ast::variant_arg>(variant.node.args) == 0u {\n         ret; // nullary constructors are just constants\n \n@@ -5207,12 +5275,12 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n               ident: \"arg\" + uint::to_str(i, 10u),\n               id: varg.id}];\n     }\n-    assert (cx.ccx.item_ids.contains_key(variant.node.id));\n+    assert (ccx.item_ids.contains_key(variant.node.id));\n     let llfndecl: ValueRef;\n-    alt cx.ccx.item_ids.find(variant.node.id) {\n+    alt ccx.item_ids.find(variant.node.id) {\n       some(x) { llfndecl = x; }\n       _ {\n-        cx.ccx.sess.span_fatal(variant.span,\n+        ccx.sess.span_fatal(variant.span,\n                                \"unbound variant id in trans_tag_variant\");\n       }\n     }\n@@ -5221,11 +5289,11 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     let ty_param_substs: [ty::t] = [];\n     i = 0u;\n     for tp: ast::ty_param in ty_params {\n-        ty_param_substs += [ty::mk_param(cx.ccx.tcx, i,\n+        ty_param_substs += [ty::mk_param(ccx.tcx, i,\n                                          ast_util::ty_param_kind(tp))];\n         i += 1u;\n     }\n-    let arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);\n+    let arg_tys = arg_tys_of_fn(ccx, variant.node.id);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n@@ -5236,11 +5304,11 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n             fcx.llretptr\n         } else {\n             let lltagptr =\n-                PointerCast(bcx, fcx.llretptr,\n-                            T_opaque_tag_ptr(fcx.lcx.ccx.tn));\n-            let lldiscrimptr = GEP(bcx, lltagptr, [C_int(0), C_int(0)]);\n-            Store(bcx, C_int(index), lldiscrimptr);\n-            GEP(bcx, lltagptr, [C_int(0), C_int(1)])\n+                PointerCast(bcx, fcx.llretptr, T_opaque_tag_ptr(ccx));\n+            let lldiscrimptr = GEP(bcx, lltagptr, [C_int(ccx, 0),\n+                                                   C_int(ccx, 0)]);\n+            Store(bcx, C_int(ccx, index), lldiscrimptr);\n+            GEP(bcx, lltagptr, [C_int(ccx, 0), C_int(ccx, 1)])\n         };\n     i = 0u;\n     let t_id = ast_util::local_def(tag_id);\n@@ -5480,18 +5548,21 @@ fn create_real_fn_pair(cx: @block_ctxt, llfnty: TypeRef, llfn: ValueRef,\n                        llenvptr: ValueRef) -> ValueRef {\n     let lcx = cx.fcx.lcx;\n \n-    let pair = alloca(cx, T_fn_pair(*lcx.ccx, llfnty));\n+    let pair = alloca(cx, T_fn_pair(lcx.ccx, llfnty));\n     fill_fn_pair(cx, pair, llfn, llenvptr);\n     ret pair;\n }\n \n fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n                 llenvptr: ValueRef) {\n-    let code_cell = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n+    let ccx = bcx_ccx(bcx);\n+    let code_cell = GEP(bcx, pair, [C_int(ccx, 0),\n+                                    C_int(ccx, abi::fn_field_code)]);\n     Store(bcx, llfn, code_cell);\n-    let env_cell = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n+    let env_cell = GEP(bcx, pair, [C_int(ccx, 0),\n+                                   C_int(ccx, abi::fn_field_box)]);\n     let llenvblobptr =\n-        PointerCast(bcx, llenvptr, T_opaque_closure_ptr(*bcx_ccx(bcx)));\n+        PointerCast(bcx, llenvptr, T_opaque_closure_ptr(ccx));\n     Store(bcx, llenvblobptr, env_cell);\n }\n "}, {"sha": "290e81e754ebe95e9da94a9a9a40ddaa6b9ec697", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9146bb09a14a66044206119366231a5296612d8d/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146bb09a14a66044206119366231a5296612d8d/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=9146bb09a14a66044206119366231a5296612d8d", "patch": "@@ -302,10 +302,11 @@ fn Free(cx: @block_ctxt, PointerVal: ValueRef) {\n }\n \n fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n+    let ccx = cx.fcx.lcx.ccx;\n     if cx.unreachable {\n         let ty = val_ty(PointerVal);\n         let eltty = if llvm::LLVMGetTypeKind(ty) == 11 {\n-            llvm::LLVMGetElementType(ty) } else { T_int() };\n+            llvm::LLVMGetElementType(ty) } else { T_int(ccx) };\n         ret llvm::LLVMGetUndef(eltty);\n     }\n     ret llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n@@ -487,10 +488,11 @@ fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-fn _UndefReturn(Fn: ValueRef) -> ValueRef {\n+fn _UndefReturn(cx: @block_ctxt, Fn: ValueRef) -> ValueRef {\n+    let ccx = cx.fcx.lcx.ccx;\n     let ty = val_ty(Fn);\n     let retty = if llvm::LLVMGetTypeKind(ty) == 8 {\n-        llvm::LLVMGetReturnType(ty) } else { T_int() };\n+        llvm::LLVMGetReturnType(ty) } else { T_int(ccx) };\n     ret llvm::LLVMGetUndef(retty);\n }\n \n@@ -574,7 +576,8 @@ fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n }\n \n fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(T_int()); }\n+    let ccx = cx.fcx.lcx.ccx;\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_int(ccx)); }\n     ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n "}, {"sha": "9a303ba88fa293ec74bb4d8d378b5aedf1960708", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 67, "deletions": 56, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/9146bb09a14a66044206119366231a5296612d8d/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9146bb09a14a66044206119366231a5296612d8d/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=9146bb09a14a66044206119366231a5296612d8d", "patch": "@@ -488,23 +488,26 @@ fn T_f64() -> TypeRef { ret llvm::LLVMDoubleType(); }\n \n fn T_bool() -> TypeRef { ret T_i1(); }\n \n-fn T_int() -> TypeRef {\n-    // FIXME: switch on target type.\n-\n-    ret T_i32();\n+fn T_int(cx: @crate_ctxt) -> TypeRef {\n+    ret alt cx.sess.get_targ_cfg().arch {\n+      arch_x86 { T_i32() }\n+      arch_x86_64 { T_i64() }\n+      arch_arm { T_i32() }\n+    };\n }\n \n-fn T_float() -> TypeRef {\n-    // FIXME: switch on target type.\n-    ret T_f64();\n+fn T_float(cx: @crate_ctxt) -> TypeRef {\n+    ret alt cx.sess.get_targ_cfg().arch {\n+      arch_x86 { T_f64() }\n+      arch_x86_64 { T_f64() }\n+      arch_arm { T_f64() }\n+    };\n }\n \n fn T_char() -> TypeRef { ret T_i32(); }\n \n-fn T_size_t() -> TypeRef {\n-    // FIXME: switch on target type.\n-\n-    ret T_i32();\n+fn T_size_t(cx: @crate_ctxt) -> TypeRef {\n+    ret T_int(cx);\n }\n \n fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n@@ -514,7 +517,7 @@ fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n     }\n }\n \n-fn T_fn_pair(cx: crate_ctxt, tfn: TypeRef) -> TypeRef {\n+fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n     ret T_struct([T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n }\n \n@@ -548,7 +551,7 @@ fn T_rust_object() -> TypeRef {\n     ret t;\n }\n \n-fn T_task() -> TypeRef {\n+fn T_task(cx: @crate_ctxt) -> TypeRef {\n     let t = T_named_struct(\"task\");\n \n     // Refcount\n@@ -563,13 +566,13 @@ fn T_task() -> TypeRef {\n     // Crate cache pointer\n \n     let elems =\n-        [T_int(), T_int(), T_int(), T_int(), T_int(), T_int(), T_int(),\n-         T_int()];\n+        [T_int(cx), T_int(cx), T_int(cx), T_int(cx),\n+         T_int(cx), T_int(cx), T_int(cx), T_int(cx)];\n     set_struct_body(t, elems);\n     ret t;\n }\n \n-fn T_tydesc_field(cx: crate_ctxt, field: int) -> TypeRef unsafe {\n+fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] =\n@@ -581,23 +584,23 @@ fn T_tydesc_field(cx: crate_ctxt, field: int) -> TypeRef unsafe {\n     ret t;\n }\n \n-fn T_glue_fn(cx: crate_ctxt) -> TypeRef {\n+fn T_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = \"glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_cmp_glue_fn(cx: crate_ctxt) -> TypeRef {\n+fn T_cmp_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = \"cmp_glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_tydesc() -> TypeRef {\n+fn T_tydesc(cx: @crate_ctxt) -> TypeRef {\n     let tydesc = T_named_struct(\"tydesc\");\n     let tydescpp = T_ptr(T_ptr(tydesc));\n     let pvoid = T_ptr(T_i8());\n@@ -609,9 +612,9 @@ fn T_tydesc() -> TypeRef {\n                     pvoid, pvoid, T_i8()], T_void()));\n \n     let elems =\n-        [tydescpp, T_int(), T_int(), glue_fn_ty, glue_fn_ty, glue_fn_ty,\n+        [tydescpp, T_int(cx), T_int(cx), glue_fn_ty, glue_fn_ty, glue_fn_ty,\n          T_ptr(T_i8()), glue_fn_ty, glue_fn_ty, glue_fn_ty, cmp_glue_fn_ty,\n-         T_ptr(T_i8()), T_ptr(T_i8()), T_int(), T_int()];\n+         T_ptr(T_i8()), T_ptr(T_i8()), T_int(cx), T_int(cx)];\n     set_struct_body(tydesc, elems);\n     ret tydesc;\n }\n@@ -622,28 +625,30 @@ fn T_array(t: TypeRef, n: uint) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n // Interior vector.\n //\n // TODO: Support user-defined vector sizes.\n-fn T_vec(t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int(), // fill\n-                  T_int(), // alloc\n+fn T_vec(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+    ret T_struct([T_int(cx), // fill\n+                  T_int(cx), // alloc\n                   T_array(t, 0u)]); // elements\n }\n \n // Note that the size of this one is in bytes.\n-fn T_opaque_vec() -> TypeRef { ret T_vec(T_i8()); }\n+fn T_opaque_vec(cx: @crate_ctxt) -> TypeRef { ret T_vec(cx, T_i8()); }\n \n-fn T_box(t: TypeRef) -> TypeRef { ret T_struct([T_int(), t]); }\n+fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+    ret T_struct([T_int(cx), t]);\n+}\n \n-fn T_port(_t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int()]); // Refcount\n+fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n+    ret T_struct([T_int(cx)]); // Refcount\n \n }\n \n-fn T_chan(_t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int()]); // Refcount\n+fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n+    ret T_struct([T_int(cx)]); // Refcount\n \n }\n \n-fn T_taskptr(cx: crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n+fn T_taskptr(cx: @crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n@@ -657,62 +662,62 @@ fn T_typaram(tn: type_names) -> TypeRef {\n \n fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_closure_ptr(cx: crate_ctxt, llbindings_ty: TypeRef, n_ty_params: uint) ->\n-   TypeRef {\n+fn T_closure_ptr(cx: @crate_ctxt, llbindings_ty: TypeRef,\n+                 n_ty_params: uint) -> TypeRef {\n     // NB: keep this in sync with code in trans_bind; we're making\n     // an LLVM typeref structure that has the same \"shape\" as the ty::t\n     // it constructs.\n-    ret T_ptr(T_box(T_struct([T_ptr(cx.tydesc_type), llbindings_ty,\n-                              T_captured_tydescs(cx, n_ty_params)])));\n+    ret T_ptr(T_box(cx, T_struct([T_ptr(cx.tydesc_type), llbindings_ty,\n+                                  T_captured_tydescs(cx, n_ty_params)])));\n }\n \n-fn T_opaque_closure_ptr(cx: crate_ctxt) -> TypeRef {\n+fn T_opaque_closure_ptr(cx: @crate_ctxt) -> TypeRef {\n     let s = \"*closure\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_closure_ptr(cx, T_nil(), 0u);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_tag(tn: type_names, size: uint) -> TypeRef {\n+fn T_tag(cx: @crate_ctxt, size: uint) -> TypeRef {\n     let s = \"tag_\" + uint::to_str(size, 10u);\n-    if tn.name_has_type(s) { ret tn.get_type(s); }\n+    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t =\n         if size == 0u {\n-            T_struct([T_int()])\n-        } else { T_struct([T_int(), T_array(T_i8(), size)]) };\n-    tn.associate(s, t);\n+            T_struct([T_int(cx)])\n+        } else { T_struct([T_int(cx), T_array(T_i8(), size)]) };\n+    cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_opaque_tag(tn: type_names) -> TypeRef {\n+fn T_opaque_tag(cx: @crate_ctxt) -> TypeRef {\n     let s = \"opaque_tag\";\n-    if tn.name_has_type(s) { ret tn.get_type(s); }\n-    let t = T_struct([T_int(), T_i8()]);\n-    tn.associate(s, t);\n+    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    let t = T_struct([T_int(cx), T_i8()]);\n+    cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_opaque_tag_ptr(tn: type_names) -> TypeRef {\n-    ret T_ptr(T_opaque_tag(tn));\n+fn T_opaque_tag_ptr(cx: @crate_ctxt) -> TypeRef {\n+    ret T_ptr(T_opaque_tag(cx));\n }\n \n-fn T_captured_tydescs(cx: crate_ctxt, n: uint) -> TypeRef {\n+fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n     ret T_struct(std::vec::init_elt::<TypeRef>(T_ptr(cx.tydesc_type), n));\n }\n \n-fn T_obj_ptr(cx: crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n+fn T_obj_ptr(cx: @crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n     // This function is not publicly exposed because it returns an incomplete\n     // type. The dynamically-sized fields follow the captured tydescs.\n \n-    fn T_obj(cx: crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n+    fn T_obj(cx: @crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n         ret T_struct([T_ptr(cx.tydesc_type),\n                       T_captured_tydescs(cx, n_captured_tydescs)]);\n     }\n-    ret T_ptr(T_box(T_obj(cx, n_captured_tydescs)));\n+    ret T_ptr(T_box(cx, T_obj(cx, n_captured_tydescs)));\n }\n \n-fn T_opaque_obj_ptr(cx: crate_ctxt) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n+fn T_opaque_obj_ptr(cx: @crate_ctxt) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n \n fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n \n@@ -732,8 +737,10 @@ fn C_integral(t: TypeRef, u: uint, sign_extend: Bool) -> ValueRef {\n     ret llvm::LLVMRustConstSmallInt(t, u, sign_extend);\n }\n \n-fn C_float(s: str) -> ValueRef {\n-    ret str::as_buf(s, {|buf| llvm::LLVMConstRealOfString(T_float(), buf) });\n+fn C_float(cx: @crate_ctxt, s: str) -> ValueRef {\n+    ret str::as_buf(s, {|buf|\n+        llvm::LLVMConstRealOfString(T_float(cx), buf)\n+    });\n }\n \n fn C_floating(s: str, t: TypeRef) -> ValueRef {\n@@ -752,9 +759,13 @@ fn C_bool(b: bool) -> ValueRef {\n     } else { ret C_integral(T_bool(), 0u, False); }\n }\n \n-fn C_int(i: int) -> ValueRef { ret C_integral(T_int(), i as uint, True); }\n+fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n+    ret C_integral(T_int(cx), i as uint, True);\n+}\n \n-fn C_uint(i: uint) -> ValueRef { ret C_integral(T_int(), i, False); }\n+fn C_uint(cx: @crate_ctxt, i: uint) -> ValueRef {\n+    ret C_integral(T_int(cx), i, False);\n+}\n \n fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i, False); }\n "}]}