{"sha": "f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwOGMwY2RkMmE5OWQyODUxZDQ3MmQyYzZiM2Y1NGQzN2FhMTNlOGE=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-21T21:52:29Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:58:33Z"}, "message": "Simplify", "tree": {"sha": "732360ce99f12145c6fa7985ca79c07bbc1b0acf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/732360ce99f12145c6fa7985ca79c07bbc1b0acf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a", "html_url": "https://github.com/rust-lang/rust/commit/f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7584260b9a222658e3e38f1d2506da95e6106283", "url": "https://api.github.com/repos/rust-lang/rust/commits/7584260b9a222658e3e38f1d2506da95e6106283", "html_url": "https://github.com/rust-lang/rust/commit/7584260b9a222658e3e38f1d2506da95e6106283"}], "stats": {"total": 101, "additions": 37, "deletions": 64}, "files": [{"sha": "66e60b698ab5282902eb98280a98e8cf97a0ddfe", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 37, "deletions": 64, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a", "patch": "@@ -183,39 +183,41 @@ impl ImportAssets {\n     }\n \n     fn applicable_defs<'a>(\n-        &self,\n+        &'a self,\n         sema: &'a Semantics<RootDatabase>,\n         prefixed: Option<hir::PrefixKind>,\n-        unfiltered_imports: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n+        unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a,\n     ) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n         let current_crate = self.module_with_candidate.krate();\n         let db = sema.db;\n \n         match &self.import_candidate {\n-            ImportCandidate::Path(path_candidate) => path_applicable_defs(\n+            ImportCandidate::Path(path_candidate) => Box::new(path_applicable_defs(\n                 sema,\n                 path_candidate,\n-                unfiltered_imports,\n-                self.module_with_candidate,\n-                prefixed,\n-            ),\n-            ImportCandidate::TraitAssocItem(trait_candidate) => trait_applicable_defs(\n-                db,\n-                current_crate,\n-                trait_candidate,\n-                true,\n-                unfiltered_imports,\n-                self.module_with_candidate,\n-                prefixed,\n+                unfiltered_defs\n+                    .into_iter()\n+                    .map(|def| def.either(ItemInNs::from, ItemInNs::from))\n+                    .filter_map(move |item_to_search| {\n+                        get_mod_path(db, item_to_search, &self.module_with_candidate, prefixed)\n+                            .zip(Some(item_to_search))\n+                    }),\n+            )),\n+            ImportCandidate::TraitAssocItem(trait_candidate) => Box::new(\n+                trait_applicable_defs(db, current_crate, trait_candidate, true, unfiltered_defs)\n+                    .into_iter()\n+                    .filter_map(move |item_to_search| {\n+                        get_mod_path(db, item_to_search, &self.module_with_candidate, prefixed)\n+                            .zip(Some(item_to_search))\n+                    }),\n             ),\n-            ImportCandidate::TraitMethod(trait_candidate) => trait_applicable_defs(\n-                db,\n-                current_crate,\n-                trait_candidate,\n-                false,\n-                unfiltered_imports,\n-                self.module_with_candidate,\n-                prefixed,\n+            ImportCandidate::TraitMethod(trait_candidate) => Box::new(\n+                trait_applicable_defs(db, current_crate, trait_candidate, false, unfiltered_defs)\n+                    .into_iter()\n+                    .filter_map(move |item_to_search| {\n+                        get_mod_path(db, item_to_search, &self.module_with_candidate, prefixed)\n+                            .zip(Some(item_to_search))\n+                    }),\n             ),\n         }\n     }\n@@ -224,22 +226,12 @@ impl ImportAssets {\n fn path_applicable_defs<'a>(\n     sema: &'a Semantics<RootDatabase>,\n     path_candidate: &PathImportCandidate,\n-    unfiltered_defs: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n-    module_with_candidate: Module,\n-    prefixed: Option<hir::PrefixKind>,\n-) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n-    let applicable_defs = unfiltered_defs\n-        .map(|candidate| candidate.either(ItemInNs::from, ItemInNs::from))\n-        .filter_map(move |item_to_search| {\n-            get_mod_path(sema.db, item_to_search, &module_with_candidate, prefixed)\n-                .zip(Some(item_to_search))\n-        });\n-\n+    unfiltered_defs: impl Iterator<Item = (ModPath, ItemInNs)> + 'a,\n+) -> impl Iterator<Item = (ModPath, ItemInNs)> + 'a {\n     let unresolved_qualifier = match &path_candidate.unresolved_qualifier {\n         Some(qualifier) => qualifier,\n         None => {\n-            // TODO kb too many boxes tossed around\n-            return Box::new(applicable_defs);\n+            return unfiltered_defs;\n         }\n     };\n \n@@ -252,7 +244,7 @@ fn path_applicable_defs<'a>(\n         // first segment is already unresolved, need to turn it into ModuleDef somehow\n     }\n \n-    return Box::new(applicable_defs);\n+    return unfiltered_defs;\n }\n \n fn resolve_qualifier_start(\n@@ -269,10 +261,8 @@ fn trait_applicable_defs<'a>(\n     current_crate: Crate,\n     trait_candidate: &TraitImportCandidate,\n     trait_assoc_item: bool,\n-    unfiltered_defs: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n-    module_with_candidate: Module,\n-    prefixed: Option<hir::PrefixKind>,\n-) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n+    unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a,\n+) -> FxHashSet<ItemInNs> {\n     let mut required_assoc_items = FxHashSet::default();\n \n     let trait_candidates = unfiltered_defs\n@@ -287,7 +277,7 @@ fn trait_applicable_defs<'a>(\n         })\n         .collect();\n \n-    let mut applicable_defs = FxHashSet::default();\n+    let mut applicable_traits = FxHashSet::default();\n \n     if trait_assoc_item {\n         trait_candidate.receiver_ty.iterate_path_candidates(\n@@ -302,7 +292,8 @@ fn trait_applicable_defs<'a>(\n                             return None;\n                         }\n                     }\n-                    applicable_defs.insert(assoc_to_module_def(assoc));\n+                    applicable_traits\n+                        .insert(ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?)));\n                 }\n                 None::<()>\n             },\n@@ -316,25 +307,15 @@ fn trait_applicable_defs<'a>(\n             |_, function| {\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n-                    applicable_defs.insert(assoc_to_module_def(assoc));\n+                    applicable_traits\n+                        .insert(ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?)));\n                 }\n                 None::<()>\n             },\n         )\n     };\n \n-    Box::new(\n-        applicable_defs\n-            .into_iter()\n-            .filter_map(move |candidate| {\n-                let canidate_trait = candidate.as_assoc_item(db)?.containing_trait(db)?;\n-                Some(ItemInNs::from(ModuleDef::from(canidate_trait)))\n-            })\n-            .filter_map(move |item_to_search| {\n-                get_mod_path(db, item_to_search, &module_with_candidate, prefixed)\n-                    .zip(Some(item_to_search))\n-            }),\n-    )\n+    applicable_traits\n }\n \n fn get_mod_path(\n@@ -350,14 +331,6 @@ fn get_mod_path(\n     }\n }\n \n-fn assoc_to_module_def(assoc: AssocItem) -> ModuleDef {\n-    match assoc {\n-        AssocItem::Function(f) => f.into(),\n-        AssocItem::Const(c) => c.into(),\n-        AssocItem::TypeAlias(t) => t.into(),\n-    }\n-}\n-\n impl ImportCandidate {\n     fn for_method_call(\n         sema: &Semantics<RootDatabase>,"}]}