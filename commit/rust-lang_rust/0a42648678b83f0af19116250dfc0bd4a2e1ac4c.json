{"sha": "0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNDI2NDg2NzhiODNmMGFmMTkxMTYyNTBkZmMwYmQ0YTJlMWFjNGM=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-07-10T04:22:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-10T04:22:01Z"}, "message": "Merge pull request #1775 from topecongiro/rfc/patterns\n\nRFC: patterns in condition and match arm", "tree": {"sha": "96323b718c3563898c04076422e7d211351f2cc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96323b718c3563898c04076422e7d211351f2cc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "html_url": "https://github.com/rust-lang/rust/commit/0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed90489871777b3a51eeb6402b8a62ddcabed3e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed90489871777b3a51eeb6402b8a62ddcabed3e5", "html_url": "https://github.com/rust-lang/rust/commit/ed90489871777b3a51eeb6402b8a62ddcabed3e5"}, {"sha": "78224a0644249b45fc033b230dd91389a9bbed19", "url": "https://api.github.com/repos/rust-lang/rust/commits/78224a0644249b45fc033b230dd91389a9bbed19", "html_url": "https://github.com/rust-lang/rust/commit/78224a0644249b45fc033b230dd91389a9bbed19"}], "stats": {"total": 358, "additions": 162, "deletions": 196}, "files": [{"sha": "9a7c9680a5c2c54c5e48468d6183755fc15ad871", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -155,8 +155,13 @@ enum TargetKind {\n impl TargetKind {\n     fn should_format(&self) -> bool {\n         match *self {\n-            TargetKind::Lib | TargetKind::Bin | TargetKind::Example | TargetKind::Test |\n-            TargetKind::Bench | TargetKind::CustomBuild | TargetKind::ProcMacro => true,\n+            TargetKind::Lib |\n+            TargetKind::Bin |\n+            TargetKind::Example |\n+            TargetKind::Test |\n+            TargetKind::Bench |\n+            TargetKind::CustomBuild |\n+            TargetKind::ProcMacro => true,\n             _ => false,\n         }\n     }"}, {"sha": "4e606369eb96f20f5e14b4c866daa265a0c2c761", "filename": "src/chains.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -390,8 +390,9 @@ fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) ->\n // parens, braces, and brackets in its idiomatic formatting.\n fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n-        ast::ExprKind::Mac(..) |\n-        ast::ExprKind::Call(..) => context.use_block_indent() && repr.contains('\\n'),\n+        ast::ExprKind::Mac(..) | ast::ExprKind::Call(..) => {\n+            context.use_block_indent() && repr.contains('\\n')\n+        }\n         ast::ExprKind::Struct(..) |\n         ast::ExprKind::While(..) |\n         ast::ExprKind::WhileLet(..) |"}, {"sha": "123df4927f41e14efbad75ac6e230c12df9e2329", "filename": "src/comment.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -71,8 +71,7 @@ impl<'a> CommentStyle<'a> {\n             CommentStyle::Custom(..) |\n             CommentStyle::Doc => \"\",\n             CommentStyle::DoubleBullet => \" **/\",\n-            CommentStyle::SingleBullet |\n-            CommentStyle::Exclamation => \" */\",\n+            CommentStyle::SingleBullet | CommentStyle::Exclamation => \" */\",\n         }\n     }\n \n@@ -81,8 +80,7 @@ impl<'a> CommentStyle<'a> {\n             CommentStyle::DoubleSlash => \"// \",\n             CommentStyle::TripleSlash => \"/// \",\n             CommentStyle::Doc => \"//! \",\n-            CommentStyle::SingleBullet |\n-            CommentStyle::Exclamation => \" * \",\n+            CommentStyle::SingleBullet | CommentStyle::Exclamation => \" * \",\n             CommentStyle::DoubleBullet => \" ** \",\n             CommentStyle::Custom(opener) => opener,\n         }\n@@ -94,15 +92,11 @@ impl<'a> CommentStyle<'a> {\n \n     pub fn line_with_same_comment_style(&self, line: &str, normalize_comments: bool) -> bool {\n         match *self {\n-            CommentStyle::DoubleSlash |\n-            CommentStyle::TripleSlash |\n-            CommentStyle::Doc => {\n+            CommentStyle::DoubleSlash | CommentStyle::TripleSlash | CommentStyle::Doc => {\n                 line.trim_left().starts_with(self.line_start().trim_left()) ||\n                     comment_style(line, normalize_comments) == *self\n             }\n-            CommentStyle::DoubleBullet |\n-            CommentStyle::SingleBullet |\n-            CommentStyle::Exclamation => {\n+            CommentStyle::DoubleBullet | CommentStyle::SingleBullet | CommentStyle::Exclamation => {\n                 line.trim_left().starts_with(self.closer().trim_left()) ||\n                     line.trim_left().starts_with(self.line_start().trim_left()) ||\n                     comment_style(line, normalize_comments) == *self"}, {"sha": "fa72e2b85d56982e5499063cb065a9a1f1b7f418", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -98,8 +98,7 @@ impl Density {\n     pub fn to_list_tactic(self) -> ListTactic {\n         match self {\n             Density::Compressed => ListTactic::Mixed,\n-            Density::Tall |\n-            Density::CompressedIfEmpty => ListTactic::HorizontalVertical,\n+            Density::Tall | Density::CompressedIfEmpty => ListTactic::HorizontalVertical,\n             Density::Vertical => ListTactic::Vertical,\n         }\n     }"}, {"sha": "b214a42a3dbf9906ac6d37ba5b3244e1a07a85a8", "filename": "src/expr.rs", "status": "modified", "additions": 77, "deletions": 110, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -315,8 +315,7 @@ pub fn format_expr(\n         }\n         // We do not format these expressions yet, but they should still\n         // satisfy our width restrictions.\n-        ast::ExprKind::InPlace(..) |\n-        ast::ExprKind::InlineAsm(..) => {\n+        ast::ExprKind::InPlace(..) | ast::ExprKind::InlineAsm(..) => {\n             wrap_str(\n                 context.snippet(expr.span),\n                 context.config.max_width(),\n@@ -419,11 +418,7 @@ where\n         }\n         Style::Rfc => {\n             // Try to calculate the initial constraint on the right hand side.\n-            let rhs_overhead = context\n-                .config\n-                .max_width()\n-                .checked_sub(shape.used_width() + shape.width)\n-                .unwrap_or(0);\n+            let rhs_overhead = shape.rhs_overhead(context.config);\n             try_opt!(\n                 Shape::indented(shape.indent.block_indent(context.config), context.config)\n                     .sub_width(rhs_overhead)\n@@ -934,8 +929,7 @@ impl Rewrite for ast::Stmt {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let result = match self.node {\n             ast::StmtKind::Local(ref local) => local.rewrite(context, shape),\n-            ast::StmtKind::Expr(ref ex) |\n-            ast::StmtKind::Semi(ref ex) => {\n+            ast::StmtKind::Expr(ref ex) | ast::StmtKind::Semi(ref ex) => {\n                 let suffix = if semicolon_for_stmt(self) { \";\" } else { \"\" };\n \n                 format_expr(\n@@ -949,8 +943,7 @@ impl Rewrite for ast::Stmt {\n                     try_opt!(shape.sub_width(suffix.len())),\n                 ).map(|s| s + suffix)\n             }\n-            ast::StmtKind::Mac(..) |\n-            ast::StmtKind::Item(..) => None,\n+            ast::StmtKind::Mac(..) | ast::StmtKind::Item(..) => None,\n         };\n         result.and_then(|res| {\n             recover_comment_removed(res, self.span, context, shape)\n@@ -1408,8 +1401,9 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n             let between_sep = match context.config.control_brace_style() {\n-                ControlBraceStyle::AlwaysNextLine |\n-                ControlBraceStyle::ClosingNextLine => &*alt_block_sep,\n+                ControlBraceStyle::AlwaysNextLine | ControlBraceStyle::ClosingNextLine => {\n+                    &*alt_block_sep\n+                }\n                 ControlBraceStyle::AlwaysSameLine => \" \",\n             };\n             let after_sep = match context.config.control_brace_style() {\n@@ -1691,14 +1685,14 @@ impl Rewrite for ast::Arm {\n                 .collect::<Option<Vec<_>>>()\n         );\n \n-        let all_simple = pat_strs.iter().all(|p| pat_is_simple(p));\n+        let all_simple = pat_strs.iter().all(|p| !p.contains('\\n'));\n         let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n+        let mut tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, pat_shape.width);\n+        if tactic == DefinitiveListTactic::Horizontal && all_simple {\n+            tactic = DefinitiveListTactic::Mixed;\n+        }\n         let fmt = ListFormatting {\n-            tactic: if all_simple {\n-                DefinitiveListTactic::Mixed\n-            } else {\n-                DefinitiveListTactic::Vertical\n-            },\n+            tactic: tactic,\n             separator: \" |\",\n             trailing_separator: SeparatorTactic::Never,\n             shape: pat_shape,\n@@ -1733,9 +1727,10 @@ impl Rewrite for ast::Arm {\n                 }\n             }\n             ast::ExprKind::Call(_, ref args) => (args.len() == 1, &**body),\n-            ast::ExprKind::Closure(..) |\n-            ast::ExprKind::Struct(..) |\n-            ast::ExprKind::Tup(..) => (true, &**body),\n+            ast::ExprKind::Closure(..) | ast::ExprKind::Struct(..) | ast::ExprKind::Tup(..) => (\n+                true,\n+                &**body,\n+            ),\n             _ => (false, &**body),\n         };\n         extend &= context.use_block_indent();\n@@ -1840,13 +1835,6 @@ impl Rewrite for ast::Arm {\n     }\n }\n \n-// A pattern is simple if it is very short or it is short-ish and just a path.\n-// E.g. `Foo::Bar` is simple, but `Foo(..)` is not.\n-fn pat_is_simple(pat_str: &str) -> bool {\n-    pat_str.len() <= 16 ||\n-        (pat_str.len() <= 24 && pat_str.chars().all(|c| c.is_alphabetic() || c == ':'))\n-}\n-\n // The `if ...` guard on a match arm.\n fn rewrite_guard(\n     context: &RewriteContext,\n@@ -1910,55 +1898,34 @@ fn rewrite_pat_expr(\n     shape: Shape,\n ) -> Option<String> {\n     debug!(\"rewrite_pat_expr {:?} {:?} {:?}\", shape, pat, expr);\n-    let mut pat_string = String::new();\n-    let mut result = match pat {\n-        Some(pat) => {\n-            let matcher = if matcher.is_empty() {\n-                matcher.to_owned()\n-            } else {\n-                format!(\"{} \", matcher)\n-            };\n-            let pat_shape =\n-                try_opt!(try_opt!(shape.offset_left(matcher.len())).sub_width(connector.len()));\n-            pat_string = try_opt!(pat.rewrite(context, pat_shape));\n-            format!(\"{}{}{}\", matcher, pat_string, connector)\n-        }\n-        None => String::new(),\n-    };\n-\n-    // Consider only the last line of the pat string.\n-    let extra_offset = extra_offset(&result, shape);\n-\n-    // The expression may (partially) fit on the current line.\n-    if shape.width > extra_offset + 1 {\n-        let spacer = if pat.is_some() { \" \" } else { \"\" };\n-\n-        let expr_shape = try_opt!(shape.offset_left(extra_offset + spacer.len()));\n-        let expr_rewrite = expr.rewrite(context, expr_shape);\n-\n-        if let Some(expr_string) = expr_rewrite {\n-            if pat.is_none() || pat_is_simple(&pat_string) || !expr_string.contains('\\n') {\n-                result.push_str(spacer);\n-                result.push_str(&expr_string);\n-                return Some(result);\n-            }\n-        }\n+    if let Some(pat) = pat {\n+        let matcher = if matcher.is_empty() {\n+            matcher.to_owned()\n+        } else {\n+            format!(\"{} \", matcher)\n+        };\n+        let pat_shape =\n+            try_opt!(try_opt!(shape.offset_left(matcher.len())).sub_width(connector.len()));\n+        let pat_string = try_opt!(pat.rewrite(context, pat_shape));\n+        let result = format!(\"{}{}{}\", matcher, pat_string, connector);\n+        return rewrite_assign_rhs(context, result, expr, shape);\n     }\n \n-    if pat.is_none() && keyword == \"if\" {\n-        return None;\n+    let expr_rw = expr.rewrite(context, shape);\n+    // The expression may (partially) fit on the current line.\n+    // We do not allow splitting between `if` and condition.\n+    if keyword == \"if\" || expr_rw.is_some() {\n+        return expr_rw;\n     }\n \n-    let nested_indent = shape.indent.block_only().block_indent(context.config);\n-\n     // The expression won't fit on the current line, jump to next.\n-    result.push('\\n');\n-    result.push_str(&nested_indent.to_string(context.config));\n-\n-    let expr_rewrite = expr.rewrite(&context, Shape::indented(nested_indent, context.config));\n-    result.push_str(&try_opt!(expr_rewrite));\n-\n-    Some(result)\n+    let nested_shape = shape\n+        .block()\n+        .block_indent(context.config.tab_spaces())\n+        .with_max_width(context.config);\n+    let nested_indent_str = nested_shape.indent.to_string(context.config);\n+    expr.rewrite(context, nested_shape)\n+        .map(|expr_rw| format!(\"\\n{}{}\", nested_indent_str, expr_rw))\n }\n \n fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Option<String> {\n@@ -2434,8 +2401,7 @@ pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_l\n         ast::ExprKind::WhileLet(..) => {\n             context.config.combine_control_expr() && context.use_block_indent() && args_len == 1\n         }\n-        ast::ExprKind::Block(..) |\n-        ast::ExprKind::Closure(..) => {\n+        ast::ExprKind::Block(..) | ast::ExprKind::Closure(..) => {\n             context.use_block_indent() ||\n                 context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n         }\n@@ -2543,12 +2509,8 @@ fn rewrite_index(\n     }\n \n     // Try putting index on the next line and see if it fits in a single line.\n-    let indent = shape.indent.block_indent(&context.config);\n-    let rhs_overhead = context\n-        .config\n-        .max_width()\n-        .checked_sub(shape.used_width() + shape.width)\n-        .unwrap_or(0);\n+    let indent = shape.indent.block_indent(context.config);\n+    let rhs_overhead = shape.rhs_overhead(context.config);\n     let index_shape = try_opt!(Shape::indented(indent, context.config).offset_left(lbr.len()));\n     let index_shape = try_opt!(index_shape.sub_width(rbr.len() + rhs_overhead));\n     let new_index_rw = index.rewrite(context, index_shape);\n@@ -2950,49 +2912,54 @@ pub fn rewrite_assign_rhs<S: Into<String>>(\n     ex: &ast::Expr,\n     shape: Shape,\n ) -> Option<String> {\n-    let mut result = lhs.into();\n-    let last_line_width = last_line_width(&result) -\n-        if result.contains('\\n') {\n+    let lhs = lhs.into();\n+    let last_line_width = last_line_width(&lhs) -\n+        if lhs.contains('\\n') {\n             shape.indent.width()\n         } else {\n             0\n         };\n     // 1 = space between operator and rhs.\n     let orig_shape = try_opt!(shape.offset_left(last_line_width + 1));\n-    let rhs = ex.rewrite(context, orig_shape);\n+    let rhs = try_opt!(choose_rhs(\n+        context,\n+        ex,\n+        shape,\n+        ex.rewrite(context, orig_shape)\n+    ));\n+    Some(lhs + &rhs)\n+}\n \n-    match rhs {\n-        Some(ref new_str) if !new_str.contains('\\n') => {\n-            result.push(' ');\n-            result.push_str(new_str);\n-        }\n+fn choose_rhs(\n+    context: &RewriteContext,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+    orig_rhs: Option<String>,\n+) -> Option<String> {\n+    match orig_rhs {\n+        Some(ref new_str) if !new_str.contains('\\n') => Some(format!(\" {}\", new_str)),\n         _ => {\n             // Expression did not fit on the same line as the identifier.\n             // Try splitting the line and see if that works better.\n-            let new_shape = try_opt!(shape.block_left(context.config.tab_spaces()));\n-            let new_rhs = ex.rewrite(context, new_shape);\n-\n-            // FIXME: DRY!\n-            match (rhs, new_rhs) {\n-                (Some(ref orig_rhs), Some(ref replacement_rhs))\n-                    if prefer_next_line(orig_rhs, replacement_rhs) => {\n-                    result.push_str(&format!(\"\\n{}\", new_shape.indent.to_string(context.config)));\n-                    result.push_str(replacement_rhs);\n-                }\n-                (None, Some(ref final_rhs)) => {\n-                    result.push_str(&format!(\"\\n{}\", new_shape.indent.to_string(context.config)));\n-                    result.push_str(final_rhs);\n-                }\n-                (None, None) => return None,\n-                (Some(ref orig_rhs), _) => {\n-                    result.push(' ');\n-                    result.push_str(orig_rhs);\n+            let new_shape = try_opt!(\n+                Shape::indented(\n+                    shape.block().indent.block_indent(context.config),\n+                    context.config,\n+                ).sub_width(shape.rhs_overhead(context.config))\n+            );\n+            let new_rhs = expr.rewrite(context, new_shape);\n+            let new_indent_str = &new_shape.indent.to_string(context.config);\n+\n+            match (orig_rhs, new_rhs) {\n+                (Some(ref orig_rhs), Some(ref new_rhs)) if prefer_next_line(orig_rhs, new_rhs) => {\n+                    Some(format!(\"\\n{}{}\", new_indent_str, new_rhs))\n                 }\n+                (None, Some(ref new_rhs)) => Some(format!(\"\\n{}{}\", new_indent_str, new_rhs)),\n+                (None, None) => None,\n+                (Some(ref orig_rhs), _) => Some(format!(\" {}\", orig_rhs)),\n             }\n         }\n     }\n-\n-    Some(result)\n }\n \n fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str) -> bool {"}, {"sha": "87299f01574719463f934ed41bb01ca78aa551cd", "filename": "src/items.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -517,8 +517,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let variant_body = match field.node.data {\n-            ast::VariantData::Tuple(..) |\n-            ast::VariantData::Struct(..) => {\n+            ast::VariantData::Tuple(..) | ast::VariantData::Struct(..) => {\n                 // FIXME: Should limit the width, as we have a trailing comma\n                 format_struct(\n                     &context,\n@@ -732,16 +731,15 @@ fn format_impl_ref_and_type(\n \n         if let Some(ref trait_ref) = *trait_ref {\n             let result_len = result.len();\n-            if let Some(trait_ref_str) =\n-                rewrite_trait_ref(\n-                    context,\n-                    &trait_ref,\n-                    offset,\n-                    &generics_str,\n-                    true,\n-                    polarity_str,\n-                    result_len,\n-                ) {\n+            if let Some(trait_ref_str) = rewrite_trait_ref(\n+                context,\n+                &trait_ref,\n+                offset,\n+                &generics_str,\n+                true,\n+                polarity_str,\n+                result_len,\n+            ) {\n                 result.push_str(&trait_ref_str);\n             } else {\n                 let generics_str = try_opt!(rewrite_generics_inner(\n@@ -2062,18 +2060,17 @@ fn rewrite_fn_base(\n                 .max_width()\n                 .checked_sub(last_line_width(&result))\n         );\n-        if let Some(where_clause_str) =\n-            rewrite_where_clause(\n-                context,\n-                where_clause,\n-                context.config.fn_brace_style(),\n-                Shape::legacy(budget, indent),\n-                Density::Compressed,\n-                \"{\",\n-                !has_braces,\n-                put_args_in_block && ret_str.is_empty(),\n-                Some(span.hi),\n-            ) {\n+        if let Some(where_clause_str) = rewrite_where_clause(\n+            context,\n+            where_clause,\n+            context.config.fn_brace_style(),\n+            Shape::legacy(budget, indent),\n+            Density::Compressed,\n+            \"{\",\n+            !has_braces,\n+            put_args_in_block && ret_str.is_empty(),\n+            Some(span.hi),\n+        ) {\n             if !where_clause_str.contains('\\n') {\n                 if last_line_width(&result) + where_clause_str.len() > context.config.max_width() {\n                     result.push('\\n');\n@@ -2628,8 +2625,7 @@ fn rewrite_where_clause(\n         // If the brace is on the next line we don't need to count it otherwise it needs two\n         // characters \" {\"\n         match brace_style {\n-            BraceStyle::AlwaysNextLine |\n-            BraceStyle::SameLineWhere => 0,\n+            BraceStyle::AlwaysNextLine | BraceStyle::SameLineWhere => 0,\n             BraceStyle::PreferSameLine => 2,\n         }\n     } else if terminator == \"=\" {"}, {"sha": "a8bade234421027c815084eed72698e1332afc9d", "filename": "src/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -363,6 +363,13 @@ impl Shape {\n     pub fn used_width(&self) -> usize {\n         self.indent.block_indent + self.offset\n     }\n+\n+    pub fn rhs_overhead(&self, config: &Config) -> usize {\n+        config\n+            .max_width()\n+            .checked_sub(self.used_width() + self.width)\n+            .unwrap_or(0)\n+    }\n }\n \n pub enum ErrorKind {\n@@ -400,16 +407,14 @@ pub struct FormattingError {\n impl FormattingError {\n     fn msg_prefix(&self) -> &str {\n         match self.kind {\n-            ErrorKind::LineOverflow(..) |\n-            ErrorKind::TrailingWhitespace => \"Rustfmt failed at\",\n+            ErrorKind::LineOverflow(..) | ErrorKind::TrailingWhitespace => \"Rustfmt failed at\",\n             ErrorKind::BadIssue(_) => \"WARNING:\",\n         }\n     }\n \n     fn msg_suffix(&self) -> &str {\n         match self.kind {\n-            ErrorKind::LineOverflow(..) |\n-            ErrorKind::TrailingWhitespace => \"(sorry)\",\n+            ErrorKind::LineOverflow(..) | ErrorKind::TrailingWhitespace => \"(sorry)\",\n             ErrorKind::BadIssue(_) => \"\",\n         }\n     }"}, {"sha": "2fce2b7ccadcc82ce0f7bb043bc4f6c30f556410", "filename": "src/patterns.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -252,11 +252,10 @@ pub fn can_be_overflowed_pat(context: &RewriteContext, pat: &TuplePatField, len:\n     match pat {\n         &TuplePatField::Pat(ref pat) => {\n             match pat.node {\n-                ast::PatKind::Path(..) |\n-                ast::PatKind::Tuple(..) |\n-                ast::PatKind::Struct(..) => context.use_block_indent() && len == 1,\n-                ast::PatKind::Ref(ref p, _) |\n-                ast::PatKind::Box(ref p) => {\n+                ast::PatKind::Path(..) | ast::PatKind::Tuple(..) | ast::PatKind::Struct(..) => {\n+                    context.use_block_indent() && len == 1\n+                }\n+                ast::PatKind::Ref(ref p, _) | ast::PatKind::Box(ref p) => {\n                     can_be_overflowed_pat(context, &TuplePatField::Pat(p), len)\n                 }\n                 ast::PatKind::Lit(ref expr) => can_be_overflowed_expr(context, expr, len),"}, {"sha": "b617c433f106699b986ee1b3b2f86591f3630157", "filename": "src/types.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -758,8 +758,7 @@ impl Rewrite for ast::Ty {\n                 it.rewrite(context, shape)\n                     .map(|it_str| format!(\"impl {}\", it_str))\n             }\n-            ast::TyKind::Err |\n-            ast::TyKind::Typeof(..) => unreachable!(),\n+            ast::TyKind::Err | ast::TyKind::Typeof(..) => unreachable!(),\n         }\n     }\n }\n@@ -837,10 +836,10 @@ pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &Vec<Strin\n \n pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize) -> bool {\n     match ty.node {\n-        ast::TyKind::Path(..) |\n-        ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n-        ast::TyKind::Rptr(_, ref mutty) |\n-        ast::TyKind::Ptr(ref mutty) => can_be_overflowed_type(context, &*mutty.ty, len),\n+        ast::TyKind::Path(..) | ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n+        ast::TyKind::Rptr(_, ref mutty) | ast::TyKind::Ptr(ref mutty) => {\n+            can_be_overflowed_type(context, &*mutty.ty, len)\n+        }\n         _ => false,\n     }\n }"}, {"sha": "7873cd5d846d1642d4178cdd4315404ea8eab889", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -160,9 +160,7 @@ pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n #[inline]\n pub fn semicolon_for_expr(expr: &ast::Expr) -> bool {\n     match expr.node {\n-        ast::ExprKind::Ret(..) |\n-        ast::ExprKind::Continue(..) |\n-        ast::ExprKind::Break(..) => true,\n+        ast::ExprKind::Ret(..) | ast::ExprKind::Continue(..) | ast::ExprKind::Break(..) => true,\n         _ => false,\n     }\n }"}, {"sha": "178f7c7691f0e2d521831a6aca4b07d05cce5e45", "filename": "src/visitor.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -307,23 +307,18 @@ impl<'a> FmtVisitor<'a> {\n                 let where_span_end = snippet\n                     .find_uncommented(\"{\")\n                     .map(|x| (BytePos(x as u32)) + source!(self, item.span).lo);\n-                if let Some(impl_str) = format_impl(\n-                    &self.get_context(),\n-                    item,\n-                    self.block_indent,\n-                    where_span_end,\n-                ) {\n+                if let Some(impl_str) =\n+                    format_impl(&self.get_context(), item, self.block_indent, where_span_end)\n+                {\n                     self.buffer.push_str(&impl_str);\n                     self.last_pos = source!(self, item.span).hi;\n                 }\n             }\n             ast::ItemKind::Trait(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                if let Some(trait_str) = format_trait(\n-                    &self.get_context(),\n-                    item,\n-                    self.block_indent,\n-                ) {\n+                if let Some(trait_str) =\n+                    format_trait(&self.get_context(), item, self.block_indent)\n+                {\n                     self.buffer.push_str(&trait_str);\n                     self.last_pos = source!(self, item.span).hi;\n                 }"}, {"sha": "c291eca34e208b11cde248c54b88c5a8ab33c18d", "filename": "tests/target/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -48,8 +48,8 @@ fn foo() -> bool {\n         // Nothing\n     }\n \n-    if let Some(x) = (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-                          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\n+    if let Some(x) =\n+        (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\n     {}\n \n     if let ("}, {"sha": "bd6376f5153ca250aa591f506a8663c1ce16a423", "filename": "tests/target/match.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a42648678b83f0af19116250dfc0bd4a2e1ac4c/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=0a42648678b83f0af19116250dfc0bd4a2e1ac4c", "patch": "@@ -24,14 +24,13 @@ fn foo() {\n         Patternnnnnnnnnnnnnnnnnnn |\n         Patternnnnnnnnnnnnnnnnnnn => meh,\n \n-        Patternnnnnnnnnnnnnnnnnnn |\n-        Patternnnnnnnnnnnnnnnnnnn if looooooooooooooooooong_guard => meh,\n-\n-        Patternnnnnnnnnnnnnnnnnnnnnnnnn |\n-        Patternnnnnnnnnnnnnnnnnnnnnnnnn if looooooooooooooooooooooooooooooooooooooooong_guard => {\n+        Patternnnnnnnnnnnnnnnnnnn | Patternnnnnnnnnnnnnnnnnnn if looooooooooooooooooong_guard => {\n             meh\n         }\n \n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn | Patternnnnnnnnnnnnnnnnnnnnnnnnn\n+            if looooooooooooooooooooooooooooooooooooooooong_guard => meh,\n+\n         // Test that earlier patterns can take the guard space\n         (aaaa, bbbbb, ccccccc, aaaaa, bbbbbbbb, cccccc, aaaa, bbbbbbbb, cccccc, dddddd) |\n         Patternnnnnnnnnnnnnnnnnnnnnnnnn if loooooooooooooooooooooooooooooooooooooooooong_guard => {}\n@@ -230,8 +229,9 @@ fn issue355() {\n fn issue280() {\n     {\n         match x {\n-            CompressionMode::DiscardNewline |\n-            CompressionMode::CompressWhitespaceNewline => ch == '\\n',\n+            CompressionMode::DiscardNewline | CompressionMode::CompressWhitespaceNewline => {\n+                ch == '\\n'\n+            }\n             ast::ItemConst(ref typ, ref expr) => {\n                 self.process_static_or_const_item(item, &typ, &expr)\n             }\n@@ -270,8 +270,7 @@ fn issue496() {\n         {\n             {\n                 match def {\n-                    def::DefConst(def_id) |\n-                    def::DefAssociatedConst(def_id) => {\n+                    def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n                         match const_eval::lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n                             Some(const_expr) => x,\n                         }\n@@ -285,8 +284,7 @@ fn issue496() {\n fn issue494() {\n     {\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) |\n-            hir::StmtSemi(ref expr, id) => {\n+            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n@@ -302,8 +300,18 @@ fn issue494() {\n fn issue386() {\n     match foo {\n         BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n-        BiAnd | BiOr | BiAdd | BiSub | BiMul | BiDiv | BiRem | BiBitXor | BiBitAnd | BiBitOr |\n-        BiShl | BiShr => false,\n+        BiAnd |\n+        BiOr |\n+        BiAdd |\n+        BiSub |\n+        BiMul |\n+        BiDiv |\n+        BiRem |\n+        BiBitXor |\n+        BiBitAnd |\n+        BiBitOr |\n+        BiShl |\n+        BiShr => false,\n     }\n }\n "}]}