{"sha": "d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZmU5N2YzZDMyYjRjZWYxYzIyYjZhNWJhNTMyNmIxYjE5NWUyNjI=", "commit": {"author": {"name": "Donato Sciarra", "email": "sciarp@gmail.com", "date": "2018-08-18T10:14:09Z"}, "committer": {"name": "Donato Sciarra", "email": "sciarp@gmail.com", "date": "2018-08-19T21:01:01Z"}, "message": "mv codemap() source_map()", "tree": {"sha": "ec538787f89f8b43016f8e799bfd7ff9762add48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec538787f89f8b43016f8e799bfd7ff9762add48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "html_url": "https://github.com/rust-lang/rust/commit/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/comments", "author": {"login": "dsciarra", "id": 2036702, "node_id": "MDQ6VXNlcjIwMzY3MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2036702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dsciarra", "html_url": "https://github.com/dsciarra", "followers_url": "https://api.github.com/users/dsciarra/followers", "following_url": "https://api.github.com/users/dsciarra/following{/other_user}", "gists_url": "https://api.github.com/users/dsciarra/gists{/gist_id}", "starred_url": "https://api.github.com/users/dsciarra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dsciarra/subscriptions", "organizations_url": "https://api.github.com/users/dsciarra/orgs", "repos_url": "https://api.github.com/users/dsciarra/repos", "events_url": "https://api.github.com/users/dsciarra/events{/privacy}", "received_events_url": "https://api.github.com/users/dsciarra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dsciarra", "id": 2036702, "node_id": "MDQ6VXNlcjIwMzY3MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2036702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dsciarra", "html_url": "https://github.com/dsciarra", "followers_url": "https://api.github.com/users/dsciarra/followers", "following_url": "https://api.github.com/users/dsciarra/following{/other_user}", "gists_url": "https://api.github.com/users/dsciarra/gists{/gist_id}", "starred_url": "https://api.github.com/users/dsciarra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dsciarra/subscriptions", "organizations_url": "https://api.github.com/users/dsciarra/orgs", "repos_url": "https://api.github.com/users/dsciarra/repos", "events_url": "https://api.github.com/users/dsciarra/events{/privacy}", "received_events_url": "https://api.github.com/users/dsciarra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82607d2cf3866c7cc31050548f2fbfa39207e319", "url": "https://api.github.com/repos/rust-lang/rust/commits/82607d2cf3866c7cc31050548f2fbfa39207e319", "html_url": "https://github.com/rust-lang/rust/commit/82607d2cf3866c7cc31050548f2fbfa39207e319"}], "stats": {"total": 418, "additions": 209, "deletions": 209}, "files": [{"sha": "31aad29d0830906fbf96cdcac0c951c0b953a90b", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -1186,7 +1186,7 @@ pub mod __internal {\n     use super::{TokenStream, LexError, Span};\n \n     pub fn lookup_char_pos(pos: BytePos) -> Loc {\n-        with_sess(|sess, _| sess.codemap().lookup_char_pos(pos))\n+        with_sess(|sess, _| sess.source_map().lookup_char_pos(pos))\n     }\n \n     pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {"}, {"sha": "b5f5f4d5c11794c57ce694274b484784eb2001f5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -3621,7 +3621,7 @@ impl<'a> LoweringContext<'a> {\n                     let tail = block.expr.take().map_or_else(\n                         || {\n                             let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                            let span = this.sess.codemap().end_point(unstable_span);\n+                            let span = this.sess.source_map().end_point(unstable_span);\n                             hir::Expr {\n                                 id: node_id,\n                                 span,"}, {"sha": "ebda91cb7b0775269fb586d87237da406adf1c89", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -1202,7 +1202,7 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator,\n                                                   cstore,\n-                                                  sess.codemap(),\n+                                                  sess.source_map(),\n                                                   cmdline_args)\n     };\n "}, {"sha": "799887df05d23ba091b5ad781000af20852ea96e", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -101,7 +101,7 @@ impl<'a> StableHashingContext<'a> {\n             definitions,\n             cstore,\n             caching_codemap: None,\n-            raw_codemap: sess.codemap(),\n+            raw_codemap: sess.source_map(),\n             hash_spans: hash_spans_initial,\n             hash_bodies: true,\n             node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n@@ -169,7 +169,7 @@ impl<'a> StableHashingContext<'a> {\n     }\n \n     #[inline]\n-    pub fn codemap(&mut self) -> &mut CachingCodemapView<'a> {\n+    pub fn source_map(&mut self) -> &mut CachingCodemapView<'a> {\n         match self.caching_codemap {\n             Some(ref mut cm) => {\n                 cm\n@@ -340,7 +340,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n             return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n         }\n \n-        let (file_lo, line_lo, col_lo) = match hcx.codemap()\n+        let (file_lo, line_lo, col_lo) = match hcx.source_map()\n                                                   .byte_pos_to_line_and_col(span.lo) {\n             Some(pos) => pos,\n             None => {"}, {"sha": "d2987119e299647d870450d078f962dc88305e31", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -189,7 +189,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         region: ty::Region<'tcx>,\n     ) -> (String, Option<Span>) {\n-        let cm = self.sess.codemap();\n+        let cm = self.sess.source_map();\n \n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn explain_span(self, heading: &str, span: Span) -> (String, Option<Span>) {\n-        let lo = self.sess.codemap().lookup_char_pos_adj(span.lo());\n+        let lo = self.sess.source_map().lookup_char_pos_adj(span.lo());\n         (\n             format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n             Some(span),\n@@ -502,14 +502,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arm with an incompatible type\";\n-                    if self.tcx.sess.codemap().is_multiline(arm_span) {\n+                    if self.tcx.sess.source_map().is_multiline(arm_span) {\n                         err.span_note(arm_span, msg);\n                     } else {\n                         err.span_label(arm_span, msg);\n                     }\n                 },\n                 hir::MatchSource::TryDesugar => { // Issue #51632\n-                    if let Ok(try_snippet) = self.tcx.sess.codemap().span_to_snippet(arm_span) {\n+                    if let Ok(try_snippet) = self.tcx.sess.source_map().span_to_snippet(arm_span) {\n                         err.span_suggestion_with_applicability(\n                             arm_span,\n                             \"try wrapping with a success variant\",\n@@ -520,7 +520,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 _ => {\n                     let msg = \"match arm with an incompatible type\";\n-                    if self.tcx.sess.codemap().is_multiline(arm_span) {\n+                    if self.tcx.sess.source_map().is_multiline(arm_span) {\n                         err.span_note(arm_span, msg);\n                     } else {\n                         err.span_label(arm_span, msg);\n@@ -1136,8 +1136,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             let sp = if has_bounds {\n                                 sp.to(self.tcx\n                                     .sess\n-                                    .codemap()\n-                                    .next_point(self.tcx.sess.codemap().next_point(sp)))\n+                                    .source_map()\n+                                    .next_point(self.tcx.sess.source_map().next_point(sp)))\n                             } else {\n                                 sp\n                             };"}, {"sha": "d25dcd5b045ca30aef3918c86285e98cfec794c9", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                             }) => name.to_string(),\n                             _ => \"'_\".to_owned(),\n                         };\n-                        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(return_sp) {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n                             err.span_suggestion(\n                                 return_sp,\n                                 &format!("}, {"sha": "015f755e97d161ae235c3cb560c48d5054337f90", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -420,7 +420,7 @@ impl BuiltinLintDiagnostics {\n         match self {\n             BuiltinLintDiagnostics::Normal => (),\n             BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n-                let (sugg, app) = match sess.codemap().span_to_snippet(span) {\n+                let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n                     Ok(ref s) if is_global => (format!(\"dyn ({})\", s),\n                                                Applicability::MachineApplicable),\n                     Ok(s) => (format!(\"dyn {}\", s), Applicability::MachineApplicable),\n@@ -429,7 +429,7 @@ impl BuiltinLintDiagnostics {\n                 db.span_suggestion_with_applicability(span, \"use `dyn`\", sugg, app);\n             }\n             BuiltinLintDiagnostics::AbsPathWithModule(span) => {\n-                let (sugg, app) = match sess.codemap().span_to_snippet(span) {\n+                let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n                     Ok(ref s) => {\n                         // FIXME(Manishearth) ideally the emitting code\n                         // can tell us whether or not this is global\n@@ -462,7 +462,7 @@ impl BuiltinLintDiagnostics {\n                     // When possible, prefer a suggestion that replaces the whole\n                     // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n                     // at a point (which makes for an ugly/confusing label)\n-                    if let Ok(snippet) = sess.codemap().span_to_snippet(path_span) {\n+                    if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n                         // But our spans can get out of whack due to macros; if the place we think\n                         // we want to insert `'_` isn't even within the path expression's span, we\n                         // should bail out of making any suggestion rather than panicking on a"}, {"sha": "5872440c36250c9148e1930b7ac25a6d7f0e00b0", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -754,7 +754,7 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n         None => return true,\n     };\n \n-    match sess.codemap().span_to_snippet(def_site) {\n+    match sess.source_map().span_to_snippet(def_site) {\n         Ok(code) => !code.starts_with(\"macro_rules\"),\n         // no snippet = external macro or compiler-builtin expansion\n         Err(_) => true,"}, {"sha": "8c4c54ec954d0d946367c1852c09a17234d49b6d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -551,7 +551,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Trait(..) |\n-                hir::ItemKind::Impl(..) => self.tcx.sess.codemap().def_span(item.span),\n+                hir::ItemKind::Impl(..) => self.tcx.sess.source_map().def_span(item.span),\n                 _ => item.span,\n             };\n             let participle = match item.node {\n@@ -612,7 +612,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n-                    let span = self.tcx.sess.codemap().def_span(impl_item.span);\n+                    let span = self.tcx.sess.source_map().def_span(impl_item.span);\n                     self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n                 }\n                 self.visit_nested_body(body_id)"}, {"sha": "7d9590ee578e609ab7fbfd6de069263b0d545d6b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -157,7 +157,7 @@ enum LiveNodeKind {\n }\n \n fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n-    let cm = tcx.sess.codemap();\n+    let cm = tcx.sess.source_map();\n     match lnk {\n         FreeVarNode(s) => {\n             format!(\"Free var node [{}]\", cm.span_to_string(s))"}, {"sha": "be1d93dbad1b882f20118ae287844aaa679df943", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -1314,7 +1314,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n         debug!(\"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n                owner_id,\n-               self.tcx.sess.codemap().span_to_string(body.value.span),\n+               self.tcx.sess.source_map().span_to_string(body.value.span),\n                body_id,\n                self.cx.parent);\n "}, {"sha": "379f4df11fa7b4881da1c7b488278bb6350b4262", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -2457,7 +2457,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n             self.tcx.hir.node_to_string(lifetime_ref.id),\n             def,\n-            self.tcx.sess.codemap().span_to_string(lifetime_ref.span)\n+            self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );\n         self.map.defs.insert(lifetime_ref.id, def);\n "}, {"sha": "efd568b03ab1f3a200d23a907ba65886a09ed0b2", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -685,7 +685,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 let msp: MultiSpan = span.into();\n-                let cm = &self.sess.parse_sess.codemap();\n+                let cm = &self.sess.parse_sess.source_map();\n                 let span_key = msp.primary_span().and_then(|sp: Span|\n                     if !sp.is_dummy() {\n                         let file = cm.lookup_char_pos(sp.lo()).file;"}, {"sha": "b92f55f4284d74daf10660a973eea0563a0f70dd", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -484,8 +484,8 @@ impl Session {\n         );\n     }\n \n-    pub fn codemap<'a>(&'a self) -> &'a source_map::SourceMap {\n-        self.parse_sess.codemap()\n+    pub fn source_map<'a>(&'a self) -> &'a source_map::SourceMap {\n+        self.parse_sess.source_map()\n     }\n     pub fn verbose(&self) -> bool {\n         self.opts.debugging_opts.verbose"}, {"sha": "5d45badf49f8d3b17333f584dedf7c5e21fa470a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -528,12 +528,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                         -> DiagnosticBuilder<'tcx>\n     {\n         let msg = \"impl has stricter requirements than trait\";\n-        let sp = self.tcx.sess.codemap().def_span(error_span);\n+        let sp = self.tcx.sess.source_map().def_span(error_span);\n \n         let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n \n         if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n-            let span = self.tcx.sess.codemap().def_span(trait_item_span);\n+            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n             err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n \n@@ -715,7 +715,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n-                        let closure_span = self.tcx.sess.codemap()\n+                        let closure_span = self.tcx.sess.source_map()\n                             .def_span(self.tcx.hir.span_if_local(closure_def_id).unwrap());\n                         let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n@@ -792,7 +792,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 let found_span = found_did.and_then(|did| {\n                     self.tcx.hir.span_if_local(did)\n-                }).map(|sp| self.tcx.sess.codemap().def_span(sp)); // the sp could be an fn def\n+                }).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n                 let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n                     ty::TyTuple(ref tys) => tys.iter()\n@@ -867,7 +867,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if let Some(hir::map::NodeLocal(ref local)) = self.tcx.hir.find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n-                        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n                             err.span_suggestion_with_applicability(\n                                 expr.span,\n                                 \"consider borrowing here\",\n@@ -890,7 +890,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let trait_ref = trait_ref.skip_binder();\n         let span = obligation.cause.span;\n \n-        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n             let refs_number = snippet.chars()\n                 .filter(|c| !c.is_whitespace())\n                 .take_while(|c| *c == '&')\n@@ -909,7 +909,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                          new_trait_ref.to_predicate());\n \n                     if self.predicate_may_hold(&new_obligation) {\n-                        let sp = self.tcx.sess.codemap()\n+                        let sp = self.tcx.sess.source_map()\n                             .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n \n                         let remove_refs = refs_remaining + 1;\n@@ -938,7 +938,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n+                (self.tcx.sess.source_map().def_span(span), self.tcx.hir.body(id).arguments.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n                             node: hir::PatKind::Tuple(args, _),\n@@ -948,13 +948,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             ArgKind::Tuple(\n                                 Some(span),\n                                 args.iter().map(|pat| {\n-                                    let snippet = self.tcx.sess.codemap()\n+                                    let snippet = self.tcx.sess.source_map()\n                                         .span_to_snippet(pat.span).unwrap();\n                                     (snippet, \"_\".to_owned())\n                                 }).collect::<Vec<_>>(),\n                             )\n                         } else {\n-                            let name = self.tcx.sess.codemap()\n+                            let name = self.tcx.sess.source_map()\n                                 .span_to_snippet(arg.pat.span).unwrap();\n                             ArgKind::Arg(name, \"_\".to_owned())\n                         }\n@@ -976,7 +976,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 node: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n+                (self.tcx.sess.source_map().def_span(span), decl.inputs.iter()\n                         .map(|arg| match arg.clone().node {\n                     hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n@@ -995,13 +995,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 ..\n             }) => {\n-                (self.tcx.sess.codemap().def_span(span),\n+                (self.tcx.sess.source_map().def_span(span),\n                  fields.iter().map(|field| {\n                      ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n                  }).collect::<Vec<_>>())\n             }\n             hir::map::NodeStructCtor(ref variant_data) => {\n-                (self.tcx.sess.codemap().def_span(self.tcx.hir.span(variant_data.id())),\n+                (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n                  variant_data.fields()\n                     .iter().map(|_| ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned()))\n                     .collect())\n@@ -1192,7 +1192,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         assert!(type_def_id.is_local());\n         let span = self.hir.span_if_local(type_def_id).unwrap();\n-        let span = self.sess.codemap().def_span(span);\n+        let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n                                        self.item_path_str(type_def_id));\n@@ -1210,7 +1210,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                       -> DiagnosticBuilder<'tcx>\n     {\n         let trait_str = self.item_path_str(trait_def_id);\n-        let span = self.sess.codemap().def_span(span);\n+        let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(\n             self.sess, span, E0038,\n             \"the trait `{}` cannot be made into an object\",\n@@ -1438,7 +1438,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let item_name = tcx.item_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n                 if let Some(sp) = tcx.hir.span_if_local(item_def_id) {\n-                    let sp = tcx.sess.codemap().def_span(sp);\n+                    let sp = tcx.sess.source_map().def_span(sp);\n                     err.span_note(sp, &msg);\n                 } else {\n                     err.note(&msg);"}, {"sha": "0ba94b5275cb2e1f90f9ebd5507a52b7e93b7b76", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -142,7 +142,7 @@ impl<'tcx> ObligationCause<'tcx> {\n             ObligationCauseCode::CompareImplMethodObligation { .. } |\n             ObligationCauseCode::MainFunctionType |\n             ObligationCauseCode::StartFunctionType => {\n-                tcx.sess.codemap().def_span(self.span)\n+                tcx.sess.source_map().def_span(self.span)\n             }\n             _ => self.span,\n         }"}, {"sha": "caebcbec3903e4569dd029aacd8428d11517fb04", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -344,7 +344,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                         }),\n                     if used_to_be_allowed { \" (E0119)\" } else { \"\" }\n                 );\n-                let impl_span = tcx.sess.codemap().def_span(\n+                let impl_span = tcx.sess.source_map().def_span(\n                     tcx.span_of_impl(impl_def_id).unwrap()\n                 );\n                 let mut err = if used_to_be_allowed {\n@@ -363,7 +363,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n \n                 match tcx.span_of_impl(overlap.with_impl) {\n                     Ok(span) => {\n-                        err.span_label(tcx.sess.codemap().def_span(span),\n+                        err.span_label(tcx.sess.source_map().def_span(span),\n                                        \"first implementation here\".to_string());\n                         err.span_label(impl_span,\n                                        format!(\"conflicting implementation{}\","}, {"sha": "ef363459108c9b13d2090203224631f430481ec6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -1818,7 +1818,7 @@ pub mod tls {\n     /// in librustc otherwise\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter) -> fmt::Result {\n         with(|tcx| {\n-            write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n+            write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n         })\n     }\n "}, {"sha": "e23034bde7672ff9d1e5260de0c52feb6744c336", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 match (&values.found.sty, &values.expected.sty) { // Issue #53280\n                     (ty::TyInfer(ty::IntVar(_)), ty::TyFloat(_)) => {\n-                        if let Ok(snippet) = self.sess.codemap().span_to_snippet(sp) {\n+                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n                             if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n                                 db.span_suggestion_with_applicability(\n                                     sp,"}, {"sha": "593470b5d1ecd49f66eb79cdcdc67890da37a06e", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.push_item_path(buffer, parent_def_id);\n         let node_id = self.hir.as_local_node_id(impl_def_id).unwrap();\n         let item = self.hir.expect_item(node_id);\n-        let span_str = self.sess.codemap().span_to_string(item.span);\n+        let span_str = self.sess.source_map().span_to_string(item.span);\n         buffer.push(&format!(\"<impl at {}>\", span_str));\n     }\n "}, {"sha": "f7876ee035c7d0dbc71ba4361537945ddb42b45b", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -140,7 +140,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_file: Lock::new(FxHashMap()),\n             prev_cnums: footer.prev_cnums,\n             cnum_map: Once::new(),\n-            codemap: sess.codemap(),\n+            codemap: sess.source_map(),\n             current_diagnostics: Lock::new(FxHashMap()),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n@@ -178,7 +178,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 let mut file_to_file_index = FxHashMap();\n                 let mut file_index_to_stable_id = FxHashMap();\n \n-                for (index, file) in tcx.sess.codemap().files().iter().enumerate() {\n+                for (index, file) in tcx.sess.source_map().files().iter().enumerate() {\n                     let index = SourceFileIndex(index as u32);\n                     let file_ptr: *const SourceFile = &**file as *const _;\n                     file_to_file_index.insert(file_ptr, index);\n@@ -196,7 +196,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 expn_info_shorthands: FxHashMap(),\n                 interpret_allocs: FxHashMap(),\n                 interpret_allocs_inverse: Vec::new(),\n-                codemap: CachingCodemapView::new(tcx.sess.codemap()),\n+                codemap: CachingCodemapView::new(tcx.sess.source_map()),\n                 file_to_file_index,\n             };\n "}, {"sha": "bf721ddd13fc6bd7088bec7612e8cdff78c5cc9f", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -251,7 +251,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         assert!(!stack.is_empty());\n \n         let fix_span = |span: Span, query: &Query<'gcx>| {\n-            self.sess.codemap().def_span(query.default_span(self, span))\n+            self.sess.source_map().def_span(query.default_span(self, span))\n         };\n \n         // Disable naming impls with types in this path, since that\n@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  i,\n                                  query.info.query.name(),\n                                  query.info.query.describe(icx.tcx)));\n-                    db.set_span(icx.tcx.sess.codemap().def_span(query.info.span));\n+                    db.set_span(icx.tcx.sess.source_map().def_span(query.info.span));\n                     icx.tcx.sess.diagnostic().force_print_db(db);\n \n                     current_query = query.parent.clone();"}, {"sha": "dab60ef16613d77971791544a852685671cfb20f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -594,7 +594,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                Some(self.tcx().sess.codemap().end_point(\n+                Some(self.tcx().sess.source_map().end_point(\n                         old_loan.kill_scope.span(self.tcx(), &self.bccx.region_scope_tree)));\n \n             let mut err = match (new_loan.kind, old_loan.kind) {"}, {"sha": "e1c3ac839902f0f52faee714205483488815dd21", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -79,7 +79,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n                 // see `get_pattern_source()` for details\n                 let initializer =\n                     e.init.as_ref().expect(\"should have an initializer to get an error\");\n-                if let Ok(snippet) = bccx.tcx.sess.codemap().span_to_snippet(initializer.span) {\n+                if let Ok(snippet) = bccx.tcx.sess.source_map().span_to_snippet(initializer.span) {\n                     err.span_suggestion(initializer.span,\n                                         \"consider using a reference instead\",\n                                         format!(\"&{}\", snippet));"}, {"sha": "7208e1ca36299f7e20d9aed5625239ad3a5ab163", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -848,7 +848,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             let sp = self.tcx.hir.span(node_id);\n                             let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n                                                   environment for modifications\";\n-                            match (self.tcx.sess.codemap().span_to_snippet(sp), &err.cmt.cat) {\n+                            match (self.tcx.sess.source_map().span_to_snippet(sp), &err.cmt.cat) {\n                                 (_, &Categorization::Upvar(mc::Upvar {\n                                     kind: ty::ClosureKind::Fn, ..\n                                 })) => {\n@@ -1160,13 +1160,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             ref ty\n         }) = pty.node {\n             // Account for existing lifetimes when generating the message\n-            let pointee_snippet = match self.tcx.sess.codemap().span_to_snippet(ty.span) {\n+            let pointee_snippet = match self.tcx.sess.source_map().span_to_snippet(ty.span) {\n                 Ok(snippet) => snippet,\n                 _ => return None\n             };\n \n             let lifetime_snippet = if !lifetime.is_elided() {\n-                format!(\"{} \", match self.tcx.sess.codemap().span_to_snippet(lifetime.span) {\n+                format!(\"{} \", match self.tcx.sess.source_map().span_to_snippet(lifetime.span) {\n                     Ok(lifetime_snippet) => lifetime_snippet,\n                     _ => return None\n                 })\n@@ -1277,7 +1277,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             binding_node_id: ast::NodeId) {\n         let let_span = self.tcx.hir.span(binding_node_id);\n         if let ty::BindByValue(..) = self.local_binding_mode(binding_node_id) {\n-            if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n+            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n                 let (ty, is_implicit_self) = self.local_ty(binding_node_id);\n                 if is_implicit_self && snippet != \"self\" {\n                     // avoid suggesting `mut &self`.\n@@ -1315,7 +1315,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         let cmt_path_or_string = self.cmt_to_path_or_string(&err.cmt);\n \n         let suggestion =\n-            match self.tcx.sess.codemap().span_to_snippet(err.span) {\n+            match self.tcx.sess.source_map().span_to_snippet(err.span) {\n                 Ok(string) => format!(\"move {}\", string),\n                 Err(_) => \"move |<args>| <body>\".to_string()\n             };\n@@ -1337,7 +1337,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                Some(self.tcx.sess.codemap().end_point(\n+                Some(self.tcx.sess.source_map().end_point(\n                         scope.span(self.tcx, &self.region_scope_tree)))\n             }\n             _ => None\n@@ -1368,7 +1368,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n                     let span = self.tcx.hir.span(local_id);\n-                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n                             db.span_label(*error_span, \"try removing `&mut` here\");"}, {"sha": "c5571ecb97cd9f92bf41d9351061bddc71a2bd22", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n             }\n \n             let (hir_id, span) = ids[0];\n-            let mut_span = tcx.sess.codemap().span_until_non_whitespace(span);\n+            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n \n             // Ok, every name wasn't used mutably, so issue a warning that this\n             // didn't need to be mutable."}, {"sha": "c59b5e2b8f5f596937e459aeee42e083c20127db", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -40,7 +40,7 @@ pub fn set_source_location(\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", bx.sess().codemap().span_to_string(span));\n+        debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n         let loc = span_start(bx.cx, span);\n         InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n     } else {"}, {"sha": "19bc4ac39d308dcf76e3f00847e110d8f9a5ffe9", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -47,7 +47,7 @@ pub fn create_DIArray(\n \n /// Return syntax_pos::Loc corresponding to the beginning of the span\n pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n-    cx.sess().codemap().lookup_char_pos(span.lo())\n+    cx.sess().source_map().lookup_char_pos(span.lo())\n }\n \n #[inline]"}, {"sha": "1104408c1c8d76f0a4041685f3623d8050a23bb6", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -359,7 +359,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 self.set_debug_loc(&bx, terminator.source_info);\n \n                 // Get the location information.\n-                let loc = bx.sess().codemap().lookup_char_pos(span.lo());\n+                let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n                 let filename = C_str_slice(bx.cx, filename);\n                 let line = C_u32(bx.cx, loc.line as u32);"}, {"sha": "d3cb97f65ce264c132abcace628b0d13650e9839", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -166,7 +166,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n-            let cm = self.cx.sess().codemap();\n+            let cm = self.cx.sess().source_map();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n             Some(debuginfo::extend_scope_to_file(self.cx,\n                                             scope_metadata.unwrap(),"}, {"sha": "1c2c0ad73a89751a587904d666bdeead2e19a3df", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -695,7 +695,7 @@ pub fn phase_1_parse_input<'a>(\n     if sess.opts.debugging_opts.input_stats {\n         println!(\n             \"Lines of code:             {}\",\n-            sess.codemap().count_lines()\n+            sess.source_map().count_lines()\n         );\n         println!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n     }\n@@ -1462,7 +1462,7 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[Pa\n     let result = (|| -> io::Result<()> {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n-        let files: Vec<String> = sess.codemap()\n+        let files: Vec<String> = sess.source_map()\n             .files()\n             .iter()\n             .filter(|fmap| fmap.is_real_file())"}, {"sha": "65cbee821e86443cd31e27e9737b96e99f9061a0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -915,7 +915,7 @@ pub fn fold_crate(sess: &Session, krate: ast::Crate, ppm: PpMode) -> ast::Crate\n \n fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, FileName) {\n     let src_name = driver::source_name(input);\n-    let src = sess.codemap()\n+    let src = sess.source_map()\n         .get_source_file(&src_name)\n         .unwrap()\n         .src\n@@ -954,7 +954,7 @@ pub fn print_after_parsing(sess: &Session,\n         s.call_with_pp_support(sess, None, move |annotation| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n-                pprust::print_crate(sess.codemap(),\n+                pprust::print_crate(sess.source_map(),\n                                     &sess.parse_sess,\n                                     krate,\n                                     src_name,\n@@ -1011,7 +1011,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                 s.call_with_pp_support(sess, Some(hir_map), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n-                    pprust::print_crate(sess.codemap(),\n+                    pprust::print_crate(sess.source_map(),\n                                         &sess.parse_sess,\n                                         krate,\n                                         src_name,\n@@ -1035,7 +1035,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n-                    pprust_hir::print_crate(sess.codemap(),\n+                    pprust_hir::print_crate(sess.source_map(),\n                                             &sess.parse_sess,\n                                             krate,\n                                             src_name,\n@@ -1076,7 +1076,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let hir_map = annotation.hir_map().expect(\"-Z unpretty missing HIR map\");\n-                    let mut pp_state = pprust_hir::State::new_from_input(sess.codemap(),\n+                    let mut pp_state = pprust_hir::State::new_from_input(sess.source_map(),\n                                                                          &sess.parse_sess,\n                                                                          src_name,\n                                                                          &mut rdr,"}, {"sha": "175422975e006cb43e14adffee121df70e8eaf51", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -162,7 +162,7 @@ fn test_env_with_pool<F>(\n                              &arenas,\n                              resolutions,\n                              hir_map,\n-                             OnDiskCache::new_empty(sess.codemap()),\n+                             OnDiskCache::new_empty(sess.source_map()),\n                              \"test_crate\",\n                              tx,\n                              &outputs,"}, {"sha": "fbc3bf03599fc5eedb21692283bcb26c9c6d2fcb", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -207,11 +207,11 @@ pub fn load_dep_graph(sess: &Session) ->\n pub fn load_query_result_cache<'sess>(sess: &'sess Session) -> OnDiskCache<'sess> {\n     if sess.opts.incremental.is_none() ||\n        !sess.opts.debugging_opts.incremental_queries {\n-        return OnDiskCache::new_empty(sess.codemap());\n+        return OnDiskCache::new_empty(sess.source_map());\n     }\n \n     match load_data(sess.opts.debugging_opts.incremental_info, &query_cache_path(sess)) {\n         LoadResult::Ok{ data: (bytes, start_pos) } => OnDiskCache::new(sess, bytes, start_pos),\n-        _ => OnDiskCache::new_empty(sess.codemap())\n+        _ => OnDiskCache::new_empty(sess.source_map())\n     }\n }"}, {"sha": "c346d3e76cd30bcf00159d5d1e899fd20ba82466", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n                 if let ast::LitKind::Bool(true) = lit.node {\n                     if lit.span.ctxt() == SyntaxContext::empty() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n-                        let condition_span = cx.tcx.sess.codemap().def_span(e.span);\n+                        let condition_span = cx.tcx.sess.source_map().def_span(e.span);\n                         let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);\n                         err.span_suggestion_short_with_applicability(\n                             condition_span,\n@@ -195,7 +195,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\", ident));\n-                        let subspan = cx.tcx.sess.codemap().span_through_char(fieldpat.span, ':');\n+                        let subspan = cx.tcx.sess.source_map().span_through_char(fieldpat.span, ':');\n                         err.span_suggestion_short_with_applicability(\n                             subspan,\n                             \"remove this\",\n@@ -367,7 +367,7 @@ impl MissingDoc {\n         let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS,\n-                         cx.tcx.sess.codemap().def_span(sp),\n+                         cx.tcx.sess.source_map().def_span(sp),\n                          &format!(\"missing documentation for {}\", desc));\n         }\n     }\n@@ -651,7 +651,7 @@ impl EarlyLintPass for AnonymousParameters {\n                             if ident.name == keywords::Invalid.name() {\n                                 let ty_snip = cx\n                                     .sess\n-                                    .codemap()\n+                                    .source_map()\n                                     .span_to_snippet(arg.ty.span);\n \n                                 let (ty_snip, appl) = if let Ok(snip) = ty_snip {\n@@ -958,7 +958,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n         if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n-            let sp = cx.tcx.sess.codemap().def_span(sp);\n+            let sp = cx.tcx.sess.source_map().def_span(sp);\n             let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION,\n                                              sp,\n                                              \"function cannot return without recurring\");\n@@ -1278,7 +1278,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                     let mut err = cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n \n                     // account for \"pub const\" (#45562)\n-                    let start = cx.tcx.sess.codemap().span_to_snippet(it.span)\n+                    let start = cx.tcx.sess.source_map().span_to_snippet(it.span)\n                         .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n                         .unwrap_or(0) as u32;\n                     // `const` is 5 chars\n@@ -1440,7 +1440,7 @@ impl UnreachablePub {\n                 if span.ctxt().outer().expn_info().is_some() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n-                let def_span = cx.tcx.sess.codemap().def_span(span);\n+                let def_span = cx.tcx.sess.source_map().def_span(span);\n                 let mut err = cx.struct_span_lint(UNREACHABLE_PUB, def_span,\n                                                   &format!(\"unreachable `pub` {}\", what));\n                 let replacement = if cx.tcx.features().crate_visibility_modifier {"}, {"sha": "46b33255b45a2de8988c0cb6ba1180e37315444c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         }\n \n         fn get_bin_hex_repr(cx: &LateContext, lit: &ast::Lit) -> Option<String> {\n-            let src = cx.sess().codemap().span_to_snippet(lit.span).ok()?;\n+            let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n             let firstch = src.chars().next()?;\n \n             if firstch == '0' {"}, {"sha": "c51bebd2e3b6373e7f07dd69cab27bee24cf8509", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -463,7 +463,7 @@ impl cstore::CStore {\n         let (name, def) = data.get_macro(id.index);\n         let source_name = FileName::Macros(name.to_string());\n \n-        let source_file = sess.parse_sess.codemap().new_source_file(source_name, def.body);\n+        let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n         let local_span = Span::new(source_file.start_pos, source_file.end_pos, NO_EXPANSION);\n         let body = source_file_to_stream(&sess.parse_sess, source_file, None);\n "}, {"sha": "ceccdea6587d1fb710fd0f71e62a3160b88b2cb6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -314,7 +314,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             bug!(\"Cannot decode Span without Session.\")\n         };\n \n-        let imported_source_files = self.cdata().imported_source_files(&sess.codemap());\n+        let imported_source_files = self.cdata().imported_source_files(&sess.source_map());\n         let source_file = {\n             // Optimize for the case that most spans within a translated item\n             // originate from the same source_file."}, {"sha": "8f3bed6bdbe92ec1a09088b53b6bac6683e676f3", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         debug_assert!(span.lo <= span.hi);\n \n         if !self.source_file_cache.contains(span.lo) {\n-            let codemap = self.tcx.sess.codemap();\n+            let codemap = self.tcx.sess.source_map();\n             let source_file_index = codemap.lookup_source_file_idx(span.lo);\n             self.source_file_cache = codemap.files()[source_file_index].clone();\n         }\n@@ -337,8 +337,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(definitions.def_path_table())\n     }\n \n-    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::SourceFile> {\n-        let codemap = self.tcx.sess.codemap();\n+    fn encode_source_map(&mut self) -> LazySeq<syntax_pos::SourceFile> {\n+        let codemap = self.tcx.sess.source_map();\n         let all_source_files = codemap.files();\n \n         let (working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir.clone();\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode codemap\n         i = self.position();\n-        let codemap = self.encode_codemap();\n+        let codemap = self.encode_source_map();\n         let codemap_bytes = self.position() - i;\n \n         // Encode DefPathTable\n@@ -1842,7 +1842,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n-            source_file_cache: tcx.sess.codemap().files()[0].clone(),\n+            source_file_cache: tcx.sess.source_map().files()[0].clone(),\n             interpret_allocs: Default::default(),\n             interpret_allocs_inverse: Default::default(),\n         };"}, {"sha": "82d3d31a52eb3b33e82a986e62e865f3469dabca", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -316,7 +316,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             }\n \n             let span = local_decl.source_info.span;\n-            let mut_span = tcx.sess.codemap().span_until_non_whitespace(span);\n+            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n \n             let mut err = tcx.struct_span_lint_node(\n                 UNUSED_MUT,\n@@ -1509,7 +1509,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead\n             // of just a span here.\n-            let span = self.tcx.sess.codemap().end_point(span);\n+            let span = self.tcx.sess.source_map().end_point(span);\n             self.report_borrowed_value_does_not_live_long_enough(\n                 context,\n                 borrow,"}, {"sha": "5ef647585c38e8d00871e77403a48beb59a47f38", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n     ) {\n-        let snippet = self.tcx.sess.codemap().span_to_snippet(span).unwrap();\n+        let snippet = self.tcx.sess.source_map().span_to_snippet(span).unwrap();\n         match error {\n             GroupedMoveError::MovesFromPlace {\n                 mut binds_to,\n@@ -394,7 +394,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 }))\n             ) = bind_to.is_user_variable {\n                 let pat_snippet = self\n-                    .tcx.sess.codemap()\n+                    .tcx.sess.source_map()\n                     .span_to_snippet(pat_span)\n                     .unwrap();\n                 if pat_snippet.starts_with('&') {"}, {"sha": "05d6f49d97c6cce3177d6545e4da9a4bee82cc10", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // a local variable, then just suggest the user remove it.\n             Place::Local(_)\n                 if {\n-                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n                     } else {\n                         false\n@@ -406,7 +406,7 @@ fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n     local_decl: &mir::LocalDecl<'tcx>,\n ) -> (Span, String) {\n     let sp = local_decl.source_info.span;\n-    (sp, match tcx.sess.codemap().span_to_snippet(sp) {\n+    (sp, match tcx.sess.source_map().span_to_snippet(sp) {\n         Ok(snippet) => {\n             let lt_pos = snippet.find('\\'');\n             if let Some(lt_pos) = lt_pos {\n@@ -444,7 +444,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n     let locations = mir.find_assignments(local);\n     if locations.len() > 0 {\n         let assignment_rhs_span = mir.source_info(locations[0]).span;\n-        if let Ok(src) = tcx.sess.codemap().span_to_snippet(assignment_rhs_span) {\n+        if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n             if let (true, Some(ws_pos)) = (\n                 src.starts_with(\"&'\"),\n                 src.find(|c: char| -> bool { c.is_whitespace() }),\n@@ -469,7 +469,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n         None => local_decl.source_info.span,\n     };\n \n-    if let Ok(src) = tcx.sess.codemap().span_to_snippet(highlight_span) {\n+    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span) {\n         if let (true, Some(ws_pos)) = (\n             src.starts_with(\"&'\"),\n             src.find(|c: char| -> bool { c.is_whitespace() }),"}, {"sha": "9724d9deead0a148b87ba440def573e5d77a873e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -189,7 +189,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         name: &InternedString,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n-        let cm = tcx.sess.codemap();\n+        let cm = tcx.sess.source_map();\n \n         let scope = error_region.free_region_binding_scope(tcx);\n         let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n@@ -383,7 +383,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         let region_name = self.synthesize_region_name(counter);\n \n                         // Just grab the first character, the `&`.\n-                        let codemap = tcx.sess.codemap();\n+                        let codemap = tcx.sess.source_map();\n                         let ampersand_span = codemap.start_point(hir_ty.span);\n \n                         diag.span_label(\n@@ -593,7 +593,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             = tcx.hir.expect_expr(mir_node_id).node\n         {\n             (\n-                tcx.sess.codemap().end_point(span),\n+                tcx.sess.source_map().end_point(span),\n                 if gen_move.is_some() { \" of generator\" } else { \" of closure\" }\n             )\n         } else {"}, {"sha": "8e99a45c87fdc3393012f58821aeeb0d51a86af9", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -732,7 +732,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let region_scope_span = region_scope.span(self.hir.tcx(),\n                                                           &self.hir.region_scope_tree);\n                 // Attribute scope exit drops to scope's closing brace.\n-                let scope_end = self.hir.tcx().sess.codemap().end_point(region_scope_span);\n+                let scope_end = self.hir.tcx().sess.source_map().end_point(region_scope_span);\n \n                 scope.drops.push(DropData {\n                     span: scope_end,"}, {"sha": "80e484d5957140e2d311e256d03e0516f84487b3", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -424,12 +424,12 @@ fn is_enclosed(tcx: TyCtxt,\n }\n \n fn report_unused_unsafe(tcx: TyCtxt, used_unsafe: &FxHashSet<ast::NodeId>, id: ast::NodeId) {\n-    let span = tcx.sess.codemap().def_span(tcx.hir.span(id));\n+    let span = tcx.sess.source_map().def_span(tcx.hir.span(id));\n     let msg = \"unnecessary `unsafe` block\";\n     let mut db = tcx.struct_span_lint_node(UNUSED_UNSAFE, id, span, msg);\n     db.span_label(span, msg);\n     if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(tcx.sess.codemap().def_span(tcx.hir.span(id)),\n+        db.span_label(tcx.sess.source_map().def_span(tcx.hir.span(id)),\n                       format!(\"because it's nested under this `unsafe` {}\", kind));\n     }\n     db.emit();"}, {"sha": "1e624081bcfb559775090617eaf77b2945c7b20a", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -33,7 +33,7 @@ pub fn suggest_ref_mut<'cx, 'gcx, 'tcx>(\n     tcx: ty::TyCtxt<'cx, 'gcx, 'tcx>,\n     binding_span: Span,\n ) -> Option<(String)> {\n-    let hi_src = tcx.sess.codemap().span_to_snippet(binding_span).unwrap();\n+    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n     if hi_src.starts_with(\"ref\")\n         && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)\n     {"}, {"sha": "df975998edcf8f6b400e898d3e1be8b377d0bc15", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -441,7 +441,7 @@ fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\n         \"scope {} at {}\",\n         scope.index(),\n-        tcx.sess.codemap().span_to_string(span)\n+        tcx.sess.source_map().span_to_string(span)\n     )\n }\n "}, {"sha": "de9481579e2f429a5c6625eb9b1ff3a87add293e", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -175,7 +175,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n         let ms = MultiSpan::from_spans(spans.clone());\n         let mut span_snippets = spans.iter()\n             .filter_map(|s| {\n-                match visitor.session.codemap().span_to_snippet(*s) {\n+                match visitor.session.source_map().span_to_snippet(*s) {\n                     Ok(s) => Some(format!(\"`{}`\", s)),\n                     _ => None,\n                 }"}, {"sha": "6dd0c32bb3e94dd392f80752cd5c89bf7ade1cc9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -195,7 +195,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            \"can't use type parameters from outer function\");\n             err.span_label(span, \"use of type variable from outer function\");\n \n-            let cm = resolver.session.codemap();\n+            let cm = resolver.session.source_map();\n             match outer_def {\n                 Def::SelfTy(_, maybe_impl_defid) => {\n                     if let Some(impl_span) = maybe_impl_defid.map_or(None,\n@@ -3085,7 +3085,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             // parser issue where a struct literal is being used on an expression\n                             // where a brace being opened means a block is being started. Look\n                             // ahead for the next text to see if `span` is followed by a `{`.\n-                            let cm = this.session.codemap();\n+                            let cm = this.session.source_map();\n                             let mut sp = span;\n                             loop {\n                                 sp = cm.next_point(sp);\n@@ -3212,7 +3212,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                                   err: &mut DiagnosticBuilder,\n                                   base_span: Span) {\n         debug!(\"type_ascription_suggetion {:?}\", base_span);\n-        let cm = self.session.codemap();\n+        let cm = self.session.source_map();\n         debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n         if let Some(sp) = self.current_type_ascription.last() {\n             let mut sp = *sp;\n@@ -4527,7 +4527,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             false => \"defined\",\n         };\n \n-        let (name, span) = (ident.name, self.session.codemap().def_span(new_binding.span));\n+        let (name, span) = (ident.name, self.session.source_map().def_span(new_binding.span));\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -4566,7 +4566,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n         if !old_binding.span.is_dummy() {\n-            err.span_label(self.session.codemap().def_span(old_binding.span),\n+            err.span_label(self.session.source_map().def_span(old_binding.span),\n                            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name));\n         }\n \n@@ -4578,7 +4578,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 old_binding\n             };\n \n-            let cm = self.session.codemap();\n+            let cm = self.session.source_map();\n             let rename_msg = \"You can use `as` to change the binding name of the import\";\n \n             if let (Ok(snippet), false) = (cm.span_to_snippet(binding.span),"}, {"sha": "58390c228869964e8049fa0262ee0b313e7a4239", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -1205,8 +1205,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                             let enum_span = enum_resolution.borrow()\n                                 .binding.expect(\"binding should exist\")\n                                 .span;\n-                            let enum_def_span = self.session.codemap().def_span(enum_span);\n-                            let enum_def_snippet = self.session.codemap()\n+                            let enum_def_span = self.session.source_map().def_span(enum_span);\n+                            let enum_def_snippet = self.session.source_map()\n                                 .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n                             // potentially need to strip extant `crate`/`pub(path)` for suggestion\n                             let after_vis_index = enum_def_snippet.find(\"enum\")"}, {"sha": "c6cec2ecca674292ed6ba3389978ff97e4b33850", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -1368,7 +1368,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n \n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n-        let cm = self.tcx.sess.codemap();\n+        let cm = self.tcx.sess.source_map();\n         let filename = cm.span_to_filename(span);\n         let data_id = ::id_from_node_id(id, &self.save_ctxt);\n         let children = m.items"}, {"sha": "b2d78850cbab9f2de9d720156f69a8afe0c6294e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -95,7 +95,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     fn span_from_span(&self, span: Span) -> SpanData {\n         use rls_span::{Column, Row};\n \n-        let cm = self.tcx.sess.codemap();\n+        let cm = self.tcx.sess.source_map();\n         let start = cm.lookup_char_pos(span.lo());\n         let end = cm.lookup_char_pos(span.hi());\n \n@@ -122,7 +122,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     continue;\n                 }\n             };\n-            let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo());\n+            let lo_loc = self.span_utils.sess.source_map().lookup_char_pos(span.lo());\n             result.push(ExternalCrateData {\n                 // FIXME: change file_name field to PathBuf in rls-data\n                 // https://github.com/nrc/rls-data/issues/7\n@@ -268,7 +268,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ItemKind::Mod(ref m) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-                let cm = self.tcx.sess.codemap();\n+                let cm = self.tcx.sess.source_map();\n                 let filename = cm.span_to_filename(m.inner);\n \n                 let sub_span = self.span_utils"}, {"sha": "e1a3829cd75388cabb18002acecdb57fee585f6a", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -47,7 +47,7 @@ impl<'a> SpanUtils<'a> {\n     }\n \n     pub fn snippet(&self, span: Span) -> String {\n-        match self.sess.codemap().span_to_snippet(span) {\n+        match self.sess.source_map().span_to_snippet(span) {\n             Ok(s) => s,\n             Err(_) => String::new(),\n         }\n@@ -151,7 +151,7 @@ impl<'a> SpanUtils<'a> {\n         }\n         #[cfg(debug_assertions)] {\n             if angle_count != 0 || bracket_count != 0 {\n-                let loc = self.sess.codemap().lookup_char_pos(span.lo());\n+                let loc = self.sess.source_map().lookup_char_pos(span.lo());\n                 span_bug!(\n                     span,\n                     \"Mis-counted brackets when breaking path? Parsing '{}' \\\n@@ -278,7 +278,7 @@ impl<'a> SpanUtils<'a> {\n \n         //If the span comes from a fake source_file, filter it.\n         if !self.sess\n-            .codemap()\n+            .source_map()\n             .lookup_char_pos(parent.lo())\n             .file\n             .is_real_file()"}, {"sha": "c14a07b7cf5d0b0d417be78e23f80f3d2ca381e2", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -350,7 +350,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             if let Some(mut err) = err {\n                                 if is_arg {\n                                     if let PatKind::Binding(..) = inner.node {\n-                                        if let Ok(snippet) = tcx.sess.codemap()\n+                                        if let Ok(snippet) = tcx.sess.source_map()\n                                                                      .span_to_snippet(pat.span)\n                                         {\n                                             err.help(&format!(\"did you mean `{}: &{}`?\","}, {"sha": "29d2fe2c7b63eaf93fe11b5d0b55306d805c89a2", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n                                         cast_ty));\n-                if let Ok(snippet) = fcx.sess().codemap().span_to_snippet(self.expr.span) {\n+                if let Ok(snippet) = fcx.sess().source_map().span_to_snippet(self.expr.span) {\n                     err.span_help(self.expr.span,\n                                    &format!(\"did you mean `*{}`?\", snippet));\n                 }\n@@ -325,7 +325,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     hir::MutImmutable => \"\",\n                 };\n                 if self.cast_ty.is_trait() {\n-                    match fcx.tcx.sess.codemap().span_to_snippet(self.cast_span) {\n+                    match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                         Ok(s) => {\n                             err.span_suggestion(self.cast_span,\n                                                 \"try casting to a reference instead\",\n@@ -344,7 +344,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 }\n             }\n             ty::TyAdt(def, ..) if def.is_box() => {\n-                match fcx.tcx.sess.codemap().span_to_snippet(self.cast_span) {\n+                match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                     Ok(s) => {\n                         err.span_suggestion(self.cast_span,\n                                             \"try casting to a `Box` instead\","}, {"sha": "044621dabb45840f916defc31ddd57a98ef6bb7e", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -40,7 +40,7 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let impl_m_span = tcx.sess.codemap().def_span(impl_m_span);\n+    let impl_m_span = tcx.sess.source_map().def_span(impl_m_span);\n \n     if let Err(ErrorReported) = compare_self_type(tcx,\n                                                   impl_m,\n@@ -319,7 +319,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             trait_m.ident);\n             if let TypeError::Mutability = terr {\n                 if let Some(trait_err_span) = trait_err_span {\n-                    if let Ok(trait_err_str) = tcx.sess.codemap().span_to_snippet(trait_err_span) {\n+                    if let Ok(trait_err_str) = tcx.sess.source_map().span_to_snippet(trait_err_span) {\n                         diag.span_suggestion(\n                             impl_err_span,\n                             \"consider change the type to match the mutability in trait\",\n@@ -386,7 +386,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // are zero. Since I don't quite know how to phrase things at\n     // the moment, give a kind of vague error message.\n     if trait_params != impl_params {\n-        let def_span = tcx.sess.codemap().def_span(span);\n+        let def_span = tcx.sess.source_map().def_span(span);\n         let span = tcx.hir.get_generics_span(impl_m.def_id).unwrap_or(def_span);\n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -397,7 +397,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         );\n         err.span_label(span, \"lifetimes do not match method in trait\");\n         if let Some(sp) = tcx.hir.span_if_local(trait_m.def_id) {\n-            let def_sp = tcx.sess.codemap().def_span(sp);\n+            let def_sp = tcx.sess.source_map().def_span(sp);\n             let sp = tcx.hir.get_generics_span(trait_m.def_id).unwrap_or(def_sp);\n             err.span_label(sp, \"lifetimes in impl do not match this method in trait\");\n         }\n@@ -770,7 +770,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // as another generic argument\n                         let new_name = tcx\n                             .sess\n-                            .codemap()\n+                            .source_map()\n                             .span_to_snippet(trait_span)\n                             .ok()?;\n                         let trait_m = tcx.hir.as_local_node_id(trait_m.def_id)?;\n@@ -783,7 +783,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // and the opening paren of the argument list\n                         let new_generics_span = tcx\n                             .sess\n-                            .codemap()\n+                            .source_map()\n                             .generate_fn_name_span(impl_span)?\n                             .shrink_to_hi();\n                         // in case there are generics, just replace them\n@@ -794,7 +794,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // replace with the generics from the trait\n                         let new_generics = tcx\n                             .sess\n-                            .codemap()\n+                            .source_map()\n                             .span_to_snippet(trait_m.generics.span)\n                             .ok()?;\n \n@@ -865,7 +865,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let bounds = bounds.first()?.span().to(bounds.last()?.span());\n                         let bounds = tcx\n                             .sess\n-                            .codemap()\n+                            .source_map()\n                             .span_to_snippet(bounds)\n                             .ok()?;\n "}, {"sha": "00cc36ecd428c8863d9b156104ad215e38a328ec", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -251,7 +251,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  checked_ty: Ty<'tcx>,\n                  expected: Ty<'tcx>)\n                  -> Option<(Span, &'static str, String)> {\n-        let cm = self.sess().codemap();\n+        let cm = self.sess().source_map();\n         // Use the callsite's span if this is a macro call. #41858\n         let sp = cm.call_span_if_macro(expr.span);\n         if !cm.span_to_filename(sp).is_real() {\n@@ -405,7 +405,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let needs_paren = expr.precedence().order() < (PREC_POSTFIX as i8);\n \n-        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+        if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n             let msg = format!(\"you can cast an `{}` to `{}`\", checked_ty, expected_ty);\n             let cast_suggestion = format!(\"{}{}{} as {}\",\n                                           if needs_paren { \"(\" } else { \"\" },"}, {"sha": "ed6ec1bf8e6e3b89b610c2a85d9792c29f49b5bd", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         };\n                         if let Some(note_span) = note_span {\n                             // We have a span pointing to the method. Show note with snippet.\n-                            err.span_note(self.tcx.sess.codemap().def_span(note_span), &note_str);\n+                            err.span_note(self.tcx.sess.source_map().def_span(note_span), &note_str);\n                         } else {\n                             err.note(&note_str);\n                         }\n@@ -141,7 +141,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let item = self\n                             .associated_item(trait_did, item_name, Namespace::Value)\n                             .unwrap();\n-                        let item_span = self.tcx.sess.codemap()\n+                        let item_span = self.tcx.sess.source_map()\n                             .def_span(self.tcx.def_span(item.def_id));\n                         if sources.len() > 1 {\n                             span_note!(err,\n@@ -246,7 +246,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         };\n                         match expr.node {\n                             hir::ExprKind::Lit(ref lit) => {  // numeric literal\n-                                let snippet = tcx.sess.codemap().span_to_snippet(lit.span)\n+                                let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n                                     .unwrap_or(\"<numeric literal>\".to_string());\n \n                                 err.span_suggestion(lit.span,\n@@ -261,9 +261,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 if let &hir::QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Def::Local(node_id) = path.def {\n                                         let span = tcx.hir.span(node_id);\n-                                        let snippet = tcx.sess.codemap().span_to_snippet(span)\n+                                        let snippet = tcx.sess.source_map().span_to_snippet(span)\n                                             .unwrap();\n-                                        let filename = tcx.sess.codemap().span_to_filename(span);\n+                                        let filename = tcx.sess.source_map().span_to_filename(span);\n \n                                         let parent_node = self.tcx.hir.get(\n                                             self.tcx.hir.get_parent_node(node_id),\n@@ -320,7 +320,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 if let Some(def) = actual.ty_adt_def() {\n                     if let Some(full_sp) = tcx.hir.span_if_local(def.did) {\n-                        let def_sp = tcx.sess.codemap().def_span(full_sp);\n+                        let def_sp = tcx.sess.source_map().def_span(full_sp);\n                         err.span_label(def_sp, format!(\"{} `{}` not found {}\",\n                                                        item_kind,\n                                                        item_name,\n@@ -341,7 +341,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 let variant = &def.non_enum_variant();\n                                 if let Some(index) = self.tcx.find_field_index(item_name, variant) {\n                                     let field = &variant.fields[index];\n-                                    let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n+                                    let snippet = tcx.sess.source_map().span_to_snippet(expr.span);\n                                     let expr_string = match snippet {\n                                         Ok(expr_string) => expr_string,\n                                         _ => \"s\".into(), // Default to a generic placeholder for the\n@@ -387,7 +387,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     if let Some(expr) = rcvr_expr {\n-                        if let Ok(expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        if let Ok(expr_string) = tcx.sess.source_map().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n                         } else if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) =\n                             expr.node"}, {"sha": "b57967a7aab211bf8ed5fddc8f59790b21bcfe6a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -1447,7 +1447,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n                                             impl_item_refs: &[hir::ImplItemRef]) {\n-    let impl_span = tcx.sess.codemap().def_span(impl_span);\n+    let impl_span = tcx.sess.source_map().def_span(impl_span);\n \n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -2668,11 +2668,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if arg_count == 1 {\" was\"} else {\"s were\"}),\n                 DiagnosticId::Error(error_code.to_owned()));\n \n-            if let Some(def_s) = def_span.map(|sp| tcx.sess.codemap().def_span(sp)) {\n+            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().def_span(sp)) {\n                 err.span_label(def_s, \"defined here\");\n             }\n             if sugg_unit {\n-                let sugg_span = tcx.sess.codemap().end_point(expr_sp);\n+                let sugg_span = tcx.sess.source_map().end_point(expr_sp);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n                 err.span_suggestion(\n@@ -2937,8 +2937,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs)) => {\n                     let msg = \"try comparing for equality\";\n                     if let (Ok(left), Ok(right)) = (\n-                        self.tcx.sess.codemap().span_to_snippet(lhs.span),\n-                        self.tcx.sess.codemap().span_to_snippet(rhs.span))\n+                        self.tcx.sess.source_map().span_to_snippet(lhs.span),\n+                        self.tcx.sess.source_map().span_to_snippet(rhs.span))\n                     {\n                         err.span_suggestion(expr.span, msg, format!(\"{} == {}\", left, right));\n                     } else {\n@@ -4232,7 +4232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 if let hir::ExprKind::Lit(ref lit) = idx.node {\n                                     if let ast::LitKind::Int(i,\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n-                                        let snip = tcx.sess.codemap().span_to_snippet(base.span);\n+                                        let snip = tcx.sess.source_map().span_to_snippet(base.span);\n                                         if let Ok(snip) = snip {\n                                             err.span_suggestion(expr.span,\n                                                                 \"to access tuple elements, use\",\n@@ -4629,7 +4629,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             err.span_suggestion(sp, msg, suggestion);\n         } else if !self.check_for_cast(err, expr, found, expected) {\n             let methods = self.get_conversion_methods(expr.span, expected, found);\n-            if let Ok(expr_text) = self.sess().codemap().span_to_snippet(expr.span) {\n+            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n                 let suggestions = iter::repeat(expr_text).zip(methods.iter())\n                     .filter_map(|(receiver, method)| {\n                         let method_call = format!(\".{}()\", method.ident);\n@@ -4673,7 +4673,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::ExprKind::Loop(..) |\n                 hir::ExprKind::Match(..) |\n                 hir::ExprKind::Block(..) => {\n-                    let sp = self.tcx.sess.codemap().next_point(cause_span);\n+                    let sp = self.tcx.sess.source_map().next_point(cause_span);\n                     err.span_suggestion(sp,\n                                         \"try adding a semicolon\",\n                                         \";\".to_string());"}, {"sha": "66a71cdd3f87c174c7627d809fba1a4e7105c2ed", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(()) => {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n-                    let codemap = self.tcx.sess.codemap();\n+                    let codemap = self.tcx.sess.source_map();\n                     match is_assign {\n                         IsAssign::Yes => {\n                             let mut err = struct_span_err!(self.tcx.sess, expr.span, E0368,\n@@ -420,7 +420,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         err: &mut errors::DiagnosticBuilder,\n         is_assign: bool,\n     ) -> bool {\n-        let codemap = self.tcx.sess.codemap();\n+        let codemap = self.tcx.sess.source_map();\n         let msg = \"`to_owned()` can be used to create an owned `String` \\\n                    from a string reference. String concatenation \\\n                    appends the string on the right to the string \\"}, {"sha": "086243314330d7d8ae119c5a550363a26761ea86", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        let msg = if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+        let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n             format!(\"unused import: `{}`\", snippet)\n         } else {\n             \"unused import\".to_string()"}, {"sha": "1b04c5da59b2853bf40274096d14ecb3475630e0", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -52,7 +52,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n-    let span = tcx.sess.codemap().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+    let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n \n     // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n     if did == li.sized_trait() {\n@@ -169,7 +169,7 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n                 traits::supertrait_def_ids(tcx,\n                                            data.principal().unwrap().def_id());\n             if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                let sp = tcx.sess.codemap().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+                let sp = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n                 struct_span_err!(tcx.sess,\n                                  sp,\n                                  E0371,"}, {"sha": "4a3747017dfc139357985d753dca970ea9a3caed", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -40,7 +40,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                        self.tcx.hir.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n-                let cm = self.tcx.sess.codemap();\n+                let cm = self.tcx.sess.source_map();\n                 let sp = cm.def_span(item.span);\n                 match traits::orphan_check(self.tcx, def_id) {\n                     Ok(()) => {}"}, {"sha": "ffd9da8c8b95c803ec870ff93738027effccda2d", "filename": "src/librustc_typeck/structured_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fstructured_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustc_typeck%2Fstructured_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fstructured_errors.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> StructuredDiagnostic<'tcx> for VariadicError<'tcx> {\n                 self.code(),\n             )\n         };\n-        if let Ok(snippet) = self.sess.codemap().span_to_snippet(self.span) {\n+        if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.span) {\n             err.span_suggestion(self.span,\n                                 &format!(\"cast the value to `{}`\", self.cast_ty),\n                                 format!(\"{} as {}\", snippet, self.cast_ty));"}, {"sha": "9b77ff82f9096e36e5874ff5dfd1b14904b28d3f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -239,7 +239,7 @@ impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         let krate_span = cx.tcx.def_span(root);\n-        let krate_src = cx.sess().codemap().span_to_filename(krate_span);\n+        let krate_src = cx.sess().source_map().span_to_filename(krate_span);\n \n         // Collect all inner modules which are tagged as implementations of\n         // primitives.\n@@ -596,7 +596,7 @@ impl Clean<Item> for doctree::Module {\n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n-            let cm = cx.sess().codemap();\n+            let cm = cx.sess().source_map();\n             let outer = cm.lookup_char_pos(self.where_outer.lo());\n             let inner = cm.lookup_char_pos(self.where_inner.lo());\n             if outer.file.start_pos == inner.file.start_pos {\n@@ -3015,7 +3015,7 @@ impl Clean<Span> for syntax_pos::Span {\n             return Span::empty();\n         }\n \n-        let cm = cx.sess().codemap();\n+        let cm = cx.sess().source_map();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo());\n         let hi = cm.lookup_char_pos(self.hi());\n@@ -3620,7 +3620,7 @@ pub trait ToSource {\n impl ToSource for syntax_pos::Span {\n     fn to_src(&self, cx: &DocContext) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean(cx));\n-        let sn = match cx.sess().codemap().span_to_snippet(*self) {\n+        let sn = match cx.sess().source_map().span_to_snippet(*self) {\n             Ok(x) => x.to_string(),\n             Err(_) => \"\".to_string()\n         };"}, {"sha": "4634054cf160cab8786f150e56a3513f5be8ba0d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -33,7 +33,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>,\n                                 tooltip: Option<(&str, &str)>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::ParseSess::new(FilePathMapping::empty());\n-    let fm = sess.codemap().new_source_file(FileName::Custom(\"stdin\".to_string()), src.to_string());\n+    let fm = sess.source_map().new_source_file(FileName::Custom(\"stdin\".to_string()), src.to_string());\n \n     let mut out = Vec::new();\n     if let Some((tooltip, class)) = tooltip {\n@@ -43,7 +43,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>,\n     }\n     write_header(class, &mut out).unwrap();\n \n-    let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.codemap());\n+    let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.source_map());\n     if classifier.write_source(&mut out).is_err() {\n         return format!(\"<pre>{}</pre>\", src);\n     }"}, {"sha": "1438299d375b649ba2609c12a03eb82ce84771ae", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -45,7 +45,7 @@ pub struct ErrorLocation {\n impl ErrorLocation {\n     /// Create an error location from a span.\n     pub fn from_span(ecx: &ExtCtxt, sp: Span) -> ErrorLocation {\n-        let loc = ecx.codemap().lookup_char_pos_adj(sp.lo());\n+        let loc = ecx.source_map().lookup_char_pos_adj(sp.lo());\n         ErrorLocation {\n             filename: loc.filename,\n             line: loc.line"}, {"sha": "154fe11dd352c45882a15fe65001ddcac8558044", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -836,7 +836,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree]) -> parser::Parser<'a> {\n         parse::stream_to_parser(self.parse_sess, tts.iter().cloned().collect())\n     }\n-    pub fn codemap(&self) -> &'a SourceMap { self.parse_sess.codemap() }\n+    pub fn source_map(&self) -> &'a SourceMap { self.parse_sess.source_map() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {"}, {"sha": "b1bed9602f3629cd9cdaee863eecaa56ca2d0e25", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -764,7 +764,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n-        let loc = self.codemap().lookup_char_pos(span.lo());\n+        let loc = self.source_map().lookup_char_pos(span.lo());\n         let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name.to_string()));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n         let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);"}, {"sha": "b12b2c49caa58608c737675bb1565e610f58ef61", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let mut module = ModuleData {\n             mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n-            directory: match self.cx.codemap().span_to_unmapped_path(krate.span) {\n+            directory: match self.cx.source_map().span_to_unmapped_path(krate.span) {\n                 FileName::Real(path) => path,\n                 other => PathBuf::from(other.to_string()),\n             },\n@@ -1355,7 +1355,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                         module.directory.push(&*item.ident.as_str());\n                     }\n                 } else {\n-                    let path = self.cx.parse_sess.codemap().span_to_unmapped_path(inner);\n+                    let path = self.cx.parse_sess.source_map().span_to_unmapped_path(inner);\n                     let mut path = match path {\n                         FileName::Real(path) => path,\n                         other => PathBuf::from(other.to_string()),\n@@ -1563,7 +1563,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                             // Add this input file to the code map to make it available as\n                             // dependency information\n-                            self.cx.codemap().new_source_file(filename.into(), src);\n+                            self.cx.source_map().new_source_file(filename.into(), src);\n \n                             let include_info = vec![\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem("}, {"sha": "19a204cc989bfeb9f05dbdf775a08ca78f32d6ce", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -36,7 +36,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n+    let loc = cx.source_map().lookup_char_pos(topmost.lo());\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.line as u32))\n }\n@@ -47,7 +47,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n+    let loc = cx.source_map().lookup_char_pos(topmost.lo());\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.col.to_usize() as u32 + 1))\n }\n@@ -70,7 +70,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n+    let loc = cx.source_map().lookup_char_pos(topmost.lo());\n     base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name.to_string())))\n }\n \n@@ -154,7 +154,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n \n             // Add this input file to the code map to make it available as\n             // dependency information\n-            cx.codemap().new_source_file(file.into(), src);\n+            cx.source_map().new_source_file(file.into(), src);\n \n             base::MacEager::expr(cx.expr_str(sp, interned_src))\n         }\n@@ -184,7 +184,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n         Ok(..) => {\n             // Add this input file to the code map to make it available as\n             // dependency information, but don't enter it's contents\n-            cx.codemap().new_source_file(file.into(), \"\".to_string());\n+            cx.source_map().new_source_file(file.into(), \"\".to_string());\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Lrc::new(bytes))))\n         }\n@@ -199,7 +199,7 @@ fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: String) -> PathBuf\n     // after macro expansion (that is, they are unhygienic).\n     if !arg.is_absolute() {\n         let callsite = sp.source_callsite();\n-        let mut path = match cx.codemap().span_to_unmapped_path(callsite) {\n+        let mut path = match cx.source_map().span_to_unmapped_path(callsite) {\n             FileName::Real(path) => path,\n             other => panic!(\"cannot resolve relative path in non-file source `{}`\", other),\n         };"}, {"sha": "74f573fceba813eb5ee404fc7df061e3ce46e333", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -1556,7 +1556,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         if !name.as_str().is_ascii() {\n             gate_feature_post!(&self,\n                                non_ascii_idents,\n-                               self.context.parse_sess.codemap().def_span(sp),\n+                               self.context.parse_sess.source_map().def_span(sp),\n                                \"non-ascii idents are not fully supported.\");\n         }\n     }"}, {"sha": "dde0466f43c2d4cb540094f302327a3bc91cfa78", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -371,7 +371,7 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut\n {\n     let mut src = String::new();\n     srdr.read_to_string(&mut src).unwrap();\n-    let cm = SourceMap::new(sess.codemap().path_mapping().clone());\n+    let cm = SourceMap::new(sess.source_map().path_mapping().clone());\n     let source_file = cm.new_source_file(path, src);\n     let mut rdr = lexer::StringReader::new_raw(sess, source_file, None);\n "}, {"sha": "6cfa2b4abe89be9dce0e62fd48ea18128827ed79", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -234,8 +234,8 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n-        let begin = sess.codemap().lookup_byte_offset(span.lo());\n-        let end = sess.codemap().lookup_byte_offset(span.hi());\n+        let begin = sess.source_map().lookup_byte_offset(span.lo());\n+        let end = sess.source_map().lookup_byte_offset(span.hi());\n \n         // Make the range zero-length if the span is invalid.\n         if span.lo() > span.hi() || begin.fm.start_pos != end.fm.start_pos {"}, {"sha": "3f66dae4e1bb0455e36cbfa4e0de5649e50218de", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -86,7 +86,7 @@ impl ParseSess {\n         }\n     }\n \n-    pub fn codemap(&self) -> &SourceMap {\n+    pub fn source_map(&self) -> &SourceMap {\n         &self.code_map\n     }\n \n@@ -171,13 +171,13 @@ crate fn parse_stmt_from_source_str(name: FileName, source: String, sess: &Parse\n pub fn parse_stream_from_source_str(name: FileName, source: String, sess: &ParseSess,\n                                     override_span: Option<Span>)\n                                     -> TokenStream {\n-    source_file_to_stream(sess, sess.codemap().new_source_file(name, source), override_span)\n+    source_file_to_stream(sess, sess.source_map().new_source_file(name, source), override_span)\n }\n \n // Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n                                       -> Parser {\n-    let mut parser = source_file_to_parser(sess, sess.codemap().new_source_file(name, source));\n+    let mut parser = source_file_to_parser(sess, sess.source_map().new_source_file(name, source));\n     parser.recurse_into_file_modules = false;\n     parser\n }\n@@ -227,7 +227,7 @@ pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n /// add the path to the session's codemap and return the new source_file.\n fn file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n                    -> Lrc<SourceFile> {\n-    match sess.codemap().load_file(path) {\n+    match sess.source_map().load_file(path) {\n         Ok(source_file) => source_file,\n         Err(e) => {\n             let msg = format!(\"couldn't read {:?}: {}\", path.display(), e);\n@@ -969,7 +969,7 @@ mod tests {\n \n             let span = tts.iter().rev().next().unwrap().span();\n \n-            match sess.codemap().span_to_snippet(span) {\n+            match sess.source_map().span_to_snippet(span) {\n                 Ok(s) => assert_eq!(&s[..], \"{ body }\"),\n                 Err(_) => panic!(\"could not get snippet\"),\n             }"}, {"sha": "c9053f0fec93f0357c22fff8fc215a472ecf01f7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -577,7 +577,7 @@ impl<'a> Parser<'a> {\n         if let Some(directory) = directory {\n             parser.directory = directory;\n         } else if !parser.span.is_dummy() {\n-            if let FileName::Real(mut path) = sess.codemap().span_to_unmapped_path(parser.span) {\n+            if let FileName::Real(mut path) = sess.source_map().span_to_unmapped_path(parser.span) {\n                 path.pop();\n                 parser.directory.path = Cow::from(path);\n             }\n@@ -652,10 +652,10 @@ impl<'a> Parser<'a> {\n                     // EOF, don't want to point at the following char, but rather the last token\n                     self.prev_span\n                 } else {\n-                    self.sess.codemap().next_point(self.prev_span)\n+                    self.sess.source_map().next_point(self.prev_span)\n                 };\n                 let label_exp = format!(\"expected `{}`\", token_str);\n-                let cm = self.sess.codemap();\n+                let cm = self.sess.source_map();\n                 match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n                     (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n                         // When the spans are in the same line, it means that the only content\n@@ -720,14 +720,14 @@ impl<'a> Parser<'a> {\n                     expect.clone()\n                 };\n                 (format!(\"expected one of {}, found `{}`\", expect, actual),\n-                 (self.sess.codemap().next_point(self.prev_span),\n+                 (self.sess.source_map().next_point(self.prev_span),\n                   format!(\"expected one of {} here\", short_expect)))\n             } else if expected.is_empty() {\n                 (format!(\"unexpected token: `{}`\", actual),\n                  (self.prev_span, \"unexpected token after this\".to_string()))\n             } else {\n                 (format!(\"expected {}, found `{}`\", expect, actual),\n-                 (self.sess.codemap().next_point(self.prev_span),\n+                 (self.sess.source_map().next_point(self.prev_span),\n                   format!(\"expected {} here\", expect)))\n             };\n             let mut err = self.fatal(&msg_exp);\n@@ -738,7 +738,7 @@ impl<'a> Parser<'a> {\n                 label_sp\n             };\n \n-            let cm = self.sess.codemap();\n+            let cm = self.sess.source_map();\n             match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n                 (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n                     // When the spans are in the same line, it means that the only content between\n@@ -2902,7 +2902,7 @@ impl<'a> Parser<'a> {\n                                                   self.this_token_descr()));\n                     // span the `not` plus trailing whitespace to avoid\n                     // trailing whitespace after the `!` in our suggestion\n-                    let to_replace = self.sess.codemap()\n+                    let to_replace = self.sess.source_map()\n                         .span_until_non_whitespace(lo.to(self.span));\n                     err.span_suggestion_short_with_applicability(\n                         to_replace,\n@@ -3000,7 +3000,7 @@ impl<'a> Parser<'a> {\n                     Err(mut err) => {\n                         err.span_label(self.span,\n                                        \"expecting a type here because of type ascription\");\n-                        let cm = self.sess.codemap();\n+                        let cm = self.sess.source_map();\n                         let cur_pos = cm.lookup_char_pos(self.span.lo());\n                         let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n                         if cur_pos.line != op_pos.line {\n@@ -3161,7 +3161,7 @@ impl<'a> Parser<'a> {\n                             id: ast::DUMMY_NODE_ID\n                         }));\n \n-                        let expr_str = self.sess.codemap().span_to_snippet(expr.span)\n+                        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n                                                 .unwrap_or(pprust::expr_to_string(&expr));\n                         err.span_suggestion_with_applicability(\n                             expr.span,\n@@ -3277,7 +3277,7 @@ impl<'a> Parser<'a> {\n         // return. This won't catch blocks with an explicit `return`, but that would be caught by\n         // the dead code lint.\n         if self.eat_keyword(keywords::Else) || !cond.returns() {\n-            let sp = self.sess.codemap().next_point(lo);\n+            let sp = self.sess.source_map().next_point(lo);\n             let mut err = self.diagnostic()\n                 .struct_span_err(sp, \"missing condition for `if` statemement\");\n             err.span_label(sp, \"expected if condition here\");\n@@ -3527,7 +3527,7 @@ impl<'a> Parser<'a> {\n             && self.token != token::CloseDelim(token::Brace);\n \n         if require_comma {\n-            let cm = self.sess.codemap();\n+            let cm = self.sess.source_map();\n             self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])\n                 .map_err(|mut err| {\n                     match (cm.span_to_lines(expr.span), cm.span_to_lines(arm_start_span)) {\n@@ -3837,7 +3837,7 @@ impl<'a> Parser<'a> {\n                 err.span_label(self.span, \"expected `}`\");\n                 let mut comma_sp = None;\n                 if self.token == token::Comma { // Issue #49257\n-                    etc_sp = etc_sp.to(self.sess.codemap().span_until_non_whitespace(self.span));\n+                    etc_sp = etc_sp.to(self.sess.source_map().span_until_non_whitespace(self.span));\n                     err.span_label(etc_sp,\n                                    \"`..` must be at the end and cannot have a trailing comma\");\n                     comma_sp = Some(self.span);\n@@ -3955,7 +3955,7 @@ impl<'a> Parser<'a> {\n             let seq_span = pat.span.to(self.prev_span);\n             let mut err = self.struct_span_err(comma_span,\n                                                \"unexpected `,` in pattern\");\n-            if let Ok(seq_snippet) = self.sess.codemap().span_to_snippet(seq_span) {\n+            if let Ok(seq_snippet) = self.sess.source_map().span_to_snippet(seq_span) {\n                 err.span_suggestion_with_applicability(\n                     seq_span,\n                     \"try adding parentheses\",\n@@ -4220,7 +4220,7 @@ impl<'a> Parser<'a> {\n                     let parser_snapshot_after_type = self.clone();\n                     mem::replace(self, parser_snapshot_before_type);\n \n-                    let snippet = self.sess.codemap().span_to_snippet(pat.span).unwrap();\n+                    let snippet = self.sess.source_map().span_to_snippet(pat.span).unwrap();\n                     err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n                     (Some((parser_snapshot_after_type, colon_sp, err)), None)\n                 }\n@@ -6039,7 +6039,7 @@ impl<'a> Parser<'a> {\n                     err.emit();\n                 } else {\n                     if seen_comma == false {\n-                        let sp = self.sess.codemap().next_point(previous_span);\n+                        let sp = self.sess.source_map().next_point(previous_span);\n                         err.span_suggestion_with_applicability(\n                             sp,\n                             \"missing comma here\",\n@@ -6051,7 +6051,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             _ => {\n-                let sp = self.sess.codemap().next_point(self.prev_span);\n+                let sp = self.sess.source_map().next_point(self.prev_span);\n                 let mut err = self.struct_span_err(sp, &format!(\"expected `,`, or `}}`, found `{}`\",\n                                                                 self.this_token_to_string()));\n                 if self.token.is_ident() {\n@@ -6418,7 +6418,7 @@ impl<'a> Parser<'a> {\n             DirectoryOwnership::UnownedViaMod(_) => None,\n         };\n         let paths = Parser::default_submod_path(\n-                        id, relative, &self.directory.path, self.sess.codemap());\n+                        id, relative, &self.directory.path, self.sess.source_map());\n \n         match self.directory.ownership {\n             DirectoryOwnership::Owned { .. } => {\n@@ -6445,7 +6445,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self.diagnostic().struct_span_err(id_sp,\n                     \"cannot declare a new module at this location\");\n                 if !id_sp.is_dummy() {\n-                    let src_path = self.sess.codemap().span_to_filename(id_sp);\n+                    let src_path = self.sess.source_map().span_to_filename(id_sp);\n                     if let FileName::Real(src_path) = src_path {\n                         if let Some(stem) = src_path.file_stem() {\n                             let mut dest_path = src_path.clone();\n@@ -7207,7 +7207,7 @@ impl<'a> Parser<'a> {\n                         sp, &suggestion, format!(\" {} \", kw), Applicability::MachineApplicable\n                     );\n                 } else {\n-                    if let Ok(snippet) = self.sess.codemap().span_to_snippet(ident_sp) {\n+                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(ident_sp) {\n                         err.span_suggestion_with_applicability(\n                             full_sp,\n                             \"if you meant to call a macro, try\","}, {"sha": "374154e63333d221ce0f381cc9dfa7414949ebbd", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -21,7 +21,7 @@ use std::path::PathBuf;\n /// Map a string to tts, using a made-up filename:\n pub fn string_to_stream(source_str: String) -> TokenStream {\n     let ps = ParseSess::new(FilePathMapping::empty());\n-    source_file_to_stream(&ps, ps.codemap()\n+    source_file_to_stream(&ps, ps.source_map()\n                              .new_source_file(PathBuf::from(\"bogofile\").into(), source_str), None)\n }\n "}, {"sha": "d97c0b14f797a998fa8bff2701b97f412d749b32", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=d3fe97f3d32b4cef1c22b6a5ba5326b1b195e262", "patch": "@@ -801,7 +801,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         }\n     };\n \n-    let is_literal = match ecx.codemap().span_to_snippet(fmt_sp) {\n+    let is_literal = match ecx.source_map().span_to_snippet(fmt_sp) {\n         Ok(ref s) if s.starts_with(\"\\\"\") || s.starts_with(\"r#\") => true,\n         _ => false,\n     };"}]}