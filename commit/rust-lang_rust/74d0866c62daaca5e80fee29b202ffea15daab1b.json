{"sha": "74d0866c62daaca5e80fee29b202ffea15daab1b", "node_id": "C_kwDOAAsO6NoAKDc0ZDA4NjZjNjJkYWFjYTVlODBmZWUyOWIyMDJmZmVhMTVkYWFiMWI", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-03-07T12:38:58Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-03-07T19:19:53Z"}, "message": "Remove redundant code from copy-suggestions", "tree": {"sha": "cf37c96fd7ef96143478724d8ed70e8661f68492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf37c96fd7ef96143478724d8ed70e8661f68492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74d0866c62daaca5e80fee29b202ffea15daab1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74d0866c62daaca5e80fee29b202ffea15daab1b", "html_url": "https://github.com/rust-lang/rust/commit/74d0866c62daaca5e80fee29b202ffea15daab1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74d0866c62daaca5e80fee29b202ffea15daab1b/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecb867ec3cefa97a5807453a68758392730e3ed9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecb867ec3cefa97a5807453a68758392730e3ed9", "html_url": "https://github.com/rust-lang/rust/commit/ecb867ec3cefa97a5807453a68758392730e3ed9"}], "stats": {"total": 135, "additions": 55, "deletions": 80}, "files": [{"sha": "7e259abd8032fa633ab164b930ea51917339e914", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 55, "deletions": 80, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/74d0866c62daaca5e80fee29b202ffea15daab1b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d0866c62daaca5e80fee29b202ffea15daab1b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=74d0866c62daaca5e80fee29b202ffea15daab1b", "patch": "@@ -12,9 +12,7 @@ use rustc_middle::mir::{\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{\n-    self, suggest_constraining_type_param, suggest_constraining_type_params, PredicateKind, Ty,\n-};\n+use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n@@ -410,86 +408,63 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     Some(ref name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n                 };\n-                if let ty::Param(param_ty) = ty.kind() {\n-                    let tcx = self.infcx.tcx;\n-                    let generics = tcx.generics_of(self.mir_def_id());\n-                    let param = generics.type_param(&param_ty, tcx);\n-                    if let Some(generics) = tcx\n-                        .typeck_root_def_id(self.mir_def_id().to_def_id())\n-                        .as_local()\n-                        .and_then(|def_id| tcx.hir().get_generics(def_id))\n-                    {\n-                        suggest_constraining_type_param(\n-                            tcx,\n-                            generics,\n-                            &mut err,\n-                            param.name.as_str(),\n-                            \"Copy\",\n-                            None,\n+\n+                // Try to find predicates on *generic params* that would allow copying `ty`\n+                let tcx = self.infcx.tcx;\n+                let generics = tcx.generics_of(self.mir_def_id());\n+                if let Some(hir_generics) = tcx\n+                    .typeck_root_def_id(self.mir_def_id().to_def_id())\n+                    .as_local()\n+                    .and_then(|def_id| tcx.hir().get_generics(def_id))\n+                {\n+                    let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n+                        let mut fulfill_cx =\n+                            <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+\n+                        let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+                        let cause = ObligationCause::new(\n+                            span,\n+                            self.mir_hir_id(),\n+                            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n                         );\n-                    }\n-                } else {\n-                    // Try to find predicates on *generic params* that would allow copying `ty`\n-\n-                    let tcx = self.infcx.tcx;\n-                    let generics = tcx.generics_of(self.mir_def_id());\n-                    if let Some(hir_generics) = tcx\n-                        .typeck_root_def_id(self.mir_def_id().to_def_id())\n-                        .as_local()\n-                        .and_then(|def_id| tcx.hir().get_generics(def_id))\n-                    {\n-                        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n-                            let mut fulfill_cx =\n-                                <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n-\n-                            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n-                            let cause = ObligationCause::new(\n-                                span,\n-                                self.mir_hir_id(),\n-                                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-                            );\n-                            fulfill_cx.register_bound(\n-                                &infcx,\n-                                self.param_env,\n-                                // Erase any region vids from the type, which may not be resolved\n-                                infcx.tcx.erase_regions(ty),\n-                                copy_did,\n-                                cause,\n-                            );\n-                            // Select all, including ambiguous predicates\n-                            let errors = fulfill_cx.select_all_or_error(&infcx);\n-\n-                            // Only emit suggestion if all required predicates are on generic\n-                            errors\n-                                .into_iter()\n-                                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n-                                    PredicateKind::Trait(predicate) => {\n-                                        match predicate.self_ty().kind() {\n-                                            ty::Param(param_ty) => Ok((\n-                                                generics.type_param(param_ty, tcx),\n-                                                predicate\n-                                                    .trait_ref\n-                                                    .print_only_trait_path()\n-                                                    .to_string(),\n-                                            )),\n-                                            _ => Err(()),\n-                                        }\n+                        fulfill_cx.register_bound(\n+                            &infcx,\n+                            self.param_env,\n+                            // Erase any region vids from the type, which may not be resolved\n+                            infcx.tcx.erase_regions(ty),\n+                            copy_did,\n+                            cause,\n+                        );\n+                        // Select all, including ambiguous predicates\n+                        let errors = fulfill_cx.select_all_or_error(&infcx);\n+\n+                        // Only emit suggestion if all required predicates are on generic\n+                        errors\n+                            .into_iter()\n+                            .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                                PredicateKind::Trait(predicate) => {\n+                                    match predicate.self_ty().kind() {\n+                                        ty::Param(param_ty) => Ok((\n+                                            generics.type_param(param_ty, tcx),\n+                                            predicate.trait_ref.print_only_trait_path().to_string(),\n+                                        )),\n+                                        _ => Err(()),\n                                     }\n-                                    _ => Err(()),\n-                                })\n-                                .collect()\n-                        });\n+                                }\n+                                _ => Err(()),\n+                            })\n+                            .collect()\n+                    });\n \n-                        if let Ok(predicates) = predicates {\n-                            suggest_constraining_type_params(\n-                                tcx,\n-                                hir_generics,\n-                                &mut err,\n-                                predicates.iter().map(|(param, constraint)| {\n-                                    (param.name.as_str(), &**constraint, None)\n-                                }),\n-                            );\n-                        }\n+                    if let Ok(predicates) = predicates {\n+                        suggest_constraining_type_params(\n+                            tcx,\n+                            hir_generics,\n+                            &mut err,\n+                            predicates.iter().map(|(param, constraint)| {\n+                                (param.name.as_str(), &**constraint, None)\n+                            }),\n+                        );\n                     }\n                 }\n "}]}