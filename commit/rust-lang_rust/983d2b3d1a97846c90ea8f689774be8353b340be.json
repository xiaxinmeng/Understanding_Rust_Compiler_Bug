{"sha": "983d2b3d1a97846c90ea8f689774be8353b340be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4M2QyYjNkMWE5Nzg0NmM5MGVhOGY2ODk3NzRiZTgzNTNiMzQwYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-22T06:30:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-22T06:30:53Z"}, "message": "Auto merge of #27826 - sfackler:wait-timeout-enum, r=alexcrichton\n\nReturning a primitive bool results in a somewhat confusing API - does\r\n`true` indicate success - i.e. no timeout, or that a timeout has\r\noccurred? An explicitly named enum makes it clearer.\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton", "tree": {"sha": "9f3393410af3fea1fa1117290db82d9c9bb5301d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f3393410af3fea1fa1117290db82d9c9bb5301d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/983d2b3d1a97846c90ea8f689774be8353b340be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/983d2b3d1a97846c90ea8f689774be8353b340be", "html_url": "https://github.com/rust-lang/rust/commit/983d2b3d1a97846c90ea8f689774be8353b340be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/983d2b3d1a97846c90ea8f689774be8353b340be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a03ec1a07a1f8d32d6f6a1d57ba1012fb3c8cd79", "url": "https://api.github.com/repos/rust-lang/rust/commits/a03ec1a07a1f8d32d6f6a1d57ba1012fb3c8cd79", "html_url": "https://github.com/rust-lang/rust/commit/a03ec1a07a1f8d32d6f6a1d57ba1012fb3c8cd79"}, {"sha": "12216b7209431ae2a53d52c3a41c0d3536ab2210", "url": "https://api.github.com/repos/rust-lang/rust/commits/12216b7209431ae2a53d52c3a41c0d3536ab2210", "html_url": "https://github.com/rust-lang/rust/commit/12216b7209431ae2a53d52c3a41c0d3536ab2210"}], "stats": {"total": 63, "additions": 42, "deletions": 21}, "files": [{"sha": "851726d91c6e873d46dca4969ab882113a53808a", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/983d2b3d1a97846c90ea8f689774be8353b340be/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/983d2b3d1a97846c90ea8f689774be8353b340be/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=983d2b3d1a97846c90ea8f689774be8353b340be", "patch": "@@ -18,6 +18,20 @@ use sys_common::poison::{self, LockResult};\n use sys::time::SteadyTime;\n use time::Duration;\n \n+/// A type indicating whether a timed wait on a condition variable returned\n+/// due to a time out or not.\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+#[unstable(feature = \"wait_timeout\", reason = \"newly added\", issue = \"27772\")]\n+pub struct WaitTimeoutResult(bool);\n+\n+impl WaitTimeoutResult {\n+    /// Returns whether the wait was known to have timed out.\n+    #[unstable(feature = \"wait_timeout\", reason = \"newly added\", issue = \"27772\")]\n+    pub fn timed_out(&self) -> bool {\n+        self.0\n+    }\n+}\n+\n /// A Condition Variable\n ///\n /// Condition variables represent the ability to block a thread such that it\n@@ -170,16 +184,16 @@ impl Condvar {\n     /// preemption or platform differences that may not cause the maximum\n     /// amount of time waited to be precisely `dur`.\n     ///\n-    /// The returned boolean is `false` only if the timeout is known\n-    /// to have elapsed.\n+    /// The returned `WaitTimeoutResult` value indicates if the timeout is\n+    /// known to have elapsed.\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n     #[unstable(feature = \"wait_timeout\", reason = \"waiting for Duration\",\n                issue = \"27772\")]\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n                                dur: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+                               -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n             me.inner.wait_timeout(guard, dur)\n@@ -199,7 +213,7 @@ impl Condvar {\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n                                        f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, bool)>\n+                                       -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n             where F: FnMut(LockResult<&mut T>) -> bool {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n@@ -278,7 +292,13 @@ impl StaticCondvar {\n                issue = \"27717\")]\n     pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)\n                                   -> LockResult<(MutexGuard<'a, T>, bool)> {\n-        self.wait_timeout(guard, Duration::from_millis(ms as u64))\n+        match self.wait_timeout(guard, Duration::from_millis(ms as u64)) {\n+            Ok((guard, timed_out)) => Ok((guard, !timed_out.timed_out())),\n+            Err(poison) => {\n+                let (guard, timed_out) = poison.into_inner();\n+                Err(PoisonError::new((guard, !timed_out.timed_out())))\n+            }\n+        }\n     }\n \n     /// Waits on this condition variable for a notification, timing out after a\n@@ -291,17 +311,17 @@ impl StaticCondvar {\n     pub fn wait_timeout<'a, T>(&'static self,\n                                guard: MutexGuard<'a, T>,\n                                timeout: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n-        let (poisoned, success) = unsafe {\n+                               -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n+        let (poisoned, result) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n             self.verify(lock);\n             let success = self.inner.wait_timeout(lock, timeout);\n-            (mutex::guard_poison(&guard).get(), success)\n+            (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n         };\n         if poisoned {\n-            Err(PoisonError::new((guard, success)))\n+            Err(PoisonError::new((guard, result)))\n         } else {\n-            Ok((guard, success))\n+            Ok((guard, result))\n         }\n     }\n \n@@ -319,7 +339,7 @@ impl StaticCondvar {\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n                                        mut f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, bool)>\n+                                       -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n             where F: FnMut(LockResult<&mut T>) -> bool {\n         // This could be made more efficient by pushing the implementation into\n         // sys::condvar\n@@ -332,28 +352,29 @@ impl StaticCondvar {\n             let now = SteadyTime::now();\n             let consumed = &now - &start;\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n-            let (new_guard_result, no_timeout) = if consumed > dur {\n-                (Ok(guard), false)\n+            let (new_guard_result, timed_out) = if consumed > dur {\n+                (Ok(guard), WaitTimeoutResult(true))\n             } else {\n                 match self.wait_timeout(guard, dur - consumed) {\n-                    Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n+                    Ok((new_guard, timed_out)) => (Ok(new_guard), timed_out),\n                     Err(err) => {\n                         let (new_guard, no_timeout) = err.into_inner();\n                         (Err(PoisonError::new(new_guard)), no_timeout)\n                     }\n                 }\n             };\n             guard_result = new_guard_result;\n-            if !no_timeout {\n+            if timed_out.timed_out() {\n                 let result = f(guard_result\n                                     .as_mut()\n                                     .map(|g| &mut **g)\n                                     .map_err(|e| PoisonError::new(&mut **e.get_mut())));\n+                let result = WaitTimeoutResult(!result);\n                 return poison::map_result(guard_result, |g| (g, result));\n             }\n         }\n \n-        poison::map_result(guard_result, |g| (g, true))\n+        poison::map_result(guard_result, |g| (g, WaitTimeoutResult(false)))\n     }\n \n     /// Wakes up one blocked thread on this condvar.\n@@ -508,10 +529,10 @@ mod tests {\n         static S: AtomicUsize = AtomicUsize::new(0);\n \n         let g = M.lock().unwrap();\n-        let (g, success) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n+        let (g, timed_out) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n             false\n         }).unwrap();\n-        assert!(!success);\n+        assert!(timed_out.timed_out());\n \n         let (tx, rx) = channel();\n         let _t = thread::spawn(move || {\n@@ -535,7 +556,7 @@ mod tests {\n \n         let mut state = 0;\n         let day = 24 * 60 * 60;\n-        let (_g, success) = C.wait_timeout_with(g, Duration::new(day, 0), |_| {\n+        let (_g, timed_out) = C.wait_timeout_with(g, Duration::new(day, 0), |_| {\n             assert_eq!(state, S.load(Ordering::SeqCst));\n             tx.send(()).unwrap();\n             state += 1;\n@@ -544,7 +565,7 @@ mod tests {\n                 _ => true,\n             }\n         }).unwrap();\n-        assert!(success);\n+        assert!(!timed_out.timed_out());\n     }\n \n     #[test]"}, {"sha": "ae21503cf6746d31318698d6b7aa9ca3505c489c", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/983d2b3d1a97846c90ea8f689774be8353b340be/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/983d2b3d1a97846c90ea8f689774be8353b340be/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=983d2b3d1a97846c90ea8f689774be8353b340be", "patch": "@@ -21,7 +21,7 @@ pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;\n \n pub use self::barrier::{Barrier, BarrierWaitResult};\n-pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n+pub use self::condvar::{Condvar, StaticCondvar, WaitTimeoutResult, CONDVAR_INIT};\n pub use self::mutex::MUTEX_INIT;\n pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::once::{Once, ONCE_INIT};"}]}