{"sha": "382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MmRjMGNjYjI2YjM4MDNkMWU2ZjVkZmVhZjZlNWIyYzg5NDBiNzM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-10T02:08:37Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-10T02:08:37Z"}, "message": "Update for my github username change.", "tree": {"sha": "b94b041a23058d931440c3c2ac6d619d856d0d48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b94b041a23058d931440c3c2ac6d619d856d0d48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "html_url": "https://github.com/rust-lang/rust/commit/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddfbb655e1b4793022265088c0548611758efba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddfbb655e1b4793022265088c0548611758efba7", "html_url": "https://github.com/rust-lang/rust/commit/ddfbb655e1b4793022265088c0548611758efba7"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "f9ae9e7d4e61907d7bc26a59229d813ecac24277", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "patch": "@@ -3,7 +3,7 @@ authors = [\"Scott Olson <scott@solson.me>\"]\n description = \"An experimental interpreter for Rust MIR.\"\n license = \"ISC\"\n name = \"miri\"\n-repository = \"https://github.com/tsion/miri\"\n+repository = \"https://github.com/solson/miri\"\n version = \"0.1.0\"\n \n [[bin]]"}, {"sha": "a553d046f1fddfc491cca61bccf7c061af105b79", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "patch": "@@ -7,7 +7,7 @@ An experimental interpreter for [Rust][rust]'s [mid-level intermediate\n representation][mir] (MIR). This project began as part of my work for the\n undergraduate research course at the [University of Saskatchewan][usask].\n \n-[![Build Status](https://travis-ci.org/tsion/miri.svg?branch=master)](https://travis-ci.org/tsion/miri)\n+[![Build Status](https://travis-ci.org/solson/miri.svg?branch=master)](https://travis-ci.org/solson/miri)\n \n ## Download Rust nightly\n "}, {"sha": "d1a395bbf3438ed8e89e8b4cbd3b7a64912bc161", "filename": "src/interpreter.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "patch": "@@ -21,7 +21,7 @@ use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n use primval::{self, PrimVal};\n \n-const TRACE_EXECUTION: bool = false;\n+const TRACE_EXECUTION: bool = true;\n \n struct GlobalEvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -41,7 +41,7 @@ struct GlobalEvalContext<'a, 'tcx: 'a> {\n     /// *creating* the `Frame` for that same function.\n     substs_stack: Vec<&'tcx Substs<'tcx>>,\n \n-    // TODO(tsion): Merge with `substs_stack`. Also try restructuring `Frame` to accomodate.\n+    // TODO(solson): Merge with `substs_stack`. Also try restructuring `Frame` to accomodate.\n     /// A stack of the things necessary to print good strack traces:\n     ///   * Function DefIds and Substs to print proper substituted function names.\n     ///   * Spans pointing to specific function calls in the source.\n@@ -101,7 +101,7 @@ struct Lvalue {\n enum LvalueExtra {\n     None,\n     Length(u64),\n-    // TODO(tsion): Vtable(memory::AllocId),\n+    // TODO(solson): Vtable(memory::AllocId),\n     DowncastVariant(usize),\n }\n \n@@ -148,7 +148,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         if let Err(ref e) = r {\n             let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n             for &(def_id, substs, span) in self.name_stack.iter().rev() {\n-                // FIXME(tsion): Find a way to do this without this Display impl hack.\n+                // FIXME(solson): Find a way to do this without this Display impl hack.\n                 use rustc::util::ppaux;\n                 use std::fmt;\n                 struct Instance<'tcx>(DefId, &'tcx Substs<'tcx>);\n@@ -254,7 +254,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n     fn pop_stack_frame(&mut self) {\n         let _frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n-        // TODO(tsion): Deallocate local variables.\n+        // TODO(solson): Deallocate local variables.\n         self.substs_stack.pop();\n     }\n \n@@ -356,7 +356,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                             Abi::C => self.call_c_abi(def_id, args, return_ptr.unwrap())?,\n \n                             Abi::Rust | Abi::RustCall => {\n-                                // TODO(tsion): Adjust the first argument when calling a Fn or\n+                                // TODO(solson): Adjust the first argument when calling a Fn or\n                                 // FnMut closure via FnOnce::call_once.\n \n                                 // Only trait methods can have a Self parameter.\n@@ -434,7 +434,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         }\n         self.log(1, || print!(\"need to drop {:?}\", ty));\n \n-        // TODO(tsion): Call user-defined Drop::drop impls.\n+        // TODO(solson): Call user-defined Drop::drop impls.\n \n         match ty.sty {\n             ty::TyBox(contents_ty) => {\n@@ -457,12 +457,12 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 }\n             }\n \n-            // TODO(tsion): Implement drop for other relevant types (e.g. aggregates).\n+            // TODO(solson): Implement drop for other relevant types (e.g. aggregates).\n             _ => {}\n         }\n \n         // Filling drop.\n-        // FIXME(tsion): Trait objects (with no static size) probably get filled, too.\n+        // FIXME(solson): Trait objects (with no static size) probably get filled, too.\n         let size = self.type_size(ty);\n         self.memory.drop_fill(ptr, size)?;\n \n@@ -512,7 +512,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 self.move_(args[1], ptr, ty)?;\n             }\n \n-            // FIXME(tsion): Handle different integer types correctly.\n+            // FIXME(solson): Handle different integer types correctly.\n             \"add_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty);\n@@ -525,7 +525,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 self.memory.write_bool(dest.offset(size as isize), overflowed)?;\n             }\n \n-            // FIXME(tsion): Handle different integer types correctly.\n+            // FIXME(solson): Handle different integer types correctly.\n             \"mul_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty);\n@@ -558,7 +558,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 }\n             }\n \n-            // FIXME(tsion): Handle different integer types correctly. Use primvals?\n+            // FIXME(solson): Handle different integer types correctly. Use primvals?\n             \"overflowing_sub\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty);\n@@ -820,7 +820,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     }\n \n                     Misc => {\n-                        // FIXME(tsion): Wrong for almost everything.\n+                        // FIXME(solson): Wrong for almost everything.\n                         let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n                         self.memory.copy(src, dest, size)?;\n                     }\n@@ -846,7 +846,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     Value { ref value } => Ok(self.const_to_ptr(value)?),\n                     Item { .. } => unimplemented!(),\n                     Promoted { index } => {\n-                        // TODO(tsion): Mark constants and statics as read-only and cache their\n+                        // TODO(solson): Mark constants and statics as read-only and cache their\n                         // values.\n                         let current_mir = self.mir();\n                         let mir = &current_mir.promoted[index];\n@@ -867,7 +867,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             Temp(i) => self.frame().locals[self.frame().temp_offset + i as usize],\n \n             Static(def_id) => {\n-                // TODO(tsion): Mark constants and statics as read-only and cache their values.\n+                // TODO(solson): Mark constants and statics as read-only and cache their values.\n                 let mir = self.load_mir(def_id);\n                 self.call_nested(&mir)?.unwrap()\n             }\n@@ -945,13 +945,13 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(Lvalue { ptr: ptr, extra: LvalueExtra::None })\n     }\n \n-    // TODO(tsion): Try making const_to_primval instead.\n+    // TODO(solson): Try making const_to_primval instead.\n     fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<Pointer> {\n         use rustc::middle::const_val::ConstVal::*;\n         match *const_val {\n             Float(_f) => unimplemented!(),\n             Integral(int) => {\n-                // TODO(tsion): Check int constant type.\n+                // TODO(solson): Check int constant type.\n                 let ptr = self.memory.allocate(8);\n                 self.memory.write_uint(ptr, int.to_u64_unchecked(), 8)?;\n                 Ok(ptr)\n@@ -1023,12 +1023,12 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn type_layout(&self, ty: ty::Ty<'tcx>) -> &'tcx Layout {\n-        // TODO(tsion): Is this inefficient? Needs investigation.\n+        // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty);\n \n         let infcx = infer::normalizing_infer_ctxt(self.tcx, &self.tcx.tables, ProjectionMode::Any);\n \n-        // TODO(tsion): Report this error properly.\n+        // TODO(solson): Report this error properly.\n         ty.layout(&infcx).unwrap()\n     }\n \n@@ -1045,7 +1045,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             ty::TyUint(UintTy::U32) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n             ty::TyUint(UintTy::U64) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n \n-            // TODO(tsion): Pick the PrimVal dynamically.\n+            // TODO(solson): Pick the PrimVal dynamically.\n             ty::TyInt(IntTy::Is)   => PrimVal::I64(self.memory.read_isize(ptr)?),\n             ty::TyUint(UintTy::Us) => PrimVal::U64(self.memory.read_usize(ptr)?),\n \n@@ -1255,7 +1255,7 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n                     Ok(Some(return_ptr)) => fecx.memory.dump(return_ptr.alloc_id),\n                     Ok(None) => println!(\"(diverging function returned)\"),\n                     Err(_e) => {\n-                        // TODO(tsion): Detect whether the error was already reported or not.\n+                        // TODO(solson): Detect whether the error was already reported or not.\n                         // tcx.sess.err(&e.to_string());\n                     }\n                 }\n@@ -1266,7 +1266,7 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n     }\n }\n \n-// TODO(tsion): Upstream these methods into rustc::ty::layout.\n+// TODO(solson): Upstream these methods into rustc::ty::layout.\n \n trait IntegerExt {\n     fn size(self) -> Size;"}, {"sha": "a42fd54669b635a01d8ad7e02e1b64d4fd24ec30", "filename": "src/memory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "patch": "@@ -54,7 +54,7 @@ impl Memory {\n             alloc_map: HashMap::new(),\n             next_id: AllocId(0),\n \n-            // FIXME(tsion): This should work for both 4 and 8, but it currently breaks some things\n+            // FIXME(solson): This should work for both 4 and 8, but it currently breaks some things\n             // when set to 4.\n             pointer_size: 8,\n         }\n@@ -75,11 +75,11 @@ impl Memory {\n         }\n     }\n \n-    // TODO(tsion): Track which allocations were returned from __rust_allocate and report an error\n+    // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n     pub fn reallocate(&mut self, ptr: Pointer, new_size: usize) -> EvalResult<()> {\n         if ptr.offset != 0 {\n-            // TODO(tsion): Report error about non-__rust_allocate'd pointer.\n+            // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             panic!()\n         }\n \n@@ -99,15 +99,15 @@ impl Memory {\n         Ok(())\n     }\n \n-    // TODO(tsion): See comment on `reallocate`.\n+    // TODO(solson): See comment on `reallocate`.\n     pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<()> {\n         if ptr.offset != 0 {\n-            // TODO(tsion): Report error about non-__rust_allocate'd pointer.\n+            // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             panic!()\n         }\n \n         if self.alloc_map.remove(&ptr.alloc_id).is_none() {\n-            // TODO(tsion): Report error about erroneous free. This is blocked on properly tracking\n+            // TODO(solson): Report error about erroneous free. This is blocked on properly tracking\n             // already-dropped state since this if-statement is entered even in safe code without\n             // it.\n         }\n@@ -403,7 +403,7 @@ impl Memory {\n     // Undefined bytes\n     ////////////////////////////////////////////////////////////////////////////////\n \n-    // FIXME(tsion): This is a very naive, slow version.\n+    // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         let mut v = Vec::with_capacity(size);"}, {"sha": "19faadc962e162bf15fb05b8fcaf6baba5ce34d6", "filename": "src/primval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "patch": "@@ -29,7 +29,7 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n                 BitAnd => $v($l & $r),\n                 BitOr  => $v($l | $r),\n \n-                // TODO(tsion): Can have differently-typed RHS.\n+                // TODO(solson): Can have differently-typed RHS.\n                 Shl => $v($l << $r),\n                 Shr => $v($l >> $r),\n "}, {"sha": "1ec3c5e0bb98ae26729c7ae87c030d500f9e6c4a", "filename": "tests/run-pass/std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/tests%2Frun-pass%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/tests%2Frun-pass%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstd.rs?ref=382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "patch": "@@ -1,7 +1,7 @@\n #![feature(custom_attribute, box_syntax)]\n #![allow(dead_code, unused_attributes)]\n \n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n use std::sync::Arc;\n \n@@ -13,8 +13,8 @@ fn rc_cell() -> Rc<Cell<i32>> {\n     r\n }\n \n-// TODO(tsion): borrow code needs to evaluate string statics via Lvalue::Static\n-// TODO(tsion): also requires destructors to run for the second borrow to work\n+// TODO(solson): also requires destructors to run for the second borrow to work\n+// TODO(solson): needs StructWrappedNullablePointer support\n // #[miri_run]\n // fn rc_refcell() -> i32 {\n //     let r = Rc::new(RefCell::new(42));"}, {"sha": "f8bb37b911330ad1d556fd363a0068a19329d21f", "filename": "tex/report/miri-report.tex", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/tex%2Freport%2Fmiri-report.tex", "raw_url": "https://github.com/rust-lang/rust/raw/382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73/tex%2Freport%2Fmiri-report.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Fmiri-report.tex?ref=382dc0ccb26b3803d1e6f5dfeaf6e5b2c8940b73", "patch": "@@ -97,7 +97,7 @@ \\section{First implementation}\n \\subsection{Basic operation}\n \n To investigate the possibility of executing Rust at compile-time I wrote an interpreter for MIR\n-called Miri\\footnote{\\url{https://github.com/tsion/miri}}. The structure of the interpreter closely\n+called Miri\\footnote{\\url{https://github.com/solson/miri}}. The structure of the interpreter closely\n mirrors the structure of MIR itself. It starts executing a function by iterating the statement list\n in the starting basic block, translating the lvalue into a pointer and using the rvalue to decide\n what to write into that pointer. Evaluating the rvalue may involve reads (such as for the two sides\n@@ -271,7 +271,7 @@ \\section{Deterministic execution}\n potentially unsafe code. When Miri encounters an unrecoverable error, it reports it via the Rust\n compiler's usual error reporting mechanism, pointing to the part of the original code where the\n error occurred. Below is an example from Miri's\n-repository.\\footnote{\\href{https://github.com/tsion/miri/blob/master/test/errors.rs}{miri/test/errors.rs}}\n+repository.\\footnote{\\href{https://github.com/solson/miri/blob/master/test/errors.rs}{miri/test/errors.rs}}\n \n \\begin{minted}[autogobble]{rust}\n   let b = Box::new(42);"}]}