{"sha": "a227994b5399d2ff236f116c4f62e10268ab1f73", "node_id": "C_kwDOAAsO6NoAKGEyMjc5OTRiNTM5OWQyZmYyMzZmMTE2YzRmNjJlMTAyNjhhYjFmNzM", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-07-24T01:08:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-24T01:08:07Z"}, "message": "Merge pull request #202 from rust-lang/fix/recursive-types\n\nCleanup regarding handling of recursive types", "tree": {"sha": "eb0535bddcc8d85381049396f8d2fbbeaaca32c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb0535bddcc8d85381049396f8d2fbbeaaca32c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a227994b5399d2ff236f116c4f62e10268ab1f73", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi3Jt3CRBK7hj4Ov3rIwAATpIIAIrKdM9tROjdMBvG/rKgwElr\nqkBL5mqNVuPz/LhM40w3bOwwlQkZsIztzHy2qzjv/XTIGLLeJeW2FS9DzlDa1a3M\nIRXwPBQbibcMooG76o9Qfl2vlpkgARH9Q87ND3VbT/gbfgmURkU+83R2vBsV4RZc\na5JlK2rbgFJLdAyqdYirsOgLiEC0oKNZz2fYOV4hV1+yYFPa5jAMJnDNak/1DEqk\nvM4VcObpUUWzZpHb93Ulvps6XwTLCHhVuuTntQdglBasLuSL5rwImHDPq6lOFuiY\n6crS9HBmTtao+nH/oM3DYSwVbt8yXjn/7tfH5mZdSdP3914FOFit94KTmmSmyrM=\n=4Vpf\n-----END PGP SIGNATURE-----\n", "payload": "tree eb0535bddcc8d85381049396f8d2fbbeaaca32c4\nparent 22e4f181cb9c5b376333b213ce92b8ebe55fb230\nparent 5f630f3c81583b7be15a230d47d48de0178b5da8\nauthor antoyo <antoyo@users.noreply.github.com> 1658624887 -0400\ncommitter GitHub <noreply@github.com> 1658624887 -0400\n\nMerge pull request #202 from rust-lang/fix/recursive-types\n\nCleanup regarding handling of recursive types"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a227994b5399d2ff236f116c4f62e10268ab1f73", "html_url": "https://github.com/rust-lang/rust/commit/a227994b5399d2ff236f116c4f62e10268ab1f73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a227994b5399d2ff236f116c4f62e10268ab1f73/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22e4f181cb9c5b376333b213ce92b8ebe55fb230", "url": "https://api.github.com/repos/rust-lang/rust/commits/22e4f181cb9c5b376333b213ce92b8ebe55fb230", "html_url": "https://github.com/rust-lang/rust/commit/22e4f181cb9c5b376333b213ce92b8ebe55fb230"}, {"sha": "5f630f3c81583b7be15a230d47d48de0178b5da8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f630f3c81583b7be15a230d47d48de0178b5da8", "html_url": "https://github.com/rust-lang/rust/commit/5f630f3c81583b7be15a230d47d48de0178b5da8"}], "stats": {"total": 71, "additions": 30, "deletions": 41}, "files": [{"sha": "fa40aa80804a1610646af6f68b3b430ca2de9a01", "filename": "src/asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     use ConstraintOrRegister::*;\n \n                     let (constraint, ty) = match (reg_to_gcc(reg), place) {\n-                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n+                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx)),\n                         // When `reg` is a class and not an explicit register but the out place is not specified,\n                         // we need to create an unused output variable to assign the output to. This var\n                         // needs to be of a type that's \"compatible\" with the register class, but specific type\n@@ -225,7 +225,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // This decision is also backed by the fact that LLVM needs in and out\n                     // values to be of *exactly the same type*, not just \"compatible\".\n                     // I'm not sure if GCC is so picky too, but better safe than sorry.\n-                    let ty = in_value.layout.gcc_type(self.cx, false);\n+                    let ty = in_value.layout.gcc_type(self.cx);\n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n \n                     // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n@@ -285,7 +285,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                             continue\n                         };\n \n-                        let ty = out_place.layout.gcc_type(self.cx, false);\n+                        let ty = out_place.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n@@ -305,7 +305,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 // `in(\"explicit register\") var`\n                 InlineAsmOperandRef::In { reg, value } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n-                        let ty = value.layout.gcc_type(self.cx, false);\n+                        let ty = value.layout.gcc_type(self.cx);\n                         let reg_var = self.current_func().new_local(None, ty, \"input_register\");\n                         reg_var.set_register_name(reg_name);\n                         self.llbb().add_assignment(None, reg_var, value.immediate());\n@@ -324,7 +324,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n                         // See explanation in the first pass.\n-                        let ty = in_value.layout.gcc_type(self.cx, false);\n+                        let ty = in_value.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n "}, {"sha": "616fc01b00c9f101ac1edf040dbb3831fb61e160", "filename": "src/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -745,7 +745,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if place.layout.is_gcc_immediate() {\n                 let load = self.load(\n-                    place.layout.gcc_type(self, false),\n+                    place.layout.gcc_type(self),\n                     place.llval,\n                     place.align,\n                 );\n@@ -756,7 +756,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n                 let b_offset = a.size(self).align_to(b.align(self).abi);\n-                let pair_type = place.layout.gcc_type(self, false);\n+                let pair_type = place.layout.gcc_type(self);\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {\n                     let llptr = self.struct_gep(pair_type, place.llval, i as u64);"}, {"sha": "9c55692dea121492f943238ed981a2830991878d", "filename": "src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -132,7 +132,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         });\n         let len = s_str.len();\n         let cs = self.const_ptrcast(str_global.get_address(None),\n-            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self, true)),\n+            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self)),\n         );\n         (cs, self.const_usize(len as u64))\n     }\n@@ -235,7 +235,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: ConstAllocation<'tcx>, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n         assert_eq!(alloc.inner().align, layout.align.abi);\n-        let ty = self.type_ptr_to(layout.gcc_type(self, true));\n+        let ty = self.type_ptr_to(layout.gcc_type(self));\n         let value =\n             if layout.size == Size::ZERO {\n                 let value = self.const_usize(alloc.inner().align.bytes());"}, {"sha": "e83cf53f48efdb415f4f27cbe9e3d8d7eafcfb96", "filename": "src/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -80,7 +80,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n         // TODO(antoyo): set alignment.\n \n@@ -211,7 +211,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let global =\n             if let Some(def_id) = def_id.as_local() {\n                 let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let llty = self.layout_of(ty).gcc_type(self, true);\n+                let llty = self.layout_of(ty).gcc_type(self);\n                 // FIXME: refactor this to work without accessing the HIR\n                 let global = match self.tcx.hir().get(id) {\n                     Node::Item(&hir::Item { span, kind: hir::ItemKind::Static(..), .. }) => {\n@@ -356,7 +356,7 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n \n fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-    let llty = cx.layout_of(ty).gcc_type(cx, true);\n+    let llty = cx.layout_of(ty).gcc_type(cx);\n     if let Some(linkage) = attrs.linkage {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -365,7 +365,7 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // that the static actually has a null value.\n         let llty2 =\n             if let ty::RawPtr(ref mt) = ty.kind() {\n-                cx.layout_of(mt.ty).gcc_type(cx, true)\n+                cx.layout_of(mt.ty).gcc_type(cx)\n             }\n             else {\n                 cx.sess().span_fatal("}, {"sha": "9879e31c2ea51f294e19b0f68b379db0c5b8423f", "filename": "src/context.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -1,6 +1,6 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Struct, Type};\n+use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n@@ -78,8 +78,6 @@ pub struct CodegenCx<'gcc, 'tcx> {\n \n     pub struct_types: RefCell<FxHashMap<Vec<Type<'gcc>>, Type<'gcc>>>,\n \n-    pub types_with_fields_to_set: RefCell<FxHashMap<Type<'gcc>, (Struct<'gcc>, TyAndLayout<'tcx>)>>,\n-\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n     /// Cache function instances of monomorphic and polymorphic items\n@@ -243,7 +241,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             types: Default::default(),\n             tcx,\n             struct_types: Default::default(),\n-            types_with_fields_to_set: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n             eh_personality: Cell::new(None),\n             pointee_infos: Default::default(),"}, {"sha": "1315edf0891ec69fde2a2ad21c42ec99126a5d10", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let name = tcx.item_name(def_id);\n         let name_str = name.as_str();\n \n-        let llret_ty = self.layout_of(ret_ty).gcc_type(self, true);\n+        let llret_ty = self.layout_of(ret_ty).gcc_type(self);\n         let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n \n         let simple = get_simple_intrinsic(self, name);\n@@ -389,7 +389,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     /// Gets the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n-        self.layout.gcc_type(cx, true)\n+        self.layout.gcc_type(cx)\n     }\n \n     /// Stores a direct/indirect value described by this ArgAbi into a"}, {"sha": "454c7538edb98cb99b444ccf37bc5a664407f89c", "filename": "src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -15,7 +15,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         let attrs = self.tcx.codegen_fn_attrs(def_id);\n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n         let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n         let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);"}, {"sha": "b85aad7c00b3cdf7e08ef446a08caf5f05ab2b38", "filename": "src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -273,7 +273,7 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n         result.push(cx.type_padding_filler(padding, padding_align));\n \n-        result.push(field.gcc_type(cx, !field.ty.is_any_ptr())); // FIXME(antoyo): might need to check if the type is inside another, like Box<Type>.\n+        result.push(field.gcc_type(cx));\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }"}, {"sha": "c7aa4239c7fae4243f02f973f19d7311b1b6decd", "filename": "src/type_of.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a227994b5399d2ff236f116c4f62e10268ab1f73/src%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_of.rs?ref=a227994b5399d2ff236f116c4f62e10268ab1f73", "patch": "@@ -50,7 +50,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n-pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n+fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         Abi::Vector { ref element, count } => {\n@@ -114,7 +114,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n                 },\n             }\n         }\n-        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx, true), count),\n+        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx), count),\n         FieldsShape::Arbitrary { .. } =>\n             match name {\n                 None => {\n@@ -133,7 +133,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n pub trait LayoutGccExt<'tcx> {\n     fn is_gcc_immediate(&self) -> bool;\n     fn is_gcc_scalar_pair(&self) -> bool;\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc>;\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn immediate_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc>;\n     fn scalar_pair_element_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, index: usize, immediate: bool) -> Type<'gcc>;\n@@ -168,8 +168,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    //TODO(antoyo): do we still need the set_fields parameter?\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc> {\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n         if let Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n@@ -179,10 +178,10 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             let ty =\n                 match *self.ty.kind() {\n                     ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx, set_fields))\n+                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx))\n                     }\n                     ty::Adt(def, _) if def.is_box() => {\n-                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx, true))\n+                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx))\n                     }\n                     ty::FnPtr(sig) => cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty())),\n                     _ => self.scalar_gcc_type_at(cx, scalar, Size::ZERO),\n@@ -199,13 +198,6 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             };\n         let cached_type = cx.types.borrow().get(&(self.ty, variant_index)).cloned();\n         if let Some(ty) = cached_type {\n-            let type_to_set_fields = cx.types_with_fields_to_set.borrow_mut().remove(&ty);\n-            if let Some((struct_type, layout)) = type_to_set_fields {\n-                // Since we might be trying to generate a type containing another type which is not\n-                // completely generated yet, we deferred setting the fields until now.\n-                let (fields, packed) = struct_fields(cx, layout);\n-                cx.set_struct_body(struct_type, &fields, packed);\n-            }\n             return ty;\n         }\n \n@@ -222,17 +214,17 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 if let Some(v) = variant_index {\n                     layout = layout.for_variant(cx, v);\n                 }\n-                layout.gcc_type(cx, true)\n+                layout.gcc_type(cx)\n             }\n             else {\n                 uncached_gcc_type(cx, *self, &mut defer)\n             };\n \n         cx.types.borrow_mut().insert((self.ty, variant_index), ty);\n \n-        if let Some((ty, layout)) = defer {\n+        if let Some((deferred_ty, layout)) = defer {\n             let (fields, packed) = struct_fields(cx, layout);\n-            cx.set_struct_body(ty, &fields, packed);\n+            cx.set_struct_body(deferred_ty, &fields, packed);\n         }\n \n         ty\n@@ -244,7 +236,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 return cx.type_i1();\n             }\n         }\n-        self.gcc_type(cx, true)\n+        self.gcc_type(cx)\n     }\n \n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc> {\n@@ -273,7 +265,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.kind() {\n             ty::Ref(..) | ty::RawPtr(_) => {\n-                return self.field(cx, index).gcc_type(cx, true);\n+                return self.field(cx, index).gcc_type(cx);\n             }\n             // only wide pointer boxes are handled as pointers\n             // thin pointer boxes with scalar allocators are handled by the general logic below\n@@ -343,7 +335,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n \n impl<'gcc, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {\n-        layout.gcc_type(self, true)\n+        layout.gcc_type(self)\n     }\n \n     fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {"}]}