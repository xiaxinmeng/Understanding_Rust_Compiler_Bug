{"sha": "04128982ffbf2609a94fa6b7786fe98c85c6b113", "node_id": "C_kwDOAAsO6NoAKDA0MTI4OTgyZmZiZjI2MDlhOTRmYTZiNzc4NmZlOThjODVjNmIxMTM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-16T16:51:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-16T16:51:24Z"}, "message": "Rollup merge of #108057 - GuillaumeGomez:fix-reexport-attr-merge, r=notriddle\n\nPrevent some attributes from being merged with others on reexports\n\nFinal fix for https://github.com/rust-lang/rust/issues/59368.\n\nAs discussed on zulip [here](https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Filtering.20sub.20attributes.20in.20ast.3A.3AAttribute), we need to clone the `Attribute` to be able to filter some parts of it. Then we need to go through the attributes to able to only keep what we want (everything except a few attributes in short).\n\nAs for the second commit, when I wrote the test, I realized that the code to traverse all reexports one by one to collect all their attributes was not completely working so I fixed the few issues remaining.\n\nr? `@notriddle`", "tree": {"sha": "5140daf1fd6a95f757ac3ffbf5921fe101215081", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5140daf1fd6a95f757ac3ffbf5921fe101215081"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04128982ffbf2609a94fa6b7786fe98c85c6b113", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj7l8MCRBK7hj4Ov3rIwAAQQAIAEiPQN2rSun0kz0yY7EFtwt8\n6cCv+G7kih+lg4xhsKmoEkw9ZBrkluQykuajg1NE5wCO84xHwWlZpu9qq6CLFfMg\nVyX7OMNGXwBVn6Hssm7FNbATTY26NlZNILJ4clR3sVtcOR3aR/hN6i96x8yjgiZm\nVo/37MRyU8wZS401j2LgrZIPFKO2a/Ae9eBJVgXyW1hvZNVUdBq1j2fuK0J6yJgB\n3Zp/tJ0R3MWw2n2CBkZy/egCbMCdi8ajWrlIAktN6wi+UzCOH8ffmm8l9h4iWanY\nml/hHFYvi8nAQGhJQ9Boc3TWl+HJDgHo3Fs9FrxeQHW259nzi3YLez1rOX5g6vU=\n=cSa0\n-----END PGP SIGNATURE-----\n", "payload": "tree 5140daf1fd6a95f757ac3ffbf5921fe101215081\nparent f65c6e416c6f401c332149da8f8ad1d7b8a218a7\nparent 374f798ad2f10280f75a3561f2dc9449ccb5e5fe\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676566284 +0100\ncommitter GitHub <noreply@github.com> 1676566284 +0100\n\nRollup merge of #108057 - GuillaumeGomez:fix-reexport-attr-merge, r=notriddle\n\nPrevent some attributes from being merged with others on reexports\n\nFinal fix for https://github.com/rust-lang/rust/issues/59368.\n\nAs discussed on zulip [here](https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Filtering.20sub.20attributes.20in.20ast.3A.3AAttribute), we need to clone the `Attribute` to be able to filter some parts of it. Then we need to go through the attributes to able to only keep what we want (everything except a few attributes in short).\n\nAs for the second commit, when I wrote the test, I realized that the code to traverse all reexports one by one to collect all their attributes was not completely working so I fixed the few issues remaining.\n\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04128982ffbf2609a94fa6b7786fe98c85c6b113", "html_url": "https://github.com/rust-lang/rust/commit/04128982ffbf2609a94fa6b7786fe98c85c6b113", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04128982ffbf2609a94fa6b7786fe98c85c6b113/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f65c6e416c6f401c332149da8f8ad1d7b8a218a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f65c6e416c6f401c332149da8f8ad1d7b8a218a7", "html_url": "https://github.com/rust-lang/rust/commit/f65c6e416c6f401c332149da8f8ad1d7b8a218a7"}, {"sha": "374f798ad2f10280f75a3561f2dc9449ccb5e5fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/374f798ad2f10280f75a3561f2dc9449ccb5e5fe", "html_url": "https://github.com/rust-lang/rust/commit/374f798ad2f10280f75a3561f2dc9449ccb5e5fe"}], "stats": {"total": 205, "additions": 178, "deletions": 27}, "files": [{"sha": "54c8f156f9da7d3b99b827b87679d287789aa2ae", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 145, "deletions": 27, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/04128982ffbf2609a94fa6b7786fe98c85c6b113/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04128982ffbf2609a94fa6b7786fe98c85c6b113/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=04128982ffbf2609a94fa6b7786fe98c85c6b113", "patch": "@@ -11,6 +11,8 @@ pub(crate) mod types;\n pub(crate) mod utils;\n \n use rustc_ast as ast;\n+use rustc_ast::token::{Token, TokenKind};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet, IndexEntry};\n use rustc_hir as hir;\n@@ -2079,8 +2081,8 @@ impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n     fn visit_item(&mut self, item: &'hir hir::Item<'hir>) {\n         if self.item.is_none()\n             && item.ident == self.looking_for\n-            && matches!(item.kind, hir::ItemKind::Use(_, _))\n-            || item.owner_id.def_id == self.target_def_id\n+            && (matches!(item.kind, hir::ItemKind::Use(_, _))\n+                || item.owner_id.def_id == self.target_def_id)\n         {\n             self.item = Some(item);\n         }\n@@ -2096,34 +2098,149 @@ fn get_all_import_attributes<'hir>(\n     tcx: TyCtxt<'hir>,\n     target_def_id: LocalDefId,\n     attributes: &mut Vec<ast::Attribute>,\n+    is_inline: bool,\n ) {\n     let hir_map = tcx.hir();\n     let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n     let mut visited = FxHashSet::default();\n     // If the item is an import and has at least a path with two parts, we go into it.\n-    while let hir::ItemKind::Use(path, _) = item.kind &&\n-        path.segments.len() > 1 &&\n-        let hir::def::Res::Def(_, def_id) = path.segments[path.segments.len() - 2].res &&\n-        visited.insert(def_id)\n-    {\n-        if let Some(hir::Node::Item(parent_item)) = hir_map.get_if_local(def_id) {\n-            // We add the attributes from this import into the list.\n-            attributes.extend_from_slice(hir_map.attrs(item.hir_id()));\n-            // We get the `Ident` we will be looking for into `item`.\n-            let looking_for = path.segments[path.segments.len() - 1].ident;\n-            visitor.reset(looking_for);\n-            hir::intravisit::walk_item(&mut visitor, parent_item);\n-            if let Some(i) = visitor.item {\n-                item = i;\n-            } else {\n-                break;\n+    while let hir::ItemKind::Use(path, _) = item.kind && visited.insert(item.hir_id()) {\n+        // We add the attributes from this import into the list.\n+        add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n+\n+        let def_id = if path.segments.len() > 1 {\n+            match path.segments[path.segments.len() - 2].res {\n+                hir::def::Res::Def(_, def_id) => def_id,\n+                _ => break,\n+            }\n+        } else {\n+            // If the path doesn't have a parent, then the parent is the current module.\n+            tcx.parent(item.owner_id.def_id.to_def_id())\n+        };\n+\n+        let Some(parent) = hir_map.get_if_local(def_id) else { break };\n+\n+        // We get the `Ident` we will be looking for into `item`.\n+        let looking_for = path.segments[path.segments.len() - 1].ident;\n+        visitor.reset(looking_for);\n+\n+        match parent {\n+            hir::Node::Item(parent_item) => {\n+                hir::intravisit::walk_item(&mut visitor, parent_item);\n+            }\n+            hir::Node::Crate(m) => {\n+                hir::intravisit::walk_mod(\n+                    &mut visitor,\n+                    m,\n+                    tcx.local_def_id_to_hir_id(def_id.as_local().unwrap()),\n+                );\n             }\n+            _ => break,\n+        }\n+        if let Some(i) = visitor.item {\n+            item = i;\n         } else {\n             break;\n         }\n     }\n }\n \n+fn filter_tokens_from_list(\n+    args_tokens: TokenStream,\n+    should_retain: impl Fn(&TokenTree) -> bool,\n+) -> Vec<TokenTree> {\n+    let mut tokens = Vec::with_capacity(args_tokens.len());\n+    let mut skip_next_comma = false;\n+    for token in args_tokens.into_trees() {\n+        match token {\n+            TokenTree::Token(Token { kind: TokenKind::Comma, .. }, _) if skip_next_comma => {\n+                skip_next_comma = false;\n+            }\n+            token if should_retain(&token) => {\n+                skip_next_comma = false;\n+                tokens.push(token);\n+            }\n+            _ => {\n+                skip_next_comma = true;\n+            }\n+        }\n+    }\n+    tokens\n+}\n+\n+/// When inlining items, we merge its attributes (and all the reexports attributes too) with the\n+/// final reexport. For example:\n+///\n+/// ```ignore (just an example)\n+/// #[doc(hidden, cfg(feature = \"foo\"))]\n+/// pub struct Foo;\n+///\n+/// #[doc(cfg(feature = \"bar\"))]\n+/// #[doc(hidden, no_inline)]\n+/// pub use Foo as Foo1;\n+///\n+/// #[doc(inline)]\n+/// pub use Foo2 as Bar;\n+/// ```\n+///\n+/// So `Bar` at the end will have both `cfg(feature = \"...\")`. However, we don't want to merge all\n+/// attributes so we filter out the following ones:\n+/// * `doc(inline)`\n+/// * `doc(no_inline)`\n+/// * `doc(hidden)`\n+fn add_without_unwanted_attributes(\n+    attrs: &mut Vec<ast::Attribute>,\n+    new_attrs: &[ast::Attribute],\n+    is_inline: bool,\n+) {\n+    // If it's `#[doc(inline)]`, we don't want all attributes, otherwise we keep everything.\n+    if !is_inline {\n+        attrs.extend_from_slice(new_attrs);\n+        return;\n+    }\n+    for attr in new_attrs {\n+        let mut attr = attr.clone();\n+        match attr.kind {\n+            ast::AttrKind::Normal(ref mut normal) => {\n+                if let [ident] = &*normal.item.path.segments &&\n+                    let ident = ident.ident.name &&\n+                    ident == sym::doc\n+                {\n+                    match normal.item.args {\n+                        ast::AttrArgs::Delimited(ref mut args) => {\n+                            let tokens =\n+                                filter_tokens_from_list(args.tokens.clone(), |token| {\n+                                    !matches!(\n+                                        token,\n+                                        TokenTree::Token(\n+                                            Token {\n+                                                kind: TokenKind::Ident(\n+                                                    sym::hidden | sym::inline | sym::no_inline,\n+                                                    _,\n+                                                ),\n+                                                ..\n+                                            },\n+                                            _,\n+                                        ),\n+                                    )\n+                                });\n+                            args.tokens = TokenStream::new(tokens);\n+                            attrs.push(attr);\n+                        }\n+                        ast::AttrArgs::Empty | ast::AttrArgs::Eq(..) => {\n+                            attrs.push(attr);\n+                            continue;\n+                        }\n+                    }\n+                }\n+            }\n+            ast::AttrKind::DocComment(..) => {\n+                attrs.push(attr);\n+            }\n+        }\n+    }\n+}\n+\n fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n@@ -2212,19 +2329,20 @@ fn clean_maybe_renamed_item<'tcx>(\n         {\n             // First, we add the attributes from the current import.\n             extra_attrs.extend_from_slice(inline::load_attrs(cx, import_id.to_def_id()));\n+            let is_inline = extra_attrs.lists(sym::doc).get_word_attr(sym::inline).is_some();\n             // Then we get all the various imports' attributes.\n-            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs);\n+            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs, is_inline);\n+            add_without_unwanted_attributes(&mut extra_attrs, inline::load_attrs(cx, def_id), is_inline);\n+        } else {\n+            // We only keep the item's attributes.\n+            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n         }\n \n-        let mut item = if !extra_attrs.is_empty() {\n-            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n-            let attrs = Attributes::from_ast(&extra_attrs);\n-            let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+        let attrs = Attributes::from_ast(&extra_attrs);\n+        let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n \n-            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg)\n-        } else {\n-            Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n-        };\n+        let mut item =\n+            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n         item.inline_stmt_id = import_id.map(|def_id| def_id.to_def_id());\n         vec![item]\n     })"}, {"sha": "f6c23a1365f46ea389b706ea4b4bc1b1231a1799", "filename": "tests/rustdoc/reexport-attr-merge.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/04128982ffbf2609a94fa6b7786fe98c85c6b113/tests%2Frustdoc%2Freexport-attr-merge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04128982ffbf2609a94fa6b7786fe98c85c6b113/tests%2Frustdoc%2Freexport-attr-merge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-attr-merge.rs?ref=04128982ffbf2609a94fa6b7786fe98c85c6b113", "patch": "@@ -0,0 +1,33 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/59368>.\n+// The goal is to ensure that `doc(hidden)`, `doc(inline)` and `doc(no_inline)`\n+// are not copied from an item when inlined.\n+\n+#![crate_name = \"foo\"]\n+#![feature(doc_cfg)]\n+\n+// @has 'foo/index.html'\n+\n+#[doc(hidden, cfg(feature = \"foo\"))]\n+pub struct Foo;\n+\n+#[doc(hidden, no_inline, cfg(feature = \"bar\"))]\n+pub use Foo as Foo1;\n+\n+#[doc(hidden, inline)]\n+pub use Foo1 as Foo2;\n+\n+// First we ensure that only the reexport `Bar2` and the inlined struct `Bar`\n+// are inlined.\n+// @count - '//a[@class=\"struct\"]' 2\n+// Then we check that both `cfg` are displayed.\n+// @has - '//*[@class=\"stab portability\"]' 'foo'\n+// @has - '//*[@class=\"stab portability\"]' 'bar'\n+// And finally we check that the only element displayed is `Bar`.\n+// @has - '//a[@class=\"struct\"]' 'Bar'\n+#[doc(inline)]\n+pub use Foo2 as Bar;\n+\n+// This one should appear but `Bar2` won't be linked because there is no\n+// `#[doc(inline)]`.\n+// @has - '//*[@id=\"reexport.Bar2\"]' 'pub use Foo2 as Bar2;'\n+pub use Foo2 as Bar2;"}]}