{"sha": "3836b195dd36fd41631570741378c2453dadf40b", "node_id": "C_kwDOAAsO6NoAKDM4MzZiMTk1ZGQzNmZkNDE2MzE1NzA3NDEzNzhjMjQ1M2RhZGY0MGI", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2022-01-02T16:05:37Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2022-01-02T16:05:37Z"}, "message": "minor: replace panics with types", "tree": {"sha": "5520ba31048e657014651b0d462a4b6b4bfa0c69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5520ba31048e657014651b0d462a4b6b4bfa0c69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3836b195dd36fd41631570741378c2453dadf40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3836b195dd36fd41631570741378c2453dadf40b", "html_url": "https://github.com/rust-lang/rust/commit/3836b195dd36fd41631570741378c2453dadf40b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3836b195dd36fd41631570741378c2453dadf40b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "174c439c56b3d6c9dec9452d08fe338c2246c872", "url": "https://api.github.com/repos/rust-lang/rust/commits/174c439c56b3d6c9dec9452d08fe338c2246c872", "html_url": "https://github.com/rust-lang/rust/commit/174c439c56b3d6c9dec9452d08fe338c2246c872"}], "stats": {"total": 36, "additions": 15, "deletions": 21}, "files": [{"sha": "5d7055824153ab7d0385d840dc92303632cc287a", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3836b195dd36fd41631570741378c2453dadf40b/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3836b195dd36fd41631570741378c2453dadf40b/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=3836b195dd36fd41631570741378c2453dadf40b", "patch": "@@ -280,7 +280,7 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n         parent.subtree.token_trees.extend(entry.subtree.token_trees);\n     }\n \n-    let subtree = stack.into_first().subtree;\n+    let subtree = stack.into_last().subtree;\n     if let [tt::TokenTree::Subtree(first)] = &*subtree.token_trees {\n         first.clone()\n     } else {"}, {"sha": "342194c7838c6c24b3c360a7bd1a2b6323016f05", "filename": "crates/stdx/src/non_empty_vec.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3836b195dd36fd41631570741378c2453dadf40b/crates%2Fstdx%2Fsrc%2Fnon_empty_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3836b195dd36fd41631570741378c2453dadf40b/crates%2Fstdx%2Fsrc%2Fnon_empty_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fnon_empty_vec.rs?ref=3836b195dd36fd41631570741378c2453dadf40b", "patch": "@@ -1,45 +1,39 @@\n-//! A [`Vec`] that is guaranteed to at least contain one element.\n+//! See [`NonEmptyVec`].\n \n-pub struct NonEmptyVec<T>(Vec<T>);\n+/// A [`Vec`] that is guaranteed to at least contain one element.\n+pub struct NonEmptyVec<T> {\n+    first: T,\n+    rest: Vec<T>,\n+}\n \n impl<T> NonEmptyVec<T> {\n     #[inline]\n-    pub fn new(initial: T) -> Self {\n-        NonEmptyVec(vec![initial])\n+    pub fn new(first: T) -> Self {\n+        NonEmptyVec { first, rest: Vec::new() }\n     }\n \n     #[inline]\n     pub fn last_mut(&mut self) -> &mut T {\n-        match self.0.last_mut() {\n-            Some(it) => it,\n-            None => unreachable!(),\n-        }\n+        self.rest.last_mut().unwrap_or(&mut self.first)\n     }\n \n     #[inline]\n     pub fn pop(&mut self) -> Option<T> {\n-        if self.0.len() <= 1 {\n-            None\n-        } else {\n-            self.0.pop()\n-        }\n+        self.rest.pop()\n     }\n \n     #[inline]\n     pub fn push(&mut self, value: T) {\n-        self.0.push(value)\n+        self.rest.push(value)\n     }\n \n     #[inline]\n     pub fn len(&self) -> usize {\n-        self.0.len()\n+        1 + self.rest.len()\n     }\n \n     #[inline]\n-    pub fn into_first(mut self) -> T {\n-        match self.0.pop() {\n-            Some(it) => it,\n-            None => unreachable!(),\n-        }\n+    pub fn into_last(mut self) -> T {\n+        self.rest.pop().unwrap_or(self.first)\n     }\n }"}]}