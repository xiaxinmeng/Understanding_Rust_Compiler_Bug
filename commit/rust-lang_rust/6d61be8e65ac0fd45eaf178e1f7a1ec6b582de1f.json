{"sha": "6d61be8e65ac0fd45eaf178e1f7a1ec6b582de1f", "node_id": "C_kwDOAAsO6NoAKDZkNjFiZThlNjVhYzBmZDQ1ZWFmMTc4ZTFmN2ExZWM2YjU4MmRlMWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T12:18:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T12:18:42Z"}, "message": "Auto merge of #13681 - lowr:fix/extract-function-tail-expr, r=Veykril\n\nfix: check tail expressions more precisely in `extract_function`\n\nFixes #13620\n\nWhen extracting expressions with control flows into a function, we can avoid wrapping tail expressions in `Option` or `Result` when they are also tail expressions of the container we're extracting from (see #7840, #9773). This is controlled by `ContainerInfo::is_in_tail`, but we've been computing it by checking if the tail expression of the range to extract is contained in the container's syntactically last expression, which may be a block that contains both tail and non-tail expressions (e.g. in #13620, the range to be extracted is not a tail expression but we set the flag to true).\n\nThis PR tries to compute the flag as precise as possible by utilizing `for_each_tail_expr()` (and also moves the flag to `Function` struct as it's more of a property of the function to be extracted than of the container).", "tree": {"sha": "bfb92430118ee60900e620f3f0742298e34e2d2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfb92430118ee60900e620f3f0742298e34e2d2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d61be8e65ac0fd45eaf178e1f7a1ec6b582de1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d61be8e65ac0fd45eaf178e1f7a1ec6b582de1f", "html_url": "https://github.com/rust-lang/rust/commit/6d61be8e65ac0fd45eaf178e1f7a1ec6b582de1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d61be8e65ac0fd45eaf178e1f7a1ec6b582de1f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34e2bc6a541cca670307cec94cfc5546016705d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/34e2bc6a541cca670307cec94cfc5546016705d6", "html_url": "https://github.com/rust-lang/rust/commit/34e2bc6a541cca670307cec94cfc5546016705d6"}, {"sha": "8e03f18e37d2782189391955bc56d3aebead81f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e03f18e37d2782189391955bc56d3aebead81f5", "html_url": "https://github.com/rust-lang/rust/commit/8e03f18e37d2782189391955bc56d3aebead81f5"}], "stats": {"total": 210, "additions": 186, "deletions": 24}, "files": [{"sha": "0483cfdc64667012313eeca7d1afc65ba6a8277e", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 186, "deletions": 24, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/6d61be8e65ac0fd45eaf178e1f7a1ec6b582de1f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d61be8e65ac0fd45eaf178e1f7a1ec6b582de1f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=6d61be8e65ac0fd45eaf178e1f7a1ec6b582de1f", "patch": "@@ -11,7 +11,9 @@ use ide_db::{\n     helpers::mod_path_to_ast,\n     imports::insert_use::{insert_use, ImportScope},\n     search::{FileReference, ReferenceCategory, SearchScope},\n-    syntax_helpers::node_ext::{preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr},\n+    syntax_helpers::node_ext::{\n+        for_each_tail_expr, preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr,\n+    },\n     FxIndexSet, RootDatabase,\n };\n use itertools::Itertools;\n@@ -78,7 +80,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n     };\n \n     let body = extraction_target(&node, range)?;\n-    let container_info = body.analyze_container(&ctx.sema)?;\n+    let (container_info, contains_tail_expr) = body.analyze_container(&ctx.sema)?;\n \n     let (locals_used, self_param) = body.analyze(&ctx.sema);\n \n@@ -119,6 +121,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                 ret_ty,\n                 body,\n                 outliving_locals,\n+                contains_tail_expr,\n                 mods: container_info,\n             };\n \n@@ -245,6 +248,8 @@ struct Function {\n     ret_ty: RetType,\n     body: FunctionBody,\n     outliving_locals: Vec<OutlivedLocal>,\n+    /// Whether at least one of the container's tail expr is contained in the range we're extracting.\n+    contains_tail_expr: bool,\n     mods: ContainerInfo,\n }\n \n@@ -265,7 +270,7 @@ enum ParamKind {\n     MutRef,\n }\n \n-#[derive(Debug, Eq, PartialEq)]\n+#[derive(Debug)]\n enum FunType {\n     Unit,\n     Single(hir::Type),\n@@ -294,7 +299,6 @@ struct ControlFlow {\n #[derive(Clone, Debug)]\n struct ContainerInfo {\n     is_const: bool,\n-    is_in_tail: bool,\n     parent_loop: Option<SyntaxNode>,\n     /// The function's return type, const's type etc.\n     ret_type: Option<hir::Type>,\n@@ -743,7 +747,10 @@ impl FunctionBody {\n         (res, self_param)\n     }\n \n-    fn analyze_container(&self, sema: &Semantics<'_, RootDatabase>) -> Option<ContainerInfo> {\n+    fn analyze_container(\n+        &self,\n+        sema: &Semantics<'_, RootDatabase>,\n+    ) -> Option<(ContainerInfo, bool)> {\n         let mut ancestors = self.parent()?.ancestors();\n         let infer_expr_opt = |expr| sema.type_of_expr(&expr?).map(TypeInfo::adjusted);\n         let mut parent_loop = None;\n@@ -815,28 +822,36 @@ impl FunctionBody {\n                 }\n             };\n         };\n-        let container_tail = match expr? {\n-            ast::Expr::BlockExpr(block) => block.tail_expr(),\n-            expr => Some(expr),\n-        };\n-        let is_in_tail =\n-            container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n-                container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n+\n+        let expr = expr?;\n+        let contains_tail_expr = if let Some(body_tail) = self.tail_expr() {\n+            let mut contains_tail_expr = false;\n+            let tail_expr_range = body_tail.syntax().text_range();\n+            for_each_tail_expr(&expr, &mut |e| {\n+                if tail_expr_range.contains_range(e.syntax().text_range()) {\n+                    contains_tail_expr = true;\n+                }\n             });\n+            contains_tail_expr\n+        } else {\n+            false\n+        };\n \n         let parent = self.parent()?;\n         let parents = generic_parents(&parent);\n         let generic_param_lists = parents.iter().filter_map(|it| it.generic_param_list()).collect();\n         let where_clauses = parents.iter().filter_map(|it| it.where_clause()).collect();\n \n-        Some(ContainerInfo {\n-            is_in_tail,\n-            is_const,\n-            parent_loop,\n-            ret_type: ty,\n-            generic_param_lists,\n-            where_clauses,\n-        })\n+        Some((\n+            ContainerInfo {\n+                is_const,\n+                parent_loop,\n+                ret_type: ty,\n+                generic_param_lists,\n+                where_clauses,\n+            },\n+            contains_tail_expr,\n+        ))\n     }\n \n     fn return_ty(&self, ctx: &AssistContext<'_>) -> Option<RetType> {\n@@ -1368,7 +1383,7 @@ impl FlowHandler {\n             None => FlowHandler::None,\n             Some(flow_kind) => {\n                 let action = flow_kind.clone();\n-                if *ret_ty == FunType::Unit {\n+                if let FunType::Unit = ret_ty {\n                     match flow_kind {\n                         FlowKind::Return(None)\n                         | FlowKind::Break(_, None)\n@@ -1633,7 +1648,7 @@ impl Function {\n \n     fn make_ret_ty(&self, ctx: &AssistContext<'_>, module: hir::Module) -> Option<ast::RetType> {\n         let fun_ty = self.return_type(ctx);\n-        let handler = if self.mods.is_in_tail {\n+        let handler = if self.contains_tail_expr {\n             FlowHandler::None\n         } else {\n             FlowHandler::from_ret_ty(self, &fun_ty)\n@@ -1707,7 +1722,7 @@ fn make_body(\n     fun: &Function,\n ) -> ast::BlockExpr {\n     let ret_ty = fun.return_type(ctx);\n-    let handler = if fun.mods.is_in_tail {\n+    let handler = if fun.contains_tail_expr {\n         FlowHandler::None\n     } else {\n         FlowHandler::from_ret_ty(fun, &ret_ty)\n@@ -1946,7 +1961,7 @@ fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) {\n                 if nested_scope.is_none() {\n                     if let Some(expr) = ast::Expr::cast(e.clone()) {\n                         match expr {\n-                            ast::Expr::ReturnExpr(return_expr) if nested_scope.is_none() => {\n+                            ast::Expr::ReturnExpr(return_expr) => {\n                                 let expr = return_expr.expr();\n                                 if let Some(replacement) = make_rewritten_flow(handler, expr) {\n                                     ted::replace(return_expr.syntax(), replacement.syntax())\n@@ -5582,6 +5597,153 @@ impl <T, U> Struct<T, U> where T: Into<i32> + Copy, U: Debug {\n fn $0fun_name<T, V>(t: T, v: V) -> i32 where T: Into<i32> + Copy, V: Into<i32> {\n     t.into() + v.into()\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_tail_expr_of_tail_expr_loop() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+pub fn f() {\n+    loop {\n+        $0if true {\n+            continue;\n+        }$0\n+\n+        if false {\n+            break;\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+pub fn f() {\n+    loop {\n+        if let ControlFlow::Break(_) = fun_name() {\n+            continue;\n+        }\n+\n+        if false {\n+            break;\n+        }\n+    }\n+}\n+\n+fn $0fun_name() -> ControlFlow<()> {\n+    if true {\n+        return ControlFlow::Break(());\n+    }\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_tail_expr_of_tail_if_block() {\n+        // FIXME: double semicolon\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: option, try\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        let a = $0if true {\n+            Some(())?\n+        } else {\n+            ()\n+        }$0;\n+        Some(a)\n+    } else {\n+        None\n+    }\n+}\n+\"#,\n+            r#\"\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        let a = fun_name()?;;\n+        Some(a)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn $0fun_name() -> Option<()> {\n+    Some(if true {\n+        Some(())?\n+    } else {\n+        ()\n+    })\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tail_expr_of_tail_block_nested() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: option, try\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        $0{\n+            let a = if true {\n+                Some(())?\n+            } else {\n+                ()\n+            };\n+            Some(a)\n+        }$0\n+    } else {\n+        None\n+    }\n+}\n+\"#,\n+            r#\"\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        fun_name()?\n+    } else {\n+        None\n+    }\n+}\n+\n+fn $0fun_name() -> Option<()> {\n+    let a = if true {\n+        Some(())?\n+    } else {\n+        ()\n+    };\n+    Some(a)\n+}\n \"#,\n         );\n     }"}]}