{"sha": "cefecd86017da9dabc998369bdbe73ef17b8b2c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZmVjZDg2MDE3ZGE5ZGFiYzk5ODM2OWJkYmU3M2VmMTdiOGIyYzc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-13T18:29:05Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-20T14:53:23Z"}, "message": "core: add str::each{,i}_reverse", "tree": {"sha": "951bc8b296cb11177882423ce8867c02d10f9a3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/951bc8b296cb11177882423ce8867c02d10f9a3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cefecd86017da9dabc998369bdbe73ef17b8b2c7", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cefecd86017da9dabc998369bdbe73ef17b8b2c7", "html_url": "https://github.com/rust-lang/rust/commit/cefecd86017da9dabc998369bdbe73ef17b8b2c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cefecd86017da9dabc998369bdbe73ef17b8b2c7/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d5ab3061ad2774883f273110a534477939162b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d5ab3061ad2774883f273110a534477939162b1", "html_url": "https://github.com/rust-lang/rust/commit/8d5ab3061ad2774883f273110a534477939162b1"}], "stats": {"total": 310, "additions": 221, "deletions": 89}, "files": [{"sha": "fcdd8fdd571b7aa5dc391e1384f5c1b4e0279448", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cefecd86017da9dabc998369bdbe73ef17b8b2c7/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefecd86017da9dabc998369bdbe73ef17b8b2c7/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=cefecd86017da9dabc998369bdbe73ef17b8b2c7", "patch": "@@ -218,7 +218,7 @@ pub impl ReprVisitor {\n \n     fn write_escaped_slice(&self, slice: &str) {\n         self.writer.write_char('\"');\n-        for str::chars_each(slice) |ch| {\n+        for slice.each_char |ch| {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');"}, {"sha": "748cea50e90d4c7e5d384e8a48fad37e67915ce4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 214, "deletions": 76, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/cefecd86017da9dabc998369bdbe73ef17b8b2c7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefecd86017da9dabc998369bdbe73ef17b8b2c7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=cefecd86017da9dabc998369bdbe73ef17b8b2c7", "patch": "@@ -596,20 +596,20 @@ pub pure fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n /// Levenshtein Distance between two strings\n pub fn levdistance(s: &str, t: &str) -> uint {\n \n-    let slen = str::len(s);\n-    let tlen = str::len(t);\n+    let slen = s.len();\n+    let tlen = s.len();\n \n     if slen == 0 { return tlen; }\n     if tlen == 0 { return slen; }\n \n     let mut dcol = vec::from_fn(tlen + 1, |x| x);\n \n-    for str::each_chari(s) |i, sc| {\n+    for s.each_chari |i, sc| {\n \n         let mut current = i;\n         dcol[0] = current + 1;\n \n-        for str::each_chari(t) |j, tc| {\n+        for s.each_chari |j, tc| {\n \n             let mut next = dcol[j + 1];\n \n@@ -933,37 +933,44 @@ pub pure fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(&mut result, len(ss));\n-        for chars_each(ss) |cc| {\n+        for ss.each_char |cc| {\n             str::push_char(&mut result, ff(cc));\n         }\n     }\n     result\n }\n \n /// Iterate over the bytes in a string\n-pub pure fn bytes_each(ss: &str, it: &fn(u8) -> bool) {\n-    let mut pos = 0u;\n-    let len = len(ss);\n+#[inline(always)]\n+pub pure fn each(s: &str, it: &fn(u8) -> bool) {\n+    eachi(s, |_i, b| it(b))\n+}\n+\n+/// Iterate over the bytes in a string, with indices\n+#[inline(always)]\n+pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n+    let mut pos = 0;\n+    let len = s.len();\n \n-    while (pos < len) {\n-        if !it(ss[pos]) { return; }\n-        pos += 1u;\n+    while pos < len {\n+        if !it(pos, s[pos]) { break; }\n+        pos += 1;\n     }\n }\n \n-/// Iterate over the bytes in a string\n+/// Iterate over the bytes in a string in reverse\n #[inline(always)]\n-pub pure fn each(s: &str, it: &fn(u8) -> bool) {\n-    eachi(s, |_i, b| it(b) )\n+pub pure fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n+    eachi_reverse(s, |_i, b| it(b) )\n }\n \n-/// Iterate over the bytes in a string, with indices\n+/// Iterate over the bytes in a string in reverse, with indices\n #[inline(always)]\n-pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n-    let mut i = 0u, l = len(s);\n-    while (i < l) {\n-        if !it(i, s[i]) { break; }\n-        i += 1u;\n+pub pure fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n+    let mut pos = s.len();\n+    while pos > 0 {\n+        pos -= 1;\n+        if !it(pos, s[pos]) { break; }\n     }\n }\n \n@@ -976,8 +983,9 @@ pub pure fn each_char(s: &str, it: &fn(char) -> bool) {\n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n-    let mut pos = 0u, ch_pos = 0u;\n-    let len = len(s);\n+    let mut pos = 0;\n+    let mut ch_pos = 0u;\n+    let len = s.len();\n     while pos < len {\n         let CharRange {ch, next} = char_range_at(s, pos);\n         pos = next;\n@@ -986,14 +994,25 @@ pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n     }\n }\n \n-/// Iterate over the characters in a string\n-pub pure fn chars_each(s: &str, it: &fn(char) -> bool) {\n-    let mut pos = 0u;\n-    let len = len(s);\n-    while (pos < len) {\n-        let CharRange {ch, next} = char_range_at(s, pos);\n+/// Iterates over the chars in a string in reverse\n+#[inline(always)]\n+pub pure fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n+    let mut pos = 0;\n+    let len = s.char_len();\n+    while pos > 0 {\n+        let CharRange {ch, next} = char_range_at_reverse(s, pos);\n         pos = next;\n-        if !it(ch) { return; }\n+        if !it(ch) { break; }\n+    }\n+}\n+\n+// Iterates over the chars in a string in reverse, with indices\n+#[inline(always)]\n+pub pure fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n+    let mut ch_pos = s.char_len();\n+    for s.each_char_reverse |ch| {\n+        ch_pos -= 1;\n+        if !it(ch_pos, ch) { break; }\n     }\n }\n \n@@ -1573,9 +1592,9 @@ pub pure fn is_utf16(v: &[u16]) -> bool {\n /// Converts to a vector of `u16` encoded as UTF-16\n pub pure fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n-    for chars_each(s) |cch| {\n+    for s.each_char |ch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n-        let mut ch = cch as u32;\n+        let mut ch = ch as u32;\n \n         unsafe {\n             if (ch & 0xFFFF_u32) == ch {\n@@ -2027,7 +2046,7 @@ pub pure fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n-        for chars_each(s) |c| {\n+        for s.each_char |c| {\n             push_str(&mut out, char::escape_default(c));\n         }\n     }\n@@ -2039,7 +2058,7 @@ pub pure fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n-        for chars_each(s) |c| {\n+        for s.each_char |c| {\n             push_str(&mut out, char::escape_unicode(c));\n         }\n     }\n@@ -2256,8 +2275,12 @@ pub trait StrSlice {\n     pure fn contains_char(&self, needle: char) -> bool;\n     pure fn each(&self, it: &fn(u8) -> bool);\n     pure fn eachi(&self, it: &fn(uint, u8) -> bool);\n+    pure fn each_reverse(&self, it: &fn(u8) -> bool);\n+    pure fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n     pure fn each_char(&self, it: &fn(char) -> bool);\n     pure fn each_chari(&self, it: &fn(uint, char) -> bool);\n+    pure fn each_char_reverse(&self, it: &fn(char) -> bool);\n+    pure fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n     pure fn ends_with(&self, needle: &str) -> bool;\n     pure fn is_empty(&self) -> bool;\n     pure fn is_whitespace(&self) -> bool;\n@@ -2314,6 +2337,16 @@ impl StrSlice for &'self str {\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n     pure fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n+    /// Iterate over the bytes in a string\n+    #[inline]\n+    pure fn each_reverse(&self, it: &fn(u8) -> bool) {\n+        each_reverse(*self, it)\n+    }\n+    /// Iterate over the bytes in a string, with indices\n+    #[inline]\n+    pure fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n+        eachi_reverse(*self, it)\n+    }\n     /// Iterate over the chars in a string\n     #[inline]\n     pure fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n@@ -2322,6 +2355,17 @@ impl StrSlice for &'self str {\n     pure fn each_chari(&self, it: &fn(uint, char) -> bool) {\n         each_chari(*self, it)\n     }\n+    /// Iterate over the chars in a string in reverse\n+    #[inline]\n+    pure fn each_char_reverse(&self, it: &fn(char) -> bool) {\n+        each_char_reverse(*self, it)\n+    }\n+    /// Iterate over the chars in a string in reverse, with indices from the\n+    /// end\n+    #[inline]\n+    pure fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n+        each_chari_reverse(*self, it)\n+    }\n     /// Returns true if one string ends with another\n     #[inline]\n     pure fn ends_with(&self, needle: &str) -> bool {\n@@ -3249,41 +3293,6 @@ mod tests {\n         fail_unless!(!contains_char(~\"\", 'a'));\n     }\n \n-    #[test]\n-    fn test_chars_each() {\n-        let mut i = 0;\n-        for chars_each(~\"x\\u03c0y\") |ch| {\n-            match i {\n-              0 => fail_unless!(ch == 'x'),\n-              1 => fail_unless!(ch == '\\u03c0'),\n-              2 => fail_unless!(ch == 'y'),\n-              _ => fail!(~\"test_chars_each failed\")\n-            }\n-            i += 1;\n-        }\n-\n-        chars_each(~\"\", |_ch| fail!() ); // should not fail\n-    }\n-\n-    #[test]\n-    fn test_bytes_each() {\n-        let mut i = 0;\n-\n-        for bytes_each(~\"xyz\") |bb| {\n-            match i {\n-              0 => fail_unless!(bb == 'x' as u8),\n-              1 => fail_unless!(bb == 'y' as u8),\n-              2 => fail_unless!(bb == 'z' as u8),\n-              _ => fail!(~\"test_bytes_each failed\")\n-            }\n-            i += 1;\n-        }\n-\n-        for bytes_each(~\"\") |bb| {\n-            fail_unless!(bb == 0u8);\n-        }\n-    }\n-\n     #[test]\n     fn test_split_char_each() {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n@@ -3463,17 +3472,146 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_each() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = 0;\n+\n+        for s.each |b| {\n+            fail_unless!(b == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_empty() {\n+        for \"\".each |b| {\n+            fail_unless!(b == 0u8);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eachi() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = 0;\n+\n+        for s.eachi |i, b| {\n+            fail_unless!(pos == i);\n+            fail_unless!(b == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eachi_empty() {\n+        for \"\".eachi |i, b| {\n+            fail_unless!(i == 0);\n+            fail_unless!(b == 0);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = v.len();\n+\n+        for s.each_reverse |b| {\n+            pos -= 1;\n+            fail_unless!(b == v[pos]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_empty_reverse() {\n+        for \"\".each_reverse |b| {\n+            fail_unless!(b == 0u8);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eachi_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = v.len();\n+\n+        for s.eachi_reverse |i, b| {\n+            pos -= 1;\n+            fail_unless!(pos == i);\n+            fail_unless!(b == v[pos]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eachi_reverse_empty() {\n+        for \"\".eachi_reverse |i, b| {\n+            fail_unless!(i == 0);\n+            fail_unless!(b == 0);\n+        }\n+    }\n+\n     #[test]\n     fn test_each_char() {\n-        let s = ~\"abc\";\n-        let mut found_b = false;\n-        for each_char(s) |ch| {\n-            if ch == 'b' {\n-                found_b = true;\n-                break;\n-            }\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = 0;\n+        for s.each_char |ch| {\n+            fail_unless!(ch == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_chari() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = 0;\n+        for s.each_chari |i, ch| {\n+            fail_unless!(pos == i);\n+            fail_unless!(ch == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_char_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = 0;\n+        for s.each_char_reverse |ch| {\n+            fail_unless!(ch == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_chari_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = v.len();\n+        for s.each_chari_reverse |i, ch| {\n+            pos -= 1;\n+            fail_unless!(pos == i);\n+            fail_unless!(ch == v[pos]);\n         }\n-        fail_unless!(found_b);\n     }\n \n     #[test]"}, {"sha": "2410608cbb7445198f017bd22f48d8218af94fd9", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cefecd86017da9dabc998369bdbe73ef17b8b2c7/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefecd86017da9dabc998369bdbe73ef17b8b2c7/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=cefecd86017da9dabc998369bdbe73ef17b8b2c7", "patch": "@@ -625,7 +625,7 @@ pub fn get_symbol_hash(ccx: @CrateContext, t: ty::t) -> @str {\n // gas doesn't!\n pub fn sanitize(s: &str) -> ~str {\n     let mut result = ~\"\";\n-    for str::chars_each(s) |c| {\n+    for str::each_char(s) |c| {\n         match c {\n           '@' => result += ~\"_sbox_\",\n           '~' => result += ~\"_ubox_\","}, {"sha": "7503f28e8486bda19e40c25f38d876f96e6b8535", "filename": "src/libstd/json.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cefecd86017da9dabc998369bdbe73ef17b8b2c7/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefecd86017da9dabc998369bdbe73ef17b8b2c7/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=cefecd86017da9dabc998369bdbe73ef17b8b2c7", "patch": "@@ -14,20 +14,14 @@\n \n //! json serialization\n \n+use core::prelude::*;\n+use core::io::{WriterUtil, ReaderUtil};\n+use core::hashmap::linear::LinearMap;\n+\n use serialize::Encodable;\n use serialize;\n use sort::Sort;\n \n-use core::char;\n-use core::cmp::{Eq, Ord};\n-use core::float;\n-use core::io::{WriterUtil, ReaderUtil};\n-use core::io;\n-use core::prelude::*;\n-use core::hashmap::linear::LinearMap;\n-use core::str;\n-use core::to_str;\n-\n /// Represents a json value\n pub enum Json {\n     Number(float),\n@@ -49,7 +43,7 @@ pub struct Error {\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    for str::chars_each(s) |c| {\n+    for str::each_char(s) |c| {\n         match c {\n           '\"' => escaped += ~\"\\\\\\\"\",\n           '\\\\' => escaped += ~\"\\\\\\\\\","}]}