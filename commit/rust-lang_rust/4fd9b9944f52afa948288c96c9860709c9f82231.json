{"sha": "4fd9b9944f52afa948288c96c9860709c9f82231", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZDliOTk0NGY1MmFmYTk0ODI4OGM5NmM5ODYwNzA5YzlmODIyMzE=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-18T21:35:56Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-23T22:26:41Z"}, "message": "Add cycle detection for graphs", "tree": {"sha": "edceacfd2352bce92faf17d30ed21979086219f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edceacfd2352bce92faf17d30ed21979086219f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fd9b9944f52afa948288c96c9860709c9f82231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd9b9944f52afa948288c96c9860709c9f82231", "html_url": "https://github.com/rust-lang/rust/commit/4fd9b9944f52afa948288c96c9860709c9f82231", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fd9b9944f52afa948288c96c9860709c9f82231/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ad1e7c46cf690b7ec6953b142430d21ca2d8799", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad1e7c46cf690b7ec6953b142430d21ca2d8799", "html_url": "https://github.com/rust-lang/rust/commit/9ad1e7c46cf690b7ec6953b142430d21ca2d8799"}], "stats": {"total": 225, "additions": 224, "deletions": 1}, "files": [{"sha": "cbf6a0a3c03a0810d9c42a4ebe53210569ee99c1", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 203, "deletions": 1, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/4fd9b9944f52afa948288c96c9860709c9f82231/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd9b9944f52afa948288c96c9860709c9f82231/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=4fd9b9944f52afa948288c96c9860709c9f82231", "patch": "@@ -1,5 +1,5 @@\n use super::super::indexed_vec::IndexVec;\n-use super::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use super::{DirectedGraph, WithNumNodes, WithSuccessors, WithStartNode};\n use crate::bit_set::BitSet;\n \n #[cfg(test)]\n@@ -85,3 +85,205 @@ where\n         Some(n)\n     }\n }\n+\n+/// Allows searches to terminate early with a value.\n+#[derive(Clone, Copy, Debug)]\n+pub enum ControlFlow<T> {\n+    Break(T),\n+    Continue,\n+}\n+\n+/// The status of a node in the depth-first search.\n+///\n+/// See the documentation of `TriColorDepthFirstSearch` to see how a node's status is updated\n+/// during DFS.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum NodeStatus {\n+    /// This node has been examined by the depth-first search but is not yet `Settled`.\n+    ///\n+    /// Also referred to as \"gray\" or \"discovered\" nodes in [CLR][].\n+    ///\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    Visited,\n+\n+    /// This node and all nodes reachable from it have been examined by the depth-first search.\n+    ///\n+    /// Also referred to as \"black\" or \"finished\" nodes in [CLR][].\n+    ///\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    Settled,\n+}\n+\n+struct Event<N> {\n+    node: N,\n+    becomes: NodeStatus,\n+}\n+\n+/// A depth-first search that also tracks when all successors of a node have been examined.\n+///\n+/// This is based on the DFS described in [Introduction to Algorithms (1st ed.)][CLR], hereby\n+/// referred to as **CLR**. However, we use the terminology in [`NodeStatus`][] above instead of\n+/// \"discovered\"/\"finished\" or \"white\"/\"grey\"/\"black\". Each node begins the search with no status,\n+/// becomes `Visited` when it is first examined by the DFS and is `Settled` when all nodes\n+/// reachable from it have been examined. This allows us to differentiate between \"tree\", \"back\"\n+/// and \"forward\" edges (see [`TriColorVisitor::node_examined`]).\n+///\n+/// Unlike the pseudocode in [CLR][], this implementation is iterative and does not use timestamps.\n+/// We accomplish this by storing `Event`s on the stack that result in a (possible) state change\n+/// for each node. A `Visited` event signifies that we should examine this node if it has not yet\n+/// been `Visited` or `Settled`. When a node is examined for the first time, we mark it as\n+/// `Visited` and push a `Settled` event for it on stack followed by `Visited` events for all of\n+/// its predecessors, scheduling them for examination. Multiple `Visited` events for a single node\n+/// may exist on the stack simultaneously if a node has multiple predecessors, but only one\n+/// `Settled` event will ever be created for each node. After all `Visited` events for a node's\n+/// successors have been popped off the stack (as well as any new events triggered by visiting\n+/// those successors), we will pop off that node's `Settled` event.\n+///\n+/// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+/// [`NodeStatus`]: ./enum.NodeStatus.html\n+/// [`TriColorVisitor::node_examined`]: ./trait.TriColorVisitor.html#method.node_examined\n+pub struct TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    graph: &'graph G,\n+    stack: Vec<Event<G::Node>>,\n+    visited: BitSet<G::Node>,\n+    settled: BitSet<G::Node>,\n+}\n+\n+impl<G> TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    pub fn new(graph: &'graph G) -> Self {\n+        TriColorDepthFirstSearch {\n+            graph,\n+            stack: vec![],\n+            visited: BitSet::new_empty(graph.num_nodes()),\n+            settled: BitSet::new_empty(graph.num_nodes()),\n+        }\n+    }\n+\n+    /// Performs a depth-first search, starting from the given `root`.\n+    ///\n+    /// This won't visit nodes that are not reachable from `root`.\n+    pub fn run_from<V>(mut self, root: G::Node, visitor: &mut V) -> Option<V::BreakVal>\n+    where\n+        V: TriColorVisitor<G>,\n+    {\n+        use NodeStatus::{Visited, Settled};\n+\n+        self.stack.push(Event { node: root, becomes: Visited });\n+\n+        loop {\n+            match self.stack.pop()? {\n+                Event { node, becomes: Settled } => {\n+                    let not_previously_settled = self.settled.insert(node);\n+                    assert!(not_previously_settled, \"A node should be settled exactly once\");\n+                    if let ControlFlow::Break(val) = visitor.node_settled(node) {\n+                        return Some(val);\n+                    }\n+                }\n+\n+                Event { node, becomes: Visited } => {\n+                    let not_previously_visited = self.visited.insert(node);\n+                    let prior_status = if not_previously_visited {\n+                        None\n+                    } else if self.settled.contains(node) {\n+                        Some(Settled)\n+                    } else {\n+                        Some(Visited)\n+                    };\n+\n+                    if let ControlFlow::Break(val) = visitor.node_examined(node, prior_status) {\n+                        return Some(val);\n+                    }\n+\n+                    // If this node has already been examined, we are done.\n+                    if prior_status.is_some() {\n+                        continue;\n+                    }\n+\n+                    // Otherwise, push a `Settled` event for this node onto the stack, then\n+                    // schedule its successors for examination.\n+                    self.stack.push(Event { node, becomes: Settled });\n+                    for succ in self.graph.successors(node) {\n+                        self.stack.push(Event { node: succ, becomes: Visited });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<G> TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors + WithStartNode,\n+{\n+    /// Performs a depth-first search, starting from `G::start_node()`.\n+    ///\n+    /// This won't visit nodes that are not reachable from the start node.\n+    pub fn run_from_start<V>(self, visitor: &mut V) -> Option<V::BreakVal>\n+    where\n+        V: TriColorVisitor<G>,\n+    {\n+        let root = self.graph.start_node();\n+        self.run_from(root, visitor)\n+    }\n+}\n+\n+/// What to do when a node is examined or becomes `Settled` during DFS.\n+pub trait TriColorVisitor<G>\n+where\n+    G: ?Sized + DirectedGraph,\n+{\n+    /// The value returned by this search.\n+    type BreakVal;\n+\n+    /// Called when a node is examined by the depth-first search.\n+    ///\n+    /// By checking the value of `prior_status`, this visitor can determine whether the edge\n+    /// leading to this node was a tree edge (`None`), forward edge (`Some(Settled)`) or back edge\n+    /// (`Some(Visited)`). For a full explanation of each edge type, see the \"Depth-first Search\"\n+    /// chapter in [CLR][] or [wikipedia][].\n+    ///\n+    /// If you want to know *both* nodes linked by each edge, you'll need to modify\n+    /// `TriColorDepthFirstSearch` to store a `source` node for each `Visited` event.\n+    ///\n+    /// [wikipedia]: https://en.wikipedia.org/wiki/Depth-first_search#Output_of_a_depth-first_search\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    fn node_examined(\n+        &mut self,\n+        _target: G::Node,\n+        _prior_status: Option<NodeStatus>,\n+    ) -> ControlFlow<Self::BreakVal> {\n+        ControlFlow::Continue\n+    }\n+\n+    /// Called after all nodes reachable from this one have been examined.\n+    fn node_settled(&mut self, _target: G::Node) -> ControlFlow<Self::BreakVal> {\n+        ControlFlow::Continue\n+    }\n+}\n+\n+/// This `TriColorVisitor` looks for back edges in a graph, which indicate that a cycle exists.\n+pub struct CycleDetector;\n+\n+impl<G> TriColorVisitor<G> for CycleDetector\n+where\n+    G: ?Sized + DirectedGraph,\n+{\n+    type BreakVal = ();\n+\n+    fn node_examined(\n+        &mut self,\n+        _node: G::Node,\n+        prior_status: Option<NodeStatus>,\n+    ) -> ControlFlow<Self::BreakVal> {\n+        match prior_status {\n+            Some(NodeStatus::Visited) => ControlFlow::Break(()),\n+            _ => ControlFlow::Continue,\n+        }\n+    }\n+}"}, {"sha": "0e038e88b221dfed3f8d3b6aabbdb0b272d9ab96", "filename": "src/librustc_data_structures/graph/iterate/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4fd9b9944f52afa948288c96c9860709c9f82231/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd9b9944f52afa948288c96c9860709c9f82231/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs?ref=4fd9b9944f52afa948288c96c9860709c9f82231", "patch": "@@ -9,3 +9,14 @@ fn diamond_post_order() {\n     let result = post_order_from(&graph, 0);\n     assert_eq!(result, vec![3, 1, 2, 0]);\n }\n+\n+#[test]\n+fn is_cyclic() {\n+    use super::super::is_cyclic;\n+\n+    let diamond_acyclic = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n+    let diamond_cyclic = TestGraph::new(0, &[(0, 1), (1, 2), (2, 3), (3, 0)]);\n+\n+    assert!(!is_cyclic(&diamond_acyclic));\n+    assert!(is_cyclic(&diamond_cyclic));\n+}"}, {"sha": "0a607659f3e246233bc74988269806fee7a9e44e", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fd9b9944f52afa948288c96c9860709c9f82231/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd9b9944f52afa948288c96c9860709c9f82231/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=4fd9b9944f52afa948288c96c9860709c9f82231", "patch": "@@ -81,3 +81,13 @@ where\n         + WithNumNodes,\n {\n }\n+\n+/// Returns `true` if the graph has a cycle that is reachable from the start node.\n+pub fn is_cyclic<G>(graph: &G) -> bool\n+where\n+    G: ?Sized + DirectedGraph + WithStartNode + WithSuccessors + WithNumNodes,\n+{\n+    iterate::TriColorDepthFirstSearch::new(graph)\n+        .run_from_start(&mut iterate::CycleDetector)\n+        .is_some()\n+}"}]}