{"sha": "b5d71bfb0f229472c48554c9df4bbfedd0633430", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZDcxYmZiMGYyMjk0NzJjNDg1NTRjOWRmNGJiZmVkZDA2MzM0MzA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-03-27T18:26:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-03-27T18:26:10Z"}, "message": "add definition of 'allocated object', and link it from relevant method docs", "tree": {"sha": "2e66e6ee50c826bdd3a476cda2537804474ffaed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e66e6ee50c826bdd3a476cda2537804474ffaed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5d71bfb0f229472c48554c9df4bbfedd0633430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d71bfb0f229472c48554c9df4bbfedd0633430", "html_url": "https://github.com/rust-lang/rust/commit/b5d71bfb0f229472c48554c9df4bbfedd0633430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5d71bfb0f229472c48554c9df4bbfedd0633430/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f811f14006fa46030f1af714f7d640580d3ad822", "url": "https://api.github.com/repos/rust-lang/rust/commits/f811f14006fa46030f1af714f7d640580d3ad822", "html_url": "https://github.com/rust-lang/rust/commit/f811f14006fa46030f1af714f7d640580d3ad822"}], "stats": {"total": 84, "additions": 47, "deletions": 37}, "files": [{"sha": "abe40fd96d0b8203fbc60f066fbf308fa91e1526", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b5d71bfb0f229472c48554c9df4bbfedd0633430/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d71bfb0f229472c48554c9df4bbfedd0633430/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=b5d71bfb0f229472c48554c9df4bbfedd0633430", "patch": "@@ -184,8 +184,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -210,6 +209,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_offset`]: #method.wrapping_offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -245,9 +245,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n+    /// It may *not* be used to access a different allocated object.\n     ///\n     /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -269,6 +268,7 @@ impl<T: ?Sized> *const T {\n     /// do the arithmetic there.\n     ///\n     /// [`offset`]: #method.offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -314,8 +314,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * Both pointers must be *derived from* a pointer to the same object.\n     ///   (See below for an example.)\n@@ -345,6 +344,7 @@ impl<T: ?Sized> *const T {\n     /// such large allocations either.)\n     ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Panics\n     ///\n@@ -468,8 +468,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -494,6 +493,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_add`]: #method.wrapping_add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -532,8 +532,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n     ///\n@@ -558,6 +557,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_sub`]: #method.wrapping_sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -594,9 +594,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n+    /// It may *not* be used to access a different allocated object.\n     ///\n     /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -618,6 +617,7 @@ impl<T: ?Sized> *const T {\n     /// do the arithmetic there.\n     ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -659,9 +659,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n+    /// It may *not* be used to access a different allocated object.\n     ///\n     /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -683,6 +682,7 @@ impl<T: ?Sized> *const T {\n     /// do the arithmetic there.\n     ///\n     /// [`sub`]: #method.sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -997,7 +997,7 @@ impl<T> *const [T] {\n     /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n     ///   and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1019,6 +1019,7 @@ impl<T> *const [T] {\n     /// See also [`slice::from_raw_parts`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {"}, {"sha": "d2f90c7fc8cb9b2b3ddf7369d79b16c95d2131ba", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5d71bfb0f229472c48554c9df4bbfedd0633430/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d71bfb0f229472c48554c9df4bbfedd0633430/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=b5d71bfb0f229472c48554c9df4bbfedd0633430", "patch": "@@ -55,6 +55,14 @@\n //! has size 0, i.e., even if memory is not actually touched. Consider using\n //! [`NonNull::dangling`] in such cases.\n //!\n+//! ## Allocated object\n+//!\n+//! For several operations, such as [`offset`] or field projections (`expr.field`), the notion of an\n+//! \"allocated object\" becomes relevant. An allocated object is a contiguous region of memory.\n+//! Common examples of allocated objects include stack-allocated variables (each variable is a\n+//! separate allocated object), heap allocations (each allocation created by the global allocator is\n+//! a separate allocated object), and `static` variables.\n+//!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html"}, {"sha": "51ddc7da8a4571969e4296a712f7c48950fe9d56", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b5d71bfb0f229472c48554c9df4bbfedd0633430/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d71bfb0f229472c48554c9df4bbfedd0633430/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=b5d71bfb0f229472c48554c9df4bbfedd0633430", "patch": "@@ -189,8 +189,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -215,6 +214,7 @@ impl<T: ?Sized> *mut T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_offset`]: #method.wrapping_offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -251,9 +251,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n+    /// It may *not* be used to access a different allocated object.\n     ///\n     /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -275,6 +274,7 @@ impl<T: ?Sized> *mut T {\n     /// do the arithmetic there.\n     ///\n     /// [`offset`]: #method.offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -485,8 +485,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * Both pointers must be *derived from* a pointer to the same object.\n     ///   (See below for an example.)\n@@ -516,6 +515,7 @@ impl<T: ?Sized> *mut T {\n     /// such large allocations either.)\n     ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Panics\n     ///\n@@ -575,8 +575,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -639,8 +638,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n     ///\n@@ -665,6 +663,7 @@ impl<T: ?Sized> *mut T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_sub`]: #method.wrapping_sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -701,9 +700,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n+    /// It may *not* be used to access a different allocated object.\n     ///\n     /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -725,6 +723,7 @@ impl<T: ?Sized> *mut T {\n     /// do the arithmetic there.\n     ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -766,9 +765,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n+    /// It may *not* be used to access a different allocated object.\n     ///\n     /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -790,6 +788,7 @@ impl<T: ?Sized> *mut T {\n     /// do the arithmetic there.\n     ///\n     /// [`sub`]: #method.sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -1261,7 +1260,7 @@ impl<T> *mut [T] {\n     /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n     ///   and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1283,6 +1282,7 @@ impl<T> *mut [T] {\n     /// See also [`slice::from_raw_parts`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n@@ -1311,7 +1311,7 @@ impl<T> *mut [T] {\n     /// * The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()`\n     ///   many bytes, and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1333,6 +1333,7 @@ impl<T> *mut [T] {\n     /// See also [`slice::from_raw_parts_mut`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {"}]}