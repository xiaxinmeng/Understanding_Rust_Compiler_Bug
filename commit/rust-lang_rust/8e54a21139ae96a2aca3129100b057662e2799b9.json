{"sha": "8e54a21139ae96a2aca3129100b057662e2799b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNTRhMjExMzlhZTk2YTJhY2EzMTI5MTAwYjA1NzY2MmUyNzk5Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-13T20:30:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-13T20:30:07Z"}, "message": "Auto merge of #81238 - RalfJung:copy-intrinsics, r=m-ou-se\n\ndirectly expose copy and copy_nonoverlapping intrinsics\n\nThis effectively un-does https://github.com/rust-lang/rust/pull/57997. That should help with `ptr::read` codegen in debug builds (and any other of these low-level functions that bottoms out at `copy`/`copy_nonoverlapping`), where the wrapper function will not get inlined. See the discussion in https://github.com/rust-lang/rust/pull/80290 and https://github.com/rust-lang/rust/issues/81163.\n\nCc `@bjorn3` `@therealprof`", "tree": {"sha": "7b2455feb283e4e0fba25de51555a693420d4111", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b2455feb283e4e0fba25de51555a693420d4111"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e54a21139ae96a2aca3129100b057662e2799b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e54a21139ae96a2aca3129100b057662e2799b9", "html_url": "https://github.com/rust-lang/rust/commit/8e54a21139ae96a2aca3129100b057662e2799b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e54a21139ae96a2aca3129100b057662e2799b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c10a880eca60379343a6c6d19dd5bda38ead55d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c10a880eca60379343a6c6d19dd5bda38ead55d", "html_url": "https://github.com/rust-lang/rust/commit/3c10a880eca60379343a6c6d19dd5bda38ead55d"}, {"sha": "1a806352e41fcba5eac91784476fc6dfa6ee05b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a806352e41fcba5eac91784476fc6dfa6ee05b7", "html_url": "https://github.com/rust-lang/rust/commit/1a806352e41fcba5eac91784476fc6dfa6ee05b7"}], "stats": {"total": 403, "additions": 180, "deletions": 223}, "files": [{"sha": "570ed1f41bbe4157286978c4c31eb858eb02c235", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 151, "deletions": 186, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/8e54a21139ae96a2aca3129100b057662e2799b9/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e54a21139ae96a2aca3129100b057662e2799b9/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=8e54a21139ae96a2aca3129100b057662e2799b9", "patch": "@@ -1730,6 +1730,157 @@ extern \"rust-intrinsic\" {\n     /// Allocate at compile time. Should not be called at runtime.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n+\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination must *not* overlap.\n+    ///\n+    /// For regions of memory which might overlap, use [`copy`] instead.\n+    ///\n+    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n+    /// with the argument order swapped.\n+    ///\n+    /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n+    ///\n+    /// # Safety\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * Both `src` and `dst` must be properly aligned.\n+    ///\n+    /// * The region of memory beginning at `src` with a size of `count *\n+    ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n+    ///   beginning at `dst` with the same size.\n+    ///\n+    /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n+    /// in the region beginning at `*src` and the region beginning at `*dst` can\n+    /// [violate memory safety][read-ownership].\n+    ///\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointers must be non-NULL and properly aligned.\n+    ///\n+    /// [`read`]: crate::ptr::read\n+    /// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+    /// [valid]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Manually implement [`Vec::append`]:\n+    ///\n+    /// ```\n+    /// use std::ptr;\n+    ///\n+    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n+    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n+    ///     let src_len = src.len();\n+    ///     let dst_len = dst.len();\n+    ///\n+    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n+    ///     dst.reserve(src_len);\n+    ///\n+    ///     unsafe {\n+    ///         // The call to offset is always safe because `Vec` will never\n+    ///         // allocate more than `isize::MAX` bytes.\n+    ///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n+    ///         let src_ptr = src.as_ptr();\n+    ///\n+    ///         // Truncate `src` without dropping its contents. We do this first,\n+    ///         // to avoid problems in case something further down panics.\n+    ///         src.set_len(0);\n+    ///\n+    ///         // The two regions cannot overlap because mutable references do\n+    ///         // not alias, and two different vectors cannot own the same\n+    ///         // memory.\n+    ///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n+    ///\n+    ///         // Notify `dst` that it now holds the contents of `src`.\n+    ///         dst.set_len(dst_len + src_len);\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut a = vec!['r'];\n+    /// let mut b = vec!['u', 's', 't'];\n+    ///\n+    /// append(&mut a, &mut b);\n+    ///\n+    /// assert_eq!(a, &['r', 'u', 's', 't']);\n+    /// assert!(b.is_empty());\n+    /// ```\n+    ///\n+    /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n+    #[doc(alias = \"memcpy\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination may overlap.\n+    ///\n+    /// If the source and destination will *never* overlap,\n+    /// [`copy_nonoverlapping`] can be used instead.\n+    ///\n+    /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n+    /// order swapped. Copying takes place as if the bytes were copied from `src`\n+    /// to a temporary array and then copied from the array to `dst`.\n+    ///\n+    /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n+    ///\n+    /// # Safety\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * Both `src` and `dst` must be properly aligned.\n+    ///\n+    /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n+    /// in the region beginning at `*src` and the region beginning at `*dst` can\n+    /// [violate memory safety][read-ownership].\n+    ///\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointers must be non-NULL and properly aligned.\n+    ///\n+    /// [`read`]: crate::ptr::read\n+    /// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+    /// [valid]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Efficiently create a Rust vector from an unsafe buffer:\n+    ///\n+    /// ```\n+    /// use std::ptr;\n+    ///\n+    /// /// # Safety\n+    /// ///\n+    /// /// * `ptr` must be correctly aligned for its type and non-zero.\n+    /// /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n+    /// /// * Those elements must not be used after calling this function unless `T: Copy`.\n+    /// # #[allow(dead_code)]\n+    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n+    ///     let mut dst = Vec::with_capacity(elts);\n+    ///\n+    ///     // SAFETY: Our precondition ensures the source is aligned and valid,\n+    ///     // and `Vec::with_capacity` ensures that we have usable space to write them.\n+    ///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n+    ///\n+    ///     // SAFETY: We created it with this much capacity earlier,\n+    ///     // and the previous `copy` has initialized these elements.\n+    ///     dst.set_len(elts);\n+    ///     dst\n+    /// }\n+    /// ```\n+    #[doc(alias = \"memmove\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n }\n \n // Some functions are defined here because they accidentally got made\n@@ -1755,192 +1906,6 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n     diff >= size\n }\n \n-/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-/// and destination must *not* overlap.\n-///\n-/// For regions of memory which might overlap, use [`copy`] instead.\n-///\n-/// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n-/// with the argument order swapped.\n-///\n-/// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n-///\n-/// # Safety\n-///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n-///\n-/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-///\n-/// * Both `src` and `dst` must be properly aligned.\n-///\n-/// * The region of memory beginning at `src` with a size of `count *\n-///   size_of::<T>()` bytes must *not* overlap with the region of memory\n-///   beginning at `dst` with the same size.\n-///\n-/// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n-/// in the region beginning at `*src` and the region beginning at `*dst` can\n-/// [violate memory safety][read-ownership].\n-///\n-/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-/// `0`, the pointers must be non-NULL and properly aligned.\n-///\n-/// [`read`]: crate::ptr::read\n-/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n-/// [valid]: crate::ptr#safety\n-///\n-/// # Examples\n-///\n-/// Manually implement [`Vec::append`]:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n-/// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n-///     let src_len = src.len();\n-///     let dst_len = dst.len();\n-///\n-///     // Ensure that `dst` has enough capacity to hold all of `src`.\n-///     dst.reserve(src_len);\n-///\n-///     unsafe {\n-///         // The call to offset is always safe because `Vec` will never\n-///         // allocate more than `isize::MAX` bytes.\n-///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n-///         let src_ptr = src.as_ptr();\n-///\n-///         // Truncate `src` without dropping its contents. We do this first,\n-///         // to avoid problems in case something further down panics.\n-///         src.set_len(0);\n-///\n-///         // The two regions cannot overlap because mutable references do\n-///         // not alias, and two different vectors cannot own the same\n-///         // memory.\n-///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n-///\n-///         // Notify `dst` that it now holds the contents of `src`.\n-///         dst.set_len(dst_len + src_len);\n-///     }\n-/// }\n-///\n-/// let mut a = vec!['r'];\n-/// let mut b = vec!['u', 's', 't'];\n-///\n-/// append(&mut a, &mut b);\n-///\n-/// assert_eq!(a, &['r', 'u', 's', 't']);\n-/// assert!(b.is_empty());\n-/// ```\n-///\n-/// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n-#[doc(alias = \"memcpy\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-#[inline]\n-pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n-    extern \"rust-intrinsic\" {\n-        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n-\n-    // FIXME: Perform these checks only at run time\n-    /*if cfg!(debug_assertions)\n-        && !(is_aligned_and_not_null(src)\n-            && is_aligned_and_not_null(dst)\n-            && is_nonoverlapping(src, dst, count))\n-    {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }*/\n-\n-    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n-    // upheld by the caller.\n-    unsafe { copy_nonoverlapping(src, dst, count) }\n-}\n-\n-/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-/// and destination may overlap.\n-///\n-/// If the source and destination will *never* overlap,\n-/// [`copy_nonoverlapping`] can be used instead.\n-///\n-/// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n-/// order swapped. Copying takes place as if the bytes were copied from `src`\n-/// to a temporary array and then copied from the array to `dst`.\n-///\n-/// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n-///\n-/// # Safety\n-///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n-///\n-/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-///\n-/// * Both `src` and `dst` must be properly aligned.\n-///\n-/// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n-/// in the region beginning at `*src` and the region beginning at `*dst` can\n-/// [violate memory safety][read-ownership].\n-///\n-/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-/// `0`, the pointers must be non-NULL and properly aligned.\n-///\n-/// [`read`]: crate::ptr::read\n-/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n-/// [valid]: crate::ptr#safety\n-///\n-/// # Examples\n-///\n-/// Efficiently create a Rust vector from an unsafe buffer:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// /// # Safety\n-/// ///\n-/// /// * `ptr` must be correctly aligned for its type and non-zero.\n-/// /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n-/// /// * Those elements must not be used after calling this function unless `T: Copy`.\n-/// # #[allow(dead_code)]\n-/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n-///     let mut dst = Vec::with_capacity(elts);\n-///\n-///     // SAFETY: Our precondition ensures the source is aligned and valid,\n-///     // and `Vec::with_capacity` ensures that we have usable space to write them.\n-///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n-///\n-///     // SAFETY: We created it with this much capacity earlier,\n-///     // and the previous `copy` has initialized these elements.\n-///     dst.set_len(elts);\n-///     dst\n-/// }\n-/// ```\n-#[doc(alias = \"memmove\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-#[inline]\n-pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n-    extern \"rust-intrinsic\" {\n-        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n-        fn copy<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n-\n-    // FIXME: Perform these checks only at run time\n-    /*if cfg!(debug_assertions) && !(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)) {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }*/\n-\n-    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n-    unsafe { copy(src, dst, count) }\n-}\n-\n /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n /// `val`.\n ///"}, {"sha": "f71233e7c32b9e8e3ba35e329cacd9ef4b5f3369", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e54a21139ae96a2aca3129100b057662e2799b9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e54a21139ae96a2aca3129100b057662e2799b9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=8e54a21139ae96a2aca3129100b057662e2799b9", "patch": "@@ -881,17 +881,12 @@ pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n-    // We are calling the intrinsics directly to avoid function calls in the generated code\n-    // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n-    extern \"rust-intrinsic\" {\n-        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n-\n     // SAFETY: the caller must guarantee that `dst` is valid for writes.\n     // `dst` cannot overlap `src` because the caller has mutable access\n     // to `dst` while `src` is owned by this function.\n     unsafe {\n         copy_nonoverlapping(&src as *const T, dst, 1);\n+        // We are calling the intrinsic directly to avoid function calls in the generated code.\n         intrinsics::forget(src);\n     }\n }"}, {"sha": "6c4092e3e5cc82d9c9f79eb753be09e41a338630", "filename": "src/test/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8e54a21139ae96a2aca3129100b057662e2799b9/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e54a21139ae96a2aca3129100b057662e2799b9/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=8e54a21139ae96a2aca3129100b057662e2799b9", "patch": "@@ -1,13 +1,12 @@\n error: any use of this value will cause an error\n-  --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n-   |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |              inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |              inside `_READ` at $DIR/out_of_bounds_read.rs:13:33\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         inside `_READ` at $DIR/out_of_bounds_read.rs:13:33\n    | \n   ::: $DIR/out_of_bounds_read.rs:13:5\n    |\n@@ -19,16 +18,15 @@ LL |     const _READ: u32 = unsafe { ptr::read(PAST_END_PTR) };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n-   |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |              inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |              inside `ptr::const_ptr::<impl *const u32>::read` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |              inside `_CONST_READ` at $DIR/out_of_bounds_read.rs:14:39\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         inside `ptr::const_ptr::<impl *const u32>::read` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |         inside `_CONST_READ` at $DIR/out_of_bounds_read.rs:14:39\n    | \n   ::: $DIR/out_of_bounds_read.rs:14:5\n    |\n@@ -39,16 +37,15 @@ LL |     const _CONST_READ: u32 = unsafe { PAST_END_PTR.read() };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n-   |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |              inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |              inside `ptr::mut_ptr::<impl *mut u32>::read` at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-   |              inside `_MUT_READ` at $DIR/out_of_bounds_read.rs:15:37\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         inside `ptr::mut_ptr::<impl *mut u32>::read` at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+   |         inside `_MUT_READ` at $DIR/out_of_bounds_read.rs:15:37\n    | \n   ::: $DIR/out_of_bounds_read.rs:15:5\n    |"}, {"sha": "e61786796475347d6442341b403a42a83cfdac77", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e54a21139ae96a2aca3129100b057662e2799b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e54a21139ae96a2aca3129100b057662e2799b9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=8e54a21139ae96a2aca3129100b057662e2799b9", "patch": "@@ -20,8 +20,8 @@ pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n-pub const COPY: [&str; 3] = [\"core\", \"intrinsics\", \"copy_nonoverlapping\"];\n-pub const COPY_NONOVERLAPPING: [&str; 3] = [\"core\", \"intrinsics\", \"copy\"];\n+pub const COPY: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"copy_nonoverlapping\"];\n+pub const COPY_NONOVERLAPPING: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"copy\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];"}]}