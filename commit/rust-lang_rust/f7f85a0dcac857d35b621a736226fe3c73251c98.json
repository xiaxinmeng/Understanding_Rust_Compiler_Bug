{"sha": "f7f85a0dcac857d35b621a736226fe3c73251c98", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3Zjg1YTBkY2FjODU3ZDM1YjYyMWE3MzYyMjZmZTNjNzMyNTFjOTg=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-05-17T21:53:54Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-05-17T21:53:54Z"}, "message": "Prevent symbocalypse", "tree": {"sha": "10e3f883327f7d980cdbf89e91528ff7e62fdc6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10e3f883327f7d980cdbf89e91528ff7e62fdc6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7f85a0dcac857d35b621a736226fe3c73251c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f85a0dcac857d35b621a736226fe3c73251c98", "html_url": "https://github.com/rust-lang/rust/commit/f7f85a0dcac857d35b621a736226fe3c73251c98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7f85a0dcac857d35b621a736226fe3c73251c98/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11194e3d050f45ff002a775f451ff6222fcd5b2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/11194e3d050f45ff002a775f451ff6222fcd5b2c", "html_url": "https://github.com/rust-lang/rust/commit/11194e3d050f45ff002a775f451ff6222fcd5b2c"}], "stats": {"total": 1846, "additions": 686, "deletions": 1160}, "files": [{"sha": "873df03ceb08cb19671078b741b03517a3fe35a6", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,13 +1,10 @@\n use crate::utils::span_lint;\n-use crate::utils::sym;\n-use lazy_static::lazy_static;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use std::f64::consts as f64;\n use syntax::ast::{FloatTy, LitKind};\n use syntax::symbol;\n-use syntax::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for floating point literals that approximate\n@@ -33,27 +30,25 @@ declare_clippy_lint! {\n     \"the approximate of a known float constant (in `std::fXX::consts`)\"\n }\n \n-lazy_static! {\n // Tuples are of the form (constant, name, min_digits)\n-static ref KNOWN_CONSTS: [(f64, Symbol, usize); 16] = [\n-    (f64::E, *sym::E, 4),\n-    (f64::FRAC_1_PI, *sym::FRAC_1_PI, 4),\n-    (f64::FRAC_1_SQRT_2, *sym::FRAC_1_SQRT_2, 5),\n-    (f64::FRAC_2_PI, *sym::FRAC_2_PI, 5),\n-    (f64::FRAC_2_SQRT_PI, *sym::FRAC_2_SQRT_PI, 5),\n-    (f64::FRAC_PI_2, *sym::FRAC_PI_2, 5),\n-    (f64::FRAC_PI_3, *sym::FRAC_PI_3, 5),\n-    (f64::FRAC_PI_4, *sym::FRAC_PI_4, 5),\n-    (f64::FRAC_PI_6, *sym::FRAC_PI_6, 5),\n-    (f64::FRAC_PI_8, *sym::FRAC_PI_8, 5),\n-    (f64::LN_10, *sym::LN_10, 5),\n-    (f64::LN_2, *sym::LN_2, 5),\n-    (f64::LOG10_E, *sym::LOG10_E, 5),\n-    (f64::LOG2_E, *sym::LOG2_E, 5),\n-    (f64::PI, *sym::PI, 3),\n-    (f64::SQRT_2, *sym::SQRT_2, 5),\n+const KNOWN_CONSTS: [(f64, &str, usize); 16] = [\n+    (f64::E, \"E\", 4),\n+    (f64::FRAC_1_PI, \"FRAC_1_PI\", 4),\n+    (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\", 5),\n+    (f64::FRAC_2_PI, \"FRAC_2_PI\", 5),\n+    (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\", 5),\n+    (f64::FRAC_PI_2, \"FRAC_PI_2\", 5),\n+    (f64::FRAC_PI_3, \"FRAC_PI_3\", 5),\n+    (f64::FRAC_PI_4, \"FRAC_PI_4\", 5),\n+    (f64::FRAC_PI_6, \"FRAC_PI_6\", 5),\n+    (f64::FRAC_PI_8, \"FRAC_PI_8\", 5),\n+    (f64::LN_10, \"LN_10\", 5),\n+    (f64::LN_2, \"LN_2\", 5),\n+    (f64::LOG10_E, \"LOG10_E\", 5),\n+    (f64::LOG2_E, \"LOG2_E\", 5),\n+    (f64::PI, \"PI\", 3),\n+    (f64::SQRT_2, \"SQRT_2\", 5),\n ];\n-}\n \n declare_lint_pass!(ApproxConstant => [APPROX_CONSTANT]);\n "}, {"sha": "0f0c0dbc15d058ee3fb81ae3ddbdb48898ea16ea", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -5,7 +5,6 @@ use rustc::{declare_lint_pass, declare_tool_lint};\n use syntax_pos::Span;\n \n use crate::consts::{constant, Constant};\n-use crate::utils::sym;\n use crate::utils::{in_macro_or_desugar, is_direct_expn_of, span_help_and_lint};\n \n declare_clippy_lint! {\n@@ -41,9 +40,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n             !in_macro_or_desugar(span)\n         };\n         if_chain! {\n-            if let Some(assert_span) = is_direct_expn_of(e.span, *sym::assert);\n+            if let Some(assert_span) = is_direct_expn_of(e.span, \"assert\");\n             if !in_macro_or_desugar(assert_span)\n-                || is_direct_expn_of(assert_span, *sym::debug_assert)\n+                || is_direct_expn_of(assert_span, \"debug_assert\")\n                     .map_or(false, debug_assert_not_in_macro_or_desugar);\n             if let ExprKind::Unary(_, ref lit) = e.node;\n             if let Some(bool_const) = constant(cx, cx.tables, lit);"}, {"sha": "2056a4af0d5367b129462e89740ed2fad5bb660e", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -9,7 +9,6 @@ use crate::utils::{\n     get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n };\n use crate::utils::{higher, sugg};\n-use syntax::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n@@ -89,11 +88,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                              $($trait_name:ident),+) => {\n                                 match $op {\n                                     $(hir::BinOpKind::$trait_name => {\n-                                        let [krate, module] = *crate::utils::paths::OPS_MODULE;\n-                                        let ident = {\n-                                            *crate::utils::sym::assign::$trait_name\n-                                        };\n-                                        let path: [Symbol; 3] = [krate, module, ident];\n+                                        let [krate, module] = crate::utils::paths::OPS_MODULE;\n+                                        let path: [&str; 3] = [krate, module, concat!(stringify!($trait_name), \"Assign\")];\n                                         let trait_id = if let Some(trait_id) = get_trait_def_id($cx, &path) {\n                                             trait_id\n                                         } else {"}, {"sha": "36fc4b94385f9363c2d81597998fb3664f96f2e9", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,7 +1,6 @@\n //! checks for attributes\n \n use crate::reexport::*;\n-use crate::utils::sym;\n use crate::utils::{\n     in_macro_or_desugar, is_present_in_source, last_line_of_span, match_def_path, paths, snippet_opt, span_lint,\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n@@ -18,7 +17,7 @@ use rustc_errors::Applicability;\n use semver::Version;\n use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use syntax::source_map::Span;\n-use syntax::symbol::Symbol;\n+use syntax_pos::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n@@ -207,14 +206,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n                     },\n                     _ => {},\n                 }\n-                if items.is_empty() || !attr.check_name(*sym::deprecated) {\n+                if items.is_empty() || !attr.check_name(sym!(deprecated)) {\n                     return;\n                 }\n                 for item in items {\n                     if_chain! {\n                         if let NestedMetaItem::MetaItem(mi) = &item;\n                         if let MetaItemKind::NameValue(lit) = &mi.node;\n-                        if mi.check_name(*sym::since);\n+                        if mi.check_name(sym!(since));\n                         then {\n                             check_semver(cx, item.span(), lit);\n                         }\n@@ -230,7 +229,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n         }\n         match item.node {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n-                let skip_unused_imports = item.attrs.iter().any(|attr| attr.check_name(*sym::macro_use));\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.check_name(sym!(macro_use)));\n \n                 for attr in &item.attrs {\n                     if in_external_macro(cx.sess(), attr.span) {\n@@ -245,17 +244,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n                                     for lint in lint_list {\n                                         match item.node {\n                                             ItemKind::Use(..) => {\n-                                                if is_word(lint, *sym::unused_imports)\n-                                                    || is_word(lint, *sym::deprecated)\n+                                                if is_word(lint, sym!(unused_imports))\n+                                                    || is_word(lint, sym!(deprecated))\n                                                 {\n                                                     return;\n                                                 }\n                                             },\n                                             ItemKind::ExternCrate(..) => {\n-                                                if is_word(lint, *sym::unused_imports) && skip_unused_imports {\n+                                                if is_word(lint, sym!(unused_imports)) && skip_unused_imports {\n                                                     return;\n                                                 }\n-                                                if is_word(lint, *sym::unused_extern_crates) {\n+                                                if is_word(lint, sym!(unused_extern_crates)) {\n                                                     return;\n                                                 }\n                                             },\n@@ -399,7 +398,7 @@ fn is_relevant_expr(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, exp\n         ExprKind::Call(path_expr, _) => {\n             if let ExprKind::Path(qpath) = &path_expr.node {\n                 if let Some(fun_id) = tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    !match_def_path(cx, fun_id, &*paths::BEGIN_PANIC)\n+                    !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n                 } else {\n                     true\n                 }\n@@ -445,10 +444,10 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n         }\n \n         if let Some(values) = attr.meta_item_list() {\n-            if values.len() != 1 || !attr.check_name(*sym::inline) {\n+            if values.len() != 1 || !attr.check_name(sym!(inline)) {\n                 continue;\n             }\n-            if is_word(&values[0], *sym::always) {\n+            if is_word(&values[0], sym!(always)) {\n                 span_lint(\n                     cx,\n                     INLINE_ALWAYS,\n@@ -491,16 +490,16 @@ impl EarlyLintPass for DeprecatedCfgAttribute {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &Attribute) {\n         if_chain! {\n             // check cfg_attr\n-            if attr.check_name(*sym::cfg_attr);\n+            if attr.check_name(sym!(cfg_attr));\n             if let Some(items) = attr.meta_item_list();\n             if items.len() == 2;\n             // check for `rustfmt`\n             if let Some(feature_item) = items[0].meta_item();\n-            if feature_item.check_name(*sym::rustfmt);\n+            if feature_item.check_name(sym!(rustfmt));\n             // check for `rustfmt_skip` and `rustfmt::skip`\n             if let Some(skip_item) = &items[1].meta_item();\n-            if skip_item.check_name(*sym::rustfmt_skip) ||\n-                skip_item.path.segments.last().expect(\"empty path in attribute\").ident.name == *sym::skip;\n+            if skip_item.check_name(sym!(rustfmt_skip)) ||\n+                skip_item.path.segments.last().expect(\"empty path in attribute\").ident.name == sym!(skip);\n             // Only lint outer attributes, because custom inner attributes are unstable\n             // Tracking issue: https://github.com/rust-lang/rust/issues/54726\n             if let AttrStyle::Outer = attr.style;"}, {"sha": "9a3f1075520dd19becbb7fb23df71647f0b63b07", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,9 +1,7 @@\n-use crate::utils::sym;\n use crate::utils::{\n     get_trait_def_id, implements_trait, in_macro, in_macro_or_desugar, match_type, paths, snippet_opt,\n     span_lint_and_then, SpanlessEq,\n };\n-use lazy_static::lazy_static;\n use rustc::hir::intravisit::*;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -12,7 +10,6 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::{dummy_spanned, Span, DUMMY_SP};\n-use syntax::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for boolean expressions that can be written more\n@@ -52,13 +49,11 @@ declare_clippy_lint! {\n     \"boolean expressions that contain terminals which can be eliminated\"\n }\n \n-lazy_static! {\n // For each pairs, both orders are considered.\n-static ref METHODS_WITH_NEGATION: [(Symbol, Symbol); 2] = [\n-    (*sym::is_some, *sym::is_none),\n-    (*sym::is_err, *sym::is_ok),\n+const METHODS_WITH_NEGATION: [(&str, &str); 2] = [\n+    (\"is_some\", \"is_none\"),\n+    (\"is_err\", \"is_ok\"),\n ];\n-}\n \n declare_lint_pass!(NonminimalBool => [NONMINIMAL_BOOL, LOGIC_BUG]);\n \n@@ -195,16 +190,16 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n             },\n             ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n                 let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n-                if !match_type(self.cx, type_of_receiver, &*paths::OPTION)\n-                    && !match_type(self.cx, type_of_receiver, &*paths::RESULT)\n+                if !match_type(self.cx, type_of_receiver, &paths::OPTION)\n+                    && !match_type(self.cx, type_of_receiver, &paths::RESULT)\n                 {\n                     return None;\n                 }\n                 METHODS_WITH_NEGATION\n                     .iter()\n                     .cloned()\n                     .flat_map(|(a, b)| vec![(a, b), (b, a)])\n-                    .find(|&(a, _)| a == path.ident.name)\n+                    .find(|&(a, _)| a == path.ident.name.as_str())\n                     .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", self.snip(&args[0])?, neg_method)))\n             },\n             _ => None,\n@@ -474,5 +469,5 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n \n fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n-    get_trait_def_id(cx, &*paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+    get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }"}, {"sha": "98485838261465fa9d7a66e4d55cab5b86021964", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{\n     contains_name, get_pat_name, match_type, paths, single_segment_path, snippet_with_applicability,\n     span_lint_and_sugg, walk_ptrs_ty,\n@@ -38,10 +37,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.node;\n-            if count.ident.name == *sym::count;\n+            if count.ident.name == sym!(count);\n             if count_args.len() == 1;\n             if let ExprKind::MethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n-            if filter.ident.name == *sym::filter;\n+            if filter.ident.name == sym!(filter);\n             if filter_args.len() == 2;\n             if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].node;\n             then {\n@@ -53,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                     if op.node == BinOpKind::Eq;\n                     if match_type(cx,\n                                walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n-                               &*paths::SLICE_ITER);\n+                               &paths::SLICE_ITER);\n                     then {\n                         let needle = match get_path_name(l) {\n                             Some(name) if check_arg(name, argname, r) => r,\n@@ -68,7 +67,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args) =\n                                 filter_args[0].node {\n                             let p = path.ident.name;\n-                            if (p == *sym::iter || p == *sym::iter_mut) && args.len() == 1 {\n+                            if (p == sym!(iter) || p == sym!(iter_mut)) && args.len() == 1 {\n                                 &args[0]\n                             } else {\n                                 &filter_args[0]"}, {"sha": "38d7307a1873484edae35fe731c9c7c4a9705404", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -9,7 +9,6 @@ use rustc::{declare_tool_lint, impl_lint_pass};\n use syntax::ast::Attribute;\n use syntax::source_map::Span;\n \n-use crate::utils::sym;\n use crate::utils::{in_macro_or_desugar, is_allowed, match_type, paths, span_help_and_lint, LimitStack};\n \n declare_clippy_lint! {\n@@ -72,7 +71,7 @@ impl CognitiveComplexity {\n             ..\n         } = helper;\n         let ret_ty = cx.tables.node_type(expr.hir_id);\n-        let ret_adjust = if match_type(cx, ret_ty, &*paths::RESULT) {\n+        let ret_adjust = if match_type(cx, ret_ty, &paths::RESULT) {\n             returns\n         } else {\n             returns / 2\n@@ -119,7 +118,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CognitiveComplexity {\n         hir_id: HirId,\n     ) {\n         let def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n-        if !cx.tcx.has_attr(def_id, *sym::test) {\n+        if !cx.tcx.has_attr(def_id, sym!(test)) {\n             self.check(cx, body, span);\n         }\n     }"}, {"sha": "79e30f1a7d8aad3b993a72ee5a65fd241fcb041b", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyIterator {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n             let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n \n-            if is_copy(cx, ty) && match_path(&trait_ref.path, &*paths::ITERATOR) {\n+            if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {\n                 span_note_and_lint(\n                     cx,\n                     COPY_ITERATOR,"}, {"sha": "ff76b35fa21bdc98be291bb50b5e4f480e16b226", "filename": "clippy_lints/src/dbg_macro.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdbg_macro.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{snippet_opt, span_help_and_lint, span_lint_and_sugg};\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n@@ -32,7 +31,7 @@ declare_lint_pass!(DbgMacro => [DBG_MACRO]);\n \n impl EarlyLintPass for DbgMacro {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::Mac) {\n-        if mac.node.path == *sym::dbg {\n+        if mac.node.path == sym!(dbg) {\n             if let Some(sugg) = tts_span(mac.node.tts.clone()).and_then(|span| snippet_opt(cx, span)) {\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "fb7ba64836a530795760bb9733a8c4485f4faca5", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n             if let ExprKind::Path(ref qpath) = path.node;\n             if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &*paths::DEFAULT_TRAIT_METHOD);\n+            if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {\n                 match qpath {\n                     QPath::Resolved(..) => {"}, {"sha": "bf2845af13367e49cf6e4c5bad27a3773153a9a9", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -88,7 +88,7 @@ fn check_hash_peq<'a, 'tcx>(\n     hash_is_automatically_derived: bool,\n ) {\n     if_chain! {\n-        if match_path(&trait_ref.path, &*paths::HASH);\n+        if match_path(&trait_ref.path, &paths::HASH);\n         if let Some(peq_trait_def_id) = cx.tcx.lang_items().eq_trait();\n         then {\n             // Look for the PartialEq implementations for `ty`\n@@ -129,7 +129,7 @@ fn check_hash_peq<'a, 'tcx>(\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: Ty<'tcx>) {\n-    if match_path(&trait_ref.path, &*paths::CLONE_TRAIT) {\n+    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n         if !is_copy(cx, ty) {\n             return;\n         }"}, {"sha": "2b1f6afb3d89e4cea6ac9698d61595882f406aef", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,5 +1,4 @@\n use crate::utils::span_lint;\n-use crate::utils::sym;\n use itertools::Itertools;\n use pulldown_cmark;\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n@@ -128,7 +127,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>,\n                 spans.extend_from_slice(&current_spans);\n                 doc.push_str(&current);\n             }\n-        } else if attr.check_name(*sym::doc) {\n+        } else if attr.check_name(sym!(doc)) {\n             // ignore mix of sugared and non-sugared doc\n             return;\n         }"}, {"sha": "e48de3f64818b7123fa5f6941adc1207b563a742", "filename": "clippy_lints/src/drop_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_bounds.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -56,7 +56,7 @@ fn lint_bound<'a, 'tcx>(cx: &rustc::lint::LateContext<'a, 'tcx>, bound: &'tcx Ge\n     if_chain! {\n         if let GenericBound::Trait(t, _) = bound;\n         if let Some(def_id) = t.trait_ref.path.res.opt_def_id();\n-        if match_def_path(cx, def_id, &*paths::DROP_TRAIT);\n+        if match_def_path(cx, def_id, &paths::DROP_TRAIT);\n         then {\n             span_lint(\n                 cx,"}, {"sha": "a815eae9fbb3aca2ee77a2366fa378f7b0dbb7ca", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -122,10 +122,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n                 let arg_ty = cx.tables.expr_ty(arg);\n \n                 if let ty::Ref(..) = arg_ty.sty {\n-                    if match_def_path(cx, def_id, &*paths::DROP) {\n+                    if match_def_path(cx, def_id, &paths::DROP) {\n                         lint = DROP_REF;\n                         msg = DROP_REF_SUMMARY.to_string();\n-                    } else if match_def_path(cx, def_id, &*paths::MEM_FORGET) {\n+                    } else if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                         lint = FORGET_REF;\n                         msg = FORGET_REF_SUMMARY.to_string();\n                     } else {\n@@ -138,10 +138,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n                                        arg.span,\n                                        &format!(\"argument has type {}\", arg_ty));\n                 } else if is_copy(cx, arg_ty) {\n-                    if match_def_path(cx, def_id, &*paths::DROP) {\n+                    if match_def_path(cx, def_id, &paths::DROP) {\n                         lint = DROP_COPY;\n                         msg = DROP_COPY_SUMMARY.to_string();\n-                    } else if match_def_path(cx, def_id, &*paths::MEM_FORGET) {\n+                    } else if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                         lint = FORGET_COPY;\n                         msg = FORGET_COPY_SUMMARY.to_string();\n                     } else {"}, {"sha": "60470ede5419d2466ff4786103c8b26e2e5f9aaa", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.node;\n             if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.node;\n-            if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &*paths::DURATION);\n+            if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n             then {\n                 let suggested_fn = match (method_path.ident.as_str().as_ref(), divisor) {"}, {"sha": "43930842387a4f9e56d995eba23f62133d3c9bd1", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::SpanlessEq;\n use crate::utils::{get_item_name, higher, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty};\n use if_chain::if_chain;\n@@ -92,16 +91,16 @@ fn check_cond<'a, 'tcx, 'b>(\n     if_chain! {\n         if let ExprKind::MethodCall(ref path, _, ref params) = check.node;\n         if params.len() >= 2;\n-        if path.ident.name == *sym::contains_key;\n+        if path.ident.name == sym!(contains_key);\n         if let ExprKind::AddrOf(_, ref key) = params[1].node;\n         then {\n             let map = &params[0];\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n \n-            return if match_type(cx, obj_ty, &*paths::BTREEMAP) {\n+            return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n                 Some((\"BTreeMap\", map, key))\n             }\n-            else if match_type(cx, obj_ty, &*paths::HASHMAP) {\n+            else if match_type(cx, obj_ty, &paths::HASHMAP) {\n                 Some((\"HashMap\", map, key))\n             }\n             else {\n@@ -127,7 +126,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n         if_chain! {\n             if let ExprKind::MethodCall(ref path, _, ref params) = expr.node;\n             if params.len() == 3;\n-            if path.ident.name == *sym::insert;\n+            if path.ident.name == sym!(insert);\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);\n             if SpanlessEq::new(self.cx).eq_expr(self.key, &params[1]);\n             then {"}, {"sha": "dc76bb0b2b90cb83418526d906c885bd5a43a9a9", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{is_expn_of, match_def_path, paths, resolve_node, span_lint, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc::hir::*;\n@@ -32,20 +31,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n         if_chain! {\n             // match call to unwrap\n             if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n-            if unwrap_fun.ident.name == *sym::unwrap;\n+            if unwrap_fun.ident.name == sym!(unwrap);\n             // match call to write_fmt\n             if unwrap_args.len() > 0;\n             if let ExprKind::MethodCall(ref write_fun, _, ref write_args) =\n                 unwrap_args[0].node;\n-            if write_fun.ident.name == *sym::write_fmt;\n+            if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if write_args.len() > 0;\n             if let ExprKind::Call(ref dest_fun, _) = write_args[0].node;\n             if let ExprKind::Path(ref qpath) = dest_fun.node;\n             if let Some(dest_fun_id) = resolve_node(cx, qpath, dest_fun.hir_id).opt_def_id();\n-            if let Some(dest_name) = if match_def_path(cx, dest_fun_id, &*paths::STDOUT) {\n+            if let Some(dest_name) = if match_def_path(cx, dest_fun_id, &paths::STDOUT) {\n                 Some(\"stdout\")\n-            } else if match_def_path(cx, dest_fun_id, &*paths::STDERR) {\n+            } else if match_def_path(cx, dest_fun_id, &paths::STDERR) {\n                 Some(\"stderr\")\n             } else {\n                 None\n@@ -54,9 +53,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n                 let write_span = unwrap_args[0].span;\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n-                    if is_expn_of(write_span, *sym::writeln).is_some() {\n+                    if is_expn_of(write_span, \"writeln\").is_some() {\n                         Some(\"writeln\")\n-                    } else if is_expn_of(write_span, *sym::write).is_some() {\n+                    } else if is_expn_of(write_span, \"write\").is_some() {\n                         Some(\"write\")\n                     } else {\n                         None"}, {"sha": "3aac7bfc69ec9b80b680ea38f05728de388ce58a", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,12 +1,10 @@\n use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT};\n-use crate::utils::sym;\n use crate::utils::{is_expn_of, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty::{self, Ty};\n use rustc::{declare_lint_pass, declare_tool_lint};\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n declare_clippy_lint! {\n@@ -39,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n         if_chain! {\n             if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n-            if match_def_path(cx, impl_trait_ref.def_id, &*FROM_TRAIT);\n+            if match_def_path(cx, impl_trait_ref.def_id, &FROM_TRAIT);\n             then {\n                 lint_impl_body(cx, item.span, impl_items);\n             }\n@@ -64,18 +62,18 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n                 if let ExprKind::Call(ref func_expr, _) = expr.node;\n                 if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.node;\n                 if let Some(path_def_id) = path.res.opt_def_id();\n-                if match_def_path(self.lcx, path_def_id, &*BEGIN_PANIC) ||\n-                    match_def_path(self.lcx, path_def_id, &*BEGIN_PANIC_FMT);\n-                if is_expn_of(expr.span, *sym::unreachable).is_none();\n+                if match_def_path(self.lcx, path_def_id, &BEGIN_PANIC) ||\n+                    match_def_path(self.lcx, path_def_id, &BEGIN_PANIC_FMT);\n+                if is_expn_of(expr.span, \"unreachable\").is_none();\n                 then {\n                     self.result.push(expr.span);\n                 }\n             }\n \n             // check for `unwrap`\n-            if let Some(arglists) = method_chain_args(expr, &[*sym::unwrap]) {\n+            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n-                if match_type(self.lcx, reciever_ty, &*OPTION) || match_type(self.lcx, reciever_ty, &*RESULT) {\n+                if match_type(self.lcx, reciever_ty, &OPTION) || match_type(self.lcx, reciever_ty, &RESULT) {\n                     self.result.push(expr.span);\n                 }\n             }\n@@ -91,7 +89,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n \n     for impl_item in impl_items {\n         if_chain! {\n-            if impl_item.ident.name == *sym::from;\n+            if impl_item.ident.name == sym!(from);\n             if let ImplItemKind::Method(_, body_id) =\n                 cx.tcx.hir().impl_item(impl_item.id).node;\n             then {\n@@ -124,7 +122,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n }\n \n-fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[Symbol]) -> bool {\n+fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,"}, {"sha": "25a5e2eca4386064cdc3daa927d12c646ba4d0b2", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,5 +1,4 @@\n use crate::utils::paths;\n-use crate::utils::sym;\n use crate::utils::{\n     in_macro_or_desugar, is_expn_of, last_path_segment, match_def_path, match_type, resolve_node, snippet,\n     span_lint_and_then, walk_ptrs_ty,\n@@ -39,7 +38,7 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let Some(span) = is_expn_of(expr.span, *sym::format) {\n+        if let Some(span) = is_expn_of(expr.span, \"format\") {\n             if in_macro_or_desugar(span) {\n                 return;\n             }\n@@ -49,10 +48,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessFormat {\n                     if_chain! {\n                         if let ExprKind::Path(ref qpath) = fun.node;\n                         if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-                        let new_v1 = match_def_path(cx, fun_def_id, &*paths::FMT_ARGUMENTS_NEWV1);\n+                        let new_v1 = match_def_path(cx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n                         let new_v1_fmt = match_def_path(cx,\n                             fun_def_id,\n-                            &*paths::FMT_ARGUMENTS_NEWV1FORMATTED\n+                            &paths::FMT_ARGUMENTS_NEWV1FORMATTED\n                         );\n                         if new_v1 || new_v1_fmt;\n                         if check_single_piece(&args[0]);\n@@ -151,10 +150,10 @@ fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option\n         if args.len() == 2;\n         if let ExprKind::Path(ref qpath) = args[1].node;\n         if let Some(fun_def_id) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n-        if match_def_path(cx, fun_def_id, &*paths::DISPLAY_FMT_METHOD);\n+        if match_def_path(cx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n-            if ty.sty == ty::Str || match_type(cx, ty, &*paths::STRING) {\n+            if ty.sty == ty::Str || match_type(cx, ty, &paths::STRING) {\n                 if let ExprKind::Tup(ref values) = match_expr.node {\n                     return Some(&values[0]);\n                 }\n@@ -181,14 +180,14 @@ fn check_unformatted(expr: &Expr) -> bool {\n         if let ExprKind::Array(ref exprs) = expr.node;\n         if exprs.len() == 1;\n         if let ExprKind::Struct(_, ref fields, _) = exprs[0].node;\n-        if let Some(format_field) = fields.iter().find(|f| f.ident.name == *sym::format);\n+        if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym!(format));\n         if let ExprKind::Struct(_, ref fields, _) = format_field.expr.node;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == *sym::width);\n+        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n         if let ExprKind::Path(ref width_qpath) = width_field.expr.node;\n-        if last_path_segment(width_qpath).ident.name == *sym::Implied;\n-        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == *sym::precision);\n+        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n+        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym!(precision));\n         if let ExprKind::Path(ref precision_path) = precision_field.expr.node;\n-        if last_path_segment(precision_path).ident.name == *sym::Implied;\n+        if last_path_segment(precision_path).ident.name == sym!(Implied);\n         then {\n             return true;\n         }"}, {"sha": "50ba2b90ee59962ffc314ef6491e7e354601a73c", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n             },\n \n             ExprKind::MethodCall(ref name, .., ref args) => {\n-                if match_trait_method(cx, e, &*paths::INTO) && &*name.ident.as_str() == \"into\" {\n+                if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n                     if same_tys(cx, a, b) {\n@@ -72,7 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                         });\n                     }\n                 }\n-                if match_trait_method(cx, e, &*paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n+                if match_trait_method(cx, e, &paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n                     if same_tys(cx, a, b) {\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n             ExprKind::Call(ref path, ref args) => {\n                 if let ExprKind::Path(ref qpath) = path.node {\n                     if let Some(def_id) = resolve_node(cx, qpath, path.hir_id).opt_def_id() {\n-                        if match_def_path(cx, def_id, &*paths::FROM_FROM) {\n+                        if match_def_path(cx, def_id, &paths::FROM_FROM) {\n                             let a = cx.tables.expr_ty(e);\n                             let b = cx.tables.expr_ty(&args[0]);\n                             if same_tys(cx, a, b) {"}, {"sha": "dc5a3a6b2f7327c9de39e3d4a865a9da81b3fe98", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{in_macro_or_desugar, is_expn_of, snippet_opt, span_lint_and_then};\n use rustc::hir::{intravisit::FnKind, Body, ExprKind, FnDecl, HirId, MatchSource};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -96,7 +95,7 @@ impl ImplicitReturn {\n             // everything else is missing `return`\n             _ => {\n                 // make sure it's not just an unreachable expression\n-                if is_expn_of(expr.span, *sym::unreachable).is_none() {\n+                if is_expn_of(expr.span, \"unreachable\").is_none() {\n                     Self::lint(cx, expr.span, expr.span, \"add `return` as shown\")\n                 }\n             },"}, {"sha": "46faa87d6a9214344a57281f64af0bf9b671d2cc", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 57, "deletions": 64, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -2,10 +2,7 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n \n-use crate::utils::sym;\n use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, match_type, paths, span_lint};\n-use lazy_static::lazy_static;\n-use syntax::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for iteration that is guaranteed to be infinite.\n@@ -112,40 +109,38 @@ enum Heuristic {\n \n use self::Heuristic::{All, Always, Any, First};\n \n-lazy_static! {\n /// a slice of (method name, number of args, heuristic, bounds) tuples\n /// that will be used to determine whether the method in question\n /// returns an infinite or possibly infinite iterator. The finiteness\n /// is an upper bound, e.g., some methods can return a possibly\n /// infinite iterator at worst, e.g., `take_while`.\n-static ref HEURISTICS: [(Symbol, usize, Heuristic, Finiteness); 19] = [\n-    (*sym::zip, 2, All, Infinite),\n-    (*sym::chain, 2, Any, Infinite),\n-    (*sym::cycle, 1, Always, Infinite),\n-    (*sym::map, 2, First, Infinite),\n-    (*sym::by_ref, 1, First, Infinite),\n-    (*sym::cloned, 1, First, Infinite),\n-    (*sym::rev, 1, First, Infinite),\n-    (*sym::inspect, 1, First, Infinite),\n-    (*sym::enumerate, 1, First, Infinite),\n-    (*sym::peekable, 2, First, Infinite),\n-    (*sym::fuse, 1, First, Infinite),\n-    (*sym::skip, 2, First, Infinite),\n-    (*sym::skip_while, 1, First, Infinite),\n-    (*sym::filter, 2, First, Infinite),\n-    (*sym::filter_map, 2, First, Infinite),\n-    (*sym::flat_map, 2, First, Infinite),\n-    (*sym::unzip, 1, First, Infinite),\n-    (*sym::take_while, 2, First, MaybeInfinite),\n-    (*sym::scan, 3, First, MaybeInfinite),\n+const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n+    (\"zip\", 2, All, Infinite),\n+    (\"chain\", 2, Any, Infinite),\n+    (\"cycle\", 1, Always, Infinite),\n+    (\"map\", 2, First, Infinite),\n+    (\"by_ref\", 1, First, Infinite),\n+    (\"cloned\", 1, First, Infinite),\n+    (\"rev\", 1, First, Infinite),\n+    (\"inspect\", 1, First, Infinite),\n+    (\"enumerate\", 1, First, Infinite),\n+    (\"peekable\", 2, First, Infinite),\n+    (\"fuse\", 1, First, Infinite),\n+    (\"skip\", 2, First, Infinite),\n+    (\"skip_while\", 1, First, Infinite),\n+    (\"filter\", 2, First, Infinite),\n+    (\"filter_map\", 2, First, Infinite),\n+    (\"flat_map\", 2, First, Infinite),\n+    (\"unzip\", 1, First, Infinite),\n+    (\"take_while\", 2, First, MaybeInfinite),\n+    (\"scan\", 3, First, MaybeInfinite),\n ];\n-}\n \n fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n-                if method.ident.name == name && args.len() == len {\n+                if method.ident.name.as_str() == name && args.len() == len {\n                     return (match heuristic {\n                         Always => Infinite,\n                         First => is_infinite(cx, &args[0]),\n@@ -155,7 +150,7 @@ fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n                     .and(cap);\n                 }\n             }\n-            if method.ident.name == *sym::flat_map && args.len() == 2 {\n+            if method.ident.name == sym!(flat_map) && args.len() == 2 {\n                 if let ExprKind::Closure(_, _, body_id, _, _) = args[1].node {\n                     let body = cx.tcx.hir().body(body_id);\n                     return is_infinite(cx, &body.value);\n@@ -167,7 +162,7 @@ fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n         ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) => is_infinite(cx, e),\n         ExprKind::Call(ref path, _) => {\n             if let ExprKind::Path(ref qpath) = path.node {\n-                match_qpath(qpath, &*paths::REPEAT).into()\n+                match_qpath(qpath, &paths::REPEAT).into()\n             } else {\n                 Finite\n             }\n@@ -177,68 +172,66 @@ fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     }\n }\n \n-lazy_static! {\n /// the names and argument lengths of methods that *may* exhaust their\n /// iterators\n-static ref POSSIBLY_COMPLETING_METHODS: [(Symbol, usize); 6] = [\n-    (*sym::find, 2),\n-    (*sym::rfind, 2),\n-    (*sym::position, 2),\n-    (*sym::rposition, 2),\n-    (*sym::any, 2),\n-    (*sym::all, 2),\n+const POSSIBLY_COMPLETING_METHODS: [(&str, usize); 6] = [\n+    (\"find\", 2),\n+    (\"rfind\", 2),\n+    (\"position\", 2),\n+    (\"rposition\", 2),\n+    (\"any\", 2),\n+    (\"all\", 2),\n ];\n \n /// the names and argument lengths of methods that *always* exhaust\n /// their iterators\n-static ref COMPLETING_METHODS: [(Symbol, usize); 12] = [\n-    (*sym::count, 1),\n-    (*sym::fold, 3),\n-    (*sym::for_each, 2),\n-    (*sym::partition, 2),\n-    (*sym::max, 1),\n-    (*sym::max_by, 2),\n-    (*sym::max_by_key, 2),\n-    (*sym::min, 1),\n-    (*sym::min_by, 2),\n-    (*sym::min_by_key, 2),\n-    (*sym::sum, 1),\n-    (*sym::product, 1),\n+const COMPLETING_METHODS: [(&str, usize); 12] = [\n+    (\"count\", 1),\n+    (\"fold\", 3),\n+    (\"for_each\", 2),\n+    (\"partition\", 2),\n+    (\"max\", 1),\n+    (\"max_by\", 2),\n+    (\"max_by_key\", 2),\n+    (\"min\", 1),\n+    (\"min_by\", 2),\n+    (\"min_by_key\", 2),\n+    (\"sum\", 1),\n+    (\"product\", 1),\n ];\n \n /// the paths of types that are known to be infinitely allocating\n-static ref INFINITE_COLLECTORS: [Vec<Symbol>; 8] = [\n-    paths::BINARY_HEAP.to_vec(),\n-    paths::BTREEMAP.to_vec(),\n-    paths::BTREESET.to_vec(),\n-    paths::HASHMAP.to_vec(),\n-    paths::HASHSET.to_vec(),\n-    paths::LINKED_LIST.to_vec(),\n-    paths::VEC.to_vec(),\n-    paths::VEC_DEQUE.to_vec(),\n+const INFINITE_COLLECTORS: [&[&str]; 8] = [\n+    &paths::BINARY_HEAP,\n+    &paths::BTREEMAP,\n+    &paths::BTREESET,\n+    &paths::HASHMAP,\n+    &paths::HASHSET,\n+    &paths::LINKED_LIST,\n+    &paths::VEC,\n+    &paths::VEC_DEQUE,\n ];\n-}\n \n fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len) in COMPLETING_METHODS.iter() {\n-                if method.ident.name == name && args.len() == len {\n+                if method.ident.name.as_str() == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);\n                 }\n             }\n             for &(name, len) in POSSIBLY_COMPLETING_METHODS.iter() {\n-                if method.ident.name == name && args.len() == len {\n+                if method.ident.name.as_str() == name && args.len() == len {\n                     return MaybeInfinite.and(is_infinite(cx, &args[0]));\n                 }\n             }\n-            if method.ident.name == *sym::last && args.len() == 1 {\n-                let not_double_ended = get_trait_def_id(cx, &*paths::DOUBLE_ENDED_ITERATOR)\n+            if method.ident.name == sym!(last) && args.len() == 1 {\n+                let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR)\n                     .map_or(false, |id| !implements_trait(cx, cx.tables.expr_ty(&args[0]), id, &[]));\n                 if not_double_ended {\n                     return is_infinite(cx, &args[0]);\n                 }\n-            } else if method.ident.name == *sym::collect {\n+            } else if method.ident.name == sym!(collect) {\n                 let ty = cx.tables.expr_ty(expr);\n                 if INFINITE_COLLECTORS.iter().any(|path| match_type(cx, ty, path)) {\n                     return is_infinite(cx, &args[0]);"}, {"sha": "ffc7a8005055c1981887e9b37626e6ba91dbe1f2", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -2,7 +2,6 @@\n \n use crate::utils::span_lint_and_then;\n use crate::utils::sugg::DiagnosticBuilderExt;\n-use crate::utils::sym;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n@@ -41,7 +40,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InlineFnWithoutBody {\n \n fn check_attrs(cx: &LateContext<'_, '_>, name: Name, attrs: &[Attribute]) {\n     for attr in attrs {\n-        if !attr.check_name(*sym::inline) {\n+        if !attr.check_name(sym!(inline)) {\n             continue;\n         }\n "}, {"sha": "af100f4c41d9a1068ba45975501f0a19bf21f5b7", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -37,12 +37,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n             if let ty::Ref(..) = cx.tables.expr_ty(expr).sty;\n             if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id();\n             then {\n-                let msg = if match_def_path(cx, def_id, &*paths::MEM_ZEROED) |\n-                             match_def_path(cx, def_id, &*paths::INIT)\n+                let msg = if match_def_path(cx, def_id, &paths::MEM_ZEROED) |\n+                             match_def_path(cx, def_id, &paths::INIT)\n                 {\n                     ZERO_REF_SUMMARY\n-                } else if match_def_path(cx, def_id, &*paths::MEM_UNINIT) |\n-                          match_def_path(cx, def_id, &*paths::UNINIT)\n+                } else if match_def_path(cx, def_id, &paths::MEM_UNINIT) |\n+                          match_def_path(cx, def_id, &paths::UNINIT)\n                 {\n                     UNINIT_REF_SUMMARY\n                 } else {"}, {"sha": "ccf899ca73cb4e29e6327e6f4fb05827c2620d26", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{\n     get_item_name, in_macro_or_desugar, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty,\n };\n@@ -11,7 +10,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use syntax::ast::{LitKind, Name};\n use syntax::source_map::{Span, Spanned};\n-use syntax::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for getting the length of something via `.len()`\n@@ -120,8 +118,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n }\n \n fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n-    fn is_named_self(cx: &LateContext<'_, '_>, item: &TraitItemRef, name: Symbol) -> bool {\n-        item.ident.name == name\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &TraitItemRef, name: &str) -> bool {\n+        item.ident.name.as_str() == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n                     let did = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n@@ -141,7 +139,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.hir_id) && trait_items.iter().any(|i| is_named_self(cx, i, *sym::len))\n+    if cx.access_levels.is_exported(visited_trait.hir_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\"))\n     {\n         let mut current_and_super_traits = FxHashSet::default();\n         let visited_trait_def_id = cx.tcx.hir().local_def_id_from_hir_id(visited_trait.hir_id);\n@@ -153,7 +151,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n             .any(|i| {\n                 i.kind == ty::AssociatedKind::Method\n                     && i.method_has_self_argument\n-                    && i.ident.name == *sym::is_empty\n+                    && i.ident.name == sym!(is_empty)\n                     && cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n             });\n \n@@ -172,8 +170,8 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n }\n \n fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplItemRef]) {\n-    fn is_named_self(cx: &LateContext<'_, '_>, item: &ImplItemRef, name: Symbol) -> bool {\n-        item.ident.name == name\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &ImplItemRef, name: &str) -> bool {\n+        item.ident.name.as_str() == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n                     let did = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n@@ -184,7 +182,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n             }\n     }\n \n-    let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, *sym::is_empty)) {\n+    let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n         if cx.access_levels.is_exported(is_empty.id.hir_id) {\n             return;\n         } else {\n@@ -194,7 +192,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n         \"no corresponding\"\n     };\n \n-    if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, *sym::len)) {\n+    if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n         if cx.access_levels.is_exported(i.id.hir_id) {\n             let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let ty = cx.tcx.type_of(def_id);\n@@ -216,7 +214,7 @@ fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr, lit: &Expr, op\n     if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.node, &lit.node) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n-            if name == *sym::is_empty {\n+            if name.as_str() == \"is_empty\" {\n                 return;\n             }\n         }\n@@ -240,7 +238,7 @@ fn check_len(\n             return;\n         }\n \n-        if method_name == *sym::len && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if method_name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n@@ -264,7 +262,7 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     /// Gets an `AssociatedItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n-            if item.ident.name == *sym::is_empty {\n+            if item.ident.name.as_str() == \"is_empty\" {\n                 let sig = cx.tcx.fn_sig(item.def_id);\n                 let ty = sig.skip_binder();\n                 ty.inputs().len() == 1"}, {"sha": "c4febdd4ddffb2453ac4171509f14d0e57d572d4", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -10,7 +10,6 @@ use rustc::middle::region;\n use rustc::{declare_lint_pass, declare_tool_lint};\n // use rustc::middle::region::CodeExtent;\n use crate::consts::{constant, Constant};\n-use crate::utils::sym;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{in_macro_or_desugar, sext, sugg};\n use rustc::middle::expr_use_visitor::*;\n@@ -555,9 +554,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n             {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if method_path.ident.name == *sym::next\n-                    && match_trait_method(cx, match_expr, &*paths::ITERATOR)\n-                    && lhs_constructor.ident.name == *sym::Some\n+                if method_path.ident.name == sym!(next)\n+                    && match_trait_method(cx, match_expr, &paths::ITERATOR)\n+                    && lhs_constructor.ident.name == sym!(Some)\n                     && (pat_args.is_empty()\n                         || !is_refutable(cx, &pat_args[0])\n                             && !is_used_inside(cx, iter_expr, &arms[0].body)\n@@ -595,8 +594,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n         if let StmtKind::Semi(ref expr) = stmt.node {\n             if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1\n-                    && method.ident.name == *sym::collect\n-                    && match_trait_method(cx, expr, &*paths::ITERATOR)\n+                    && method.ident.name == sym!(collect)\n+                    && match_trait_method(cx, expr, &paths::ITERATOR)\n                 {\n                     span_lint(\n                         cx,\n@@ -815,7 +814,7 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n         _ => false,\n     };\n \n-    is_slice || match_type(cx, ty, &*paths::VEC) || match_type(cx, ty, &*paths::VEC_DEQUE)\n+    is_slice || match_type(cx, ty, &paths::VEC) || match_type(cx, ty, &paths::VEC_DEQUE)\n }\n \n fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> Option<FixedOffsetVar> {\n@@ -878,7 +877,7 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n-        if method.ident.name == *sym::clone;\n+        if method.ident.name == sym!(clone);\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n         then {\n@@ -984,7 +983,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                 if let Some(end) = *end {\n                     if_chain! {\n                         if let ExprKind::MethodCall(ref method, _, ref len_args) = end.node;\n-                        if method.ident.name == *sym::len;\n+                        if method.ident.name == sym!(len);\n                         if len_args.len() == 1;\n                         if let Some(arg) = len_args.get(0);\n                         if snippet(cx, arg.span, \"??\") == var_name;\n@@ -1226,7 +1225,7 @@ fn is_len_call(expr: &Expr, var: Name) -> bool {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref len_args) = expr.node;\n         if len_args.len() == 1;\n-        if method.ident.name == *sym::len;\n+        if method.ident.name == sym!(len);\n         if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].node;\n         if path.segments.len() == 1;\n         if path.segments[0].ident.name == var;\n@@ -1354,7 +1353,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n                 if is_ref_iterable_type(cx, &args[0]) {\n                     lint_iter_method(cx, args, arg, method_name);\n                 }\n-            } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &*paths::INTO_ITERATOR) {\n+            } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n                 let def_id = cx.tables.type_dependent_def_id(arg.hir_id).unwrap();\n                 let substs = cx.tables.node_substs(arg.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n@@ -1382,7 +1381,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n                         applicability,\n                     );\n                 }\n-            } else if method_name == \"next\" && match_trait_method(cx, arg, &*paths::ITERATOR) {\n+            } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n                 span_lint(\n                     cx,\n                     ITER_NEXT_LOOP,\n@@ -1402,7 +1401,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n /// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n     let ty = cx.tables.expr_ty(arg);\n-    if match_type(cx, ty, &*paths::OPTION) {\n+    if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(\n             cx,\n             FOR_LOOP_OVER_OPTION,\n@@ -1418,7 +1417,7 @@ fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n                 snippet(cx, arg.span, \"_\")\n             ),\n         );\n-    } else if match_type(cx, ty, &*paths::RESULT) {\n+    } else if match_type(cx, ty, &paths::RESULT) {\n         span_help_and_lint(\n             cx,\n             FOR_LOOP_OVER_RESULT,\n@@ -1531,7 +1530,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n                 _ => arg,\n             };\n \n-            if match_type(cx, ty, &*paths::HASHMAP) || match_type(cx, ty, &*paths::BTREEMAP) {\n+            if match_type(cx, ty, &paths::HASHMAP) || match_type(cx, ty, &paths::BTREEMAP) {\n                 span_lint_and_then(\n                     cx,\n                     FOR_KV_MAP,\n@@ -1811,8 +1810,8 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         if_chain! {\n             // a range index op\n             if let ExprKind::MethodCall(ref meth, _, ref args) = expr.node;\n-            if (meth.ident.name == *sym::index && match_trait_method(self.cx, expr, &*paths::INDEX))\n-                || (meth.ident.name == *sym::index_mut && match_trait_method(self.cx, expr, &*paths::INDEX_MUT));\n+            if (meth.ident.name == sym!(index) && match_trait_method(self.cx, expr, &paths::INDEX))\n+                || (meth.ident.name == sym!(index_mut) && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n             then { return }\n         }\n@@ -1967,14 +1966,14 @@ fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     // will allow further borrows afterwards\n     let ty = cx.tables.expr_ty(e);\n     is_iterable_array(ty, cx) ||\n-    match_type(cx, ty, &*paths::VEC) ||\n-    match_type(cx, ty, &*paths::LINKED_LIST) ||\n-    match_type(cx, ty, &*paths::HASHMAP) ||\n-    match_type(cx, ty, &*paths::HASHSET) ||\n-    match_type(cx, ty, &*paths::VEC_DEQUE) ||\n-    match_type(cx, ty, &*paths::BINARY_HEAP) ||\n-    match_type(cx, ty, &*paths::BTREEMAP) ||\n-    match_type(cx, ty, &*paths::BTREESET)\n+    match_type(cx, ty, &paths::VEC) ||\n+    match_type(cx, ty, &paths::LINKED_LIST) ||\n+    match_type(cx, ty, &paths::HASHMAP) ||\n+    match_type(cx, ty, &paths::HASHSET) ||\n+    match_type(cx, ty, &paths::VEC_DEQUE) ||\n+    match_type(cx, ty, &paths::BINARY_HEAP) ||\n+    match_type(cx, ty, &paths::BTREEMAP) ||\n+    match_type(cx, ty, &paths::BTREESET)\n }\n \n fn is_iterable_array(ty: Ty<'_>, cx: &LateContext<'_, '_>) -> bool {\n@@ -2415,16 +2414,16 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n         if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].node;\n-        if chain_method.ident.name == *sym::collect && match_trait_method(cx, &args[0], &*paths::ITERATOR);\n+        if chain_method.ident.name == sym!(collect) && match_trait_method(cx, &args[0], &paths::ITERATOR);\n         if let Some(ref generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         then {\n             let ty = cx.tables.node_type(ty.hir_id);\n-            if match_type(cx, ty, &*paths::VEC) ||\n-                match_type(cx, ty, &*paths::VEC_DEQUE) ||\n-                match_type(cx, ty, &*paths::BTREEMAP) ||\n-                match_type(cx, ty, &*paths::HASHMAP) {\n-                if method.ident.name == *sym::len {\n+            if match_type(cx, ty, &paths::VEC) ||\n+                match_type(cx, ty, &paths::VEC_DEQUE) ||\n+                match_type(cx, ty, &paths::BTREEMAP) ||\n+                match_type(cx, ty, &paths::HASHMAP) {\n+                if method.ident.name == sym!(len) {\n                     let span = shorten_needless_collect_span(expr);\n                     span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {\n                         db.span_suggestion(\n@@ -2435,7 +2434,7 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>\n                         );\n                     });\n                 }\n-                if method.ident.name == *sym::is_empty {\n+                if method.ident.name == sym!(is_empty) {\n                     let span = shorten_needless_collect_span(expr);\n                     span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {\n                         db.span_suggestion(\n@@ -2446,7 +2445,7 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>\n                         );\n                     });\n                 }\n-                if method.ident.name == *sym::contains {\n+                if method.ident.name == sym!(contains) {\n                     let contains_arg = snippet(cx, args[1].span, \"??\");\n                     let span = shorten_needless_collect_span(expr);\n                     span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {"}, {"sha": "df10336d6d9729735e048198b6427803e9911482", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n             let ty = cx.tables.expr_ty(&args[0]);\n-            if match_type(cx, ty, &*paths::OPTION) || match_trait_method(cx, e, &*paths::ITERATOR);\n+            if match_type(cx, ty, &paths::OPTION) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].node;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n                             },\n                             hir::ExprKind::MethodCall(ref method, _, ref obj) => {\n                                 if ident_eq(name, &obj[0]) && method.ident.as_str() == \"clone\"\n-                                    && match_trait_method(cx, closure_expr, &*paths::CLONE_TRAIT) {\n+                                    && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n \n                                     let obj_ty = cx.tables.expr_ty(&obj[0]);\n                                     if let ty::Ref(_, ty, _) = obj_ty.sty {"}, {"sha": "2e97f44b317f721c4b0a3f5b56795589c3275dcb", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,5 +1,4 @@\n use crate::utils::paths;\n-use crate::utils::sym;\n use crate::utils::{in_macro_or_desugar, iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n use if_chain::if_chain;\n use rustc::hir;\n@@ -186,9 +185,9 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n     let var_arg = &map_args[0];\n \n-    let (map_type, variant, lint) = if match_type(cx, cx.tables.expr_ty(var_arg), &*paths::OPTION) {\n+    let (map_type, variant, lint) = if match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n         (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-    } else if match_type(cx, cx.tables.expr_ty(var_arg), &*paths::RESULT) {\n+    } else if match_type(cx, cx.tables.expr_ty(var_arg), &paths::RESULT) {\n         (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n     } else {\n         return;\n@@ -246,7 +245,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapUnit {\n         }\n \n         if let hir::StmtKind::Semi(ref expr) = stmt.node {\n-            if let Some(arglists) = method_chain_args(expr, &[*sym::map]) {\n+            if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n                 lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n             }\n         }"}, {"sha": "cb33ad4d974b8cd7a76602442744a95f66a4a23f", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,7 +1,6 @@\n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n-use crate::utils::sym;\n use crate::utils::{\n     expr_block, in_macro_or_desugar, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg, remove_blocks,\n     snippet, snippet_with_applicability, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty,\n@@ -320,13 +319,13 @@ fn check_single_match_opt_like(\n ) {\n     // list of candidate `Enum`s we know will never get any more members\n     let candidates = &[\n-        (&*paths::COW, \"Borrowed\"),\n-        (&*paths::COW, \"Cow::Borrowed\"),\n-        (&*paths::COW, \"Cow::Owned\"),\n-        (&*paths::COW, \"Owned\"),\n-        (&*paths::OPTION, \"None\"),\n-        (&*paths::RESULT, \"Err\"),\n-        (&*paths::RESULT, \"Ok\"),\n+        (&paths::COW, \"Borrowed\"),\n+        (&paths::COW, \"Cow::Borrowed\"),\n+        (&paths::COW, \"Cow::Owned\"),\n+        (&paths::COW, \"Owned\"),\n+        (&paths::OPTION, \"None\"),\n+        (&paths::RESULT, \"Err\"),\n+        (&paths::RESULT, \"Ok\"),\n     ];\n \n     let path = match arms[1].pats[0].node {\n@@ -437,7 +436,7 @@ fn is_wild(pat: &impl std::ops::Deref<Target = Pat>) -> bool {\n \n fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n-    if match_type(cx, ex_ty, &*paths::RESULT) {\n+    if match_type(cx, ex_ty, &paths::RESULT) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pats[0].node {\n                 let path_str = print::to_string(print::NO_ANN, |s| s.print_qpath(path, false));\n@@ -553,10 +552,10 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n fn is_panic_block(block: &Block) -> bool {\n     match (&block.expr, block.stmts.len(), block.stmts.first()) {\n         (&Some(ref exp), 0, _) => {\n-            is_expn_of(exp.span, *sym::panic).is_some() && is_expn_of(exp.span, *sym::unreachable).is_none()\n+            is_expn_of(exp.span, \"panic\").is_some() && is_expn_of(exp.span, \"unreachable\").is_none()\n         },\n         (&None, 1, Some(stmt)) => {\n-            is_expn_of(stmt.span, *sym::panic).is_some() && is_expn_of(stmt.span, *sym::unreachable).is_none()\n+            is_expn_of(stmt.span, \"panic\").is_some() && is_expn_of(stmt.span, \"unreachable\").is_none()\n         },\n         _ => false,\n     }\n@@ -718,7 +717,7 @@ fn is_unit_expr(expr: &Expr) -> bool {\n // Checks if arm has the form `None => None`\n fn is_none_arm(arm: &Arm) -> bool {\n     match arm.pats[0].node {\n-        PatKind::Path(ref path) if match_qpath(path, &*paths::OPTION_NONE) => true,\n+        PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n         _ => false,\n     }\n }\n@@ -727,12 +726,12 @@ fn is_none_arm(arm: &Arm) -> bool {\n fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pats[0].node;\n-        if pats.len() == 1 && match_qpath(path, &*paths::OPTION_SOME);\n+        if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n         if let PatKind::Binding(rb, .., ident, _) = pats[0].node;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n         if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).node;\n         if let ExprKind::Path(ref some_path) = e.node;\n-        if match_qpath(some_path, &*paths::OPTION_SOME) && args.len() == 1;\n+        if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n         if let ExprKind::Path(ref qpath) = args[0].node;\n         if let &QPath::Resolved(_, ref path2) = qpath;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;"}, {"sha": "d1966a9f61ed026909a344e841dc9ad5cc2dc6a5", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n             // is `mem::discriminant`\n             if let ExprKind::Path(ref func_qpath) = func.node;\n             if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &*paths::MEM_DISCRIMINANT);\n+            if match_def_path(cx, def_id, &paths::MEM_DISCRIMINANT);\n             // type is non-enum\n             let ty_param = cx.tables.node_substs(func.hir_id).type_at(0);\n             if !ty_param.is_enum();"}, {"sha": "55673c43047e877992bd83747f6fd09d60a1c086", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n         if let ExprKind::Call(ref path_expr, ref args) = e.node {\n             if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if match_def_path(cx, def_id, &*paths::MEM_FORGET) {\n+                    if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.tables.expr_ty(&args[0]);\n \n                         if forgot_ty.ty_adt_def().map_or(false, |def| def.has_dtor(cx.tcx)) {"}, {"sha": "7e83e836b8569750177e60d4bf81be456eeb3ffb", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -42,11 +42,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n             if func_args.len() == 2;\n             if let ExprKind::Path(ref func_qpath) = func.node;\n             if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &*paths::MEM_REPLACE);\n+            if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n \n             // Check that second argument is `Option::None`\n             if let ExprKind::Path(ref replacement_qpath) = func_args[1].node;\n-            if match_qpath(replacement_qpath, &*paths::OPTION_NONE);\n+            if match_qpath(replacement_qpath, &paths::OPTION_NONE);\n \n             then {\n                 // Since this is a late pass (already type-checked),"}, {"sha": "c97a60bb85346b543ae679cbcc24f1d65ad2470e", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 113, "deletions": 114, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -21,7 +21,6 @@ use syntax::symbol::{LocalInternedString, Symbol};\n \n use crate::utils::paths;\n use crate::utils::sugg;\n-use crate::utils::sym;\n use crate::utils::{\n     get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy,\n     is_ctor_function, is_expn_of, is_self, is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path,\n@@ -908,7 +907,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n                 let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && method_call.ident.name == *sym::clone {\n+                if args.len() == 1 && method_call.ident.name == sym!(clone) {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                     lint_clone_on_ref_ptr(cx, expr, &args[0]);\n                 }\n@@ -921,7 +920,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                             }\n                         }\n                     },\n-                    ty::Ref(..) if method_call.ident.name == *sym::into_iter => {\n+                    ty::Ref(..) if method_call.ident.name == sym!(into_iter) => {\n                         lint_into_iter(cx, expr, self_ty, *method_span);\n                     },\n                     _ => (),\n@@ -1033,7 +1032,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                 }\n             }\n \n-            if name == *sym::new && !same_tys(cx, ret_ty, ty) {\n+            if name == sym!(new) && !same_tys(cx, ret_ty, ty) {\n                 span_lint(\n                     cx,\n                     NEW_RET_NO_SELF,\n@@ -1112,7 +1111,7 @@ fn lint_or_fun_call<'a, 'tcx: 'a>(\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tables.expr_ty(arg);\n-                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &*paths::DEFAULT_TRAIT)\n+                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT)\n                     {\n                         default_trait_id\n                     } else {\n@@ -1156,10 +1155,10 @@ fn lint_or_fun_call<'a, 'tcx: 'a>(\n     ) {\n         // (path, fn_has_argument, methods, suffix)\n         let know_types: &[(&[_], _, &[_], _)] = &[\n-            (&*paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&*paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&*paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-            (&*paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n         // early check if the name is one we care about\n@@ -1248,11 +1247,11 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n                 hir::ExprKind::AddrOf(_, expr) => expr,\n                 hir::ExprKind::MethodCall(method_name, _, call_args) => {\n                     if call_args.len() == 1\n-                        && (method_name.ident.name == *sym::as_str || method_name.ident.name == *sym::as_ref)\n+                        && (method_name.ident.name == sym!(as_str) || method_name.ident.name == sym!(as_ref))\n                         && {\n                             let arg_type = cx.tables.expr_ty(&call_args[0]);\n                             let base_type = walk_ptrs_ty(arg_type);\n-                            base_type.sty == ty::Str || match_type(cx, base_type, &*paths::STRING)\n+                            base_type.sty == ty::Str || match_type(cx, base_type, &paths::STRING)\n                         }\n                     {\n                         &call_args[0]\n@@ -1270,7 +1269,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n     // converted to string.\n     fn requires_to_string(cx: &LateContext<'_, '_>, arg: &hir::Expr) -> bool {\n         let arg_ty = cx.tables.expr_ty(arg);\n-        if match_type(cx, arg_ty, &*paths::STRING) {\n+        if match_type(cx, arg_ty, &paths::STRING) {\n             return false;\n         }\n         if let ty::Ref(ty::ReStatic, ty, ..) = arg_ty.sty {\n@@ -1319,9 +1318,9 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n     }\n \n     let receiver_type = cx.tables.expr_ty(&args[0]);\n-    let closure_args = if match_type(cx, receiver_type, &*paths::OPTION) {\n+    let closure_args = if match_type(cx, receiver_type, &paths::OPTION) {\n         \"||\"\n-    } else if match_type(cx, receiver_type, &*paths::RESULT) {\n+    } else if match_type(cx, receiver_type, &paths::RESULT) {\n         \"|_|\"\n     } else {\n         return;\n@@ -1335,7 +1334,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n \n     //Special handling for `format!` as arg_root\n     if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.node {\n-        if is_expn_of(inner_fun.span, *sym::format).is_some() && inner_args.len() == 1 {\n+        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n             if let hir::ExprKind::Call(_, format_args) = &inner_args[0].node {\n                 let fmt_spec = &format_args[0];\n                 let fmt_args = &format_args[1];\n@@ -1475,11 +1474,11 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n \n     if let ty::Adt(_, subst) = obj_ty.sty {\n-        let caller_type = if match_type(cx, obj_ty, &*paths::RC) {\n+        let caller_type = if match_type(cx, obj_ty, &paths::RC) {\n             \"Rc\"\n-        } else if match_type(cx, obj_ty, &*paths::ARC) {\n+        } else if match_type(cx, obj_ty, &paths::ARC) {\n             \"Arc\"\n-        } else if match_type(cx, obj_ty, &*paths::WEAK_RC) || match_type(cx, obj_ty, &*paths::WEAK_ARC) {\n+        } else if match_type(cx, obj_ty, &paths::WEAK_RC) || match_type(cx, obj_ty, &paths::WEAK_ARC) {\n             \"Weak\"\n         } else {\n             return;\n@@ -1504,12 +1503,12 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::\n \n fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg = &args[1];\n-    if let Some(arglists) = method_chain_args(arg, &[*sym::chars]) {\n+    if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n         let self_ty = walk_ptrs_ty(cx.tables.expr_ty(target));\n         let ref_str = if self_ty.sty == ty::Str {\n             \"\"\n-        } else if match_type(cx, self_ty, &*paths::STRING) {\n+        } else if match_type(cx, self_ty, &paths::STRING) {\n             \"&\"\n         } else {\n             return;\n@@ -1535,7 +1534,7 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::E\n \n fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n-    if match_type(cx, obj_ty, &*paths::STRING) {\n+    if match_type(cx, obj_ty, &paths::STRING) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n@@ -1546,7 +1545,7 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, new: &hir::Ex\n         if args.len() == 1;\n         if let hir::ExprKind::Path(ref path) = fun.node;\n         if let Res::Def(DefKind::Method, did) = cx.tables.qpath_res(path, fun.hir_id);\n-        if match_def_path(cx, did, &*paths::CSTRING_NEW);\n+        if match_def_path(cx, did, &paths::CSTRING_NEW);\n         then {\n             span_lint_and_then(\n                 cx,\n@@ -1562,7 +1561,7 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, new: &hir::Ex\n }\n \n fn lint_iter_cloned_collect<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_args: &'tcx [hir::Expr]) {\n-    if match_type(cx, cx.tables.expr_ty(expr), &*paths::VEC) {\n+    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC) {\n         if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])) {\n             if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite()) {\n                 span_lint_and_sugg(\n@@ -1640,7 +1639,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n     }\n \n     // Check that this is a call to Iterator::fold rather than just some function called fold\n-    if !match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n     }\n \n@@ -1666,9 +1665,9 @@ fn lint_iter_nth<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_ar\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    } else if match_type(cx, cx.tables.expr_ty(&iter_args[0]), &*paths::VEC) {\n+    } else if match_type(cx, cx.tables.expr_ty(&iter_args[0]), &paths::VEC) {\n         \"Vec\"\n-    } else if match_type(cx, cx.tables.expr_ty(&iter_args[0]), &*paths::VEC_DEQUE) {\n+    } else if match_type(cx, cx.tables.expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n         \"VecDeque\"\n     } else {\n         return; // caller is not a type that we want to lint\n@@ -1699,16 +1698,16 @@ fn lint_get_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, get_a\n     let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"slice\"\n-    } else if match_type(cx, expr_ty, &*paths::VEC) {\n+    } else if match_type(cx, expr_ty, &paths::VEC) {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"Vec\"\n-    } else if match_type(cx, expr_ty, &*paths::VEC_DEQUE) {\n+    } else if match_type(cx, expr_ty, &paths::VEC_DEQUE) {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"VecDeque\"\n-    } else if !is_mut && match_type(cx, expr_ty, &*paths::HASHMAP) {\n+    } else if !is_mut && match_type(cx, expr_ty, &paths::HASHMAP) {\n         needs_ref = true;\n         \"HashMap\"\n-    } else if !is_mut && match_type(cx, expr_ty, &*paths::BTREEMAP) {\n+    } else if !is_mut && match_type(cx, expr_ty, &paths::BTREEMAP) {\n         needs_ref = true;\n         \"BTreeMap\"\n     } else {\n@@ -1760,7 +1759,7 @@ fn lint_get_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, get_a\n \n fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n     // lint if caller of skip is an Iterator\n-    if match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         span_lint(\n             cx,\n             ITER_SKIP_NEXT,\n@@ -1779,15 +1778,15 @@ fn derefs_to_slice<'a, 'tcx>(\n         match ty.sty {\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n-            ty::Adt(..) => match_type(cx, ty, &*paths::VEC),\n+            ty::Adt(..) => match_type(cx, ty, &paths::VEC),\n             ty::Array(_, size) => size.assert_usize(cx.tcx).expect(\"array length\") < 32,\n             ty::Ref(_, inner, _) => may_slice(cx, inner),\n             _ => false,\n         }\n     }\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n-        if path.ident.name == *sym::iter && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n+        if path.ident.name == sym!(iter) && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {\n             None\n@@ -1812,9 +1811,9 @@ fn derefs_to_slice<'a, 'tcx>(\n fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n \n-    let mess = if match_type(cx, obj_ty, &*paths::OPTION) {\n+    let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n         Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n-    } else if match_type(cx, obj_ty, &*paths::RESULT) {\n+    } else if match_type(cx, obj_ty, &paths::RESULT) {\n         Some((RESULT_UNWRAP_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -1838,7 +1837,7 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::E\n /// lint use of `ok().expect()` for `Result`s\n fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n     // lint if the caller of `ok()` is a `Result`\n-    if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &*paths::RESULT) {\n+    if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT) {\n         let result_type = cx.tables.expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type) {\n             if has_debug_impl(error_type, cx) {\n@@ -1856,7 +1855,7 @@ fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Ex\n /// lint use of `map().flatten()` for `Iterators`\n fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.map().flatten()` is an Iterator\n-    if match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `map(..).flatten()` on an `Iterator`. \\\n                    This is more succinctly expressed by calling `.flat_map(..)`\";\n         let self_snippet = snippet(cx, map_args[0].span, \"..\");\n@@ -1881,8 +1880,8 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n     unwrap_args: &'tcx [hir::Expr],\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = match_type(cx, cx.tables.expr_ty(&map_args[0]), &*paths::OPTION);\n-    let is_result = match_type(cx, cx.tables.expr_ty(&map_args[0]), &*paths::RESULT);\n+    let is_option = match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION);\n+    let is_result = match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::RESULT);\n     if is_option || is_result {\n         // lint message\n         let msg = if is_option {\n@@ -1934,10 +1933,10 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n \n /// lint use of `_.map_or(None, _)` for `Option`s\n fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n-    if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &*paths::OPTION) {\n+    if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n         let map_or_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].node {\n-            match_qpath(qpath, &*paths::OPTION_NONE)\n+            match_qpath(qpath, &paths::OPTION_NONE)\n         } else {\n             false\n         };\n@@ -1964,7 +1963,7 @@ fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n /// lint use of `filter().next()` for `Iterators`\n fn lint_filter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, filter_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.filter().next()` is an Iterator\n-    if match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find(p)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n@@ -1992,7 +1991,7 @@ fn lint_filter_map<'a, 'tcx>(\n     _map_args: &'tcx [hir::Expr],\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n-    if match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).map(q)` on an `Iterator`. \\\n                    This is more succinctly expressed by calling `.filter_map(..)` instead.\";\n         span_lint(cx, FILTER_MAP, expr.span, msg);\n@@ -2001,7 +2000,7 @@ fn lint_filter_map<'a, 'tcx>(\n \n /// lint use of `filter_map().next()` for `Iterators`\n fn lint_filter_map_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, filter_args: &'tcx [hir::Expr]) {\n-    if match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find_map(p)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n@@ -2028,7 +2027,7 @@ fn lint_find_map<'a, 'tcx>(\n     map_args: &'tcx [hir::Expr],\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n-    if match_trait_method(cx, &map_args[0], &*paths::ITERATOR) {\n+    if match_trait_method(cx, &map_args[0], &paths::ITERATOR) {\n         let msg = \"called `find(p).map(q)` on an `Iterator`. \\\n                    This is more succinctly expressed by calling `.find_map(..)` instead.\";\n         span_lint(cx, FIND_MAP, expr.span, msg);\n@@ -2043,7 +2042,7 @@ fn lint_filter_map_map<'a, 'tcx>(\n     _map_args: &'tcx [hir::Expr],\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n-    if match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).map(q)` on an `Iterator`. \\\n                    This is more succinctly expressed by only calling `.filter_map(..)` instead.\";\n         span_lint(cx, FILTER_MAP, expr.span, msg);\n@@ -2058,7 +2057,7 @@ fn lint_filter_flat_map<'a, 'tcx>(\n     _map_args: &'tcx [hir::Expr],\n ) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n-    if match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).flat_map(q)` on an `Iterator`. \\\n                    This is more succinctly expressed by calling `.flat_map(..)` \\\n                    and filtering by returning an empty Iterator.\";\n@@ -2074,7 +2073,7 @@ fn lint_filter_map_flat_map<'a, 'tcx>(\n     _map_args: &'tcx [hir::Expr],\n ) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n-    if match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`. \\\n                    This is more succinctly expressed by calling `.flat_map(..)` \\\n                    and filtering by returning an empty Iterator.\";\n@@ -2091,7 +2090,7 @@ fn lint_search_is_some<'a, 'tcx>(\n     is_some_args: &'tcx [hir::Expr],\n ) {\n     // lint if caller of search is an Iterator\n-    if match_trait_method(cx, &is_some_args[0], &*paths::ITERATOR) {\n+    if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n         let msg = format!(\n             \"called `is_some()` after searching an `Iterator` with {}. This is more succinctly \\\n              expressed by calling `any()`.\",\n@@ -2164,7 +2163,7 @@ fn lint_binary_expr_with_method_call(cx: &LateContext<'_, '_>, info: &mut Binary\n fn lint_chars_cmp(\n     cx: &LateContext<'_, '_>,\n     info: &BinaryExprInfo<'_>,\n-    chain_methods: &[Symbol],\n+    chain_methods: &[&str],\n     lint: &'static Lint,\n     suggest: &str,\n ) -> bool {\n@@ -2174,7 +2173,7 @@ fn lint_chars_cmp(\n         if arg_char.len() == 1;\n         if let hir::ExprKind::Path(ref qpath) = fun.node;\n         if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == *sym::Some;\n+        if segment.ident.name == sym!(Some);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n@@ -2206,23 +2205,23 @@ fn lint_chars_cmp(\n \n /// Checks for the `CHARS_NEXT_CMP` lint.\n fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    lint_chars_cmp(cx, info, &[*sym::chars, *sym::next], CHARS_NEXT_CMP, \"starts_with\")\n+    lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint.\n fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    if lint_chars_cmp(cx, info, &[*sym::chars, *sym::last], CHARS_LAST_CMP, \"ends_with\") {\n+    if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {\n-        lint_chars_cmp(cx, info, &[*sym::chars, *sym::next_back], CHARS_LAST_CMP, \"ends_with\")\n+        lint_chars_cmp(cx, info, &[\"chars\", \"next_back\"], CHARS_LAST_CMP, \"ends_with\")\n     }\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     info: &BinaryExprInfo<'_>,\n-    chain_methods: &[Symbol],\n+    chain_methods: &[&str],\n     lint: &'static Lint,\n     suggest: &str,\n ) -> bool {\n@@ -2258,7 +2257,7 @@ fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &\n     lint_chars_cmp_with_unwrap(\n         cx,\n         info,\n-        &[*sym::chars, *sym::next, *sym::unwrap],\n+        &[\"chars\", \"next\", \"unwrap\"],\n         CHARS_NEXT_CMP,\n         \"starts_with\",\n     )\n@@ -2269,7 +2268,7 @@ fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &\n     if lint_chars_cmp_with_unwrap(\n         cx,\n         info,\n-        &[*sym::chars, *sym::last, *sym::unwrap],\n+        &[\"chars\", \"last\", \"unwrap\"],\n         CHARS_LAST_CMP,\n         \"ends_with\",\n     ) {\n@@ -2278,7 +2277,7 @@ fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &\n         lint_chars_cmp_with_unwrap(\n             cx,\n             info,\n-            &[*sym::chars, *sym::next_back, *sym::unwrap],\n+            &[\"chars\", \"next_back\", \"unwrap\"],\n             CHARS_LAST_CMP,\n             \"ends_with\",\n         )\n@@ -2313,7 +2312,7 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, _expr: &'tcx h\n fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_ref_args: &[hir::Expr]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n-    if match_trait_method(cx, expr, &*paths::ASREF_TRAIT) || match_trait_method(cx, expr, &*paths::ASMUT_TRAIT) {\n+    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n         let recvr = &as_ref_args[0];\n         let rcv_ty = cx.tables.expr_ty(recvr);\n@@ -2345,9 +2344,9 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n     }\n }\n \n-fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: Ty<'_>) -> Option<(&'static Lint, Symbol, &'static str)> {\n+fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: Ty<'_>) -> Option<(&'static Lint, &'static str, &'static str)> {\n     if let Some(ty_name) = has_iter_method(cx, self_ref_ty) {\n-        let lint = if ty_name == *sym::array || ty_name == *sym::PathBuf {\n+        let lint = if ty_name == \"array\" || ty_name == \"PathBuf\" {\n             INTO_ITER_ON_ARRAY\n         } else {\n             INTO_ITER_ON_REF\n@@ -2367,7 +2366,7 @@ fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: Ty<'_>) -> Option<(\n }\n \n fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: Ty<'_>, method_span: Span) {\n-    if !match_trait_method(cx, expr, &*paths::INTO_ITERATOR) {\n+    if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n         return;\n     }\n     if let Some((lint, kind, method_name)) = ty_has_iter_method(cx, self_ref_ty) {\n@@ -2389,7 +2388,7 @@ fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: Ty<'_\n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::Adt(_, substs) = ty.sty {\n-        if match_type(cx, ty, &*paths::RESULT) {\n+        if match_type(cx, ty, &paths::RESULT) {\n             substs.types().nth(1)\n         } else {\n             None\n@@ -2426,59 +2425,59 @@ const CONVENTIONS: [(Convention, &[SelfKind]); 7] = [\n #[rustfmt::skip]\n lazy_static! {\n static ref TRAIT_METHODS: [(Symbol, usize, SelfKind, OutType, &'static str); 30] = [\n-    (*sym::add, 2, SelfKind::Value, OutType::Any, \"std::ops::Add\"),\n-    (*sym::as_mut, 1, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n-    (*sym::as_ref, 1, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n-    (*sym::bitand, 2, SelfKind::Value, OutType::Any, \"std::ops::BitAnd\"),\n-    (*sym::bitor, 2, SelfKind::Value, OutType::Any, \"std::ops::BitOr\"),\n-    (*sym::bitxor, 2, SelfKind::Value, OutType::Any, \"std::ops::BitXor\"),\n-    (*sym::borrow, 1, SelfKind::Ref, OutType::Ref, \"std::borrow::Borrow\"),\n-    (*sym::borrow_mut, 1, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n-    (*sym::clone, 1, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n-    (*sym::cmp, 2, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n-    (*sym::default, 0, SelfKind::No, OutType::Any, \"std::default::Default\"),\n-    (*sym::deref, 1, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n-    (*sym::deref_mut, 1, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n-    (*sym::div, 2, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n-    (*sym::drop, 1, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n-    (*sym::eq, 2, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n-    (*sym::from_iter, 1, SelfKind::No, OutType::Any, \"std::iter::FromIterator\"),\n-    (*sym::from_str, 1, SelfKind::No, OutType::Any, \"std::str::FromStr\"),\n-    (*sym::hash, 2, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n-    (*sym::index, 2, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n-    (*sym::index_mut, 2, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n-    (*sym::into_iter, 1, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n-    (*sym::mul, 2, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n-    (*sym::neg, 1, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n-    (*sym::next, 1, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n-    (*sym::not, 1, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n-    (*sym::rem, 2, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n-    (*sym::shl, 2, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n-    (*sym::shr, 2, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n-    (*sym::sub, 2, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n+    (sym!(add), 2, SelfKind::Value, OutType::Any, \"std::ops::Add\"),\n+    (sym!(as_mut), 1, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n+    (sym!(as_ref), 1, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n+    (sym!(bitand), 2, SelfKind::Value, OutType::Any, \"std::ops::BitAnd\"),\n+    (sym!(bitor), 2, SelfKind::Value, OutType::Any, \"std::ops::BitOr\"),\n+    (sym!(bitxor), 2, SelfKind::Value, OutType::Any, \"std::ops::BitXor\"),\n+    (sym!(borrow), 1, SelfKind::Ref, OutType::Ref, \"std::borrow::Borrow\"),\n+    (sym!(borrow_mut), 1, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n+    (sym!(clone), 1, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n+    (sym!(cmp), 2, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n+    (sym!(default), 0, SelfKind::No, OutType::Any, \"std::default::Default\"),\n+    (sym!(deref), 1, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n+    (sym!(deref_mut), 1, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n+    (sym!(div), 2, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n+    (sym!(drop), 1, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n+    (sym!(eq), 2, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n+    (sym!(from_iter), 1, SelfKind::No, OutType::Any, \"std::iter::FromIterator\"),\n+    (sym!(from_str), 1, SelfKind::No, OutType::Any, \"std::str::FromStr\"),\n+    (sym!(hash), 2, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n+    (sym!(index), 2, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n+    (sym!(index_mut), 2, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n+    (sym!(into_iter), 1, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n+    (sym!(mul), 2, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n+    (sym!(neg), 1, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n+    (sym!(next), 1, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n+    (sym!(not), 1, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n+    (sym!(rem), 2, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n+    (sym!(shl), 2, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n+    (sym!(shr), 2, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n+    (sym!(sub), 2, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n ];\n }\n \n #[rustfmt::skip]\n lazy_static! {\n static ref PATTERN_METHODS: [(Symbol, usize); 17] = [\n-    (*sym::contains, 1),\n-    (*sym::starts_with, 1),\n-    (*sym::ends_with, 1),\n-    (*sym::find, 1),\n-    (*sym::rfind, 1),\n-    (*sym::split, 1),\n-    (*sym::rsplit, 1),\n-    (*sym::split_terminator, 1),\n-    (*sym::rsplit_terminator, 1),\n-    (*sym::splitn, 2),\n-    (*sym::rsplitn, 2),\n-    (*sym::matches, 1),\n-    (*sym::rmatches, 1),\n-    (*sym::match_indices, 1),\n-    (*sym::rmatch_indices, 1),\n-    (*sym::trim_start_matches, 1),\n-    (*sym::trim_end_matches, 1),\n+    (sym!(contains), 1),\n+    (sym!(starts_with), 1),\n+    (sym!(ends_with), 1),\n+    (sym!(find), 1),\n+    (sym!(rfind), 1),\n+    (sym!(split), 1),\n+    (sym!(rsplit), 1),\n+    (sym!(split_terminator), 1),\n+    (sym!(rsplit_terminator), 1),\n+    (sym!(splitn), 2),\n+    (sym!(rsplitn), 2),\n+    (sym!(matches), 1),\n+    (sym!(rmatches), 1),\n+    (sym!(match_indices), 1),\n+    (sym!(rmatch_indices), 1),\n+    (sym!(trim_start_matches), 1),\n+    (sym!(trim_end_matches), 1),\n ];\n }\n \n@@ -2536,8 +2535,8 @@ impl SelfKind {\n         } else {\n             match self {\n                 SelfKind::Value => false,\n-                SelfKind::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &*paths::ASREF_TRAIT),\n-                SelfKind::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &*paths::ASMUT_TRAIT),\n+                SelfKind::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n+                SelfKind::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n                 SelfKind::No => true,\n             }\n         }\n@@ -2553,7 +2552,7 @@ impl SelfKind {\n     }\n }\n \n-fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[Symbol]) -> bool {\n+fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.params.iter().any(|param| match param.kind {\n             hir::GenericParamKind::Type { .. } => {\n@@ -2657,7 +2656,7 @@ impl OutType {\n \n fn is_bool(ty: &hir::Ty) -> bool {\n     if let hir::TyKind::Path(ref p) = ty.node {\n-        match_qpath(p, &[*sym::bool])\n+        match_qpath(p, &[\"bool\"])\n     } else {\n         false\n     }"}, {"sha": "ce78c740f7c45c26d74570e50faab3b6859c58a7", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n use rustc::hir::{self, *};\n use rustc::lint::LateContext;\n use rustc_data_structures::fx::FxHashSet;\n-use syntax::symbol::Symbol;\n+use syntax_pos::symbol::Symbol;\n \n use super::OPTION_MAP_UNWRAP_OR;\n \n@@ -16,7 +16,7 @@ pub(super) fn lint<'a, 'tcx>(\n     unwrap_args: &'tcx [hir::Expr],\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &*paths::OPTION) {\n+    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n         if !is_copy(cx, cx.tables.expr_ty(&unwrap_args[1])) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument"}, {"sha": "a28e6fa88bbe718aad0bb4d0f071653284285b78", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -11,7 +11,7 @@ use if_chain::if_chain;\n use super::UNNECESSARY_FILTER_MAP;\n \n pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n-    if !match_trait_method(cx, expr, &*paths::ITERATOR) {\n+    if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n     }\n \n@@ -63,7 +63,7 @@ fn check_expression<'a, 'tcx: 'a>(\n             if_chain! {\n                 if let hir::ExprKind::Path(ref path) = func.node;\n                 then {\n-                    if match_qpath(path, &*paths::OPTION_SOME) {\n+                    if match_qpath(path, &paths::OPTION_SOME) {\n                         if_chain! {\n                             if let hir::ExprKind::Path(path) = &args[0].node;\n                             if let Res::Local(ref local) = cx.tables.qpath_res(path, args[0].hir_id);\n@@ -99,7 +99,7 @@ fn check_expression<'a, 'tcx: 'a>(\n             }\n             (found_mapping, found_filtering)\n         },\n-        hir::ExprKind::Path(path) if match_qpath(path, &*paths::OPTION_NONE) => (false, true),\n+        hir::ExprKind::Path(path) if match_qpath(path, &paths::OPTION_NONE) => (false, true),\n         _ => (true, true),\n     }\n }"}, {"sha": "4cc1e0e3691dc785e77a16199835cdbccf8a6c57", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -63,9 +63,9 @@ fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Cons\n     if let ExprKind::Call(ref path, ref args) = expr.node {\n         if let ExprKind::Path(ref qpath) = path.node {\n             cx.tables.qpath_res(qpath, path.hir_id).opt_def_id().and_then(|def_id| {\n-                if match_def_path(cx, def_id, &*paths::CMP_MIN) {\n+                if match_def_path(cx, def_id, &paths::CMP_MIN) {\n                     fetch_const(cx, args, MinMax::Min)\n-                } else if match_def_path(cx, def_id, &*paths::CMP_MAX) {\n+                } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n                     fetch_const(cx, args, MinMax::Max)\n                 } else {\n                     None"}, {"sha": "72680d3a6f408492238dbb76b5cd649bdc27ad6b", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -11,7 +11,6 @@ use syntax::source_map::{ExpnFormat, Span};\n \n use crate::consts::{constant, Constant};\n use crate::utils::sugg::Sugg;\n-use crate::utils::sym;\n use crate::utils::{\n     get_item_name, get_parent_expr, implements_trait, in_constant, in_macro_or_desugar, is_integer_literal,\n     iter_input_pats, last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint, span_lint_and_then,\n@@ -462,7 +461,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n fn check_nan(cx: &LateContext<'_, '_>, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.hir_id) {\n         if let Some(seg) = path.segments.last() {\n-            if seg.ident.name == *sym::NAN {\n+            if seg.ident.name == sym!(NAN) {\n                 span_lint(\n                     cx,\n                     CMP_NAN,\n@@ -497,15 +496,15 @@ fn is_float(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n     let (arg_ty, snip) = match expr.node {\n         ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n-            if match_trait_method(cx, expr, &*paths::TO_STRING) || match_trait_method(cx, expr, &*paths::TO_OWNED) {\n+            if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n                 (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.node {\n-                if match_qpath(path, &[*sym::String, *sym::from_str]) || match_qpath(path, &[*sym::String, *sym::from])\n+                if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"])\n                 {\n                     (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {"}, {"sha": "8cf08e3683b8e989464d4d9bedee1a97029a1496", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -5,7 +5,6 @@\n // [`missing_doc`]: https://github.com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.rs#L246\n //\n \n-use crate::utils::sym;\n use crate::utils::{in_macro_or_desugar, span_lint};\n use if_chain::if_chain;\n use rustc::hir;\n@@ -92,7 +91,7 @@ impl MissingDoc {\n \n         let has_doc = attrs\n             .iter()\n-            .any(|a| a.check_name(*sym::doc) && (a.is_value_str() || Self::has_include(a.meta())));\n+            .any(|a| a.check_name(sym!(doc)) && (a.is_value_str() || Self::has_include(a.meta())));\n         if !has_doc {\n             span_lint(\n                 cx,\n@@ -110,10 +109,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n-                attr.check_name(*sym::doc)\n+                attr.check_name(sym!(doc))\n                     && match attr.meta_item_list() {\n                         None => false,\n-                        Some(l) => attr::list_contains_name(&l[..], *sym::hidden),\n+                        Some(l) => attr::list_contains_name(&l[..], sym!(hidden)),\n                     }\n             });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -133,7 +132,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Enum(..) => \"an enum\",\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n-                if it.ident.name == *sym::main {\n+                if it.ident.name == sym!(main) {\n                     let def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n                     let def_key = cx.tcx.hir().def_key(def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {"}, {"sha": "8de0d02c61b8c839ff949e91ae781ea598564010", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,5 +1,4 @@\n use crate::utils::span_lint;\n-use crate::utils::sym;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n@@ -58,7 +57,7 @@ declare_clippy_lint! {\n }\n \n fn check_missing_inline_attrs(cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n-    let has_inline = attrs.iter().any(|a| a.check_name(*sym::inline));\n+    let has_inline = attrs.iter().any(|a| a.check_name(sym!(inline)));\n     if !has_inline {\n         span_lint(\n             cx,"}, {"sha": "3b9641b354f2a1d041aeca1254d0ff38b462a1c6", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Mutex {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let ty = cx.tables.expr_ty(expr);\n         if let ty::Adt(_, subst) = ty.sty {\n-            if match_type(cx, ty, &*paths::MUTEX) {\n+            if match_type(cx, ty, &paths::MUTEX) {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!("}, {"sha": "b15f836bb1ee5bd722c52bc95dd1afbdf1a1204c", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -2,7 +2,6 @@\n //!\n //! This lint is **warn** by default\n \n-use crate::utils::sym;\n use crate::utils::{in_macro_or_desugar, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n use rustc::hir::{BindingAnnotation, Expr, ExprKind, HirId, Item, MutImmutable, Pat, PatKind};\n@@ -109,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n     }\n \n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if item.attrs.iter().any(|a| a.check_name(*sym::automatically_derived)) {\n+        if item.attrs.iter().any(|a| a.check_name(sym!(automatically_derived))) {\n             debug_assert!(self.derived_item.is_none());\n             self.derived_item = Some(item.hir_id);\n         }"}, {"sha": "0741fd52f4f8df0bf738d6501603553cdd7bc54b", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,5 +1,4 @@\n use crate::utils::ptr::get_spans;\n-use crate::utils::sym;\n use crate::utils::{\n     get_trait_def_id, implements_trait, in_macro_or_desugar, is_copy, is_self, match_type, multispan_sugg, paths,\n     snippet, snippet_opt, span_lint_and_then,\n@@ -102,12 +101,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         }\n \n         // Allow `Borrow` or functions to be taken by value\n-        let borrow_trait = need!(get_trait_def_id(cx, &*paths::BORROW_TRAIT));\n+        let borrow_trait = need!(get_trait_def_id(cx, &paths::BORROW_TRAIT));\n         let whitelisted_traits = [\n             need!(cx.tcx.lang_items().fn_trait()),\n             need!(cx.tcx.lang_items().fn_once_trait()),\n             need!(cx.tcx.lang_items().fn_mut_trait()),\n-            need!(get_trait_def_id(cx, &*paths::RANGE_ARGUMENT_TRAIT)),\n+            need!(get_trait_def_id(cx, &paths::RANGE_ARGUMENT_TRAIT)),\n         ];\n \n         let sized_trait = need!(cx.tcx.lang_items().sized_trait());\n@@ -215,12 +214,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n                         let deref_span = spans_need_deref.get(&canonical_id);\n                         if_chain! {\n-                            if match_type(cx, ty, &*paths::VEC);\n+                            if match_type(cx, ty, &paths::VEC);\n                             if let Some(clone_spans) =\n-                                get_spans(cx, Some(body.id()), idx, &[(*sym::clone, \".to_owned()\")]);\n+                                get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n                             if let TyKind::Path(QPath::Resolved(_, ref path)) = input.node;\n                             if let Some(elem_ty) = path.segments.iter()\n-                                .find(|seg| seg.ident.name == *sym::Vec)\n+                                .find(|seg| seg.ident.name == sym!(Vec))\n                                 .and_then(|ps| ps.args.as_ref())\n                                 .map(|params| params.args.iter().find_map(|arg| match arg {\n                                     GenericArg::Type(ty) => Some(ty),\n@@ -254,9 +253,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                             }\n                         }\n \n-                        if match_type(cx, ty, &*paths::STRING) {\n+                        if match_type(cx, ty, &paths::STRING) {\n                             if let Some(clone_spans) =\n-                                get_spans(cx, Some(body.id()), idx, &[(*sym::clone, \".to_string()\"), (*sym::as_str, \"\")]) {\n+                                get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n                                 db.span_suggestion(\n                                     input.span,\n                                     \"consider changing the type to\",\n@@ -313,7 +312,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n /// Functions marked with these attributes must have the exact signature.\n fn requires_exact_signature(attrs: &[Attribute]) -> bool {\n     attrs.iter().any(|attr| {\n-        [*sym::proc_macro, *sym::proc_macro_attribute, *sym::proc_macro_derive]\n+        [sym!(proc_macro), sym!(proc_macro_attribute), sym!(proc_macro_derive)]\n             .iter()\n             .any(|&allow| attr.check_name(allow))\n     })"}, {"sha": "e05a953b306084cef03d06c125d1e93df34dfdbe", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -58,15 +58,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n                 let ty = cx.tables.expr_ty(left);\n \n                 let implements_ord = {\n-                    if let Some(id) = utils::get_trait_def_id(cx, &*paths::ORD) {\n+                    if let Some(id) = utils::get_trait_def_id(cx, &paths::ORD) {\n                         utils::implements_trait(cx, ty, id, &[])\n                     } else {\n                         return;\n                     }\n                 };\n \n                 let implements_partial_ord = {\n-                    if let Some(id) = utils::get_trait_def_id(cx, &*paths::PARTIAL_ORD) {\n+                    if let Some(id) = utils::get_trait_def_id(cx, &paths::PARTIAL_ORD) {\n                         utils::implements_trait(cx, ty, id, &[])\n                     } else {\n                         return;"}, {"sha": "e325f0e70fde45ee121e0ed0a27511bdc59debb6", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,6 +1,5 @@\n use crate::utils::paths;\n use crate::utils::sugg::DiagnosticBuilderExt;\n-use crate::utils::sym;\n use crate::utils::{get_trait_def_id, implements_trait, return_ty, same_tys, span_lint_hir_and_then};\n use if_chain::if_chain;\n use rustc::hir;\n@@ -121,12 +120,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             // impl of `Default`\n                             return;\n                         }\n-                        if sig.decl.inputs.is_empty() && name == *sym::new && cx.access_levels.is_reachable(id) {\n+                        if sig.decl.inputs.is_empty() && name == sym!(new) && cx.access_levels.is_reachable(id) {\n                             let self_did = cx.tcx.hir().local_def_id_from_hir_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_did);\n                             if_chain! {\n                                 if same_tys(cx, self_ty, return_ty(cx, id));\n-                                if let Some(default_trait_id) = get_trait_def_id(cx, &*paths::DEFAULT_TRAIT);\n+                                if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n                                 then {\n                                     if self.impling_types.is_none() {\n                                         let mut impls = NodeSet::default();"}, {"sha": "c2e4805fa7bbcf1138ec9e13fae0bea0e078062c", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{span_lint, span_lint_and_then};\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, impl_lint_pass};\n@@ -356,7 +355,7 @@ impl EarlyLintPass for NonExpressiveNames {\n }\n \n fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext<'_>, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n-    if !attr::contains_name(attrs, *sym::test) {\n+    if !attr::contains_name(attrs, sym!(test)) {\n         let mut visitor = SimilarNamesLocalVisitor {\n             names: Vec::new(),\n             cx,"}, {"sha": "01d41f679dbb35db173bf37d4f306ee3812053ec", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{match_type, method_chain_args, paths, snippet, span_help_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n@@ -44,10 +43,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n             if let MatchSource::IfLetDesugar { .. } = *source; //test if it is an If Let\n             if let ExprKind::MethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node; //get operation\n-            if method_chain_args(op, &[*sym::ok]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n+            if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n \n             then {\n-                let is_result_type = match_type(cx, cx.tables.expr_ty(&result_types[0]), &*paths::RESULT);\n+                let is_result_type = match_type(cx, cx.tables.expr_ty(&result_types[0]), &paths::RESULT);\n                 let some_expr_string = snippet(cx, y[0].span, \"\");\n                 if print::to_string(print::NO_ANN, |s| s.print_path(x, false)) == \"Some\" && is_result_type {\n                     span_help_and_lint(cx, IF_LET_SOME_RESULT, expr.span,"}, {"sha": "e115769abe8c45f29e9868d41c3dab460fe5d25b", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{match_type, paths, span_lint, walk_ptrs_ty};\n use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -32,7 +31,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprKind::MethodCall(ref path, _, ref arguments) = e.node {\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n-            if path.ident.name == *sym::open && match_type(cx, obj_ty, &*paths::OPEN_OPTIONS) {\n+            if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);\n@@ -62,7 +61,7 @@ fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr, options: &mut Vec\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n-        if match_type(cx, obj_ty, &*paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n+        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n             let argument_option = match arguments[1].node {\n                 ExprKind::Lit(ref span) => {\n                     if let Spanned {"}, {"sha": "1030efafb865c6d20a501dc7f18a3225d2148f41", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, paths, resolve_node, span_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n@@ -53,10 +52,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PanicUnimplemented {\n             if let ExprKind::Call(ref fun, ref params) = ex.node;\n             if let ExprKind::Path(ref qpath) = fun.node;\n             if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-            if match_def_path(cx, fun_def_id, &*paths::BEGIN_PANIC);\n+            if match_def_path(cx, fun_def_id, &paths::BEGIN_PANIC);\n             if params.len() == 2;\n             then {\n-                if is_expn_of(expr.span, *sym::unimplemented).is_some() {\n+                if is_expn_of(expr.span, \"unimplemented\").is_some() {\n                     let span = get_outer_span(expr);\n                     span_lint(cx, UNIMPLEMENTED, span,\n                               \"`unimplemented` should not be present in production code\");\n@@ -83,7 +82,7 @@ fn get_outer_span(expr: &Expr) -> Span {\n fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext<'_, '_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = params[0].node;\n-        if is_direct_expn_of(expr.span, *sym::panic).is_some();\n+        if is_direct_expn_of(expr.span, \"panic\").is_some();\n         if let LitKind::Str(ref string, _) = lit.node;\n         let string = string.as_str().replace(\"{{\", \"\").replace(\"}}\", \"\");\n         if let Some(par) = string.find('{');"}, {"sha": "1091ed0d6de9cea7bd1e30ec03e7c102c303d541", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{is_automatically_derived, span_lint_hir};\n use if_chain::if_chain;\n use rustc::hir::*;\n@@ -40,7 +39,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PartialEqNeImpl {\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {\n                 for impl_item in impl_items {\n-                    if impl_item.ident.name == *sym::ne {\n+                    if impl_item.ident.name == sym!(ne) {\n                         span_lint_hir(\n                             cx,\n                             PARTIALEQ_NE_IMPL,"}, {"sha": "8ebb5150ab473a63a6e4af6402bcb32e12843177", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::sym;\n use crate::utils::{match_type, paths, span_lint_and_sugg, walk_ptrs_ty};\n use if_chain::if_chain;\n use rustc::hir::*;\n@@ -45,9 +44,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathBufPushOverwrite {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n-            if path.ident.name == *sym::push;\n+            if path.ident.name == sym!(push);\n             if args.len() == 2;\n-            if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &*paths::PATH_BUF);\n+            if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::PATH_BUF);\n             if let Some(get_index_arg) = args.get(1);\n             if let ExprKind::Lit(ref lit) = get_index_arg.node;\n             if let LitKind::Str(ref path_lit, _) = lit.node;"}, {"sha": "e3ea27d0f5040eb0fe2e2777a499a0c0c43f2950", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,7 +1,6 @@\n //! Checks for usage of  `&Vec[_]` and `&String`.\n \n use crate::utils::ptr::get_spans;\n-use crate::utils::sym;\n use crate::utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then, walk_ptrs_hir_ty};\n use if_chain::if_chain;\n use rustc::hir::QPath;\n@@ -149,7 +148,7 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id:\n \n     for (idx, (arg, ty)) in decl.inputs.iter().zip(fn_ty.inputs()).enumerate() {\n         if let ty::Ref(_, ty, MutImmutable) = ty.sty {\n-            if match_type(cx, ty, &*paths::VEC) {\n+            if match_type(cx, ty, &paths::VEC) {\n                 let mut ty_snippet = None;\n                 if_chain! {\n                     if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n@@ -164,7 +163,7 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id:\n                         }\n                     }\n                 };\n-                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(*sym::clone, \".to_owned()\")]) {\n+                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n                     span_lint_and_then(\n                         cx,\n                         PTR_ARG,\n@@ -193,12 +192,12 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id:\n                         },\n                     );\n                 }\n-            } else if match_type(cx, ty, &*paths::STRING) {\n+            } else if match_type(cx, ty, &paths::STRING) {\n                 if let Some(spans) = get_spans(\n                     cx,\n                     opt_body_id,\n                     idx,\n-                    &[(*sym::clone, \".to_string()\"), (*sym::as_str, \"\")],\n+                    &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")],\n                 ) {\n                     span_lint_and_then(\n                         cx,\n@@ -220,7 +219,7 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id:\n                         },\n                     );\n                 }\n-            } else if match_type(cx, ty, &*paths::COW) {\n+            } else if match_type(cx, ty, &paths::COW) {\n                 if_chain! {\n                     if let TyKind::Rptr(_, MutTy { ref ty, ..} ) = arg.node;\n                     if let TyKind::Path(ref path) = ty.node;\n@@ -299,7 +298,7 @@ fn is_null_path(expr: &Expr) -> bool {\n     if let ExprKind::Call(ref pathexp, ref args) = expr.node {\n         if args.is_empty() {\n             if let ExprKind::Path(ref path) = pathexp.node {\n-                return match_qpath(path, &*paths::PTR_NULL) || match_qpath(path, &*paths::PTR_NULL_MUT);\n+                return match_qpath(path, &paths::PTR_NULL) || match_qpath(path, &paths::PTR_NULL_MUT);\n             }\n         }\n     }"}, {"sha": "152140c856bc7843b0a4a71a5dad565ccc4743cc", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,5 +1,4 @@\n use crate::utils;\n-use crate::utils::sym;\n use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n@@ -93,10 +92,10 @@ fn expr_as_ptr_offset_call<'a, 'tcx>(\n ) -> Option<(&'tcx Expr, &'tcx Expr, Method)> {\n     if let ExprKind::MethodCall(ref path_segment, _, ref args) = expr.node {\n         if is_expr_ty_raw_ptr(cx, &args[0]) {\n-            if path_segment.ident.name == *sym::offset {\n+            if path_segment.ident.name == sym!(offset) {\n                 return Some((&args[0], &args[1], Method::Offset));\n             }\n-            if path_segment.ident.name == *sym::wrapping_offset {\n+            if path_segment.ident.name == sym!(wrapping_offset) {\n                 return Some((&args[0], &args[1], Method::WrappingOffset));\n             }\n         }"}, {"sha": "da038800c2d8310c882ba276f197d625de00673b", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -8,7 +8,6 @@ use syntax::ptr::P;\n \n use crate::utils::paths::*;\n use crate::utils::sugg::Sugg;\n-use crate::utils::sym;\n use crate::utils::{higher, match_def_path, match_type, span_lint_and_then, SpanlessEq};\n \n declare_clippy_lint! {\n@@ -51,7 +50,7 @@ impl QuestionMark {\n         if_chain! {\n             if let Some((if_expr, body, else_)) = higher::if_block(&expr);\n             if let ExprKind::MethodCall(segment, _, args) = &if_expr.node;\n-            if segment.ident.name == *sym::is_none;\n+            if segment.ident.name == sym!(is_none);\n             if Self::expression_returns_none(cx, body);\n             if let Some(subject) = args.get(0);\n             if Self::is_option(cx, subject);\n@@ -104,7 +103,7 @@ impl QuestionMark {\n     fn is_option(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n-        match_type(cx, expr_ty, &*OPTION)\n+        match_type(cx, expr_ty, &OPTION)\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n@@ -121,7 +120,7 @@ impl QuestionMark {\n                 if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n                     cx.tables.qpath_res(qp, expression.hir_id)\n                 {\n-                    return match_def_path(cx, def_id, &*OPTION_NONE);\n+                    return match_def_path(cx, def_id, &OPTION_NONE);\n                 }\n \n                 false"}, {"sha": "cd4e27110b3cbecbe58268e22cafcca084b14418", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -7,7 +7,6 @@ use syntax::ast::RangeLimits;\n use syntax::source_map::Spanned;\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::sym;\n use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n use crate::utils::{is_integer_literal, paths, snippet, snippet_opt, span_lint, span_lint_and_then};\n \n@@ -116,13 +115,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n                 if_chain! {\n                     // `.iter()` call\n                     if let ExprKind::MethodCall(ref iter_path, _, ref iter_args ) = *iter;\n-                    if iter_path.ident.name == *sym::iter;\n+                    if iter_path.ident.name == sym!(iter);\n                     // range expression in `.zip()` call: `0..x.len()`\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_literal(start, 0);\n                     // `.len()` call\n                     if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.node;\n-                    if len_path.ident.name == *sym::len && len_args.len() == 1;\n+                    if len_path.ident.name == sym!(len) && len_args.len() == 1;\n                     // `.iter()` and `.len()` called on same `Path`\n                     if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n                     if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n@@ -213,7 +212,7 @@ fn has_step_by(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     // can't be called on a borrowed range.\n     let ty = cx.tables.expr_ty_adjusted(expr);\n \n-    get_trait_def_id(cx, &*paths::ITERATOR)\n+    get_trait_def_id(cx, &paths::ITERATOR)\n         .map_or(false, |iterator_trait| implements_trait(cx, ty, iterator_trait, &[]))\n }\n "}, {"sha": "80b9a94d7e407cdb24390662e5ccbd3ced784904", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -94,14 +94,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n \n             let (fn_def_id, arg, arg_ty, _) = unwrap_or_continue!(is_call_with_ref_arg(cx, mir, &terminator.kind));\n \n-            let from_borrow = match_def_path(cx, fn_def_id, &*paths::CLONE_TRAIT_METHOD)\n-                || match_def_path(cx, fn_def_id, &*paths::TO_OWNED_METHOD)\n-                || (match_def_path(cx, fn_def_id, &*paths::TO_STRING_METHOD)\n-                    && match_type(cx, arg_ty, &*paths::STRING));\n+            let from_borrow = match_def_path(cx, fn_def_id, &paths::CLONE_TRAIT_METHOD)\n+                || match_def_path(cx, fn_def_id, &paths::TO_OWNED_METHOD)\n+                || (match_def_path(cx, fn_def_id, &paths::TO_STRING_METHOD)\n+                    && match_type(cx, arg_ty, &paths::STRING));\n \n             let from_deref = !from_borrow\n-                && (match_def_path(cx, fn_def_id, &*paths::PATH_TO_PATH_BUF)\n-                    || match_def_path(cx, fn_def_id, &*paths::OS_STR_TO_OS_STRING));\n+                && (match_def_path(cx, fn_def_id, &paths::PATH_TO_PATH_BUF)\n+                    || match_def_path(cx, fn_def_id, &paths::OS_STR_TO_OS_STRING));\n \n             if !from_borrow && !from_deref {\n                 continue;\n@@ -134,9 +134,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                     if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, Some(res))) =\n                         is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n                     if *res == mir::Place::Base(mir::PlaceBase::Local(cloned));\n-                    if match_def_path(cx, pred_fn_def_id, &*paths::DEREF_TRAIT_METHOD);\n-                    if match_type(cx, pred_arg_ty, &*paths::PATH_BUF)\n-                        || match_type(cx, pred_arg_ty, &*paths::OS_STRING);\n+                    if match_def_path(cx, pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n+                    if match_type(cx, pred_arg_ty, &paths::PATH_BUF)\n+                        || match_type(cx, pred_arg_ty, &paths::OS_STRING);\n                     then {\n                         pred_arg\n                     } else {"}, {"sha": "fe1a29b98833c92d9e983363d4a89f9f0ec538f4", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -5,7 +5,6 @@ use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Lint for redundant pattern matching over `Result` or\n@@ -62,11 +61,11 @@ fn find_sugg_for_if_let<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr,\n         let good_method = match arms[0].pats[0].node {\n             PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n                 if let PatKind::Wild = patterns[0].node {\n-                    if match_qpath(path, &*paths::RESULT_OK) {\n+                    if match_qpath(path, &paths::RESULT_OK) {\n                         \"is_ok()\"\n-                    } else if match_qpath(path, &*paths::RESULT_ERR) {\n+                    } else if match_qpath(path, &paths::RESULT_ERR) {\n                         \"is_err()\"\n-                    } else if match_qpath(path, &*paths::OPTION_SOME) {\n+                    } else if match_qpath(path, &paths::OPTION_SOME) {\n                         \"is_some()\"\n                     } else {\n                         return;\n@@ -76,7 +75,7 @@ fn find_sugg_for_if_let<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr,\n                 }\n             },\n \n-            PatKind::Path(ref path) if match_qpath(path, &*paths::OPTION_NONE) => \"is_none()\",\n+            PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => \"is_none()\",\n \n             _ => return,\n         };\n@@ -115,8 +114,8 @@ fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, o\n                         arms,\n                         path_left,\n                         path_right,\n-                        &*paths::RESULT_OK,\n-                        &*paths::RESULT_ERR,\n+                        &paths::RESULT_OK,\n+                        &paths::RESULT_ERR,\n                         \"is_ok()\",\n                         \"is_err()\",\n                     )\n@@ -133,8 +132,8 @@ fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, o\n                         arms,\n                         path_left,\n                         path_right,\n-                        &*paths::OPTION_SOME,\n-                        &*paths::OPTION_NONE,\n+                        &paths::OPTION_SOME,\n+                        &paths::OPTION_NONE,\n                         \"is_some()\",\n                         \"is_none()\",\n                     )\n@@ -171,8 +170,8 @@ fn find_good_method_for_match<'a>(\n     arms: &HirVec<Arm>,\n     path_left: &QPath,\n     path_right: &QPath,\n-    expected_left: &[Symbol],\n-    expected_right: &[Symbol],\n+    expected_left: &[&str],\n+    expected_right: &[&str],\n     should_be_left: &'a str,\n     should_be_right: &'a str,\n ) -> Option<&'a str> {"}, {"sha": "95f5455d42708eb9692f29cb5d559d1083fd3d1c", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,5 +1,4 @@\n use crate::consts::{constant, Constant};\n-use crate::utils::sym;\n use crate::utils::{is_expn_of, match_def_path, match_type, paths, span_help_and_lint, span_lint};\n use if_chain::if_chain;\n use regex_syntax;\n@@ -84,8 +83,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n         if_chain! {\n             if self.last.is_none();\n             if let Some(ref expr) = block.expr;\n-            if match_type(cx, cx.tables.expr_ty(expr), &*paths::REGEX);\n-            if let Some(span) = is_expn_of(expr.span, *sym::regex);\n+            if match_type(cx, cx.tables.expr_ty(expr), &paths::REGEX);\n+            if let Some(span) = is_expn_of(expr.span, \"regex\");\n             then {\n                 if !self.spans.contains(&span) {\n                     span_lint(cx,\n@@ -113,15 +112,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n             if args.len() == 1;\n             if let Some(def_id) = cx.tables.qpath_res(qpath, fun.hir_id).opt_def_id();\n             then {\n-                if match_def_path(cx, def_id, &*paths::REGEX_NEW) ||\n-                   match_def_path(cx, def_id, &*paths::REGEX_BUILDER_NEW) {\n+                if match_def_path(cx, def_id, &paths::REGEX_NEW) ||\n+                   match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {\n                     check_regex(cx, &args[0], true);\n-                } else if match_def_path(cx, def_id, &*paths::REGEX_BYTES_NEW) ||\n-                   match_def_path(cx, def_id, &*paths::REGEX_BYTES_BUILDER_NEW) {\n+                } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_NEW) ||\n+                   match_def_path(cx, def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n                     check_regex(cx, &args[0], false);\n-                } else if match_def_path(cx, def_id, &*paths::REGEX_SET_NEW) {\n+                } else if match_def_path(cx, def_id, &paths::REGEX_SET_NEW) {\n                     check_set(cx, &args[0], true);\n-                } else if match_def_path(cx, def_id, &*paths::REGEX_BYTES_SET_NEW) {\n+                } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_SET_NEW) {\n                     check_set(cx, &args[0], false);\n                 }\n             }"}, {"sha": "7f1303d5beeffa5c23393ce22d7094b020e437aa", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,13 +1,10 @@\n-use crate::utils::sym;\n use crate::utils::{match_def_path, span_lint_and_sugg};\n use if_chain::if_chain;\n-use lazy_static::lazy_static;\n use rustc::hir;\n use rustc::hir::def::{DefKind, Res};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n-use syntax::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `ATOMIC_X_INIT`, `ONCE_INIT`, and\n@@ -59,35 +56,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n     }\n }\n \n-lazy_static! {\n-static ref REPLACEMENTS: [([Symbol; 3], &'static str); 25] = [\n+const REPLACEMENTS: [([&str; 3], &'static str); 25] = [\n     // Once\n-    ([*sym::core, *sym::sync, *sym::ONCE_INIT], \"Once::new()\"),\n+    ([\"core\", \"sync\", \"ONCE_INIT\"], \"Once::new()\"),\n     // Min\n-    ([*sym::core, *sym::isize, *sym::MIN], \"isize::min_value()\"),\n-    ([*sym::core, *sym::i8, *sym::MIN], \"i8::min_value()\"),\n-    ([*sym::core, *sym::i16, *sym::MIN], \"i16::min_value()\"),\n-    ([*sym::core, *sym::i32, *sym::MIN], \"i32::min_value()\"),\n-    ([*sym::core, *sym::i64, *sym::MIN], \"i64::min_value()\"),\n-    ([*sym::core, *sym::i128, *sym::MIN], \"i128::min_value()\"),\n-    ([*sym::core, *sym::usize, *sym::MIN], \"usize::min_value()\"),\n-    ([*sym::core, *sym::u8, *sym::MIN], \"u8::min_value()\"),\n-    ([*sym::core, *sym::u16, *sym::MIN], \"u16::min_value()\"),\n-    ([*sym::core, *sym::u32, *sym::MIN], \"u32::min_value()\"),\n-    ([*sym::core, *sym::u64, *sym::MIN], \"u64::min_value()\"),\n-    ([*sym::core, *sym::u128, *sym::MIN], \"u128::min_value()\"),\n+    ([\"core\", \"isize\", \"MIN\"], \"isize::min_value()\"),\n+    ([\"core\", \"i8\", \"MIN\"], \"i8::min_value()\"),\n+    ([\"core\", \"i16\", \"MIN\"], \"i16::min_value()\"),\n+    ([\"core\", \"i32\", \"MIN\"], \"i32::min_value()\"),\n+    ([\"core\", \"i64\", \"MIN\"], \"i64::min_value()\"),\n+    ([\"core\", \"i128\", \"MIN\"], \"i128::min_value()\"),\n+    ([\"core\", \"usize\", \"MIN\"], \"usize::min_value()\"),\n+    ([\"core\", \"u8\", \"MIN\"], \"u8::min_value()\"),\n+    ([\"core\", \"u16\", \"MIN\"], \"u16::min_value()\"),\n+    ([\"core\", \"u32\", \"MIN\"], \"u32::min_value()\"),\n+    ([\"core\", \"u64\", \"MIN\"], \"u64::min_value()\"),\n+    ([\"core\", \"u128\", \"MIN\"], \"u128::min_value()\"),\n     // Max\n-    ([*sym::core, *sym::isize, *sym::MAX], \"isize::max_value()\"),\n-    ([*sym::core, *sym::i8, *sym::MAX], \"i8::max_value()\"),\n-    ([*sym::core, *sym::i16, *sym::MAX], \"i16::max_value()\"),\n-    ([*sym::core, *sym::i32, *sym::MAX], \"i32::max_value()\"),\n-    ([*sym::core, *sym::i64, *sym::MAX], \"i64::max_value()\"),\n-    ([*sym::core, *sym::i128, *sym::MAX], \"i128::max_value()\"),\n-    ([*sym::core, *sym::usize, *sym::MAX], \"usize::max_value()\"),\n-    ([*sym::core, *sym::u8, *sym::MAX], \"u8::max_value()\"),\n-    ([*sym::core, *sym::u16, *sym::MAX], \"u16::max_value()\"),\n-    ([*sym::core, *sym::u32, *sym::MAX], \"u32::max_value()\"),\n-    ([*sym::core, *sym::u64, *sym::MAX], \"u64::max_value()\"),\n-    ([*sym::core, *sym::u128, *sym::MAX], \"u128::max_value()\"),\n+    ([\"core\", \"isize\", \"MAX\"], \"isize::max_value()\"),\n+    ([\"core\", \"i8\", \"MAX\"], \"i8::max_value()\"),\n+    ([\"core\", \"i16\", \"MAX\"], \"i16::max_value()\"),\n+    ([\"core\", \"i32\", \"MAX\"], \"i32::max_value()\"),\n+    ([\"core\", \"i64\", \"MAX\"], \"i64::max_value()\"),\n+    ([\"core\", \"i128\", \"MAX\"], \"i128::max_value()\"),\n+    ([\"core\", \"usize\", \"MAX\"], \"usize::max_value()\"),\n+    ([\"core\", \"u8\", \"MAX\"], \"u8::max_value()\"),\n+    ([\"core\", \"u16\", \"MAX\"], \"u16::max_value()\"),\n+    ([\"core\", \"u32\", \"MAX\"], \"u32::max_value()\"),\n+    ([\"core\", \"u64\", \"MAX\"], \"u64::max_value()\"),\n+    ([\"core\", \"u128\", \"MAX\"], \"u128::max_value()\"),\n ];\n-}"}, {"sha": "d53a64c98f25c4b9502772216d96a08274572f02", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -7,7 +7,6 @@ use syntax::source_map::Span;\n use syntax::visit::FnKind;\n use syntax_pos::BytePos;\n \n-use crate::utils::sym;\n use crate::utils::{in_macro_or_desugar, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n \n declare_clippy_lint! {\n@@ -162,7 +161,7 @@ impl Return {\n             if let Some(ref initexpr) = local.init;\n             if let ast::PatKind::Ident(_, ident, _) = local.pat.node;\n             if let ast::ExprKind::Path(_, ref path) = retexpr.node;\n-            if match_path_ast(path, &[ident.name]);\n+            if match_path_ast(path, &[&*ident.name.as_str()]);\n             if !in_external_macro(cx.sess(), initexpr.span);\n             then {\n                     span_note_and_lint(cx,\n@@ -253,7 +252,7 @@ impl EarlyLintPass for Return {\n }\n \n fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.check_name(*sym::cfg)\n+    attr.meta_item_list().is_some() && attr.check_name(sym!(cfg))\n }\n \n // get the def site"}, {"sha": "bb4ebf63066b3e20ee520c7fd93e72d6e4fddf6c", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SerdeAPI {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref items) = item.node {\n             let did = trait_ref.path.res.def_id();\n-            if let Some(visit_did) = get_trait_def_id(cx, &*paths::SERDE_DE_VISITOR) {\n+            if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {\n                 if did == visit_did {\n                     let mut seen_str = None;\n                     let mut seen_string = None;"}, {"sha": "4e434351eb0264a7fd5e829fb1fd045b904667cc", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,5 +1,4 @@\n use crate::utils::sugg::Sugg;\n-use crate::utils::sym;\n use crate::utils::{get_enclosing_block, match_qpath, span_lint_and_then, SpanlessEq};\n use if_chain::if_chain;\n use rustc::hir::intravisit::{walk_block, walk_expr, walk_stmt, NestedVisitorMap, Visitor};\n@@ -110,7 +109,7 @@ impl SlowVectorInit {\n         if_chain! {\n             if let ExprKind::Call(ref func, ref args) = expr.node;\n             if let ExprKind::Path(ref path) = func.node;\n-            if match_qpath(path, &[*sym::Vec, *sym::with_capacity]);\n+            if match_qpath(path, &[\"Vec\", \"with_capacity\"]);\n             if args.len() == 1;\n \n             then {\n@@ -201,8 +200,8 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n             if self.initialization_found;\n             if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n             if let ExprKind::Path(ref qpath_subj) = args[0].node;\n-            if match_qpath(&qpath_subj, &[self.vec_alloc.variable_name]);\n-            if path.ident.name == *sym::extend;\n+            if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if path.ident.name == sym!(extend);\n             if let Some(ref extend_arg) = args.get(1);\n             if self.is_repeat_take(extend_arg);\n \n@@ -218,8 +217,8 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n             if self.initialization_found;\n             if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n             if let ExprKind::Path(ref qpath_subj) = args[0].node;\n-            if match_qpath(&qpath_subj, &[self.vec_alloc.variable_name]);\n-            if path.ident.name == *sym::resize;\n+            if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if path.ident.name == sym!(resize);\n             if let (Some(ref len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n \n             // Check that is filled with 0\n@@ -239,7 +238,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn is_repeat_take(&self, expr: &Expr) -> bool {\n         if_chain! {\n             if let ExprKind::MethodCall(ref take_path, _, ref take_args) = expr.node;\n-            if take_path.ident.name == *sym::take;\n+            if take_path.ident.name == sym!(take);\n \n             // Check that take is applied to `repeat(0)`\n             if let Some(ref repeat_expr) = take_args.get(0);\n@@ -262,7 +261,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n         if_chain! {\n             if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.node;\n             if let ExprKind::Path(ref qpath_repeat) = fn_expr.node;\n-            if match_qpath(&qpath_repeat, &[*sym::repeat]);\n+            if match_qpath(&qpath_repeat, &[\"repeat\"]);\n             if let Some(ref repeat_arg) = repeat_args.get(0);\n             if let ExprKind::Lit(ref lit) = repeat_arg.node;\n             if let LitKind::Int(0, _) = lit.node;"}, {"sha": "eae464ee2498be648f4c3a8f86b338e27e0c78db", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -4,7 +4,6 @@ use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::source_map::Spanned;\n \n-use crate::utils::sym;\n use crate::utils::SpanlessEq;\n use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n \n@@ -120,7 +119,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n-    match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(e)), &*paths::STRING)\n+    match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(e)), &paths::STRING)\n }\n \n fn is_add(cx: &LateContext<'_, '_>, src: &Expr, target: &Expr) -> bool {\n@@ -147,7 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use syntax::ast::{LitKind, StrStyle};\n \n         if let ExprKind::MethodCall(ref path, _, ref args) = e.node {\n-            if path.ident.name == *sym::as_bytes {\n+            if path.ident.name == sym!(as_bytes) {\n                 if let ExprKind::Lit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, style) = lit.node {\n                         let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);"}, {"sha": "fbce50f9ef84d98e75377538ce6902c93b2fcdc5", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,11 +1,9 @@\n-use crate::utils::sym;\n use crate::utils::{get_trait_def_id, span_lint, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n-use syntax::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Lints for suspicious operations in impls of arithmetic operators, e.g.\n@@ -91,7 +89,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                 cx,\n                 expr,\n                 binop.node,\n-                &[*sym::Add, *sym::Sub, *sym::Mul, *sym::Div],\n+                &[\"Add\", \"Sub\", \"Mul\", \"Div\"],\n                 &[\n                     hir::BinOpKind::Add,\n                     hir::BinOpKind::Sub,\n@@ -112,16 +110,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                 expr,\n                 binop.node,\n                 &[\n-                    *sym::AddAssign,\n-                    *sym::SubAssign,\n-                    *sym::MulAssign,\n-                    *sym::DivAssign,\n-                    *sym::BitAndAssign,\n-                    *sym::BitOrAssign,\n-                    *sym::BitXorAssign,\n-                    *sym::RemAssign,\n-                    *sym::ShlAssign,\n-                    *sym::ShrAssign,\n+                    \"AddAssign\",\n+                    \"SubAssign\",\n+                    \"MulAssign\",\n+                    \"DivAssign\",\n+                    \"BitAndAssign\",\n+                    \"BitOrAssign\",\n+                    \"BitXorAssign\",\n+                    \"RemAssign\",\n+                    \"ShlAssign\",\n+                    \"ShrAssign\",\n                 ],\n                 &[\n                     hir::BinOpKind::Add,\n@@ -151,11 +149,11 @@ fn check_binop(\n     cx: &LateContext<'_, '_>,\n     expr: &hir::Expr,\n     binop: hir::BinOpKind,\n-    traits: &[Symbol],\n+    traits: &[&'static str],\n     expected_ops: &[hir::BinOpKind],\n-) -> Option<Symbol> {\n+) -> Option<&'static str> {\n     let mut trait_ids = vec![];\n-    let [krate, module] = *crate::utils::paths::OPS_MODULE;\n+    let [krate, module] = crate::utils::paths::OPS_MODULE;\n \n     for &t in traits {\n         let path = [krate, module, t];"}, {"sha": "fc5b2150d52cf9bbca56a846d15fa20ee1e2ead0", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -96,8 +96,8 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n \n                                 if matches!(ty.sty, ty::Slice(_)) ||\n                                     matches!(ty.sty, ty::Array(_, _)) ||\n-                                    match_type(cx, ty, &*paths::VEC) ||\n-                                    match_type(cx, ty, &*paths::VEC_DEQUE) {\n+                                    match_type(cx, ty, &paths::VEC) ||\n+                                    match_type(cx, ty, &paths::VEC_DEQUE) {\n                                         return Some((lhs1, idx1, idx2));\n                                 }\n                             }"}, {"sha": "e2534dae09bc1bb224350c46c2fc8d51772fbf7e", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n         if let ExprKind::Call(ref path_expr, ref args) = e.node {\n             if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if match_def_path(cx, def_id, &*paths::TRANSMUTE) {\n+                    if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n                         let from_ty = cx.tables.expr_ty(&args[0]);\n                         let to_ty = cx.tables.expr_ty(e);\n "}, {"sha": "9390b643592d3087ed7c220f9d6bee0c50e216c0", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n         if_chain! {\n             if let ExprKind::Call(ref func, ref args) = expr.node;\n             if let ExprKind::Path(ref path) = func.node;\n-            if match_qpath(path, &*paths::STD_MEM_TRANSMUTE);\n+            if match_qpath(path, &paths::STD_MEM_TRANSMUTE);\n             if args.len() == 1;\n \n             then {\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n                 if_chain! {\n                     if let ExprKind::Call(ref func1, ref args1) = args[0].node;\n                     if let ExprKind::Path(ref path1) = func1.node;\n-                    if match_qpath(path1, &*paths::STD_PTR_NULL);\n+                    if match_qpath(path1, &paths::STD_PTR_NULL);\n                     if args1.len() == 0;\n                     then {\n                         span_lint("}, {"sha": "9866540220d2d5959b73c536cc258b97ca845075", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,6 +1,5 @@\n use std::cmp;\n \n-use crate::utils::sym;\n use crate::utils::{in_macro_or_desugar, is_copy, is_self_ty, snippet, span_lint_and_sugg};\n use if_chain::if_chain;\n use matches::matches;\n@@ -169,7 +168,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n                     return;\n                 }\n                 for a in attrs {\n-                    if a.meta_item_list().is_some() && a.check_name(*sym::proc_macro_derive) {\n+                    if a.meta_item_list().is_some() && a.check_name(sym!(proc_macro_derive)) {\n                         return;\n                     }\n                 }"}, {"sha": "7bce42369dc8eb30f1bd6c01128e30a2336599a1", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -18,11 +18,9 @@ use rustc_typeck::hir_ty_to_ty;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::errors::DiagnosticBuilder;\n use syntax::source_map::Span;\n-use syntax::symbol::Symbol;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::sym;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro_or_desugar, int_bits, last_path_segment,\n     match_def_path, match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n@@ -208,7 +206,7 @@ fn check_fn_decl(cx: &LateContext<'_, '_>, decl: &FnDecl) {\n }\n \n /// Checks if `qpath` has last segment with type parameter matching `path`\n-fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[Symbol]) -> bool {\n+fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n     if_chain! {\n         if let Some(ref params) = last.args;\n@@ -243,7 +241,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n             let res = cx.tables.qpath_res(qpath, hir_id);\n             if let Some(def_id) = res.opt_def_id() {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n-                    if match_type_parameter(cx, qpath, &*paths::VEC) {\n+                    if match_type_parameter(cx, qpath, &paths::VEC) {\n                         span_help_and_lint(\n                             cx,\n                             BOX_VEC,\n@@ -253,7 +251,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                         );\n                         return; // don't recurse into the type\n                     }\n-                } else if match_def_path(cx, def_id, &*paths::VEC) {\n+                } else if match_def_path(cx, def_id, &paths::VEC) {\n                     if_chain! {\n                         // Get the _ part of Vec<_>\n                         if let Some(ref last) = last_path_segment(qpath).args;\n@@ -288,8 +286,8 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                             }\n                         }\n                     }\n-                } else if match_def_path(cx, def_id, &*paths::OPTION) {\n-                    if match_type_parameter(cx, qpath, &*paths::OPTION) {\n+                } else if match_def_path(cx, def_id, &paths::OPTION) {\n+                    if match_type_parameter(cx, qpath, &paths::OPTION) {\n                         span_lint(\n                             cx,\n                             OPTION_OPTION,\n@@ -299,7 +297,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                         );\n                         return; // don't recurse into the type\n                     }\n-                } else if match_def_path(cx, def_id, &*paths::LINKED_LIST) {\n+                } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint(\n                         cx,\n                         LINKEDLIST,\n@@ -428,7 +426,7 @@ fn is_any_trait(t: &hir::Ty) -> bool {\n         if traits.len() >= 1;\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n-        if match_path(&traits[0].trait_ref.path, &*paths::ANY_TRAIT);\n+        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n         then {\n             return true;\n         }\n@@ -2089,14 +2087,14 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n \n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n \n-            if match_path(path, &*paths::HASHMAP) && params_len == 2 {\n+            if match_path(path, &paths::HASHMAP) && params_len == 2 {\n                 Some(ImplicitHasherType::HashMap(\n                     hir_ty.span,\n                     ty,\n                     snippet(cx, params[0].span, \"K\"),\n                     snippet(cx, params[1].span, \"V\"),\n                 ))\n-            } else if match_path(path, &*paths::HASHSET) && params_len == 1 {\n+            } else if match_path(path, &paths::HASHSET) && params_len == 1 {\n                 Some(ImplicitHasherType::HashSet(\n                     hir_ty.span,\n                     ty,\n@@ -2199,11 +2197,11 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n                     return;\n                 }\n \n-                if match_path(ty_path, &*paths::HASHMAP) {\n-                    if method.ident.name == *sym::new {\n+                if match_path(ty_path, &paths::HASHMAP) {\n+                    if method.ident.name == sym!(new) {\n                         self.suggestions\n                             .insert(e.span, \"HashMap::default()\".to_string());\n-                    } else if method.ident.name == *sym::with_capacity {\n+                    } else if method.ident.name == sym!(with_capacity) {\n                         self.suggestions.insert(\n                             e.span,\n                             format!(\n@@ -2212,11 +2210,11 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n                             ),\n                         );\n                     }\n-                } else if match_path(ty_path, &*paths::HASHSET) {\n-                    if method.ident.name == *sym::new {\n+                } else if match_path(ty_path, &paths::HASHSET) {\n+                    if method.ident.name == sym!(new) {\n                         self.suggestions\n                             .insert(e.span, \"HashSet::default()\".to_string());\n-                    } else if method.ident.name == *sym::with_capacity {\n+                    } else if method.ident.name == sym!(with_capacity) {\n                         self.suggestions.insert(\n                             e.span,\n                             format!("}, {"sha": "b3de0823bd453fdc2e8d4953597a42b35a8fd101", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n             hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n                 if let hir::ExprKind::Call(ref func, ref args) = res.node {\n                     if let hir::ExprKind::Path(ref path) = func.node {\n-                        if match_qpath(path, &*paths::TRY_INTO_RESULT) && args.len() == 1 {\n+                        if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n                             check_method_call(cx, &args[0], expr);\n                         }\n                     }\n@@ -67,14 +67,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr, expr: &hir::Expr) {\n     if let hir::ExprKind::MethodCall(ref path, _, _) = call.node {\n         let symbol = &*path.ident.as_str();\n-        if match_trait_method(cx, call, &*paths::IO_READ) && symbol == \"read\" {\n+        if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {\n             span_lint(\n                 cx,\n                 UNUSED_IO_AMOUNT,\n                 expr.span,\n                 \"handle read amount returned or use `Read::read_exact` instead\",\n             );\n-        } else if match_trait_method(cx, call, &*paths::IO_WRITE) && symbol == \"write\" {\n+        } else if match_trait_method(cx, call, &paths::IO_WRITE) && symbol == \"write\" {\n             span_lint(\n                 cx,\n                 UNUSED_IO_AMOUNT,"}, {"sha": "555a4f3f77926a6bb46f8bbf71f2ede30bdef1d6", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -2,7 +2,6 @@ use if_chain::if_chain;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n \n-use crate::utils::sym;\n use crate::utils::{\n     higher::if_block, in_macro_or_desugar, match_type, paths, span_lint_and_then, usage::is_potentially_mutated,\n };\n@@ -96,7 +95,7 @@ fn collect_unwrap_info<'a, 'tcx: 'a>(\n             if let ExprKind::MethodCall(method_name, _, args) = &expr.node;\n             if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].node;\n             let ty = cx.tables.expr_ty(&args[0]);\n-            if match_type(cx, ty, &*paths::OPTION) || match_type(cx, ty, &*paths::RESULT);\n+            if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n             let name = method_name.ident.as_str();\n             if [\"is_some\", \"is_none\", \"is_ok\", \"is_err\"].contains(&&*name);\n             then {\n@@ -144,8 +143,8 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n             if_chain! {\n                 if let ExprKind::MethodCall(ref method_name, _, ref args) = expr.node;\n                 if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].node;\n-                if [*sym::unwrap, *sym::unwrap_err].contains(&method_name.ident.name);\n-                let call_to_unwrap = method_name.ident.name == *sym::unwrap;\n+                if [sym!(unwrap), sym!(unwrap_err)].contains(&method_name.ident.name);\n+                let call_to_unwrap = method_name.ident.name == sym!(unwrap);\n                 if let Some(unwrappable) = self.unwrappables.iter()\n                     .find(|u| u.ident.res == path.res);\n                 then {"}, {"sha": "efa2697d0ad9758f44f6444b490766cd9c91180f", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -2,7 +2,6 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::sym;\n use lazy_static::lazy_static;\n use std::default::Default;\n use std::io::Read;\n@@ -14,7 +13,7 @@ use toml;\n /// Gets the configuration file from arguments.\n pub fn file_from_args(args: &[ast::NestedMetaItem]) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n     for arg in args.iter().filter_map(syntax::ast::NestedMetaItem::meta_item) {\n-        if arg.check_name(*sym::conf_file) {\n+        if arg.check_name(sym!(conf_file)) {\n             return match arg.node {\n                 ast::MetaItemKind::Word | ast::MetaItemKind::List(_) => {\n                     Err((\"`conf_file` must be a named value\", arg.span))"}, {"sha": "7c655277a601d395f2499c45bbec037f40814a2f", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -3,13 +3,11 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::sym;\n use crate::utils::{is_expn_of, match_def_path, match_qpath, paths, resolve_node};\n use if_chain::if_chain;\n use rustc::lint::LateContext;\n use rustc::{hir, ty};\n use syntax::ast;\n-use syntax::symbol::Symbol;\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n@@ -50,8 +48,8 @@ pub struct Range<'a> {\n pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> Option<Range<'b>> {\n     /// Finds the field named `name` in the field. Always return `Some` for\n     /// convenience.\n-    fn get_field(name: Symbol, fields: &[hir::Field]) -> Option<&hir::Expr> {\n-        let expr = &fields.iter().find(|field| field.ident.name == name)?.expr;\n+    fn get_field<'c>(name: &str, fields: &'c [hir::Field]) -> Option<&'c hir::Expr> {\n+        let expr = &fields.iter().find(|field| field.ident.name.as_str() == name)?.expr;\n \n         Some(expr)\n     }\n@@ -90,7 +88,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n \n     match expr.node {\n         hir::ExprKind::Path(ref path) => {\n-            if match_qpath(path, &*paths::RANGE_FULL_STD) || match_qpath(path, &*paths::RANGE_FULL) {\n+            if match_qpath(path, &paths::RANGE_FULL_STD) || match_qpath(path, &paths::RANGE_FULL) {\n                 Some(Range {\n                     start: None,\n                     end: None,\n@@ -102,8 +100,8 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n         },\n         hir::ExprKind::Call(ref path, ref args) => {\n             if let hir::ExprKind::Path(ref path) = path.node {\n-                if match_qpath(path, &*paths::RANGE_INCLUSIVE_STD_NEW)\n-                    || match_qpath(path, &*paths::RANGE_INCLUSIVE_NEW)\n+                if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW)\n+                    || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW)\n                 {\n                     Some(Range {\n                         start: Some(&args[0]),\n@@ -118,30 +116,30 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n             }\n         },\n         hir::ExprKind::Struct(ref path, ref fields, None) => {\n-            if match_qpath(path, &*paths::RANGE_FROM_STD) || match_qpath(path, &*paths::RANGE_FROM) {\n+            if match_qpath(path, &paths::RANGE_FROM_STD) || match_qpath(path, &paths::RANGE_FROM) {\n                 Some(Range {\n-                    start: Some(get_field(*sym::start, fields)?),\n+                    start: Some(get_field(\"start\", fields)?),\n                     end: None,\n                     limits: ast::RangeLimits::HalfOpen,\n                 })\n-            } else if match_qpath(path, &*paths::RANGE_STD) || match_qpath(path, &*paths::RANGE) {\n+            } else if match_qpath(path, &paths::RANGE_STD) || match_qpath(path, &paths::RANGE) {\n                 Some(Range {\n-                    start: Some(get_field(*sym::start, fields)?),\n-                    end: Some(get_field(*sym::end, fields)?),\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::HalfOpen,\n                 })\n-            } else if match_qpath(path, &*paths::RANGE_TO_INCLUSIVE_STD)\n-                || match_qpath(path, &*paths::RANGE_TO_INCLUSIVE)\n+            } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD)\n+                || match_qpath(path, &paths::RANGE_TO_INCLUSIVE)\n             {\n                 Some(Range {\n                     start: None,\n-                    end: Some(get_field(*sym::end, fields)?),\n+                    end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::Closed,\n                 })\n-            } else if match_qpath(path, &*paths::RANGE_TO_STD) || match_qpath(path, &*paths::RANGE_TO) {\n+            } else if match_qpath(path, &paths::RANGE_TO_STD) || match_qpath(path, &paths::RANGE_TO) {\n                 Some(Range {\n                     start: None,\n-                    end: Some(get_field(*sym::end, fields)?),\n+                    end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::HalfOpen,\n                 })\n             } else {\n@@ -238,14 +236,14 @@ pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<Ve\n     if_chain! {\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.node;\n         if let hir::ExprKind::Path(ref path) = fun.node;\n-        if is_expn_of(fun.span, *sym::vec).is_some();\n+        if is_expn_of(fun.span, \"vec\").is_some();\n         if let Some(fun_def_id) = resolve_node(cx, path, fun.hir_id).opt_def_id();\n         then {\n-            return if match_def_path(cx, fun_def_id, &*paths::VEC_FROM_ELEM) && args.len() == 2 {\n+            return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n                 // `vec![elem; size]` case\n                 Some(VecArgs::Repeat(&args[0], &args[1]))\n             }\n-            else if match_def_path(cx, fun_def_id, &*paths::SLICE_INTO_VEC) && args.len() == 1 {\n+            else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                 // `vec![a, b, c]` case\n                 if_chain! {\n                     if let hir::ExprKind::Box(ref boxed) = args[0].node;"}, {"sha": "b64f6b0dfc199441accda8293806df99057971d8", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -77,9 +77,9 @@ impl EarlyLintPass for ClippyLintsInternal {\n     fn check_crate(&mut self, _cx: &EarlyContext<'_>, _krate: &AstCrate) {\n         /*\n         FIXME: turn back on when we get rid of all the lazy_statics\n-        if let Some(utils) = krate.module.items.iter().find(|item| item.ident.name == *sym::utils) {\n+        if let Some(utils) = krate.module.items.iter().find(|item| item.ident.name == sym!(utils)) {\n             if let ItemKind::Mod(ref utils_mod) = utils.node {\n-                if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name == *sym::paths) {\n+                if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name == sym!(paths)) {\n                     if let ItemKind::Mod(ref paths_mod) = paths.node {\n                         let mut last_name: Option<LocalInternedString> = None;\n                         for item in &*paths_mod.items {\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n             if_chain! {\n                 if let hir::TraitRef{path, ..} = trait_ref;\n                 if let Res::Def(DefKind::Trait, def_id) = path.res;\n-                if match_def_path(cx, def_id, &*paths::LINT_PASS);\n+                if match_def_path(cx, def_id, &paths::LINT_PASS);\n                 then {\n                     let mut collector = LintCollector {\n                         output: &mut self.registered_lints,\n@@ -181,7 +181,7 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &Ty) -> bool {\n     {\n         if let TyKind::Path(ref path) = inner.node {\n             if let Res::Def(DefKind::Struct, def_id) = cx.tables.qpath_res(path, inner.hir_id) {\n-                return match_def_path(cx, def_id, &*paths::LINT);\n+                return match_def_path(cx, def_id, &paths::LINT);\n             }\n         }\n     }\n@@ -235,8 +235,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CompilerLintFunctions {\n             let fn_name = path.ident.as_str().to_string();\n             if let Some(sugg) = self.map.get(&fn_name);\n             let ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n-            if match_type(cx, ty, &*paths::EARLY_CONTEXT)\n-                || match_type(cx, ty, &*paths::LATE_CONTEXT);\n+            if match_type(cx, ty, &paths::EARLY_CONTEXT)\n+                || match_type(cx, ty, &paths::LATE_CONTEXT);\n             then {\n                 span_help_and_lint(\n                     cx,"}, {"sha": "33bb2d78732e39df9bf443a4883b2aeb584e2a64", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,3 +1,6 @@\n+#[macro_use]\n+pub mod sym;\n+\n pub mod attrs;\n pub mod author;\n pub mod camel_case;\n@@ -12,7 +15,6 @@ pub mod internal_lints;\n pub mod paths;\n pub mod ptr;\n pub mod sugg;\n-pub mod sym;\n pub mod usage;\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n@@ -122,15 +124,15 @@ pub fn is_present_in_source<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool\n }\n \n /// Checks if type is struct, enum or union type with the given def path.\n-pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[Symbol]) -> bool {\n+pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n \n /// Checks if the method call given in `expr` belongs to the given trait.\n-pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[Symbol]) -> bool {\n+pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let def_id = cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n     if let Some(trt_id) = trt_id {\n@@ -174,14 +176,14 @@ pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n /// ```rust,ignore\n /// match_qpath(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n-pub fn match_qpath(path: &QPath, segments: &[Symbol]) -> bool {\n+pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n     match *path {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n             TyKind::Path(ref inner_path) => {\n                 !segments.is_empty()\n                     && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n-                    && segment.ident.name == segments[segments.len() - 1]\n+                    && segment.ident.name.as_str() == segments[segments.len() - 1]\n             },\n             _ => false,\n         },\n@@ -196,20 +198,20 @@ pub fn match_qpath(path: &QPath, segments: &[Symbol]) -> bool {\n /// # Examples\n ///\n /// ```rust,ignore\n-/// if match_path(&trait_ref.path, &*paths::HASH) {\n+/// if match_path(&trait_ref.path, &paths::HASH) {\n ///     // This is the `std::hash::Hash` trait.\n /// }\n ///\n /// if match_path(ty_path, &[\"rustc\", \"lint\", \"Lint\"]) {\n ///     // This is a `rustc::lint::Lint`.\n /// }\n /// ```\n-pub fn match_path(path: &Path, segments: &[Symbol]) -> bool {\n+pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n     path.segments\n         .iter()\n         .rev()\n         .zip(segments.iter().rev())\n-        .all(|(a, b)| a.ident.name == *b)\n+        .all(|(a, b)| a.ident.name.as_str() == *b)\n }\n \n /// Matches a `Path` against a slice of segment string literals, e.g.\n@@ -218,18 +220,18 @@ pub fn match_path(path: &Path, segments: &[Symbol]) -> bool {\n /// ```rust,ignore\n /// match_qpath(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n-pub fn match_path_ast(path: &ast::Path, segments: &[Symbol]) -> bool {\n+pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n     path.segments\n         .iter()\n         .rev()\n         .zip(segments.iter().rev())\n-        .all(|(a, b)| a.ident.name == *b)\n+        .all(|(a, b)| a.ident.name.as_str() == *b)\n }\n \n /// Gets the definition associated to a path.\n-pub fn path_to_res(cx: &LateContext<'_, '_>, path: &[Symbol]) -> Option<(def::Res)> {\n+pub fn path_to_res(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<(def::Res)> {\n     let crates = cx.tcx.crates();\n-    let krate = crates.iter().find(|&&krate| cx.tcx.crate_name(krate) == path[0]);\n+    let krate = crates.iter().find(|&&krate| cx.tcx.crate_name(krate).as_str() == path[0]);\n     if let Some(krate) = krate {\n         let krate = DefId {\n             krate: *krate,\n@@ -245,7 +247,7 @@ pub fn path_to_res(cx: &LateContext<'_, '_>, path: &[Symbol]) -> Option<(def::Re\n             };\n \n             for item in mem::replace(&mut items, Lrc::new(vec![])).iter() {\n-                if item.ident.name == *segment {\n+                if item.ident.name.as_str() == *segment {\n                     if path_it.peek().is_none() {\n                         return Some(item.res);\n                     }\n@@ -261,7 +263,7 @@ pub fn path_to_res(cx: &LateContext<'_, '_>, path: &[Symbol]) -> Option<(def::Re\n }\n \n /// Convenience function to get the `DefId` of a trait by path.\n-pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[Symbol]) -> Option<DefId> {\n+pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId> {\n     let res = match path_to_res(cx, path) {\n         Some(res) => res,\n         None => return None,\n@@ -364,13 +366,13 @@ pub fn method_calls<'a>(expr: &'a Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&\n /// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n /// containing the `Expr`s for\n /// `.bar()` and `.baz()`\n-pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[Symbol]) -> Option<Vec<&'a [Expr]>> {\n+pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a [Expr]>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n         if let ExprKind::MethodCall(ref path, _, ref args) = current.node {\n-            if path.ident.name == *method_name {\n+            if path.ident.name.as_str() == *method_name {\n                 if args.iter().any(|e| in_macro_or_desugar(e.span)) {\n                     return None;\n                 }\n@@ -684,7 +686,7 @@ pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n /// Returns the pre-expansion span if is this comes from an expansion of the\n /// macro `name`.\n /// See also `is_direct_expn_of`.\n-pub fn is_expn_of(mut span: Span, name: Symbol) -> Option<Span> {\n+pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n         let span_name_span = span\n             .ctxt()\n@@ -693,7 +695,7 @@ pub fn is_expn_of(mut span: Span, name: Symbol) -> Option<Span> {\n             .map(|ei| (ei.format.name(), ei.call_site));\n \n         match span_name_span {\n-            Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n+            Some((mac_name, new_span)) if mac_name.as_str() == name => return Some(new_span),\n             None => return None,\n             Some((_, new_span)) => span = new_span,\n         }\n@@ -709,15 +711,15 @@ pub fn is_expn_of(mut span: Span, name: Symbol) -> Option<Span> {\n /// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only\n /// `bar!` by\n /// `is_direct_expn_of`.\n-pub fn is_direct_expn_of(span: Span, name: Symbol) -> Option<Span> {\n+pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n     let span_name_span = span\n         .ctxt()\n         .outer()\n         .expn_info()\n         .map(|ei| (ei.format.name(), ei.call_site));\n \n     match span_name_span {\n-        Some((mac_name, new_span)) if mac_name == name => Some(new_span),\n+        Some((mac_name, new_span)) if mac_name.as_str() == name => Some(new_span),\n         _ => None,\n     }\n }\n@@ -810,7 +812,7 @@ pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n /// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attr::contains_name(attrs, *sym::automatically_derived)\n+    attr::contains_name(attrs, sym!(automatically_derived))\n }\n \n /// Remove blocks around an expression.\n@@ -996,24 +998,24 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: HirId)\n }\n \n /// Returns true if ty has `iter` or `iter_mut` methods\n-pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Option<Symbol> {\n+pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n     // exists and has the desired signature. Unfortunately FnCtxt is not exported\n     // so we can't use its `lookup_method` method.\n-    let into_iter_collections: [&[Symbol]; 13] = [\n-        &*paths::VEC,\n-        &*paths::OPTION,\n-        &*paths::RESULT,\n-        &*paths::BTREESET,\n-        &*paths::BTREEMAP,\n-        &*paths::VEC_DEQUE,\n-        &*paths::LINKED_LIST,\n-        &*paths::BINARY_HEAP,\n-        &*paths::HASHSET,\n-        &*paths::HASHMAP,\n-        &*paths::PATH_BUF,\n-        &*paths::PATH,\n-        &*paths::RECEIVER,\n+    let into_iter_collections: [&[&str]; 13] = [\n+        &paths::VEC,\n+        &paths::OPTION,\n+        &paths::RESULT,\n+        &paths::BTREESET,\n+        &paths::BTREEMAP,\n+        &paths::VEC_DEQUE,\n+        &paths::LINKED_LIST,\n+        &paths::BINARY_HEAP,\n+        &paths::HASHSET,\n+        &paths::HASHMAP,\n+        &paths::PATH_BUF,\n+        &paths::PATH,\n+        &paths::RECEIVER,\n     ];\n \n     let ty_to_check = match probably_ref_ty.sty {\n@@ -1022,8 +1024,8 @@ pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Opt\n     };\n \n     let def_id = match ty_to_check.sty {\n-        ty::Array(..) => return Some(*sym::array),\n-        ty::Slice(..) => return Some(*sym::slice),\n+        ty::Array(..) => return Some(\"array\"),\n+        ty::Slice(..) => return Some(\"slice\"),\n         ty::Adt(adt, _) => adt.did,\n         _ => return None,\n     };\n@@ -1117,9 +1119,6 @@ mod test {\n     }\n }\n \n-pub fn match_def_path<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, did: DefId, syms: &[Symbol]) -> bool {\n-    // HACK: fix upstream `match_def_path` to take symbols\n-    let syms: Vec<_> = syms.iter().map(|sym| sym.as_str()).collect();\n-    let syms: Vec<_> = syms.iter().map(|sym| &**sym).collect();\n+pub fn match_def_path<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, did: DefId, syms: &[&str]) -> bool {\n     cx.match_def_path(did, &syms)\n }"}, {"sha": "4c693d2d0d4639bba86065e6d95d3e8dcdfe4924", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 112, "deletions": 120, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,123 +1,115 @@\n //! This module contains paths to types and functions Clippy needs to know\n //! about.\n \n-#![allow(default_hash_types)] // we just look at symbol names, which is good enough everywhere else\n-\n-use super::sym::{self, *};\n-use lazy_static::lazy_static;\n-use syntax::symbol::Symbol;\n-\n-lazy_static! {\n-    pub static ref ANY_TRAIT: [Symbol; 3] = [*std, *any, *Any];\n-    pub static ref ARC: [Symbol; 3] = [*alloc, *sync, *Arc];\n-    pub static ref ASMUT_TRAIT: [Symbol; 3] = [*core, *convert, *sym::AsMut];\n-    pub static ref ASREF_TRAIT: [Symbol; 3] = [*core, *convert, *sym::AsRef];\n-    pub static ref BEGIN_PANIC: [Symbol; 3] = [*std, *panicking, *begin_panic];\n-    pub static ref BEGIN_PANIC_FMT: [Symbol; 3] = [*std, *panicking, *begin_panic_fmt];\n-    pub static ref BINARY_HEAP: [Symbol; 4] = [*alloc, *collections, *binary_heap, *BinaryHeap];\n-    pub static ref BORROW_TRAIT: [Symbol; 3] = [*core, *borrow, *Borrow];\n-    pub static ref BTREEMAP: [Symbol; 5] = [*alloc, *collections, *btree, *map, *BTreeMap];\n-    pub static ref BTREEMAP_ENTRY: [Symbol; 5] = [*alloc, *collections, *btree, *map, *Entry];\n-    pub static ref BTREESET: [Symbol; 5] = [*alloc, *collections, *btree, *set, *BTreeSet];\n-    pub static ref CLONE_TRAIT: [Symbol; 3] = [*core, *clone, *sym::Clone];\n-    pub static ref CLONE_TRAIT_METHOD: [Symbol; 4] = [*core, *clone, *sym::Clone, *clone];\n-    pub static ref CMP_MAX: [Symbol; 3] = [*core, *cmp, *max];\n-    pub static ref CMP_MIN: [Symbol; 3] = [*core, *cmp, *min];\n-    pub static ref COW: [Symbol; 3] = [*alloc, *borrow, *Cow];\n-    pub static ref CSTRING_NEW: [Symbol; 5] = [*std, *ffi, *c_str, *CString, *new];\n-    pub static ref DEFAULT_TRAIT: [Symbol; 3] = [*core, *default, *sym::Default];\n-    pub static ref DEFAULT_TRAIT_METHOD: [Symbol; 4] = [*core, *default, *sym::Default, *default];\n-    pub static ref DEREF_TRAIT_METHOD: [Symbol; 5] = [*core, *ops, *deref, *Deref, *deref];\n-    pub static ref DISPLAY_FMT_METHOD: [Symbol; 4] = [*core, *fmt, *Display, *fmt];\n-    pub static ref DOUBLE_ENDED_ITERATOR: [Symbol; 4] = [*core, *iter, *traits, *sym::DoubleEndedIterator];\n-    pub static ref DROP: [Symbol; 3] = [*core, *mem, *drop];\n-    pub static ref DROP_TRAIT: [Symbol; 4] = [*core, *ops, *drop, *sym::Drop];\n-    pub static ref DURATION: [Symbol; 3] = [*core, *time, *Duration];\n-    pub static ref EARLY_CONTEXT: [Symbol; 4] = [*rustc, *lint, *context, *EarlyContext];\n-    pub static ref FMT_ARGUMENTS_NEWV1: [Symbol; 4] = [*core, *fmt, *Arguments, *new_v1];\n-    pub static ref FMT_ARGUMENTS_NEWV1FORMATTED: [Symbol; 4] = [*core, *fmt, *Arguments, *new_v1_formatted];\n-    pub static ref FROM_FROM: [Symbol; 4] = [*core, *convert, *sym::From, *from];\n-    pub static ref FROM_TRAIT: [Symbol; 3] = [*core, *convert, *sym::From];\n-    pub static ref HASH: [Symbol; 2] = [*hash, *Hash];\n-    pub static ref HASHMAP: [Symbol; 5] = [*std, *collections, *hash, *map, *HashMap];\n-    pub static ref HASHMAP_ENTRY: [Symbol; 5] = [*std, *collections, *hash, *map, *Entry];\n-    pub static ref HASHSET: [Symbol; 5] = [*std, *collections, *hash, *set, *HashSet];\n-    pub static ref INDEX: [Symbol; 3] = [*core, *ops, *Index];\n-    pub static ref INDEX_MUT: [Symbol; 3] = [*core, *ops, *IndexMut];\n-    pub static ref INIT: [Symbol; 4] = [*core, *intrinsics, *empty_symbol, *init];\n-    pub static ref INTO: [Symbol; 3] = [*core, *convert, *sym::Into];\n-    pub static ref INTO_ITERATOR: [Symbol; 5] = [*core, *iter, *traits, *collect, *sym::IntoIterator];\n-    pub static ref IO_READ: [Symbol; 3] = [*std, *io, *Read];\n-    pub static ref IO_WRITE: [Symbol; 3] = [*std, *io, *Write];\n-    pub static ref ITERATOR: [Symbol; 5] = [*core, *iter, *traits, *iterator, *sym::Iterator];\n-    pub static ref LATE_CONTEXT: [Symbol; 4] = [*rustc, *lint, *context, *LateContext];\n-    pub static ref LINKED_LIST: [Symbol; 4] = [*alloc, *collections, *linked_list, *LinkedList];\n-    pub static ref LINT: [Symbol; 3] = [*rustc, *lint, *Lint];\n-    pub static ref LINT_PASS: [Symbol; 3] = [*rustc, *lint, *LintPass];\n-    pub static ref MEM_DISCRIMINANT: [Symbol; 3] = [*core, *mem, *discriminant];\n-    pub static ref MEM_FORGET: [Symbol; 3] = [*core, *mem, *forget];\n-    pub static ref MEM_REPLACE: [Symbol; 3] = [*core, *mem, *replace];\n-    pub static ref MEM_UNINIT: [Symbol; 3] = [*core, *mem, *uninitialized];\n-    pub static ref MEM_ZEROED: [Symbol; 3] = [*core, *mem, *zeroed];\n-    pub static ref MUTEX: [Symbol; 4] = [*std, *sync, *mutex, *Mutex];\n-    pub static ref OPEN_OPTIONS: [Symbol; 3] = [*std, *fs, *OpenOptions];\n-    pub static ref OPS_MODULE: [Symbol; 2] = [*core, *ops];\n-    pub static ref OPTION: [Symbol; 3] = [*core, *option, *sym::Option];\n-    pub static ref OPTION_NONE: [Symbol; 4] = [*core, *option, *sym::Option, *sym::None];\n-    pub static ref OPTION_SOME: [Symbol; 4] = [*core, *option, *sym::Option, *sym::Some];\n-    pub static ref ORD: [Symbol; 3] = [*core, *cmp, *sym::Ord];\n-    pub static ref OS_STRING: [Symbol; 4] = [*std, *ffi, *os_str, *OsString];\n-    pub static ref OS_STR_TO_OS_STRING: [Symbol; 5] = [*std, *ffi, *os_str, *OsStr, *to_os_string];\n-    pub static ref PARTIAL_ORD: [Symbol; 3] = [*core, *cmp, *sym::PartialOrd];\n-    pub static ref PATH: [Symbol; 3] = [*std, *path, *Path];\n-    pub static ref PATH_BUF: [Symbol; 3] = [*std, *path, *PathBuf];\n-    pub static ref PATH_TO_PATH_BUF: [Symbol; 4] = [*std, *path, *Path, *to_path_buf];\n-    pub static ref PTR_NULL: [Symbol; 2] = [*ptr, *null];\n-    pub static ref PTR_NULL_MUT: [Symbol; 2] = [*ptr, *null_mut];\n-    pub static ref RANGE: [Symbol; 3] = [*core, *ops, *Range];\n-    pub static ref RANGE_ARGUMENT_TRAIT: [Symbol; 3] = [*core, *ops, *RangeBounds];\n-    pub static ref RANGE_FROM: [Symbol; 3] = [*core, *ops, *RangeFrom];\n-    pub static ref RANGE_FROM_STD: [Symbol; 3] = [*std, *ops, *RangeFrom];\n-    pub static ref RANGE_FULL: [Symbol; 3] = [*core, *ops, *RangeFull];\n-    pub static ref RANGE_FULL_STD: [Symbol; 3] = [*std, *ops, *RangeFull];\n-    pub static ref RANGE_INCLUSIVE_NEW: [Symbol; 4] = [*core, *ops, *RangeInclusive, *new];\n-    pub static ref RANGE_INCLUSIVE_STD_NEW: [Symbol; 4] = [*std, *ops, *RangeInclusive, *new];\n-    pub static ref RANGE_STD: [Symbol; 3] = [*std, *ops, *Range];\n-    pub static ref RANGE_TO: [Symbol; 3] = [*core, *ops, *RangeTo];\n-    pub static ref RANGE_TO_INCLUSIVE: [Symbol; 3] = [*core, *ops, *RangeToInclusive];\n-    pub static ref RANGE_TO_INCLUSIVE_STD: [Symbol; 3] = [*std, *ops, *RangeToInclusive];\n-    pub static ref RANGE_TO_STD: [Symbol; 3] = [*std, *ops, *RangeTo];\n-    pub static ref RC: [Symbol; 3] = [*alloc, *rc, *Rc];\n-    pub static ref RECEIVER: [Symbol; 4] = [*std, *sync, *mpsc, *Receiver];\n-    pub static ref REGEX: [Symbol; 3] = [*regex, *re_unicode, *Regex];\n-    pub static ref REGEX_BUILDER_NEW: [Symbol; 5] = [*regex, *re_builder, *unicode, *RegexBuilder, *new];\n-    pub static ref REGEX_BYTES_BUILDER_NEW: [Symbol; 5] = [*regex, *re_builder, *bytes, *RegexBuilder, *new];\n-    pub static ref REGEX_BYTES_NEW: [Symbol; 4] = [*regex, *re_bytes, *Regex, *new];\n-    pub static ref REGEX_BYTES_SET_NEW: [Symbol; 5] = [*regex, *re_set, *bytes, *RegexSet, *new];\n-    pub static ref REGEX_NEW: [Symbol; 4] = [*regex, *re_unicode, *Regex, *new];\n-    pub static ref REGEX_SET_NEW: [Symbol; 5] = [*regex, *re_set, *unicode, *RegexSet, *new];\n-    pub static ref REPEAT: [Symbol; 3] = [*core, *iter, *repeat];\n-    pub static ref RESULT: [Symbol; 3] = [*core, *result, *sym::Result];\n-    pub static ref RESULT_ERR: [Symbol; 4] = [*core, *result, *sym::Result, *sym::Err];\n-    pub static ref RESULT_OK: [Symbol; 4] = [*core, *result, *sym::Result, *sym::Ok];\n-    pub static ref SERDE_DE_VISITOR: [Symbol; 3] = [*serde, *de, *Visitor];\n-    pub static ref SLICE_INTO_VEC: [Symbol; 4] = [*alloc, *slice, *impl_slice_t, *into_vec];\n-    pub static ref SLICE_ITER: [Symbol; 3] = [*core, *slice, *Iter];\n-    pub static ref STD_MEM_TRANSMUTE: [Symbol; 3] = [*std, *mem, *transmute];\n-    pub static ref STD_PTR_NULL: [Symbol; 3] = [*std, *ptr, *null];\n-    pub static ref STDERR: [Symbol; 4] = [*std, *io, *stdio, *stderr];\n-    pub static ref STDOUT: [Symbol; 4] = [*std, *io, *stdio, *stdout];\n-    pub static ref STRING: [Symbol; 3] = [*alloc, *string, *sym::String];\n-    pub static ref TO_OWNED: [Symbol; 3] = [*alloc, *borrow, *sym::ToOwned];\n-    pub static ref TO_OWNED_METHOD: [Symbol; 4] = [*alloc, *borrow, *sym::ToOwned, *to_owned];\n-    pub static ref TO_STRING: [Symbol; 3] = [*alloc, *string, *sym::ToString];\n-    pub static ref TO_STRING_METHOD: [Symbol; 4] = [*alloc, *string, *sym::ToString, *to_string];\n-    pub static ref TRANSMUTE: [Symbol; 4] = [*core, *intrinsics, *empty_symbol, *transmute];\n-    pub static ref TRY_INTO_RESULT: [Symbol; 4] = [*std, *ops, *Try, *into_result];\n-    pub static ref UNINIT: [Symbol; 4] = [*core, *intrinsics, *empty_symbol, *uninit];\n-    pub static ref VEC: [Symbol; 3] = [*alloc, *vec, *sym::Vec];\n-    pub static ref VEC_DEQUE: [Symbol; 4] = [*alloc, *collections, *vec_deque, *VecDeque];\n-    pub static ref VEC_FROM_ELEM: [Symbol; 3] = [*alloc, *vec, *from_elem];\n-    pub static ref WEAK_ARC: [Symbol; 3] = [*alloc, *sync, *Weak];\n-    pub static ref WEAK_RC: [Symbol; 3] = [*alloc, *rc, *Weak];\n-}\n+pub const ANY_TRAIT: [&str; 3] = [\"std\", \"any\", \"Any\"];\n+pub const ARC: [&str; 3] = [\"alloc\", \"sync\", \"Arc\"];\n+pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n+pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n+pub const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n+pub const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_fmt\"];\n+pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"BinaryHeap\"];\n+pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n+pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const BTREEMAP_ENTRY: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n+pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n+pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n+pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n+pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n+pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n+pub const CSTRING_NEW: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"new\"];\n+pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n+pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n+pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n+pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n+pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n+pub const DROP_TRAIT: [&str; 4] = [\"core\", \"ops\", \"drop\", \"Drop\"];\n+pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n+pub const EARLY_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"EarlyContext\"];\n+pub const FMT_ARGUMENTS_NEWV1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTS_NEWV1FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n+pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n+pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n+pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];\n+pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n+pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n+pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n+pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n+pub const INIT: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"init\"];\n+pub const INTO: [&str; 3] = [\"core\", \"convert\", \"Into\"];\n+pub const INTO_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\"];\n+pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n+pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n+pub const ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\"];\n+pub const LATE_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"LateContext\"];\n+pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n+pub const LINT: [&str; 3] = [\"rustc\", \"lint\", \"Lint\"];\n+pub const LINT_PASS: [&str; 3] = [\"rustc\", \"lint\", \"LintPass\"];\n+pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n+pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n+pub const MEM_REPLACE: [&str; 3] = [\"core\", \"mem\", \"replace\"];\n+pub const MEM_UNINIT: [&str; 3] = [\"core\", \"mem\", \"uninitialized\"];\n+pub const MEM_ZEROED: [&str; 3] = [\"core\", \"mem\", \"zeroed\"];\n+pub const MUTEX: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n+pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n+pub const OPS_MODULE: [&str; 2] = [\"core\", \"ops\"];\n+pub const OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const OPTION_NONE: [&str; 4] = [\"core\", \"option\", \"Option\", \"None\"];\n+pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n+pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n+pub const OS_STRING: [&str; 4] = [\"std\", \"ffi\", \"os_str\", \"OsString\"];\n+pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n+pub const PARTIAL_ORD: [&str; 3] = [\"core\", \"cmp\", \"PartialOrd\"];\n+pub const PATH: [&str; 3] = [\"std\", \"path\", \"Path\"];\n+pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n+pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n+pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n+pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n+pub const RANGE: [&str; 3] = [\"core\", \"ops\", \"Range\"];\n+pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n+pub const RANGE_FROM: [&str; 3] = [\"core\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FROM_STD: [&str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FULL: [&str; 3] = [\"core\", \"ops\", \"RangeFull\"];\n+pub const RANGE_FULL_STD: [&str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n+pub const RANGE_INCLUSIVE_NEW: [&str; 4] = [\"core\", \"ops\", \"RangeInclusive\", \"new\"];\n+pub const RANGE_INCLUSIVE_STD_NEW: [&str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"new\"];\n+pub const RANGE_STD: [&str; 3] = [\"std\", \"ops\", \"Range\"];\n+pub const RANGE_TO: [&str; 3] = [\"core\", \"ops\", \"RangeTo\"];\n+pub const RANGE_TO_INCLUSIVE: [&str; 3] = [\"core\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO_INCLUSIVE_STD: [&str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO_STD: [&str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n+pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n+pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n+pub const REGEX: [&str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n+pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n+pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n+pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];\n+pub const REGEX_BYTES_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"bytes\", \"RegexSet\", \"new\"];\n+pub const REGEX_NEW: [&str; 4] = [\"regex\", \"re_unicode\", \"Regex\", \"new\"];\n+pub const REGEX_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"unicode\", \"RegexSet\", \"new\"];\n+pub const REPEAT: [&str; 3] = [\"core\", \"iter\", \"repeat\"];\n+pub const RESULT: [&str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const RESULT_ERR: [&str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n+pub const RESULT_OK: [&str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n+pub const SERDE_DE_VISITOR: [&str; 3] = [\"serde\", \"de\", \"Visitor\"];\n+pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n+pub const SLICE_ITER: [&str; 3] = [\"core\", \"slice\", \"Iter\"];\n+pub const STD_MEM_TRANSMUTE: [&str; 3] = [\"std\", \"mem\", \"transmute\"];\n+pub const STD_PTR_NULL: [&str; 3] = [\"std\", \"ptr\", \"null\"];\n+pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n+pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n+pub const STRING: [&str; 3] = [\"alloc\", \"string\", \"String\"];\n+pub const TO_OWNED: [&str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n+pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];\n+pub const TO_STRING: [&str; 3] = [\"alloc\", \"string\", \"ToString\"];\n+pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n+pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+pub const TRY_INTO_RESULT: [&str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n+pub const UNINIT: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"uninit\"];\n+pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n+pub const VEC_DEQUE: [&str; 4] = [\"alloc\", \"collections\", \"vec_deque\", \"VecDeque\"];\n+pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n+pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n+pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];"}, {"sha": "fb2e3a38d778e1610169b29c6a8f38d3c3f74b53", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,18 +1,16 @@\n-use crate::utils::sym;\n use crate::utils::{get_pat_name, match_var, snippet};\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n use rustc::lint::LateContext;\n use std::borrow::Cow;\n use syntax::ast::Name;\n use syntax::source_map::Span;\n-use syntax::symbol::Symbol;\n \n pub fn get_spans(\n     cx: &LateContext<'_, '_>,\n     opt_body_id: Option<BodyId>,\n     idx: usize,\n-    replacements: &[(Symbol, &'static str)],\n+    replacements: &[(&'static str, &'static str)],\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     if let Some(body) = opt_body_id.map(|id| cx.tcx.hir().body(id)) {\n         get_binding_name(&body.arguments[idx]).map_or_else(\n@@ -27,7 +25,7 @@ pub fn get_spans(\n fn extract_clone_suggestions<'a, 'tcx: 'a>(\n     cx: &LateContext<'a, 'tcx>,\n     name: Name,\n-    replace: &[(Symbol, &'static str)],\n+    replace: &[(&'static str, &'static str)],\n     body: &'tcx Body,\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     let mut visitor = PtrCloneVisitor {\n@@ -48,7 +46,7 @@ fn extract_clone_suggestions<'a, 'tcx: 'a>(\n struct PtrCloneVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     name: Name,\n-    replace: &'a [(Symbol, &'static str)],\n+    replace: &'a [(&'static str, &'static str)],\n     spans: Vec<(Span, Cow<'static, str>)>,\n     abort: bool,\n }\n@@ -60,12 +58,12 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         }\n         if let ExprKind::MethodCall(ref seg, _, ref args) = expr.node {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n-                if seg.ident.name == *sym::capacity {\n+                if seg.ident.name.as_str() == \"capacity\" {\n                     self.abort = true;\n                     return;\n                 }\n                 for &(fn_name, suffix) in self.replace {\n-                    if seg.ident.name == fn_name {\n+                    if seg.ident.name.as_str() == fn_name {\n                         self.spans\n                             .push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n                         return;"}, {"sha": "61de41d96d779c9044ede6f80f5f53e8deb9ebc4", "filename": "clippy_lints/src/utils/sym.rs", "status": "modified", "additions": 4, "deletions": 390, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Futils%2Fsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsym.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,393 +1,7 @@\n-#![allow(default_hash_types, non_upper_case_globals)]\n \n-use lazy_static::lazy_static;\n-use syntax::symbol::Symbol;\n-\n-macro_rules! symbols_simple {\n-    ($($ident:ident,)*) => {\n-        $(\n-            lazy_static! {\n-                pub(crate) static ref $ident: Symbol = Symbol::intern(stringify!($ident));\n-            }\n-        )*\n+#[macro_export]\n+macro_rules! sym {\n+    ($tt:tt) => {\n+        syntax::symbol::Symbol::intern(stringify!($tt))\n     };\n }\n-\n-macro_rules! symbols_init {\n-    ($($ident:ident: $expr:expr,)*) => {\n-        $(\n-            lazy_static! {\n-                pub(crate) static ref $ident: Symbol = Symbol::intern($expr);\n-            }\n-        )*\n-    };\n-}\n-\n-// exists because concat_idents is flaky\n-pub mod assign {\n-    pub(crate) use super::AddAssign as Add;\n-    pub(crate) use super::AndAssign as And;\n-    pub(crate) use super::BitAndAssign as BitAnd;\n-    pub(crate) use super::BitOrAssign as BitOr;\n-    pub(crate) use super::BitXorAssign as BitXor;\n-    pub(crate) use super::DivAssign as Div;\n-    pub(crate) use super::MulAssign as Mul;\n-    pub(crate) use super::OrAssign as Or;\n-    pub(crate) use super::RemAssign as Rem;\n-    pub(crate) use super::ShlAssign as Shl;\n-    pub(crate) use super::ShrAssign as Shr;\n-    pub(crate) use super::SubAssign as Sub;\n-}\n-\n-symbols_simple! {\n-    Option,\n-    rustc,\n-    AsMut,\n-    AsRef,\n-    Clone,\n-    Default,\n-    DoubleEndedIterator,\n-    Drop,\n-    From,\n-    Into,\n-    IntoIterator,\n-    Iterator,\n-    Ord,\n-    PartialOrd,\n-    Any,\n-    add,\n-    Add,\n-    AddAssign,\n-    AndAssign,\n-    OrAssign,\n-    all,\n-    alloc,\n-    always,\n-    any,\n-    Arc,\n-    Arguments,\n-    array,\n-    as_bytes,\n-    as_mut,\n-    as_ref,\n-    assert,\n-    as_str,\n-    automatically_derived,\n-    begin_panic,\n-    begin_panic_fmt,\n-    binary_heap,\n-    BinaryHeap,\n-    bitand,\n-    BitAndAssign,\n-    bitor,\n-    BitOrAssign,\n-    bitxor,\n-    BitXorAssign,\n-    bool,\n-    borrow,\n-    Borrow,\n-    borrow_mut,\n-    btree,\n-    BTreeMap,\n-    BTreeSet,\n-    by_ref,\n-    bytes,\n-    capacity,\n-    cfg,\n-    cfg_attr,\n-    chain,\n-    chars,\n-    clone,\n-    cloned,\n-    cmp,\n-    collect,\n-    collections,\n-    conf_file,\n-    contains,\n-    contains_key,\n-    context,\n-    convert,\n-    core,\n-    count,\n-    Cow,\n-    c_str,\n-    CString,\n-    cycle,\n-    dbg,\n-    de,\n-    debug_assert,\n-    default,\n-    deprecated,\n-    deref,\n-    Deref,\n-    deref_mut,\n-    discriminant,\n-    Display,\n-    div,\n-    Div,\n-    DivAssign,\n-    doc,\n-    drop,\n-    Duration,\n-    E,\n-    EarlyContext,\n-    end,\n-    ends_with,\n-    Entry,\n-    enumerate,\n-    eq,\n-    Err,\n-    extend,\n-    ffi,\n-    filter,\n-    filter_map,\n-    find,\n-    flat_map,\n-    fmt,\n-    fold,\n-    for_each,\n-    forget,\n-    format,\n-    FRAC_1_PI,\n-    FRAC_1_SQRT_2,\n-    FRAC_2_PI,\n-    FRAC_2_SQRT_PI,\n-    FRAC_PI_2,\n-    FRAC_PI_3,\n-    FRAC_PI_4,\n-    FRAC_PI_6,\n-    FRAC_PI_8,\n-    from,\n-    from_elem,\n-    from_iter,\n-    from_str,\n-    fs,\n-    fuse,\n-    hash,\n-    Hash,\n-    HashMap,\n-    HashSet,\n-    hidden,\n-    i128,\n-    i16,\n-    i32,\n-    i64,\n-    i8,\n-    Implied,\n-    index,\n-    Index,\n-    index_mut,\n-    IndexMut,\n-    init,\n-    inline,\n-    insert,\n-    inspect,\n-    into_iter,\n-    into_result,\n-    into_vec,\n-    intrinsics,\n-    io,\n-    is_empty,\n-    is_err,\n-    isize,\n-    is_none,\n-    is_ok,\n-    is_some,\n-    iter,\n-    Iter,\n-    iterator,\n-    iter_mut,\n-    last,\n-    LateContext,\n-    len,\n-    linked_list,\n-    LinkedList,\n-    lint,\n-    Lint,\n-    LintPass,\n-    LN_10,\n-    LN_2,\n-    LOG10_E,\n-    LOG2_E,\n-    macro_use,\n-    main,\n-    map,\n-    matches,\n-    match_indices,\n-    max,\n-    MAX,\n-    max_by,\n-    max_by_key,\n-    mem,\n-    min,\n-    MIN,\n-    min_by,\n-    min_by_key,\n-    mpsc,\n-    mul,\n-    Mul,\n-    MulAssign,\n-    mutex,\n-    Mutex,\n-    NAN,\n-    ne,\n-    neg,\n-    new,\n-    new_v1,\n-    new_v1_formatted,\n-    next,\n-    next_back,\n-    None,\n-    not,\n-    null,\n-    null_mut,\n-    offset,\n-    ok,\n-    Ok,\n-    ONCE_INIT,\n-    open,\n-    OpenOptions,\n-    ops,\n-    option,\n-    os_str,\n-    OsStr,\n-    OsString,\n-    panic,\n-    panicking,\n-    partition,\n-    path,\n-    Path,\n-    PathBuf,\n-    paths,\n-    peekable,\n-    PI,\n-    position,\n-    precision,\n-    print,\n-    println,\n-    proc_macro,\n-    proc_macro_attribute,\n-    proc_macro_derive,\n-    product,\n-    ptr,\n-    push,\n-    Range,\n-    RangeBounds,\n-    RangeFrom,\n-    RangeFull,\n-    RangeInclusive,\n-    RangeTo,\n-    RangeToInclusive,\n-    rc,\n-    Rc,\n-    Read,\n-    re_builder,\n-    re_bytes,\n-    Receiver,\n-    regex,\n-    Regex,\n-    RegexBuilder,\n-    RegexSet,\n-    rem,\n-    RemAssign,\n-    repeat,\n-    replace,\n-    re_set,\n-    resize,\n-    result,\n-    Result,\n-    re_unicode,\n-    rev,\n-    rfind,\n-    rmatches,\n-    rmatch_indices,\n-    rplit_terminator,\n-    rposition,\n-    rsplit,\n-    rsplitn,\n-    rsplit_terminator,\n-    rustfmt,\n-    rustfmt_skip,\n-    scan,\n-    serde,\n-    set,\n-    shl,\n-    ShlAssign,\n-    shr,\n-    ShrAssign,\n-    since,\n-    skip,\n-    skip_while,\n-    slice,\n-    Some,\n-    split,\n-    splitn,\n-    split_terminator,\n-    SQRT_2,\n-    start,\n-    starts_with,\n-    std,\n-    stderr,\n-    stdin,\n-    stdio,\n-    stdout,\n-    string,\n-    String,\n-    sub,\n-    Sub,\n-    SubAssign,\n-    sum,\n-    sync,\n-    take,\n-    take_while,\n-    test,\n-    time,\n-    to_os_string,\n-    to_owned,\n-    ToOwned,\n-    to_path_buf,\n-    to_string,\n-    ToString,\n-    traits,\n-    transmute,\n-    trim_end_matches,\n-    trim_start_matches,\n-    Try,\n-    u128,\n-    u16,\n-    u32,\n-    u64,\n-    u8,\n-    unicode,\n-    unimplemented,\n-    uninit,\n-    uninitialized,\n-    unreachable,\n-    unused_extern_crates,\n-    unused_imports,\n-    unwrap,\n-    unwrap_err,\n-    unzip,\n-    usize,\n-    utils,\n-    vec,\n-    Vec,\n-    vec_deque,\n-    VecDeque,\n-    Visitor,\n-    Weak,\n-    width,\n-    with_capacity,\n-    wrapping_offset,\n-    write,\n-    Write,\n-    write_fmt,\n-    writeln,\n-    zeroed,\n-    zip,\n-}\n-\n-symbols_init! {\n-    impl_slice_t: \"<impl [T]>\",\n-    empty_symbol: \"\",\n-}"}, {"sha": "bdb0923945bc4b2217accc4270ddd1294247ee4a", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f85a0dcac857d35b621a736226fe3c73251c98/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=f7f85a0dcac857d35b621a736226fe3c73251c98", "patch": "@@ -1,12 +1,12 @@\n-use crate::utils::{snippet_with_applicability, span_lint, span_lint_and_sugg, sym};\n+use crate::utils::{snippet_with_applicability, span_lint, span_lint_and_sugg};\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use std::borrow::Cow;\n use syntax::ast::*;\n use syntax::parse::{parser, token};\n-use syntax::symbol::Symbol;\n use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax_pos::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -182,7 +182,7 @@ declare_lint_pass!(Write => [\n \n impl EarlyLintPass for Write {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &Mac) {\n-        if mac.node.path == *sym::println {\n+        if mac.node.path == sym!(println) {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n             if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n                 if fmtstr == \"\" {\n@@ -197,7 +197,7 @@ impl EarlyLintPass for Write {\n                     );\n                 }\n             }\n-        } else if mac.node.path == *sym::print {\n+        } else if mac.node.path == sym!(print) {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n             if let (Some(fmtstr), _, is_raw) = check_tts(cx, &mac.node.tts, false) {\n                 if check_newlines(&fmtstr, is_raw) {\n@@ -210,7 +210,7 @@ impl EarlyLintPass for Write {\n                     );\n                 }\n             }\n-        } else if mac.node.path == *sym::write {\n+        } else if mac.node.path == sym!(write) {\n             if let (Some(fmtstr), _, is_raw) = check_tts(cx, &mac.node.tts, true) {\n                 if check_newlines(&fmtstr, is_raw) {\n                     span_lint(\n@@ -222,7 +222,7 @@ impl EarlyLintPass for Write {\n                     );\n                 }\n             }\n-        } else if mac.node.path == *sym::writeln {\n+        } else if mac.node.path == sym!(writeln) {\n             let check_tts = check_tts(cx, &mac.node.tts, true);\n             if let Some(fmtstr) = check_tts.0 {\n                 if fmtstr == \"\" {\n@@ -365,8 +365,6 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n                             match arg.position {\n                                 ArgumentImplicitlyIs(_) | ArgumentIs(_) => {},\n                                 ArgumentNamed(name) => {\n-                                    // FIXME: remove this interning if possible\n-                                    // https://github.com/rust-lang/rust/issues/60795\n                                     if *p == Symbol::intern(name) {\n                                         seen = true;\n                                         all_simple &= arg.format == SIMPLE;"}]}