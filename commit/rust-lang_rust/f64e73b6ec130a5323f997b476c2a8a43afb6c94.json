{"sha": "f64e73b6ec130a5323f997b476c2a8a43afb6c94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NGU3M2I2ZWMxMzBhNTMyM2Y5OTdiNDc2YzJhOGE0M2FmYjZjOTQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-20T21:05:21Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-28T09:29:19Z"}, "message": "rustc: simplify constant cross-crate loading and rustc_passes::consts.", "tree": {"sha": "b094b82322f6adcd7d5236aae4b3b7c4a58daa96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b094b82322f6adcd7d5236aae4b3b7c4a58daa96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f64e73b6ec130a5323f997b476c2a8a43afb6c94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f64e73b6ec130a5323f997b476c2a8a43afb6c94", "html_url": "https://github.com/rust-lang/rust/commit/f64e73b6ec130a5323f997b476c2a8a43afb6c94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f64e73b6ec130a5323f997b476c2a8a43afb6c94/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "html_url": "https://github.com/rust-lang/rust/commit/f89856be6ccd1f63ef72d343587cd5d7932cfe8b"}], "stats": {"total": 1383, "additions": 390, "deletions": 993}, "files": [{"sha": "a6ffe7cea5592e752ce7b66b09a8c6e80b700c08", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -11,7 +11,6 @@\n use super::*;\n \n use hir::intravisit::{Visitor, NestedVisitorMap};\n-use middle::cstore::InlinedItem;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n@@ -21,7 +20,7 @@ pub struct NodeCollector<'ast> {\n     /// The crate\n     pub krate: &'ast Crate,\n     /// The node map\n-    pub map: Vec<MapEntry<'ast>>,\n+    pub(super) map: Vec<MapEntry<'ast>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n     /// If true, completely ignore nested items. We set this when loading\n@@ -43,11 +42,11 @@ impl<'ast> NodeCollector<'ast> {\n         collector\n     }\n \n-    pub fn extend(krate: &'ast Crate,\n-                  parent: &'ast InlinedItem,\n-                  parent_node: NodeId,\n-                  map: Vec<MapEntry<'ast>>)\n-                  -> NodeCollector<'ast> {\n+    pub(super) fn extend(krate: &'ast Crate,\n+                         parent: &'ast InlinedItem,\n+                         parent_node: NodeId,\n+                         map: Vec<MapEntry<'ast>>)\n+                         -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n             krate: krate,\n             map: map,"}, {"sha": "2f28f1f3f55f2b9dc9a1892e8101c7edf505471c", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 92, "deletions": 82, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -17,7 +17,6 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n \n use dep_graph::{DepGraph, DepNode};\n \n-use middle::cstore::InlinedItem;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n@@ -26,6 +25,7 @@ use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n+use hir::intravisit::Visitor;\n use hir::print as pprust;\n \n use arena::TypedArena;\n@@ -38,6 +38,15 @@ mod collector;\n mod def_collector;\n pub mod definitions;\n \n+/// The data we save and restore about an inlined item or method.  This is not\n+/// part of the AST that we parse from a file, but it becomes part of the tree\n+/// that we trans.\n+#[derive(Debug)]\n+struct InlinedItem {\n+    def_id: DefId,\n+    body: Body,\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n@@ -60,14 +69,12 @@ pub enum Node<'ast> {\n     NodeLifetime(&'ast Lifetime),\n     NodeTyParam(&'ast TyParam),\n     NodeVisibility(&'ast Visibility),\n-\n-    NodeInlinedItem(&'ast InlinedItem),\n }\n \n /// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n-pub enum MapEntry<'ast> {\n+enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n@@ -121,8 +128,6 @@ impl<'ast> MapEntry<'ast> {\n             NodeLifetime(n) => EntryLifetime(p, n),\n             NodeTyParam(n) => EntryTyParam(p, n),\n             NodeVisibility(n) => EntryVisibility(p, n),\n-\n-            NodeInlinedItem(n) => RootInlinedParent(n),\n         }\n     }\n \n@@ -171,10 +176,49 @@ impl<'ast> MapEntry<'ast> {\n             EntryLifetime(_, n) => NodeLifetime(n),\n             EntryTyParam(_, n) => NodeTyParam(n),\n             EntryVisibility(_, n) => NodeVisibility(n),\n-            RootInlinedParent(n) => NodeInlinedItem(n),\n             _ => return None\n         })\n     }\n+\n+    fn is_body_owner(self, node_id: NodeId) -> bool {\n+        match self {\n+            EntryItem(_, item) => {\n+                match item.node {\n+                    ItemConst(_, body) |\n+                    ItemStatic(.., body) |\n+                    ItemFn(_, _, _, _, _, body) => body.node_id == node_id,\n+                    _ => false\n+                }\n+            }\n+\n+            EntryTraitItem(_, item) => {\n+                match item.node {\n+                    TraitItemKind::Const(_, Some(body)) |\n+                    TraitItemKind::Method(_, TraitMethod::Provided(body)) => {\n+                        body.node_id == node_id\n+                    }\n+                    _ => false\n+                }\n+            }\n+\n+            EntryImplItem(_, item) => {\n+                match item.node {\n+                    ImplItemKind::Const(_, body) |\n+                    ImplItemKind::Method(_, body) => body.node_id == node_id,\n+                    _ => false\n+                }\n+            }\n+\n+            EntryExpr(_, expr) => {\n+                match expr.node {\n+                    ExprClosure(.., body, _) => body.node_id == node_id,\n+                    _ => false\n+                }\n+            }\n+\n+            _ => false\n+        }\n+    }\n }\n \n /// Stores a crate and any number of inlined items from other crates.\n@@ -250,42 +294,19 @@ impl<'ast> Map<'ast> {\n         if !self.is_inlined_node_id(id) {\n             let mut last_expr = None;\n             loop {\n-                match map[id.as_usize()] {\n-                    EntryItem(_, item) => {\n-                        assert_eq!(id, item.id);\n-                        let def_id = self.local_def_id(id);\n-\n-                        if let Some(last_id) = last_expr {\n-                            // The body of the item may have a separate dep node\n-                            if self.is_item_body(last_id, item) {\n-                                return DepNode::HirBody(def_id);\n-                            }\n-                        }\n-                        return DepNode::Hir(def_id);\n-                    }\n-\n-                    EntryTraitItem(_, item) => {\n-                        let def_id = self.local_def_id(id);\n-\n-                        if let Some(last_id) = last_expr {\n-                            // The body of the item may have a separate dep node\n-                            if self.is_trait_item_body(last_id, item) {\n-                                return DepNode::HirBody(def_id);\n-                            }\n-                        }\n-                        return DepNode::Hir(def_id);\n-                    }\n-\n-                    EntryImplItem(_, item) => {\n-                        let def_id = self.local_def_id(id);\n-\n+                let entry = map[id.as_usize()];\n+                match entry {\n+                    EntryItem(..) |\n+                    EntryTraitItem(..) |\n+                    EntryImplItem(..) => {\n                         if let Some(last_id) = last_expr {\n-                            // The body of the item may have a separate dep node\n-                            if self.is_impl_item_body(last_id, item) {\n+                            // The body may have a separate dep node\n+                            if entry.is_body_owner(last_id) {\n+                                let def_id = self.local_def_id(id);\n                                 return DepNode::HirBody(def_id);\n                             }\n                         }\n-                        return DepNode::Hir(def_id);\n+                        return DepNode::Hir(self.local_def_id(id));\n                     }\n \n                     EntryVariant(p, v) => {\n@@ -377,33 +398,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    fn is_item_body(&self, node_id: NodeId, item: &Item) -> bool {\n-        match item.node {\n-            ItemConst(_, body) |\n-            ItemStatic(.., body) |\n-            ItemFn(_, _, _, _, _, body) => body.node_id == node_id,\n-            _ => false\n-        }\n-    }\n-\n-    fn is_trait_item_body(&self, node_id: NodeId, item: &TraitItem) -> bool {\n-        match item.node {\n-            TraitItemKind::Const(_, Some(body)) |\n-            TraitItemKind::Method(_, TraitMethod::Provided(body)) => {\n-                body.node_id == node_id\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    fn is_impl_item_body(&self, node_id: NodeId, item: &ImplItem) -> bool {\n-        match item.node {\n-            ImplItemKind::Const(_, body) |\n-            ImplItemKind::Method(_, body) => body.node_id == node_id,\n-            _ => false\n-        }\n-    }\n-\n     pub fn num_local_def_ids(&self) -> usize {\n         self.definitions.len()\n     }\n@@ -483,6 +477,23 @@ impl<'ast> Map<'ast> {\n         self.forest.krate.body(id)\n     }\n \n+    /// Returns the `NodeId` that corresponds to the definition of\n+    /// which this is the body of, i.e. a `fn`, `const` or `static`\n+    /// item (possibly associated), or a closure, or the body itself\n+    /// for embedded constant expressions (e.g. `N` in `[T; N]`).\n+    pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n+        let parent = self.get_parent_node(node_id);\n+        if self.map.borrow()[parent.as_usize()].is_body_owner(node_id) {\n+            parent\n+        } else {\n+            node_id\n+        }\n+    }\n+\n+    pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n+        self.local_def_id(self.body_owner(id))\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n@@ -726,9 +737,9 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_inlined_item(&self, id: NodeId) -> &'ast InlinedItem {\n+    pub fn expect_inlined_body(&self, id: NodeId) -> &'ast Body {\n         match self.find_entry(id) {\n-            Some(RootInlinedParent(inlined_item)) => inlined_item,\n+            Some(RootInlinedParent(inlined_item)) => &inlined_item.body,\n             _ => bug!(\"expected inlined item, found {}\", self.node_to_string(id)),\n         }\n     }\n@@ -969,24 +980,28 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n     }\n }\n \n-/// Used for items loaded from external crate that are being inlined into this\n+/// Used for bodies loaded from external crate that are being inlined into this\n /// crate.\n-pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n-                              ii: InlinedItem,\n-                              ii_parent_id: NodeId)\n-                              -> &'ast InlinedItem {\n+pub fn map_decoded_body<'ast>(map: &Map<'ast>,\n+                              def_id: DefId,\n+                              body: Body,\n+                              parent_id: NodeId)\n+                              -> &'ast Body {\n     let _ignore = map.forest.dep_graph.in_ignore();\n \n-    let ii = map.forest.inlined_items.alloc(ii);\n+    let ii = map.forest.inlined_items.alloc(InlinedItem {\n+        def_id: def_id,\n+        body: body\n+    });\n \n     let mut collector = NodeCollector::extend(map.krate(),\n                                               ii,\n-                                              ii_parent_id,\n+                                              parent_id,\n                                               mem::replace(&mut *map.map.borrow_mut(), vec![]));\n-    ii.visit(&mut collector);\n+    collector.visit_body(&ii.body);\n     *map.map.borrow_mut() = collector.map;\n \n-    ii\n+    &ii.body\n }\n \n pub trait NodePrinter {\n@@ -1016,8 +1031,6 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             // printing.\n             NodeLocal(_)       => bug!(\"cannot print isolated Local\"),\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n-\n-            NodeInlinedItem(_) => bug!(\"cannot print inlined item\"),\n         }\n     }\n }\n@@ -1131,9 +1144,6 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n-        Some(NodeInlinedItem(_)) => {\n-            format!(\"inlined item {}\", id_str)\n-        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "ff508d2d8194a3b9d39de836e7448c1485bb74d1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -33,6 +33,7 @@\n #![cfg_attr(stage0, feature(item_like_imports))]\n #![feature(libc)]\n #![feature(nonzero)]\n+#![feature(pub_restricted)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -80,9 +81,8 @@ pub mod lint;\n \n pub mod middle {\n     pub mod astconv_util;\n-    pub mod expr_use_visitor; // STAGE0: increase glitch immunity\n+    pub mod expr_use_visitor;\n     pub mod const_val;\n-    pub mod const_qualif;\n     pub mod cstore;\n     pub mod dataflow;\n     pub mod dead;"}, {"sha": "ec98637922ee385d20bbc0f67277bb4ea3bd40f7", "filename": "src/librustc/middle/const_qualif.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_qualif.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Const qualification, from partial to completely promotable.\n-bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable)]\n-    flags ConstQualif: u8 {\n-        // Inner mutability (can not be placed behind a reference) or behind\n-        // &mut in a non-global expression. Can be copied from static memory.\n-        const MUTABLE_MEM        = 1 << 0,\n-        // Constant value with a type that implements Drop. Can be copied\n-        // from static memory, similar to MUTABLE_MEM.\n-        const NEEDS_DROP         = 1 << 1,\n-        // Even if the value can be placed in static memory, copying it from\n-        // there is more expensive than in-place instantiation, and/or it may\n-        // be too large. This applies to [T; N] and everything containing it.\n-        // N.B.: references need to clear this flag to not end up on the stack.\n-        const PREFER_IN_PLACE    = 1 << 2,\n-        // May use more than 0 bytes of memory, doesn't impact the constness\n-        // directly, but is not allowed to be borrowed mutably in a constant.\n-        const NON_ZERO_SIZED     = 1 << 3,\n-        // Actually borrowed, has to always be in static memory. Does not\n-        // propagate, and requires the expression to behave like a 'static\n-        // lvalue. The set of expressions with this flag is the minimum\n-        // that have to be promoted.\n-        const HAS_STATIC_BORROWS = 1 << 4,\n-        // Invalid const for miscellaneous reasons (e.g. not implemented).\n-        const NOT_CONST          = 1 << 5,\n-\n-        // Borrowing the expression won't produce &'static T if any of these\n-        // bits are set, though the value could be copied from static memory\n-        // if `NOT_CONST` isn't set.\n-        const NON_STATIC_BORROWS = ConstQualif::MUTABLE_MEM.bits |\n-                                   ConstQualif::NEEDS_DROP.bits |\n-                                   ConstQualif::NOT_CONST.bits\n-    }\n-}"}, {"sha": "ffd1ad8a0fae1dee139f8cd7f3aab827dd92ca96", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 8, "deletions": 93, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -42,7 +42,6 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n-use hir::intravisit::Visitor;\n use rustc_back::PanicStrategy;\n \n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n@@ -133,86 +132,6 @@ pub struct NativeLibrary {\n     pub foreign_items: Vec<DefIndex>,\n }\n \n-/// The data we save and restore about an inlined item or method.  This is not\n-/// part of the AST that we parse from a file, but it becomes part of the tree\n-/// that we trans.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct InlinedItem {\n-    pub def_id: DefId,\n-    pub body: hir::Body,\n-}\n-\n-/// A borrowed version of `hir::InlinedItem`. This is what's encoded when saving\n-/// a crate; it then gets read as an InlinedItem.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n-pub struct InlinedItemRef<'a> {\n-    pub def_id: DefId,\n-    pub body: &'a hir::Body,\n-}\n-\n-impl<'a, 'tcx> InlinedItemRef<'tcx> {\n-    pub fn from_item(def_id: DefId,\n-                     item: &hir::Item,\n-                     tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                     -> InlinedItemRef<'tcx> {\n-        let body_id = match item.node {\n-            hir::ItemFn(.., body_id) |\n-            hir::ItemConst(_, body_id) => body_id,\n-            _ => bug!(\"InlinedItemRef::from_item wrong kind\")\n-        };\n-        InlinedItemRef {\n-            def_id: def_id,\n-            body: tcx.map.body(body_id),\n-        }\n-    }\n-\n-    pub fn from_trait_item(def_id: DefId,\n-                           item: &hir::TraitItem,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                           -> InlinedItemRef<'tcx> {\n-        let body_id = match item.node {\n-            hir::TraitItemKind::Const(_, Some(body_id)) => body_id,\n-            hir::TraitItemKind::Const(_, None) => {\n-                bug!(\"InlinedItemRef::from_trait_item called for const without body\")\n-            },\n-            _ => bug!(\"InlinedItemRef::from_trait_item wrong kind\")\n-        };\n-        InlinedItemRef {\n-            def_id: def_id,\n-            body: tcx.map.body(body_id),\n-        }\n-    }\n-\n-    pub fn from_impl_item(def_id: DefId,\n-                          item: &hir::ImplItem,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> InlinedItemRef<'tcx> {\n-        let body_id = match item.node {\n-            hir::ImplItemKind::Method(_, body_id) |\n-            hir::ImplItemKind::Const(_, body_id) => body_id,\n-            _ => bug!(\"InlinedItemRef::from_impl_item wrong kind\")\n-        };\n-        InlinedItemRef {\n-            def_id: def_id,\n-            body: tcx.map.body(body_id),\n-        }\n-    }\n-\n-    pub fn visit<V>(&self, visitor: &mut V)\n-        where V: Visitor<'tcx>\n-    {\n-        visitor.visit_body(self.body);\n-    }\n-}\n-\n-impl InlinedItem {\n-    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n-        where V: Visitor<'ast>\n-    {\n-        visitor.visit_body(&self.body);\n-    }\n-}\n-\n pub enum LoadedMacro {\n     MacroRules(ast::MacroDef),\n     ProcMacro(Rc<SyntaxExtension>),\n@@ -329,10 +248,9 @@ pub trait CrateStore<'tcx> {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<(&'tcx InlinedItem, ast::NodeId)>;\n-    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId>;\n-    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId>;\n+    fn maybe_get_item_body<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                               -> Option<&'tcx hir::Body>;\n+    fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool;\n \n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n@@ -499,15 +417,12 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<(&'tcx InlinedItem, ast::NodeId)> {\n-        bug!(\"maybe_get_item_ast\")\n-    }\n-    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId> {\n-        bug!(\"local_node_for_inlined_defid\")\n+    fn maybe_get_item_body<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                               -> Option<&'tcx hir::Body> {\n+        bug!(\"maybe_get_item_body\")\n     }\n-    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId> {\n-        bug!(\"defid_for_inlined_node\")\n+    fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool {\n+        bug!(\"const_is_rvalue_promotable_to_static\")\n     }\n \n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)"}, {"sha": "a3a49c916338e544a047bcd6b14f5fb819e2d066", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -287,7 +287,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn walk_fn(&mut self, body: &hir::Body) {\n+    pub fn consume_body(&mut self, body: &hir::Body) {\n         for arg in &body.arguments {\n             let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n "}, {"sha": "2d88567b8b873228d292229d057aa087a6ff872f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -73,7 +73,6 @@ use self::Aliasability::*;\n use hir::def_id::DefId;\n use hir::map as ast_map;\n use infer::InferCtxt;\n-use middle::const_qualif::ConstQualif;\n use hir::def::{Def, CtorKind};\n use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n@@ -773,23 +772,23 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n-        let qualif = self.tcx().const_qualif_map.borrow().get(&id).cloned()\n-                               .unwrap_or(ConstQualif::NOT_CONST);\n+        let promotable = self.tcx().rvalue_promotable_to_static.borrow().get(&id).cloned()\n+                                   .unwrap_or(false);\n \n         // Only promote `[T; 0]` before an RFC for rvalue promotions\n         // is accepted.\n-        let qualif = match expr_ty.sty {\n-            ty::TyArray(_, 0) => qualif,\n-            _ => ConstQualif::NOT_CONST\n+        let promotable = match expr_ty.sty {\n+            ty::TyArray(_, 0) => true,\n+            _ => promotable & false\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n-        let re = if qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n-            self.temporary_scope(id)\n-        } else {\n+        let re = if promotable {\n             self.tcx().mk_region(ty::ReStatic)\n+        } else {\n+            self.temporary_scope(id)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);"}, {"sha": "cb1fc15c5f68210c704352863b87a7f6a73229ad", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -508,14 +508,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n-    /// Cache used by const_eval when decoding external constants.\n-    /// Contains `None` when the constant has been fetched but doesn't exist.\n-    /// Constains `Some(expr_id, type)` otherwise.\n-    /// `type` is `None` in case it's not a primitive type\n-    pub extern_const_statics: RefCell<DefIdMap<Option<(NodeId, Option<Ty<'tcx>>)>>>,\n-    /// Cache used by const_eval when decoding extern const fns\n-    pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n-\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -537,8 +529,8 @@ pub struct GlobalCtxt<'tcx> {\n     /// Caches the representation hints for struct definitions.\n     repr_hint_cache: RefCell<DepTrackingMap<maps::ReprHints<'tcx>>>,\n \n-    /// Maps Expr NodeId's to their constant qualification.\n-    pub const_qualif_map: RefCell<NodeMap<middle::const_qualif::ConstQualif>>,\n+    /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n+    pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n     pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,\n@@ -787,13 +779,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             used_trait_imports: RefCell::new(NodeSet()),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n-            extern_const_statics: RefCell::new(DefIdMap()),\n-            extern_const_fns: RefCell::new(DefIdMap()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             repr_hint_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            const_qualif_map: RefCell::new(NodeMap()),\n+            rvalue_promotable_to_static: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),"}, {"sha": "dc2214dd34e72141ae4f6a02d59599fcaef22afb", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -201,7 +201,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans: all_loans,\n         param_env: &infcx.parameter_environment\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &infcx).walk_fn(body);\n+    euv::ExprUseVisitor::new(&mut clcx, &infcx).consume_body(body);\n }\n \n #[derive(PartialEq)]"}, {"sha": "34f1ad57c6211e8317a21fa15365030f8db23e1f", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -54,7 +54,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n-    euv::ExprUseVisitor::new(&mut glcx, &infcx).walk_fn(body);\n+    euv::ExprUseVisitor::new(&mut glcx, &infcx).consume_body(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;"}, {"sha": "f65a3b46e5a8ead24da96f7506b54f452a8d078c", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 17, "deletions": 75, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -17,7 +17,6 @@ use self::EvalHint::*;\n \n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n@@ -139,30 +138,17 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_statics.borrow().get(&def_id) {\n-            Some(&None) => return None,\n-            Some(&Some((expr_id, ty))) => {\n-                return Some((tcx.map.expect_expr(expr_id), ty));\n-            }\n-            None => {}\n-        }\n-        let mut used_substs = false;\n-        let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem { ref body, .. }, _)) => {\n-                Some((&body.value, Some(tcx.sess.cstore.item_type(tcx, def_id))))\n-            }\n-            _ => None\n-        };\n-        let expr_ty = match tcx.sess.cstore.describe_def(def_id) {\n+        let expr_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n+            (&body.value, Some(tcx.sess.cstore.item_type(tcx, def_id)))\n+        });\n+        match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n                 let trait_id = tcx.sess.cstore.trait_of_item(def_id);\n                 // As mentioned in the comments above for in-crate\n                 // constants, we only try to find the expression for a\n                 // trait-associated const if the caller gives us the\n                 // substitutions for the reference to it.\n                 if let Some(trait_id) = trait_id {\n-                    used_substs = true;\n-\n                     if let Some(substs) = substs {\n                         resolve_trait_associated_const(tcx, def_id, expr_ty, trait_id, substs)\n                     } else {\n@@ -174,70 +160,27 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             },\n             Some(Def::Const(..)) => expr_ty,\n             _ => None\n-        };\n-        // If we used the substitutions, particularly to choose an impl\n-        // of a trait-associated const, don't cache that, because the next\n-        // lookup with the same def_id may yield a different result.\n-        if !used_substs {\n-            tcx.extern_const_statics\n-               .borrow_mut()\n-               .insert(def_id, expr_ty.map(|(e, t)| (e.id, t)));\n         }\n-        expr_ty\n     }\n }\n \n-fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 def_id: DefId)\n-                                                 -> Option<ast::NodeId> {\n-    match tcx.extern_const_fns.borrow().get(&def_id) {\n-        Some(&ast::DUMMY_NODE_ID) => return None,\n-        Some(&fn_id) => return Some(fn_id),\n-        None => {}\n-    }\n-\n-    if !tcx.sess.cstore.is_const_fn(def_id) {\n-        tcx.extern_const_fns.borrow_mut().insert(def_id, ast::DUMMY_NODE_ID);\n-        return None;\n-    }\n-\n-    let fn_id = tcx.sess.cstore.maybe_get_item_ast(tcx, def_id).map(|t| t.1);\n-    tcx.extern_const_fns.borrow_mut().insert(def_id,\n-                                             fn_id.unwrap_or(ast::DUMMY_NODE_ID));\n-    fn_id\n-}\n-\n-pub enum ConstFnNode<'tcx> {\n-    Local(FnLikeNode<'tcx>),\n-    Inlined(&'tcx InlinedItem)\n-}\n-\n-pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                       -> Option<ConstFnNode<'tcx>>\n+fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                                   -> Option<&'tcx hir::Body>\n {\n-    let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        node_id\n-    } else {\n-        if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n-            if let ast_map::NodeInlinedItem(ii) = tcx.map.get(fn_id) {\n-                return Some(ConstFnNode::Inlined(ii));\n+    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+        FnLikeNode::from_node(tcx.map.get(node_id)).and_then(|fn_like| {\n+            if fn_like.constness() == hir::Constness::Const {\n+                Some(tcx.map.body(fn_like.body()))\n             } else {\n-                bug!(\"Got const fn from external crate, but it's not inlined\")\n+                None\n             }\n+        })\n+    } else {\n+        if tcx.sess.cstore.is_const_fn(def_id) {\n+            tcx.sess.cstore.maybe_get_item_body(tcx, def_id)\n         } else {\n-            return None;\n+            None\n         }\n-    };\n-\n-    let fn_like = match FnLikeNode::from_node(tcx.map.get(fn_id)) {\n-        Some(fn_like) => fn_like,\n-        None => return None\n-    };\n-\n-    if fn_like.constness() == hir::Constness::Const {\n-        Some(ConstFnNode::Local(fn_like))\n-    } else {\n-        None\n     }\n }\n \n@@ -871,8 +814,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               callee => signal!(e, CallOn(callee)),\n           };\n           let body = match lookup_const_fn_by_id(tcx, did) {\n-              Some(ConstFnNode::Inlined(ii)) => &ii.body,\n-              Some(ConstFnNode::Local(fn_like)) => tcx.map.body(fn_like.body()),\n+              Some(body) => body,\n               None => signal!(e, NonConstPath),\n           };\n "}, {"sha": "54824fc51d6611a839e0b59e6c98957faa54819c", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -16,8 +16,7 @@ use cstore::CrateMetadata;\n use encoder::EncodeContext;\n use schema::*;\n \n-use rustc::middle::cstore::{InlinedItem, InlinedItemRef};\n-use rustc::middle::const_qualif::ConstQualif;\n+use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TyCtxt, Ty};\n@@ -29,8 +28,9 @@ use rustc_serialize::Encodable;\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ast<'tcx> {\n     id_range: IdRange,\n-    item: Lazy<InlinedItem>,\n+    body: Lazy<hir::Body>,\n     side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>,\n+    pub rvalue_promotable_to_static: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -39,31 +39,36 @@ enum TableEntry<'tcx> {\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n     Adjustment(ty::adjustment::Adjustment<'tcx>),\n-    ConstQualif(ConstQualif),\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    pub fn encode_inlined_item(&mut self, ii: InlinedItemRef<'tcx>) -> Lazy<Ast<'tcx>> {\n+    pub fn encode_body(&mut self, body: hir::BodyId) -> Lazy<Ast<'tcx>> {\n+        let body = self.tcx.map.body(body);\n+\n         let mut id_visitor = IdRangeComputingVisitor::new(&self.tcx.map);\n-        ii.visit(&mut id_visitor);\n+        id_visitor.visit_body(body);\n \n-        let ii_pos = self.position();\n-        ii.encode(self).unwrap();\n+        let body_pos = self.position();\n+        body.encode(self).unwrap();\n \n         let tables_pos = self.position();\n         let tables_count = {\n             let mut visitor = SideTableEncodingIdVisitor {\n                 ecx: self,\n                 count: 0,\n             };\n-            ii.visit(&mut visitor);\n+            visitor.visit_body(body);\n             visitor.count\n         };\n \n+        let rvalue_promotable_to_static =\n+            self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n+\n         self.lazy(&Ast {\n             id_range: id_visitor.result(),\n-            item: Lazy::with_position(ii_pos),\n+            body: Lazy::with_position(body_pos),\n             side_tables: LazySeq::with_position_and_length(tables_pos, tables_count),\n+            rvalue_promotable_to_static: rvalue_promotable_to_static\n         })\n     }\n }\n@@ -94,18 +99,17 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n         encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n         encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n         encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n-        encode(tcx.const_qualif_map.borrow().get(&id).cloned().map(TableEntry::ConstQualif));\n     }\n }\n \n-/// Decodes an item from its AST in the cdata's metadata and adds it to the\n+/// Decodes an item's body from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n-pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ast: Ast<'tcx>,\n-                                     orig_did: DefId)\n-                                     -> &'tcx InlinedItem {\n-    debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n+pub fn decode_body<'a, 'tcx>(cdata: &CrateMetadata,\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             def_id: DefId,\n+                             ast: Ast<'tcx>)\n+                             -> &'tcx hir::Body {\n+    debug!(\"> Decoding inlined fn: {}\", tcx.item_path_str(def_id));\n \n     let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n     let start = tcx.sess.reserve_node_ids(cnt);\n@@ -115,12 +119,6 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                          max: ast::NodeId::new(start.as_usize() + cnt),\n                      }];\n \n-    let ii = ast.item.decode((cdata, tcx, id_ranges));\n-    let item_node_id = tcx.sess.next_node_id();\n-    let ii = ast_map::map_decoded_item(&tcx.map,\n-                                       ii,\n-                                       item_node_id);\n-\n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n             TableEntry::TypeRelativeDef(def) => {\n@@ -135,11 +133,9 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n             TableEntry::Adjustment(adj) => {\n                 tcx.tables.borrow_mut().adjustments.insert(id, adj);\n             }\n-            TableEntry::ConstQualif(qualif) => {\n-                tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n-            }\n         }\n     }\n \n-    ii\n+    let body = ast.body.decode((cdata, tcx, id_ranges));\n+    ast_map::map_decoded_body(&tcx.map, def_id, body, tcx.sess.next_node_id())\n }"}, {"sha": "aab4034b7705aee99a5747a42d74bcc44a8e4e15", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -88,13 +88,6 @@ pub struct CrateMetadata {\n     pub dllimport_foreign_items: FxHashSet<DefIndex>,\n }\n \n-pub struct CachedInlinedItem {\n-    /// The NodeId of the RootInlinedParent HIR map entry\n-    pub inlined_root: ast::NodeId,\n-    /// The local NodeId of the inlined entity\n-    pub item_id: ast::NodeId,\n-}\n-\n pub struct CStore {\n     pub dep_graph: DepGraph,\n     metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n@@ -104,8 +97,7 @@ pub struct CStore {\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub inlined_item_cache: RefCell<DefIdMap<Option<CachedInlinedItem>>>,\n-    pub defid_for_inlined_node: RefCell<NodeMap<DefId>>,\n+    pub inlined_item_cache: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n@@ -121,7 +113,6 @@ impl CStore {\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n             inlined_item_cache: RefCell::new(FxHashMap()),\n-            defid_for_inlined_node: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "a5173e00c7241da252714b138374f4b28b59ab45", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 21, "deletions": 78, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -13,7 +13,7 @@ use encoder;\n use locator;\n use schema;\n \n-use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n+use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n@@ -427,94 +427,37 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n-    fn maybe_get_item_ast<'a>(&'tcx self,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> Option<(&'tcx InlinedItem, ast::NodeId)>\n+    fn maybe_get_item_body<'a>(&'tcx self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               def_id: DefId)\n+                               -> Option<&'tcx hir::Body>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n \n-        match self.inlined_item_cache.borrow().get(&def_id) {\n-            Some(&None) => {\n-                return None; // Not inlinable\n-            }\n-            Some(&Some(ref cached_inlined_item)) => {\n+        if let Some(&cached) = self.inlined_item_cache.borrow().get(&def_id) {\n+            return cached.map(|root_id| {\n                 // Already inline\n-                debug!(\"maybe_get_item_ast({}): already inline as node id {}\",\n-                          tcx.item_path_str(def_id), cached_inlined_item.item_id);\n-                return Some((tcx.map.expect_inlined_item(cached_inlined_item.inlined_root),\n-                             cached_inlined_item.item_id));\n-            }\n-            None => {\n-                // Not seen yet\n-            }\n+                debug!(\"maybe_get_item_body({}): already inline\", tcx.item_path_str(def_id));\n+                tcx.map.expect_inlined_body(root_id)\n+            });\n         }\n \n-        debug!(\"maybe_get_item_ast({}): inlining item\", tcx.item_path_str(def_id));\n-\n-        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_ast(tcx, def_id.index);\n-\n-        let cache_inlined_item = |original_def_id, inlined_item_id, inlined_root_node_id| {\n-            let cache_entry = cstore::CachedInlinedItem {\n-                inlined_root: inlined_root_node_id,\n-                item_id: inlined_item_id,\n-            };\n-            self.inlined_item_cache\n-                .borrow_mut()\n-                .insert(original_def_id, Some(cache_entry));\n-            self.defid_for_inlined_node\n-                .borrow_mut()\n-                .insert(inlined_item_id, original_def_id);\n-        };\n+        debug!(\"maybe_get_item_body({}): inlining item\", tcx.item_path_str(def_id));\n \n-        let find_inlined_item_root = |inlined_item_id| {\n-            let mut node = inlined_item_id;\n+        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index);\n \n-            // If we can't find the inline root after a thousand hops, we can\n-            // be pretty sure there's something wrong with the HIR map.\n-            for _ in 0 .. 1000 {\n-                let parent_node = tcx.map.get_parent_node(node);\n-                if parent_node == node {\n-                    return node;\n-                }\n-                node = parent_node;\n-            }\n-            bug!(\"cycle in HIR map parent chain\")\n-        };\n+        self.inlined_item_cache.borrow_mut().insert(def_id, inlined.map(|body| {\n+            let root_id = tcx.map.get_parent_node(body.value.id);\n+            assert_eq!(tcx.map.get_parent_node(root_id), root_id);\n+            root_id\n+        }));\n \n-        match inlined {\n-            None => {\n-                self.inlined_item_cache\n-                    .borrow_mut()\n-                    .insert(def_id, None);\n-            }\n-            Some(&InlinedItem { ref body, .. }) => {\n-                let inlined_root_node_id = find_inlined_item_root(body.value.id);\n-                cache_inlined_item(def_id, inlined_root_node_id, inlined_root_node_id);\n-            }\n-        }\n-\n-        // We can be sure to hit the cache now\n-        return self.maybe_get_item_ast(tcx, def_id);\n+        inlined\n     }\n \n-    fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId> {\n-        assert!(!def_id.is_local());\n-        match self.inlined_item_cache.borrow().get(&def_id) {\n-            Some(&Some(ref cached_inlined_item)) => {\n-                Some(cached_inlined_item.item_id)\n-            }\n-            Some(&None) => {\n-                None\n-            }\n-            _ => {\n-                bug!(\"Trying to lookup inlined NodeId for unexpected item\");\n-            }\n-        }\n-    }\n-\n-    fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId> {\n-        self.defid_for_inlined_node.borrow().get(&node_id).map(|x| *x)\n+    fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).const_is_rvalue_promotable_to_static(def.index)\n     }\n \n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx> {"}, {"sha": "81f638259198f0748551264cb4eb136ef34b91ae", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -10,15 +10,15 @@\n \n // Decoding metadata from a single crate's metadata\n \n-use astencode::decode_inlined_item;\n+use astencode::decode_body;\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n-use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n+use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n@@ -819,20 +819,21 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn maybe_get_item_ast(&self,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: DefIndex)\n-                              -> Option<&'tcx InlinedItem> {\n-        debug!(\"Looking up item: {:?}\", id);\n+    pub fn maybe_get_item_body(&self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               id: DefIndex)\n+                               -> Option<&'tcx hir::Body> {\n         if self.is_proc_macro(id) { return None; }\n-        let item_doc = self.entry(id);\n-        let item_did = self.local_def_id(id);\n-        item_doc.ast.map(|ast| {\n-            let ast = ast.decode(self);\n-            decode_inlined_item(self, tcx, ast, item_did)\n+        self.entry(id).ast.map(|ast| {\n+            decode_body(self, tcx, self.local_def_id(id), ast.decode(self))\n         })\n     }\n \n+    pub fn const_is_rvalue_promotable_to_static(&self, id: DefIndex) -> bool {\n+        self.entry(id).ast.expect(\"const item missing `ast`\")\n+            .decode(self).rvalue_promotable_to_static\n+    }\n+\n     pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()"}, {"sha": "72dcb4ba9a3a8f3f1ab460f68b133cfc773c9ca4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -12,8 +12,7 @@ use cstore;\n use index::Index;\n use schema::*;\n \n-use rustc::middle::cstore::{InlinedItemRef, LinkMeta};\n-use rustc::middle::cstore::{LinkagePreference, NativeLibrary};\n+use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary};\n use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -495,13 +494,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if let hir::TraitItemKind::Const(_, Some(_)) = ast_item.node {\n-                // We only save the HIR for associated consts with bodies\n-                // (InlinedItemRef::from_trait_item panics otherwise)\n-                let trait_def_id = trait_item.container.id();\n-                Some(self.encode_inlined_item(\n-                    InlinedItemRef::from_trait_item(trait_def_id, ast_item, tcx)\n-                ))\n+            ast: if let hir::TraitItemKind::Const(_, Some(body)) = ast_item.node {\n+                Some(self.encode_body(body))\n             } else {\n                 None\n             },\n@@ -510,12 +504,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        let tcx = self.tcx;\n-\n         let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.map.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n-        let impl_def_id = impl_item.container.id();\n \n         let container = match impl_item.defaultness {\n             hir::Defaultness::Default { has_value: true } => AssociatedContainer::ImplDefault,\n@@ -544,17 +535,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::AssociatedKind::Type => EntryKind::AssociatedType(container)\n         };\n \n-        let (ast, mir) = if impl_item.kind == ty::AssociatedKind::Const {\n-            (true, true)\n-        } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n+        let (ast, mir) = if let hir::ImplItemKind::Const(_, body) = ast_item.node {\n+            (Some(body), true)\n+        } else if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n             let generics = self.tcx.item_generics(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n             let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n             let is_const_fn = sig.constness == hir::Constness::Const;\n+            let ast = if is_const_fn { Some(body) } else { None };\n             let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-            (is_const_fn, needs_inline || is_const_fn || always_encode_mir)\n+            (ast, needs_inline || is_const_fn || always_encode_mir)\n         } else {\n-            (false, false)\n+            (None, false)\n         };\n \n         Entry {\n@@ -572,13 +564,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if ast {\n-                Some(self.encode_inlined_item(\n-                    InlinedItemRef::from_impl_item(impl_def_id, ast_item, tcx)\n-                ))\n-            } else {\n-                None\n-            },\n+            ast: ast.map(|body| self.encode_body(body)),\n             mir: if mir { self.encode_mir(def_id) } else { None },\n         }\n     }\n@@ -809,11 +795,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             },\n \n             ast: match item.node {\n-                hir::ItemConst(..) |\n-                hir::ItemFn(_, _, hir::Constness::Const, ..) => {\n-                    Some(self.encode_inlined_item(\n-                        InlinedItemRef::from_item(def_id, item, tcx)\n-                    ))\n+                hir::ItemConst(_, body) |\n+                hir::ItemFn(_, _, hir::Constness::Const, _, _, body) => {\n+                    Some(self.encode_body(body))\n                 }\n                 _ => None,\n             },"}, {"sha": "d1d9a201567bbc6ba022672d3134019f96e9f459", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 133, "deletions": 400, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -26,94 +26,45 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n-use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, compare_lit_exprs};\n-use rustc_const_eval::{ConstFnNode, eval_const_expr_partial, lookup_const_by_id};\n+use rustc_const_eval::{ConstEvalErr, compare_lit_exprs};\n+use rustc_const_eval::{eval_const_expr_partial};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n use rustc_const_eval::ErrKind::UnresolvedPath;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n+use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::NodeMap;\n-use rustc::middle::const_qualif::ConstQualif;\n+use rustc::util::nodemap::NodeSet;\n use rustc::lint::builtin::CONST_ERR;\n \n use rustc::hir::{self, PatKind};\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-enum Mode {\n-    Const,\n-    ConstFn,\n-    Static,\n-    StaticMut,\n-\n-    // An expression that occurs outside of any constant context\n-    // (i.e. `const`, `static`, array lengths, etc.). The value\n-    // can be variable at runtime, but will be promotable to\n-    // static memory if we can prove it is actually constant.\n-    Var,\n-}\n+use std::mem;\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mode: Mode,\n-    qualif: ConstQualif,\n-    rvalue_borrows: NodeMap<hir::Mutability>,\n+    in_fn: bool,\n+    promotable: bool,\n+    mut_rvalue_borrows: NodeSet,\n+    param_env: ty::ParameterEnvironment<'tcx>,\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n-    fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R\n-        where F: FnOnce(&mut CheckCrateVisitor<'a, 'gcx>) -> R\n-    {\n-        let (old_mode, old_qualif) = (self.mode, self.qualif);\n-        self.mode = mode;\n-        self.qualif = ConstQualif::empty();\n-        let r = f(self);\n-        self.mode = old_mode;\n-        self.qualif = old_qualif;\n-        r\n-    }\n-\n-    fn with_euv<F, R>(&mut self, item_id: Option<ast::NodeId>, f: F) -> R\n-        where F: for<'b, 'tcx> FnOnce(&mut euv::ExprUseVisitor<'b, 'gcx, 'tcx>) -> R\n-    {\n-        let param_env = match item_id {\n-            Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n-            None => self.tcx.empty_parameter_environment(),\n-        };\n-\n-        self.tcx\n-            .infer_ctxt(None, Some(param_env), Reveal::NotSpecializable)\n-            .enter(|infcx| f(&mut euv::ExprUseVisitor::new(self, &infcx)))\n-    }\n-\n-    fn global_body(&mut self, mode: Mode, body: hir::BodyId) -> ConstQualif {\n-        let expr = &self.tcx.map.body(body).value;\n-        self.global_expr(mode, expr)\n-    }\n-\n-    fn global_expr(&mut self, mode: Mode, expr: &'gcx hir::Expr) -> ConstQualif {\n-        assert!(mode != Mode::Var);\n-        match self.tcx.const_qualif_map.borrow_mut().entry(expr.id) {\n-            Entry::Occupied(entry) => return *entry.get(),\n-            Entry::Vacant(entry) => {\n-                // Prevent infinite recursion on re-entry.\n-                entry.insert(ConstQualif::empty());\n-            }\n-        }\n+    fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n         if let Err(err) = eval_const_expr_partial(self.tcx, expr, ExprTypeChecked, None) {\n             match err.kind {\n                 UnimplementedConstVal(_) => {}\n@@ -129,184 +80,78 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 }\n             }\n         }\n-        self.with_mode(mode, |this| {\n-            this.with_euv(None, |euv| euv.consume_expr(expr));\n-            this.visit_expr(expr);\n-            this.qualif\n-        })\n     }\n \n-    fn fn_like(&mut self,\n-               fk: FnKind<'gcx>,\n-               fd: &'gcx hir::FnDecl,\n-               b: hir::BodyId,\n-               s: Span,\n-               fn_id: ast::NodeId)\n-               -> ConstQualif {\n-        match self.tcx.const_qualif_map.borrow_mut().entry(fn_id) {\n-            Entry::Occupied(entry) => return *entry.get(),\n-            Entry::Vacant(entry) => {\n-                // Prevent infinite recursion on re-entry.\n-                entry.insert(ConstQualif::empty());\n-            }\n+    // Adds the worst effect out of all the values of one type.\n+    fn add_type(&mut self, ty: Ty<'gcx>) {\n+        if ty.type_contents(self.tcx).interior_unsafe() {\n+            self.promotable = false;\n         }\n \n-        let mode = match fk {\n-            FnKind::ItemFn(_, _, _, hir::Constness::Const, ..)\n-                => Mode::ConstFn,\n-            FnKind::Method(_, m, ..) => {\n-                if m.constness == hir::Constness::Const {\n-                    Mode::ConstFn\n-                } else {\n-                    Mode::Var\n-                }\n-            }\n-            _ => Mode::Var,\n-        };\n-\n-        let qualif = self.with_mode(mode, |this| {\n-            let body = this.tcx.map.body(b);\n-            this.with_euv(Some(fn_id), |euv| euv.walk_fn(body));\n-            intravisit::walk_fn(this, fk, fd, b, s, fn_id);\n-            this.qualif\n-        });\n-\n-        // Keep only bits that aren't affected by function body (NON_ZERO_SIZED),\n-        // and bits that don't change semantics, just optimizations (PREFER_IN_PLACE).\n-        let qualif = qualif & (ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n-\n-        self.tcx.const_qualif_map.borrow_mut().insert(fn_id, qualif);\n-        qualif\n-    }\n-\n-    fn add_qualif(&mut self, qualif: ConstQualif) {\n-        self.qualif = self.qualif | qualif;\n-    }\n-\n-    /// Returns true if the call is to a const fn or method.\n-    fn handle_const_fn_call(&mut self, _expr: &hir::Expr, def_id: DefId, ret_ty: Ty<'gcx>) -> bool {\n-        match lookup_const_fn_by_id(self.tcx, def_id) {\n-            Some(ConstFnNode::Local(fn_like)) => {\n-                let qualif = self.fn_like(fn_like.kind(),\n-                                          fn_like.decl(),\n-                                          fn_like.body(),\n-                                          fn_like.span(),\n-                                          fn_like.id());\n-\n-                self.add_qualif(qualif);\n-\n-                if ret_ty.type_contents(self.tcx).interior_unsafe() {\n-                    self.add_qualif(ConstQualif::MUTABLE_MEM);\n-                }\n-\n-                true\n-            },\n-            Some(ConstFnNode::Inlined(ii)) => {\n-                let node_id = ii.body.value.id;\n-\n-                let qualif = match self.tcx.const_qualif_map.borrow_mut().entry(node_id) {\n-                    Entry::Occupied(entry) => *entry.get(),\n-                    _ => bug!(\"const qualif entry missing for inlined item\")\n-                };\n-\n-                self.add_qualif(qualif);\n-\n-                if ret_ty.type_contents(self.tcx).interior_unsafe() {\n-                    self.add_qualif(ConstQualif::MUTABLE_MEM);\n-                }\n-\n-                true\n-            },\n-            None => false\n+        if self.tcx.type_needs_drop_given_env(ty, &self.param_env) {\n+            self.promotable = false;\n         }\n     }\n \n-    fn record_borrow(&mut self, id: ast::NodeId, mutbl: hir::Mutability) {\n-        match self.rvalue_borrows.entry(id) {\n-            Entry::Occupied(mut entry) => {\n-                // Merge the two borrows, taking the most demanding\n-                // one, mutability-wise.\n-                if mutbl == hir::MutMutable {\n-                    entry.insert(mutbl);\n-                }\n-            }\n-            Entry::Vacant(entry) => {\n-                entry.insert(mutbl);\n-            }\n-        }\n+    fn handle_const_fn_call(&mut self, def_id: DefId, ret_ty: Ty<'gcx>) {\n+        self.add_type(ret_ty);\n+\n+        self.promotable &= if let Some(fn_id) = self.tcx.map.as_local_node_id(def_id) {\n+            FnLikeNode::from_node(self.tcx.map.get(fn_id)).map_or(false, |fn_like| {\n+                fn_like.constness() == hir::Constness::Const\n+            })\n+        } else {\n+            self.tcx.sess.cstore.is_const_fn(def_id)\n+        };\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    fn visit_item(&mut self, i: &'tcx hir::Item) {\n-        debug!(\"visit_item(item={})\", self.tcx.map.node_to_string(i.id));\n-        assert_eq!(self.mode, Mode::Var);\n-        match i.node {\n-            hir::ItemStatic(_, hir::MutImmutable, expr) => {\n-                self.global_body(Mode::Static, expr);\n-            }\n-            hir::ItemStatic(_, hir::MutMutable, expr) => {\n-                self.global_body(Mode::StaticMut, expr);\n-            }\n-            hir::ItemConst(_, expr) => {\n-                self.global_body(Mode::Const, expr);\n-            }\n-            hir::ItemEnum(ref enum_definition, _) => {\n-                for var in &enum_definition.variants {\n-                    if let Some(ex) = var.node.disr_expr {\n-                        self.global_body(Mode::Const, ex);\n-                    }\n-                }\n-            }\n-            _ => {\n-                intravisit::walk_item(self, i);\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        match self.tcx.rvalue_promotable_to_static.borrow_mut().entry(body.node_id) {\n+            Entry::Occupied(_) => return,\n+            Entry::Vacant(entry) => {\n+                // Prevent infinite recursion on re-entry.\n+                entry.insert(false);\n             }\n         }\n-    }\n \n-    fn visit_trait_item(&mut self, t: &'tcx hir::TraitItem) {\n-        match t.node {\n-            hir::TraitItemKind::Const(_, default) => {\n-                if let Some(expr) = default {\n-                    self.global_body(Mode::Const, expr);\n-                } else {\n-                    intravisit::walk_trait_item(self, t);\n-                }\n-            }\n-            _ => self.with_mode(Mode::Var, |v| intravisit::walk_trait_item(v, t)),\n-        }\n-    }\n+        let item_id = self.tcx.map.body_owner(body);\n \n-    fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n-        match i.node {\n-            hir::ImplItemKind::Const(_, expr) => {\n-                self.global_body(Mode::Const, expr);\n-            }\n-            _ => self.with_mode(Mode::Var, |v| intravisit::walk_impl_item(v, i)),\n+        let outer_in_fn = self.in_fn;\n+        self.in_fn = match MirSource::from_node(self.tcx, item_id) {\n+            MirSource::Fn(_) => true,\n+            _ => false\n+        };\n+\n+        let body = self.tcx.map.body(body);\n+        if !self.in_fn {\n+            self.check_const_eval(&body.value);\n         }\n-    }\n \n-    fn visit_fn(&mut self,\n-                fk: FnKind<'tcx>,\n-                fd: &'tcx hir::FnDecl,\n-                b: hir::BodyId,\n-                s: Span,\n-                fn_id: ast::NodeId) {\n-        self.fn_like(fk, fd, b, s, fn_id);\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n+        let outer_param_env = mem::replace(&mut self.param_env, param_env);\n+        self.tcx.infer_ctxt(None, Some(self.param_env.clone()), Reveal::NotSpecializable)\n+            .enter(|infcx| euv::ExprUseVisitor::new(self, &infcx).consume_body(body));\n+\n+        self.visit_body(body);\n+\n+        self.param_env = outer_param_env;\n+        self.in_fn = outer_in_fn;\n     }\n \n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         match p.node {\n             PatKind::Lit(ref lit) => {\n-                self.global_expr(Mode::Const, &lit);\n+                self.check_const_eval(lit);\n             }\n             PatKind::Range(ref start, ref end) => {\n-                self.global_expr(Mode::Const, &start);\n-                self.global_expr(Mode::Const, &end);\n+                self.check_const_eval(start);\n+                self.check_const_eval(end);\n \n                 match compare_lit_exprs(self.tcx, p.span, start, end) {\n                     Ok(Ordering::Less) |\n@@ -320,119 +165,60 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     Err(ErrorReported) => {}\n                 }\n             }\n-            _ => intravisit::walk_pat(self, p),\n+            _ => {}\n         }\n+        intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n-        // Check all statements in the block\n-        for stmt in &block.stmts {\n-            match stmt.node {\n-                hir::StmtDecl(ref decl, _) => {\n-                    match decl.node {\n-                        hir::DeclLocal(_) => {}\n-                        // Item statements are allowed\n-                        hir::DeclItem(_) => continue,\n+    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n+        match stmt.node {\n+            hir::StmtDecl(ref decl, _) => {\n+                match decl.node {\n+                    hir::DeclLocal(_) => {\n+                        self.promotable = false;\n                     }\n+                    // Item statements are allowed\n+                    hir::DeclItem(_) => {}\n                 }\n-                hir::StmtExpr(..) => {}\n-                hir::StmtSemi(..) => {}\n             }\n-            self.add_qualif(ConstQualif::NOT_CONST);\n+            hir::StmtExpr(..) |\n+            hir::StmtSemi(..) => {\n+                self.promotable = false;\n+            }\n         }\n-        intravisit::walk_block(self, block);\n+        intravisit::walk_stmt(self, stmt);\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n-        let mut outer = self.qualif;\n-        self.qualif = ConstQualif::empty();\n+        let outer = self.promotable;\n+        self.promotable = true;\n \n         let node_ty = self.tcx.tables().node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n-        // Special-case some expressions to avoid certain flags bubbling up.\n-        match ex.node {\n-            hir::ExprCall(ref callee, ref args) => {\n-                for arg in args {\n-                    self.visit_expr(&arg)\n+        if let hir::ExprMatch(ref discr, ref arms, _) = ex.node {\n+            // Compute the most demanding borrow from all the arms'\n+            // patterns and set that on the discriminator.\n+            let mut mut_borrow = false;\n+            for pat in arms.iter().flat_map(|arm| &arm.pats) {\n+                if self.mut_rvalue_borrows.remove(&pat.id) {\n+                    mut_borrow = true;\n                 }\n-\n-                let inner = self.qualif;\n-                self.visit_expr(&callee);\n-                // The callee's size doesn't count in the call.\n-                let added = self.qualif - inner;\n-                self.qualif = inner | (added - ConstQualif::NON_ZERO_SIZED);\n             }\n-            hir::ExprRepeat(ref element, _) => {\n-                self.visit_expr(&element);\n-                // The count is checked elsewhere (typeck).\n-                let count = match node_ty.sty {\n-                    ty::TyArray(_, n) => n,\n-                    _ => bug!(),\n-                };\n-                // [element; 0] is always zero-sized.\n-                if count == 0 {\n-                    self.qualif.remove(ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n-                }\n+            if mut_borrow {\n+                self.mut_rvalue_borrows.insert(discr.id);\n             }\n-            hir::ExprMatch(ref discr, ref arms, _) => {\n-                // Compute the most demanding borrow from all the arms'\n-                // patterns and set that on the discriminator.\n-                let mut borrow = None;\n-                for pat in arms.iter().flat_map(|arm| &arm.pats) {\n-                    let pat_borrow = self.rvalue_borrows.remove(&pat.id);\n-                    match (borrow, pat_borrow) {\n-                        (None, _) |\n-                        (_, Some(hir::MutMutable)) => {\n-                            borrow = pat_borrow;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                if let Some(mutbl) = borrow {\n-                    self.record_borrow(discr.id, mutbl);\n-                }\n-                intravisit::walk_expr(self, ex);\n-            }\n-            _ => intravisit::walk_expr(self, ex),\n         }\n \n+        intravisit::walk_expr(self, ex);\n+\n         // Handle borrows on (or inside the autorefs of) this expression.\n-        match self.rvalue_borrows.remove(&ex.id) {\n-            Some(hir::MutImmutable) => {\n-                // Constants cannot be borrowed if they contain interior mutability as\n-                // it means that our \"silent insertion of statics\" could change\n-                // initializer values (very bad).\n-                // If the type doesn't have interior mutability, then `ConstQualif::MUTABLE_MEM` has\n-                // propagated from another error, so erroring again would be just noise.\n-                let tc = node_ty.type_contents(self.tcx);\n-                if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n-                    outer = outer | ConstQualif::NOT_CONST;\n-                }\n-                // If the reference has to be 'static, avoid in-place initialization\n-                // as that will end up pointing to the stack instead.\n-                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n-                    self.qualif = self.qualif - ConstQualif::PREFER_IN_PLACE;\n-                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n-                }\n-            }\n-            Some(hir::MutMutable) => {\n-                // `&mut expr` means expr could be mutated, unless it's zero-sized.\n-                if self.qualif.intersects(ConstQualif::NON_ZERO_SIZED) {\n-                    if self.mode == Mode::Var {\n-                        outer = outer | ConstQualif::NOT_CONST;\n-                        self.add_qualif(ConstQualif::MUTABLE_MEM);\n-                    }\n-                }\n-                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n-                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n-                }\n-            }\n-            None => {}\n+        if self.mut_rvalue_borrows.remove(&ex.id) {\n+            self.promotable = false;\n         }\n \n-        if self.mode == Mode::Var && !self.qualif.intersects(ConstQualif::NOT_CONST) {\n+        if self.in_fn && self.promotable {\n             match eval_const_expr_partial(self.tcx, ex, ExprTypeChecked, None) {\n                 Ok(_) => {}\n                 Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n@@ -453,9 +239,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             }\n         }\n \n-        self.tcx.const_qualif_map.borrow_mut().insert(ex.id, self.qualif);\n-        // Don't propagate certain flags.\n-        self.qualif = outer | (self.qualif - ConstQualif::HAS_STATIC_BORROWS);\n+        self.tcx.rvalue_promotable_to_static.borrow_mut().insert(ex.id, self.promotable);\n+        self.promotable &= outer;\n     }\n }\n \n@@ -468,7 +253,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyAdt(def, _) if def.has_dtor() => {\n-            v.add_qualif(ConstQualif::NEEDS_DROP);\n+            v.promotable = false;\n         }\n         _ => {}\n     }\n@@ -478,17 +263,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n         hir::ExprIndex(..) if v.tcx.tables().method_map.contains_key(&method_call) => {\n-            v.add_qualif(ConstQualif::NOT_CONST);\n+            v.promotable = false;\n         }\n         hir::ExprBox(_) => {\n-            v.add_qualif(ConstQualif::NOT_CONST);\n+            v.promotable = false;\n         }\n         hir::ExprUnary(op, ref inner) => {\n             match v.tcx.tables().node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n-                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    v.promotable = false;\n                 }\n                 _ => {}\n             }\n@@ -500,7 +285,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n                             op.node == hir::BiGe || op.node == hir::BiGt);\n \n-                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    v.promotable = false;\n                 }\n                 _ => {}\n             }\n@@ -510,41 +295,32 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             match v.tcx.cast_kinds.borrow().get(&from.id) {\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n-                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    v.promotable = false;\n                 }\n                 _ => {}\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n             let def = v.tcx.tables().qpath_def(qpath, e.id);\n             match def {\n-                Def::VariantCtor(_, CtorKind::Const) => {\n-                    // Size is determined by the whole enum, may be non-zero.\n-                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n-                }\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n-                Def::Static(..) => {\n-                    match v.mode {\n-                        Mode::Static | Mode::StaticMut => {}\n-                        Mode::Const | Mode::ConstFn => {}\n-                        Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n-                    }\n-                }\n-                Def::Const(did) | Def::AssociatedConst(did) => {\n-                    let substs = Some(v.tcx.tables().node_id_item_substs(e.id)\n-                        .unwrap_or_else(|| v.tcx.intern_substs(&[])));\n-                    if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n-                        let inner = v.global_expr(Mode::Const, expr);\n-                        v.add_qualif(inner);\n-                    }\n-                }\n-                Def::Local(..) if v.mode == Mode::ConstFn => {\n-                    // Sadly, we can't determine whether the types are zero-sized.\n-                    v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n+                Def::AssociatedConst(_) => v.add_type(node_ty),\n+                Def::Const(did) => {\n+                    v.promotable &= if let Some(node_id) = v.tcx.map.as_local_node_id(did) {\n+                        match v.tcx.map.expect_item(node_id).node {\n+                            hir::ItemConst(_, body) => {\n+                                v.visit_nested_body(body);\n+                                v.tcx.rvalue_promotable_to_static.borrow()[&body.node_id]\n+                            }\n+                            _ => false\n+                        }\n+                    } else {\n+                        v.tcx.sess.cstore.const_is_rvalue_promotable_to_static(did)\n+                    };\n                 }\n                 _ => {\n-                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    v.promotable = false;\n                 }\n             }\n         }\n@@ -565,65 +341,48 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             } else {\n                 Def::Err\n             };\n-            let is_const = match def {\n+            match def {\n                 Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Fn) => {\n-                    // `NON_ZERO_SIZED` is about the call result, not about the ctor itself.\n-                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n-                    true\n-                }\n+                Def::VariantCtor(_, CtorKind::Fn) => {}\n                 Def::Fn(did) => {\n-                    v.handle_const_fn_call(e, did, node_ty)\n+                    v.handle_const_fn_call(did, node_ty)\n                 }\n                 Def::Method(did) => {\n                     match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => {\n-                            v.handle_const_fn_call(e, did, node_ty)\n+                            v.handle_const_fn_call(did, node_ty)\n                         }\n-                        ty::TraitContainer(_) => false\n+                        ty::TraitContainer(_) => v.promotable = false\n                     }\n                 }\n-                _ => false\n-            };\n-            if !is_const {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n+                _ => v.promotable = false\n             }\n         }\n         hir::ExprMethodCall(..) => {\n             let method = v.tcx.tables().method_map[&method_call];\n-            let is_const = match v.tcx.associated_item(method.def_id).container {\n-                ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n-                ty::TraitContainer(_) => false\n-            };\n-            if !is_const {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n+            match v.tcx.associated_item(method.def_id).container {\n+                ty::ImplContainer(_) => v.handle_const_fn_call(method.def_id, node_ty),\n+                ty::TraitContainer(_) => v.promotable = false\n             }\n         }\n         hir::ExprStruct(..) => {\n             if let ty::TyAdt(adt, ..) = v.tcx.tables().expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n-                    v.add_qualif(ConstQualif::MUTABLE_MEM);\n+                    v.promotable = false;\n                 }\n             }\n         }\n \n         hir::ExprLit(_) |\n-        hir::ExprAddrOf(..) => {\n-            v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n-        }\n-\n-        hir::ExprRepeat(..) => {\n-            v.add_qualif(ConstQualif::PREFER_IN_PLACE);\n-        }\n+        hir::ExprAddrOf(..) |\n+        hir::ExprRepeat(..) => {}\n \n         hir::ExprClosure(..) => {\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n-                assert!(v.mode == Mode::Var,\n-                        \"global closures can't capture anything\");\n-                v.add_qualif(ConstQualif::NOT_CONST);\n+                v.promotable = false;\n             }\n         }\n \n@@ -652,7 +411,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprAssign(..) |\n         hir::ExprAssignOp(..) |\n         hir::ExprInlineAsm(..) => {\n-            v.add_qualif(ConstQualif::NOT_CONST);\n+            v.promotable = false;\n         }\n     }\n }\n@@ -671,7 +430,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n         Some(Adjust::DerefRef { autoderefs, .. }) => {\n             if (0..autoderefs as u32)\n                 .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n+                v.promotable = false;\n             }\n         }\n     }\n@@ -681,9 +440,10 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_item_likes_in_krate(DepNode::CheckConst,\n                                       &mut CheckCrateVisitor {\n                                           tcx: tcx,\n-                                          mode: Mode::Var,\n-                                          qualif: ConstQualif::NOT_CONST,\n-                                          rvalue_borrows: NodeMap(),\n+                                          in_fn: false,\n+                                          promotable: false,\n+                                          mut_rvalue_borrows: NodeSet(),\n+                                          param_env: tcx.empty_parameter_environment(),\n                                       }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n@@ -692,24 +452,9 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,\n-               cmt: mc::cmt,\n-               _mode: euv::ConsumeMode) {\n-        let mut cur = &cmt;\n-        loop {\n-            match cur.cat {\n-                Categorization::StaticItem => {\n-                    break;\n-                }\n-                Categorization::Deref(ref cmt, ..) |\n-                Categorization::Downcast(ref cmt, _) |\n-                Categorization::Interior(ref cmt, _) => cur = cmt,\n+               _cmt: mc::cmt,\n+               _mode: euv::ConsumeMode) {}\n \n-                Categorization::Rvalue(..) |\n-                Categorization::Upvar(..) |\n-                Categorization::Local(..) => break,\n-            }\n-        }\n-    }\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n@@ -736,21 +481,9 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n                         // Ignore the dummy immutable borrow created by EUV.\n                         break;\n                     }\n-                    let mutbl = bk.to_mutbl_lossy();\n-                    if mutbl == hir::MutMutable && self.mode == Mode::StaticMut {\n-                        // Mutable slices are the only `&mut` allowed in\n-                        // globals, but only in `static mut`, nowhere else.\n-                        // FIXME: This exception is really weird... there isn't\n-                        // any fundamental reason to restrict this based on\n-                        // type of the expression.  `&mut [1]` has exactly the\n-                        // same representation as &mut 1.\n-                        match cmt.ty.sty {\n-                            ty::TyArray(..) |\n-                            ty::TySlice(_) => break,\n-                            _ => {}\n-                        }\n+                    if bk.to_mutbl_lossy() == hir::MutMutable {\n+                        self.mut_rvalue_borrows.insert(borrow_id);\n                     }\n-                    self.record_borrow(borrow_id, mutbl);\n                     break;\n                 }\n                 Categorization::StaticItem => {"}, {"sha": "3da4f24b6c2fe077243b34e0c25a60f9dd84f77e", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n             };\n             let body = infcx.tcx.map.body(b);\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n-            euv.walk_fn(body);\n+            euv.consume_body(body);\n         });\n         intravisit::walk_fn(self, fk, fd, b, s, fn_id)\n     }"}, {"sha": "2bc42a461528da2bfb28b779341c40ad1e8ec73c", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 11, "deletions": 66, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -202,8 +202,6 @@ use rustc::mir::{self, Location};\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use rustc_const_eval as const_eval;\n-\n use syntax::abi::Abi;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n@@ -344,19 +342,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             recursion_depth_reset = None;\n \n-            // Scan the MIR in order to find function calls, closures, and\n-            // drop-glue\n-            let mir = scx.tcx().item_mir(def_id);\n-\n-            let empty_substs = scx.empty_substs_for_def_id(def_id);\n-            let visitor = MirNeighborCollector {\n-                scx: scx,\n-                mir: &mir,\n-                output: &mut neighbors,\n-                param_substs: empty_substs\n-            };\n-\n-            visit_mir_and_promoted(visitor, &mir);\n+            collect_neighbours(scx, Instance::mono(scx, def_id), &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n@@ -365,18 +351,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                                recursion_depths));\n             check_type_length_limit(scx.tcx(), instance);\n \n-            // Scan the MIR in order to find function calls, closures, and\n-            // drop-glue\n-            let mir = scx.tcx().item_mir(instance.def);\n-\n-            let visitor = MirNeighborCollector {\n-                scx: scx,\n-                mir: &mir,\n-                output: &mut neighbors,\n-                param_substs: instance.substs\n-            };\n-\n-            visit_mir_and_promoted(visitor, &mir);\n+            collect_neighbours(scx, instance, &mut neighbors);\n         }\n     }\n \n@@ -563,33 +538,12 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     // This is not a callee, but we still have to look for\n                     // references to `const` items\n                     if let mir::Literal::Item { def_id, substs } = constant.literal {\n-                        let tcx = self.scx.tcx();\n                         let substs = monomorphize::apply_param_substs(self.scx,\n                                                                       self.param_substs,\n                                                                       &substs);\n \n-                        // If the constant referred to here is an associated\n-                        // item of a trait, we need to resolve it to the actual\n-                        // constant in the corresponding impl. Luckily\n-                        // const_eval::lookup_const_by_id() does that for us.\n-                        if let Some((expr, _)) = const_eval::lookup_const_by_id(tcx,\n-                                                                                def_id,\n-                                                                                Some(substs)) {\n-                            // The hir::Expr we get here is the initializer of\n-                            // the constant, what we really want is the item\n-                            // DefId.\n-                            let const_node_id = tcx.map.get_parent(expr.id);\n-                            let def_id = if tcx.map.is_inlined_node_id(const_node_id) {\n-                                tcx.sess.cstore.defid_for_inlined_node(const_node_id).unwrap()\n-                            } else {\n-                                tcx.map.local_def_id(const_node_id)\n-                            };\n-\n-                            collect_const_item_neighbours(self.scx,\n-                                                          def_id,\n-                                                          substs,\n-                                                          self.output);\n-                        }\n+                        let instance = Instance::new(def_id, substs).resolve_const(self.scx);\n+                        collect_neighbours(self.scx, instance, self.output);\n                     }\n \n                     None\n@@ -1233,29 +1187,20 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n     }\n }\n \n-// There are no translation items for constants themselves but their\n-// initializers might still contain something that produces translation items,\n-// such as cast that introduce a new vtable.\n-fn collect_const_item_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                           def_id: DefId,\n-                                           substs: &'tcx Substs<'tcx>,\n-                                           output: &mut Vec<TransItem<'tcx>>)\n+/// Scan the MIR in order to find function calls, closures, and drop-glue\n+fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                instance: Instance<'tcx>,\n+                                output: &mut Vec<TransItem<'tcx>>)\n {\n-    // Scan the MIR in order to find function calls, closures, and\n-    // drop-glue\n-    let mir = scx.tcx().item_mir(def_id);\n+    let mir = scx.tcx().item_mir(instance.def);\n \n-    let visitor = MirNeighborCollector {\n+    let mut visitor = MirNeighborCollector {\n         scx: scx,\n         mir: &mir,\n         output: output,\n-        param_substs: substs\n+        param_substs: instance.substs\n     };\n \n-    visit_mir_and_promoted(visitor, &mir);\n-}\n-\n-fn visit_mir_and_promoted<'tcx, V: MirVisitor<'tcx>>(mut visitor: V, mir: &mir::Mir<'tcx>) {\n     visitor.visit_mir(&mir);\n     for promoted in &mir.promoted {\n         visitor.visit_mir(promoted);"}, {"sha": "d9179d6a6fa73888a7f9e4a5c4fad00562364518", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -737,14 +737,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().drop_glues\n     }\n \n-    pub fn local_node_for_inlined_defid<'a>(&'a self, def_id: DefId) -> Option<ast::NodeId> {\n-        self.sess().cstore.local_node_for_inlined_defid(def_id)\n-    }\n-\n-    pub fn defid_for_inlined_node<'a>(&'a self, node_id: ast::NodeId) -> Option<DefId> {\n-        self.sess().cstore.defid_for_inlined_node(node_id)\n-    }\n-\n     pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }"}, {"sha": "1cedaa0a4e1a4ee68d9da82dd60fd881c41befff", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -18,7 +18,6 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n@@ -36,7 +35,7 @@ use type_::Type;\n use value::Value;\n \n use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use std::fmt;\n use std::ptr;\n@@ -238,24 +237,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n-                 mut instance: Instance<'tcx>,\n+                 instance: Instance<'tcx>,\n                  args: IndexVec<mir::Local, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalErr> {\n-        // Try to resolve associated constants.\n-        if let Some(trait_id) = ccx.tcx().trait_of_item(instance.def) {\n-            let trait_ref = ty::TraitRef::new(trait_id, instance.substs);\n-            let trait_ref = ty::Binder(trait_ref);\n-            let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n-            if let traits::VtableImpl(vtable_impl) = vtable {\n-                let name = ccx.tcx().item_name(instance.def);\n-                let ac = ccx.tcx().associated_items(vtable_impl.impl_def_id)\n-                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n-                if let Some(ac) = ac {\n-                    instance = Instance::new(ac.def_id, vtable_impl.substs);\n-                }\n-            }\n-        }\n-\n+        let instance = instance.resolve_const(ccx.shared());\n         let mir = ccx.tcx().item_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }"}, {"sha": "4b31d5b7f88de1ac9258351683a9c222e41e8c72", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -11,11 +11,15 @@\n use common::*;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n+use rustc::traits;\n use rustc::ty::fold::{TypeFolder, TypeFoldable};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::ppaux;\n use rustc::util::common::MemoizationMap;\n+\n+use syntax::codemap::DUMMY_SP;\n+\n use std::fmt;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -30,15 +34,35 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n     }\n }\n \n-impl<'tcx> Instance<'tcx> {\n+impl<'a, 'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n                -> Instance<'tcx> {\n         assert!(substs.regions().all(|&r| r == ty::ReErased));\n         Instance { def: def_id, substs: substs }\n     }\n-    pub fn mono<'a>(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n+\n+    pub fn mono(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n         Instance::new(def_id, scx.empty_substs_for_def_id(def_id))\n     }\n+\n+    /// For associated constants from traits, return the impl definition.\n+    pub fn resolve_const(&self, scx: &SharedCrateContext<'a, 'tcx>) -> Self {\n+        if let Some(trait_id) = scx.tcx().trait_of_item(self.def) {\n+            let trait_ref = ty::TraitRef::new(trait_id, self.substs);\n+            let trait_ref = ty::Binder(trait_ref);\n+            let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n+            if let traits::VtableImpl(vtable_impl) = vtable {\n+                let name = scx.tcx().item_name(self.def);\n+                let ac = scx.tcx().associated_items(vtable_impl.impl_def_id)\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n+                if let Some(ac) = ac {\n+                    return Instance::new(ac.def_id, vtable_impl.substs);\n+                }\n+            }\n+        }\n+\n+        *self\n+    }\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope"}, {"sha": "5d927a503a116036bbf092882e80dcd4b7b32d4b", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                                                   mc::MemCategorizationOptions {\n                                                       during_closure_kind_inference: true\n                                                   });\n-            euv.walk_fn(body);\n+            euv.consume_body(body);\n         }\n \n         // Now that we've analyzed the closure, we know how each"}, {"sha": "f2ba6952eb8645c997a7904bf337b8d9bb46456d", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64e73b6ec130a5323f997b476c2a8a43afb6c94/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f64e73b6ec130a5323f997b476c2a8a43afb6c94", "patch": "@@ -21,8 +21,6 @@ use rustc::hir::print as pprust;\n use rustc::ty;\n use rustc::util::nodemap::FxHashSet;\n \n-use rustc_const_eval::lookup_const_by_id;\n-\n use core::{DocContext, DocAccessLevels};\n use doctree;\n use clean::{self, GetDefId};\n@@ -346,7 +344,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             ty::AssociatedKind::Const => {\n                 let default = if item.defaultness.has_value() {\n                     Some(pprust::expr_to_string(\n-                        lookup_const_by_id(tcx, item.def_id, None).unwrap().0))\n+                        &tcx.sess.cstore.maybe_get_item_body(tcx, item.def_id).unwrap().value))\n                 } else {\n                     None\n                 };\n@@ -477,16 +475,10 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n }\n \n fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n-    let (expr, ty) = lookup_const_by_id(cx.tcx, did, None).unwrap_or_else(|| {\n-        panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n-    });\n-    debug!(\"converting constant expr {:?} to snippet\", expr);\n-    let sn = pprust::expr_to_string(expr);\n-    debug!(\"got snippet {}\", sn);\n-\n     clean::Constant {\n-        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| cx.tcx.item_type(did).clean(cx)),\n-        expr: sn\n+        type_: cx.tcx.item_type(did).clean(cx),\n+        expr: pprust::expr_to_string(\n+            &cx.tcx.sess.cstore.maybe_get_item_body(cx.tcx, did).unwrap().value)\n     }\n }\n "}]}