{"sha": "4507382f2e66cd0e6498228bfdffb16769063b0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MDczODJmMmU2NmNkMGU2NDk4MjI4YmZkZmZiMTY3NjkwNjNiMGY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T13:09:10Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-31T13:10:20Z"}, "message": "Move unprefixed field/method completion to `dot`", "tree": {"sha": "a3f95f4b5bdaa8e1d5f861e169d66ecb8e7723da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3f95f4b5bdaa8e1d5f861e169d66ecb8e7723da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4507382f2e66cd0e6498228bfdffb16769063b0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4507382f2e66cd0e6498228bfdffb16769063b0f", "html_url": "https://github.com/rust-lang/rust/commit/4507382f2e66cd0e6498228bfdffb16769063b0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4507382f2e66cd0e6498228bfdffb16769063b0f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d346f5bf75bfe3c7dc357c748c257569c0fb23c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d346f5bf75bfe3c7dc357c748c257569c0fb23c3", "html_url": "https://github.com/rust-lang/rust/commit/d346f5bf75bfe3c7dc357c748c257569c0fb23c3"}], "stats": {"total": 194, "additions": 101, "deletions": 93}, "files": [{"sha": "ffdcdc930a943973cef3521950eb1db8ad5c80fc", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4507382f2e66cd0e6498228bfdffb16769063b0f/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4507382f2e66cd0e6498228bfdffb16769063b0f/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=4507382f2e66cd0e6498228bfdffb16769063b0f", "patch": "@@ -18,10 +18,8 @@ pub(crate) mod unqualified_path;\n \n use std::iter;\n \n-use either::Either;\n-use hir::{known, HasVisibility};\n+use hir::known;\n use ide_db::SymbolKind;\n-use rustc_hash::FxHashSet;\n \n use crate::{\n     item::{Builder, CompletionKind},\n@@ -254,44 +252,3 @@ fn complete_enum_variants(\n         }\n     }\n }\n-\n-fn complete_fields(\n-    ctx: &CompletionContext,\n-    receiver: &hir::Type,\n-    mut f: impl FnMut(Either<hir::Field, usize>, hir::Type),\n-) {\n-    for receiver in receiver.autoderef(ctx.db) {\n-        for (field, ty) in receiver.fields(ctx.db) {\n-            if ctx.scope.module().map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n-                // Skip private field. FIXME: If the definition location of the\n-                // field is editable, we should show the completion\n-                continue;\n-            }\n-            f(Either::Left(field), ty);\n-        }\n-        for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {\n-            // FIXME: Handle visibility\n-            f(Either::Right(i), ty);\n-        }\n-    }\n-}\n-\n-fn complete_methods(\n-    ctx: &CompletionContext,\n-    receiver: &hir::Type,\n-    mut f: impl FnMut(hir::Function),\n-) {\n-    if let Some(krate) = ctx.krate {\n-        let mut seen_methods = FxHashSet::default();\n-        let traits_in_scope = ctx.scope.traits_in_scope();\n-        receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n-            if func.self_param(ctx.db).is_some()\n-                && ctx.scope.module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n-                && seen_methods.insert(func.name(ctx.db))\n-            {\n-                f(func);\n-            }\n-            None::<()>\n-        });\n-    }\n-}"}, {"sha": "886251639e74e02a90b9fa31fbc1eadd0aceb5ee", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 100, "deletions": 3, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4507382f2e66cd0e6498228bfdffb16769063b0f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4507382f2e66cd0e6498228bfdffb16769063b0f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=4507382f2e66cd0e6498228bfdffb16769063b0f", "patch": "@@ -1,14 +1,16 @@\n //! Completes references after dot (fields and method calls).\n \n use either::Either;\n+use hir::{HasVisibility, ScopeDef};\n+use rustc_hash::FxHashSet;\n \n use crate::{context::CompletionContext, Completions};\n \n /// Complete dot accesses, i.e. fields or methods.\n pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     let dot_receiver = match &ctx.dot_receiver {\n         Some(expr) => expr,\n-        _ => return,\n+        _ => return complete_undotted_self(acc, ctx),\n     };\n \n     let receiver_ty = match ctx.sema.type_of_expr(&dot_receiver) {\n@@ -19,12 +21,77 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     if ctx.is_call {\n         cov_mark::hit!(test_no_struct_field_completion_for_method_call);\n     } else {\n-        super::complete_fields(ctx, &receiver_ty, |field, ty| match field {\n+        complete_fields(ctx, &receiver_ty, |field, ty| match field {\n             Either::Left(field) => acc.add_field(ctx, None, field, &ty),\n             Either::Right(tuple_idx) => acc.add_tuple_field(ctx, None, tuple_idx, &ty),\n         });\n     }\n-    super::complete_methods(ctx, &receiver_ty, |func| acc.add_method(ctx, func, None, None));\n+    complete_methods(ctx, &receiver_ty, |func| acc.add_method(ctx, func, None, None));\n+}\n+\n+fn complete_undotted_self(acc: &mut Completions, ctx: &CompletionContext) {\n+    if !ctx.is_trivial_path {\n+        return;\n+    }\n+    ctx.scope.process_all_names(&mut |name, def| {\n+        if let ScopeDef::Local(local) = &def {\n+            if local.is_self(ctx.db) {\n+                let ty = local.ty(ctx.db);\n+                complete_fields(ctx, &ty, |field, ty| match field {\n+                    either::Either::Left(field) => {\n+                        acc.add_field(ctx, Some(name.clone()), field, &ty)\n+                    }\n+                    either::Either::Right(tuple_idx) => {\n+                        acc.add_tuple_field(ctx, Some(name.clone()), tuple_idx, &ty)\n+                    }\n+                });\n+                complete_methods(ctx, &ty, |func| {\n+                    acc.add_method(ctx, func, Some(name.clone()), None)\n+                });\n+            }\n+        }\n+    });\n+}\n+\n+fn complete_fields(\n+    ctx: &CompletionContext,\n+    receiver: &hir::Type,\n+    mut f: impl FnMut(Either<hir::Field, usize>, hir::Type),\n+) {\n+    for receiver in receiver.autoderef(ctx.db) {\n+        for (field, ty) in receiver.fields(ctx.db) {\n+            if ctx.scope.module().map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n+                // Skip private field. FIXME: If the definition location of the\n+                // field is editable, we should show the completion\n+                continue;\n+            }\n+            f(Either::Left(field), ty);\n+        }\n+        for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {\n+            // FIXME: Handle visibility\n+            f(Either::Right(i), ty);\n+        }\n+    }\n+}\n+\n+fn complete_methods(\n+    ctx: &CompletionContext,\n+    receiver: &hir::Type,\n+    mut f: impl FnMut(hir::Function),\n+) {\n+    if let Some(krate) = ctx.krate {\n+        let mut seen_methods = FxHashSet::default();\n+        let traits_in_scope = ctx.scope.traits_in_scope();\n+        receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n+            if func.self_param(ctx.db).is_some()\n+                && ctx.scope.module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n+                && seen_methods.insert(func.name(ctx.db))\n+            {\n+                f(func);\n+            }\n+            None::<()>\n+        });\n+    }\n }\n \n #[cfg(test)]\n@@ -453,4 +520,34 @@ impl S {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn completes_bare_fields_and_methods_in_methods() {\n+        check(\n+            r#\"\n+struct Foo { field: i32 }\n+\n+impl Foo { fn foo(&self) { $0 } }\"#,\n+            expect![[r#\"\n+                lc self       &Foo\n+                sp Self\n+                st Foo\n+                fd self.field i32\n+                me self.foo() fn(&self)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+struct Foo(i32);\n+\n+impl Foo { fn foo(&mut self) { $0 } }\"#,\n+            expect![[r#\"\n+                lc self       &mut Foo\n+                sp Self\n+                st Foo\n+                fd self.0     i32\n+                me self.foo() fn(&mut self)\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "20188a7ddc600f75154e00aa62d9ece23d09bbc3", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4507382f2e66cd0e6498228bfdffb16769063b0f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4507382f2e66cd0e6498228bfdffb16769063b0f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=4507382f2e66cd0e6498228bfdffb16769063b0f", "patch": "@@ -47,22 +47,6 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n             cov_mark::hit!(skip_lifetime_completion);\n             return;\n         }\n-        if let ScopeDef::Local(local) = &res {\n-            if local.is_self(ctx.db) {\n-                let ty = local.ty(ctx.db);\n-                super::complete_fields(ctx, &ty, |field, ty| match field {\n-                    either::Either::Left(field) => {\n-                        acc.add_field(ctx, Some(name.clone()), field, &ty)\n-                    }\n-                    either::Either::Right(tuple_idx) => {\n-                        acc.add_tuple_field(ctx, Some(name.clone()), tuple_idx, &ty)\n-                    }\n-                });\n-                super::complete_methods(ctx, &ty, |func| {\n-                    acc.add_method(ctx, func, Some(name.clone()), None)\n-                });\n-            }\n-        }\n         acc.add_resolution(ctx, name, &res);\n     });\n }\n@@ -393,36 +377,6 @@ fn foo() {\n         );\n     }\n \n-    #[test]\n-    fn completes_qualified_fields_and_methods_in_methods() {\n-        check(\n-            r#\"\n-struct Foo { field: i32 }\n-\n-impl Foo { fn foo(&self) { $0 } }\"#,\n-            expect![[r#\"\n-                fd self.field i32\n-                me self.foo() fn(&self)\n-                lc self       &Foo\n-                sp Self\n-                st Foo\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-struct Foo(i32);\n-\n-impl Foo { fn foo(&mut self) { $0 } }\"#,\n-            expect![[r#\"\n-                fd self.0     i32\n-                me self.foo() fn(&mut self)\n-                lc self       &mut Foo\n-                sp Self\n-                st Foo\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_prelude() {\n         check("}]}