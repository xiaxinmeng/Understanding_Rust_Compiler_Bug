{"sha": "6b96d17a5a7f7e9a32e9aa24c34d858bf4394571", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiOTZkMTdhNWE3ZjdlOWEzMmU5YWEyNGMzNGQ4NThiZjQzOTQ1NzE=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-14T17:11:15Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-17T00:15:23Z"}, "message": "Dumb NRVO", "tree": {"sha": "a2303b4c95be18b4cf10ed834d7ac558511b0299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2303b4c95be18b4cf10ed834d7ac558511b0299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b96d17a5a7f7e9a32e9aa24c34d858bf4394571", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b96d17a5a7f7e9a32e9aa24c34d858bf4394571", "html_url": "https://github.com/rust-lang/rust/commit/6b96d17a5a7f7e9a32e9aa24c34d858bf4394571", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b96d17a5a7f7e9a32e9aa24c34d858bf4394571/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd927a5b0f29342f7ad919fb52ca29510d2e7362", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd927a5b0f29342f7ad919fb52ca29510d2e7362", "html_url": "https://github.com/rust-lang/rust/commit/dd927a5b0f29342f7ad919fb52ca29510d2e7362"}], "stats": {"total": 221, "additions": 221, "deletions": 0}, "files": [{"sha": "0551ed5a15ddb2a103e8120c003cbb598c070649", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b96d17a5a7f7e9a32e9aa24c34d858bf4394571/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b96d17a5a7f7e9a32e9aa24c34d858bf4394571/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=6b96d17a5a7f7e9a32e9aa24c34d858bf4394571", "patch": "@@ -28,6 +28,7 @@ pub mod generator;\n pub mod inline;\n pub mod instcombine;\n pub mod no_landing_pads;\n+pub mod nrvo;\n pub mod promote_consts;\n pub mod qualify_min_const_fn;\n pub mod remove_noop_landing_pads;\n@@ -324,6 +325,7 @@ fn run_optimization_passes<'tcx>(\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"after-remove-noop-landing-pads\"),\n         &simplify::SimplifyCfg::new(\"final\"),\n+        &nrvo::RenameReturnPlace,\n         &simplify::SimplifyLocals,\n     ];\n "}, {"sha": "c33e2eb88e1488d1b704e729628e8778524093b5", "filename": "src/librustc_mir/transform/nrvo.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/6b96d17a5a7f7e9a32e9aa24c34d858bf4394571/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b96d17a5a7f7e9a32e9aa24c34d858bf4394571/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs?ref=6b96d17a5a7f7e9a32e9aa24c34d858bf4394571", "patch": "@@ -0,0 +1,219 @@\n+use rustc_index::bit_set::HybridBitSet;\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n+use rustc_middle::mir::{self, BasicBlock, Local, Location};\n+use rustc_middle::ty::TyCtxt;\n+\n+use crate::transform::{MirPass, MirSource};\n+\n+/// This pass looks for MIR that always copies the same local into the return place and eliminates\n+/// the copy by renaming all uses of that local to `_0`.\n+///\n+/// This allows LLVM to perform an optimization similar to the named return value optimization\n+/// (NRVO) that is guaranteed in C++. This avoids a stack allocation and `memcpy` for the\n+/// relatively common pattern of allocating a buffer on the stack, mutating it, and returning it by\n+/// value like so:\n+///\n+/// ```rust\n+/// fn foo(init: fn(&mut [u8; 1024])) -> [u8; 1024] {\n+///     let mut buf = [0; 1024];\n+///     init(&mut buf);\n+///     buf\n+/// }\n+/// ```\n+///\n+/// For now, this pass is very simple and only capable of eliminating a single copy.\n+/// A more general version of copy propagation could yield even more benefits.\n+pub struct RenameReturnPlace;\n+\n+impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut mir::Body<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n+            return;\n+        }\n+\n+        let returned_local = match local_eligible_for_nrvo(body) {\n+            Some(l) => l,\n+            None => {\n+                debug!(\"`{:?}` was ineligible for NRVO\", src.def_id());\n+                return;\n+            }\n+        };\n+\n+        debug!(\n+            \"`{:?}` was eligible for NRVO, making {:?} the return place\",\n+            src.def_id(),\n+            returned_local\n+        );\n+\n+        RenameToReturnPlace { tcx, to_rename: returned_local }.visit_body(body);\n+\n+        // Clean up the `NOP`s we inserted for statements made useless by our renaming.\n+        for block_data in body.basic_blocks_mut() {\n+            block_data.statements.retain(|stmt| stmt.kind != mir::StatementKind::Nop);\n+        }\n+\n+        // Overwrite the debuginfo of `_0` with that of the renamed local.\n+        let (renamed_decl, ret_decl) =\n+            body.local_decls.pick2_mut(returned_local, mir::RETURN_PLACE);\n+        debug_assert_eq!(ret_decl.ty, renamed_decl.ty);\n+        ret_decl.clone_from(renamed_decl);\n+    }\n+}\n+\n+/// MIR that is eligible for the NRVO must fulfill two conditions:\n+///   1. The return place must not be read prior to the `Return` terminator.\n+///   2. A simple assignment of a whole local to the return place (e.g., `_0 = _1`) must be the\n+///      only definition of the return place reaching the `Return` terminator.\n+///\n+/// If the MIR fulfills both these conditions, this function returns the `Local` that is assigned\n+/// to the return place along all possible paths through the control-flow graph.\n+fn local_eligible_for_nrvo(body: &mut mir::Body<'_>) -> Option<Local> {\n+    if IsReturnPlaceRead::run(body) {\n+        return None;\n+    }\n+\n+    let mut copied_to_return_place = None;\n+    for block in body.basic_blocks().indices() {\n+        // Look for blocks with a `Return` terminator.\n+        if !matches!(body[block].terminator().kind, mir::TerminatorKind::Return) {\n+            continue;\n+        }\n+\n+        // Look for an assignment of a single local to the return place prior to the `Return`.\n+        let returned_local = find_local_assigned_to_return_place(block, body)?;\n+        match body.local_kind(returned_local) {\n+            // FIXME: Can we do this for arguments as well?\n+            mir::LocalKind::Arg => return None,\n+\n+            mir::LocalKind::ReturnPointer => bug!(\"Return place was assigned to itself?\"),\n+            mir::LocalKind::Var | mir::LocalKind::Temp => {}\n+        }\n+\n+        // If multiple different locals are copied to the return place. We can't pick a\n+        // single one to rename.\n+        if copied_to_return_place.map_or(false, |old| old != returned_local) {\n+            return None;\n+        }\n+\n+        copied_to_return_place = Some(returned_local);\n+    }\n+\n+    return copied_to_return_place;\n+}\n+\n+fn find_local_assigned_to_return_place(\n+    start: BasicBlock,\n+    body: &mut mir::Body<'_>,\n+) -> Option<Local> {\n+    let mut block = start;\n+    let mut seen = HybridBitSet::new_empty(body.basic_blocks().len());\n+\n+    // Iterate as long as `block` has exactly one predecessor that we have not yet visited.\n+    while seen.insert(block) {\n+        trace!(\"Looking for assignments to `_0` in {:?}\", block);\n+\n+        let local = body[block].statements.iter().rev().find_map(as_local_assigned_to_return_place);\n+        if local.is_some() {\n+            return local;\n+        }\n+\n+        match body.predecessors()[block].as_slice() {\n+            &[pred] => block = pred,\n+            _ => return None,\n+        }\n+    }\n+\n+    return None;\n+}\n+\n+// If this statement is an assignment of an unprojected local to the return place,\n+// return that local.\n+fn as_local_assigned_to_return_place(stmt: &mir::Statement<'_>) -> Option<Local> {\n+    if let mir::StatementKind::Assign(box (lhs, rhs)) = &stmt.kind {\n+        if lhs.as_local() == Some(mir::RETURN_PLACE) {\n+            if let mir::Rvalue::Use(mir::Operand::Copy(rhs) | mir::Operand::Move(rhs)) = rhs {\n+                return rhs.as_local();\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+struct RenameToReturnPlace<'tcx> {\n+    to_rename: Local,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+/// Replaces all uses of `self.to_rename` with `_0`.\n+impl MutVisitor<'tcx> for RenameToReturnPlace<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_statement(&mut self, stmt: &mut mir::Statement<'tcx>, loc: Location) {\n+        // Remove assignments of the local being replaced to the return place, since it is now the\n+        // return place:\n+        //     _0 = _1\n+        if as_local_assigned_to_return_place(stmt) == Some(self.to_rename) {\n+            stmt.kind = mir::StatementKind::Nop;\n+            return;\n+        }\n+\n+        // Remove storage annotations for the local being replaced:\n+        //     StorageLive(_1)\n+        if let mir::StatementKind::StorageLive(local) | mir::StatementKind::StorageDead(local) =\n+            stmt.kind\n+        {\n+            if local == self.to_rename {\n+                stmt.kind = mir::StatementKind::Nop;\n+                return;\n+            }\n+        }\n+\n+        self.super_statement(stmt, loc)\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mut mir::Terminator<'tcx>, loc: Location) {\n+        // Ignore the implicit \"use\" of the return place in a `Return` statement.\n+        if let mir::TerminatorKind::Return = terminator.kind {\n+            return;\n+        }\n+\n+        self.super_terminator(terminator, loc);\n+    }\n+\n+    fn visit_local(&mut self, l: &mut Local, _: PlaceContext, _: Location) {\n+        assert_ne!(*l, mir::RETURN_PLACE);\n+        if *l == self.to_rename {\n+            *l = mir::RETURN_PLACE;\n+        }\n+    }\n+}\n+\n+struct IsReturnPlaceRead(bool);\n+\n+impl IsReturnPlaceRead {\n+    fn run(body: &mir::Body<'_>) -> bool {\n+        let mut vis = IsReturnPlaceRead(false);\n+        vis.visit_body(body);\n+        vis.0\n+    }\n+}\n+\n+impl Visitor<'tcx> for IsReturnPlaceRead {\n+    fn visit_local(&mut self, &l: &Local, ctxt: PlaceContext, _: Location) {\n+        if l == mir::RETURN_PLACE && ctxt.is_use() && !ctxt.is_place_assignment() {\n+            self.0 = true;\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, loc: Location) {\n+        // Ignore the implicit \"use\" of the return place in a `Return` statement.\n+        if let mir::TerminatorKind::Return = terminator.kind {\n+            return;\n+        }\n+\n+        self.super_terminator(terminator, loc);\n+    }\n+}"}]}