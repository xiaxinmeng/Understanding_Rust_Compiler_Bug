{"sha": "18da3c671b8147fb8d4e206d487f0ee4e4c3ba11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZGEzYzY3MWI4MTQ3ZmI4ZDRlMjA2ZDQ4N2YwZWU0ZTRjM2JhMTE=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-26T07:47:32Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-26T07:47:32Z"}, "message": "Do not expand a derive invocation when derive is not allowed\n\n1. Change the return type of `expand_invoc()` and its subroutines to\n   `Option<Expansion>` from `Expansion`.\n2. Return `None` when expanding a derive invocation if the item cannot\n   have derive on it (in `expand_derive_invoc()`).", "tree": {"sha": "44008e34c1ca92a795595088ecf7e3dd171bb335", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44008e34c1ca92a795595088ecf7e3dd171bb335"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11", "html_url": "https://github.com/rust-lang/rust/commit/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cd67581e7d048810874903dc589e5b855f47e7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cd67581e7d048810874903dc589e5b855f47e7d", "html_url": "https://github.com/rust-lang/rust/commit/0cd67581e7d048810874903dc589e5b855f47e7d"}], "stats": {"total": 205, "additions": 126, "deletions": 79}, "files": [{"sha": "be71d6e038c854a8e23f84343d94d4cced6f9076", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=18da3c671b8147fb8d4e206d487f0ee4e4c3ba11", "patch": "@@ -96,6 +96,18 @@ impl Annotatable {\n             _ => panic!(\"expected Item\")\n         }\n     }\n+\n+    pub fn derive_allowed(&self) -> bool {\n+        match *self {\n+            Annotatable::Item(ref item) => match item.node {\n+                ast::ItemKind::Struct(..) |\n+                ast::ItemKind::Enum(..) |\n+                ast::ItemKind::Union(..) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n }\n \n // A more flexible ItemDecorator."}, {"sha": "11988a8f89d70a471512a01acf9393cf03ff27ce", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 91, "deletions": 79, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=18da3c671b8147fb8d4e206d487f0ee4e4c3ba11", "patch": "@@ -136,8 +136,8 @@ expansions! {\n }\n \n impl ExpansionKind {\n-    fn dummy(self, span: Span) -> Expansion {\n-        self.make_from(DummyResult::any(span)).unwrap()\n+    fn dummy(self, span: Span) -> Option<Expansion> {\n+        self.make_from(DummyResult::any(span))\n     }\n \n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n@@ -304,21 +304,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             // FIXME(jseyfried): Refactor out the following logic\n             let (expansion, new_invocations) = if let Some(ext) = ext {\n                 if let Some(ext) = ext {\n-                    let expansion = self.expand_invoc(invoc, ext);\n+                    let dummy = invoc.expansion_kind.dummy(invoc.span()).unwrap();\n+                    let expansion = self.expand_invoc(invoc, ext).unwrap_or(dummy);\n                     self.collect_invocations(expansion, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n-                    let derive_allowed = match item {\n-                        Annotatable::Item(ref item) => match item.node {\n-                            ast::ItemKind::Struct(..) |\n-                            ast::ItemKind::Enum(..) |\n-                            ast::ItemKind::Union(..) => true,\n-                            _ => false,\n-                        },\n-                        _ => false,\n-                    };\n-                    if !derive_allowed {\n-                        let attr = item.attrs().iter()\n-                            .find(|attr| attr.check_name(\"derive\"))\n+                    if !item.derive_allowed() {\n+                        let attr = attr::find_by_name(item.attrs(), \"derive\")\n                             .expect(\"`derive` attribute should exist\");\n                         let span = attr.span;\n                         let mut err = self.cx.mut_span_err(span,\n@@ -366,7 +357,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     unreachable!()\n                 }\n             } else {\n-                self.collect_invocations(invoc.expansion_kind.dummy(invoc.span()), &[])\n+                self.collect_invocations(invoc.expansion_kind.dummy(invoc.span()).unwrap(), &[])\n             };\n \n             if expansions.len() < depth {\n@@ -446,11 +437,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Option<Expansion> {\n         let result = match invoc.kind {\n-            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n-            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n-            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n+            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext)?,\n+            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext)?,\n+            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext)?,\n         };\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n@@ -467,13 +458,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             panic!(FatalError);\n         }\n \n-        result\n+        Some(result)\n     }\n \n-    fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+    fn expand_attr_invoc(&mut self,\n+                         invoc: Invocation,\n+                         ext: Rc<SyntaxExtension>)\n+                         -> Option<Expansion> {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (attr, item) = match invoc.kind {\n-            InvocationKind::Attr { attr, item, .. } => (attr.unwrap(), item),\n+            InvocationKind::Attr { attr, item, .. } => (attr?, item),\n             _ => unreachable!(),\n         };\n \n@@ -490,16 +484,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             MultiModifier(ref mac) => {\n-                let meta = panictry!(attr.parse_meta(self.cx.parse_sess));\n+                let meta = attr.parse_meta(self.cx.parse_sess).ok()?;\n                 let item = mac.expand(self.cx, attr.span, &meta, item);\n-                kind.expect_from_annotatables(item)\n+                Some(kind.expect_from_annotatables(item))\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n-                let meta = panictry!(attr.parse_meta(self.cx.parse_sess));\n+                let meta = attr.parse_meta(self.cx.parse_sess).ok()?;\n                 mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n                 items.push(item);\n-                kind.expect_from_annotatables(items)\n+                Some(kind.expect_from_annotatables(items))\n             }\n             AttrProcMacro(ref mac) => {\n                 let item_tok = TokenTree::Token(DUMMY_SP, Token::interpolated(match item {\n@@ -525,7 +519,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     /// Expand a macro invocation. Returns the result of expansion.\n-    fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+    fn expand_bang_invoc(&mut self,\n+                         invoc: Invocation,\n+                         ext: Rc<SyntaxExtension>)\n+                         -> Option<Expansion> {\n         let (mark, kind) = (invoc.expansion_data.mark, invoc.expansion_kind);\n         let (mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n@@ -558,9 +555,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                                              false, false) {\n                     self.cx.span_err(path.span, &msg);\n                     self.cx.trace_macros_diag();\n-                    return kind.dummy(span);\n+                    kind.dummy(span)\n+                } else {\n+                    kind.make_from(expand.expand(self.cx, span, mac.node.stream()))\n                 }\n-                kind.make_from(expand.expand(self.cx, span, mac.node.stream()))\n             }\n \n             NormalTT {\n@@ -574,44 +572,45 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                                              allow_internal_unsafe) {\n                     self.cx.span_err(path.span, &msg);\n                     self.cx.trace_macros_diag();\n-                    return kind.dummy(span);\n+                    kind.dummy(span)\n+                } else {\n+                    kind.make_from(expander.expand(self.cx, span, mac.node.stream()))\n                 }\n-                kind.make_from(expander.expand(self.cx, span, mac.node.stream()))\n             }\n \n             IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n                 if ident.name == keywords::Invalid.name() {\n                     self.cx.span_err(path.span,\n                                     &format!(\"macro {}! expects an ident argument\", path));\n                     self.cx.trace_macros_diag();\n-                    return kind.dummy(span);\n-                };\n-\n-                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                    call_site: span,\n-                    callee: NameAndSpan {\n-                        format: macro_bang_format(path),\n-                        span: tt_span,\n-                        allow_internal_unstable,\n-                        allow_internal_unsafe: false,\n-                    }\n-                });\n+                    kind.dummy(span)\n+                } else {\n+                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n+                        call_site: span,\n+                        callee: NameAndSpan {\n+                            format: macro_bang_format(path),\n+                            span: tt_span,\n+                            allow_internal_unstable,\n+                            allow_internal_unsafe: false,\n+                        }\n+                    });\n \n-                let input: Vec<_> = mac.node.stream().into_trees().collect();\n-                kind.make_from(expander.expand(self.cx, span, ident, input))\n+                    let input: Vec<_> = mac.node.stream().into_trees().collect();\n+                    kind.make_from(expander.expand(self.cx, span, ident, input))\n+                }\n             }\n \n             MultiDecorator(..) | MultiModifier(..) | AttrProcMacro(..) => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n-                return kind.dummy(span);\n+                kind.dummy(span)\n             }\n \n             ProcMacroDerive(..) | BuiltinDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", path));\n                 self.cx.trace_macros_diag();\n-                return kind.dummy(span);\n+                kind.dummy(span)\n             }\n \n             ProcMacro(ref expandfun) => {\n@@ -620,43 +619,51 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                     self.cx.span_err(path.span, &msg);\n                     self.cx.trace_macros_diag();\n-                    return kind.dummy(span);\n-                }\n+                    kind.dummy(span)\n+                } else {\n+                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n+                        call_site: span,\n+                        callee: NameAndSpan {\n+                            format: macro_bang_format(path),\n+                            // FIXME procedural macros do not have proper span info\n+                            // yet, when they do, we should use it here.\n+                            span: None,\n+                            // FIXME probably want to follow macro_rules macros here.\n+                            allow_internal_unstable: false,\n+                            allow_internal_unsafe: false,\n+                        },\n+                    });\n \n-                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                    call_site: span,\n-                    callee: NameAndSpan {\n-                        format: macro_bang_format(path),\n-                        // FIXME procedural macros do not have proper span info\n-                        // yet, when they do, we should use it here.\n-                        span: None,\n-                        // FIXME probably want to follow macro_rules macros here.\n-                        allow_internal_unstable: false,\n-                        allow_internal_unsafe: false,\n-                    },\n-                });\n-\n-                let tok_result = expandfun.expand(self.cx, span, mac.node.stream());\n-                Some(self.parse_expansion(tok_result, kind, path, span))\n+                    let tok_result = expandfun.expand(self.cx, span, mac.node.stream());\n+                    self.parse_expansion(tok_result, kind, path, span)\n+                }\n             }\n         };\n \n-        unwrap_or!(opt_expanded, {\n+        if opt_expanded.is_some() {\n+            opt_expanded\n+        } else {\n             let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n                               name = path.segments[0].identifier.name, kind = kind.name());\n             self.cx.span_err(path.span, &msg);\n             self.cx.trace_macros_diag();\n             kind.dummy(span)\n-        })\n+        }\n     }\n \n     /// Expand a derive invocation. Returns the result of expansion.\n-    fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+    fn expand_derive_invoc(&mut self,\n+                           invoc: Invocation,\n+                           ext: Rc<SyntaxExtension>)\n+                           -> Option<Expansion> {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (path, item) = match invoc.kind {\n             InvocationKind::Derive { path, item } => (path, item),\n             _ => unreachable!(),\n         };\n+        if !item.derive_allowed() {\n+            return None;\n+        }\n \n         let pretty_name = Symbol::intern(&format!(\"derive({})\", path));\n         let span = path.span;\n@@ -686,15 +693,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n-                kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item))\n+                Some(kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item)))\n             }\n             BuiltinDerive(func) => {\n                 expn_info.callee.allow_internal_unstable = true;\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let mut items = Vec::new();\n-                func(self.cx, span, &attr.meta().unwrap(), &item, &mut |a| items.push(a));\n-                kind.expect_from_annotatables(items)\n+                func(self.cx, span, &attr.meta()?, &item, &mut |a| items.push(a));\n+                Some(kind.expect_from_annotatables(items))\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n@@ -705,19 +712,24 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, path: &Path, span: Span)\n-                       -> Expansion {\n+    fn parse_expansion(&mut self,\n+                       toks: TokenStream,\n+                       kind: ExpansionKind,\n+                       path: &Path,\n+                       span: Span)\n+                       -> Option<Expansion> {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n-        let expansion = match parser.parse_expansion(kind, false) {\n-            Ok(expansion) => expansion,\n+        match parser.parse_expansion(kind, false) {\n+            Ok(expansion) => {\n+                parser.ensure_complete_parse(path, kind.name(), span);\n+                Some(expansion)\n+            }\n             Err(mut err) => {\n                 err.emit();\n                 self.cx.trace_macros_diag();\n-                return kind.dummy(span);\n+                kind.dummy(span)\n             }\n-        };\n-        parser.ensure_complete_parse(path, kind.name(), span);\n-        expansion\n+        }\n     }\n }\n "}, {"sha": "9ff1c14f54c6e114e85a9082aa812302d11ec948", "filename": "src/test/compile-fail/derive-on-trait-item-or-impl-item.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11/src%2Ftest%2Fcompile-fail%2Fderive-on-trait-item-or-impl-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18da3c671b8147fb8d4e206d487f0ee4e4c3ba11/src%2Ftest%2Fcompile-fail%2Fderive-on-trait-item-or-impl-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderive-on-trait-item-or-impl-item.rs?ref=18da3c671b8147fb8d4e206d487f0ee4e4c3ba11", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    #[derive(Clone)]\n+    //~^ ERROR `derive` may only be applied to structs, enums and unions\n+    type Bar;\n+}\n+\n+impl Bar {\n+    #[derive(Clone)]\n+    //~^ ERROR `derive` may only be applied to structs, enums and unions\n+    fn bar(&self) {}\n+}\n+\n+fn main() {}"}]}