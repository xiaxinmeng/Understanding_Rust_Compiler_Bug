{"sha": "130e7632acef435caa9bf56e7333e4c28c7dffc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMGU3NjMyYWNlZjQzNWNhYTliZjU2ZTczMzNlNGMyOGM3ZGZmYzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-18T14:40:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-18T14:40:43Z"}, "message": "Merge #5433\n\n5433: Simplify exclusion logic r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ca33f4a791eb41439cee21d6b715b8f89fb80b1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca33f4a791eb41439cee21d6b715b8f89fb80b1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/130e7632acef435caa9bf56e7333e4c28c7dffc7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEwnrCRBK7hj4Ov3rIwAAdHIIAC8cMSPiMkltcqNDfi+IFjR/\nAehwL641+gfqlX+CbZ7QMaSLvXvRFOjx6jg974k0UkZdNqQwp2yWNR4IJiIPDJfZ\nhgrhfR47dyGDAAd+ohgcMiaNAKMieMbzVKpv337EU3kO3tMiKroqDhPqmXh2+Qbp\nG1YZ0Qrv60gyQPUdNYHSRnoqG53KDVrFcKVNit+9YlRj5m2JsymcsmdkCbTI+Q7u\nV4Q0uM2kLjJlKQKjaqxsxM/UaEJ0vHC9mrnpNYgVxiTt7SFmy2TX2aQqMQSf98OR\nQ1nQj3wEIfxkBxt4IqN5dLsfYmUgu6aiKm/HFwnIEKQgfq5cpELUR1t8B2qNj6E=\n=Pt+9\n-----END PGP SIGNATURE-----\n", "payload": "tree ca33f4a791eb41439cee21d6b715b8f89fb80b1e\nparent fd6717799c03c9171bb7ec0f50bce98d1dfb44bd\nparent 46ac9ff5e3cf070584d8167150655d091d47e3c2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1595083243 +0000\ncommitter GitHub <noreply@github.com> 1595083243 +0000\n\nMerge #5433\n\n5433: Simplify exclusion logic r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/130e7632acef435caa9bf56e7333e4c28c7dffc7", "html_url": "https://github.com/rust-lang/rust/commit/130e7632acef435caa9bf56e7333e4c28c7dffc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/130e7632acef435caa9bf56e7333e4c28c7dffc7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd6717799c03c9171bb7ec0f50bce98d1dfb44bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6717799c03c9171bb7ec0f50bce98d1dfb44bd", "html_url": "https://github.com/rust-lang/rust/commit/fd6717799c03c9171bb7ec0f50bce98d1dfb44bd"}, {"sha": "46ac9ff5e3cf070584d8167150655d091d47e3c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/46ac9ff5e3cf070584d8167150655d091d47e3c2", "html_url": "https://github.com/rust-lang/rust/commit/46ac9ff5e3cf070584d8167150655d091d47e3c2"}], "stats": {"total": 261, "additions": 120, "deletions": 141}, "files": [{"sha": "c58c3035c1d9c0cf1725d028b26856f3d18d55a0", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/130e7632acef435caa9bf56e7333e4c28c7dffc7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/130e7632acef435caa9bf56e7333e4c28c7dffc7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=130e7632acef435caa9bf56e7333e4c28c7dffc7", "patch": "@@ -103,15 +103,6 @@ version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n \n-[[package]]\n-name = \"bstr\"\n-version = \"0.2.13\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"31accafdb70df7871592c058eca3985b71104e15ac32f64706022c58867da931\"\n-dependencies = [\n- \"memchr\",\n-]\n-\n [[package]]\n name = \"byteorder\"\n version = \"1.3.4\"\n@@ -403,12 +394,6 @@ dependencies = [\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"fnv\"\n-version = \"1.0.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n-\n [[package]]\n name = \"fs_extra\"\n version = \"1.1.0\"\n@@ -473,19 +458,6 @@ version = \"0.22.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aaf91faf136cb47367fa430cd46e37a788775e7fa104f8b4bcb3861dc389b724\"\n \n-[[package]]\n-name = \"globset\"\n-version = \"0.4.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7ad1da430bd7281dde2576f44c84cc3f0f7b475e7202cd503042dff01a8c8120\"\n-dependencies = [\n- \"aho-corasick\",\n- \"bstr\",\n- \"fnv\",\n- \"log\",\n- \"regex\",\n-]\n-\n [[package]]\n name = \"goblin\"\n version = \"0.2.3\"\n@@ -1494,7 +1466,6 @@ dependencies = [\n  \"env_logger\",\n  \"expect\",\n  \"flycheck\",\n- \"globset\",\n  \"itertools\",\n  \"jod-thread\",\n  \"log\",\n@@ -2003,7 +1974,6 @@ name = \"vfs-notify\"\n version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel\",\n- \"globset\",\n  \"jod-thread\",\n  \"log\",\n  \"notify\","}, {"sha": "5eb2d0bb701ed29582d942248d7a143b38e975a9", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130e7632acef435caa9bf56e7333e4c28c7dffc7/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/130e7632acef435caa9bf56e7333e4c28c7dffc7/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=130e7632acef435caa9bf56e7333e4c28c7dffc7", "patch": "@@ -17,7 +17,6 @@ path = \"src/bin/main.rs\"\n anyhow = \"1.0.26\"\n crossbeam-channel = \"0.4.0\"\n env_logger = { version = \"0.7.1\", default-features = false }\n-globset = \"0.4.4\"\n itertools = \"0.9.0\"\n jod-thread = \"0.1.0\"\n log = \"0.4.8\""}, {"sha": "fce7bae3ad81d0db0fe22772c14e715a3d98eea2", "filename": "crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130e7632acef435caa9bf56e7333e4c28c7dffc7/crates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/130e7632acef435caa9bf56e7333e4c28c7dffc7/crates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2FCargo.toml?ref=130e7632acef435caa9bf56e7333e4c28c7dffc7", "patch": "@@ -13,7 +13,6 @@ log = \"0.4.8\"\n rustc-hash = \"1.0\"\n jod-thread = \"0.1.0\"\n walkdir = \"2.3.1\"\n-globset = \"0.4.5\"\n crossbeam-channel = \"0.4.0\"\n notify = \"5.0.0-pre.3\"\n "}, {"sha": "59da3d77a10b9779219d576c99fa82eebed9bfec", "filename": "crates/vfs-notify/src/include.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fd6717799c03c9171bb7ec0f50bce98d1dfb44bd/crates%2Fvfs-notify%2Fsrc%2Finclude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6717799c03c9171bb7ec0f50bce98d1dfb44bd/crates%2Fvfs-notify%2Fsrc%2Finclude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Finclude.rs?ref=fd6717799c03c9171bb7ec0f50bce98d1dfb44bd", "patch": "@@ -1,42 +0,0 @@\n-//! See `Include`.\n-use std::convert::TryFrom;\n-\n-use globset::{Glob, GlobSet, GlobSetBuilder};\n-use paths::{RelPath, RelPathBuf};\n-\n-/// `Include` is the opposite of .gitignore.\n-///\n-/// It describes the set of files inside some directory.\n-///\n-/// The current implementation is very limited, it allows including file globs\n-/// and recursively excluding directories.\n-#[derive(Debug, Clone)]\n-pub(crate) struct Include {\n-    include_files: GlobSet,\n-    exclude_dirs: Vec<RelPathBuf>,\n-}\n-\n-impl Include {\n-    pub(crate) fn new(include: Vec<String>) -> Include {\n-        let mut include_files = GlobSetBuilder::new();\n-        let mut exclude_dirs = Vec::new();\n-\n-        for glob in include {\n-            if glob.starts_with(\"!/\") {\n-                if let Ok(path) = RelPathBuf::try_from(&glob[\"!/\".len()..]) {\n-                    exclude_dirs.push(path)\n-                }\n-            } else {\n-                include_files.add(Glob::new(&glob).unwrap());\n-            }\n-        }\n-        let include_files = include_files.build().unwrap();\n-        Include { include_files, exclude_dirs }\n-    }\n-    pub(crate) fn include_file(&self, path: &RelPath) -> bool {\n-        self.include_files.is_match(path)\n-    }\n-    pub(crate) fn exclude_dir(&self, path: &RelPath) -> bool {\n-        self.exclude_dirs.iter().any(|excluded| path.starts_with(excluded))\n-    }\n-}"}, {"sha": "e1e36612a608d9369ea2259b334ace880001bc11", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 47, "deletions": 57, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/130e7632acef435caa9bf56e7333e4c28c7dffc7/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130e7632acef435caa9bf56e7333e4c28c7dffc7/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=130e7632acef435caa9bf56e7333e4c28c7dffc7", "patch": "@@ -6,18 +6,14 @@\n //!\n //! Hopefully, one day a reliable file watching/walking crate appears on\n //! crates.io, and we can reduce this to trivial glue code.\n-mod include;\n-\n-use std::convert::{TryFrom, TryInto};\n+use std::convert::TryFrom;\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use notify::{RecommendedWatcher, RecursiveMode, Watcher};\n use paths::{AbsPath, AbsPathBuf};\n use vfs::loader;\n use walkdir::WalkDir;\n \n-use crate::include::Include;\n-\n #[derive(Debug)]\n pub struct NotifyHandle {\n     // Relative order of fields below is significant.\n@@ -53,7 +49,7 @@ type NotifyEvent = notify::Result<notify::Event>;\n \n struct NotifyActor {\n     sender: loader::Sender,\n-    config: Vec<(AbsPathBuf, Include, bool)>,\n+    watched_entries: Vec<loader::Entry>,\n     // Drop order is significant.\n     watcher: Option<(RecommendedWatcher, Receiver<NotifyEvent>)>,\n }\n@@ -66,7 +62,7 @@ enum Event {\n \n impl NotifyActor {\n     fn new(sender: loader::Sender) -> NotifyActor {\n-        NotifyActor { sender, config: Vec::new(), watcher: None }\n+        NotifyActor { sender, watched_entries: Vec::new(), watcher: None }\n     }\n     fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n         let watcher_receiver = self.watcher.as_ref().map(|(_, receiver)| receiver);\n@@ -93,15 +89,17 @@ impl NotifyActor {\n                         let n_total = config.load.len();\n                         self.send(loader::Message::Progress { n_total, n_done: 0 });\n \n-                        self.config.clear();\n+                        self.watched_entries.clear();\n \n                         for (i, entry) in config.load.into_iter().enumerate() {\n                             let watch = config.watch.contains(&i);\n+                            if watch {\n+                                self.watched_entries.push(entry.clone())\n+                            }\n                             let files = self.load_entry(entry, watch);\n                             self.send(loader::Message::Loaded { files });\n                             self.send(loader::Message::Progress { n_total, n_done: i + 1 });\n                         }\n-                        self.config.sort_by(|x, y| x.0.cmp(&y.0));\n                     }\n                     Message::Invalidate(path) => {\n                         let contents = read(path.as_path());\n@@ -116,34 +114,27 @@ impl NotifyActor {\n                             .into_iter()\n                             .map(|path| AbsPathBuf::try_from(path).unwrap())\n                             .filter_map(|path| {\n-                                let is_dir = path.is_dir();\n-                                let is_file = path.is_file();\n-\n-                                let config_idx =\n-                                    match self.config.binary_search_by(|it| it.0.cmp(&path)) {\n-                                        Ok(it) => it,\n-                                        Err(it) => it.saturating_sub(1),\n-                                    };\n-                                let include = self.config.get(config_idx).and_then(|it| {\n-                                    let rel_path = path.strip_prefix(&it.0)?;\n-                                    Some((rel_path, &it.1))\n-                                });\n-\n-                                if let Some((rel_path, include)) = include {\n-                                    if is_dir && include.exclude_dir(&rel_path)\n-                                        || is_file && !include.include_file(&rel_path)\n-                                    {\n-                                        return None;\n-                                    }\n+                                if path.is_dir()\n+                                    && self\n+                                        .watched_entries\n+                                        .iter()\n+                                        .any(|entry| entry.contains_dir(&path))\n+                                {\n+                                    self.watch(path);\n+                                    return None;\n                                 }\n \n-                                if is_dir {\n-                                    self.watch(path);\n+                                if !path.is_file() {\n                                     return None;\n                                 }\n-                                if !is_file {\n+                                if !self\n+                                    .watched_entries\n+                                    .iter()\n+                                    .any(|entry| entry.contains_file(&path))\n+                                {\n                                     return None;\n                                 }\n+\n                                 let contents = read(&path);\n                                 Some((path, contents))\n                             })\n@@ -170,43 +161,42 @@ impl NotifyActor {\n                     (file, contents)\n                 })\n                 .collect::<Vec<_>>(),\n-            loader::Entry::Directory { path, include } => {\n-                let include = Include::new(include);\n-                self.config.push((path.clone(), include.clone(), watch));\n-\n-                let files = WalkDir::new(&path)\n-                    .into_iter()\n-                    .filter_entry(|entry| {\n-                        let abs_path: &AbsPath = entry.path().try_into().unwrap();\n-                        match abs_path.strip_prefix(&path) {\n-                            Some(rel_path) => {\n-                                !(entry.file_type().is_dir() && include.exclude_dir(rel_path))\n-                            }\n-                            None => false,\n+            loader::Entry::Directories(dirs) => {\n+                let mut res = Vec::new();\n+\n+                for root in dirs.include.iter() {\n+                    let walkdir = WalkDir::new(root).into_iter().filter_entry(|entry| {\n+                        if !entry.file_type().is_dir() {\n+                            return true;\n                         }\n-                    })\n-                    .filter_map(|entry| entry.ok())\n-                    .filter_map(|entry| {\n+                        let path = AbsPath::assert(entry.path());\n+                        root == path\n+                            || dirs.exclude.iter().chain(&dirs.include).all(|it| it != path)\n+                    });\n+\n+                    let files = walkdir.filter_map(|it| it.ok()).filter_map(|entry| {\n                         let is_dir = entry.file_type().is_dir();\n                         let is_file = entry.file_type().is_file();\n-                        let abs_path = AbsPathBuf::try_from(entry.into_path()).unwrap();\n+                        let abs_path = AbsPathBuf::assert(entry.into_path());\n                         if is_dir && watch {\n                             self.watch(abs_path.clone());\n                         }\n-                        let rel_path = abs_path.strip_prefix(&path)?;\n-                        if is_file && include.include_file(&rel_path) {\n-                            Some(abs_path)\n-                        } else {\n-                            None\n+                        if !is_file {\n+                            return None;\n+                        }\n+                        let ext = abs_path.extension().unwrap_or_default();\n+                        if dirs.extensions.iter().all(|it| it.as_str() != ext) {\n+                            return None;\n                         }\n+                        Some(abs_path)\n                     });\n \n-                files\n-                    .map(|file| {\n+                    res.extend(files.map(|file| {\n                         let contents = read(file.as_path());\n                         (file, contents)\n-                    })\n-                    .collect()\n+                    }));\n+                }\n+                res\n             }\n         }\n     }"}, {"sha": "9c6e4b6a7da697de968f0db41a899f08b49dfc39", "filename": "crates/vfs/src/loader.rs", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/130e7632acef435caa9bf56e7333e4c28c7dffc7/crates%2Fvfs%2Fsrc%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130e7632acef435caa9bf56e7333e4c28c7dffc7/crates%2Fvfs%2Fsrc%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Floader.rs?ref=130e7632acef435caa9bf56e7333e4c28c7dffc7", "patch": "@@ -3,10 +3,25 @@ use std::fmt;\n \n use paths::{AbsPath, AbsPathBuf};\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum Entry {\n     Files(Vec<AbsPathBuf>),\n-    Directory { path: AbsPathBuf, include: Vec<String> },\n+    Directories(Directories),\n+}\n+\n+/// Specifies a set of files on the file system.\n+///\n+/// A file is included if:\n+///   * it has included extension\n+///   * it is under an `include` path\n+///   * it is not under `exclude` path\n+///\n+/// If many include/exclude paths match, the longest one wins.\n+#[derive(Debug, Clone)]\n+pub struct Directories {\n+    pub extensions: Vec<String>,\n+    pub include: Vec<AbsPathBuf>,\n+    pub exclude: Vec<AbsPathBuf>,\n }\n \n #[derive(Debug)]\n@@ -33,21 +48,70 @@ pub trait Handle: fmt::Debug {\n \n impl Entry {\n     pub fn rs_files_recursively(base: AbsPathBuf) -> Entry {\n-        Entry::Directory { path: base, include: globs(&[\"*.rs\", \"!/.git/\"]) }\n+        Entry::Directories(dirs(base, &[\".git\"]))\n     }\n     pub fn local_cargo_package(base: AbsPathBuf) -> Entry {\n-        Entry::Directory { path: base, include: globs(&[\"*.rs\", \"!/target/\", \"!/.git/\"]) }\n+        Entry::Directories(dirs(base, &[\".git\", \"target\"]))\n     }\n     pub fn cargo_package_dependency(base: AbsPathBuf) -> Entry {\n-        Entry::Directory {\n-            path: base,\n-            include: globs(&[\"*.rs\", \"!/tests/\", \"!/examples/\", \"!/benches/\", \"!/.git/\"]),\n+        Entry::Directories(dirs(base, &[\".git\", \"/tests\", \"/examples\", \"/benches\"]))\n+    }\n+\n+    pub fn contains_file(&self, path: &AbsPath) -> bool {\n+        match self {\n+            Entry::Files(files) => files.iter().any(|it| it == path),\n+            Entry::Directories(dirs) => dirs.contains_file(path),\n+        }\n+    }\n+    pub fn contains_dir(&self, path: &AbsPath) -> bool {\n+        match self {\n+            Entry::Files(_) => false,\n+            Entry::Directories(dirs) => dirs.contains_dir(path),\n+        }\n+    }\n+}\n+\n+impl Directories {\n+    pub fn contains_file(&self, path: &AbsPath) -> bool {\n+        let ext = path.extension().unwrap_or_default();\n+        if self.extensions.iter().all(|it| it.as_str() != ext) {\n+            return false;\n+        }\n+        self.includes_path(path)\n+    }\n+    pub fn contains_dir(&self, path: &AbsPath) -> bool {\n+        self.includes_path(path)\n+    }\n+    fn includes_path(&self, path: &AbsPath) -> bool {\n+        let mut include = None;\n+        for incl in &self.include {\n+            if is_prefix(incl, path) {\n+                include = Some(match include {\n+                    Some(prev) if is_prefix(incl, prev) => prev,\n+                    _ => incl,\n+                })\n+            }\n+        }\n+        let include = match include {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+        for excl in &self.exclude {\n+            if is_prefix(excl, path) && is_prefix(include, excl) {\n+                return false;\n+            }\n+        }\n+        return true;\n+\n+        fn is_prefix(short: &AbsPath, long: &AbsPath) -> bool {\n+            long.strip_prefix(short).is_some()\n         }\n     }\n }\n \n-fn globs(globs: &[&str]) -> Vec<String> {\n-    globs.iter().map(|it| it.to_string()).collect()\n+fn dirs(base: AbsPathBuf, exclude: &[&str]) -> Directories {\n+    let exclude = exclude.iter().map(|it| base.join(it)).collect::<Vec<_>>();\n+    Directories { extensions: vec![\"rs\".to_string()], include: vec![base], exclude }\n }\n \n impl fmt::Debug for Message {"}, {"sha": "ca14e8ac1357d474693bfa5afd056f2d55f7b396", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130e7632acef435caa9bf56e7333e4c28c7dffc7/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130e7632acef435caa9bf56e7333e4c28c7dffc7/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=130e7632acef435caa9bf56e7333e4c28c7dffc7", "patch": "@@ -54,7 +54,6 @@ fn check_licenses() {\n     let expected = \"\n 0BSD OR MIT OR Apache-2.0\n Apache-2.0\n-Apache-2.0 / MIT\n Apache-2.0 OR BSL-1.0\n Apache-2.0 OR MIT\n Apache-2.0 WITH LLVM-exception OR Apache-2.0 OR MIT"}]}