{"sha": "c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNTY3NmI5N2YyMTUxMjQyYTA3ZTk4YmJkZTUzZTljNWQ3ZjFlN2E=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-05-01T06:50:59Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-05-21T08:55:43Z"}, "message": "Add an in-place rotate method for slices to libcore\n\nA helpful primitive for moving chunks of data around inside a slice.\nIn particular, adding elements to the end of a Vec then moving them\nsomewhere else, as a way to do efficient multiple-insert.  (There's\ndrain for efficient block-remove, but no easy way to block-insert.)\n\nTalk with another example: <https://youtu.be/qH6sSOr-yk8?t=560>", "tree": {"sha": "39dddd3ba1fe72fb5d21b6049ec02b178dcf2683", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39dddd3ba1fe72fb5d21b6049ec02b178dcf2683"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "html_url": "https://github.com/rust-lang/rust/commit/c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bd9e1f5e6e9832691d033f1cc32409f5e2a9145", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd9e1f5e6e9832691d033f1cc32409f5e2a9145", "html_url": "https://github.com/rust-lang/rust/commit/0bd9e1f5e6e9832691d033f1cc32409f5e2a9145"}], "stats": {"total": 327, "additions": 327, "deletions": 0}, "files": [{"sha": "de2c2b837677f98cba517828b2601959eb9a536e", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -195,6 +195,7 @@\n     - [sip_hash_13](library-features/sip-hash-13.md)\n     - [slice_concat_ext](library-features/slice-concat-ext.md)\n     - [slice_get_slice](library-features/slice-get-slice.md)\n+    - [slice_rotate](library-features/slice-rotate.md)\n     - [slice_rsplit](library-features/slice-rsplit.md)\n     - [sort_internals](library-features/sort-internals.md)\n     - [sort_unstable](library-features/sort-unstable.md)"}, {"sha": "40063412c2961852a8c72549fe9f461a9dfe7aeb", "filename": "src/doc/unstable-book/src/library-features/slice-rotate.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rotate.md", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rotate.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rotate.md?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -0,0 +1,7 @@\n+# `slice_rotate`\n+\n+The tracking issue for this feature is: [#123456789]\n+\n+[#123456789]: https://github.com/rust-lang/rust/issues/123456789\n+\n+------------------------"}, {"sha": "958020d0b0e0c33e3b70b803f187fc204c0f84bb", "filename": "src/libcollections/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Flib.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -13,6 +13,7 @@\n #![feature(i128_type)]\n #![feature(rand)]\n #![feature(repr_simd)]\n+#![feature(slice_rotate)]\n #![feature(sort_unstable)]\n #![feature(test)]\n "}, {"sha": "aa5a438b35e62341e5611755f233b1b12c7c830e", "filename": "src/libcollections/benches/slice.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fslice.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -195,6 +195,11 @@ fn gen_random(len: usize) -> Vec<u64> {\n     rng.gen_iter::<u64>().take(len).collect()\n }\n \n+fn gen_random_bytes(len: usize) -> Vec<u8> {\n+    let mut rng = thread_rng();\n+    rng.gen_iter::<u8>().take(len).collect()\n+}\n+\n fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n     let mut rng = thread_rng();\n     let mut v = gen_ascending(len);\n@@ -315,3 +320,39 @@ reverse!(reverse_u64, u64, |x| x as u64);\n reverse!(reverse_u128, u128, |x| x as u128);\n #[repr(simd)] struct F64x4(f64, f64, f64, f64);\n reverse!(reverse_simd_f64x4, F64x4, |x| { let x = x as f64; F64x4(x,x,x,x) });\n+\n+macro_rules! rotate {\n+    ($name:ident, $gen:expr, $len:expr, $mid:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            let size = mem::size_of_val(&$gen(1)[0]);\n+            let mut v = $gen($len * 8 / size);\n+            b.iter(|| black_box(&mut v).rotate(($mid*8+size-1)/size));\n+            b.bytes = (v.len() * size) as u64;\n+        }\n+    }\n+}\n+\n+rotate!(rotate_tiny_by1, gen_random, 16, 1);\n+rotate!(rotate_tiny_half, gen_random, 16, 16/2);\n+rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16/2+1);\n+\n+rotate!(rotate_medium_by1, gen_random, 9158, 1);\n+rotate!(rotate_medium_by727_u64, gen_random, 9158, 727);\n+rotate!(rotate_medium_by727_bytes, gen_random_bytes, 9158, 727);\n+rotate!(rotate_medium_by727_strings, gen_strings, 9158, 727);\n+rotate!(rotate_medium_half, gen_random, 9158, 9158/2);\n+rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158/2+1);\n+\n+// Intended to use more RAM than the machine has cache\n+rotate!(rotate_huge_by1, gen_random, 5*1024*1024, 1);\n+rotate!(rotate_huge_by9199_u64, gen_random, 5*1024*1024, 9199);\n+rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5*1024*1024, 9199);\n+rotate!(rotate_huge_by9199_strings, gen_strings, 5*1024*1024, 9199);\n+rotate!(rotate_huge_by9199_big, gen_big_random, 5*1024*1024, 9199);\n+rotate!(rotate_huge_by1234577_u64, gen_random, 5*1024*1024, 1234577);\n+rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5*1024*1024, 1234577);\n+rotate!(rotate_huge_by1234577_strings, gen_strings, 5*1024*1024, 1234577);\n+rotate!(rotate_huge_by1234577_big, gen_big_random, 5*1024*1024, 1234577);\n+rotate!(rotate_huge_half, gen_random, 5*1024*1024, 5*1024*1024/2);\n+rotate!(rotate_huge_half_plus_one, gen_random, 5*1024*1024, 5*1024*1024/2+1);"}, {"sha": "713f379014f39788b20cb0820ad189dbcc3ca26a", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -55,6 +55,7 @@\n #![feature(shared)]\n #![feature(slice_get_slice)]\n #![feature(slice_patterns)]\n+#![cfg_attr(not(test), feature(slice_rotate))]\n #![feature(slice_rsplit)]\n #![cfg_attr(not(test), feature(sort_unstable))]\n #![feature(specialization)]"}, {"sha": "c4c20848caae65a22d09ba342d2ce1a11aee3150", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -1337,6 +1337,58 @@ impl<T> [T] {\n         core_slice::SliceExt::sort_unstable_by_key(self, f);\n     }\n \n+    /// Permutes the slice in-place such that `self[mid..]` move to the\n+    /// beginning of the slice while `self[..mid]` move to the end of the\n+    /// slice.  Equivalently, rotates the slice `mid` places to the left\n+    /// or `k = self.len() - mid` places to the right.\n+    ///\n+    /// Rotation by `mid` and rotation by `k` are inverse operations.\n+    /// The method returns `k`, which is also the new location of\n+    /// the formerly-first element.\n+    ///\n+    /// This is a \"k-rotation\", a permutation in which item `i` moves to\n+    /// position `i + k`, modulo the length of the slice.  See _Elements\n+    /// of Programming_ [\u00a710.4][eop].\n+    ///\n+    /// [eop]: https://books.google.com/books?id=CO9ULZGINlsC&pg=PA178&q=k-rotation\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if `mid` is greater than the length of the\n+    /// slice.  (Note that `mid == self.len()` does _not_ panic; it's a nop\n+    /// rotation with `k == 0`, the inverse of a rotation with `mid == 0`.)\n+    ///\n+    /// # Complexity\n+    ///\n+    /// Takes linear (in `self.len()`) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_rotate)]\n+    ///\n+    /// let mut a = [1, 2, 3, 4, 5, 6, 7];\n+    /// let k = a.rotate(2);\n+    /// assert_eq!(&a, &[3, 4, 5, 6, 7, 1, 2]);\n+    /// a.rotate(k);\n+    /// assert_eq!(&a, &[1, 2, 3, 4, 5, 6, 7]);\n+    ///\n+    /// fn extend_at<T, I>(v: &mut Vec<T>, index: usize, iter: I)\n+    ///     where I: Iterator<Item=T>\n+    /// {\n+    ///     let mid = v.len() - index;\n+    ///     v.extend(iter);\n+    ///     v[index..].rotate(mid);\n+    /// }\n+    /// let mut v = (0..10).collect();\n+    /// extend_at(&mut v, 7, 100..104);\n+    /// assert_eq!(&v, &[0, 1, 2, 3, 4, 5, 6, 100, 101, 102, 103, 7, 8, 9]);\n+    /// ```\n+    #[unstable(feature = \"slice_rotate\", issue = \"123456789\")]\n+    pub fn rotate(&mut self, mid: usize) -> usize {\n+        core_slice::SliceExt::rotate(self, mid)\n+    }\n+\n     /// Copies the elements from `src` into `self`.\n     ///\n     /// The length of `src` must be the same as `self`."}, {"sha": "7eab5a049c38c6a613f95376f1a992330ce968a8", "filename": "src/libcollections/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Flib.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -20,6 +20,7 @@\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n+#![feature(slice_rotate)]\n #![feature(splice)]\n #![feature(step_by)]\n #![feature(str_escape)]"}, {"sha": "6feaf91d6da064fa1d0103875e2d82936f394eee", "filename": "src/libcollections/tests/slice.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcollections%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fslice.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -466,6 +466,42 @@ fn test_sort_stability() {\n     }\n }\n \n+#[test]\n+fn test_rotate() {\n+    let expected: Vec<_> = (0..13).collect();\n+    let mut v = Vec::new();\n+\n+    // no-ops\n+    v.clone_from(&expected);\n+    v.rotate(0);\n+    assert_eq!(v, expected);\n+    v.rotate(expected.len());\n+    assert_eq!(v, expected);\n+    let mut zst_array = [(), (), ()];\n+    zst_array.rotate(2);\n+\n+    // happy path\n+    v = (5..13).chain(0..5).collect();\n+    let k = v.rotate(8);\n+    assert_eq!(v, expected);\n+    assert_eq!(k, 5);\n+\n+    let expected: Vec<_> = (0..1000).collect();\n+\n+    // small rotations in large slice, uses ptr::copy\n+    v = (2..1000).chain(0..2).collect();\n+    v.rotate(998);\n+    assert_eq!(v, expected);\n+    v = (998..1000).chain(0..998).collect();\n+    v.rotate(2);\n+    assert_eq!(v, expected);\n+\n+    // non-small prime rotation, has a few rounds of swapping\n+    v = (389..1000).chain(0..389).collect();\n+    v.rotate(1000-389);\n+    assert_eq!(v, expected);\n+}\n+\n #[test]\n fn test_concat() {\n     let v: [Vec<i32>; 0] = [];"}, {"sha": "744dd791a7e77446a406cd141d6f38b0fdeda233", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -51,6 +51,7 @@ use mem;\n use marker::{Copy, Send, Sync, Sized, self};\n use iter_private::TrustedRandomAccess;\n \n+mod rotate;\n mod sort;\n \n #[repr(C)]\n@@ -202,6 +203,9 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n+    #[unstable(feature = \"slice_rotate\", issue = \"123456789\")]\n+    fn rotate(&mut self, mid: usize) -> usize;\n+\n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n     fn clone_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Clone;\n \n@@ -635,6 +639,18 @@ impl<T> SliceExt for [T] {\n         self.binary_search_by(|p| p.borrow().cmp(x))\n     }\n \n+    fn rotate(&mut self, mid: usize) -> usize {\n+        assert!(mid <= self.len());\n+        let k = self.len() - mid;\n+\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            rotate::ptr_rotate(mid, p.offset(mid as isize), k);\n+        }\n+\n+        k\n+    }\n+\n     #[inline]\n     fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n         assert!(self.len() == src.len(),"}, {"sha": "71a627a327c19a634205ee965225028f5aad6b57", "filename": "src/libcore/slice/rotate.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cmp;\n+use mem;\n+use ptr;\n+\n+/// Rotation is much faster if it has access to a little bit of memory. This\n+/// union provides a RawVec-like interface, but to a fixed-size stack buffer.\n+#[allow(unions_with_drop_fields)]\n+union RawArray<T> {\n+    /// Ensure this is appropriately aligned for T, and is big\n+    /// enough for two elements even if T is enormous.\n+    typed: [T; 2],\n+    /// For normally-sized types, especially things like u8, having more\n+    /// than 2 in the buffer is necessary for usefulness, so pad it out\n+    /// enough to be helpful, but not so big as to risk overflow.\n+    _extra: [usize; 32],\n+}\n+\n+impl<T> RawArray<T> {\n+    fn new() -> Self {\n+        unsafe { mem::uninitialized() }\n+    }\n+    fn ptr(&self) -> *mut T {\n+        unsafe { &self.typed as *const T as *mut T }\n+    }\n+    fn cap() -> usize {\n+        if mem::size_of::<T>() == 0 {\n+            usize::max_value()\n+        } else {\n+            mem::size_of::<Self>() / mem::size_of::<T>()\n+        }\n+    }\n+}\n+\n+/// Rotates the range `[mid-left, mid+right)` such that the element at `mid`\n+/// becomes the first element.  Equivalently, rotates the range `left`\n+/// elements to the left or `right` elements to the right.\n+///\n+/// # Safety\n+///\n+/// The specified range must be valid for reading and writing.\n+/// The type `T` must have non-zero size.\n+///\n+/// # Algorithm\n+///\n+/// For longer rotations, swap the left-most `delta = min(left, right)`\n+/// elements with the right-most `delta` elements.  LLVM vectorizes this,\n+/// which is profitable as we only reach this step for a \"large enough\"\n+/// rotation.  Doing this puts `delta` elements on the larger side into the\n+/// correct position, leaving a smaller rotate problem.  Demonstration:\n+///\n+/// ```text\n+/// [ 6 7 8 9 10 11 12 13 . 1 2 3 4 5 ]\n+/// 1 2 3 4 5 [ 11 12 13 . 6 7 8 9 10 ]\n+/// 1 2 3 4 5 [ 8 9 10 . 6 7 ] 11 12 13\n+/// 1 2 3 4 5 6 7 [ 10 . 8 9 ] 11 12 13\n+/// 1 2 3 4 5 6 7 [ 9 . 8 ] 10 11 12 13\n+/// 1 2 3 4 5 6 7 8 [ . ] 9 10 11 12 13\n+/// ```\n+///\n+/// Once the rotation is small enough, copy some elements into a stack\n+/// buffer, `memmove` the others, and move the ones back from the buffer.\n+pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n+    loop {\n+        let delta = cmp::min(left, right);\n+        if delta <= RawArray::<T>::cap() {\n+            break;\n+        }\n+\n+        ptr_swap_n(\n+            mid.offset(-(left as isize)),\n+            mid.offset((right-delta) as isize),\n+            delta);\n+\n+        if left <= right {\n+            right -= delta;\n+        } else {\n+            left -= delta;\n+        }\n+    }\n+\n+    let rawarray = RawArray::new();\n+    let buf = rawarray.ptr();\n+\n+    let dim = mid.offset(-(left as isize)).offset(right as isize);\n+    if left <= right {\n+        ptr::copy_nonoverlapping(mid.offset(-(left as isize)), buf, left);\n+        ptr::copy(mid, mid.offset(-(left as isize)), right);\n+        ptr::copy_nonoverlapping(buf, dim, left);\n+    }\n+    else {\n+        ptr::copy_nonoverlapping(mid, buf, right);\n+        ptr::copy(mid.offset(-(left as isize)), dim, left);\n+        ptr::copy_nonoverlapping(buf, mid.offset(-(left as isize)), right);\n+    }\n+}\n+\n+unsafe fn ptr_swap_u8(a: *mut u8, b: *mut u8, n: usize) {\n+    for i in 0..n {\n+        ptr::swap(a.offset(i as isize), b.offset(i as isize));\n+    }\n+}\n+unsafe fn ptr_swap_u16(a: *mut u16, b: *mut u16, n: usize) {\n+    for i in 0..n {\n+        ptr::swap(a.offset(i as isize), b.offset(i as isize));\n+    }\n+}\n+unsafe fn ptr_swap_u32(a: *mut u32, b: *mut u32, n: usize) {\n+    for i in 0..n {\n+        ptr::swap(a.offset(i as isize), b.offset(i as isize));\n+    }\n+}\n+unsafe fn ptr_swap_u64(a: *mut u64, b: *mut u64, n: usize) {\n+    for i in 0..n {\n+        ptr::swap(a.offset(i as isize), b.offset(i as isize));\n+    }\n+}\n+\n+unsafe fn ptr_swap_n<T>(a: *mut T, b: *mut T, n: usize) {\n+    // Doing this as a generic is 16% & 40% slower in two of the `String`\n+    // benchmarks, as (based on the block names) LLVM doesn't vectorize it.\n+    // Since this is just operating on raw memory, dispatch to a version\n+    // with appropriate alignment.  Helps with code size as well, by\n+    // avoiding monomorphizing different unrolled loops for `i32`,\n+    // `u32`, `f32`, `[u32; 1]`, etc.\n+    let size_of_t = mem::size_of::<T>();\n+    let align_of_t = mem::align_of::<T>();\n+\n+    let a64 = mem::align_of::<u64>();\n+    if a64 == 8 && align_of_t % a64 == 0 {\n+        return ptr_swap_u64(a as *mut u64, b as *mut u64, n * (size_of_t / 8));\n+    }\n+\n+    let a32 = mem::align_of::<u32>();\n+    if a32 == 4 && align_of_t % a32 == 0 {\n+        return ptr_swap_u32(a as *mut u32, b as *mut u32, n * (size_of_t / 4));\n+    }\n+\n+    let a16 = mem::align_of::<u16>();\n+    if a16 == 2 && align_of_t % a16 == 0 {\n+        return ptr_swap_u16(a as *mut u16, b as *mut u16, n * (size_of_t / 2));\n+    }\n+\n+    ptr_swap_u8(a as *mut u8, b as *mut u8, n * size_of_t);\n+}"}, {"sha": "a9f88e9fd02604c1d6fbbc5d0b32501f61ba6333", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -29,6 +29,7 @@\n #![feature(raw)]\n #![feature(sip_hash_13)]\n #![feature(slice_patterns)]\n+#![feature(slice_rotate)]\n #![feature(sort_internals)]\n #![feature(sort_unstable)]\n #![feature(step_by)]"}, {"sha": "f34f94975009efe36ead17ed9afa828b33a6ebfb", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05676b97f2151242a07e98bbde53e9c5d7f1e7a/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=c05676b97f2151242a07e98bbde53e9c5d7f1e7a", "patch": "@@ -238,6 +238,22 @@ fn test_find_rfind() {\n     assert_eq!(v.iter().rfind(|&&x| x <= 3), Some(&3));\n }\n \n+#[test]\n+fn test_rotate() {\n+    const N: usize = 600;\n+    let a: &mut [_] = &mut [0; N];\n+    for i in 0..N {\n+        a[i] = i;\n+    }\n+\n+    let k = a.rotate(42);\n+\n+    assert_eq!(k, N - 42);\n+    for i in 0..N {\n+        assert_eq!(a[(i+k)%N], i);\n+    }\n+}\n+\n #[test]\n fn sort_unstable() {\n     let mut v = [0; 600];"}]}