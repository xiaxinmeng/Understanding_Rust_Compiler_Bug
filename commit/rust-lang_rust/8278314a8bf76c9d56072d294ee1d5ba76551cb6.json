{"sha": "8278314a8bf76c9d56072d294ee1d5ba76551cb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNzgzMTRhOGJmNzZjOWQ1NjA3MmQyOTRlZTFkNWJhNzY1NTFjYjY=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-12-22T03:49:03Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-01-16T23:40:47Z"}, "message": "Remove PredicateKind::Atom", "tree": {"sha": "2b4d38a219636d7b72263ce851b4465a2f0e7fae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b4d38a219636d7b72263ce851b4465a2f0e7fae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8278314a8bf76c9d56072d294ee1d5ba76551cb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8278314a8bf76c9d56072d294ee1d5ba76551cb6", "html_url": "https://github.com/rust-lang/rust/commit/8278314a8bf76c9d56072d294ee1d5ba76551cb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8278314a8bf76c9d56072d294ee1d5ba76551cb6/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a6518427e11e6dd13d6f39663b82eb4f810ca05", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6518427e11e6dd13d6f39663b82eb4f810ca05", "html_url": "https://github.com/rust-lang/rust/commit/8a6518427e11e6dd13d6f39663b82eb4f810ca05"}], "stats": {"total": 172, "additions": 72, "deletions": 100}, "files": [{"sha": "6dbaf8d225a7ac22eba3e4612b467006cd6f9a5a", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -541,8 +541,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n                 }\n             };\n-            let predicate =\n-                predicate.rebind(atom).potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n+            let predicate = predicate.rebind(atom).potentially_quantified(self.tcx);\n \n             Obligation::new(cause.clone(), param_env, predicate)\n         })"}, {"sha": "d9ef5d88f1cfaef3f80f89edc1d04cd9106a2545", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -14,7 +14,6 @@ pub fn anonymize_predicate<'tcx>(\n             let new = ty::PredicateKind::ForAll(tcx.anonymize_late_bound_regions(binder));\n             tcx.reuse_or_mk_predicate(pred, new)\n         }\n-        ty::PredicateKind::Atom(_) => pred,\n     }\n }\n "}, {"sha": "47ada10f55f84ee7896be5fa3fe4bac65dbeca98", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -211,7 +211,6 @@ impl FlagComputation {\n                     computation.add_predicate_atom(atom)\n                 });\n             }\n-            ty::PredicateKind::Atom(atom) => self.add_predicate_atom(atom),\n         }\n     }\n "}, {"sha": "539506409660c0e701385ee7ae6b56039b6a41c3", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -1037,7 +1037,7 @@ crate struct PredicateInner<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateInner<'_>, 48);\n+static_assert_size!(PredicateInner<'_>, 40);\n \n #[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n@@ -1074,10 +1074,6 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn skip_binders(self) -> PredicateAtom<'tcx> {\n         match self.kind() {\n             &PredicateKind::ForAll(binder) => binder.skip_binder(),\n-            &PredicateKind::Atom(atom) => {\n-                debug_assert!(!atom.has_escaping_bound_vars());\n-                atom\n-            }\n         }\n     }\n \n@@ -1090,7 +1086,6 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn skip_binders_unchecked(self) -> PredicateAtom<'tcx> {\n         match self.kind() {\n             &PredicateKind::ForAll(binder) => binder.skip_binder(),\n-            &PredicateKind::Atom(atom) => atom,\n         }\n     }\n \n@@ -1099,19 +1094,14 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn bound_atom(self) -> Binder<PredicateAtom<'tcx>> {\n         match self.kind() {\n             &PredicateKind::ForAll(binder) => binder,\n-            &PredicateKind::Atom(atom) => {\n-                debug_assert!(!atom.has_escaping_bound_vars());\n-                Binder::dummy(atom)\n-            }\n         }\n     }\n \n     /// Allows using a `Binder<PredicateAtom<'tcx>>` even if the given predicate previously\n     /// contained unbound variables by shifting these variables outwards.\n-    pub fn bound_atom_with_opt_escaping(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n+    pub fn bound_atom_with_opt_escaping(self, _tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n         match self.kind() {\n             &PredicateKind::ForAll(binder) => binder,\n-            &PredicateKind::Atom(atom) => Binder::wrap_nonbinding(tcx, atom),\n         }\n     }\n }\n@@ -1136,7 +1126,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n pub enum PredicateKind<'tcx> {\n     /// `for<'a>: ...`\n     ForAll(Binder<PredicateAtom<'tcx>>),\n-    Atom(PredicateAtom<'tcx>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n@@ -1189,16 +1178,8 @@ pub enum PredicateAtom<'tcx> {\n \n impl<'tcx> Binder<PredicateAtom<'tcx>> {\n     /// Wraps `self` with the given qualifier if this predicate has any unbound variables.\n-    pub fn potentially_quantified(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        qualifier: impl FnOnce(Binder<PredicateAtom<'tcx>>) -> PredicateKind<'tcx>,\n-    ) -> Predicate<'tcx> {\n-        match self.no_bound_vars() {\n-            Some(atom) => PredicateKind::Atom(atom),\n-            None => qualifier(self),\n-        }\n-        .to_predicate(tcx)\n+    pub fn potentially_quantified(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::ForAll(self).to_predicate(tcx)\n     }\n }\n \n@@ -1289,11 +1270,7 @@ impl<'tcx> Predicate<'tcx> {\n         let substs = trait_ref.skip_binder().substs;\n         let pred = self.skip_binders();\n         let new = pred.subst(tcx, substs);\n-        if new != pred {\n-            ty::Binder::bind(new).potentially_quantified(tcx, PredicateKind::ForAll)\n-        } else {\n-            self\n-        }\n+        if new != pred { ty::Binder::bind(new).potentially_quantified(tcx) } else { self }\n     }\n }\n \n@@ -1425,7 +1402,7 @@ impl ToPredicate<'tcx> for PredicateAtom<'tcx> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         debug_assert!(!self.has_escaping_bound_vars(), \"escaping bound vars for {:?}\", self);\n-        tcx.mk_predicate(PredicateKind::Atom(self))\n+        tcx.mk_predicate(PredicateKind::ForAll(Binder::dummy(self)))\n     }\n }\n \n@@ -1450,27 +1427,25 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.value\n             .map_bound(|value| PredicateAtom::Trait(value, self.constness))\n-            .potentially_quantified(tcx, PredicateKind::ForAll)\n+            .potentially_quantified(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateAtom::RegionOutlives)\n-            .potentially_quantified(tcx, PredicateKind::ForAll)\n+        self.map_bound(PredicateAtom::RegionOutlives).potentially_quantified(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateAtom::TypeOutlives)\n-            .potentially_quantified(tcx, PredicateKind::ForAll)\n+        self.map_bound(PredicateAtom::TypeOutlives).potentially_quantified(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateAtom::Projection).potentially_quantified(tcx, PredicateKind::ForAll)\n+        self.map_bound(PredicateAtom::Projection).potentially_quantified(tcx)\n     }\n }\n "}, {"sha": "bc9ea3728b61a328f6b466741e0c53de6efdcfd9", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -2069,7 +2069,6 @@ define_print_and_forward_display! {\n \n     ty::Predicate<'tcx> {\n         match self.kind() {\n-            &ty::PredicateKind::Atom(atom) => p!(print(atom)),\n             ty::PredicateKind::ForAll(binder) => p!(print(binder)),\n         }\n     }"}, {"sha": "934d97d00e8460ee502b3e9df1b2c13c79f44885", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -232,7 +232,6 @@ impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             ty::PredicateKind::ForAll(binder) => write!(f, \"ForAll({:?})\", binder),\n-            ty::PredicateKind::Atom(atom) => write!(f, \"{:?}\", atom),\n         }\n     }\n }\n@@ -486,7 +485,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::PredicateKind::ForAll(binder) => tcx.lift(binder).map(ty::PredicateKind::ForAll),\n-            ty::PredicateKind::Atom(atom) => tcx.lift(atom).map(ty::PredicateKind::Atom),\n         }\n     }\n }"}, {"sha": "55d5331ae37b77f70d7e159be2e70a9999e9b771", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -346,45 +346,47 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         let infcx = self.selcx.infcx();\n \n         match *obligation.predicate.kind() {\n-            ty::PredicateKind::ForAll(binder) => match binder.skip_binder() {\n-                // Evaluation will discard candidates using the leak check.\n-                // This means we need to pass it the bound version of our\n-                // predicate.\n-                ty::PredicateAtom::Trait(trait_ref, _constness) => {\n-                    let trait_obligation = obligation.with(binder.rebind(trait_ref));\n-\n-                    self.process_trait_obligation(\n-                        obligation,\n-                        trait_obligation,\n-                        &mut pending_obligation.stalled_on,\n-                    )\n-                }\n-                ty::PredicateAtom::Projection(data) => {\n-                    let project_obligation = obligation.with(binder.rebind(data));\n+            ty::PredicateKind::ForAll(binder) if binder.skip_binder().has_escaping_bound_vars() => {\n+                match binder.skip_binder() {\n+                    // Evaluation will discard candidates using the leak check.\n+                    // This means we need to pass it the bound version of our\n+                    // predicate.\n+                    ty::PredicateAtom::Trait(trait_ref, _constness) => {\n+                        let trait_obligation = obligation.with(binder.rebind(trait_ref));\n+\n+                        self.process_trait_obligation(\n+                            obligation,\n+                            trait_obligation,\n+                            &mut pending_obligation.stalled_on,\n+                        )\n+                    }\n+                    ty::PredicateAtom::Projection(data) => {\n+                        let project_obligation = obligation.with(binder.rebind(data));\n \n-                    self.process_projection_obligation(\n-                        project_obligation,\n-                        &mut pending_obligation.stalled_on,\n-                    )\n-                }\n-                ty::PredicateAtom::RegionOutlives(_)\n-                | ty::PredicateAtom::TypeOutlives(_)\n-                | ty::PredicateAtom::WellFormed(_)\n-                | ty::PredicateAtom::ObjectSafe(_)\n-                | ty::PredicateAtom::ClosureKind(..)\n-                | ty::PredicateAtom::Subtype(_)\n-                | ty::PredicateAtom::ConstEvaluatable(..)\n-                | ty::PredicateAtom::ConstEquate(..) => {\n-                    let pred = infcx.replace_bound_vars_with_placeholders(binder);\n-                    ProcessResult::Changed(mk_pending(vec![\n-                        obligation.with(pred.to_predicate(self.selcx.tcx())),\n-                    ]))\n-                }\n-                ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n-                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n+                        self.process_projection_obligation(\n+                            project_obligation,\n+                            &mut pending_obligation.stalled_on,\n+                        )\n+                    }\n+                    ty::PredicateAtom::RegionOutlives(_)\n+                    | ty::PredicateAtom::TypeOutlives(_)\n+                    | ty::PredicateAtom::WellFormed(_)\n+                    | ty::PredicateAtom::ObjectSafe(_)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::Subtype(_)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => {\n+                        let pred = infcx.replace_bound_vars_with_placeholders(binder);\n+                        ProcessResult::Changed(mk_pending(vec![\n+                            obligation.with(pred.to_predicate(self.selcx.tcx())),\n+                        ]))\n+                    }\n+                    ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+                        bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n+                    }\n                 }\n-            },\n-            ty::PredicateKind::Atom(atom) => match atom {\n+            }\n+            ty::PredicateKind::ForAll(binder) => match binder.skip_binder() {\n                 ty::PredicateAtom::Trait(data, _) => {\n                     let trait_obligation = obligation.with(Binder::dummy(data));\n "}, {"sha": "a4da22fc2ca83e9500d1ca9fab203de6ed7c1d8c", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -95,8 +95,12 @@ fn compute_implied_outlives_bounds<'tcx>(\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate.kind() {\n-                &ty::PredicateKind::ForAll(..) => vec![],\n-                &ty::PredicateKind::Atom(atom) => match atom {\n+                &ty::PredicateKind::ForAll(binder)\n+                    if binder.skip_binder().has_escaping_bound_vars() =>\n+                {\n+                    vec![]\n+                }\n+                &ty::PredicateKind::ForAll(binder) => match binder.skip_binder() {\n                     ty::PredicateAtom::Trait(..)\n                     | ty::PredicateAtom::Subtype(..)\n                     | ty::PredicateAtom::Projection(..)"}, {"sha": "b1242f0d1d5183f35cd12184398383dcb529dd71", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -1949,10 +1949,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                         let predicate = ty::Binder::bind(ty::PredicateAtom::TypeOutlives(\n                             ty::OutlivesPredicate(ty, re_root_empty),\n                         ));\n-                        predicates.insert((\n-                            predicate.potentially_quantified(tcx, ty::PredicateKind::ForAll),\n-                            span,\n-                        ));\n+                        predicates.insert((predicate.potentially_quantified(tcx), span));\n                     }\n                 }\n \n@@ -1996,7 +1993,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                                 ty::Binder::bind(ty::PredicateAtom::TypeOutlives(\n                                     ty::OutlivesPredicate(ty, region),\n                                 ))\n-                                .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n+                                .potentially_quantified(tcx),\n                                 lifetime.span,\n                             ));\n                         }"}, {"sha": "649edfb8f52316368411bcb1f25857b34929875e", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -31,13 +31,11 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|(out_pred, _)| match out_pred.kind() {\n-                            ty::PredicateKind::Atom(ty::PredicateAtom::RegionOutlives(p)) => {\n-                                p.to_string()\n-                            }\n-                            ty::PredicateKind::Atom(ty::PredicateAtom::TypeOutlives(p)) => {\n-                                p.to_string()\n-                            }\n-                            err => bug!(\"unexpected predicate {:?}\", err),\n+                            ty::PredicateKind::ForAll(binder) => match binder.skip_binder() {\n+                                ty::PredicateAtom::RegionOutlives(p) => p.to_string(),\n+                                ty::PredicateAtom::TypeOutlives(p) => p.to_string(),\n+                                err => bug!(\"unexpected predicate {:?}\", err),\n+                            },\n                         })\n                         .collect();\n                     pred.sort();"}, {"sha": "fab36adb0f44e5bdd79a86d76d1ffaced705b5e6", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -1,4 +1,4 @@\n-error: cannot specialize on `ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id::This) }, (I,))`\n+error: cannot specialize on `ForAll(Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id::This) }, (I,))))`\n   --> $DIR/repeated_projection_type.rs:19:1\n    |\n LL | / impl<I, V: Id<This = (I,)>> X for V {"}, {"sha": "ad50a6a0405fcc6eff1ee94154065938e2294102", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8278314a8bf76c9d56072d294ee1d5ba76551cb6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8278314a8bf76c9d56072d294ee1d5ba76551cb6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=8278314a8bf76c9d56072d294ee1d5ba76551cb6", "patch": "@@ -115,13 +115,15 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             .filter(|p| !p.is_global())\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n-                if let ty::PredicateKind::Atom(ty::PredicateAtom::Trait(pred, _)) = obligation.predicate.kind() {\n-                    if pred.def_id() == sized_trait {\n-                        return None;\n+                let ty::PredicateKind::ForAll(binder) = obligation.predicate.kind();\n+                match binder.skip_binder() {\n+                    ty::PredicateAtom::Trait(pred, _) if !binder.has_escaping_bound_vars() => {\n+                        if pred.def_id() == sized_trait {\n+                            return None;\n+                        }\n+                        Some(pred)\n                     }\n-                    Some(pred)\n-                } else {\n-                    None\n+                    _ => None,\n                 }\n             })\n             .collect::<Vec<_>>();"}]}