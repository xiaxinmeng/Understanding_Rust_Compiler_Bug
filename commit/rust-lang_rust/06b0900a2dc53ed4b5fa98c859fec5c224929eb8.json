{"sha": "06b0900a2dc53ed4b5fa98c859fec5c224929eb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YjA5MDBhMmRjNTNlZDRiNWZhOThjODU5ZmVjNWMyMjQ5MjllYjg=", "commit": {"author": {"name": "max-heller", "email": "max.a.heller@gmail.com", "date": "2021-01-04T02:55:53Z"}, "committer": {"name": "max-heller", "email": "max.a.heller@gmail.com", "date": "2021-01-04T02:55:53Z"}, "message": "half working", "tree": {"sha": "f6685b94bb2b0cf44ff1ac43e00cd1b2b28ffed8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6685b94bb2b0cf44ff1ac43e00cd1b2b28ffed8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06b0900a2dc53ed4b5fa98c859fec5c224929eb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06b0900a2dc53ed4b5fa98c859fec5c224929eb8", "html_url": "https://github.com/rust-lang/rust/commit/06b0900a2dc53ed4b5fa98c859fec5c224929eb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06b0900a2dc53ed4b5fa98c859fec5c224929eb8/comments", "author": {"login": "max-heller", "id": 25730408, "node_id": "MDQ6VXNlcjI1NzMwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/25730408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/max-heller", "html_url": "https://github.com/max-heller", "followers_url": "https://api.github.com/users/max-heller/followers", "following_url": "https://api.github.com/users/max-heller/following{/other_user}", "gists_url": "https://api.github.com/users/max-heller/gists{/gist_id}", "starred_url": "https://api.github.com/users/max-heller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/max-heller/subscriptions", "organizations_url": "https://api.github.com/users/max-heller/orgs", "repos_url": "https://api.github.com/users/max-heller/repos", "events_url": "https://api.github.com/users/max-heller/events{/privacy}", "received_events_url": "https://api.github.com/users/max-heller/received_events", "type": "User", "site_admin": false}, "committer": {"login": "max-heller", "id": 25730408, "node_id": "MDQ6VXNlcjI1NzMwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/25730408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/max-heller", "html_url": "https://github.com/max-heller", "followers_url": "https://api.github.com/users/max-heller/followers", "following_url": "https://api.github.com/users/max-heller/following{/other_user}", "gists_url": "https://api.github.com/users/max-heller/gists{/gist_id}", "starred_url": "https://api.github.com/users/max-heller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/max-heller/subscriptions", "organizations_url": "https://api.github.com/users/max-heller/orgs", "repos_url": "https://api.github.com/users/max-heller/repos", "events_url": "https://api.github.com/users/max-heller/events{/privacy}", "received_events_url": "https://api.github.com/users/max-heller/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6", "html_url": "https://github.com/rust-lang/rust/commit/fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6"}], "stats": {"total": 101, "additions": 51, "deletions": 50}, "files": [{"sha": "f8e37d7bb56cf61b1c0dd513eb546b420ac58631", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/06b0900a2dc53ed4b5fa98c859fec5c224929eb8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06b0900a2dc53ed4b5fa98c859fec5c224929eb8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=06b0900a2dc53ed4b5fa98c859fec5c224929eb8", "patch": "@@ -1147,69 +1147,70 @@ impl LinkCollector<'_, '_> {\n             );\n         };\n \n-        let (kind, id) = match res {\n+        let verify = |kind: DefKind, id: DefId| {\n+            debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n+\n+            // Disallow e.g. linking to enums with `struct@`\n+            debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n+            match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n+                | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n+                // NOTE: this allows 'method' to mean both normal functions and associated functions\n+                // This can't cause ambiguity because both are in the same namespace.\n+                | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n+                // These are namespaces; allow anything in the namespace to match\n+                | (_, Some(Disambiguator::Namespace(_)))\n+                // If no disambiguator given, allow anything\n+                | (_, None)\n+                // All of these are valid, so do nothing\n+                => {}\n+                (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n+                (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n+                    report_mismatch(specified, Disambiguator::Kind(kind));\n+                    return None;\n+                }\n+            }\n+\n+            // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n+            if let Some((src_id, dst_id)) = id\n+                .as_local()\n+                .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n+            {\n+                use rustc_hir::def_id::LOCAL_CRATE;\n+\n+                let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n+                let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n+\n+                if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n+                    && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n+                {\n+                    privacy_error(cx, &item, &path_str, dox, &ori_link);\n+                }\n+            }\n+\n+            Some((kind, id))\n+        };\n+\n+        match res {\n             Res::Primitive(_) => {\n                 if let Some((kind, id)) = self.kind_side_channel.take() {\n-                    (kind, id)\n+                    verify(kind, id)?;\n                 } else {\n                     match disambiguator {\n-                        Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                            return Some(ItemLink {\n-                                link: ori_link.link,\n-                                link_text,\n-                                did: None,\n-                                fragment,\n-                            });\n-                        }\n+                        Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n                         Some(other) => {\n                             report_mismatch(other, Disambiguator::Primitive);\n                             return None;\n                         }\n                     }\n                 }\n+                Some(ItemLink { link: ori_link.link, link_text, did: None, fragment })\n             }\n-            Res::Def(kind, id) => (kind, id),\n-        };\n-\n-        debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n-\n-        // Disallow e.g. linking to enums with `struct@`\n-        debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n-        match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n-            | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n-            // NOTE: this allows 'method' to mean both normal functions and associated functions\n-            // This can't cause ambiguity because both are in the same namespace.\n-            | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n-            // These are namespaces; allow anything in the namespace to match\n-            | (_, Some(Disambiguator::Namespace(_)))\n-            // If no disambiguator given, allow anything\n-            | (_, None)\n-            // All of these are valid, so do nothing\n-            => {}\n-            (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n-            (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n-                report_mismatch(specified, Disambiguator::Kind(kind));\n-                return None;\n-            }\n-        }\n-\n-        // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-        if let Some((src_id, dst_id)) =\n-            id.as_local().and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n-        {\n-            use rustc_hir::def_id::LOCAL_CRATE;\n-\n-            let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n-            let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n-\n-            if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n-                && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n-            {\n-                privacy_error(cx, &item, &path_str, dox, &ori_link);\n+            Res::Def(kind, id) => {\n+                let (kind, id) = verify(kind, id)?;\n+                let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n+                Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n             }\n         }\n-        let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n-        Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n     }\n \n     fn resolve_with_disambiguator_cached("}]}