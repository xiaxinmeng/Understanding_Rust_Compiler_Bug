{"sha": "4be3262058a151699cb66f95cbdcf39cf0263a83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZTMyNjIwNThhMTUxNjk5Y2I2NmY5NWNiZGNmMzljZjAyNjNhODM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-17T14:53:10Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-17T15:03:04Z"}, "message": "syntax::ext: replace span_fatal with span_err in many places.\n\nThis means that compilation continues for longer, and so we can see more\nerrors per compile. This is mildly more user-friendly because it stops\nusers having to run rustc n times to see n macro errors: just run it\nonce to see all of them.", "tree": {"sha": "238b722025df2639984d7f1cb0d64e0369cf19c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/238b722025df2639984d7f1cb0d64e0369cf19c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4be3262058a151699cb66f95cbdcf39cf0263a83", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4be3262058a151699cb66f95cbdcf39cf0263a83", "html_url": "https://github.com/rust-lang/rust/commit/4be3262058a151699cb66f95cbdcf39cf0263a83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4be3262058a151699cb66f95cbdcf39cf0263a83/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fdc81262a5d44f10e335384b5d69b938d6d729c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fdc81262a5d44f10e335384b5d69b938d6d729c", "html_url": "https://github.com/rust-lang/rust/commit/5fdc81262a5d44f10e335384b5d69b938d6d729c"}], "stats": {"total": 329, "additions": 245, "deletions": 84}, "files": [{"sha": "021f0d29d9e237e61f0438cff1aa345d5b60fe09", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -59,9 +59,12 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     while continue_ {\n         match state {\n             Asm => {\n-                let (s, style) =\n-                    expr_to_str(cx, p.parse_expr(),\n-                                \"inline assembly must be a string literal.\");\n+                let (s, style) = match expr_to_str(cx, p.parse_expr(),\n+                                                   \"inline assembly must be a string literal.\") {\n+                    Some((s, st)) => (s, st),\n+                    // let compilation continue\n+                    None => return MacResult::dummy_expr(),\n+                };\n                 asm = s;\n                 asm_str_style = Some(style);\n             }"}, {"sha": "538562813b3bbdd73e58a0742a324b18ef353a7d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 60, "deletions": 16, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -136,6 +136,17 @@ pub enum MacResult {\n     MRAny(@AnyMacro),\n     MRDef(MacroDef),\n }\n+impl MacResult {\n+    /// Create an empty expression MacResult; useful for satisfying\n+    /// type signatures after emitting a non-fatal error (which stop\n+    /// compilation well before the validity (or otherwise)) of the\n+    /// expression are checked.\n+    pub fn dummy_expr() -> MacResult {\n+        MRExpr(@ast::Expr {\n+                id: ast::DUMMY_NODE_ID, node: ast::ExprLogLevel, span: codemap::DUMMY_SP\n+            })\n+    }\n+}\n \n pub enum SyntaxExtension {\n     // #[deriving] and such\n@@ -364,10 +375,27 @@ impl<'a> ExtCtxt<'a> {\n             _ => self.bug(\"tried to pop without a push\")\n         }\n     }\n+    /// Emit `msg` attached to `sp`, and stop compilation immediately.\n+    ///\n+    /// `span_err` should be strongly prefered where-ever possible:\n+    /// this should *only* be used when\n+    /// - continuing has a high risk of flow-on errors (e.g. errors in\n+    ///   declaring a macro would cause all uses of that macro to\n+    ///   complain about \"undefined macro\"), or\n+    /// - there is literally nothing else that can be done (however,\n+    ///   in most cases one can construct a dummy expression/item to\n+    ///   substitute; we never hit resolve/type-checking so the dummy\n+    ///   value doesn't have to match anything)\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n     }\n+\n+    /// Emit `msg` attached to `sp`, without immediately stopping\n+    /// compilation.\n+    ///\n+    /// Compilation will be stopped in the near future (at the end of\n+    /// the macro expansion phase).\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_err(sp, msg);\n@@ -402,53 +430,69 @@ impl<'a> ExtCtxt<'a> {\n     }\n }\n \n-pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr, err_msg: &str) -> (@str, ast::StrStyle) {\n+/// Extract a string literal from `expr`, emitting `err_msg` if `expr`\n+/// is not a string literal. This does not stop compilation on error,\n+/// merely emits a non-fatal error and returns None.\n+pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr,\n+                   err_msg: &str) -> Option<(@str, ast::StrStyle)> {\n     match expr.node {\n         ast::ExprLit(l) => match l.node {\n-            ast::LitStr(s, style) => (s, style),\n-            _ => cx.span_fatal(l.span, err_msg)\n+            ast::LitStr(s, style) => return Some((s, style)),\n+            _ => cx.span_err(l.span, err_msg)\n         },\n-        _ => cx.span_fatal(expr.span, err_msg)\n+        _ => cx.span_err(expr.span, err_msg)\n     }\n+    None\n }\n \n+/// Non-fatally assert that `tts` is empty. Note that this function\n+/// returns even when `tts` is non-empty, macros that *need* to stop\n+/// compilation should call\n+/// `cx.parse_sess.span_diagnostic.abort_if_errors()` (this should be\n+/// done as rarely as possible).\n pub fn check_zero_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n-        cx.span_fatal(sp, format!(\"{} takes no arguments\", name));\n+        cx.span_err(sp, format!(\"{} takes no arguments\", name));\n     }\n }\n \n+/// Extract the string literal from the first token of `tts`. If this\n+/// is not a string literal, emit an error and return None.\n pub fn get_single_str_from_tts(cx: &ExtCtxt,\n                                sp: Span,\n                                tts: &[ast::TokenTree],\n                                name: &str)\n-                               -> @str {\n+                               -> Option<@str> {\n     if tts.len() != 1 {\n-        cx.span_fatal(sp, format!(\"{} takes 1 argument.\", name));\n-    }\n-\n-    match tts[0] {\n-        ast::TTTok(_, token::LIT_STR(ident))\n-        | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => cx.str_of(ident),\n-        _ => cx.span_fatal(sp, format!(\"{} requires a string.\", name)),\n+        cx.span_err(sp, format!(\"{} takes 1 argument.\", name));\n+    } else {\n+        match tts[0] {\n+            ast::TTTok(_, token::LIT_STR(ident))\n+                | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => return Some(cx.str_of(ident)),\n+            _ => cx.span_err(sp, format!(\"{} requires a string.\", name)),\n+        }\n     }\n+    None\n }\n \n+/// Extract comma-separated expressions from `tts`. If there is a\n+/// parsing error, emit a non-fatal error and return None.\n pub fn get_exprs_from_tts(cx: &ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::TokenTree]) -> ~[@ast::Expr] {\n+                          tts: &[ast::TokenTree]) -> Option<~[@ast::Expr]> {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.to_owned());\n     let mut es = ~[];\n     while p.token != token::EOF {\n         if es.len() != 0 && !p.eat(&token::COMMA) {\n-            cx.span_fatal(sp, \"expected token: `,`\");\n+            cx.span_err(sp, \"expected token: `,`\");\n+            return None;\n         }\n         es.push(p.parse_expr());\n     }\n-    es\n+    Some(es)\n }\n \n // in order to have some notion of scoping for macros,"}, {"sha": "0c9a23be558c857b68d3f92724d165d6b7a1b247", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -20,7 +20,10 @@ use std::char;\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n     // Gather all argument expressions\n-    let exprs = get_exprs_from_tts(cx, sp, tts);\n+    let exprs = match get_exprs_from_tts(cx, sp, tts) {\n+        None => return MacResult::dummy_expr(),\n+        Some(e) => e,\n+    };\n     let mut bytes = ~[];\n \n     for expr in exprs.iter() {"}, {"sha": "2a68674af952ca4f6e59011d298115b80248bb8d", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -18,7 +18,10 @@ use ext::build::AstBuilder;\n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n                          tts: &[ast::TokenTree]) -> base::MacResult {\n-    let es = base::get_exprs_from_tts(cx, sp, tts);\n+    let es = match base::get_exprs_from_tts(cx, sp, tts) {\n+        Some(e) => e,\n+        None => return base::MacResult::dummy_expr()\n+    };\n     let mut accumulator = ~\"\";\n     for e in es.move_iter() {\n         let e = cx.expand_expr(e);"}, {"sha": "9dcb5b4cb4c2a49814f728bdb4f2fb27f4eb3219", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -23,12 +23,18 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         if i & 1 == 1 {\n             match *e {\n                 ast::TTTok(_, token::COMMA) => (),\n-                _ => cx.span_fatal(sp, \"concat_idents! expecting comma.\")\n+                _ => {\n+                    cx.span_err(sp, \"concat_idents! expecting comma.\");\n+                    return MacResult::dummy_expr();\n+                }\n             }\n         } else {\n             match *e {\n                 ast::TTTok(_, token::IDENT(ident,_)) => res_str.push_str(cx.str_of(ident)),\n-                _ => cx.span_fatal(sp, \"concat_idents! requires ident args.\")\n+                _ => {\n+                    cx.span_err(sp, \"concat_idents! requires ident args.\");\n+                    return MacResult::dummy_expr();\n+                }\n             }\n         }\n     }"}, {"sha": "088a221c965eb75f36c36edc1732c4b96d8413da", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -70,8 +70,9 @@ fn default_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Exp\n             }\n         }\n         StaticEnum(..) => {\n-            cx.span_fatal(span, \"`Default` cannot be derived for enums, \\\n-                                 only structs\")\n+            cx.span_err(span, \"`Default` cannot be derived for enums, only structs\");\n+            // let compilation continue\n+            cx.expr_uint(span, 0)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Default)`\")\n     };"}, {"sha": "29023dea6211fd80df02729479eb5cfe4b58c74b", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -73,7 +73,9 @@ fn rand_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         }\n         StaticEnum(_, ref variants) => {\n             if variants.is_empty() {\n-                cx.span_fatal(span, \"`Rand` cannot be derived for enums with no variants\");\n+                cx.span_err(span, \"`Rand` cannot be derived for enums with no variants\");\n+                // let compilation continue\n+                return cx.expr_uint(span, 0);\n             }\n \n             let variant_count = cx.expr_uint(span, variants.len());"}, {"sha": "31020b4a56224dc2784b4cdc2805431789a5c842", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -86,8 +86,9 @@ fn zero_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n             }\n         }\n         StaticEnum(..) => {\n-            cx.span_fatal(span, \"`Zero` cannot be derived for enums, \\\n-                                 only structs\")\n+            cx.span_err(span, \"`Zero` cannot be derived for enums, only structs\");\n+            // let compilation continue\n+            cx.expr_uint(span, 0)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Zero)`\")\n     };"}, {"sha": "a9b40ea7ec63844043e1f86bd9e0e8a70825f73b", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -24,7 +24,10 @@ use std::os;\n \n pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n-    let var = get_single_str_from_tts(cx, sp, tts, \"option_env!\");\n+    let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n+        None => return MacResult::dummy_expr(),\n+        Some(v) => v\n+    };\n \n     let e = match os::getenv(var) {\n       None => quote_expr!(cx, ::std::option::None::<&'static str>),\n@@ -35,24 +38,38 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n-    let exprs = get_exprs_from_tts(cx, sp, tts);\n-\n-    if exprs.len() == 0 {\n-        cx.span_fatal(sp, \"env! takes 1 or 2 arguments\");\n-    }\n+    let exprs = match get_exprs_from_tts(cx, sp, tts) {\n+        Some([]) => {\n+            cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n+            return MacResult::dummy_expr();\n+        }\n+        None => return MacResult::dummy_expr(),\n+        Some(exprs) => exprs\n+    };\n \n-    let (var, _var_str_style) = expr_to_str(cx, exprs[0], \"expected string literal\");\n+    let var = match expr_to_str(cx, exprs[0], \"expected string literal\") {\n+        None => return MacResult::dummy_expr(),\n+        Some((v, _style)) => v\n+    };\n     let msg = match exprs.len() {\n         1 => format!(\"environment variable `{}` not defined\", var).to_managed(),\n         2 => {\n-            let (s, _style) = expr_to_str(cx, exprs[1], \"expected string literal\");\n-            s\n+            match expr_to_str(cx, exprs[1], \"expected string literal\") {\n+                None => return MacResult::dummy_expr(),\n+                Some((s, _style)) => s\n+            }\n+        }\n+        _ => {\n+            cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n+            return MacResult::dummy_expr();\n         }\n-        _ => cx.span_fatal(sp, \"env! takes 1 or 2 arguments\")\n     };\n \n     let e = match os::getenv(var) {\n-        None => cx.span_fatal(sp, msg),\n+        None => {\n+            cx.span_err(sp, msg);\n+            cx.expr_uint(sp, 0)\n+        }\n         Some(s) => cx.expr_str(sp, s.to_managed())\n     };\n     MRExpr(e)"}, {"sha": "a17478178eb50e91a306066311631c9e797941a6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -46,19 +46,24 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                 // Token-tree macros:\n                 MacInvocTT(ref pth, ref tts, ctxt) => {\n                     if (pth.segments.len() > 1u) {\n-                        fld.cx.span_fatal(\n+                        fld.cx.span_err(\n                             pth.span,\n                             format!(\"expected macro name without module \\\n                                   separators\"));\n+                        // let compilation continue\n+                        return e;\n                     }\n                     let extname = &pth.segments[0].identifier;\n                     let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n                     let marked_after = match fld.extsbox.find(&extname.name) {\n                         None => {\n-                            fld.cx.span_fatal(\n+                            fld.cx.span_err(\n                                 pth.span,\n-                                format!(\"macro undefined: '{}'\", extnamestr))\n+                                format!(\"macro undefined: '{}'\", extnamestr));\n+\n+                            // let compilation continue\n+                            return e;\n                         }\n                         Some(&NormalTT(ref expandfun, exp_span)) => {\n                             fld.cx.bt_push(ExpnInfo {\n@@ -87,24 +92,26 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                                 MRExpr(e) => e,\n                                 MRAny(any_macro) => any_macro.make_expr(),\n                                 _ => {\n-                                    fld.cx.span_fatal(\n+                                    fld.cx.span_err(\n                                         pth.span,\n                                         format!(\n                                             \"non-expr macro in expr pos: {}\",\n                                             extnamestr\n                                         )\n-                                    )\n+                                    );\n+                                    return e;\n                                 }\n                             };\n \n                             // mark after:\n                             mark_expr(expanded,fm)\n                         }\n                         _ => {\n-                            fld.cx.span_fatal(\n+                            fld.cx.span_err(\n                                 pth.span,\n                                 format!(\"'{}' is not a tt-style macro\", extnamestr)\n-                            )\n+                            );\n+                            return e;\n                         }\n                     };\n \n@@ -299,15 +306,20 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n     let extnamestr = ident_to_str(extname);\n     let fm = fresh_mark();\n     let expanded = match fld.extsbox.find(&extname.name) {\n-        None => fld.cx.span_fatal(pth.span,\n-                                  format!(\"macro undefined: '{}!'\", extnamestr)),\n+        None => {\n+            fld.cx.span_err(pth.span,\n+                            format!(\"macro undefined: '{}!'\", extnamestr));\n+            // let compilation continue\n+            return SmallVector::zero();\n+        }\n \n         Some(&NormalTT(ref expander, span)) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n-                fld.cx.span_fatal(pth.span,\n-                                  format!(\"macro {}! expects no ident argument, \\\n-                                           given '{}'\", extnamestr,\n-                                           ident_to_str(&it.ident)));\n+                fld.cx.span_err(pth.span,\n+                                format!(\"macro {}! expects no ident argument, \\\n+                                        given '{}'\", extnamestr,\n+                                        ident_to_str(&it.ident)));\n+                return SmallVector::zero();\n             }\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n@@ -324,9 +336,9 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n         }\n         Some(&IdentTT(ref expander, span)) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n-                fld.cx.span_fatal(pth.span,\n-                                  format!(\"macro {}! expects an ident argument\",\n-                                          extnamestr));\n+                fld.cx.span_err(pth.span,\n+                                format!(\"macro {}! expects an ident argument\", extnamestr));\n+                return SmallVector::zero();\n             }\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n@@ -341,9 +353,10 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n             let marked_ctxt = new_mark(fm,ctxt);\n             expander.expand(fld.cx, it.span, it.ident, marked_tts, marked_ctxt)\n         }\n-        _ => fld.cx.span_fatal(it.span,\n-                               format!(\"{}! is not legal in item position\",\n-                                       extnamestr))\n+        _ => {\n+            fld.cx.span_err(it.span, format!(\"{}! is not legal in item position\", extnamestr));\n+            return SmallVector::zero();\n+        }\n     };\n \n     let items = match expanded {\n@@ -353,8 +366,8 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n                 .collect()\n         }\n         MRExpr(_) => {\n-            fld.cx.span_fatal(pth.span, format!(\"expr macro in item position: {}\",\n-                                                extnamestr))\n+            fld.cx.span_err(pth.span, format!(\"expr macro in item position: {}\", extnamestr));\n+            return SmallVector::zero();\n         }\n         MRAny(any_macro) => {\n             any_macro.make_items().move_iter()\n@@ -418,12 +431,16 @@ fn load_extern_macros(crate: &ast::ViewItem, fld: &mut MacroExpander) {\n \n     let lib = match DynamicLibrary::open(Some(&path)) {\n         Ok(lib) => lib,\n+        // this is fatal: there are almost certainly macros we need\n+        // inside this crate, so continue would spew \"macro undefined\"\n+        // errors\n         Err(err) => fld.cx.span_fatal(crate.span, err)\n     };\n \n     unsafe {\n         let registrar: MacroCrateRegistrationFun = match lib.symbol(registrar) {\n             Ok(registrar) => registrar,\n+            // again fatal if we can't register macros\n             Err(err) => fld.cx.span_fatal(crate.span, err)\n         };\n         registrar(|name, extension| {\n@@ -454,14 +471,15 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n         _ => return expand_non_macro_stmt(s, fld)\n     };\n     if (pth.segments.len() > 1u) {\n-        fld.cx.span_fatal(pth.span,\n-                          \"expected macro name without module separators\");\n+        fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n+        return SmallVector::zero();\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n     let marked_after = match fld.extsbox.find(&extname.name) {\n         None => {\n-            fld.cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n+            fld.cx.span_err(pth.span, format!(\"macro undefined: '{}'\", extnamestr));\n+            return SmallVector::zero();\n         }\n \n         Some(&NormalTT(ref expandfun, exp_span)) => {\n@@ -493,26 +511,27 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n                     }\n                 }\n                 MRAny(any_macro) => any_macro.make_stmt(),\n-                _ => fld.cx.span_fatal(\n-                    pth.span,\n-                    format!(\"non-stmt macro in stmt pos: {}\", extnamestr))\n+                _ => {\n+                    fld.cx.span_err(pth.span,\n+                                    format!(\"non-stmt macro in stmt pos: {}\", extnamestr));\n+                    return SmallVector::zero();\n+                }\n             };\n \n             mark_stmt(expanded,fm)\n         }\n \n         _ => {\n-            fld.cx.span_fatal(pth.span,\n-                              format!(\"'{}' is not a tt-style macro\",\n-                                      extnamestr))\n+            fld.cx.span_err(pth.span, format!(\"'{}' is not a tt-style macro\", extnamestr));\n+            return SmallVector::zero();\n         }\n     };\n \n     // Keep going, outside-in.\n     let fully_expanded = fld.fold_stmt(marked_after);\n     if fully_expanded.is_empty() {\n-        fld.cx.span_fatal(pth.span,\n-                      \"macro didn't expand to a statement\");\n+        fld.cx.span_err(pth.span, \"macro didn't expand to a statement\");\n+        return SmallVector::zero();\n     }\n     fld.cx.bt_pop();\n     let fully_expanded: SmallVector<@Stmt> = fully_expanded.move_iter()"}, {"sha": "ff6db43a29211e016603fc4859c9a64c21bdffa2", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -748,8 +748,11 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n     // Be sure to recursively expand macros just in case the format string uses\n     // a macro to build the format expression.\n     let expr = cx.ecx.expand_expr(efmt);\n-    let (fmt, _) = expr_to_str(cx.ecx, expr,\n-                               \"format argument must be a string literal.\");\n+    let fmt = match expr_to_str(cx.ecx, expr,\n+                                     \"format argument must be a string literal.\") {\n+        Some((fmt, _)) => fmt,\n+        None => return MacResult::dummy_expr()\n+    };\n \n     let mut err = false;\n     parse::parse_error::cond.trap(|m| {"}, {"sha": "711f8ff11ee63548838b01ae0bf2ab704235106f", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -79,7 +79,10 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n // unhygienically.\n pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n-    let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n+    let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n+        Some(f) => f,\n+        None => return MacResult::dummy_expr(),\n+    };\n     // The file will be added to the code map by the parser\n     let mut p =\n         parse::new_sub_parser_from_file(cx.parse_sess(),\n@@ -94,12 +97,15 @@ pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n-    let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n+    let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n+        Some(f) => f,\n+        None => return MacResult::dummy_expr()\n+    };\n     let file = res_rel_file(cx, sp, &Path::new(file));\n     let bytes = match io::result(|| File::open(&file).read_to_end()) {\n         Err(e) => {\n-            cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n-                                      file.display(), e.desc));\n+            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e.desc));\n+            return MacResult::dummy_expr();\n         }\n         Ok(bytes) => bytes,\n     };\n@@ -114,7 +120,8 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             base::MRExpr(cx.expr_str(sp, src))\n         }\n         None => {\n-            cx.span_fatal(sp, format!(\"{} wasn't a utf-8 file\", file.display()));\n+            cx.span_err(sp, format!(\"{} wasn't a utf-8 file\", file.display()));\n+            return MacResult::dummy_expr();\n         }\n     }\n }\n@@ -124,12 +131,15 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n {\n     use std::at_vec;\n \n-    let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n+    let file = match get_single_str_from_tts(cx, sp, tts, \"include_bin!\") {\n+        Some(f) => f,\n+        None => return MacResult::dummy_expr()\n+    };\n     let file = res_rel_file(cx, sp, &Path::new(file));\n     match io::result(|| File::open(&file).read_to_end()) {\n         Err(e) => {\n-            cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n-                                      file.display(), e.desc));\n+            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e.desc));\n+            return MacResult::dummy_expr();\n         }\n         Ok(bytes) => {\n             let bytes = at_vec::to_managed_move(bytes);"}, {"sha": "83c6c6a1762351142c7a3d5a812c93f50d688908", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -33,7 +33,8 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n     } else if rust_parser.is_keyword(keywords::False) {\n         cx.set_trace_macros(false);\n     } else {\n-        cx.span_fatal(sp, \"trace_macros! only accepts `true` or `false`\")\n+        cx.span_err(sp, \"trace_macros! only accepts `true` or `false`\");\n+        return base::MacResult::dummy_expr();\n     }\n \n     rust_parser.bump();"}, {"sha": "1080291179b550e6bbab1596c0878f95dd6e9541", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -183,8 +183,8 @@ pub fn nameize(p_s: @ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n                 node: MatchNonterminal(ref bind_name, _, idx), span: sp\n           } => {\n             if ret_val.contains_key(bind_name) {\n-                p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n-                                               ident_to_str(bind_name))\n+                p_s.span_diagnostic.span_fatal(sp,\n+                                               \"Duplicated bind name: \"+ ident_to_str(bind_name))\n             }\n             ret_val.insert(*bind_name, res[idx]);\n           }"}, {"sha": "475faa75704623de19d9851d82b9f4a3f00bcf7a", "filename": "src/test/compile-fail/macros-nonfatal-errors.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be3262058a151699cb66f95cbdcf39cf0263a83/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs?ref=4be3262058a151699cb66f95cbdcf39cf0263a83", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// test that errors in a (selection) of macros don't kill compilation\n+// immediately, so that we get more errors listed at a time.\n+\n+#[feature(asm)];\n+\n+#[deriving(Default, //~ ERROR\n+           Rand, //~ ERROR\n+           Zero)] //~ ERROR\n+enum CantDeriveThose {}\n+\n+fn main() {\n+    doesnt_exist!(); //~ ERROR\n+\n+    bytes!(invalid); //~ ERROR\n+\n+    asm!(invalid); //~ ERROR\n+\n+    concat_idents!(\"not\", \"idents\"); //~ ERROR\n+\n+    option_env!(invalid); //~ ERROR\n+    env!(invalid); //~ ERROR\n+    env!(foo, abr, baz); //~ ERROR\n+    env!(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\"); //~ ERROR\n+\n+    foo::blah!(); //~ ERROR\n+\n+    format!(); //~ ERROR\n+    format!(invalid); //~ ERROR\n+\n+    include!(invalid); //~ ERROR\n+\n+    include_str!(invalid); //~ ERROR\n+    include_str!(\"i'd be quite surprised if a file with this name existed\"); //~ ERROR\n+    include_bin!(invalid); //~ ERROR\n+    include_bin!(\"i'd be quite surprised if a file with this name existed\"); //~ ERROR\n+\n+    trace_macros!(invalid); //~ ERROR\n+}"}]}