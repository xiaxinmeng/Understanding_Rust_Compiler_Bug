{"sha": "cb51f872a841f658449f2dd3adebf0b243aa96e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNTFmODcyYTg0MWY2NTg0NDlmMmRkM2FkZWJmMGIyNDNhYTk2ZTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-06T21:58:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-06T21:58:59Z"}, "message": "miri engine: lazily allocate memory for locals on first write", "tree": {"sha": "a2427262f11db93beed79666fb078cd347ceae4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2427262f11db93beed79666fb078cd347ceae4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb51f872a841f658449f2dd3adebf0b243aa96e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb51f872a841f658449f2dd3adebf0b243aa96e3", "html_url": "https://github.com/rust-lang/rust/commit/cb51f872a841f658449f2dd3adebf0b243aa96e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb51f872a841f658449f2dd3adebf0b243aa96e3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "209b0b41ac39bdeaaa0dd5d52efec4b1f8d0011f", "url": "https://api.github.com/repos/rust-lang/rust/commits/209b0b41ac39bdeaaa0dd5d52efec4b1f8d0011f", "html_url": "https://github.com/rust-lang/rust/commit/209b0b41ac39bdeaaa0dd5d52efec4b1f8d0011f"}], "stats": {"total": 119, "additions": 79, "deletions": 40}, "files": [{"sha": "c3726c63ea4a90380f307a74e7b77d8d631a3517", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cb51f872a841f658449f2dd3adebf0b243aa96e3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb51f872a841f658449f2dd3adebf0b243aa96e3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=cb51f872a841f658449f2dd3adebf0b243aa96e3", "patch": "@@ -116,26 +116,41 @@ pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n /// State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum LocalValue<Tag=(), Id=AllocId> {\n+    /// This local is not currently alive, and cannot be used at all.\n     Dead,\n-    // Mostly for convenience, we re-use the `Operand` type here.\n-    // This is an optimization over just always having a pointer here;\n-    // we can thus avoid doing an allocation when the local just stores\n-    // immediate values *and* never has its address taken.\n+    /// This local is alive but not yet initialized. It can be written to\n+    /// but not read from or its address taken. Locals get initialized on\n+    /// first write because for unsized locals, we do not know their size\n+    /// before that.\n+    Uninitialized,\n+    /// A normal, live local.\n+    /// Mostly for convenience, we re-use the `Operand` type here.\n+    /// This is an optimization over just always having a pointer here;\n+    /// we can thus avoid doing an allocation when the local just stores\n+    /// immediate values *and* never has its address taken.\n     Live(Operand<Tag, Id>),\n }\n \n-impl<'tcx, Tag> LocalState<'tcx, Tag> {\n+impl<'tcx, Tag: Copy> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> EvalResult<'tcx, &Operand<Tag>> {\n         match self.state {\n-            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Dead | LocalValue::Uninitialized => err!(DeadLocal),\n             LocalValue::Live(ref val) => Ok(val),\n         }\n     }\n \n-    pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand<Tag>> {\n+    /// Overwrite the local.  If the local can be overwritten in place, return a reference\n+    /// to do so; otherwise return the `MemPlace` to consult instead.\n+    pub fn access_mut(\n+        &mut self,\n+    ) -> EvalResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.state {\n             LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(ref mut val) => Ok(val),\n+            LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n+            ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n+            ref mut local @ LocalValue::Uninitialized => {\n+                Ok(Ok(local))\n+            }\n         }\n     }\n }\n@@ -327,6 +342,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                     let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n                     self.layout_of(local_ty)\n                 })?;\n+                // Layouts of locals are requested a lot, so we cache them.\n                 frame.locals[local].layout.set(Some(layout));\n                 Ok(layout)\n             }\n@@ -473,13 +489,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n \n         // don't allocate at all for trivial constants\n         if mir.local_decls.len() > 1 {\n-            // We put some marker immediate into the locals that we later want to initialize.\n-            // This can be anything except for LocalValue::Dead -- because *that* is the\n-            // value we use for things that we know are initially dead.\n+            // Locals are initially uninitialized.\n             let dummy = LocalState {\n-                state: LocalValue::Live(Operand::Immediate(Immediate::Scalar(\n-                    ScalarMaybeUndef::Undef,\n-                ))),\n+                state: LocalValue::Uninitialized,\n                 layout: Cell::new(None),\n             };\n             let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n@@ -506,19 +518,25 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                     }\n                 },\n             }\n-            // Finally, properly initialize all those that still have the dummy value\n+            // FIXME: We initialize live ZST here.  This should not be needed if MIR was\n+            // consistently generated for ZST, but that seems to not be the case -- there\n+            // is MIR (around promoteds in particular) that reads local ZSTs that never\n+            // were written to.\n             for (idx, local) in locals.iter_enumerated_mut() {\n                 match local.state {\n-                    LocalValue::Live(_) => {\n+                    LocalValue::Uninitialized => {\n                         // This needs to be properly initialized.\n                         let ty = self.monomorphize(mir.local_decls[idx].ty)?;\n                         let layout = self.layout_of(ty)?;\n-                        local.state = LocalValue::Live(self.uninit_operand(layout)?);\n+                        if layout.is_zst() {\n+                            local.state = LocalValue::Live(self.uninit_operand(layout)?);\n+                        }\n                         local.layout = Cell::new(Some(layout));\n                     }\n                     LocalValue::Dead => {\n                         // Nothing to do\n                     }\n+                    LocalValue::Live(_) => bug!(\"Locals cannot be live yet\"),\n                 }\n             }\n             // done"}, {"sha": "f69ce4e0d3d177a77dcfeb53932ba659992be927", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cb51f872a841f658449f2dd3adebf0b243aa96e3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb51f872a841f658449f2dd3adebf0b243aa96e3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=cb51f872a841f658449f2dd3adebf0b243aa96e3", "patch": "@@ -15,7 +15,7 @@ use rustc::ty::TypeFoldable;\n use super::{\n     GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n     InterpretCx, Machine, AllocMap, AllocationExtra,\n-    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n+    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -639,6 +639,7 @@ where\n                 None => return err!(InvalidNullPointerUsage),\n             },\n             Base(PlaceBase::Local(local)) => PlaceTy {\n+                // This works even for dead/uninitialized locals; we check further when writing\n                 place: Place::Local {\n                     frame: self.cur_frame(),\n                     local,\n@@ -714,16 +715,19 @@ where\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n-                match *self.stack[frame].locals[local].access_mut()? {\n-                    Operand::Immediate(ref mut dest_val) => {\n-                        // Yay, we can just change the local directly.\n-                        *dest_val = src;\n+                match self.stack[frame].locals[local].access_mut()? {\n+                    Ok(local) => {\n+                        // Local can be updated in-place.\n+                        *local = LocalValue::Live(Operand::Immediate(src));\n                         return Ok(());\n-                    },\n-                    Operand::Indirect(mplace) => mplace, // already in memory\n+                    }\n+                    Err(mplace) => {\n+                        // The local is in memory, go on below.\n+                        mplace\n+                    }\n                 }\n             },\n-            Place::Ptr(mplace) => mplace, // already in memory\n+            Place::Ptr(mplace) => mplace, // already referring to memory\n         };\n         let dest = MPlaceTy { mplace, layout: dest.layout };\n \n@@ -904,27 +908,40 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let mplace = match place.place {\n             Place::Local { frame, local } => {\n-                match *self.stack[frame].locals[local].access()? {\n-                    Operand::Indirect(mplace) => mplace,\n-                    Operand::Immediate(value) => {\n+                match self.stack[frame].locals[local].access_mut()? {\n+                    Ok(local_val) => {\n                         // We need to make an allocation.\n                         // FIXME: Consider not doing anything for a ZST, and just returning\n                         // a fake pointer?  Are we even called for ZST?\n \n+                        // We cannot hold on to the reference `local_val` while allocating,\n+                        // but we can hold on to the value in there.\n+                        let old_val =\n+                            if let LocalValue::Live(Operand::Immediate(value)) = *local_val {\n+                                Some(value)\n+                            } else {\n+                                None\n+                            };\n+\n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n                         let local_layout = self.layout_of_local(&self.stack[frame], local, None)?;\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack);\n-                        // We don't have to validate as we can assume the local\n-                        // was already valid for its type.\n-                        self.write_immediate_to_mplace_no_validate(value, ptr)?;\n+                        if let Some(value) = old_val {\n+                            // Preserve old value.\n+                            // We don't have to validate as we can assume the local\n+                            // was already valid for its type.\n+                            self.write_immediate_to_mplace_no_validate(value, ptr)?;\n+                        }\n                         let mplace = ptr.mplace;\n-                        // Update the local\n-                        *self.stack[frame].locals[local].access_mut()? =\n-                            Operand::Indirect(mplace);\n+                        // Now we can call `access_mut` again, asserting it goes well,\n+                        // and actually overwrite things.\n+                        *self.stack[frame].locals[local].access_mut().unwrap().unwrap() =\n+                            LocalValue::Live(Operand::Indirect(mplace));\n                         mplace\n                     }\n+                    Err(mplace) => mplace, // this already was an indirect local\n                 }\n             }\n             Place::Ptr(mplace) => mplace"}, {"sha": "f440e2966063c3286a90367d79772ffa560a98fa", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb51f872a841f658449f2dd3adebf0b243aa96e3/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb51f872a841f658449f2dd3adebf0b243aa96e3/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=cb51f872a841f658449f2dd3adebf0b243aa96e3", "patch": "@@ -114,10 +114,11 @@ macro_rules! impl_snapshot_for {\n             fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n                 match *self {\n                     $(\n-                        $enum_name::$variant $( ( $(ref $field),* ) )? =>\n+                        $enum_name::$variant $( ( $(ref $field),* ) )? => {\n                             $enum_name::$variant $(\n-                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),* ),\n+                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),* )\n                             )?\n+                        }\n                     )*\n                 }\n             }\n@@ -250,11 +251,13 @@ impl_snapshot_for!(enum Operand {\n \n impl_stable_hash_for!(enum crate::interpret::LocalValue {\n     Dead,\n+    Uninitialized,\n     Live(x),\n });\n impl_snapshot_for!(enum LocalValue {\n-    Live(v),\n     Dead,\n+    Uninitialized,\n+    Live(v),\n });\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations"}, {"sha": "3bf0ff905ab7a1d59d8b62a31d612f9605498fe9", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb51f872a841f658449f2dd3adebf0b243aa96e3/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb51f872a841f658449f2dd3adebf0b243aa96e3/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=cb51f872a841f658449f2dd3adebf0b243aa96e3", "patch": "@@ -315,12 +315,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     );\n \n                     // Figure out how to pass which arguments.\n-                    // We have two iterators: Where the arguments come from,\n-                    // and where they go to.\n+                    // The Rust ABI is special: ZST get skipped.\n                     let rust_abi = match caller_abi {\n                         Abi::Rust | Abi::RustCall => true,\n                         _ => false\n                     };\n+                    // We have two iterators: Where the arguments come from,\n+                    // and where they go to.\n \n                     // For where they come from: If the ABI is RustCall, we untuple the\n                     // last incoming argument.  These two iterators do not have the same type,\n@@ -368,7 +369,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     }\n                     // Now we should have no more caller args\n                     if caller_iter.next().is_some() {\n-                        trace!(\"Caller has too many args over\");\n+                        trace!(\"Caller has passed too many args\");\n                         return err!(FunctionArgCountMismatch);\n                     }\n                     // Don't forget to check the return type!"}]}