{"sha": "58988c356539b356201b19886edc61a5231656f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4OTg4YzM1NjUzOWIzNTYyMDFiMTk4ODZlZGM2MWE1MjMxNjU2ZjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T00:18:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T00:25:56Z"}, "message": "changes to get std passing borrowck", "tree": {"sha": "74e0a4f4e1b6a378abade1cacd9cba4872026391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74e0a4f4e1b6a378abade1cacd9cba4872026391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58988c356539b356201b19886edc61a5231656f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58988c356539b356201b19886edc61a5231656f3", "html_url": "https://github.com/rust-lang/rust/commit/58988c356539b356201b19886edc61a5231656f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58988c356539b356201b19886edc61a5231656f3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c2bf8e4a73710db9430483028d268843f562d28", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2bf8e4a73710db9430483028d268843f562d28", "html_url": "https://github.com/rust-lang/rust/commit/4c2bf8e4a73710db9430483028d268843f562d28"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "6697c58252eb9f52cbea7d5bb269701dfcc0e33a", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58988c356539b356201b19886edc61a5231656f3/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58988c356539b356201b19886edc61a5231656f3/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=58988c356539b356201b19886edc61a5231656f3", "patch": "@@ -406,8 +406,8 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n         let {tag: r_tag, doc: r_doc} =\n             ebml::doc_at(self.parent.data, self.pos);\n         #debug[\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n-               self.parent.start, self.parent.end, self.pos,\n-               r_tag, r_doc.start, r_doc.end];\n+               copy self.parent.start, copy self.parent.end,\n+               copy self.pos, r_tag, r_doc.start, r_doc.end];\n         if r_tag != (exp_tag as uint) {\n             fail #fmt[\"expected EMBL doc with tag %? but found tag %?\",\n                       exp_tag, r_tag];"}, {"sha": "4967eaf9f850e7436db3c9b02cd92b0dfd55eff0", "filename": "src/libstd/map.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58988c356539b356201b19886edc61a5231656f3/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58988c356539b356201b19886edc61a5231656f3/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=58988c356539b356201b19886edc61a5231656f3", "patch": "@@ -102,16 +102,15 @@ mod chained {\n             let mut e0 = e_root;\n             let mut comp = 1u;   // for logging\n             loop {\n-                alt e0.next {\n+                alt copy e0.next {\n                   absent {\n                     #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                            comp, h, idx);\n                     ret not_found;\n                   }\n                   present(e1) {\n                     comp += 1u;\n-                    let e1_key = e1.key; // Satisfy alias checker.\n-                    if e1.hash == h && self.eqer(e1_key, k) {\n+                    if e1.hash == h && self.eqer(e1.key, k) {\n                         #debug(\"search_tbl: present, comp %u, \\\n                                 hash %u, idx %u\",\n                                comp, h, idx);\n@@ -126,15 +125,14 @@ mod chained {\n \n         fn search_tbl(k: K, h: uint) -> search_result<K,V> {\n             let idx = h % vec::len(self.chains);\n-            alt self.chains[idx] {\n+            alt copy self.chains[idx] {\n               absent {\n                 #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                        0u, h, idx);\n                 ret not_found;\n               }\n               present(e) {\n-                // FIXME: This copy of the key is not good for perf\n-                if e.hash == h && self.eqer(copy e.key, k) {\n+                if e.hash == h && self.eqer(e.key, k) {\n                     #debug(\"search_tbl: present, comp %u, hash %u, idx %u\",\n                            1u, h, idx);\n                     ret found_first(idx, e);"}, {"sha": "b1ca3d5c50d8ee866fb24ac335f99bbec8c22d64", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/58988c356539b356201b19886edc61a5231656f3/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58988c356539b356201b19886edc61a5231656f3/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=58988c356539b356201b19886edc61a5231656f3", "patch": "@@ -9,67 +9,74 @@ red-black tree or something else.\n import core::option::{some, none};\n import option = core::option;\n \n-export treemap;\n export treemap;\n export insert;\n export find;\n export traverse;\n \n-type treemap<K, V> = @mut tree_node<K, V>;\n+type treemap<K, V> = @mut tree_edge<K, V>;\n+\n+type tree_edge<K, V> = option<@tree_node<K, V>>;\n \n-enum tree_node<K, V> { empty, node(@K, @V, treemap<K, V>, treemap<K, V>) }\n+enum tree_node<K, V> = {\n+    key: K,\n+    mut value: V,\n+    mut left: tree_edge<K, V>,\n+    mut right: tree_edge<K, V>\n+};\n \n #[doc = \"Create a treemap\"]\n-fn treemap<K, V>() -> treemap<K, V> { @mut empty }\n+fn treemap<K, V>() -> treemap<K, V> { @mut none }\n \n #[doc = \"Insert a value into the map\"]\n-fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) {\n-    alt m {\n-      @empty { *m = node(@k, @v, @mut empty, @mut empty); }\n-      @node(@kk, _, _, _) {\n-\n-        // We have to name left and right individually, because\n-        // otherwise the alias checker complains.\n-        if k < kk {\n-            alt check m { @node(_, _, left, _) { insert(left, k, v); } }\n+fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n+    alt copy *m {\n+      none {\n+        *m = some(@tree_node({key: k,\n+                              mut value: v,\n+                              mut left: none,\n+                              mut right: none}));\n+        ret;\n+      }\n+      some(node) {\n+        if k == node.key {\n+            node.value = v;\n+        } else if k < node.key {\n+            insert(&mut node.left, k, v);\n         } else {\n-            alt check m {\n-              @node(_, _, _, right) { insert(right, k, v); }\n-            }\n+            insert(&mut node.right, k, v);\n         }\n       }\n-    }\n+    };\n }\n \n #[doc = \"Find a value based on the key\"]\n-fn find<K: copy, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n-    alt *m {\n-      empty { none }\n+fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n+    alt copy *m {\n+      none { none }\n+\n       // TODO: was that an optimization?\n-      node(@kk, @v, left, right) {\n-        if k == kk {\n-            some(v)\n-        } else if k < kk {\n-            find(left, k)\n-        } else { find(right, k) }\n+      some(node) {\n+        if k == node.key {\n+            some(node.value)\n+        } else if k < node.key {\n+            find(&const node.left, k)\n+        } else {\n+            find(&const node.right, k)\n+        }\n       }\n     }\n }\n \n #[doc = \"Visit all pairs in the map in order.\"]\n-fn traverse<K, V>(m: treemap<K, V>, f: fn(K, V)) {\n-    alt *m {\n-      empty { }\n-      /*\n-        Previously, this had what looked like redundant\n-        matches to me, so I changed it. but that may be a\n-        de-optimization -- tjc\n-       */\n-      node(k, v, left, right) {\n-        let k1 = k, v1 = v;\n-        traverse(left, f);\n-        f(*k1, *v1);\n-        traverse(right, f);\n+fn traverse<K, V: copy>(m: &const tree_edge<K, V>, f: fn(K, V)) {\n+    alt copy *m {\n+      none { }\n+      some(node) {\n+        traverse(&const node.left, f);\n+        // copy of value is req'd as f() requires an immutable ptr\n+        f(node.key, copy node.value);\n+        traverse(&const node.right, f);\n       }\n     }\n }\n@@ -134,4 +141,4 @@ mod tests {\n         assert (find(m, k2) == some(\"bar\"));\n         assert (find(m, k1) == some(\"foo\"));\n     }\n-}\n\\ No newline at end of file\n+}"}]}