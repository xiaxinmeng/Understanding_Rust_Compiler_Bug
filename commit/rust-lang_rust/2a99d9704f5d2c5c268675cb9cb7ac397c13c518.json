{"sha": "2a99d9704f5d2c5c268675cb9cb7ac397c13c518", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhOTlkOTcwNGY1ZDJjNWMyNjg2NzVjYjljYjdhYzM5N2MxM2M1MTg=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-07T06:48:47Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-09T05:07:43Z"}, "message": "Use overflow::rewrite_with_angle_brackets to rewrite generics", "tree": {"sha": "3538f7e1f6d9ff292ec2ceb746fd6008e3e25e8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3538f7e1f6d9ff292ec2ceb746fd6008e3e25e8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a99d9704f5d2c5c268675cb9cb7ac397c13c518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a99d9704f5d2c5c268675cb9cb7ac397c13c518", "html_url": "https://github.com/rust-lang/rust/commit/2a99d9704f5d2c5c268675cb9cb7ac397c13c518", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a99d9704f5d2c5c268675cb9cb7ac397c13c518/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae629abc41fd1d0f28a1733b6deb17f9b9026579", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae629abc41fd1d0f28a1733b6deb17f9b9026579", "html_url": "https://github.com/rust-lang/rust/commit/ae629abc41fd1d0f28a1733b6deb17f9b9026579"}], "stats": {"total": 259, "additions": 80, "deletions": 179}, "files": [{"sha": "647b81830d42fa1882c5eb6bd85580baf273591f", "filename": "src/expr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a99d9704f5d2c5c268675cb9cb7ac397c13c518/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a99d9704f5d2c5c268675cb9cb7ac397c13c518/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=2a99d9704f5d2c5c268675cb9cb7ac397c13c518", "patch": "@@ -2643,3 +2643,13 @@ impl<'a> ToExpr for MacroArg {\n         }\n     }\n }\n+\n+impl ToExpr for ast::GenericParam {\n+    fn to_expr(&self) -> Option<&ast::Expr> {\n+        None\n+    }\n+\n+    fn can_be_overflowed(&self, _: &RewriteContext, _: usize) -> bool {\n+        false\n+    }\n+}"}, {"sha": "23f96358d8e036ba7ee45c4710a7ac9aa967740c", "filename": "src/items.rs", "status": "modified", "additions": 37, "deletions": 151, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/2a99d9704f5d2c5c268675cb9cb7ac397c13c518/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a99d9704f5d2c5c268675cb9cb7ac397c13c518/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=2a99d9704f5d2c5c268675cb9cb7ac397c13c518", "patch": "@@ -718,7 +718,6 @@ fn format_impl_ref_and_type(\n         result.push_str(&format_visibility(&item.vis));\n         result.push_str(format_defaultness(defaultness));\n         result.push_str(format_unsafety(unsafety));\n-        result.push_str(\"impl\");\n \n         let lo = context.snippet_provider.span_after(item.span, \"impl\");\n         let hi = match *trait_ref {\n@@ -730,9 +729,8 @@ fn format_impl_ref_and_type(\n             Shape::indented(offset + last_line_width(&result), context.config),\n             0,\n         )?;\n-        let one_line_budget = shape.width.checked_sub(last_line_width(&result) + 2)?;\n-        let generics_str =\n-            rewrite_generics_inner(context, generics, shape, one_line_budget, mk_sp(lo, hi))?;\n+        let generics_str = rewrite_generics(context, \"impl\", generics, shape, mk_sp(lo, hi))?;\n+        result.push_str(&generics_str);\n \n         let polarity_str = if polarity == ast::ImplPolarity::Negative {\n             \"!\"\n@@ -741,32 +739,14 @@ fn format_impl_ref_and_type(\n         };\n \n         if let Some(ref trait_ref) = *trait_ref {\n-            let result_len = result.len();\n-            if let Some(trait_ref_str) = rewrite_trait_ref(\n+            let result_len = last_line_width(&result);\n+            result.push_str(&rewrite_trait_ref(\n                 context,\n                 trait_ref,\n                 offset,\n-                &generics_str,\n-                true,\n                 polarity_str,\n                 result_len,\n-            ) {\n-                result.push_str(&trait_ref_str);\n-            } else {\n-                let generics_str =\n-                    rewrite_generics_inner(context, generics, shape, 0, mk_sp(lo, hi))?;\n-                result.push_str(&rewrite_trait_ref(\n-                    context,\n-                    trait_ref,\n-                    offset,\n-                    &generics_str,\n-                    false,\n-                    polarity_str,\n-                    result_len,\n-                )?);\n-            }\n-        } else {\n-            result.push_str(&generics_str);\n+            )?);\n         }\n \n         // Try to put the self type in a single line.\n@@ -821,37 +801,27 @@ fn rewrite_trait_ref(\n     context: &RewriteContext,\n     trait_ref: &ast::TraitRef,\n     offset: Indent,\n-    generics_str: &str,\n-    retry: bool,\n     polarity_str: &str,\n     result_len: usize,\n ) -> Option<String> {\n     // 1 = space between generics and trait_ref\n-    let used_space = 1 + polarity_str.len() + last_line_used_width(generics_str, result_len);\n+    let used_space = 1 + polarity_str.len() + result_len;\n     let shape = Shape::indented(offset + used_space, context.config);\n     if let Some(trait_ref_str) = trait_ref.rewrite(context, shape) {\n-        if !(retry && trait_ref_str.contains('\\n')) {\n-            return Some(format!(\n-                \"{} {}{}\",\n-                generics_str, polarity_str, &trait_ref_str\n-            ));\n+        if !trait_ref_str.contains('\\n') {\n+            return Some(format!(\" {}{}\", polarity_str, &trait_ref_str));\n         }\n     }\n     // We could not make enough space for trait_ref, so put it on new line.\n-    if !retry {\n-        let offset = offset.block_indent(context.config);\n-        let shape = Shape::indented(offset, context.config);\n-        let trait_ref_str = trait_ref.rewrite(context, shape)?;\n-        Some(format!(\n-            \"{}\\n{}{}{}\",\n-            generics_str,\n-            &offset.to_string(context.config),\n-            polarity_str,\n-            &trait_ref_str\n-        ))\n-    } else {\n-        None\n-    }\n+    let offset = offset.block_indent(context.config);\n+    let shape = Shape::indented(offset, context.config);\n+    let trait_ref_str = trait_ref.rewrite(context, shape)?;\n+    Some(format!(\n+        \"{}{}{}\",\n+        &offset.to_string_with_newline(context.config),\n+        polarity_str,\n+        &trait_ref_str\n+    ))\n }\n \n pub struct StructParts<'a> {\n@@ -919,19 +889,23 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n     {\n         let mut result = String::with_capacity(128);\n         let header = format!(\n-            \"{}{}trait {}\",\n+            \"{}{}trait \",\n             format_visibility(&item.vis),\n             format_unsafety(unsafety),\n-            item.ident\n         );\n \n         result.push_str(&header);\n \n         let body_lo = context.snippet_provider.span_after(item.span, \"{\");\n \n         let shape = Shape::indented(offset, context.config).offset_left(result.len())?;\n-        let generics_str =\n-            rewrite_generics(context, generics, shape, mk_sp(item.span.lo(), body_lo))?;\n+        let generics_str = rewrite_generics(\n+            context,\n+            &item.ident.to_string(),\n+            generics,\n+            shape,\n+            mk_sp(item.span.lo(), body_lo),\n+        )?;\n         result.push_str(&generics_str);\n \n         // FIXME(#2055): rustfmt fails to format when there are comments between trait bounds.\n@@ -1080,9 +1054,9 @@ pub fn format_trait_alias(\n ) -> Option<String> {\n     let alias = ident.name.as_str();\n     // 6 = \"trait \", 2 = \" =\"\n-    let g_shape = shape.offset_left(6 + alias.len())?.sub_width(2)?;\n-    let generics_str = rewrite_generics(context, generics, g_shape, generics.span)?;\n-    let lhs = format!(\"trait {}{} =\", alias, generics_str);\n+    let g_shape = shape.offset_left(6)?.sub_width(2)?;\n+    let generics_str = rewrite_generics(context, &alias, generics, g_shape, generics.span)?;\n+    let lhs = format!(\"trait {} =\", generics_str);\n     // 1 = \";\"\n     rewrite_assign_rhs(context, lhs, ty_param_bounds, shape.sub_width(1)?).map(|s| s + \";\")\n }\n@@ -1259,7 +1233,7 @@ fn format_tuple_struct(\n             let budget = context.budget(last_line_width(&header_str));\n             let shape = Shape::legacy(budget, offset);\n             let g_span = mk_sp(span.lo(), body_lo);\n-            let generics_str = rewrite_generics(context, generics, shape, g_span)?;\n+            let generics_str = rewrite_generics(context, \"\", generics, shape, g_span)?;\n             result.push_str(&generics_str);\n \n             let where_budget = context.budget(last_line_width(&result));\n@@ -1350,7 +1324,6 @@ pub fn rewrite_type_alias(\n \n     result.push_str(&format_visibility(vis));\n     result.push_str(\"type \");\n-    result.push_str(&ident.to_string());\n \n     // 2 = `= `\n     let g_shape = Shape::indented(indent, context.config)\n@@ -1360,7 +1333,7 @@ pub fn rewrite_type_alias(\n         context.snippet_provider.span_after(span, \"type\"),\n         ty.span.lo(),\n     );\n-    let generics_str = rewrite_generics(context, generics, g_shape, g_span)?;\n+    let generics_str = rewrite_generics(context, &ident.to_string(), generics, g_shape, g_span)?;\n     result.push_str(&generics_str);\n \n     let where_budget = context.budget(last_line_width(&result));\n@@ -1801,7 +1774,6 @@ fn rewrite_fn_base(\n \n     // fn foo\n     result.push_str(\"fn \");\n-    result.push_str(&ident.to_string());\n \n     // Generics.\n     let overhead = if has_body && !newline_brace {\n@@ -1820,7 +1792,8 @@ fn rewrite_fn_base(\n     };\n     let fd = fn_sig.decl;\n     let g_span = mk_sp(span.lo(), fd.output.span().lo());\n-    let generics_str = rewrite_generics(context, fn_sig.generics, shape, g_span)?;\n+    let generics_str =\n+        rewrite_generics(context, &ident.to_string(), fn_sig.generics, shape, g_span)?;\n     result.push_str(&generics_str);\n \n     let snuggle_angle_bracket = generics_str\n@@ -2326,43 +2299,20 @@ fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n \n fn rewrite_generics(\n     context: &RewriteContext,\n+    ident: &str,\n     generics: &ast::Generics,\n     shape: Shape,\n     span: Span,\n-) -> Option<String> {\n-    let g_shape = generics_shape_from_config(context.config, shape, 0)?;\n-    let one_line_width = shape.width.checked_sub(2).unwrap_or(0);\n-    rewrite_generics_inner(context, generics, g_shape, one_line_width, span)\n-        .or_else(|| rewrite_generics_inner(context, generics, g_shape, 0, span))\n-}\n-\n-fn rewrite_generics_inner(\n-    context: &RewriteContext,\n-    generics: &ast::Generics,\n-    shape: Shape,\n-    one_line_width: usize,\n-    span: Span,\n ) -> Option<String> {\n     // FIXME: convert bounds to where clauses where they get too big or if\n     // there is a where clause at all.\n \n     if generics.params.is_empty() {\n-        return Some(String::new());\n+        return Some(ident.to_owned());\n     }\n \n-    let items = itemize_list(\n-        context.snippet_provider,\n-        generics.params.iter(),\n-        \">\",\n-        \",\",\n-        |arg| arg.span().lo(),\n-        |arg| arg.span().hi(),\n-        |arg| arg.rewrite(context, shape),\n-        context.snippet_provider.span_after(span, \"<\"),\n-        span.hi(),\n-        false,\n-    );\n-    format_generics_item_list(context, items, shape, one_line_width)\n+    let params = &generics.params.iter().map(|e| &*e).collect::<Vec<_>>()[..];\n+    overflow::rewrite_with_angle_brackets(context, ident, params, shape, span)\n }\n \n pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize) -> Option<Shape> {\n@@ -2379,70 +2329,6 @@ pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize)\n     }\n }\n \n-pub fn format_generics_item_list<I>(\n-    context: &RewriteContext,\n-    items: I,\n-    shape: Shape,\n-    one_line_budget: usize,\n-) -> Option<String>\n-where\n-    I: Iterator<Item = ListItem>,\n-{\n-    let item_vec = items.collect::<Vec<_>>();\n-\n-    let tactic = definitive_tactic(\n-        &item_vec,\n-        ListTactic::HorizontalVertical,\n-        Separator::Comma,\n-        one_line_budget,\n-    );\n-    let fmt = ListFormatting {\n-        tactic,\n-        separator: \",\",\n-        trailing_separator: if context.config.indent_style() == IndentStyle::Visual {\n-            SeparatorTactic::Never\n-        } else {\n-            context.config.trailing_comma()\n-        },\n-        separator_place: SeparatorPlace::Back,\n-        shape,\n-        ends_with_newline: tactic.ends_with_newline(context.config.indent_style()),\n-        preserve_newline: true,\n-        config: context.config,\n-    };\n-\n-    let list_str = write_list(&item_vec, &fmt)?;\n-\n-    Some(wrap_generics_with_angle_brackets(\n-        context,\n-        &list_str,\n-        shape.indent,\n-    ))\n-}\n-\n-pub fn wrap_generics_with_angle_brackets(\n-    context: &RewriteContext,\n-    list_str: &str,\n-    list_offset: Indent,\n-) -> String {\n-    if context.config.indent_style() == IndentStyle::Block\n-        && (list_str.contains('\\n') || list_str.ends_with(','))\n-    {\n-        format!(\n-            \"<\\n{}{}\\n{}>\",\n-            list_offset.to_string(context.config),\n-            list_str,\n-            list_offset\n-                .block_unindent(context.config)\n-                .to_string(context.config)\n-        )\n-    } else if context.config.spaces_within_parens_and_brackets() {\n-        format!(\"< {} >\", list_str)\n-    } else {\n-        format!(\"<{}>\", list_str)\n-    }\n-}\n-\n fn rewrite_trait_bounds(\n     context: &RewriteContext,\n     bounds: &[ast::TyParamBound],\n@@ -2713,7 +2599,7 @@ fn format_generics(\n     used_width: usize,\n ) -> Option<String> {\n     let shape = Shape::legacy(context.budget(used_width + offset.width()), offset);\n-    let mut result = rewrite_generics(context, generics, shape, span)?;\n+    let mut result = rewrite_generics(context, \"\", generics, shape, span)?;\n \n     let same_line_brace = if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n         let budget = context.budget(last_line_used_width(&result, offset.width()));"}, {"sha": "ac7990b9c0b05bb7f3030d766fd380c2b6934908", "filename": "src/types.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2a99d9704f5d2c5c268675cb9cb7ac397c13c518/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a99d9704f5d2c5c268675cb9cb7ac397c13c518/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=2a99d9704f5d2c5c268675cb9cb7ac397c13c518", "patch": "@@ -18,10 +18,10 @@ use syntax::symbol::keywords;\n \n use codemap::SpanUtils;\n use config::{IndentStyle, TypeDensity};\n-use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, wrap_args_with_parens, PairParts};\n-use items::{format_generics_item_list, generics_shape_from_config};\n+use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, PairParts, ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use macros::{rewrite_macro, MacroPosition};\n+use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n@@ -151,8 +151,8 @@ enum SegmentParam<'a> {\n     Binding(&'a ast::TypeBinding),\n }\n \n-impl<'a> SegmentParam<'a> {\n-    fn get_span(&self) -> Span {\n+impl<'a> Spanned for SegmentParam<'a> {\n+    fn span(&self) -> Span {\n         match *self {\n             SegmentParam::LifeTime(lt) => lt.span,\n             SegmentParam::Type(ty) => ty.span,\n@@ -161,6 +161,19 @@ impl<'a> SegmentParam<'a> {\n     }\n }\n \n+impl<'a> ToExpr for SegmentParam<'a> {\n+    fn to_expr(&self) -> Option<&ast::Expr> {\n+        None\n+    }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        match *self {\n+            SegmentParam::Type(ty) => ty.can_be_overflowed(context, len),\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'a> Rewrite for SegmentParam<'a> {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {\n@@ -204,7 +217,11 @@ fn rewrite_segment(\n     result.push_str(&segment.identifier.name.as_str());\n \n     let ident_len = result.len();\n-    let shape = shape.shrink_left(ident_len)?;\n+    let shape = if context.use_block_indent() {\n+        shape.offset_left(ident_len)?\n+    } else {\n+        shape.shrink_left(ident_len)?\n+    };\n \n     if let Some(ref params) = segment.parameters {\n         match **params {\n@@ -219,37 +236,25 @@ fn rewrite_segment(\n                     .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n                     .collect::<Vec<_>>();\n \n-                let next_span_lo = param_list.last().unwrap().get_span().hi() + BytePos(1);\n-                let list_lo = context\n-                    .snippet_provider\n-                    .span_after(mk_sp(*span_lo, span_hi), \"<\");\n                 let separator = if path_context == PathContext::Expr {\n                     \"::\"\n                 } else {\n                     \"\"\n                 };\n                 result.push_str(separator);\n \n-                let generics_shape =\n-                    generics_shape_from_config(context.config, shape, separator.len())?;\n-                let one_line_width = shape.width.checked_sub(separator.len() + 2)?;\n-                let items = itemize_list(\n-                    context.snippet_provider,\n-                    param_list.into_iter(),\n-                    \">\",\n-                    \",\",\n-                    |param| param.get_span().lo(),\n-                    |param| param.get_span().hi(),\n-                    |seg| seg.rewrite(context, generics_shape),\n-                    list_lo,\n-                    span_hi,\n-                    false,\n-                );\n-                let generics_str =\n-                    format_generics_item_list(context, items, generics_shape, one_line_width)?;\n+                let generics_str = overflow::rewrite_with_angle_brackets(\n+                    context,\n+                    \"\",\n+                    &param_list.iter().map(|e| &*e).collect::<Vec<_>>()[..],\n+                    shape,\n+                    mk_sp(*span_lo, span_hi),\n+                )?;\n \n                 // Update position of last bracket.\n-                *span_lo = next_span_lo;\n+                *span_lo = context\n+                    .snippet_provider\n+                    .span_after(mk_sp(*span_lo, span_hi), \"<\");\n \n                 result.push_str(&generics_str)\n             }\n@@ -807,7 +812,7 @@ pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &[String])\n \n pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize) -> bool {\n     match ty.node {\n-        ast::TyKind::Path(..) | ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n+        ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n         ast::TyKind::Rptr(_, ref mutty) | ast::TyKind::Ptr(ref mutty) => {\n             can_be_overflowed_type(context, &*mutty.ty, len)\n         }"}]}