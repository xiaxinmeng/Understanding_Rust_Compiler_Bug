{"sha": "a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "node_id": "C_kwDOAAsO6NoAKGEwMGZhOTYzMzY0NWEyMzU5ZGY4MWIyZTNmZDA4YzRlYWFmMDVmYmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-13T11:05:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-13T11:05:55Z"}, "message": "Auto merge of #2479 - saethlin:tag-gc, r=oli-obk\n\nImplement a garbage collector for tags\n\nThe general approach here is to scan TLS, all locals, and the main memory map for all provenance, accumulating a `HashSet` of all pointer tags which are stored anywhere (we also have a special case for panic payloads). Then we iterate over every borrow stack and remove tags which are not in said `HashSet`, or which could be terminating a SRW block.\n\nRuntime of benchmarks decreases by between 17% and 81%.\n\nGC off:\n```\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/backtraces/Cargo.toml\n  Time (mean \u00b1 \u03c3):      7.080 s \u00b1  0.249 s    [User: 6.870 s, System: 0.202 s]\n  Range (min \u2026 max):    6.933 s \u2026  7.521 s    5 runs\n\n  Warning: Statistical outliers were detected. Consider re-running this benchmark on a quiet PC without any interferences from other programs. It might help to use the '--warmup' or '--prepare' options.\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/mse/Cargo.toml\n  Time (mean \u00b1 \u03c3):      1.875 s \u00b1  0.031 s    [User: 1.630 s, System: 0.245 s]\n  Range (min \u2026 max):    1.825 s \u2026  1.910 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/serde1/Cargo.toml\n  Time (mean \u00b1 \u03c3):      2.785 s \u00b1  0.075 s    [User: 2.536 s, System: 0.168 s]\n  Range (min \u2026 max):    2.698 s \u2026  2.851 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/serde2/Cargo.toml\n  Time (mean \u00b1 \u03c3):      6.267 s \u00b1  0.066 s    [User: 6.072 s, System: 0.190 s]\n  Range (min \u2026 max):    6.152 s \u2026  6.314 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/slice-get-unchecked/Cargo.toml\n  Time (mean \u00b1 \u03c3):      4.733 s \u00b1  0.080 s    [User: 4.177 s, System: 0.513 s]\n  Range (min \u2026 max):    4.681 s \u2026  4.874 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/unicode/Cargo.toml\n  Time (mean \u00b1 \u03c3):      3.770 s \u00b1  0.034 s    [User: 3.549 s, System: 0.211 s]\n  Range (min \u2026 max):    3.724 s \u2026  3.819 s    5 runs\n```\nGC on:\n```\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/backtraces/Cargo.toml\n  Time (mean \u00b1 \u03c3):      5.886 s \u00b1  0.054 s    [User: 5.696 s, System: 0.182 s]\n  Range (min \u2026 max):    5.799 s \u2026  5.937 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/mse/Cargo.toml\n  Time (mean \u00b1 \u03c3):     936.4 ms \u00b1   7.0 ms    [User: 815.4 ms, System: 119.6 ms]\n  Range (min \u2026 max):   925.7 ms \u2026 945.0 ms    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/serde1/Cargo.toml\n  Time (mean \u00b1 \u03c3):      2.126 s \u00b1  0.022 s    [User: 1.979 s, System: 0.146 s]\n  Range (min \u2026 max):    2.089 s \u2026  2.143 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/serde2/Cargo.toml\n  Time (mean \u00b1 \u03c3):      4.242 s \u00b1  0.066 s    [User: 4.051 s, System: 0.160 s]\n  Range (min \u2026 max):    4.196 s \u2026  4.357 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/slice-get-unchecked/Cargo.toml\n  Time (mean \u00b1 \u03c3):     907.4 ms \u00b1   2.4 ms    [User: 788.6 ms, System: 118.2 ms]\n  Range (min \u2026 max):   903.5 ms \u2026 909.4 ms    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/unicode/Cargo.toml\n  Time (mean \u00b1 \u03c3):      1.821 s \u00b1  0.011 s    [User: 1.687 s, System: 0.133 s]\n  Range (min \u2026 max):    1.802 s \u2026  1.831 s    5 runs\n```\n\nBut much more importantly for me this drops the peak memory usage of the first 1 minute of running `regex`'s tests from 103  GB to 1.7 GB.\n\nThanks to `@oli-obk` for suggesting a while ago that this was possible and `@darksonn` for reminding me that we can just search through memory to find Provenance to locate pointers.\n\nFixes https://github.com/rust-lang/miri/issues/1367", "tree": {"sha": "3e47923633febd70b0d3850c9389292404eac8dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e47923633febd70b0d3850c9389292404eac8dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "html_url": "https://github.com/rust-lang/rust/commit/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3886a63ea4a4579afb54173e33a4d4a55d977096", "url": "https://api.github.com/repos/rust-lang/rust/commits/3886a63ea4a4579afb54173e33a4d4a55d977096", "html_url": "https://github.com/rust-lang/rust/commit/3886a63ea4a4579afb54173e33a4d4a55d977096"}, {"sha": "f59605ce521b6eae453875cbdfe9263ab7e50d9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f59605ce521b6eae453875cbdfe9263ab7e50d9e", "html_url": "https://github.com/rust-lang/rust/commit/f59605ce521b6eae453875cbdfe9263ab7e50d9e"}], "stats": {"total": 251, "additions": 243, "deletions": 8}, "files": [{"sha": "fde575922dd11111d724f30069f11347b9764616", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -34,6 +34,10 @@ jobs:\n     steps:\n       - uses: actions/checkout@v3\n \n+      - name: Set the tag GC interval to 1 on linux\n+        if: runner.os == 'macOS'\n+        run: echo \"MIRIFLAGS=-Zmiri-tag-gc=1\" >> $GITHUB_ENV\n+\n       # We install gnu-tar because BSD tar is buggy on macOS builders of GHA.\n       # See <https://github.com/actions/cache/issues/403>.\n       - name: Install GNU tar"}, {"sha": "120ce82e60f9cec29b47729eea377da0a7c91eb8", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -323,6 +323,10 @@ environment variable. We first document the most relevant and most commonly used\n   ensure alignment.  (The standard library `align_to` method works fine in both modes; under\n   symbolic alignment it only fills the middle slice when the allocation guarantees sufficient\n   alignment.)\n+* `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n+  is to search for and remove unreachable tags once every `10,000` basic blocks. Setting this to\n+  `0` disables the garbage collector, which causes some programs to have explosive memory usage\n+  and/or super-linear runtime.\n \n The remaining flags are for advanced use only, and more likely to change or be removed.\n Some of these are **unsound**, which means they can lead"}, {"sha": "aa322e54a31da02da19282f7ee4d2b55761c5c53", "filename": "ci.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/ci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/ci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci.sh?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -31,7 +31,7 @@ function run_tests {\n     # optimizations up all the way).\n     # Optimizations change diagnostics (mostly backtraces), so we don't check them\n     #FIXME(#2155): we want to only run the pass and panic tests here, not the fail tests.\n-    MIRIFLAGS=\"-O -Zmir-opt-level=4\" MIRI_SKIP_UI_CHECKS=1 ./miri test -- tests/{pass,panic}\n+    MIRIFLAGS=\"${MIRIFLAGS:-} -O -Zmir-opt-level=4\" MIRI_SKIP_UI_CHECKS=1 ./miri test -- tests/{pass,panic}\n   fi\n \n   ## test-cargo-miri"}, {"sha": "d9e91951a92291fe67f8ff7b6a6f98b534410084", "filename": "src/bin/miri.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -521,6 +521,12 @@ fn main() {\n                 Err(err) => show_error!(\"-Zmiri-report-progress requires a `u32`: {}\", err),\n             };\n             miri_config.report_progress = Some(interval);\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-tag-gc=\") {\n+            let interval = match param.parse::<u32>() {\n+                Ok(i) => i,\n+                Err(err) => show_error!(\"-Zmiri-tag-gc requires a `u32`: {}\", err),\n+            };\n+            miri_config.gc_interval = interval;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-measureme=\") {\n             miri_config.measureme_out = Some(param.to_string());\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-backtrace=\") {"}, {"sha": "19da0fc678ab226db3d709899878a95e05b914e5", "filename": "src/concurrency/thread.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fthread.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -289,6 +289,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         &mut self.threads[self.active_thread].stack\n     }\n \n+    pub fn iter(&self) -> impl Iterator<Item = &Thread<'mir, 'tcx>> {\n+        self.threads.iter()\n+    }\n+\n     pub fn all_stacks(\n         &self,\n     ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>]> {"}, {"sha": "8cdb2876f1a1f74398029b3854dd657f06b17c63", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -132,6 +132,8 @@ pub struct MiriConfig {\n     /// The location of a shared object file to load when calling external functions\n     /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory\n     pub external_so_file: Option<PathBuf>,\n+    /// Run a garbage collector for SbTags every N basic blocks.\n+    pub gc_interval: u32,\n }\n \n impl Default for MiriConfig {\n@@ -164,6 +166,7 @@ impl Default for MiriConfig {\n             report_progress: None,\n             retag_fields: false,\n             external_so_file: None,\n+            gc_interval: 10_000,\n         }\n     }\n }"}, {"sha": "4fb6704165be54c110f8049a7e08c2c2a656ff4c", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -62,6 +62,7 @@ mod operator;\n mod range_map;\n mod shims;\n mod stacked_borrows;\n+mod tag_gc;\n \n // Establish a \"crate-wide prelude\": we often import `crate::*`.\n \n@@ -110,6 +111,7 @@ pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n     CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n };\n+pub use crate::tag_gc::EvalContextExt as _;\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "60fe2a91adf73d607bbffbe89f99176b0f06a1ce", "filename": "src/machine.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -394,6 +394,11 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Handle of the optional shared object file for external functions.\n     pub external_so_lib: Option<(libloading::Library, std::path::PathBuf)>,\n+\n+    /// Run a garbage collector for SbTags every N basic blocks.\n+    pub(crate) gc_interval: u32,\n+    /// The number of blocks that passed since the last SbTag GC pass.\n+    pub(crate) since_gc: u32,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n@@ -469,6 +474,8 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n                     lib_file_path.clone(),\n                 )\n             }),\n+            gc_interval: config.gc_interval,\n+            since_gc: 0,\n         }\n     }\n \n@@ -1008,6 +1015,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         ecx.machine.basic_block_count += 1u64; // a u64 that is only incremented by 1 will \"never\" overflow\n+        ecx.machine.since_gc += 1;\n         // Possibly report our progress.\n         if let Some(report_progress) = ecx.machine.report_progress {\n             if ecx.machine.basic_block_count % u64::from(report_progress) == 0 {\n@@ -1016,6 +1024,16 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 });\n             }\n         }\n+\n+        // Search for SbTags to find all live pointers, then remove all other tags from borrow\n+        // stacks.\n+        // When debug assertions are enabled, run the GC as often as possible so that any cases\n+        // where it mistakenly removes an important tag become visible.\n+        if ecx.machine.gc_interval > 0 && ecx.machine.since_gc >= ecx.machine.gc_interval {\n+            ecx.machine.since_gc = 0;\n+            ecx.garbage_collect_tags()?;\n+        }\n+\n         // These are our preemption points.\n         ecx.maybe_preempt_active_thread();\n         Ok(())"}, {"sha": "343fa05712dcfd6e4d547b1ecd52986c2d33706e", "filename": "src/shims/tls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -233,6 +233,12 @@ impl<'tcx> TlsData<'tcx> {\n             data.remove(&thread_id);\n         }\n     }\n+\n+    pub fn iter(&self, mut visitor: impl FnMut(&Scalar<Provenance>)) {\n+        for scalar in self.keys.values().flat_map(|v| v.data.values()) {\n+            visitor(scalar);\n+        }\n+    }\n }\n \n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}"}, {"sha": "9257628456632a6ef53f83878f741a2e1eabee32", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -80,6 +80,8 @@ pub struct Stacks {\n     history: AllocHistory,\n     /// The set of tags that have been exposed inside this allocation.\n     exposed_tags: FxHashSet<SbTag>,\n+    /// Whether this memory has been modified since the last time the tag GC ran\n+    modified_since_last_gc: bool,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -422,6 +424,7 @@ impl<'tcx> Stack {\n             let item = self.get(idx).unwrap();\n             Stack::item_popped(&item, global, dcx)?;\n         }\n+\n         Ok(())\n     }\n \n@@ -496,6 +499,20 @@ impl<'tcx> Stack {\n }\n // # Stacked Borrows Core End\n \n+/// Integration with the SbTag garbage collector\n+impl Stacks {\n+    pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<SbTag>) {\n+        if self.modified_since_last_gc {\n+            for stack in self.stacks.iter_mut_all() {\n+                if stack.len() > 64 {\n+                    stack.retain(live_tags);\n+                }\n+            }\n+            self.modified_since_last_gc = false;\n+        }\n+    }\n+}\n+\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates a new stack with an initial tag. For diagnostic purposes, we also need to know\n@@ -514,6 +531,7 @@ impl<'tcx> Stacks {\n             stacks: RangeMap::new(size, stack),\n             history: AllocHistory::new(id, item, current_span),\n             exposed_tags: FxHashSet::default(),\n+            modified_since_last_gc: false,\n         }\n     }\n \n@@ -528,6 +546,7 @@ impl<'tcx> Stacks {\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n+        self.modified_since_last_gc = true;\n         for (offset, stack) in self.stacks.iter_mut(range.start, range.size) {\n             let mut dcx = dcx_builder.build(&mut self.history, offset);\n             f(stack, &mut dcx, &mut self.exposed_tags)?;"}, {"sha": "494ea08b56e48b2b594f4fa2725e2b14543613d1", "filename": "src/stacked_borrows/stack.rs", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fstack.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -39,6 +39,61 @@ pub struct Stack {\n     unique_range: Range<usize>,\n }\n \n+impl Stack {\n+    pub fn retain(&mut self, tags: &FxHashSet<SbTag>) {\n+        let mut first_removed = None;\n+\n+        let mut read_idx = 1;\n+        let mut write_idx = 1;\n+        while read_idx < self.borrows.len() {\n+            let left = self.borrows[read_idx - 1];\n+            let this = self.borrows[read_idx];\n+            let should_keep = match this.perm() {\n+                // SharedReadWrite is the simplest case, if it's unreachable we can just remove it.\n+                Permission::SharedReadWrite => tags.contains(&this.tag()),\n+                // Only retain a Disabled tag if it is terminating a SharedReadWrite block.\n+                Permission::Disabled => left.perm() == Permission::SharedReadWrite,\n+                // Unique and SharedReadOnly can terminate a SharedReadWrite block, so only remove\n+                // them if they are both unreachable and not directly after a SharedReadWrite.\n+                Permission::Unique | Permission::SharedReadOnly =>\n+                    left.perm() == Permission::SharedReadWrite || tags.contains(&this.tag()),\n+            };\n+\n+            if should_keep {\n+                if read_idx != write_idx {\n+                    self.borrows[write_idx] = self.borrows[read_idx];\n+                }\n+                write_idx += 1;\n+            } else if first_removed.is_none() {\n+                first_removed = Some(read_idx);\n+            }\n+\n+            read_idx += 1;\n+        }\n+        self.borrows.truncate(write_idx);\n+\n+        #[cfg(not(feature = \"stack-cache\"))]\n+        drop(first_removed); // This is only needed for the stack-cache\n+\n+        #[cfg(feature = \"stack-cache\")]\n+        if let Some(first_removed) = first_removed {\n+            // Either end of unique_range may have shifted, all we really know is that we can't\n+            // have introduced a new Unique.\n+            if !self.unique_range.is_empty() {\n+                self.unique_range = 0..self.len();\n+            }\n+\n+            // Replace any Items which have been collected with the base item, a known-good value.\n+            for i in 0..CACHE_LEN {\n+                if self.cache.idx[i] >= first_removed {\n+                    self.cache.items[i] = self.borrows[0];\n+                    self.cache.idx[i] = 0;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// A very small cache of searches of a borrow stack, mapping `Item`s to their position in said stack.\n ///\n /// It may seem like maintaining this cache is a waste for small stacks, but\n@@ -105,14 +160,11 @@ impl<'tcx> Stack {\n \n         // Check that the unique_range is a valid index into the borrow stack.\n         // This asserts that the unique_range's start <= end.\n-        let uniques = &self.borrows[self.unique_range.clone()];\n+        let _uniques = &self.borrows[self.unique_range.clone()];\n \n-        // Check that the start of the unique_range is precise.\n-        if let Some(first_unique) = uniques.first() {\n-            assert_eq!(first_unique.perm(), Permission::Unique);\n-        }\n-        // We cannot assert that the unique range is exact on the upper end.\n-        // When we pop items within the unique range, setting the end of the range precisely\n+        // We cannot assert that the unique range is precise.\n+        // Both ends may shift around when `Stack::retain` is called. Additionally,\n+        // when we pop items within the unique range, setting the end of the range precisely\n         // requires doing a linear search of the borrow stack, which is exactly the kind of\n         // operation that all this caching exists to avoid.\n     }"}, {"sha": "0402e4d35dd512c24924adf0257b4e223d747c8d", "filename": "src/tag_gc.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00fa9633645a2359df81b2e3fd08c4eaaf05fbe/src%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftag_gc.rs?ref=a00fa9633645a2359df81b2e3fd08c4eaaf05fbe", "patch": "@@ -0,0 +1,117 @@\n+use crate::*;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+    fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        // No reason to do anything at all if stacked borrows is off.\n+        if this.machine.stacked_borrows.is_none() {\n+            return Ok(());\n+        }\n+\n+        let mut tags = FxHashSet::default();\n+\n+        for thread in this.machine.threads.iter() {\n+            if let Some(Scalar::Ptr(\n+                Pointer { provenance: Provenance::Concrete { sb, .. }, .. },\n+                _,\n+            )) = thread.panic_payload\n+            {\n+                tags.insert(sb);\n+            }\n+        }\n+\n+        self.find_tags_in_tls(&mut tags);\n+        self.find_tags_in_memory(&mut tags);\n+        self.find_tags_in_locals(&mut tags)?;\n+\n+        self.remove_unreachable_tags(tags);\n+\n+        Ok(())\n+    }\n+\n+    fn find_tags_in_tls(&mut self, tags: &mut FxHashSet<SbTag>) {\n+        let this = self.eval_context_mut();\n+        this.machine.tls.iter(|scalar| {\n+            if let Scalar::Ptr(Pointer { provenance: Provenance::Concrete { sb, .. }, .. }, _) =\n+                scalar\n+            {\n+                tags.insert(*sb);\n+            }\n+        });\n+    }\n+\n+    fn find_tags_in_memory(&mut self, tags: &mut FxHashSet<SbTag>) {\n+        let this = self.eval_context_mut();\n+        this.memory.alloc_map().iter(|it| {\n+            for (_id, (_kind, alloc)) in it {\n+                for (_size, prov) in alloc.provenance().iter() {\n+                    if let Provenance::Concrete { sb, .. } = prov {\n+                        tags.insert(*sb);\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    fn find_tags_in_locals(&mut self, tags: &mut FxHashSet<SbTag>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for frame in this.machine.threads.all_stacks().flatten() {\n+            // Handle the return place of each frame\n+            if let Ok(return_place) = frame.return_place.try_as_mplace() {\n+                if let Some(Provenance::Concrete { sb, .. }) = return_place.ptr.provenance {\n+                    tags.insert(sb);\n+                }\n+            }\n+\n+            for local in frame.locals.iter() {\n+                let LocalValue::Live(value) = local.value else {\n+                continue;\n+            };\n+                match value {\n+                    Operand::Immediate(Immediate::Scalar(Scalar::Ptr(ptr, _))) =>\n+                        if let Provenance::Concrete { sb, .. } = ptr.provenance {\n+                            tags.insert(sb);\n+                        },\n+                    Operand::Immediate(Immediate::ScalarPair(s1, s2)) => {\n+                        if let Scalar::Ptr(ptr, _) = s1 {\n+                            if let Provenance::Concrete { sb, .. } = ptr.provenance {\n+                                tags.insert(sb);\n+                            }\n+                        }\n+                        if let Scalar::Ptr(ptr, _) = s2 {\n+                            if let Provenance::Concrete { sb, .. } = ptr.provenance {\n+                                tags.insert(sb);\n+                            }\n+                        }\n+                    }\n+                    Operand::Indirect(MemPlace { ptr, .. }) => {\n+                        if let Some(Provenance::Concrete { sb, .. }) = ptr.provenance {\n+                            tags.insert(sb);\n+                        }\n+                    }\n+                    Operand::Immediate(Immediate::Uninit)\n+                    | Operand::Immediate(Immediate::Scalar(Scalar::Int(_))) => {}\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn remove_unreachable_tags(&mut self, tags: FxHashSet<SbTag>) {\n+        let this = self.eval_context_mut();\n+        this.memory.alloc_map().iter(|it| {\n+            for (_id, (_kind, alloc)) in it {\n+                alloc\n+                    .extra\n+                    .stacked_borrows\n+                    .as_ref()\n+                    .unwrap()\n+                    .borrow_mut()\n+                    .remove_unreachable_tags(&tags);\n+            }\n+        });\n+    }\n+}"}]}