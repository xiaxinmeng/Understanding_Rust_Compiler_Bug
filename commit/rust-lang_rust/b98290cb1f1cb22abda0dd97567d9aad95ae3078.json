{"sha": "b98290cb1f1cb22abda0dd97567d9aad95ae3078", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ODI5MGNiMWYxY2IyMmFiZGEwZGQ5NzU2N2Q5YWFkOTVhZTMwNzg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-11-07T21:43:05Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-11-07T21:43:05Z"}, "message": "save-analysis: run rustfmt", "tree": {"sha": "585d5b74c2898f2e0ff77007e0a4578c916380a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/585d5b74c2898f2e0ff77007e0a4578c916380a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b98290cb1f1cb22abda0dd97567d9aad95ae3078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b98290cb1f1cb22abda0dd97567d9aad95ae3078", "html_url": "https://github.com/rust-lang/rust/commit/b98290cb1f1cb22abda0dd97567d9aad95ae3078", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b98290cb1f1cb22abda0dd97567d9aad95ae3078/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1328c29d4ae91fe0f932a6036e38374740179213", "url": "https://api.github.com/repos/rust-lang/rust/commits/1328c29d4ae91fe0f932a6036e38374740179213", "html_url": "https://github.com/rust-lang/rust/commit/1328c29d4ae91fe0f932a6036e38374740179213"}], "stats": {"total": 1712, "additions": 945, "deletions": 767}, "files": [{"sha": "272b1cb8d35160e45038d7d63f8df2240f6adfbb", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 521, "deletions": 399, "changes": 920, "blob_url": "https://github.com/rust-lang/rust/blob/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b98290cb1f1cb22abda0dd97567d9aad95ae3078", "patch": "@@ -32,22 +32,22 @@ use rustc_data_structures::fx::FxHashSet;\n \n use std::path::Path;\n \n-use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n+use syntax::ast::{self, Attribute, NodeId, PatKind, CRATE_NODE_ID};\n use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n+use syntax::print::pprust::{bounds_to_string, generics_to_string, path_to_string, ty_to_string};\n use syntax::ptr::P;\n use syntax::codemap::Spanned;\n use syntax_pos::*;\n \n-use {escape, generated_code, SaveContext, PathCollector, lower_attributes};\n-use json_dumper::{JsonDumper, DumpOutput};\n+use {escape, generated_code, lower_attributes, PathCollector, SaveContext};\n+use json_dumper::{DumpOutput, JsonDumper};\n use span_utils::SpanUtils;\n use sig;\n \n-use rls_data::{CratePreludeData, GlobalCrateId, Import, ImportKind, SpanData,\n-               Ref, RefKind, Def, DefKind, Relation, RelationKind};\n+use rls_data::{CratePreludeData, Def, DefKind, GlobalCrateId, Import, ImportKind, Ref, RefKind,\n+               Relation, RelationKind, SpanData};\n \n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $sp:expr) => {\n@@ -77,9 +77,10 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> {\n }\n \n impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n-    pub fn new(save_ctxt: SaveContext<'l, 'tcx>,\n-               dumper: &'ll mut JsonDumper<O>)\n-               -> DumpVisitor<'l, 'tcx, 'll, O> {\n+    pub fn new(\n+        save_ctxt: SaveContext<'l, 'tcx>,\n+        dumper: &'ll mut JsonDumper<O>,\n+    ) -> DumpVisitor<'l, 'tcx, 'll, O> {\n         let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n         DumpVisitor {\n             tcx: save_ctxt.tcx,\n@@ -93,7 +94,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     }\n \n     fn nest_scope<F>(&mut self, scope_id: NodeId, f: F)\n-        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, O>)\n+    where\n+        F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, O>),\n     {\n         let parent_scope = self.cur_scope;\n         self.cur_scope = scope_id;\n@@ -102,7 +104,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     }\n \n     fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n-        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, O>)\n+    where\n+        F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, O>),\n     {\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n         if self.tcx.has_typeck_tables(item_def_id) {\n@@ -133,8 +136,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let data = CratePreludeData {\n             crate_id: GlobalCrateId {\n                 name: name.into(),\n-                disambiguator: self.tcx.sess.local_crate_disambiguator()\n-                                   .to_fingerprint().as_value(),\n+                disambiguator: self.tcx\n+                    .sess\n+                    .local_crate_disambiguator()\n+                    .to_fingerprint()\n+                    .as_value(),\n             },\n             crate_root: crate_root.unwrap_or(\"<no source>\".to_owned()),\n             external_crates: self.save_ctxt.get_external_crates(),\n@@ -210,10 +216,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if len <= 1 {\n             return;\n         }\n-        let sub_paths = &sub_paths[.. (len-1)];\n+        let sub_paths = &sub_paths[..(len - 1)];\n \n         // write the trait part of the sub-path\n-        let (ref span, _) = sub_paths[len-2];\n+        let (ref span, _) = sub_paths[len - 2];\n         let span = self.span_from_span(*span);\n         self.dumper.dump_ref(Ref {\n             kind: RefKind::Type,\n@@ -225,7 +231,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = &sub_paths[..len-2];\n+        let sub_paths = &sub_paths[..len - 2];\n         for &(ref span, _) in sub_paths {\n             let span = self.span_from_span(*span);\n             self.dumper.dump_ref(Ref {\n@@ -243,11 +249,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n-    fn process_def_kind(&mut self,\n-                        ref_id: NodeId,\n-                        span: Span,\n-                        sub_span: Option<Span>,\n-                        def_id: DefId) {\n+    fn process_def_kind(\n+        &mut self,\n+        ref_id: NodeId,\n+        span: Span,\n+        sub_span: Option<Span>,\n+        def_id: DefId,\n+    ) {\n         if self.span.filter_generated(sub_span, span) {\n             return;\n         }\n@@ -309,9 +317,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             HirDef::PrimTy(_) |\n             HirDef::GlobalAsm(_) |\n             HirDef::Err => {\n-               span_bug!(span,\n-                         \"process_def_kind for unexpected item: {:?}\",\n-                         def);\n+                span_bug!(span, \"process_def_kind for unexpected item: {:?}\", def);\n             }\n         }\n     }\n@@ -334,49 +340,55 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let id = ::id_from_node_id(id, &self.save_ctxt);\n                     let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n-                    self.dumper.dump_def(false, Def {\n-                        kind: DefKind::Local,\n-                        id,\n-                        span,\n-                        name: i.to_string(),\n-                        qualname: format!(\"{}::{}\", qualname, i.to_string()),\n-                        value: typ,\n-                        parent: None,\n-                        children: vec![],\n-                        decl_id: None,\n-                        docs: String::new(),\n-                        sig: None,\n-                        attributes:vec![],\n-                    });\n+                    self.dumper.dump_def(\n+                        false,\n+                        Def {\n+                            kind: DefKind::Local,\n+                            id,\n+                            span,\n+                            name: i.to_string(),\n+                            qualname: format!(\"{}::{}\", qualname, i.to_string()),\n+                            value: typ,\n+                            parent: None,\n+                            children: vec![],\n+                            decl_id: None,\n+                            docs: String::new(),\n+                            sig: None,\n+                            attributes: vec![],\n+                        },\n+                    );\n                 }\n             }\n         }\n     }\n \n-    fn process_method(&mut self,\n-                      sig: &'l ast::MethodSig,\n-                      body: Option<&'l ast::Block>,\n-                      id: ast::NodeId,\n-                      name: ast::Ident,\n-                      generics: &'l ast::Generics,\n-                      vis: ast::Visibility,\n-                      span: Span) {\n+    fn process_method(\n+        &mut self,\n+        sig: &'l ast::MethodSig,\n+        body: Option<&'l ast::Block>,\n+        id: ast::NodeId,\n+        name: ast::Ident,\n+        generics: &'l ast::Generics,\n+        vis: ast::Visibility,\n+        span: Span,\n+    ) {\n         debug!(\"process_method: {}:{}\", id, name);\n \n         if let Some(mut method_data) = self.save_ctxt.get_method_data(id, name.name, span) {\n-\n             let sig_str = ::make_signature(&sig.decl, &generics);\n             if body.is_some() {\n-                self.nest_tables(id, |v| {\n-                    v.process_formals(&sig.decl.inputs, &method_data.qualname)\n-                });\n+                self.nest_tables(\n+                    id,\n+                    |v| v.process_formals(&sig.decl.inputs, &method_data.qualname),\n+                );\n             }\n \n             self.process_generic_params(&generics, span, &method_data.qualname, id);\n \n             method_data.value = sig_str;\n             method_data.sig = sig::method_signature(id, name, generics, sig, &self.save_ctxt);\n-            self.dumper.dump_def(vis == ast::Visibility::Public, method_data);\n+            self.dumper\n+                .dump_def(vis == ast::Visibility::Public, method_data);\n         }\n \n         // walk arg and return types\n@@ -397,57 +409,66 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            self.dumper.dump_def(field.vis == ast::Visibility::Public, field_data);\n+            self.dumper\n+                .dump_def(field.vis == ast::Visibility::Public, field_data);\n         }\n     }\n \n     // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(&mut self,\n-                              generics: &'l ast::Generics,\n-                              full_span: Span,\n-                              prefix: &str,\n-                              id: NodeId) {\n+    fn process_generic_params(\n+        &mut self,\n+        generics: &'l ast::Generics,\n+        full_span: Span,\n+        prefix: &str,\n+        id: NodeId,\n+    ) {\n         for param in &generics.ty_params {\n             let param_ss = param.span;\n             let name = escape(self.span.snippet(param_ss));\n             // Append $id to name to make sure each one is unique\n-            let qualname = format!(\"{}::{}${}\",\n-                                   prefix,\n-                                   name,\n-                                   id);\n+            let qualname = format!(\"{}::{}${}\", prefix, name, id);\n             if !self.span.filter_generated(Some(param_ss), full_span) {\n                 let id = ::id_from_node_id(param.id, &self.save_ctxt);\n                 let span = self.span_from_span(param_ss);\n \n-                self.dumper.dump_def(false, Def {\n-                    kind: DefKind::Type,\n-                    id,\n-                    span,\n-                    name,\n-                    qualname,\n-                    value: String::new(),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: String::new(),\n-                    sig: None,\n-                    attributes: vec![],\n-                });\n+                self.dumper.dump_def(\n+                    false,\n+                    Def {\n+                        kind: DefKind::Type,\n+                        id,\n+                        span,\n+                        name,\n+                        qualname,\n+                        value: String::new(),\n+                        parent: None,\n+                        children: vec![],\n+                        decl_id: None,\n+                        docs: String::new(),\n+                        sig: None,\n+                        attributes: vec![],\n+                    },\n+                );\n             }\n         }\n         self.visit_generics(generics);\n     }\n \n-    fn process_fn(&mut self,\n-                  item: &'l ast::Item,\n-                  decl: &'l ast::FnDecl,\n-                  ty_params: &'l ast::Generics,\n-                  body: &'l ast::Block) {\n+    fn process_fn(\n+        &mut self,\n+        item: &'l ast::Item,\n+        decl: &'l ast::FnDecl,\n+        ty_params: &'l ast::Generics,\n+        body: &'l ast::Block,\n+    ) {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(fn_data, DefData, item.span);\n-            self.nest_tables(item.id, |v| v.process_formals(&decl.inputs, &fn_data.qualname));\n+            self.nest_tables(\n+                item.id,\n+                |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n+            );\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n-            self.dumper.dump_def(item.vis == ast::Visibility::Public, fn_data);\n+            self.dumper\n+                .dump_def(item.vis == ast::Visibility::Public, fn_data);\n         }\n \n         for arg in &decl.inputs {\n@@ -461,29 +482,34 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.nest_tables(item.id, |v| v.nest_scope(item.id, |v| v.visit_block(&body)));\n     }\n \n-    fn process_static_or_const_item(&mut self,\n-                                    item: &'l ast::Item,\n-                                    typ: &'l ast::Ty,\n-                                    expr: &'l ast::Expr) {\n+    fn process_static_or_const_item(\n+        &mut self,\n+        item: &'l ast::Item,\n+        typ: &'l ast::Ty,\n+        expr: &'l ast::Expr,\n+    ) {\n         self.nest_tables(item.id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n+                v.dumper\n+                    .dump_def(item.vis == ast::Visibility::Public, var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n         });\n     }\n \n-    fn process_assoc_const(&mut self,\n-                           id: ast::NodeId,\n-                           name: ast::Name,\n-                           span: Span,\n-                           typ: &'l ast::Ty,\n-                           expr: Option<&'l ast::Expr>,\n-                           parent_id: DefId,\n-                           vis: ast::Visibility,\n-                           attrs: &'l [Attribute]) {\n+    fn process_assoc_const(\n+        &mut self,\n+        id: ast::NodeId,\n+        name: ast::Name,\n+        span: Span,\n+        typ: &'l ast::Ty,\n+        expr: Option<&'l ast::Expr>,\n+        parent_id: DefId,\n+        vis: ast::Visibility,\n+        attrs: &'l [Attribute],\n+    ) {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n@@ -493,20 +519,23 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             let id = ::id_from_node_id(id, &self.save_ctxt);\n             let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n-            self.dumper.dump_def(vis == ast::Visibility::Public, Def {\n-                kind: DefKind::Const,\n-                id,\n-                span,\n-                name: name.to_string(),\n-                qualname,\n-                value: ty_to_string(&typ),\n-                parent: Some(::id_from_def_id(parent_id)),\n-                children: vec![],\n-                decl_id: None,\n-                docs: self.save_ctxt.docs_for_attrs(attrs),\n-                sig,\n-                attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n-            });\n+            self.dumper.dump_def(\n+                vis == ast::Visibility::Public,\n+                Def {\n+                    kind: DefKind::Const,\n+                    id,\n+                    span,\n+                    name: name.to_string(),\n+                    qualname,\n+                    value: ty_to_string(&typ),\n+                    parent: Some(::id_from_def_id(parent_id)),\n+                    children: vec![],\n+                    decl_id: None,\n+                    docs: self.save_ctxt.docs_for_attrs(attrs),\n+                    sig,\n+                    attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n+                },\n+            );\n         }\n \n         // walk type and init value\n@@ -517,10 +546,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     }\n \n     // FIXME tuple structs should generate tuple-specific data.\n-    fn process_struct(&mut self,\n-                      item: &'l ast::Item,\n-                      def: &'l ast::VariantData,\n-                      ty_params: &'l ast::Generics) {\n+    fn process_struct(\n+        &mut self,\n+        item: &'l ast::Item,\n+        def: &'l ast::VariantData,\n+        ty_params: &'l ast::Generics,\n+    ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n@@ -540,36 +571,47 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                         if include_priv_fields || f.vis == ast::Visibility::Public {\n-                             f.ident.map(|i| i.to_string()).or_else(|| Some(i.to_string()))\n-                         } else {\n-                             None\n-                         }\n+                        if include_priv_fields || f.vis == ast::Visibility::Public {\n+                            f.ident\n+                                .map(|i| i.to_string())\n+                                .or_else(|| Some(i.to_string()))\n+                        } else {\n+                            None\n+                        }\n                     })\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n                 let value = format!(\"{} {{ {} }}\", name, fields_str);\n-                (value, fields.iter().map(|f| ::id_from_node_id(f.id, &self.save_ctxt)).collect())\n+                (\n+                    value,\n+                    fields\n+                        .iter()\n+                        .map(|f| ::id_from_node_id(f.id, &self.save_ctxt))\n+                        .collect(),\n+                )\n             }\n-            _ => (String::new(), vec![])\n+            _ => (String::new(), vec![]),\n         };\n \n         if !self.span.filter_generated(sub_span, item.span) {\n             let span = self.span_from_span(sub_span.expect(\"No span found for struct\"));\n-            self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n-                kind,\n-                id: ::id_from_node_id(item.id, &self.save_ctxt),\n-                span,\n-                name,\n-                qualname: qualname.clone(),\n-                value,\n-                parent: None,\n-                children: fields,\n-                decl_id: None,\n-                docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n-                sig: sig::item_signature(item, &self.save_ctxt),\n-                attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n-            });\n+            self.dumper.dump_def(\n+                item.vis == ast::Visibility::Public,\n+                Def {\n+                    kind,\n+                    id: ::id_from_node_id(item.id, &self.save_ctxt),\n+                    span,\n+                    name,\n+                    qualname: qualname.clone(),\n+                    value,\n+                    parent: None,\n+                    children: fields,\n+                    decl_id: None,\n+                    docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n+                    sig: sig::item_signature(item, &self.save_ctxt),\n+                    attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+                },\n+            );\n         }\n \n         for field in def.fields() {\n@@ -580,10 +622,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.process_generic_params(ty_params, item.span, &qualname, item.id);\n     }\n \n-    fn process_enum(&mut self,\n-                    item: &'l ast::Item,\n-                    enum_definition: &'l ast::EnumDef,\n-                    ty_params: &'l ast::Generics) {\n+    fn process_enum(\n+        &mut self,\n+        item: &'l ast::Item,\n+        enum_definition: &'l ast::EnumDef,\n+        ty_params: &'l ast::Generics,\n+    ) {\n         let enum_data = self.save_ctxt.get_item_data(item);\n         let enum_data = match enum_data {\n             None => return,\n@@ -600,45 +644,53 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             match variant.node.data {\n                 ast::VariantData::Struct(ref fields, _) => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n-                    let fields_str = fields.iter()\n-                                           .enumerate()\n-                                           .map(|(i, f)| f.ident.map(|i| i.to_string())\n-                                                          .unwrap_or(i.to_string()))\n-                                           .collect::<Vec<_>>()\n-                                           .join(\", \");\n+                    let fields_str = fields\n+                        .iter()\n+                        .enumerate()\n+                        .map(|(i, f)| {\n+                            f.ident.map(|i| i.to_string()).unwrap_or(i.to_string())\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \");\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(sub_span, variant.span) {\n-                        let span = self.span_from_span(\n-                            sub_span.expect(\"No span found for struct variant\"));\n+                        let span = self\n+                            .span_from_span(sub_span.expect(\"No span found for struct variant\"));\n                         let id = ::id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n-                        self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n-                            kind: DefKind::StructVariant,\n-                            id,\n-                            span,\n-                            name,\n-                            qualname,\n-                            value,\n-                            parent,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n-                            sig: sig::variant_signature(variant, &self.save_ctxt),\n-                            attributes: lower_attributes(variant.node.attrs.clone(),\n-                                                         &self.save_ctxt),\n-                        });\n+                        self.dumper.dump_def(\n+                            item.vis == ast::Visibility::Public,\n+                            Def {\n+                                kind: DefKind::StructVariant,\n+                                id,\n+                                span,\n+                                name,\n+                                qualname,\n+                                value,\n+                                parent,\n+                                children: vec![],\n+                                decl_id: None,\n+                                docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n+                                sig: sig::variant_signature(variant, &self.save_ctxt),\n+                                attributes: lower_attributes(\n+                                    variant.node.attrs.clone(),\n+                                    &self.save_ctxt,\n+                                ),\n+                            },\n+                        );\n                     }\n                 }\n                 ref v => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n                     let mut value = format!(\"{}::{}\", enum_data.name, name);\n                     if let &ast::VariantData::Tuple(ref fields, _) = v {\n                         value.push('(');\n-                        value.push_str(&fields.iter()\n-                                              .map(|f| ty_to_string(&f.ty))\n-                                              .collect::<Vec<_>>()\n-                                              .join(\", \"));\n+                        value.push_str(&fields\n+                            .iter()\n+                            .map(|f| ty_to_string(&f.ty))\n+                            .collect::<Vec<_>>()\n+                            .join(\", \"));\n                         value.push(')');\n                     }\n                     if !self.span.filter_generated(sub_span, variant.span) {\n@@ -647,21 +699,26 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         let id = ::id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n-                        self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n-                            kind: DefKind::TupleVariant,\n-                            id,\n-                            span,\n-                            name,\n-                            qualname,\n-                            value,\n-                            parent,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n-                            sig: sig::variant_signature(variant, &self.save_ctxt),\n-                            attributes: lower_attributes(variant.node.attrs.clone(),\n-                                                         &self.save_ctxt),\n-                        });\n+                        self.dumper.dump_def(\n+                            item.vis == ast::Visibility::Public,\n+                            Def {\n+                                kind: DefKind::TupleVariant,\n+                                id,\n+                                span,\n+                                name,\n+                                qualname,\n+                                value,\n+                                parent,\n+                                children: vec![],\n+                                decl_id: None,\n+                                docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n+                                sig: sig::variant_signature(variant, &self.save_ctxt),\n+                                attributes: lower_attributes(\n+                                    variant.node.attrs.clone(),\n+                                    &self.save_ctxt,\n+                                ),\n+                            },\n+                        );\n                     }\n                 }\n             }\n@@ -673,15 +730,18 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             }\n         }\n         self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n-        self.dumper.dump_def(item.vis == ast::Visibility::Public, enum_data);\n+        self.dumper\n+            .dump_def(item.vis == ast::Visibility::Public, enum_data);\n     }\n \n-    fn process_impl(&mut self,\n-                    item: &'l ast::Item,\n-                    type_parameters: &'l ast::Generics,\n-                    trait_ref: &'l Option<ast::TraitRef>,\n-                    typ: &'l ast::Ty,\n-                    impl_items: &'l [ast::ImplItem]) {\n+    fn process_impl(\n+        &mut self,\n+        item: &'l ast::Item,\n+        type_parameters: &'l ast::Generics,\n+        trait_ref: &'l Option<ast::TraitRef>,\n+        typ: &'l ast::Ty,\n+        impl_items: &'l [ast::ImplItem],\n+    ) {\n         if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(impl_data, RelationData, item.span);\n             self.dumper.dump_relation(impl_data);\n@@ -697,11 +757,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n-    fn process_trait(&mut self,\n-                     item: &'l ast::Item,\n-                     generics: &'l ast::Generics,\n-                     trait_refs: &'l ast::TyParamBounds,\n-                     methods: &'l [ast::TraitItem]) {\n+    fn process_trait(\n+        &mut self,\n+        item: &'l ast::Item,\n+        generics: &'l ast::Generics,\n+        trait_refs: &'l ast::TyParamBounds,\n+        methods: &'l [ast::TraitItem],\n+    ) {\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n         let mut val = name.clone();\n@@ -716,30 +778,33 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if !self.span.filter_generated(sub_span, item.span) {\n             let id = ::id_from_node_id(item.id, &self.save_ctxt);\n             let span = self.span_from_span(sub_span.expect(\"No span found for trait\"));\n-            let children =\n-                methods.iter().map(|i| ::id_from_node_id(i.id, &self.save_ctxt)).collect();\n-            self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n-                kind: DefKind::Trait,\n-                id,\n-                span,\n-                name,\n-                qualname: qualname.clone(),\n-                value: val,\n-                parent: None,\n-                children,\n-                decl_id: None,\n-                docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n-                sig: sig::item_signature(item, &self.save_ctxt),\n-                attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n-            });\n+            let children = methods\n+                .iter()\n+                .map(|i| ::id_from_node_id(i.id, &self.save_ctxt))\n+                .collect();\n+            self.dumper.dump_def(\n+                item.vis == ast::Visibility::Public,\n+                Def {\n+                    kind: DefKind::Trait,\n+                    id,\n+                    span,\n+                    name,\n+                    qualname: qualname.clone(),\n+                    value: val,\n+                    parent: None,\n+                    children,\n+                    decl_id: None,\n+                    docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n+                    sig: sig::item_signature(item, &self.save_ctxt),\n+                    attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+                },\n+            );\n         }\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n             let trait_ref = match *super_bound {\n-                ast::TraitTyParamBound(ref trait_ref, _) => {\n-                    trait_ref\n-                }\n+                ast::TraitTyParamBound(ref trait_ref, _) => trait_ref,\n                 ast::RegionTyParamBound(..) => {\n                     continue;\n                 }\n@@ -781,7 +846,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(item.vis == ast::Visibility::Public, mod_data);\n+            self.dumper\n+                .dump_def(item.vis == ast::Visibility::Public, mod_data);\n         }\n     }\n \n@@ -803,11 +869,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         for seg in &path.segments {\n             if let Some(ref params) = seg.parameters {\n                 match **params {\n-                    ast::PathParameters::AngleBracketed(ref data) => {\n-                        for t in &data.types {\n-                            self.visit_ty(t);\n-                        }\n-                    }\n+                    ast::PathParameters::AngleBracketed(ref data) => for t in &data.types {\n+                        self.visit_ty(t);\n+                    },\n                     ast::PathParameters::Parenthesized(ref data) => {\n                         for t in &data.inputs {\n                             self.visit_ty(t);\n@@ -845,12 +909,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n-    fn process_struct_lit(&mut self,\n-                          ex: &'l ast::Expr,\n-                          path: &'l ast::Path,\n-                          fields: &'l [ast::Field],\n-                          variant: &'l ty::VariantDef,\n-                          base: &'l Option<P<ast::Expr>>) {\n+    fn process_struct_lit(\n+        &mut self,\n+        ex: &'l ast::Expr,\n+        path: &'l ast::Path,\n+        fields: &'l [ast::Field],\n+        variant: &'l ty::VariantDef,\n+        base: &'l Option<P<ast::Expr>>,\n+    ) {\n         self.write_sub_paths_truncated(path);\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n@@ -860,8 +926,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             }\n \n             for field in fields {\n-                if let Some(field_data) = self.save_ctxt\n-                                              .get_field_ref_data(field, variant) {\n+                if let Some(field_data) = self.save_ctxt.get_field_ref_data(field, variant) {\n                     self.dumper.dump_ref(field_data);\n                 }\n \n@@ -872,10 +937,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         walk_list!(self, visit_expr, base);\n     }\n \n-    fn process_method_call(&mut self,\n-                           ex: &'l ast::Expr,\n-                           seg: &'l ast::PathSegment,\n-                           args: &'l [P<ast::Expr>]) {\n+    fn process_method_call(\n+        &mut self,\n+        ex: &'l ast::Expr,\n+        seg: &'l ast::PathSegment,\n+        args: &'l [P<ast::Expr>],\n+    ) {\n         debug!(\"process_method_call {:?} {:?}\", ex, ex.span);\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, RefData, ex.span);\n@@ -911,7 +978,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 };\n                 let variant = adt.variant_of_def(self.save_ctxt.get_path_def(p.id));\n \n-                for &Spanned { node: ref field, span } in fields {\n+                for &Spanned {\n+                    node: ref field,\n+                    span,\n+                } in fields\n+                {\n                     let sub_span = self.span.span_for_first_ident(span);\n                     if let Some(f) = variant.find_field_named(field.ident.name) {\n                         if !self.span.filter_generated(sub_span, span) {\n@@ -966,20 +1037,23 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 let id = ::id_from_node_id(id, &self.save_ctxt);\n                 let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n-                self.dumper.dump_def(false, Def {\n-                    kind: DefKind::Local,\n-                    id,\n-                    span,\n-                    name: i.to_string(),\n-                    qualname,\n-                    value: typ,\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: String::new(),\n-                    sig: None,\n-                    attributes:vec![],\n-                });\n+                self.dumper.dump_def(\n+                    false,\n+                    Def {\n+                        kind: DefKind::Local,\n+                        id,\n+                        span,\n+                        name: i.to_string(),\n+                        qualname,\n+                        value: typ,\n+                        parent: None,\n+                        children: vec![],\n+                        decl_id: None,\n+                        docs: String::new(),\n+                        sig: None,\n+                        attributes: vec![],\n+                    },\n+                );\n             }\n         }\n     }\n@@ -1030,52 +1104,62 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.process_macro_use(trait_item.span);\n         match trait_item.node {\n             ast::TraitItemKind::Const(ref ty, ref expr) => {\n-                self.process_assoc_const(trait_item.id,\n-                                         trait_item.ident.name,\n-                                         trait_item.span,\n-                                         &ty,\n-                                         expr.as_ref().map(|e| &**e),\n-                                         trait_id,\n-                                         ast::Visibility::Public,\n-                                         &trait_item.attrs);\n+                self.process_assoc_const(\n+                    trait_item.id,\n+                    trait_item.ident.name,\n+                    trait_item.span,\n+                    &ty,\n+                    expr.as_ref().map(|e| &**e),\n+                    trait_id,\n+                    ast::Visibility::Public,\n+                    &trait_item.attrs,\n+                );\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n-                self.process_method(sig,\n-                                    body.as_ref().map(|x| &**x),\n-                                    trait_item.id,\n-                                    trait_item.ident,\n-                                    &trait_item.generics,\n-                                    ast::Visibility::Public,\n-                                    trait_item.span);\n+                self.process_method(\n+                    sig,\n+                    body.as_ref().map(|x| &**x),\n+                    trait_item.id,\n+                    trait_item.ident,\n+                    &trait_item.generics,\n+                    ast::Visibility::Public,\n+                    trait_item.span,\n+                );\n             }\n             ast::TraitItemKind::Type(ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(trait_item.id));\n-                let sub_span = self.span.sub_span_after_keyword(trait_item.span, keywords::Type);\n+                let sub_span = self.span\n+                    .sub_span_after_keyword(trait_item.span, keywords::Type);\n \n                 if !self.span.filter_generated(sub_span, trait_item.span) {\n                     let span = self.span_from_span(sub_span.expect(\"No span found for assoc type\"));\n                     let id = ::id_from_node_id(trait_item.id, &self.save_ctxt);\n \n-                    self.dumper.dump_def(true, Def {\n-                        kind: DefKind::Type,\n-                        id,\n-                        span,\n-                        name,\n-                        qualname,\n-                        value: self.span.snippet(trait_item.span),\n-                        parent: Some(::id_from_def_id(trait_id)),\n-                        children: vec![],\n-                        decl_id: None,\n-                        docs: self.save_ctxt.docs_for_attrs(&trait_item.attrs),\n-                        sig: sig::assoc_type_signature(trait_item.id,\n-                                                       trait_item.ident,\n-                                                       Some(bounds),\n-                                                       default_ty.as_ref().map(|ty| &**ty),\n-                                                       &self.save_ctxt),\n-                        attributes: lower_attributes(trait_item.attrs.clone(), &self.save_ctxt),\n-                    });\n+                    self.dumper.dump_def(\n+                        true,\n+                        Def {\n+                            kind: DefKind::Type,\n+                            id,\n+                            span,\n+                            name,\n+                            qualname,\n+                            value: self.span.snippet(trait_item.span),\n+                            parent: Some(::id_from_def_id(trait_id)),\n+                            children: vec![],\n+                            decl_id: None,\n+                            docs: self.save_ctxt.docs_for_attrs(&trait_item.attrs),\n+                            sig: sig::assoc_type_signature(\n+                                trait_item.id,\n+                                trait_item.ident,\n+                                Some(bounds),\n+                                default_ty.as_ref().map(|ty| &**ty),\n+                                &self.save_ctxt,\n+                            ),\n+                            attributes: lower_attributes(trait_item.attrs.clone(), &self.save_ctxt),\n+                        },\n+                    );\n                 }\n \n                 if let &Some(ref default_ty) = default_ty {\n@@ -1090,23 +1174,27 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.process_macro_use(impl_item.span);\n         match impl_item.node {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.process_assoc_const(impl_item.id,\n-                                         impl_item.ident.name,\n-                                         impl_item.span,\n-                                         &ty,\n-                                         Some(expr),\n-                                         impl_id,\n-                                         impl_item.vis.clone(),\n-                                         &impl_item.attrs);\n+                self.process_assoc_const(\n+                    impl_item.id,\n+                    impl_item.ident.name,\n+                    impl_item.span,\n+                    &ty,\n+                    Some(expr),\n+                    impl_id,\n+                    impl_item.vis.clone(),\n+                    &impl_item.attrs,\n+                );\n             }\n             ast::ImplItemKind::Method(ref sig, ref body) => {\n-                self.process_method(sig,\n-                                    Some(body),\n-                                    impl_item.id,\n-                                    impl_item.ident,\n-                                    &impl_item.generics,\n-                                    impl_item.vis.clone(),\n-                                    impl_item.span);\n+                self.process_method(\n+                    sig,\n+                    Some(body),\n+                    impl_item.id,\n+                    impl_item.ident,\n+                    &impl_item.generics,\n+                    impl_item.vis.clone(),\n+                    impl_item.span,\n+                );\n             }\n             ast::ImplItemKind::Type(ref ty) => {\n                 // FIXME uses of the assoc type should ideally point to this\n@@ -1130,23 +1218,29 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         let cm = self.tcx.sess.codemap();\n         let filename = cm.span_to_filename(span);\n         let data_id = ::id_from_node_id(id, &self.save_ctxt);\n-        let children = m.items.iter().map(|i| ::id_from_node_id(i.id, &self.save_ctxt)).collect();\n+        let children = m.items\n+            .iter()\n+            .map(|i| ::id_from_node_id(i.id, &self.save_ctxt))\n+            .collect();\n         let span = self.span_from_span(span);\n \n-        self.dumper.dump_def(true, Def {\n-            kind: DefKind::Mod,\n-            id: data_id,\n-            name: String::new(),\n-            qualname,\n-            span,\n-            value: filename,\n-            children,\n-            parent: None,\n-            decl_id: None,\n-            docs: self.save_ctxt.docs_for_attrs(attrs),\n-            sig: None,\n-            attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n-        });\n+        self.dumper.dump_def(\n+            true,\n+            Def {\n+                kind: DefKind::Mod,\n+                id: data_id,\n+                name: String::new(),\n+                qualname,\n+                span,\n+                value: filename,\n+                children,\n+                parent: None,\n+                decl_id: None,\n+                docs: self.save_ctxt.docs_for_attrs(attrs),\n+                sig: None,\n+                attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n+            },\n+        );\n         self.nest_scope(id, |v| visit::walk_mod(v, m));\n     }\n \n@@ -1168,22 +1262,26 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n \n                         // 'use' always introduces an alias, if there is not an explicit\n                         // one, there is an implicit one.\n-                        let sub_span = match self.span.sub_span_after_keyword(use_item.span,\n-                                                                              keywords::As) {\n+                        let sub_span = match self.span\n+                            .sub_span_after_keyword(use_item.span, keywords::As)\n+                        {\n                             Some(sub_span) => Some(sub_span),\n                             None => sub_span,\n                         };\n \n                         if !self.span.filter_generated(sub_span, path.span) {\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span found for use\"));\n-                            self.dumper.import(item.vis == ast::Visibility::Public, Import {\n-                                kind: ImportKind::Use,\n-                                ref_id: mod_id.map(|id| ::id_from_def_id(id)),\n-                                span,\n-                                name: ident.to_string(),\n-                                value: String::new(),\n-                            });\n+                            self.dumper.import(\n+                                item.vis == ast::Visibility::Public,\n+                                Import {\n+                                    kind: ImportKind::Use,\n+                                    ref_id: mod_id.map(|id| ::id_from_def_id(id)),\n+                                    span,\n+                                    name: ident.to_string(),\n+                                    value: String::new(),\n+                                },\n+                            );\n                         }\n                         self.write_sub_paths_truncated(path);\n                     }\n@@ -1199,17 +1297,20 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         }\n \n                         let sub_span = self.span\n-                                           .sub_span_of_token(item.span, token::BinOp(token::Star));\n+                            .sub_span_of_token(item.span, token::BinOp(token::Star));\n                         if !self.span.filter_generated(sub_span, item.span) {\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n-                            self.dumper.import(item.vis == ast::Visibility::Public, Import {\n-                                kind: ImportKind::GlobUse,\n-                                ref_id: None,\n-                                span,\n-                                name: \"*\".to_owned(),\n-                                value: names.join(\", \"),\n-                            });\n+                            self.dumper.import(\n+                                item.vis == ast::Visibility::Public,\n+                                Import {\n+                                    kind: ImportKind::GlobUse,\n+                                    ref_id: None,\n+                                    span,\n+                                    name: \"*\".to_owned(),\n+                                    value: names.join(\", \"),\n+                                },\n+                            );\n                         }\n                         self.write_sub_paths(path);\n                     }\n@@ -1232,34 +1333,33 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 if !self.span.filter_generated(alias_span, item.span) {\n                     let span =\n                         self.span_from_span(alias_span.expect(\"No span found for extern crate\"));\n-                    self.dumper.import(false, Import {\n-                        kind: ImportKind::ExternCrate,\n-                        ref_id: None,\n-                        span,\n-                        name: item.ident.to_string(),\n-                        value: String::new(),\n-                    });\n+                    self.dumper.import(\n+                        false,\n+                        Import {\n+                            kind: ImportKind::ExternCrate,\n+                            ref_id: None,\n+                            span,\n+                            name: item.ident.to_string(),\n+                            value: String::new(),\n+                        },\n+                    );\n                 }\n             }\n-            Fn(ref decl, .., ref ty_params, ref body) =>\n-                self.process_fn(item, &decl, ty_params, &body),\n-            Static(ref typ, _, ref expr) =>\n-                self.process_static_or_const_item(item, typ, expr),\n-            Const(ref typ, ref expr) =>\n-                self.process_static_or_const_item(item, &typ, &expr),\n+            Fn(ref decl, .., ref ty_params, ref body) => {\n+                self.process_fn(item, &decl, ty_params, &body)\n+            }\n+            Static(ref typ, _, ref expr) => self.process_static_or_const_item(item, typ, expr),\n+            Const(ref typ, ref expr) => self.process_static_or_const_item(item, &typ, &expr),\n             Struct(ref def, ref ty_params) | Union(ref def, ref ty_params) => {\n                 self.process_struct(item, def, ty_params)\n             }\n             Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            Impl(..,\n-                 ref ty_params,\n-                 ref trait_ref,\n-                 ref typ,\n-                 ref impl_items) => {\n+            Impl(.., ref ty_params, ref trait_ref, ref typ, ref impl_items) => {\n                 self.process_impl(item, ty_params, trait_ref, &typ, impl_items)\n             }\n-            Trait(_, _, ref generics, ref trait_refs, ref methods) =>\n-                self.process_trait(item, generics, trait_refs, methods),\n+            Trait(_, _, ref generics, ref trait_refs, ref methods) => {\n+                self.process_trait(item, generics, trait_refs, methods)\n+            }\n             Mod(ref m) => {\n                 self.process_mod(item);\n                 self.nest_scope(item.id, |v| visit::walk_mod(v, m));\n@@ -1272,20 +1372,23 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     let span = self.span_from_span(sub_span.expect(\"No span found for typedef\"));\n                     let id = ::id_from_node_id(item.id, &self.save_ctxt);\n \n-                    self.dumper.dump_def(item.vis == ast::Visibility::Public, Def {\n-                        kind: DefKind::Type,\n-                        id,\n-                        span,\n-                        name: item.ident.to_string(),\n-                        qualname: qualname.clone(),\n-                        value,\n-                        parent: None,\n-                        children: vec![],\n-                        decl_id: None,\n-                        docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n-                        sig: sig::item_signature(item, &self.save_ctxt),\n-                        attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n-                    });\n+                    self.dumper.dump_def(\n+                        item.vis == ast::Visibility::Public,\n+                        Def {\n+                            kind: DefKind::Type,\n+                            id,\n+                            span,\n+                            name: item.ident.to_string(),\n+                            qualname: qualname.clone(),\n+                            value,\n+                            parent: None,\n+                            children: vec![],\n+                            decl_id: None,\n+                            docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n+                            sig: sig::item_signature(item, &self.save_ctxt),\n+                            attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+                        },\n+                    );\n                 }\n \n                 self.visit_ty(&ty);\n@@ -1372,8 +1475,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 let hir_node = match self.save_ctxt.tcx.hir.find(sub_ex.id) {\n                     Some(Node::NodeExpr(expr)) => expr,\n                     _ => {\n-                        debug!(\"Missing or weird node for sub-expression {} in {:?}\",\n-                               sub_ex.id, ex);\n+                        debug!(\n+                            \"Missing or weird node for sub-expression {} in {:?}\",\n+                            sub_ex.id,\n+                            ex\n+                        );\n                         return;\n                     }\n                 };\n@@ -1398,9 +1504,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         }\n                     }\n                     ty::TyTuple(..) => {}\n-                    _ => span_bug!(ex.span,\n-                                   \"Expected struct or tuple type, found {:?}\",\n-                                   ty),\n+                    _ => span_bug!(ex.span, \"Expected struct or tuple type, found {:?}\", ty),\n                 }\n             }\n             ast::ExprKind::Closure(_, ref decl, ref body, _fn_decl_span) => {\n@@ -1443,15 +1547,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             }\n             // In particular, we take this branch for call and path expressions,\n             // where we'll index the idents involved just by continuing to walk.\n-            _ => {\n-                visit::walk_expr(self, ex)\n-            }\n+            _ => visit::walk_expr(self, ex),\n         }\n     }\n \n     fn visit_mac(&mut self, mac: &'l ast::Mac) {\n         // These shouldn't exist in the AST at this point, log a span bug.\n-        span_bug!(mac.span, \"macro invocation should have been expanded out of AST\");\n+        span_bug!(\n+            mac.span,\n+            \"macro invocation should have been expanded out of AST\"\n+        );\n     }\n \n     fn visit_pat(&mut self, p: &'l ast::Pat) {\n@@ -1478,10 +1583,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     };\n                     let hir_id = self.tcx.hir.node_to_hir_id(id);\n                     let typ = self.save_ctxt\n-                                  .tables\n-                                  .node_id_to_type_opt(hir_id)\n-                                  .map(|t| t.to_string())\n-                                  .unwrap_or(String::new());\n+                        .tables\n+                        .node_id_to_type_opt(hir_id)\n+                        .map(|t| t.to_string())\n+                        .unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n \n@@ -1490,31 +1595,40 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         let id = ::id_from_node_id(id, &self.save_ctxt);\n                         let span = self.span_from_span(sp);\n \n-                        self.dumper.dump_def(false, Def {\n-                            kind: DefKind::Local,\n-                            id,\n-                            span,\n-                            name: i.to_string(),\n-                            qualname,\n-                            value: typ,\n-                            parent: None,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: String::new(),\n-                            sig: None,\n-                            attributes:vec![],\n-                        });\n+                        self.dumper.dump_def(\n+                            false,\n+                            Def {\n+                                kind: DefKind::Local,\n+                                id,\n+                                span,\n+                                name: i.to_string(),\n+                                qualname,\n+                                value: typ,\n+                                parent: None,\n+                                children: vec![],\n+                                decl_id: None,\n+                                docs: String::new(),\n+                                sig: None,\n+                                attributes: vec![],\n+                            },\n+                        );\n                     }\n                 }\n-                HirDef::StructCtor(..) | HirDef::VariantCtor(..) |\n-                HirDef::Const(..) | HirDef::AssociatedConst(..) |\n-                HirDef::Struct(..) | HirDef::Variant(..) |\n-                HirDef::TyAlias(..) | HirDef::AssociatedTy(..) |\n+                HirDef::StructCtor(..) |\n+                HirDef::VariantCtor(..) |\n+                HirDef::Const(..) |\n+                HirDef::AssociatedConst(..) |\n+                HirDef::Struct(..) |\n+                HirDef::Variant(..) |\n+                HirDef::TyAlias(..) |\n+                HirDef::AssociatedTy(..) |\n                 HirDef::SelfTy(..) => {\n                     self.dump_path_ref(id, &ast::Path::from_ident(sp, i));\n                 }\n-                def => error!(\"unexpected definition kind when processing collected idents: {:?}\",\n-                              def),\n+                def => error!(\n+                    \"unexpected definition kind when processing collected idents: {:?}\",\n+                    def\n+                ),\n             }\n         }\n \n@@ -1536,7 +1650,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n \n     fn visit_local(&mut self, l: &'l ast::Local) {\n         self.process_macro_use(l.span);\n-        let value = l.init.as_ref().map(|i| self.span.snippet(i.span)).unwrap_or(String::new());\n+        let value = l.init\n+            .as_ref()\n+            .map(|i| self.span.snippet(i.span))\n+            .unwrap_or(String::new());\n         self.process_var_decl(&l.pat, value);\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n@@ -1550,10 +1667,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(fn_data, DefData, item.span);\n \n-                    self.nest_tables(item.id, |v| v.process_formals(&decl.inputs,\n-                                                                    &fn_data.qualname));\n+                    self.nest_tables(\n+                        item.id,\n+                        |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n+                    );\n                     self.process_generic_params(generics, item.span, &fn_data.qualname, item.id);\n-                    self.dumper.dump_def(item.vis == ast::Visibility::Public, fn_data);\n+                    self.dumper\n+                        .dump_def(item.vis == ast::Visibility::Public, fn_data);\n                 }\n \n                 for arg in &decl.inputs {\n@@ -1567,15 +1687,17 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             ast::ForeignItemKind::Static(ref ty, _) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n+                    self.dumper\n+                        .dump_def(item.vis == ast::Visibility::Public, var_data);\n                 }\n \n                 self.visit_ty(ty);\n             }\n             ast::ForeignItemKind::Ty => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n+                    self.dumper\n+                        .dump_def(item.vis == ast::Visibility::Public, var_data);\n                 }\n             }\n         }"}, {"sha": "14b624b9338f6937775bad07dd425e11a4021bcc", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=b98290cb1f1cb22abda0dd97567d9aad95ae3078", "patch": "@@ -12,8 +12,8 @@ use std::io::Write;\n \n use rustc_serialize::json::as_json;\n \n-use rls_data::{self, Analysis, Import, Def, DefKind, Ref, RefKind, MacroRef,\n-               Relation, CratePreludeData};\n+use rls_data::{self, Analysis, CratePreludeData, Def, DefKind, Import, MacroRef, Ref, RefKind,\n+               Relation};\n use rls_data::config::Config;\n use rls_span::{Column, Row};\n \n@@ -54,15 +54,16 @@ impl<'b, W: Write> JsonDumper<WriteOutput<'b, W>> {\n         JsonDumper {\n             output: WriteOutput { output: writer },\n             config: config.clone(),\n-            result: Analysis::new(config)\n+            result: Analysis::new(config),\n         }\n     }\n }\n \n impl<'b> JsonDumper<CallbackOutput<'b>> {\n-    pub fn with_callback(callback: &'b mut FnMut(&Analysis),\n-                         config: Config)\n-                         -> JsonDumper<CallbackOutput<'b>> {\n+    pub fn with_callback(\n+        callback: &'b mut FnMut(&Analysis),\n+        config: Config,\n+    ) -> JsonDumper<CallbackOutput<'b>> {\n         JsonDumper {\n             output: CallbackOutput { callback: callback },\n             config: config.clone(),"}, {"sha": "fddafed11f3146f8ef40b4d429c1fe227baf0a99", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 241, "deletions": 175, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b98290cb1f1cb22abda0dd97567d9aad95ae3078", "patch": "@@ -9,20 +9,22 @@\n // except according to those terms.\n \n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n-\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n \n-#[macro_use] extern crate rustc;\n+#[macro_use]\n+extern crate rustc;\n \n-#[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+#[macro_use]\n+extern crate log;\n extern crate rustc_data_structures;\n extern crate rustc_serialize;\n extern crate rustc_typeck;\n+#[macro_use]\n+extern crate syntax;\n extern crate syntax_pos;\n \n extern crate rls_data;\n@@ -38,7 +40,7 @@ mod sig;\n use rustc::hir;\n use rustc::hir::def::Def as HirDef;\n use rustc::hir::map::{Node, NodeItem};\n-use rustc::hir::def_id::{LOCAL_CRATE, DefId};\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::config::CrateType::CrateTypeExecutable;\n use rustc::ty::{self, TyCtxt};\n use rustc_typeck::hir_ty_to_ty;\n@@ -48,22 +50,22 @@ use std::env;\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use syntax::ast::{self, NodeId, PatKind, Attribute};\n+use syntax::ast::{self, Attribute, NodeId, PatKind};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{ty_to_string, arg_to_string};\n+use syntax::print::pprust::{arg_to_string, ty_to_string};\n use syntax::codemap::MacroAttribute;\n use syntax_pos::*;\n \n use json_dumper::JsonDumper;\n use dump_visitor::DumpVisitor;\n use span_utils::SpanUtils;\n \n-use rls_data::{Ref, RefKind, SpanData, MacroRef, Def, DefKind, Relation, RelationKind,\n-               ExternalCrateData, GlobalCrateId};\n+use rls_data::{Def, DefKind, ExternalCrateData, GlobalCrateId, MacroRef, Ref, RefKind, Relation,\n+               RelationKind, SpanData};\n use rls_data::config::Config;\n \n \n@@ -84,7 +86,7 @@ pub enum Data {\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     fn span_from_span(&self, span: Span) -> SpanData {\n-        use rls_span::{Row, Column};\n+        use rls_span::{Column, Row};\n \n         let cm = self.tcx.sess.codemap();\n         let start = cm.lookup_char_pos(span.lo());\n@@ -119,8 +121,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 num: n.as_u32(),\n                 id: GlobalCrateId {\n                     name: self.tcx.crate_name(n).to_string(),\n-                    disambiguator: self.tcx.crate_disambiguator(n)\n-                                       .to_fingerprint().as_value(),\n+                    disambiguator: self.tcx.crate_disambiguator(n).to_fingerprint().as_value(),\n                 },\n             });\n         }\n@@ -132,7 +133,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n+                let sub_span = self.span_utils\n+                    .sub_span_after_keyword(item.span, keywords::Fn);\n                 filter!(self.span_utils, sub_span, item.span, None);\n \n                 Some(Data::DefData(Def {\n@@ -182,7 +184,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         match item.node {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n+                let sub_span = self.span_utils\n+                    .sub_span_after_keyword(item.span, keywords::Fn);\n                 filter!(self.span_utils, sub_span, item.span, None);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Function,\n@@ -230,7 +233,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ItemKind::Const(ref typ, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n+                let sub_span = self.span_utils\n+                    .sub_span_after_keyword(item.span, keywords::Const);\n                 filter!(self.span_utils, sub_span, item.span, None);\n \n                 let id = id_from_node_id(item.id, self);\n@@ -257,7 +261,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let cm = self.tcx.sess.codemap();\n                 let filename = cm.span_to_filename(m.inner);\n \n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Mod);\n+                let sub_span = self.span_utils\n+                    .sub_span_after_keyword(item.span, keywords::Mod);\n                 filter!(self.span_utils, sub_span, item.span, None);\n \n                 Some(Data::DefData(Def {\n@@ -268,7 +273,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(sub_span.unwrap()),\n                     value: filename,\n                     parent: None,\n-                    children: m.items.iter().map(|i| id_from_node_id(i.id, self)).collect(),\n+                    children: m.items\n+                        .iter()\n+                        .map(|i| id_from_node_id(i.id, self))\n+                        .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n@@ -278,12 +286,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ItemKind::Enum(ref def, _) => {\n                 let name = item.ident.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n+                let sub_span = self.span_utils\n+                    .sub_span_after_keyword(item.span, keywords::Enum);\n                 filter!(self.span_utils, sub_span, item.span, None);\n-                let variants_str = def.variants.iter()\n-                                      .map(|v| v.node.name.to_string())\n-                                      .collect::<Vec<_>>()\n-                                      .join(\", \");\n+                let variants_str = def.variants\n+                    .iter()\n+                    .map(|v| v.node.name.to_string())\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n                 let value = format!(\"{}::{{{}}}\", name, variants_str);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n@@ -294,9 +304,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     value,\n                     parent: None,\n                     children: def.variants\n-                                 .iter()\n-                                 .map(|v| id_from_node_id(v.node.data.id(), self))\n-                                 .collect(),\n+                        .iter()\n+                        .map(|v| id_from_node_id(v.node.data.id(), self))\n+                        .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n@@ -313,15 +323,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     filter!(self.span_utils, sub_span, typ.span, None);\n \n                     let type_data = self.lookup_ref_id(typ.id);\n-                    type_data.map(|type_data| Data::RelationData(Relation {\n-                        kind: RelationKind::Impl,\n-                        span: self.span_from_span(sub_span.unwrap()),\n-                        from: id_from_def_id(type_data),\n-                        to: trait_ref.as_ref()\n-                                     .and_then(|t| self.lookup_ref_id(t.ref_id))\n-                                     .map(id_from_def_id)\n-                                     .unwrap_or(null_id()),\n-                    }))\n+                    type_data.map(|type_data| {\n+                        Data::RelationData(Relation {\n+                            kind: RelationKind::Impl,\n+                            span: self.span_from_span(sub_span.unwrap()),\n+                            from: id_from_def_id(type_data),\n+                            to: trait_ref\n+                                .as_ref()\n+                                .and_then(|t| self.lookup_ref_id(t.ref_id))\n+                                .map(id_from_def_id)\n+                                .unwrap_or(null_id()),\n+                        })\n+                    })\n                 } else {\n                     None\n                 }\n@@ -333,14 +346,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_field_data(&self,\n-                          field: &ast::StructField,\n-                          scope: NodeId)\n-                          -> Option<Def> {\n+    pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<Def> {\n         if let Some(ident) = field.ident {\n             let name = ident.to_string();\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n+            let sub_span = self.span_utils\n+                .sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             let def_id = self.tcx.hir.local_def_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n@@ -370,18 +381,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self,\n-                           id: ast::NodeId,\n-                           name: ast::Name,\n-                           span: Span)\n-                           -> Option<Def> {\n+    pub fn get_method_data(&self, id: ast::NodeId, name: ast::Name, span: Span) -> Option<Def> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n-          match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n-            Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n-                Some(Node::NodeItem(item)) => {\n-                    match item.node {\n+            match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n+                Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n+                    Some(Node::NodeItem(item)) => match item.node {\n                         hir::ItemImpl(.., ref ty, _) => {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n@@ -391,7 +397,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             if let Some(def_id) = trait_id {\n                                 result.push_str(\" as \");\n                                 result.push_str(&self.tcx.item_path_str(def_id));\n-                                self.tcx.associated_items(def_id)\n+                                self.tcx\n+                                    .associated_items(def_id)\n                                     .find(|item| item.name == name)\n                                     .map(|item| decl_id = Some(item.def_id));\n                             } else {\n@@ -403,53 +410,61 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             }\n                             result.push_str(\">\");\n \n-                            (result, trait_id, decl_id,\n-                             self.docs_for_attrs(&item.attrs),\n-                             item.attrs.to_vec())\n+                            (\n+                                result,\n+                                trait_id,\n+                                decl_id,\n+                                self.docs_for_attrs(&item.attrs),\n+                                item.attrs.to_vec(),\n+                            )\n                         }\n                         _ => {\n-                            span_bug!(span,\n-                                      \"Container {:?} for method {} not an impl?\",\n-                                      impl_id,\n-                                      id);\n+                            span_bug!(\n+                                span,\n+                                \"Container {:?} for method {} not an impl?\",\n+                                impl_id,\n+                                id\n+                            );\n                         }\n+                    },\n+                    r => {\n+                        span_bug!(\n+                            span,\n+                            \"Container {:?} for method {} is not a node item {:?}\",\n+                            impl_id,\n+                            id,\n+                            r\n+                        );\n                     }\n-                }\n-                r => {\n-                    span_bug!(span,\n-                              \"Container {:?} for method {} is not a node item {:?}\",\n-                              impl_id,\n-                              id,\n-                              r);\n-                }\n-            },\n-            None => match self.tcx.trait_of_item(self.tcx.hir.local_def_id(id)) {\n-                Some(def_id) => {\n-                    match self.tcx.hir.get_if_local(def_id) {\n-                        Some(Node::NodeItem(item)) => {\n-                            (format!(\"::{}\", self.tcx.item_path_str(def_id)),\n-                             Some(def_id), None,\n-                             self.docs_for_attrs(&item.attrs),\n-                             item.attrs.to_vec())\n-                        }\n+                },\n+                None => match self.tcx.trait_of_item(self.tcx.hir.local_def_id(id)) {\n+                    Some(def_id) => match self.tcx.hir.get_if_local(def_id) {\n+                        Some(Node::NodeItem(item)) => (\n+                            format!(\"::{}\", self.tcx.item_path_str(def_id)),\n+                            Some(def_id),\n+                            None,\n+                            self.docs_for_attrs(&item.attrs),\n+                            item.attrs.to_vec(),\n+                        ),\n                         r => {\n-                            span_bug!(span,\n-                                      \"Could not find container {:?} for \\\n-                                       method {}, got {:?}\",\n-                                      def_id,\n-                                      id,\n-                                      r);\n+                            span_bug!(\n+                                span,\n+                                \"Could not find container {:?} for \\\n+                                 method {}, got {:?}\",\n+                                def_id,\n+                                id,\n+                                r\n+                            );\n                         }\n+                    },\n+                    None => {\n+                        debug!(\"Could not find container for method {} at {:?}\", id, span);\n+                        // This is not necessarily a bug, if there was a compilation error,\n+                        // the tables we need might not exist.\n+                        return None;\n                     }\n-                }\n-                None => {\n-                    debug!(\"Could not find container for method {} at {:?}\", id, span);\n-                    // This is not necessarily a bug, if there was a compilation error, the tables\n-                    // we need might not exist.\n-                    return None;\n-                }\n-            },\n-        };\n+                },\n+            };\n \n         let qualname = format!(\"{}::{}\", qualname, name);\n \n@@ -473,9 +488,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         })\n     }\n \n-    pub fn get_trait_ref_data(&self,\n-                              trait_ref: &ast::TraitRef)\n-                              -> Option<Ref> {\n+    pub fn get_trait_ref_data(&self, trait_ref: &ast::TraitRef) -> Option<Ref> {\n         self.lookup_ref_id(trait_ref.ref_id).and_then(|def_id| {\n             let span = trait_ref.path.span;\n             if generated_code(span) {\n@@ -503,8 +516,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let hir_node = match self.tcx.hir.find(sub_ex.id) {\n                     Some(Node::NodeExpr(expr)) => expr,\n                     _ => {\n-                        debug!(\"Missing or weird node for sub-expression {} in {:?}\",\n-                               sub_ex.id, expr);\n+                        debug!(\n+                            \"Missing or weird node for sub-expression {} in {:?}\",\n+                            sub_ex.id,\n+                            expr\n+                        );\n                         return None;\n                     }\n                 };\n@@ -565,7 +581,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 Some(Data::RefData(Ref {\n                     kind: RefKind::Function,\n                     span,\n-                    ref_id: def_id.or(decl_id).map(|id| id_from_def_id(id)).unwrap_or(null_id()),\n+                    ref_id: def_id\n+                        .or(decl_id)\n+                        .map(|id| id_from_def_id(id))\n+                        .unwrap_or(null_id()),\n                 }))\n             }\n             ast::ExprKind::Path(_, ref path) => {\n@@ -582,40 +601,61 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         match self.tcx.hir.get(id) {\n             Node::NodeTraitRef(tr) => tr.path.def,\n \n-            Node::NodeItem(&hir::Item { node: hir::ItemUse(ref path, _), .. }) |\n+            Node::NodeItem(&hir::Item {\n+                node: hir::ItemUse(ref path, _),\n+                ..\n+            }) |\n             Node::NodeVisibility(&hir::Visibility::Restricted { ref path, .. }) => path.def,\n \n-            Node::NodeExpr(&hir::Expr { node: hir::ExprStruct(ref qpath, ..), .. }) |\n-            Node::NodeExpr(&hir::Expr { node: hir::ExprPath(ref qpath), .. }) |\n-            Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n-            Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n-            Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n+            Node::NodeExpr(&hir::Expr {\n+                node: hir::ExprStruct(ref qpath, ..),\n+                ..\n+            }) |\n+            Node::NodeExpr(&hir::Expr {\n+                node: hir::ExprPath(ref qpath),\n+                ..\n+            }) |\n+            Node::NodePat(&hir::Pat {\n+                node: hir::PatKind::Path(ref qpath),\n+                ..\n+            }) |\n+            Node::NodePat(&hir::Pat {\n+                node: hir::PatKind::Struct(ref qpath, ..),\n+                ..\n+            }) |\n+            Node::NodePat(&hir::Pat {\n+                node: hir::PatKind::TupleStruct(ref qpath, ..),\n+                ..\n+            }) => {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 self.tables.qpath_def(qpath, hir_id)\n             }\n \n             Node::NodeBinding(&hir::Pat {\n-                node: hir::PatKind::Binding(_, canonical_id, ..), ..\n+                node: hir::PatKind::Binding(_, canonical_id, ..),\n+                ..\n             }) => HirDef::Local(canonical_id),\n \n-            Node::NodeTy(ty) => {\n-                if let hir::Ty { node: hir::TyPath(ref qpath), .. } = *ty {\n-                    match *qpath {\n-                        hir::QPath::Resolved(_, ref path) => path.def,\n-                        hir::QPath::TypeRelative(..) => {\n-                            let ty = hir_ty_to_ty(self.tcx, ty);\n-                            if let ty::TyProjection(proj) = ty.sty {\n-                                return HirDef::AssociatedTy(proj.item_def_id);\n-                            }\n-                            HirDef::Err\n+            Node::NodeTy(ty) => if let hir::Ty {\n+                node: hir::TyPath(ref qpath),\n+                ..\n+            } = *ty\n+            {\n+                match *qpath {\n+                    hir::QPath::Resolved(_, ref path) => path.def,\n+                    hir::QPath::TypeRelative(..) => {\n+                        let ty = hir_ty_to_ty(self.tcx, ty);\n+                        if let ty::TyProjection(proj) = ty.sty {\n+                            return HirDef::AssociatedTy(proj.item_def_id);\n                         }\n+                        HirDef::Err\n                     }\n-                } else {\n-                    HirDef::Err\n                 }\n-            }\n+            } else {\n+                HirDef::Err\n+            },\n \n-            _ => HirDef::Err\n+            _ => HirDef::Err,\n         }\n     }\n \n@@ -642,8 +682,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let sub_span = last_seg.span;\n         filter!(self.span_utils, Some(sub_span), path.span, None);\n         match def {\n-            HirDef::Upvar(id, ..) |\n-            HirDef::Local(id) => {\n+            HirDef::Upvar(id, ..) | HirDef::Local(id) => {\n                 let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n@@ -666,10 +705,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 // Function type bounds are desugared in the parser, so we have to\n                 // special case them here.\n                 let fn_span = self.span_utils.span_for_first_ident(path.span);\n-                fn_span.map(|span| Ref {\n-                    kind: RefKind::Type,\n-                    span: self.span_from_span(span),\n-                    ref_id: id_from_def_id(def_id),\n+                fn_span.map(|span| {\n+                    Ref {\n+                        kind: RefKind::Type,\n+                        span: self.span_from_span(span),\n+                        ref_id: id_from_def_id(def_id),\n+                    }\n                 })\n             }\n             HirDef::Struct(def_id) |\n@@ -703,7 +744,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Method(decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n-                    self.tcx.associated_items(ti.container.id())\n+                    self.tcx\n+                        .associated_items(ti.container.id())\n                         .find(|item| item.name == ti.name && item.defaultness.has_value())\n                         .map(|item| item.def_id)\n                 } else {\n@@ -741,10 +783,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_field_ref_data(&self,\n-                              field_ref: &ast::Field,\n-                              variant: &ty::VariantDef)\n-                              -> Option<Ref> {\n+    pub fn get_field_ref_data(\n+        &self,\n+        field_ref: &ast::Field,\n+        variant: &ty::VariantDef,\n+    ) -> Option<Ref> {\n         let f = variant.field_named(field_ref.ident.node.name);\n         // We don't really need a sub-span here, but no harm done\n         let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n@@ -782,7 +825,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         // If the callee is an imported macro from an external crate, need to get\n         // the source span and name from the session, as their spans are localized\n         // when read in, and no longer correspond to the source.\n-        if let Some(mac) = self.tcx.sess.imported_macro_spans.borrow().get(&callee_span) {\n+        if let Some(mac) = self.tcx\n+            .sess\n+            .imported_macro_spans\n+            .borrow()\n+            .get(&callee_span)\n+        {\n             let &(ref mac_name, mac_span) = mac;\n             let mac_span = self.span_from_span(mac_span);\n             return Some(MacroRef {\n@@ -837,21 +885,29 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     let mut sig = \"fn \".to_owned();\n     if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n         sig.push('<');\n-        sig.push_str(&generics.lifetimes.iter()\n-                              .map(|l| l.lifetime.ident.name.to_string())\n-                              .collect::<Vec<_>>()\n-                              .join(\", \"));\n+        sig.push_str(&generics\n+            .lifetimes\n+            .iter()\n+            .map(|l| l.lifetime.ident.name.to_string())\n+            .collect::<Vec<_>>()\n+            .join(\", \"));\n         if !generics.lifetimes.is_empty() {\n             sig.push_str(\", \");\n         }\n-        sig.push_str(&generics.ty_params.iter()\n-                              .map(|l| l.ident.to_string())\n-                              .collect::<Vec<_>>()\n-                              .join(\", \"));\n+        sig.push_str(&generics\n+            .ty_params\n+            .iter()\n+            .map(|l| l.ident.to_string())\n+            .collect::<Vec<_>>()\n+            .join(\", \"));\n         sig.push_str(\"> \");\n     }\n     sig.push('(');\n-    sig.push_str(&decl.inputs.iter().map(arg_to_string).collect::<Vec<_>>().join(\", \"));\n+    sig.push_str(&decl.inputs\n+        .iter()\n+        .map(arg_to_string)\n+        .collect::<Vec<_>>()\n+        .join(\", \"));\n     sig.push(')');\n     match decl.output {\n         ast::FunctionRetTy::Default(_) => sig.push_str(\" -> ()\"),\n@@ -883,23 +939,25 @@ impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n             PatKind::Struct(ref path, ..) => {\n                 self.collected_paths.push((p.id, path));\n             }\n-            PatKind::TupleStruct(ref path, ..) |\n-            PatKind::Path(_, ref path) => {\n+            PatKind::TupleStruct(ref path, ..) | PatKind::Path(_, ref path) => {\n                 self.collected_paths.push((p.id, path));\n             }\n             PatKind::Ident(bm, ref path1, _) => {\n-                debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n-                       path1.node,\n-                       p.span,\n-                       path1.span);\n+                debug!(\n+                    \"PathCollector, visit ident in pat {}: {:?} {:?}\",\n+                    path1.node,\n+                    p.span,\n+                    path1.span\n+                );\n                 let immut = match bm {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n                     // is still worthwhile.\n                     ast::BindingMode::ByRef(_) => ast::Mutability::Immutable,\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n-                self.collected_idents.push((p.id, path1.node, path1.span, immut));\n+                self.collected_idents\n+                    .push((p.id, path1.node, path1.span, immut));\n             }\n             _ => {}\n         }\n@@ -909,23 +967,25 @@ impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n \n /// Defines what to do with the results of saving the analysis.\n pub trait SaveHandler {\n-    fn save<'l, 'tcx>(&mut self,\n-                      save_ctxt: SaveContext<'l, 'tcx>,\n-                      krate: &ast::Crate,\n-                      cratename: &str);\n+    fn save<'l, 'tcx>(\n+        &mut self,\n+        save_ctxt: SaveContext<'l, 'tcx>,\n+        krate: &ast::Crate,\n+        cratename: &str,\n+    );\n }\n \n /// Dump the save-analysis results to a file.\n pub struct DumpHandler<'a> {\n     odir: Option<&'a Path>,\n-    cratename: String\n+    cratename: String,\n }\n \n impl<'a> DumpHandler<'a> {\n     pub fn new(odir: Option<&'a Path>, cratename: &str) -> DumpHandler<'a> {\n         DumpHandler {\n             odir,\n-            cratename: cratename.to_owned()\n+            cratename: cratename.to_owned(),\n         }\n     }\n \n@@ -943,8 +1003,10 @@ impl<'a> DumpHandler<'a> {\n                     error!(\"Could not create directory {}: {}\", root_path.display(), e);\n                 }\n \n-                let executable =\n-                    sess.crate_types.borrow().iter().any(|ct| *ct == CrateTypeExecutable);\n+                let executable = sess.crate_types\n+                    .borrow()\n+                    .iter()\n+                    .any(|ct| *ct == CrateTypeExecutable);\n                 let mut out_name = if executable {\n                     \"\".to_owned()\n                 } else {\n@@ -961,19 +1023,21 @@ impl<'a> DumpHandler<'a> {\n \n         info!(\"Writing output to {}\", file_name.display());\n \n-        let output_file = File::create(&file_name).unwrap_or_else(|e| {\n-            sess.fatal(&format!(\"Could not open {}: {}\", file_name.display(), e))\n-        });\n+        let output_file = File::create(&file_name).unwrap_or_else(\n+            |e| sess.fatal(&format!(\"Could not open {}: {}\", file_name.display(), e)),\n+        );\n \n         output_file\n     }\n }\n \n impl<'a> SaveHandler for DumpHandler<'a> {\n-    fn save<'l, 'tcx>(&mut self,\n-                      save_ctxt: SaveContext<'l, 'tcx>,\n-                      krate: &ast::Crate,\n-                      cratename: &str) {\n+    fn save<'l, 'tcx>(\n+        &mut self,\n+        save_ctxt: SaveContext<'l, 'tcx>,\n+        krate: &ast::Crate,\n+        cratename: &str,\n+    ) {\n         let output = &mut self.output_file(&save_ctxt);\n         let mut dumper = JsonDumper::new(output, save_ctxt.config.clone());\n         let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n@@ -989,10 +1053,12 @@ pub struct CallbackHandler<'b> {\n }\n \n impl<'b> SaveHandler for CallbackHandler<'b> {\n-    fn save<'l, 'tcx>(&mut self,\n-                      save_ctxt: SaveContext<'l, 'tcx>,\n-                      krate: &ast::Crate,\n-                      cratename: &str) {\n+    fn save<'l, 'tcx>(\n+        &mut self,\n+        save_ctxt: SaveContext<'l, 'tcx>,\n+        krate: &ast::Crate,\n+        cratename: &str,\n+    ) {\n         // We're using the JsonDumper here because it has the format of the\n         // save-analysis results that we will pass to the callback. IOW, we are\n         // using the JsonDumper to collect the save-analysis results, but not\n@@ -1006,12 +1072,14 @@ impl<'b> SaveHandler for CallbackHandler<'b> {\n     }\n }\n \n-pub fn process_crate<'l, 'tcx, H: SaveHandler>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-                                               krate: &ast::Crate,\n-                                               analysis: &'l ty::CrateAnalysis,\n-                                               cratename: &str,\n-                                               config: Option<Config>,\n-                                               mut handler: H) {\n+pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n+    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    krate: &ast::Crate,\n+    analysis: &'l ty::CrateAnalysis,\n+    cratename: &str,\n+    config: Option<Config>,\n+    mut handler: H,\n+) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     assert!(analysis.glob_map.is_some());\n@@ -1034,10 +1102,8 @@ fn find_config(supplied: Option<Config>) -> Config {\n         return config;\n     }\n     match env::var_os(\"RUST_SAVE_ANALYSIS_CONFIG\") {\n-        Some(config_string) => {\n-            rustc_serialize::json::decode(config_string.to_str().unwrap())\n-                .expect(\"Could not deserialize save-analysis config\")\n-        },\n+        Some(config_string) => rustc_serialize::json::decode(config_string.to_str().unwrap())\n+            .expect(\"Could not deserialize save-analysis config\"),\n         None => Config::default(),\n     }\n }"}, {"sha": "b244876226c484a71ea789880070da50fdcf3ec9", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 152, "deletions": 173, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=b98290cb1f1cb22abda0dd97567d9aad95ae3078", "patch": "@@ -35,9 +35,9 @@\n //\n // FIXME where clauses need implementing, defs/refs in generics are mostly missing.\n \n-use {SaveContext, id_from_def_id, id_from_node_id};\n+use {id_from_def_id, id_from_node_id, SaveContext};\n \n-use rls_data::{Signature, SigElement};\n+use rls_data::{SigElement, Signature};\n \n use rustc::hir::def::Def;\n use syntax::ast::{self, NodeId};\n@@ -75,36 +75,39 @@ pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext) -> Option<Si\n     variant.node.make(0, None, scx).ok()\n }\n \n-pub fn method_signature(id: NodeId,\n-                        ident: ast::Ident,\n-                        generics: &ast::Generics,\n-                        m: &ast::MethodSig,\n-                        scx: &SaveContext)\n-                        -> Option<Signature> {\n+pub fn method_signature(\n+    id: NodeId,\n+    ident: ast::Ident,\n+    generics: &ast::Generics,\n+    m: &ast::MethodSig,\n+    scx: &SaveContext,\n+) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n     make_method_signature(id, ident, generics, m, scx).ok()\n }\n \n-pub fn assoc_const_signature(id: NodeId,\n-                             ident: ast::Name,\n-                             ty: &ast::Ty,\n-                             default: Option<&ast::Expr>,\n-                             scx: &SaveContext)\n-                             -> Option<Signature> {\n+pub fn assoc_const_signature(\n+    id: NodeId,\n+    ident: ast::Name,\n+    ty: &ast::Ty,\n+    default: Option<&ast::Expr>,\n+    scx: &SaveContext,\n+) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n     make_assoc_const_signature(id, ident, ty, default, scx).ok()\n }\n \n-pub fn assoc_type_signature(id: NodeId,\n-                            ident: ast::Ident,\n-                            bounds: Option<&ast::TyParamBounds>,\n-                            default: Option<&ast::Ty>,\n-                            scx: &SaveContext)\n-                            -> Option<Signature> {\n+pub fn assoc_type_signature(\n+    id: NodeId,\n+    ident: ast::Ident,\n+    bounds: Option<&ast::TyParamBounds>,\n+    default: Option<&ast::Ty>,\n+    scx: &SaveContext,\n+) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n@@ -117,11 +120,12 @@ trait Sig {\n     fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext) -> Result;\n }\n \n-fn extend_sig(mut sig: Signature,\n-              text: String,\n-              defs: Vec<SigElement>,\n-              refs: Vec<SigElement>)\n-              -> Signature {\n+fn extend_sig(\n+    mut sig: Signature,\n+    text: String,\n+    defs: Vec<SigElement>,\n+    refs: Vec<SigElement>,\n+) -> Signature {\n     sig.text = text;\n     sig.defs.extend(defs.into_iter());\n     sig.refs.extend(refs.into_iter());\n@@ -142,8 +146,12 @@ fn merge_sigs(text: String, sigs: Vec<Signature>) -> Signature {\n \n     let (defs, refs): (Vec<_>, Vec<_>) = sigs.into_iter().map(|s| (s.defs, s.refs)).unzip();\n \n-    result.defs.extend(defs.into_iter().flat_map(|ds| ds.into_iter()));\n-    result.refs.extend(refs.into_iter().flat_map(|rs| rs.into_iter()));\n+    result\n+        .defs\n+        .extend(defs.into_iter().flat_map(|ds| ds.into_iter()));\n+    result\n+        .refs\n+        .extend(refs.into_iter().flat_map(|rs| rs.into_iter()));\n \n     result\n }\n@@ -188,9 +196,7 @@ impl Sig for ast::Ty {\n                 let text = format!(\"{}{}\", prefix, nested.text);\n                 Ok(replace_text(nested, text))\n             }\n-            ast::TyKind::Never => {\n-                Ok(text_sig(\"!\".to_owned()))\n-            },\n+            ast::TyKind::Never => Ok(text_sig(\"!\".to_owned())),\n             ast::TyKind::Tup(ref ts) => {\n                 let mut text = \"(\".to_owned();\n                 let mut defs = vec![];\n@@ -215,8 +221,11 @@ impl Sig for ast::Ty {\n                 if !f.lifetimes.is_empty() {\n                     // FIXME defs, bounds on lifetimes\n                     text.push_str(\"for<\");\n-                    text.push_str(&f.lifetimes.iter().map(|l|\n-                        l.lifetime.ident.to_string()).collect::<Vec<_>>().join(\", \"));\n+                    text.push_str(&f.lifetimes\n+                        .iter()\n+                        .map(|l| l.lifetime.ident.to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \"));\n                     text.push('>');\n                 }\n \n@@ -251,9 +260,7 @@ impl Sig for ast::Ty {\n \n                 Ok(Signature { text, defs, refs })\n             }\n-            ast::TyKind::Path(None, ref path) => {\n-                path.make(offset, id, scx)\n-            }\n+            ast::TyKind::Path(None, ref path) => path.make(offset, id, scx),\n             ast::TyKind::Path(Some(ref qself), ref path) => {\n                 let nested_ty = qself.ty.make(offset + 1, id, scx)?;\n                 let prefix = if qself.position == 0 {\n@@ -325,11 +332,13 @@ impl Sig for ast::Item {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n+                let defs = vec![\n+                    SigElement {\n+                        id: id_from_node_id(self.id, scx),\n+                        start: offset + text.len(),\n+                        end: offset + text.len() + name.len(),\n+                    },\n+                ];\n                 text.push_str(&name);\n                 text.push_str(\": \");\n \n@@ -346,11 +355,13 @@ impl Sig for ast::Item {\n             ast::ItemKind::Const(ref ty, ref expr) => {\n                 let mut text = \"const \".to_owned();\n                 let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n+                let defs = vec![\n+                    SigElement {\n+                        id: id_from_node_id(self.id, scx),\n+                        start: offset + text.len(),\n+                        end: offset + text.len() + name.len(),\n+                    },\n+                ];\n                 text.push_str(&name);\n                 text.push_str(\": \");\n \n@@ -379,12 +390,7 @@ impl Sig for ast::Item {\n                 }\n                 text.push_str(\"fn \");\n \n-                let mut sig = name_and_generics(text,\n-                                                offset,\n-                                                generics,\n-                                                self.id,\n-                                                self.ident,\n-                                                scx)?;\n+                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n \n                 sig.text.push('(');\n                 for i in &decl.inputs {\n@@ -413,11 +419,13 @@ impl Sig for ast::Item {\n             ast::ItemKind::Mod(ref _mod) => {\n                 let mut text = \"mod \".to_owned();\n                 let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n+                let defs = vec![\n+                    SigElement {\n+                        id: id_from_node_id(self.id, scx),\n+                        start: offset + text.len(),\n+                        end: offset + text.len() + name.len(),\n+                    },\n+                ];\n                 text.push_str(&name);\n                 // Could be either `mod foo;` or `mod foo { ... }`, but we'll just puck one.\n                 text.push(';');\n@@ -430,12 +438,7 @@ impl Sig for ast::Item {\n             }\n             ast::ItemKind::Ty(ref ty, ref generics) => {\n                 let text = \"type \".to_owned();\n-                let mut sig = name_and_generics(text,\n-                                                offset,\n-                                                generics,\n-                                                self.id,\n-                                                self.ident,\n-                                                scx)?;\n+                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n \n                 sig.text.push_str(\" = \");\n                 let ty = ty.make(offset + sig.text.len(), id, scx)?;\n@@ -446,34 +449,19 @@ impl Sig for ast::Item {\n             }\n             ast::ItemKind::Enum(_, ref generics) => {\n                 let text = \"enum \".to_owned();\n-                let mut sig = name_and_generics(text,\n-                                                offset,\n-                                                generics,\n-                                                self.id,\n-                                                self.ident,\n-                                                scx)?;\n+                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             ast::ItemKind::Struct(_, ref generics) => {\n                 let text = \"struct \".to_owned();\n-                let mut sig = name_and_generics(text,\n-                                                offset,\n-                                                generics,\n-                                                self.id,\n-                                                self.ident,\n-                                                scx)?;\n+                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             ast::ItemKind::Union(_, ref generics) => {\n                 let text = \"union \".to_owned();\n-                let mut sig = name_and_generics(text,\n-                                                offset,\n-                                                generics,\n-                                                self.id,\n-                                                self.ident,\n-                                                scx)?;\n+                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n@@ -488,12 +476,7 @@ impl Sig for ast::Item {\n                     text.push_str(\"unsafe \");\n                 }\n                 text.push_str(\"trait \");\n-                let mut sig = name_and_generics(text,\n-                                                offset,\n-                                                generics,\n-                                                self.id,\n-                                                self.ident,\n-                                                scx)?;\n+                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\": \");\n@@ -515,13 +498,15 @@ impl Sig for ast::Item {\n                 text.push_str(\" for .. {}\");\n                 Ok(replace_text(trait_sig, text))\n             }\n-            ast::ItemKind::Impl(unsafety,\n-                                polarity,\n-                                defaultness,\n-                                ref generics,\n-                                ref opt_trait,\n-                                ref ty,\n-                                _) => {\n+            ast::ItemKind::Impl(\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                ref generics,\n+                ref opt_trait,\n+                ref ty,\n+                _,\n+            ) => {\n                 let mut text = String::new();\n                 if let ast::Defaultness::Default = defaultness {\n                     text.push_str(\"default \");\n@@ -562,8 +547,7 @@ impl Sig for ast::Item {\n             ast::ItemKind::ExternCrate(_) => Err(\"extern crate\"),\n             // FIXME should implement this (e.g., pub use).\n             ast::ItemKind::Use(_) => Err(\"import\"),\n-            ast::ItemKind::Mac(..) |\n-            ast::ItemKind::MacroDef(_) => Err(\"Macro\"),\n+            ast::ItemKind::Mac(..) | ast::ItemKind::MacroDef(_) => Err(\"Macro\"),\n         }\n     }\n }\n@@ -573,19 +557,14 @@ impl Sig for ast::Path {\n         let def = scx.get_path_def(id.ok_or(\"Missing id for Path\")?);\n \n         let (name, start, end) = match def {\n-            Def::Label(..)  |\n-            Def::PrimTy(..) |\n-            Def::SelfTy(..) |\n-            Def::Err => {\n+            Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {\n                 return Ok(Signature {\n                     text: pprust::path_to_string(self),\n                     defs: vec![],\n                     refs: vec![],\n                 })\n             }\n-            Def::AssociatedConst(..) |\n-            Def::Variant(..) |\n-            Def::VariantCtor(..) => {\n+            Def::AssociatedConst(..) | Def::Variant(..) | Def::VariantCtor(..) => {\n                 let len = self.segments.len();\n                 if len < 2 {\n                     return Err(\"Bad path\");\n@@ -635,9 +614,11 @@ impl Sig for ast::Generics {\n \n             if !l.bounds.is_empty() {\n                 l_text.push_str(\": \");\n-                let bounds = l.bounds.iter().map(|l| {\n-                    l.ident.to_string()\n-                }).collect::<Vec<_>>().join(\" + \");\n+                let bounds = l.bounds\n+                    .iter()\n+                    .map(|l| l.ident.to_string())\n+                    .collect::<Vec<_>>()\n+                    .join(\" + \");\n                 l_text.push_str(&bounds);\n                 // FIXME add lifetime bounds refs.\n             }\n@@ -662,7 +643,11 @@ impl Sig for ast::Generics {\n         }\n \n         text.push('>');\n-        Ok(Signature {text, defs, refs: vec![] })\n+        Ok(Signature {\n+            text,\n+            defs,\n+            refs: vec![],\n+        })\n     }\n }\n \n@@ -710,11 +695,7 @@ impl Sig for ast::Variant_ {\n                     refs.extend(field_sig.refs.into_iter());\n                 }\n                 text.push('}');\n-                Ok(Signature {\n-                    text,\n-                    defs,\n-                    refs,\n-                })\n+                Ok(Signature { text, defs, refs })\n             }\n             ast::VariantData::Tuple(ref fields, id) => {\n                 let name_def = SigElement {\n@@ -733,11 +714,7 @@ impl Sig for ast::Variant_ {\n                     refs.extend(field_sig.refs.into_iter());\n                 }\n                 text.push(')');\n-                Ok(Signature {\n-                    text,\n-                    defs,\n-                    refs,\n-                })\n+                Ok(Signature { text, defs, refs })\n             }\n             ast::VariantData::Unit(id) => {\n                 let name_def = SigElement {\n@@ -763,12 +740,7 @@ impl Sig for ast::ForeignItem {\n                 let mut text = String::new();\n                 text.push_str(\"fn \");\n \n-                let mut sig = name_and_generics(text,\n-                                                offset,\n-                                                generics,\n-                                                self.id,\n-                                                self.ident,\n-                                                scx)?;\n+                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n \n                 sig.text.push('(');\n                 for i in &decl.inputs {\n@@ -800,11 +772,13 @@ impl Sig for ast::ForeignItem {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n+                let defs = vec![\n+                    SigElement {\n+                        id: id_from_node_id(self.id, scx),\n+                        start: offset + text.len(),\n+                        end: offset + text.len() + name.len(),\n+                    },\n+                ];\n                 text.push_str(&name);\n                 text.push_str(\": \");\n \n@@ -816,11 +790,13 @@ impl Sig for ast::ForeignItem {\n             ast::ForeignItemKind::Ty => {\n                 let mut text = \"type \".to_owned();\n                 let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n+                let defs = vec![\n+                    SigElement {\n+                        id: id_from_node_id(self.id, scx),\n+                        start: offset + text.len(),\n+                        end: offset + text.len() + name.len(),\n+                    },\n+                ];\n                 text.push_str(&name);\n                 text.push(';');\n \n@@ -834,13 +810,14 @@ impl Sig for ast::ForeignItem {\n     }\n }\n \n-fn name_and_generics(mut text: String,\n-                     offset: usize,\n-                     generics: &ast::Generics,\n-                     id: NodeId,\n-                     name: ast::Ident,\n-                     scx: &SaveContext)\n-                     -> Result {\n+fn name_and_generics(\n+    mut text: String,\n+    offset: usize,\n+    generics: &ast::Generics,\n+    id: NodeId,\n+    name: ast::Ident,\n+    scx: &SaveContext,\n+) -> Result {\n     let name = name.to_string();\n     let def = SigElement {\n         id: id_from_node_id(id, scx),\n@@ -855,19 +832,22 @@ fn name_and_generics(mut text: String,\n }\n \n \n-fn make_assoc_type_signature(id: NodeId,\n-                             ident: ast::Ident,\n-                             bounds: Option<&ast::TyParamBounds>,\n-                             default: Option<&ast::Ty>,\n-                             scx: &SaveContext)\n-                             -> Result {\n+fn make_assoc_type_signature(\n+    id: NodeId,\n+    ident: ast::Ident,\n+    bounds: Option<&ast::TyParamBounds>,\n+    default: Option<&ast::Ty>,\n+    scx: &SaveContext,\n+) -> Result {\n     let mut text = \"type \".to_owned();\n     let name = ident.to_string();\n-    let mut defs = vec![SigElement {\n-        id: id_from_node_id(id, scx),\n-        start: text.len(),\n-        end: text.len() + name.len(),\n-    }];\n+    let mut defs = vec![\n+        SigElement {\n+            id: id_from_node_id(id, scx),\n+            start: text.len(),\n+            end: text.len() + name.len(),\n+        },\n+    ];\n     let mut refs = vec![];\n     text.push_str(&name);\n     if let Some(bounds) = bounds {\n@@ -886,19 +866,22 @@ fn make_assoc_type_signature(id: NodeId,\n     Ok(Signature { text, defs, refs })\n }\n \n-fn make_assoc_const_signature(id: NodeId,\n-                              ident: ast::Name,\n-                              ty: &ast::Ty,\n-                              default: Option<&ast::Expr>,\n-                              scx: &SaveContext)\n-                              -> Result {\n+fn make_assoc_const_signature(\n+    id: NodeId,\n+    ident: ast::Name,\n+    ty: &ast::Ty,\n+    default: Option<&ast::Expr>,\n+    scx: &SaveContext,\n+) -> Result {\n     let mut text = \"const \".to_owned();\n     let name = ident.to_string();\n-    let mut defs = vec![SigElement {\n-        id: id_from_node_id(id, scx),\n-        start: text.len(),\n-        end: text.len() + name.len(),\n-    }];\n+    let mut defs = vec![\n+        SigElement {\n+            id: id_from_node_id(id, scx),\n+            start: text.len(),\n+            end: text.len() + name.len(),\n+        },\n+    ];\n     let mut refs = vec![];\n     text.push_str(&name);\n     text.push_str(\": \");\n@@ -916,12 +899,13 @@ fn make_assoc_const_signature(id: NodeId,\n     Ok(Signature { text, defs, refs })\n }\n \n-fn make_method_signature(id: NodeId,\n-                         ident: ast::Ident,\n-                         generics: &ast::Generics,\n-                         m: &ast::MethodSig,\n-                         scx: &SaveContext)\n-                         -> Result {\n+fn make_method_signature(\n+    id: NodeId,\n+    ident: ast::Ident,\n+    generics: &ast::Generics,\n+    m: &ast::MethodSig,\n+    scx: &SaveContext,\n+) -> Result {\n     // FIXME code dup with function signature\n     let mut text = String::new();\n     if m.constness.node == ast::Constness::Const {\n@@ -937,12 +921,7 @@ fn make_method_signature(id: NodeId,\n     }\n     text.push_str(\"fn \");\n \n-    let mut sig = name_and_generics(text,\n-                                    0,\n-                                    generics,\n-                                    id,\n-                                    ident,\n-                                    scx)?;\n+    let mut sig = name_and_generics(text, 0, generics, id, ident, scx)?;\n \n     sig.text.push('(');\n     for i in &m.decl.inputs {"}, {"sha": "ff1a8541e06a6e3b057980649b52a7de106fe9a1", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b98290cb1f1cb22abda0dd97567d9aad95ae3078/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=b98290cb1f1cb22abda0dd97567d9aad95ae3078", "patch": "@@ -42,7 +42,11 @@ impl<'a> SpanUtils<'a> {\n         if path.is_absolute() {\n             path.clone().display().to_string()\n         } else {\n-            env::current_dir().unwrap().join(&path).display().to_string()\n+            env::current_dir()\n+                .unwrap()\n+                .join(&path)\n+                .display()\n+                .to_string()\n         }\n     }\n \n@@ -66,7 +70,7 @@ impl<'a> SpanUtils<'a> {\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n-                return result\n+                return result;\n             }\n             if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n                 result = Some(ts.sp);\n@@ -122,10 +126,9 @@ impl<'a> SpanUtils<'a> {\n         loop {\n             let next = toks.real_token();\n \n-            if (next.tok == token::Lt || next.tok == token::Colon) &&\n-               angle_count == 0 &&\n-               bracket_count == 0 &&\n-               prev.tok.is_ident() {\n+            if (next.tok == token::Lt || next.tok == token::Colon) && angle_count == 0\n+                && bracket_count == 0 && prev.tok.is_ident()\n+            {\n                 result = Some(prev.sp);\n             }\n \n@@ -152,12 +155,14 @@ impl<'a> SpanUtils<'a> {\n         }\n         if angle_count != 0 || bracket_count != 0 {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo());\n-            span_bug!(span,\n-                      \"Mis-counted brackets when breaking path? Parsing '{}' \\\n-                       in {}, line {}\",\n-                      self.snippet(span),\n-                      loc.file.name,\n-                      loc.line);\n+            span_bug!(\n+                span,\n+                \"Mis-counted brackets when breaking path? Parsing '{}' \\\n+                 in {}, line {}\",\n+                self.snippet(span),\n+                loc.file.name,\n+                loc.line\n+            );\n         }\n         if result.is_none() && prev.tok.is_ident() && angle_count == 0 {\n             return Some(prev.sp);\n@@ -211,7 +216,7 @@ impl<'a> SpanUtils<'a> {\n             if f(ts.tok) {\n                 let ts = toks.real_token();\n                 if ts.tok == token::Eof {\n-                    return None\n+                    return None;\n                 } else {\n                     return Some(ts.sp);\n                 }\n@@ -278,7 +283,12 @@ impl<'a> SpanUtils<'a> {\n         };\n \n         //If the span comes from a fake filemap, filter it.\n-        if !self.sess.codemap().lookup_char_pos(parent.lo()).file.is_real_file() {\n+        if !self.sess\n+            .codemap()\n+            .lookup_char_pos(parent.lo())\n+            .file\n+            .is_real_file()\n+        {\n             return true;\n         }\n "}]}