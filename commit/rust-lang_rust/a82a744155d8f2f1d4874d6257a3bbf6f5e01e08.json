{"sha": "a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MmE3NDQxNTVkOGYyZjFkNDg3NGQ2MjU3YTNiYmY2ZjVlMDFlMDg=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-07-01T15:17:19Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-07-01T15:41:24Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "5521aa76b80a2436256f6514be4966878fc2cb3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5521aa76b80a2436256f6514be4966878fc2cb3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmDd4iQACgkQHKDfKvWd\naKXaXxAAkgA8V2UxUDa9dwZ1K3VkeMlPRo0RjycL3ZdU39V/jgxBKSOIjfqA0oBb\ndT1D0G0+WPMw5ahJ3tGRWNYMhLJjTgRADbJo2L8SQmeL1hEN7mkeaVB7y8opMpqS\nYjM6xNrkqloiVxcB93AagFsT4hfHwSQdhMVIEAu4fW42StDQzaCoXHERwgbPpRK9\nHRUzbjGGW4mDTjbqJ4CVsjc5McPlqNCYaen4ER9eo/XRikGuoIgdFTAs7xAm651v\nK8rDard1nQgc8rCI9vQELRfu1RNNSbYMNGcjJvJIajKgko5XX5dMbZj67264IrB9\nVgh6Tm4Y98gLLkHCfBsG58IcugDtQ50SlXEdxHOPe0Qjf90ZHB1uLYp5+IKUKgw3\nUTcr18Xd+kOMmDWlpRjaeOHzEokQ/l9TbMhy6GPkWripnjY1IWNQfW9OEejwyqL+\nWaSsxHrdgYoenUl5TPaavYITuGAJzyvMWxP+ZKhvQn08ouD8ISByidLZANwZJWOv\nbTAzc6n489IdTdkbWwIyV4gOGKpAdo9XhLdw06kEy6aTd9G/5Qd/bINCux3a4t3v\nL5BdgFIlegoMFtOt7ZOB4VGHvgFr5YgFaApQ9gSdQjUanxNTCvhmZi3zuJWWkd4K\n1yxvhwHt15sZ2f9egacp2HuX2c/aCna4bY7eYGmtUAXleovDgK0=\n=4rWe\n-----END PGP SIGNATURE-----", "payload": "tree 5521aa76b80a2436256f6514be4966878fc2cb3d\nparent abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9\nparent 753bce30f057c8a51c1121e0d1958da4cb28059b\nauthor flip1995 <philipp.krones@embecosm.com> 1625152639 +0200\ncommitter flip1995 <philipp.krones@embecosm.com> 1625154084 +0200\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "html_url": "https://github.com/rust-lang/rust/commit/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9", "html_url": "https://github.com/rust-lang/rust/commit/abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9"}, {"sha": "753bce30f057c8a51c1121e0d1958da4cb28059b", "url": "https://api.github.com/repos/rust-lang/rust/commits/753bce30f057c8a51c1121e0d1958da4cb28059b", "html_url": "https://github.com/rust-lang/rust/commit/753bce30f057c8a51c1121e0d1958da4cb28059b"}], "stats": {"total": 4315, "additions": 3210, "deletions": 1105}, "files": [{"sha": "d856c55a41a4b8768b246009e43785a0b21ef6ca", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -71,7 +71,7 @@ jobs:\n       working-directory: clippy_workspace_tests\n \n     - name: Test cargo-clippy --fix\n-      run: ../target/debug/cargo-clippy clippy --fix -Zunstable-options\n+      run: ../target/debug/cargo-clippy clippy --fix\n       working-directory: clippy_workspace_tests\n \n     - name: Test clippy-driver"}, {"sha": "146b6fccd0c76e94962ca9260732ce849a535ee0", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -90,11 +90,6 @@ jobs:\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    # FIXME: should not be necessary once 1.24.2 is the default version on the windows runner\n-    - name: Update rustup\n-      run: rustup self update\n-      if: runner.os == 'Windows'\n-\n     - name: Install toolchain\n       run: rustup show active-toolchain\n \n@@ -139,7 +134,7 @@ jobs:\n       working-directory: clippy_workspace_tests\n \n     - name: Test cargo-clippy --fix\n-      run: ../target/debug/cargo-clippy clippy --fix -Zunstable-options\n+      run: ../target/debug/cargo-clippy clippy --fix\n       working-directory: clippy_workspace_tests\n \n     - name: Test clippy-driver"}, {"sha": "77efdec1e50db71b34a533df1d0deb068e3827e7", "filename": ".github/workflows/remark.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fremark.yml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -22,7 +22,7 @@ jobs:\n       uses: actions/setup-node@v1.4.4\n \n     - name: Install remark\n-      run: npm install remark-cli remark-lint remark-lint-maximum-line-length remark-preset-lint-recommended\n+      run: npm install remark-cli remark-lint remark-lint-maximum-line-length remark-preset-lint-recommended remark-gfm\n \n     # Run\n     - name: Check *.md files"}, {"sha": "04b82b8cc581ff573d7bc7cd14856d38c2d127ed", "filename": ".remarkrc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/.remarkrc", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/.remarkrc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.remarkrc?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,7 @@\n {\n   \"plugins\": [\n     \"remark-preset-lint-recommended\",\n+    \"remark-gfm\",\n     [\"remark-lint-list-item-indent\", false],\n     [\"remark-lint-no-literal-urls\", false],\n     [\"remark-lint-no-shortcut-reference-link\", false],"}, {"sha": "f3a8070323879ec8e9d1fb765ac47df1a74c3cb2", "filename": "CHANGELOG.md", "status": "modified", "additions": 136, "deletions": 3, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -6,11 +6,139 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[7c7683c...master](https://github.com/rust-lang/rust-clippy/compare/7c7683c...master)\n+[3ae8faf...master](https://github.com/rust-lang/rust-clippy/compare/3ae8faf...master)\n+\n+## Rust 1.54\n+\n+Current beta, release 2021-07-29\n+\n+[7c7683c...3ae8faf](https://github.com/rust-lang/rust-clippy/compare/7c7683c...3ae8faf)\n+\n+### New Lints\n+\n+- [`ref_binding_to_reference`]\n+  [#7105](https://github.com/rust-lang/rust-clippy/pull/7105)\n+- [`needless_bitwise_bool`]\n+  [#7133](https://github.com/rust-lang/rust-clippy/pull/7133)\n+- [`unused_async`] [#7225](https://github.com/rust-lang/rust-clippy/pull/7225)\n+- [`manual_str_repeat`]\n+  [#7265](https://github.com/rust-lang/rust-clippy/pull/7265)\n+- [`suspicious_splitn`]\n+  [#7292](https://github.com/rust-lang/rust-clippy/pull/7292)\n+\n+### Moves and Deprecations\n+\n+- Deprecate `pub_enum_variant_names` and `wrong_pub_self_convention` in favor of\n+  the new `avoid_breaking_exported_api` config option (see\n+  [Enhancements](#1-54-enhancements))\n+  [#7187](https://github.com/rust-lang/rust-clippy/pull/7187)\n+- Move [`inconsistent_struct_constructor`] to `pedantic`\n+  [#7193](https://github.com/rust-lang/rust-clippy/pull/7193)\n+- Move [`needless_borrow`] to `style` (now warn-by-default)\n+  [#7254](https://github.com/rust-lang/rust-clippy/pull/7254)\n+- Move [`suspicious_operation_groupings`] to `nursery`\n+  [#7266](https://github.com/rust-lang/rust-clippy/pull/7266)\n+- Move [`semicolon_if_nothing_returned`] to `pedantic`\n+  [#7268](https://github.com/rust-lang/rust-clippy/pull/7268)\n+\n+### Enhancements <a name=\"1-54-enhancements\"></a>\n+\n+- [`while_let_on_iterator`]: Now also lints in nested loops\n+  [#6966](https://github.com/rust-lang/rust-clippy/pull/6966)\n+- [`single_char_pattern`]: Now also lints on `strip_prefix` and `strip_suffix`\n+  [#7156](https://github.com/rust-lang/rust-clippy/pull/7156)\n+- [`needless_collect`]: Now also lints on assignments with type annotations\n+  [#7163](https://github.com/rust-lang/rust-clippy/pull/7163)\n+- [`if_then_some_else_none`]: Now works with the MSRV config\n+  [#7177](https://github.com/rust-lang/rust-clippy/pull/7177)\n+- Add `avoid_breaking_exported_api` config option for the lints\n+  [`enum_variant_names`], [`large_types_passed_by_value`],\n+  [`trivially_copy_pass_by_ref`], [`unnecessary_wraps`],\n+  [`upper_case_acronyms`], and [`wrong_self_convention`]. We recommend to set\n+  this configuration option to `false` before a major release (1.0/2.0/...) to\n+  clean up the API [#7187](https://github.com/rust-lang/rust-clippy/pull/7187)\n+- [`needless_collect`]: Now lints on even more data structures\n+  [#7188](https://github.com/rust-lang/rust-clippy/pull/7188)\n+- [`missing_docs_in_private_items`]: No longer sees `#[<name> = \"<value>\"]` like\n+  attributes as sufficient documentation\n+  [#7281](https://github.com/rust-lang/rust-clippy/pull/7281)\n+- [`needless_collect`], [`short_circuit_statement`], [`unnecessary_operation`]:\n+  Now work as expected when used with `allow`\n+  [#7282](https://github.com/rust-lang/rust-clippy/pull/7282)\n+\n+### False Positive Fixes\n+\n+- [`implicit_return`]: Now takes all diverging functions in account to avoid\n+  false positives [#6951](https://github.com/rust-lang/rust-clippy/pull/6951)\n+- [`while_let_on_iterator`]: No longer lints when the iterator is a struct field\n+  and the struct is used in the loop\n+  [#6966](https://github.com/rust-lang/rust-clippy/pull/6966)\n+- [`multiple_inherent_impl`]: No longer lints with generic arguments\n+  [#7089](https://github.com/rust-lang/rust-clippy/pull/7089)\n+- [`comparison_chain`]: No longer lints in a `const` context\n+  [#7118](https://github.com/rust-lang/rust-clippy/pull/7118)\n+- [`while_immutable_condition`]: Fix false positive where mutation in the loop\n+  variable wasn't picked up\n+  [#7144](https://github.com/rust-lang/rust-clippy/pull/7144)\n+- [`default_trait_access`]: No longer lints in macros\n+  [#7150](https://github.com/rust-lang/rust-clippy/pull/7150)\n+- [`needless_question_mark`]: No longer lints when the inner value is implicitly\n+  dereferenced [#7165](https://github.com/rust-lang/rust-clippy/pull/7165)\n+- [`unused_unit`]: No longer lints when multiple macro contexts are involved\n+  [#7167](https://github.com/rust-lang/rust-clippy/pull/7167)\n+- [`eval_order_dependence`]: Fix false positive in async context\n+  [#7174](https://github.com/rust-lang/rust-clippy/pull/7174)\n+- [`unnecessary_filter_map`]: No longer lints if the `filter_map` changes the\n+  type [#7175](https://github.com/rust-lang/rust-clippy/pull/7175)\n+- [`wrong_self_convention`]: No longer lints in trait implementations of\n+  non-`Copy` types [#7182](https://github.com/rust-lang/rust-clippy/pull/7182)\n+- [`suboptimal_flops`]: No longer lints on `powi(2)`\n+  [#7201](https://github.com/rust-lang/rust-clippy/pull/7201)\n+- [`wrong_self_convention`]: No longer lints if there is no implicit `self`\n+  [#7215](https://github.com/rust-lang/rust-clippy/pull/7215)\n+- [`option_if_let_else`]: No longer lints on `else if let` pattern\n+  [#7216](https://github.com/rust-lang/rust-clippy/pull/7216)\n+- [`use_self`], [`useless_conversion`]: Fix false positives when generic\n+  arguments are involved\n+  [#7223](https://github.com/rust-lang/rust-clippy/pull/7223)\n+- [`manual_unwrap_or`]: Fix false positive with deref coercion\n+  [#7233](https://github.com/rust-lang/rust-clippy/pull/7233)\n+- [`similar_names`]: No longer lints on `wparam`/`lparam`\n+  [#7255](https://github.com/rust-lang/rust-clippy/pull/7255)\n+- [`redundant_closure`]: No longer lints on using the `vec![]` macro in a\n+  closure [#7263](https://github.com/rust-lang/rust-clippy/pull/7263)\n+\n+### Suggestion Fixes/Improvements\n+\n+- [`implicit_return`]\n+  [#6951](https://github.com/rust-lang/rust-clippy/pull/6951)\n+    - Fix suggestion for async functions\n+    - Improve suggestion with macros\n+    - Suggest to change `break` to `return` when appropriate\n+- [`while_let_on_iterator`]: Now suggests `&mut iter` when necessary\n+  [#6966](https://github.com/rust-lang/rust-clippy/pull/6966)\n+- [`match_single_binding`]: Improve suggestion when match scrutinee has side\n+  effects [#7095](https://github.com/rust-lang/rust-clippy/pull/7095)\n+- [`needless_borrow`]: Now suggests to also change usage sites as needed\n+  [#7105](https://github.com/rust-lang/rust-clippy/pull/7105)\n+- [`write_with_newline`]: Improve suggestion when only `\\n` is written to the\n+  buffer [#7183](https://github.com/rust-lang/rust-clippy/pull/7183)\n+- [`from_iter_instead_of_collect`]: The suggestion is now auto applicable also\n+  when a `<_ as Trait>::_` is involved\n+  [#7264](https://github.com/rust-lang/rust-clippy/pull/7264)\n+- [`not_unsafe_ptr_arg_deref`]: Improved error message\n+  [#7294](https://github.com/rust-lang/rust-clippy/pull/7294)\n+\n+### ICE Fixes\n+\n+- Fix ICE when running Clippy on `libstd`\n+  [#7140](https://github.com/rust-lang/rust-clippy/pull/7140)\n+- [`implicit_return`]\n+  [#7242](https://github.com/rust-lang/rust-clippy/pull/7242)\n \n ## Rust 1.53\n \n-Current beta, release 2021-06-17\n+Current stable, released 2021-06-17\n \n [6ed6f1e...7c7683c](https://github.com/rust-lang/rust-clippy/compare/6ed6f1e...7c7683c)\n \n@@ -194,7 +322,7 @@ Current beta, release 2021-06-17\n \n ## Rust 1.52\n \n-Current stable, released 2021-05-06\n+Released 2021-05-06\n \n [3e41797...6ed6f1e](https://github.com/rust-lang/rust-clippy/compare/3e41797...6ed6f1e)\n \n@@ -2295,6 +2423,7 @@ Released 2018-09-13\n <!-- begin autogenerated links to lint list -->\n [`absurd_extreme_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n [`almost_swapped`]: https://rust-lang.github.io/rust-clippy/master/index.html#almost_swapped\n+[`append_instead_of_extend`]: https://rust-lang.github.io/rust-clippy/master/index.html#append_instead_of_extend\n [`approx_constant`]: https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n [`as_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_conversions\n [`assertions_on_constants`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants\n@@ -2358,6 +2487,8 @@ Released 2018-09-13\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`disallowed_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method\n+[`disallowed_script_idents`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_script_idents\n+[`disallowed_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_type\n [`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n [`doc_markdown`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown\n [`double_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_comparisons\n@@ -2527,6 +2658,7 @@ Released 2018-09-13\n [`misrefactored_assign_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#misrefactored_assign_op\n [`missing_const_for_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_const_for_fn\n [`missing_docs_in_private_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items\n+[`missing_enforced_import_renames`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_enforced_import_renames\n [`missing_errors_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc\n [`missing_inline_in_public_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_inline_in_public_items\n [`missing_panics_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc\n@@ -2574,6 +2706,7 @@ Released 2018-09-13\n [`non_octal_unix_permissions`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_octal_unix_permissions\n [`nonminimal_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonminimal_bool\n [`nonsensical_open_options`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonsensical_open_options\n+[`nonstandard_macro_braces`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonstandard_macro_braces\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref"}, {"sha": "4273fda4e640d5d9356a5d63f166db26224fc603", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -115,7 +115,7 @@ To work around this, you need to have a copy of the [rustc-repo][rustc_repo] ava\n `git clone https://github.com/rust-lang/rust/`.\n Then you can run a `cargo dev` command to automatically make Clippy use the rustc-repo via path-dependencies\n which `IntelliJ Rust` will be able to understand.\n-Run `cargo dev ide_setup --repo-path <repo-path>` where `<repo-path>` is a path to the rustc repo\n+Run `cargo dev setup intellij --repo-path <repo-path>` where `<repo-path>` is a path to the rustc repo\n you just cloned.\n The command will add path-dependencies pointing towards rustc-crates inside the rustc repo to\n Clippys `Cargo.toml`s and should allow `IntelliJ Rust` to understand most of the types that Clippy uses."}, {"sha": "9b5d9b2adf3b2413c85027477d1a2e36043b9801", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.54\"\n+version = \"0.1.55\"\n authors = [\"The Rust Clippy Developers\"]\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\""}, {"sha": "e1c968273cdf63ef95eae0633929566df1304e7e", "filename": "README.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -10,16 +10,17 @@ A collection of lints to catch common mistakes and improve your [Rust](https://g\n Lints are divided into categories, each with a default [lint level](https://doc.rust-lang.org/rustc/lints/levels.html).\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category.\n \n-| Category              | Description                                                             | Default level |\n-| --------------------- | ----------------------------------------------------------------------- | ------------- |\n-| `clippy::all`         | all lints that are on by default (correctness, style, complexity, perf) | **warn/deny** |\n-| `clippy::correctness` | code that is outright wrong or very useless                             | **deny**      |\n-| `clippy::style`       | code that should be written in a more idiomatic way                     | **warn**      |\n-| `clippy::complexity`  | code that does something simple but in a complex way                    | **warn**      |\n-| `clippy::perf`        | code that can be written to run faster                                  | **warn**      |\n-| `clippy::pedantic`    | lints which are rather strict or might have false positives             | allow         |\n-| `clippy::nursery`     | new lints that are still under development                              | allow         |\n-| `clippy::cargo`       | lints for the cargo manifest                                            | allow         |\n+| Category              | Description                                                                         | Default level |\n+| --------------------- | ----------------------------------------------------------------------------------- | ------------- |\n+| `clippy::all`         | all lints that are on by default (correctness, suspicious, style, complexity, perf) | **warn/deny** |\n+| `clippy::correctness` | code that is outright wrong or useless                                              | **deny**      |\n+| `clippy::suspicious`  | code that is most likely wrong or useless                                           | **warn**      |\n+| `clippy::style`       | code that should be written in a more idiomatic way                                 | **warn**      |\n+| `clippy::complexity`  | code that does something simple but in a complex way                                | **warn**      |\n+| `clippy::perf`        | code that can be written to run faster                                              | **warn**      |\n+| `clippy::pedantic`    | lints which are rather strict or might have false positives                         | allow         |\n+| `clippy::nursery`     | new lints that are still under development                                          | allow         |\n+| `clippy::cargo`       | lints for the cargo manifest                                                        | allow         |\n \n More to come, please [file an issue](https://github.com/rust-lang/rust-clippy/issues) if you have ideas!\n \n@@ -75,11 +76,10 @@ cargo clippy\n \n #### Automatically applying Clippy suggestions\n \n-Clippy can automatically apply some lint suggestions.\n-Note that this is still experimental and only supported on the nightly channel:\n+Clippy can automatically apply some lint suggestions, just like the compiler.\n \n ```terminal\n-cargo clippy --fix -Z unstable-options\n+cargo clippy --fix\n ```\n \n #### Workspaces"}, {"sha": "5c6c106e0e638429705e62ebba344f6e4ca6bf78", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -8,7 +8,7 @@ edition = \"2018\"\n bytecount = \"0.6\"\n clap = \"2.33\"\n itertools = \"0.9\"\n-opener = \"0.4\"\n+opener = \"0.5\"\n regex = \"1\"\n shell-escape = \"0.1\"\n walkdir = \"2\""}, {"sha": "c81eb40d52f3551ffc698db36acf7767b5c3874e", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -60,11 +60,7 @@ pub fn run(check: bool, verbose: bool) {\n             let entry = entry?;\n             let path = entry.path();\n \n-            if path.extension() != Some(\"rs\".as_ref())\n-                || entry.file_name() == \"ice-3891.rs\"\n-                // Avoid rustfmt bug rust-lang/rustfmt#1873\n-                || cfg!(windows) && entry.file_name() == \"implicit_hasher.rs\"\n-            {\n+            if path.extension() != Some(\"rs\".as_ref()) || entry.file_name() == \"ice-3891.rs\" {\n                 continue;\n             }\n \n@@ -90,7 +86,7 @@ pub fn run(check: bool, verbose: bool) {\n             },\n             CliError::RaSetupActive => {\n                 eprintln!(\n-                    \"error: a local rustc repo is enabled as path dependency via `cargo dev ide_setup`.\n+                    \"error: a local rustc repo is enabled as path dependency via `cargo dev setup intellij`.\n Not formatting because that would format the local repo as well!\n Please revert the changes to Cargo.tomls first.\"\n                 );"}, {"sha": "defb1133e44e60f285bf642a48abd5c22ffe8cc1", "filename": "clippy_dev/src/ide_setup.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9/clippy_dev%2Fsrc%2Fide_setup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9/clippy_dev%2Fsrc%2Fide_setup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fide_setup.rs?ref=abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9", "patch": "@@ -1,103 +0,0 @@\n-use std::fs;\n-use std::fs::File;\n-use std::io::prelude::*;\n-use std::path::{Path, PathBuf};\n-\n-// This module takes an absolute path to a rustc repo and alters the dependencies to point towards\n-// the respective rustc subcrates instead of using extern crate xyz.\n-// This allows rust analyzer to analyze rustc internals and show proper information inside clippy\n-// code. See https://github.com/rust-analyzer/rust-analyzer/issues/3517 and https://github.com/rust-lang/rust-clippy/issues/5514 for details\n-\n-/// # Panics\n-///\n-/// Panics if `rustc_path` does not lead to a rustc repo or the files could not be read\n-pub fn run(rustc_path: Option<&str>) {\n-    // we can unwrap here because the arg is required by clap\n-    let rustc_path = PathBuf::from(rustc_path.unwrap())\n-        .canonicalize()\n-        .expect(\"failed to get the absolute repo path\");\n-    assert!(rustc_path.is_dir(), \"path is not a directory\");\n-    let rustc_source_basedir = rustc_path.join(\"compiler\");\n-    assert!(\n-        rustc_source_basedir.is_dir(),\n-        \"are you sure the path leads to a rustc repo?\"\n-    );\n-\n-    let clippy_root_manifest = fs::read_to_string(\"Cargo.toml\").expect(\"failed to read ./Cargo.toml\");\n-    let clippy_root_lib_rs = fs::read_to_string(\"src/driver.rs\").expect(\"failed to read ./src/driver.rs\");\n-    inject_deps_into_manifest(\n-        &rustc_source_basedir,\n-        \"Cargo.toml\",\n-        &clippy_root_manifest,\n-        &clippy_root_lib_rs,\n-    )\n-    .expect(\"Failed to inject deps into ./Cargo.toml\");\n-\n-    let clippy_lints_manifest =\n-        fs::read_to_string(\"clippy_lints/Cargo.toml\").expect(\"failed to read ./clippy_lints/Cargo.toml\");\n-    let clippy_lints_lib_rs =\n-        fs::read_to_string(\"clippy_lints/src/lib.rs\").expect(\"failed to read ./clippy_lints/src/lib.rs\");\n-    inject_deps_into_manifest(\n-        &rustc_source_basedir,\n-        \"clippy_lints/Cargo.toml\",\n-        &clippy_lints_manifest,\n-        &clippy_lints_lib_rs,\n-    )\n-    .expect(\"Failed to inject deps into ./clippy_lints/Cargo.toml\");\n-}\n-\n-fn inject_deps_into_manifest(\n-    rustc_source_dir: &Path,\n-    manifest_path: &str,\n-    cargo_toml: &str,\n-    lib_rs: &str,\n-) -> std::io::Result<()> {\n-    // do not inject deps if we have aleady done so\n-    if cargo_toml.contains(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\") {\n-        eprintln!(\n-            \"cargo dev ide_setup: warning: deps already found inside {}, doing nothing.\",\n-            manifest_path\n-        );\n-        return Ok(());\n-    }\n-\n-    let extern_crates = lib_rs\n-        .lines()\n-        // get the deps\n-        .filter(|line| line.starts_with(\"extern crate\"))\n-        // we have something like \"extern crate foo;\", we only care about the \"foo\"\n-        //              \u2193          \u2193\n-        // extern crate rustc_middle;\n-        .map(|s| &s[13..(s.len() - 1)]);\n-\n-    let new_deps = extern_crates.map(|dep| {\n-        // format the dependencies that are going to be put inside the Cargo.toml\n-        format!(\n-            \"{dep} = {{ path = \\\"{source_path}/{dep}\\\" }}\\n\",\n-            dep = dep,\n-            source_path = rustc_source_dir.display()\n-        )\n-    });\n-\n-    // format a new [dependencies]-block with the new deps we need to inject\n-    let mut all_deps = String::from(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\\n\");\n-    new_deps.for_each(|dep_line| {\n-        all_deps.push_str(&dep_line);\n-    });\n-    all_deps.push_str(\"\\n[dependencies]\\n\");\n-\n-    // replace \"[dependencies]\" with\n-    // [dependencies]\n-    // dep1 = { path = ... }\n-    // dep2 = { path = ... }\n-    // etc\n-    let new_manifest = cargo_toml.replacen(\"[dependencies]\\n\", &all_deps, 1);\n-\n-    // println!(\"{}\", new_manifest);\n-    let mut file = File::create(manifest_path)?;\n-    file.write_all(new_manifest.as_bytes())?;\n-\n-    println!(\"Dependency paths injected: {}\", manifest_path);\n-\n-    Ok(())\n-}"}, {"sha": "72bdaf8d59282f89f39f63142a9191325f4c224f", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -14,9 +14,9 @@ use walkdir::WalkDir;\n \n pub mod bless;\n pub mod fmt;\n-pub mod ide_setup;\n pub mod new_lint;\n pub mod serve;\n+pub mod setup;\n pub mod stderr_length_check;\n pub mod update_lints;\n "}, {"sha": "ff324ff6ee6fff5b6a38edc9aaefc6ee09df0f34", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -2,8 +2,8 @@\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n-use clap::{App, Arg, ArgMatches, SubCommand};\n-use clippy_dev::{bless, fmt, ide_setup, new_lint, serve, stderr_length_check, update_lints};\n+use clap::{App, AppSettings, Arg, ArgMatches, SubCommand};\n+use clippy_dev::{bless, fmt, new_lint, serve, setup, stderr_length_check, update_lints};\n fn main() {\n     let matches = get_clap_config();\n \n@@ -36,7 +36,22 @@ fn main() {\n         (\"limit_stderr_length\", _) => {\n             stderr_length_check::check();\n         },\n-        (\"ide_setup\", Some(matches)) => ide_setup::run(matches.value_of(\"rustc-repo-path\")),\n+        (\"setup\", Some(sub_command)) => match sub_command.subcommand() {\n+            (\"intellij\", Some(matches)) => setup::intellij::setup_rustc_src(\n+                matches\n+                    .value_of(\"rustc-repo-path\")\n+                    .expect(\"this field is mandatory and therefore always valid\"),\n+            ),\n+            (\"git-hook\", Some(matches)) => setup::git_hook::install_hook(matches.is_present(\"force-override\")),\n+            (\"vscode-tasks\", Some(matches)) => setup::vscode::install_tasks(matches.is_present(\"force-override\")),\n+            _ => {},\n+        },\n+        (\"remove\", Some(sub_command)) => match sub_command.subcommand() {\n+            (\"git-hook\", Some(_)) => setup::git_hook::remove_hook(),\n+            (\"intellij\", Some(_)) => setup::intellij::remove_rustc_src(),\n+            (\"vscode-tasks\", Some(_)) => setup::vscode::remove_tasks(),\n+            _ => {},\n+        },\n         (\"serve\", Some(matches)) => {\n             let port = matches.value_of(\"port\").unwrap().parse().unwrap();\n             let lint = matches.value_of(\"lint\");\n@@ -48,6 +63,7 @@ fn main() {\n \n fn get_clap_config<'a>() -> ArgMatches<'a> {\n     App::new(\"Clippy developer tooling\")\n+        .setting(AppSettings::ArgRequiredElseHelp)\n         .subcommand(\n             SubCommand::with_name(\"bless\")\n                 .about(\"bless the test output changes\")\n@@ -123,6 +139,7 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                         .possible_values(&[\n                             \"style\",\n                             \"correctness\",\n+                            \"suspicious\",\n                             \"complexity\",\n                             \"perf\",\n                             \"pedantic\",\n@@ -140,16 +157,54 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                 .about(\"Ensures that stderr files do not grow longer than a certain amount of lines.\"),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"ide_setup\")\n-                .about(\"Alter dependencies so Intellij Rust can find rustc internals\")\n-                .arg(\n-                    Arg::with_name(\"rustc-repo-path\")\n-                        .long(\"repo-path\")\n-                        .short(\"r\")\n-                        .help(\"The path to a rustc repo that will be used for setting the dependencies\")\n-                        .takes_value(true)\n-                        .value_name(\"path\")\n-                        .required(true),\n+            SubCommand::with_name(\"setup\")\n+                .about(\"Support for setting up your personal development environment\")\n+                .setting(AppSettings::ArgRequiredElseHelp)\n+                .subcommand(\n+                    SubCommand::with_name(\"intellij\")\n+                        .about(\"Alter dependencies so Intellij Rust can find rustc internals\")\n+                        .arg(\n+                            Arg::with_name(\"rustc-repo-path\")\n+                                .long(\"repo-path\")\n+                                .short(\"r\")\n+                                .help(\"The path to a rustc repo that will be used for setting the dependencies\")\n+                                .takes_value(true)\n+                                .value_name(\"path\")\n+                                .required(true),\n+                        ),\n+                )\n+                .subcommand(\n+                    SubCommand::with_name(\"git-hook\")\n+                        .about(\"Add a pre-commit git hook that formats your code to make it look pretty\")\n+                        .arg(\n+                            Arg::with_name(\"force-override\")\n+                                .long(\"force-override\")\n+                                .short(\"f\")\n+                                .help(\"Forces the override of an existing git pre-commit hook\")\n+                                .required(false),\n+                        ),\n+                )\n+                .subcommand(\n+                    SubCommand::with_name(\"vscode-tasks\")\n+                        .about(\"Add several tasks to vscode for formatting, validation and testing\")\n+                        .arg(\n+                            Arg::with_name(\"force-override\")\n+                                .long(\"force-override\")\n+                                .short(\"f\")\n+                                .help(\"Forces the override of existing vscode tasks\")\n+                                .required(false),\n+                        ),\n+                ),\n+        )\n+        .subcommand(\n+            SubCommand::with_name(\"remove\")\n+                .about(\"Support for undoing changes done by the setup command\")\n+                .setting(AppSettings::ArgRequiredElseHelp)\n+                .subcommand(SubCommand::with_name(\"git-hook\").about(\"Remove any existing pre-commit git hook\"))\n+                .subcommand(SubCommand::with_name(\"vscode-tasks\").about(\"Remove any existing vscode tasks\"))\n+                .subcommand(\n+                    SubCommand::with_name(\"intellij\")\n+                        .about(\"Removes rustc source paths added via `cargo dev setup intellij`\"),\n                 ),\n         )\n         .subcommand("}, {"sha": "3fbb77d59235c32604ec8079fcb1c57081a73521", "filename": "clippy_dev/src/setup/git_hook.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fsetup%2Fgit_hook.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,85 @@\n+use std::fs;\n+use std::path::Path;\n+\n+use super::verify_inside_clippy_dir;\n+\n+/// Rusts setup uses `git rev-parse --git-common-dir` to get the root directory of the repo.\n+/// I've decided against this for the sake of simplicity and to make sure that it doesn't install\n+/// the hook if `clippy_dev` would be used in the rust tree. The hook also references this tool\n+/// for formatting and should therefor only be used in a normal clone of clippy\n+const REPO_GIT_DIR: &str = \".git\";\n+const HOOK_SOURCE_FILE: &str = \"util/etc/pre-commit.sh\";\n+const HOOK_TARGET_FILE: &str = \".git/hooks/pre-commit\";\n+\n+pub fn install_hook(force_override: bool) {\n+    if !check_precondition(force_override) {\n+        return;\n+    }\n+\n+    // So a little bit of a funny story. Git on unix requires the pre-commit file\n+    // to have the `execute` permission to be set. The Rust functions for modifying\n+    // these flags doesn't seem to work when executed with normal user permissions.\n+    //\n+    // However, there is a little hack that is also being used by Rust itself in their\n+    // setup script. Git saves the `execute` flag when syncing files. This means\n+    // that we can check in a file with execution permissions and the sync it to create\n+    // a file with the flag set. We then copy this file here. The copy function will also\n+    // include the `execute` permission.\n+    match fs::copy(HOOK_SOURCE_FILE, HOOK_TARGET_FILE) {\n+        Ok(_) => {\n+            println!(\"info: the hook can be removed with `cargo dev remove git-hook`\");\n+            println!(\"git hook successfully installed\");\n+        },\n+        Err(err) => eprintln!(\n+            \"error: unable to copy `{}` to `{}` ({})\",\n+            HOOK_SOURCE_FILE, HOOK_TARGET_FILE, err\n+        ),\n+    }\n+}\n+\n+fn check_precondition(force_override: bool) -> bool {\n+    if !verify_inside_clippy_dir() {\n+        return false;\n+    }\n+\n+    // Make sure that we can find the git repository\n+    let git_path = Path::new(REPO_GIT_DIR);\n+    if !git_path.exists() || !git_path.is_dir() {\n+        eprintln!(\"error: clippy_dev was unable to find the `.git` directory\");\n+        return false;\n+    }\n+\n+    // Make sure that we don't override an existing hook by accident\n+    let path = Path::new(HOOK_TARGET_FILE);\n+    if path.exists() {\n+        if force_override {\n+            return delete_git_hook_file(path);\n+        }\n+\n+        eprintln!(\"error: there is already a pre-commit hook installed\");\n+        println!(\"info: use the `--force-override` flag to override the existing hook\");\n+        return false;\n+    }\n+\n+    true\n+}\n+\n+pub fn remove_hook() {\n+    let path = Path::new(HOOK_TARGET_FILE);\n+    if path.exists() {\n+        if delete_git_hook_file(path) {\n+            println!(\"git hook successfully removed\");\n+        }\n+    } else {\n+        println!(\"no pre-commit hook was found\");\n+    }\n+}\n+\n+fn delete_git_hook_file(path: &Path) -> bool {\n+    if let Err(err) = fs::remove_file(path) {\n+        eprintln!(\"error: unable to delete existing pre-commit git hook ({})\", err);\n+        false\n+    } else {\n+        true\n+    }\n+}"}, {"sha": "bf741e6d1217f98b25b1168ba8ede7df757440ff", "filename": "clippy_dev/src/setup/intellij.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fsetup%2Fintellij.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fsetup%2Fintellij.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fsetup%2Fintellij.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,223 @@\n+use std::fs;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::{Path, PathBuf};\n+\n+// This module takes an absolute path to a rustc repo and alters the dependencies to point towards\n+// the respective rustc subcrates instead of using extern crate xyz.\n+// This allows IntelliJ to analyze rustc internals and show proper information inside Clippy\n+// code. See https://github.com/rust-lang/rust-clippy/issues/5514 for details\n+\n+const RUSTC_PATH_SECTION: &str = \"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\";\n+const DEPENDENCIES_SECTION: &str = \"[dependencies]\";\n+\n+const CLIPPY_PROJECTS: &[ClippyProjectInfo] = &[\n+    ClippyProjectInfo::new(\"root\", \"Cargo.toml\", \"src/driver.rs\"),\n+    ClippyProjectInfo::new(\"clippy_lints\", \"clippy_lints/Cargo.toml\", \"clippy_lints/src/lib.rs\"),\n+    ClippyProjectInfo::new(\"clippy_utils\", \"clippy_utils/Cargo.toml\", \"clippy_utils/src/lib.rs\"),\n+];\n+\n+/// Used to store clippy project information to later inject the dependency into.\n+struct ClippyProjectInfo {\n+    /// Only used to display information to the user\n+    name: &'static str,\n+    cargo_file: &'static str,\n+    lib_rs_file: &'static str,\n+}\n+\n+impl ClippyProjectInfo {\n+    const fn new(name: &'static str, cargo_file: &'static str, lib_rs_file: &'static str) -> Self {\n+        Self {\n+            name,\n+            cargo_file,\n+            lib_rs_file,\n+        }\n+    }\n+}\n+\n+pub fn setup_rustc_src(rustc_path: &str) {\n+    let rustc_source_dir = match check_and_get_rustc_dir(rustc_path) {\n+        Ok(path) => path,\n+        Err(_) => return,\n+    };\n+\n+    for project in CLIPPY_PROJECTS {\n+        if inject_deps_into_project(&rustc_source_dir, project).is_err() {\n+            return;\n+        }\n+    }\n+\n+    println!(\"info: the source paths can be removed again with `cargo dev remove intellij`\");\n+}\n+\n+fn check_and_get_rustc_dir(rustc_path: &str) -> Result<PathBuf, ()> {\n+    let mut path = PathBuf::from(rustc_path);\n+\n+    if path.is_relative() {\n+        match path.canonicalize() {\n+            Ok(absolute_path) => {\n+                println!(\"info: the rustc path was resolved to: `{}`\", absolute_path.display());\n+                path = absolute_path;\n+            },\n+            Err(err) => {\n+                eprintln!(\"error: unable to get the absolute path of rustc ({})\", err);\n+                return Err(());\n+            },\n+        };\n+    }\n+\n+    let path = path.join(\"compiler\");\n+    println!(\"info: looking for compiler sources at: {}\", path.display());\n+\n+    if !path.exists() {\n+        eprintln!(\"error: the given path does not exist\");\n+        return Err(());\n+    }\n+\n+    if !path.is_dir() {\n+        eprintln!(\"error: the given path is not a directory\");\n+        return Err(());\n+    }\n+\n+    Ok(path)\n+}\n+\n+fn inject_deps_into_project(rustc_source_dir: &Path, project: &ClippyProjectInfo) -> Result<(), ()> {\n+    let cargo_content = read_project_file(project.cargo_file)?;\n+    let lib_content = read_project_file(project.lib_rs_file)?;\n+\n+    if inject_deps_into_manifest(rustc_source_dir, project.cargo_file, &cargo_content, &lib_content).is_err() {\n+        eprintln!(\n+            \"error: unable to inject dependencies into {} with the Cargo file {}\",\n+            project.name, project.cargo_file\n+        );\n+        Err(())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+/// `clippy_dev` expects to be executed in the root directory of Clippy. This function\n+/// loads the given file or returns an error. Having it in this extra function ensures\n+/// that the error message looks nice.\n+fn read_project_file(file_path: &str) -> Result<String, ()> {\n+    let path = Path::new(file_path);\n+    if !path.exists() {\n+        eprintln!(\"error: unable to find the file `{}`\", file_path);\n+        return Err(());\n+    }\n+\n+    match fs::read_to_string(path) {\n+        Ok(content) => Ok(content),\n+        Err(err) => {\n+            eprintln!(\"error: the file `{}` could not be read ({})\", file_path, err);\n+            Err(())\n+        },\n+    }\n+}\n+\n+fn inject_deps_into_manifest(\n+    rustc_source_dir: &Path,\n+    manifest_path: &str,\n+    cargo_toml: &str,\n+    lib_rs: &str,\n+) -> std::io::Result<()> {\n+    // do not inject deps if we have already done so\n+    if cargo_toml.contains(RUSTC_PATH_SECTION) {\n+        eprintln!(\n+            \"warn: dependencies are already setup inside {}, skipping file\",\n+            manifest_path\n+        );\n+        return Ok(());\n+    }\n+\n+    let extern_crates = lib_rs\n+        .lines()\n+        // only take dependencies starting with `rustc_`\n+        .filter(|line| line.starts_with(\"extern crate rustc_\"))\n+        // we have something like \"extern crate foo;\", we only care about the \"foo\"\n+        // extern crate rustc_middle;\n+        //              ^^^^^^^^^^^^\n+        .map(|s| &s[13..(s.len() - 1)]);\n+\n+    let new_deps = extern_crates.map(|dep| {\n+        // format the dependencies that are going to be put inside the Cargo.toml\n+        format!(\n+            \"{dep} = {{ path = \\\"{source_path}/{dep}\\\" }}\\n\",\n+            dep = dep,\n+            source_path = rustc_source_dir.display()\n+        )\n+    });\n+\n+    // format a new [dependencies]-block with the new deps we need to inject\n+    let mut all_deps = String::from(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\\n\");\n+    new_deps.for_each(|dep_line| {\n+        all_deps.push_str(&dep_line);\n+    });\n+    all_deps.push_str(\"\\n[dependencies]\\n\");\n+\n+    // replace \"[dependencies]\" with\n+    // [dependencies]\n+    // dep1 = { path = ... }\n+    // dep2 = { path = ... }\n+    // etc\n+    let new_manifest = cargo_toml.replacen(\"[dependencies]\\n\", &all_deps, 1);\n+\n+    // println!(\"{}\", new_manifest);\n+    let mut file = File::create(manifest_path)?;\n+    file.write_all(new_manifest.as_bytes())?;\n+\n+    println!(\"info: successfully setup dependencies inside {}\", manifest_path);\n+\n+    Ok(())\n+}\n+\n+pub fn remove_rustc_src() {\n+    for project in CLIPPY_PROJECTS {\n+        remove_rustc_src_from_project(project);\n+    }\n+}\n+\n+fn remove_rustc_src_from_project(project: &ClippyProjectInfo) -> bool {\n+    let mut cargo_content = if let Ok(content) = read_project_file(project.cargo_file) {\n+        content\n+    } else {\n+        return false;\n+    };\n+    let section_start = if let Some(section_start) = cargo_content.find(RUSTC_PATH_SECTION) {\n+        section_start\n+    } else {\n+        println!(\n+            \"info: dependencies could not be found in `{}` for {}, skipping file\",\n+            project.cargo_file, project.name\n+        );\n+        return true;\n+    };\n+\n+    let end_point = if let Some(end_point) = cargo_content.find(DEPENDENCIES_SECTION) {\n+        end_point\n+    } else {\n+        eprintln!(\n+            \"error: the end of the rustc dependencies section could not be found in `{}`\",\n+            project.cargo_file\n+        );\n+        return false;\n+    };\n+\n+    cargo_content.replace_range(section_start..end_point, \"\");\n+\n+    match File::create(project.cargo_file) {\n+        Ok(mut file) => {\n+            file.write_all(cargo_content.as_bytes()).unwrap();\n+            println!(\"info: successfully removed dependencies inside {}\", project.cargo_file);\n+            true\n+        },\n+        Err(err) => {\n+            eprintln!(\n+                \"error: unable to open file `{}` to remove rustc dependencies for {} ({})\",\n+                project.cargo_file, project.name, err\n+            );\n+            false\n+        },\n+    }\n+}"}, {"sha": "a1e4dd103b88bfa708948c44ba7cd8a48ec1a346", "filename": "clippy_dev/src/setup/mod.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,23 @@\n+pub mod git_hook;\n+pub mod intellij;\n+pub mod vscode;\n+\n+use std::path::Path;\n+\n+const CLIPPY_DEV_DIR: &str = \"clippy_dev\";\n+\n+/// This function verifies that the tool is being executed in the clippy directory.\n+/// This is useful to ensure that setups only modify Clippys resources. The verification\n+/// is done by checking that `clippy_dev` is a sub directory of the current directory.\n+///\n+/// It will print an error message and return `false` if the directory could not be\n+/// verified.\n+fn verify_inside_clippy_dir() -> bool {\n+    let path = Path::new(CLIPPY_DEV_DIR);\n+    if path.exists() && path.is_dir() {\n+        true\n+    } else {\n+        eprintln!(\"error: unable to verify that the working directory is clippys directory\");\n+        false\n+    }\n+}"}, {"sha": "d59001b2c66afc49b6cfc7c8fa230f2bc7b50446", "filename": "clippy_dev/src/setup/vscode.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fsetup%2Fvscode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fsetup%2Fvscode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fsetup%2Fvscode.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,104 @@\n+use std::fs;\n+use std::path::Path;\n+\n+use super::verify_inside_clippy_dir;\n+\n+const VSCODE_DIR: &str = \".vscode\";\n+const TASK_SOURCE_FILE: &str = \"util/etc/vscode-tasks.json\";\n+const TASK_TARGET_FILE: &str = \".vscode/tasks.json\";\n+\n+pub fn install_tasks(force_override: bool) {\n+    if !check_install_precondition(force_override) {\n+        return;\n+    }\n+\n+    match fs::copy(TASK_SOURCE_FILE, TASK_TARGET_FILE) {\n+        Ok(_) => {\n+            println!(\"info: the task file can be removed with `cargo dev remove vscode-tasks`\");\n+            println!(\"vscode tasks successfully installed\");\n+        },\n+        Err(err) => eprintln!(\n+            \"error: unable to copy `{}` to `{}` ({})\",\n+            TASK_SOURCE_FILE, TASK_TARGET_FILE, err\n+        ),\n+    }\n+}\n+\n+fn check_install_precondition(force_override: bool) -> bool {\n+    if !verify_inside_clippy_dir() {\n+        return false;\n+    }\n+\n+    let vs_dir_path = Path::new(VSCODE_DIR);\n+    if vs_dir_path.exists() {\n+        // verify the target will be valid\n+        if !vs_dir_path.is_dir() {\n+            eprintln!(\"error: the `.vscode` path exists but seems to be a file\");\n+            return false;\n+        }\n+\n+        // make sure that we don't override any existing tasks by accident\n+        let path = Path::new(TASK_TARGET_FILE);\n+        if path.exists() {\n+            if force_override {\n+                return delete_vs_task_file(path);\n+            }\n+\n+            eprintln!(\n+                \"error: there is already a `task.json` file inside the `{}` directory\",\n+                VSCODE_DIR\n+            );\n+            println!(\"info: use the `--force-override` flag to override the existing `task.json` file\");\n+            return false;\n+        }\n+    } else {\n+        match fs::create_dir(vs_dir_path) {\n+            Ok(_) => {\n+                println!(\"info: created `{}` directory for clippy\", VSCODE_DIR);\n+            },\n+            Err(err) => {\n+                eprintln!(\n+                    \"error: the task target directory `{}` could not be created ({})\",\n+                    VSCODE_DIR, err\n+                );\n+            },\n+        }\n+    }\n+\n+    true\n+}\n+\n+pub fn remove_tasks() {\n+    let path = Path::new(TASK_TARGET_FILE);\n+    if path.exists() {\n+        if delete_vs_task_file(path) {\n+            try_delete_vs_directory_if_empty();\n+            println!(\"vscode tasks successfully removed\");\n+        }\n+    } else {\n+        println!(\"no vscode tasks were found\");\n+    }\n+}\n+\n+fn delete_vs_task_file(path: &Path) -> bool {\n+    if let Err(err) = fs::remove_file(path) {\n+        eprintln!(\"error: unable to delete the existing `tasks.json` file ({})\", err);\n+        return false;\n+    }\n+\n+    true\n+}\n+\n+/// This function will try to delete the `.vscode` directory if it's empty.\n+/// It may fail silently.\n+fn try_delete_vs_directory_if_empty() {\n+    let path = Path::new(VSCODE_DIR);\n+    if path.read_dir().map_or(false, |mut iter| iter.next().is_none()) {\n+        // The directory is empty. We just try to delete it but allow a silence\n+        // fail as an empty `.vscode` directory is still valid\n+        let _silence_result = fs::remove_dir(path);\n+    } else {\n+        // The directory is not empty or could not be read. Either way don't take\n+        // any further actions\n+    }\n+}"}, {"sha": "db467c26f15466de263ddd1c5a00bac7b1f995e5", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -92,7 +92,10 @@ pub fn run(update_mode: UpdateMode) {\n         || {\n             // clippy::all should only include the following lint groups:\n             let all_group_lints = usable_lints.iter().filter(|l| {\n-                l.group == \"correctness\" || l.group == \"style\" || l.group == \"complexity\" || l.group == \"perf\"\n+                matches!(\n+                    &*l.group,\n+                    \"correctness\" | \"suspicious\" | \"style\" | \"complexity\" | \"perf\"\n+                )\n             });\n \n             gen_lint_group_list(all_group_lints)"}, {"sha": "42cf7547f519459a6cb470ed8a963a181490d7fd", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.1.54\"\n+version = \"0.1.55\"\n # end automatic update\n authors = [\"The Rust Clippy Developers\"]\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n@@ -23,6 +23,7 @@ serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = { version = \"1.0\", optional = true }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n+unicode-script = { version = \"0.5.3\", default-features = false }\n semver = \"0.11\"\n rustc-semver = \"1.1.0\"\n # NOTE: cargo requires serde feat in its url dep"}, {"sha": "a8c527fe2e353fd131defe916887f5fd8cdd6f05", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -55,7 +55,7 @@ declare_clippy_lint! {\n     /// a += a + b;\n     /// ```\n     pub MISREFACTORED_ASSIGN_OP,\n-    complexity,\n+    suspicious,\n     \"having a variable on both sides of an assign op\"\n }\n "}, {"sha": "f272ed010a1b03df405044a4750f5b0afe4f64b5", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -173,7 +173,7 @@ declare_clippy_lint! {\n     /// #![deny(clippy::as_conversions)]\n     /// ```\n     pub BLANKET_CLIPPY_RESTRICTION_LINTS,\n-    style,\n+    suspicious,\n     \"enabling the complete restriction group\"\n }\n "}, {"sha": "8eb94f3c28e447943dcbc5702085a4c1bba9614e", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::{diagnostics::span_lint, is_test_module_or_function};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::{Pat, PatKind};\n+use rustc_hir::{Item, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n@@ -25,18 +25,37 @@ declare_clippy_lint! {\n #[derive(Clone, Debug)]\n pub struct BlacklistedName {\n     blacklist: FxHashSet<String>,\n+    test_modules_deep: u32,\n }\n \n impl BlacklistedName {\n     pub fn new(blacklist: FxHashSet<String>) -> Self {\n-        Self { blacklist }\n+        Self {\n+            blacklist,\n+            test_modules_deep: 0,\n+        }\n+    }\n+\n+    fn in_test_module(&self) -> bool {\n+        self.test_modules_deep != 0\n     }\n }\n \n impl_lint_pass!(BlacklistedName => [BLACKLISTED_NAME]);\n \n impl<'tcx> LateLintPass<'tcx> for BlacklistedName {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_test_module_or_function(cx.tcx, item) {\n+            self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n+        }\n+    }\n+\n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n+        // Check whether we are under the `test` attribute.\n+        if self.in_test_module() {\n+            return;\n+        }\n+\n         if let PatKind::Binding(.., ident, _) = pat.kind {\n             if self.blacklist.contains(&ident.name.to_string()) {\n                 span_lint(\n@@ -48,4 +67,10 @@ impl<'tcx> LateLintPass<'tcx> for BlacklistedName {\n             }\n         }\n     }\n+\n+    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_test_module_or_function(cx.tcx, item) {\n+            self.test_modules_deep = self.test_modules_deep.saturating_sub(1);\n+        }\n+    }\n }"}, {"sha": "4f7ffdcdfb499ac972c9dbd9eeced0153b492ddc", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,15 +1,15 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n-use clippy_utils::{contains_name, get_pat_name, paths, single_segment_path};\n+use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, UnOp};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n-use rustc_span::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for naive byte counts\n@@ -38,42 +38,43 @@ declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n impl<'tcx> LateLintPass<'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(count, _, count_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(count, _, [count_recv], _) = expr.kind;\n             if count.ident.name == sym!(count);\n-            if count_args.len() == 1;\n-            if let ExprKind::MethodCall(filter, _, filter_args, _) = count_args[0].kind;\n+            if let ExprKind::MethodCall(filter, _, [filter_recv, filter_arg], _) = count_recv.kind;\n             if filter.ident.name == sym!(filter);\n-            if filter_args.len() == 2;\n-            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n+            if let ExprKind::Closure(_, _, body_id, _, _) = filter_arg.kind;\n             let body = cx.tcx.hir().body(body_id);\n-            if body.params.len() == 1;\n-            if let Some(argname) = get_pat_name(body.params[0].pat);\n+            if let [param] = body.params;\n+            if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n             if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n             if op.node == BinOpKind::Eq;\n             if match_type(cx,\n-                       cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n+                       cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n                        &paths::SLICE_ITER);\n+            let operand_is_arg = |expr| {\n+                let expr = peel_ref_operators(cx, remove_blocks(expr));\n+                path_to_local_id(expr, arg_id)\n+            };\n+            let needle = if operand_is_arg(l) {\n+                r\n+            } else if operand_is_arg(r) {\n+                l\n+            } else {\n+                return;\n+            };\n+            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n+            if !LocalUsedVisitor::new(cx, arg_id).check_expr(needle);\n             then {\n-                let needle = match get_path_name(l) {\n-                    Some(name) if check_arg(name, argname, r) => r,\n-                    _ => match get_path_name(r) {\n-                        Some(name) if check_arg(name, argname, l) => l,\n-                        _ => { return; }\n-                    }\n-                };\n-                if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n-                    return;\n-                }\n                 let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n-                        filter_args[0].kind {\n+                        filter_recv.kind {\n                     let p = path.ident.name;\n                     if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n                         &args[0]\n                     } else {\n-                        &filter_args[0]\n+                        &filter_recv\n                     }\n                 } else {\n-                    &filter_args[0]\n+                    &filter_recv\n                 };\n                 let mut applicability = Applicability::MaybeIncorrect;\n                 span_lint_and_sugg(\n@@ -91,24 +92,3 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n         };\n     }\n }\n-\n-fn check_arg(name: Symbol, arg: Symbol, needle: &Expr<'_>) -> bool {\n-    name == arg && !contains_name(name, needle)\n-}\n-\n-fn get_path_name(expr: &Expr<'_>) -> Option<Symbol> {\n-    match expr.kind {\n-        ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) | ExprKind::Unary(UnOp::Deref, e) => {\n-            get_path_name(e)\n-        },\n-        ExprKind::Block(b, _) => {\n-            if b.stmts.is_empty() {\n-                b.expr.as_ref().and_then(|p| get_path_name(p))\n-            } else {\n-                None\n-            }\n-        },\n-        ExprKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        _ => None,\n-    }\n-}"}, {"sha": "a6c3a5b0e83c466bc8b98f14e55ca7070a876da1", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{is_lang_ctor, path_to_local, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind, UnOp};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::TypeckResults;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n \n@@ -73,7 +72,7 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         if arms_inner.iter().all(|arm| arm.guard.is_none());\n         // match expression must be a local binding\n         // match <local> { .. }\n-        if let Some(binding_id) = path_to_local(strip_ref_operators(expr_in, cx.typeck_results()));\n+        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, expr_in));\n         // one of the branches must be \"wild-like\"\n         if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(cx, arm_inner));\n         let (wild_inner_arm, non_wild_inner_arm) =\n@@ -163,16 +162,3 @@ fn pat_contains_or(pat: &Pat<'_>) -> bool {\n     });\n     result\n }\n-\n-/// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n-/// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n-fn strip_ref_operators<'hir>(mut expr: &'hir Expr<'hir>, typeck_results: &TypeckResults<'_>) -> &'hir Expr<'hir> {\n-    loop {\n-        match expr.kind {\n-            ExprKind::AddrOf(_, _, e) => expr = e,\n-            ExprKind::Unary(UnOp::Deref, e) if typeck_results.expr_ty(e).is_ref() => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}"}, {"sha": "947479db8f5d78e77fdc1b6fa60a08357fb609fa", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -7,7 +7,6 @@ use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{Ident, Symbol};\n@@ -122,7 +121,7 @@ impl LateLintPass<'_> for Default {\n                 if let StmtKind::Local(local) = stmt.kind;\n                 if let Some(expr) = local.init;\n                 if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n-                if !in_external_macro(cx.tcx.sess, expr.span);\n+                if !in_macro(expr.span);\n                 // only take bindings to identifiers\n                 if let PatKind::Binding(_, binding_id, ident, _) = local.pat.kind;\n                 // only when assigning `... = Default::default()`"}, {"sha": "a125376bffa9fa405089ba1cc483e3543496aee9", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -7,9 +7,10 @@ use rustc_hir::{\n     intravisit::{walk_expr, walk_stmt, NestedVisitorMap, Visitor},\n     Body, Expr, ExprKind, HirId, Lit, Stmt, StmtKind,\n };\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::{\n     hir::map::Map,\n+    lint::in_external_macro,\n     ty::{self, FloatTy, IntTy, PolyFnSig, Ty},\n };\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -73,6 +74,7 @@ impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n     /// Check whether a passed literal has potential to cause fallback or not.\n     fn check_lit(&self, lit: &Lit, lit_ty: Ty<'tcx>) {\n         if_chain! {\n+                if !in_external_macro(self.cx.sess(), lit.span);\n                 if let Some(ty_bound) = self.ty_bounds.last();\n                 if matches!(lit.node,\n                             LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed));"}, {"sha": "2933fbc93418add393c3e579405cf233845b6d1b", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -149,7 +149,7 @@ declare_deprecated_lint! {\n     /// enables the `enum_variant_names` lint for public items.\n     /// ```\n     pub PUB_ENUM_VARIANT_NAMES,\n-    \"set the `avoid_breaking_exported_api` config option to `false` to enable the `enum_variant_names` lint for public items\"\n+    \"set the `avoid-breaking-exported-api` config option to `false` to enable the `enum_variant_names` lint for public items\"\n }\n \n declare_deprecated_lint! {\n@@ -158,5 +158,5 @@ declare_deprecated_lint! {\n     /// **Deprecation reason:** The `avoid_breaking_exported_api` config option was added, which\n     /// enables the `wrong_self_conversion` lint for public items.\n     pub WRONG_PUB_SELF_CONVENTION,\n-    \"set the `avoid_breaking_exported_api` config option to `false` to enable the `wrong_self_convention` lint for public items\"\n+    \"set the `avoid-breaking-exported-api` config option to `false` to enable the `wrong_self_convention` lint for public items\"\n }"}, {"sha": "3ac20fd9849eef656fb2cccb4ea2f7f53c426fb7", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -410,11 +410,8 @@ impl<'tcx> Visitor<'tcx> for UnsafeVisitor<'_, 'tcx> {\n         }\n \n         if let ExprKind::Block(block, _) = expr.kind {\n-            match block.rules {\n-                BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) => {\n-                    self.has_unsafe = true;\n-                },\n-                _ => {},\n+            if let BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) = block.rules {\n+                self.has_unsafe = true;\n             }\n         }\n "}, {"sha": "aa1a609afedc0b91edfac0fbd4e3720d327f423b", "filename": "clippy_lints/src/disallowed_method.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdisallowed_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdisallowed_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_method.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint;\n use clippy_utils::fn_def_id;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::Expr;\n+use rustc_hir::{def::Res, def_id::DefId, Crate, Expr};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Symbol;\n@@ -13,21 +13,14 @@ declare_clippy_lint! {\n     /// **Why is this bad?** Some methods are undesirable in certain contexts,\n     /// and it's beneficial to lint for them as needed.\n     ///\n-    /// **Known problems:** Currently, you must write each function as a\n-    /// fully-qualified path. This lint doesn't support aliases or reexported\n-    /// names; be aware that many types in `std` are actually reexports.\n-    ///\n-    /// For example, if you want to disallow `Duration::as_secs`, your clippy.toml\n-    /// configuration would look like\n-    /// `disallowed-methods = [\"core::time::Duration::as_secs\"]` and not\n-    /// `disallowed-methods = [\"std::time::Duration::as_secs\"]` as you might expect.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     ///\n     /// An example clippy.toml configuration:\n     /// ```toml\n     /// # clippy.toml\n-    /// disallowed-methods = [\"alloc::vec::Vec::leak\", \"std::time::Instant::now\"]\n+    /// disallowed-methods = [\"std::vec::Vec::leak\", \"std::time::Instant::now\"]\n     /// ```\n     ///\n     /// ```rust,ignore\n@@ -52,6 +45,7 @@ declare_clippy_lint! {\n #[derive(Clone, Debug)]\n pub struct DisallowedMethod {\n     disallowed: FxHashSet<Vec<Symbol>>,\n+    def_ids: FxHashSet<(DefId, Vec<Symbol>)>,\n }\n \n impl DisallowedMethod {\n@@ -61,17 +55,28 @@ impl DisallowedMethod {\n                 .iter()\n                 .map(|s| s.split(\"::\").map(|seg| Symbol::intern(seg)).collect::<Vec<_>>())\n                 .collect(),\n+            def_ids: FxHashSet::default(),\n         }\n     }\n }\n \n impl_lint_pass!(DisallowedMethod => [DISALLOWED_METHOD]);\n \n impl<'tcx> LateLintPass<'tcx> for DisallowedMethod {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        for path in &self.disallowed {\n+            let segs = path.iter().map(ToString::to_string).collect::<Vec<_>>();\n+            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs.iter().map(String::as_str).collect::<Vec<_>>())\n+            {\n+                self.def_ids.insert((id, path.clone()));\n+            }\n+        }\n+    }\n+\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some(def_id) = fn_def_id(cx, expr) {\n-            let func_path = cx.get_def_path(def_id);\n-            if self.disallowed.contains(&func_path) {\n+            if self.def_ids.iter().any(|(id, _)| def_id == *id) {\n+                let func_path = cx.get_def_path(def_id);\n                 let func_path_string = func_path\n                     .into_iter()\n                     .map(Symbol::to_ident_string)"}, {"sha": "12c525634c51d77b348c9612564fa1c27ba14855", "filename": "clippy_lints/src/disallowed_script_idents.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,112 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_lint::{EarlyContext, EarlyLintPass, Level};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use unicode_script::{Script, UnicodeScript};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of unicode scripts other than those explicitly allowed\n+    /// by the lint config.\n+    ///\n+    /// This lint doesn't take into account non-text scripts such as `Unknown` and `Linear_A`.\n+    /// It also ignores the `Common` script type.\n+    /// While configuring, be sure to use official script name [aliases] from\n+    /// [the list of supported scripts][supported_scripts].\n+    ///\n+    /// See also: [`non_ascii_idents`].\n+    ///\n+    /// [aliases]: http://www.unicode.org/reports/tr24/tr24-31.html#Script_Value_Aliases\n+    /// [supported_scripts]: https://www.unicode.org/iso15924/iso15924-codes.html\n+    ///\n+    /// **Why is this bad?** It may be not desired to have many different scripts for\n+    /// identifiers in the codebase.\n+    ///\n+    /// Note that if you only want to allow plain English, you might want to use\n+    /// built-in [`non_ascii_idents`] lint instead.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Assuming that `clippy.toml` contains the following line:\n+    /// // allowed-locales = [\"Latin\", \"Cyrillic\"]\n+    /// let counter = 10; // OK, latin is allowed.\n+    /// let \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // OK, cyrillic is allowed.\n+    /// let z\u00e4hler = 10; // OK, it's still latin.\n+    /// let \u30ab\u30a6\u30f3\u30bf = 10; // Will spawn the lint.\n+    /// ```\n+    pub DISALLOWED_SCRIPT_IDENTS,\n+    restriction,\n+    \"usage of non-allowed Unicode scripts\"\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct DisallowedScriptIdents {\n+    whitelist: FxHashSet<Script>,\n+}\n+\n+impl DisallowedScriptIdents {\n+    pub fn new(whitelist: &[String]) -> Self {\n+        let whitelist = whitelist\n+            .iter()\n+            .map(String::as_str)\n+            .filter_map(Script::from_full_name)\n+            .collect();\n+        Self { whitelist }\n+    }\n+}\n+\n+impl_lint_pass!(DisallowedScriptIdents => [DISALLOWED_SCRIPT_IDENTS]);\n+\n+impl EarlyLintPass for DisallowedScriptIdents {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, _: &ast::Crate) {\n+        // Implementation is heavily inspired by the implementation of [`non_ascii_idents`] lint:\n+        // https://github.com/rust-lang/rust/blob/master/compiler/rustc_lint/src/non_ascii_idents.rs\n+\n+        let check_disallowed_script_idents = cx.builder.lint_level(DISALLOWED_SCRIPT_IDENTS).0 != Level::Allow;\n+        if !check_disallowed_script_idents {\n+            return;\n+        }\n+\n+        let symbols = cx.sess.parse_sess.symbol_gallery.symbols.lock();\n+        // Sort by `Span` so that error messages make sense with respect to the\n+        // order of identifier locations in the code.\n+        let mut symbols: Vec<_> = symbols.iter().collect();\n+        symbols.sort_unstable_by_key(|k| k.1);\n+\n+        for (symbol, &span) in &symbols {\n+            // Note: `symbol.as_str()` is an expensive operation, thus should not be called\n+            // more than once for a single symbol.\n+            let symbol_str = symbol.as_str();\n+            if symbol_str.is_ascii() {\n+                continue;\n+            }\n+\n+            for c in symbol_str.chars() {\n+                // We want to iterate through all the scripts associated with this character\n+                // and check whether at least of one scripts is in the whitelist.\n+                let forbidden_script = c\n+                    .script_extension()\n+                    .iter()\n+                    .find(|script| !self.whitelist.contains(script));\n+                if let Some(script) = forbidden_script {\n+                    span_lint(\n+                        cx,\n+                        DISALLOWED_SCRIPT_IDENTS,\n+                        span,\n+                        &format!(\n+                            \"identifier `{}` has a Unicode script that is not allowed by configuration: {}\",\n+                            symbol_str,\n+                            script.full_name()\n+                        ),\n+                    );\n+                    // We don't want to spawn warning multiple times over a single identifier.\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "e4a88c6324ebfdac3958c208b1d2251194deb6e4", "filename": "clippy_lints/src/disallowed_type.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdisallowed_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdisallowed_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_type.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,126 @@\n+use clippy_utils::diagnostics::span_lint;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{\n+    def::Res, def_id::DefId, Crate, Item, ItemKind, PolyTraitRef, TraitBoundModifier, Ty, TyKind, UseKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{Span, Symbol};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Denies the configured types in clippy.toml.\n+    ///\n+    /// **Why is this bad?** Some types are undesirable in certain contexts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// N.B. There is no way to ban primitive types.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// An example clippy.toml configuration:\n+    /// ```toml\n+    /// # clippy.toml\n+    /// disallowed-methods = [\"std::collections::BTreeMap\"]\n+    /// ```\n+    ///\n+    /// ```rust,ignore\n+    /// use std::collections::BTreeMap;\n+    /// // or its use\n+    /// let x = std::collections::BTreeMap::new();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// // A similar type that is allowed by the config\n+    /// use std::collections::HashMap;\n+    /// ```\n+    pub DISALLOWED_TYPE,\n+    nursery,\n+    \"use of a disallowed type\"\n+}\n+#[derive(Clone, Debug)]\n+pub struct DisallowedType {\n+    disallowed: FxHashSet<Vec<Symbol>>,\n+    def_ids: FxHashSet<(DefId, Vec<Symbol>)>,\n+}\n+\n+impl DisallowedType {\n+    pub fn new(disallowed: &FxHashSet<String>) -> Self {\n+        Self {\n+            disallowed: disallowed\n+                .iter()\n+                .map(|s| s.split(\"::\").map(|seg| Symbol::intern(seg)).collect::<Vec<_>>())\n+                .collect(),\n+            def_ids: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(DisallowedType => [DISALLOWED_TYPE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for DisallowedType {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        for path in &self.disallowed {\n+            let segs = path.iter().map(ToString::to_string).collect::<Vec<_>>();\n+            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs.iter().map(String::as_str).collect::<Vec<_>>())\n+            {\n+                self.def_ids.insert((id, path.clone()));\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if_chain! {\n+            if let ItemKind::Use(path, UseKind::Single) = &item.kind;\n+            if let Res::Def(_, did) = path.res;\n+            if let Some((_, name)) = self.def_ids.iter().find(|(id, _)| *id == did);\n+            then {\n+                emit(cx, name, item.span,);\n+            }\n+        }\n+    }\n+\n+    fn check_ty(&mut self, cx: &LateContext<'tcx>, ty: &'tcx Ty<'tcx>) {\n+        if_chain! {\n+            if let TyKind::Path(path) = &ty.kind;\n+            if let Some(did) = cx.qpath_res(path, ty.hir_id).opt_def_id();\n+            if let Some((_, name)) = self.def_ids.iter().find(|(id, _)| *id == did);\n+            then {\n+                emit(cx, name, path.span());\n+            }\n+        }\n+    }\n+\n+    fn check_poly_trait_ref(&mut self, cx: &LateContext<'tcx>, poly: &'tcx PolyTraitRef<'tcx>, _: TraitBoundModifier) {\n+        if_chain! {\n+            if let Res::Def(_, did) = poly.trait_ref.path.res;\n+            if let Some((_, name)) = self.def_ids.iter().find(|(id, _)| *id == did);\n+            then {\n+                emit(cx, name, poly.trait_ref.path.span);\n+            }\n+        }\n+    }\n+\n+    // TODO: if non primitive const generics are a thing\n+    // fn check_generic_arg(&mut self, cx: &LateContext<'tcx>, arg: &'tcx GenericArg<'tcx>) {\n+    //     match arg {\n+    //         GenericArg::Const(c) => {},\n+    //     }\n+    // }\n+    // fn check_generic_param(&mut self, cx: &LateContext<'tcx>, param: &'tcx GenericParam<'tcx>) {\n+    //     match param.kind {\n+    //         GenericParamKind::Const { .. } => {},\n+    //     }\n+    // }\n+}\n+\n+fn emit(cx: &LateContext<'_>, name: &[Symbol], span: Span) {\n+    let name = name.iter().map(|s| s.to_ident_string()).collect::<Vec<_>>().join(\"::\");\n+    span_lint(\n+        cx,\n+        DISALLOWED_TYPE,\n+        span,\n+        &format!(\"`{}` is not allowed according to config\", name),\n+    );\n+}"}, {"sha": "4e164d33a0512b5ef15a909c82f52247520876df", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,4 +1,5 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_note};\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_note};\n+use clippy_utils::source::first_line_of_span;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use clippy_utils::{is_entrypoint_fn, is_expn_of, match_panic_def_id, method_chain_args, return_ty};\n use if_chain::if_chain;\n@@ -37,7 +38,8 @@ declare_clippy_lint! {\n     /// consider that.\n     ///\n     /// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks\n-    /// for is limited, and there are still false positives.\n+    /// for is limited, and there are still false positives. HTML elements and their\n+    /// content are not linted.\n     ///\n     /// In addition, when writing documentation comments, including `[]` brackets\n     /// inside a link text would trip the parser. Therfore, documenting link with\n@@ -469,11 +471,11 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     spans: &[(usize, Span)],\n ) -> DocHeaders {\n     // true if a safety header was found\n-    use pulldown_cmark::CodeBlockKind;\n     use pulldown_cmark::Event::{\n         Code, End, FootnoteReference, HardBreak, Html, Rule, SoftBreak, Start, TaskListMarker, Text,\n     };\n-    use pulldown_cmark::Tag::{CodeBlock, Heading, Link};\n+    use pulldown_cmark::Tag::{CodeBlock, Heading, Item, Link, Paragraph};\n+    use pulldown_cmark::{CodeBlockKind, CowStr};\n \n     let mut headers = DocHeaders {\n         safety: false,\n@@ -485,6 +487,9 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     let mut in_heading = false;\n     let mut is_rust = false;\n     let mut edition = None;\n+    let mut ticks_unbalanced = false;\n+    let mut text_to_check: Vec<(CowStr<'_>, Span)> = Vec::new();\n+    let mut paragraph_span = spans.get(0).expect(\"function isn't called if doc comment is empty\").1;\n     for (event, range) in events {\n         match event {\n             Start(CodeBlock(ref kind)) => {\n@@ -510,13 +515,42 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n             },\n             Start(Link(_, url, _)) => in_link = Some(url),\n             End(Link(..)) => in_link = None,\n-            Start(Heading(_)) => in_heading = true,\n-            End(Heading(_)) => in_heading = false,\n+            Start(Heading(_) | Paragraph | Item) => {\n+                if let Start(Heading(_)) = event {\n+                    in_heading = true;\n+                }\n+                ticks_unbalanced = false;\n+                let (_, span) = get_current_span(spans, range.start);\n+                paragraph_span = first_line_of_span(cx, span);\n+            },\n+            End(Heading(_) | Paragraph | Item) => {\n+                if let End(Heading(_)) = event {\n+                    in_heading = false;\n+                }\n+                if ticks_unbalanced {\n+                    span_lint_and_help(\n+                        cx,\n+                        DOC_MARKDOWN,\n+                        paragraph_span,\n+                        \"backticks are unbalanced\",\n+                        None,\n+                        \"a backtick may be missing a pair\",\n+                    );\n+                } else {\n+                    for (text, span) in text_to_check {\n+                        check_text(cx, valid_idents, &text, span);\n+                    }\n+                }\n+                text_to_check = Vec::new();\n+            },\n             Start(_tag) | End(_tag) => (), // We don't care about other tags\n             Html(_html) => (),             // HTML is weird, just ignore it\n             SoftBreak | HardBreak | TaskListMarker(_) | Code(_) | Rule => (),\n             FootnoteReference(text) | Text(text) => {\n-                if Some(&text) == in_link.as_ref() {\n+                let (begin, span) = get_current_span(spans, range.start);\n+                paragraph_span = paragraph_span.with_hi(span.hi());\n+                ticks_unbalanced |= text.contains('`');\n+                if Some(&text) == in_link.as_ref() || ticks_unbalanced {\n                     // Probably a link of the form `<http://example.com>`\n                     // Which are represented as a link to \"http://example.com\" with\n                     // text \"http://example.com\" by pulldown-cmark\n@@ -525,11 +559,6 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n                 headers.safety |= in_heading && text.trim() == \"Safety\";\n                 headers.errors |= in_heading && text.trim() == \"Errors\";\n                 headers.panics |= in_heading && text.trim() == \"Panics\";\n-                let index = match spans.binary_search_by(|c| c.0.cmp(&range.start)) {\n-                    Ok(o) => o,\n-                    Err(e) => e - 1,\n-                };\n-                let (begin, span) = spans[index];\n                 if in_code {\n                     if is_rust {\n                         let edition = edition.unwrap_or_else(|| cx.tcx.sess.edition());\n@@ -538,15 +567,22 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n                 } else {\n                     // Adjust for the beginning of the current `Event`\n                     let span = span.with_lo(span.lo() + BytePos::from_usize(range.start - begin));\n-\n-                    check_text(cx, valid_idents, &text, span);\n+                    text_to_check.push((text, span));\n                 }\n             },\n         }\n     }\n     headers\n }\n \n+fn get_current_span(spans: &[(usize, Span)], idx: usize) -> (usize, Span) {\n+    let index = match spans.binary_search_by(|c| c.0.cmp(&idx)) {\n+        Ok(o) => o,\n+        Err(e) => e - 1,\n+    };\n+    spans[index]\n+}\n+\n fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n     fn has_needless_main(code: &str, edition: Edition) -> bool {\n         rustc_driver::catch_fatal_errors(|| {"}, {"sha": "03a8b40df555fde5f0f4c1c1480571d000d9dc91", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -38,7 +38,7 @@ declare_clippy_lint! {\n     /// let a = tmp + x;\n     /// ```\n     pub EVAL_ORDER_DEPENDENCE,\n-    complexity,\n+    suspicious,\n     \"whether a variable read occurs before a write depends on sub-expression evaluation order\"\n }\n "}, {"sha": "1e503cc795ccbb70d9ec7c2fb002b703d5ef5c24", "filename": "clippy_lints/src/float_equality_without_abs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -36,7 +36,7 @@ declare_clippy_lint! {\n      /// }\n      /// ```\n     pub FLOAT_EQUALITY_WITHOUT_ABS,\n-    correctness,\n+    suspicious,\n     \"float equality check without `.abs()`\"\n }\n "}, {"sha": "8aefb8d46f6e843115d9d90d3658d1ae4f280dd0", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -22,7 +22,7 @@ declare_clippy_lint! {\n     /// a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n     /// ```\n     pub SUSPICIOUS_ASSIGNMENT_FORMATTING,\n-    style,\n+    suspicious,\n     \"suspicious formatting of `*=`, `-=` or `!=`\"\n }\n \n@@ -44,7 +44,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub SUSPICIOUS_UNARY_OP_FORMATTING,\n-    style,\n+    suspicious,\n     \"suspicious formatting of unary `-` or `!` on the RHS of a BinOp\"\n }\n \n@@ -80,7 +80,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub SUSPICIOUS_ELSE_FORMATTING,\n-    style,\n+    suspicious,\n     \"suspicious formatting of `else`\"\n }\n "}, {"sha": "8e45fdfecc447a641ec2882c80f41a2fe779f88b", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n \n             // LHS of subtraction is \"x.len()\"\n             if let ExprKind::MethodCall(arg_lhs_path, _, lhs_args, _) = &lhs.kind;\n-            if arg_lhs_path.ident.name == sym!(len);\n+            if arg_lhs_path.ident.name == sym::len;\n             if let Some(arg_lhs_struct) = lhs_args.get(0);\n \n             // The two vectors referenced (x in x.get(...) and in x.len())"}, {"sha": "5403d76ea30c8774c4f5c64e2b26a73a8821c3ab", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n     }\n }\n \n-/// Checks if `Mutex::lock` is called in the `if let _ = expr.\n+/// Checks if `Mutex::lock` is called in the `if let` expr.\n pub struct OppVisitor<'a, 'tcx> {\n     mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,"}, {"sha": "d69187f67466dd991ed1c5b046861255be1da678", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if_chain! {\n-            if item.ident.as_str() == \"len\";\n+            if item.ident.name == sym::len;\n             if let ImplItemKind::Fn(sig, _) = &item.kind;\n             if sig.decl.implicit_self.has_implicit_self();\n             if cx.access_levels.is_exported(item.hir_id());\n@@ -189,8 +189,8 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n }\n \n fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items: &[TraitItemRef]) {\n-    fn is_named_self(cx: &LateContext<'_>, item: &TraitItemRef, name: &str) -> bool {\n-        item.ident.name.as_str() == name\n+    fn is_named_self(cx: &LateContext<'_>, item: &TraitItemRef, name: Symbol) -> bool {\n+        item.ident.name == name\n             && if let AssocItemKind::Fn { has_self } = item.kind {\n                 has_self && { cx.tcx.fn_sig(item.id.def_id).inputs().skip_binder().len() == 1 }\n             } else {\n@@ -207,7 +207,9 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.hir_id()) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n+    if cx.access_levels.is_exported(visited_trait.hir_id())\n+        && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n+    {\n         let mut current_and_super_traits = DefIdSet::default();\n         fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n \n@@ -401,7 +403,7 @@ fn check_len(\n             return;\n         }\n \n-        if method_name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if method_name == sym::len && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "e0325738466bec902564ee0c4138862bfd4365d5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 55, "deletions": 27, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -60,9 +60,9 @@ use rustc_session::Session;\n /// 4. The `description` that contains a short explanation on what's wrong with code where the\n ///    lint is triggered.\n ///\n-/// Currently the categories `style`, `correctness`, `complexity` and `perf` are enabled by default.\n-/// As said in the README.md of this repository, if the lint level mapping changes, please update\n-/// README.md.\n+/// Currently the categories `style`, `correctness`, `suspicious`, `complexity` and `perf` are\n+/// enabled by default. As said in the README.md of this repository, if the lint level mapping\n+/// changes, please update README.md.\n ///\n /// # Example\n ///\n@@ -106,6 +106,11 @@ macro_rules! declare_clippy_lint {\n             $(#[$attr])* pub clippy::$name, Deny, $description, report_in_external_macro: true\n         }\n     };\n+    { $(#[$attr:meta])* pub $name:tt, suspicious, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n+    };\n     { $(#[$attr:meta])* pub $name:tt, complexity, $description:tt } => {\n         declare_tool_lint! {\n             $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n@@ -187,6 +192,8 @@ mod default_numeric_fallback;\n mod dereference;\n mod derive;\n mod disallowed_method;\n+mod disallowed_script_idents;\n+mod disallowed_type;\n mod doc;\n mod double_comparison;\n mod double_parens;\n@@ -254,7 +261,6 @@ mod manual_strip;\n mod manual_unwrap_or;\n mod map_clone;\n mod map_err_ignore;\n-mod map_identity;\n mod map_unit_fn;\n mod match_on_vec_items;\n mod matches;\n@@ -267,6 +273,7 @@ mod misc;\n mod misc_early;\n mod missing_const_for_fn;\n mod missing_doc;\n+mod missing_enforced_import_rename;\n mod missing_inline;\n mod modulo_arithmetic;\n mod multiple_crate_versions;\n@@ -293,6 +300,7 @@ mod no_effect;\n mod non_copy_const;\n mod non_expressive_names;\n mod non_octal_unix_permissions;\n+mod nonstandard_macro_braces;\n mod open_options;\n mod option_env_unwrap;\n mod option_if_let_else;\n@@ -483,11 +491,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     );\n     store.register_removed(\n         \"clippy::pub_enum_variant_names\",\n-        \"set the `avoid_breaking_exported_api` config option to `false` to enable the `enum_variant_names` lint for public items\",\n+        \"set the `avoid-breaking-exported-api` config option to `false` to enable the `enum_variant_names` lint for public items\",\n     );\n     store.register_removed(\n         \"clippy::wrong_pub_self_convention\",\n-        \"set the `avoid_breaking_exported_api` config option to `false` to enable the `wrong_self_convention` lint for public items\",\n+        \"set the `avoid-breaking-exported-api` config option to `false` to enable the `wrong_self_convention` lint for public items\",\n     );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n@@ -583,6 +591,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         derive::EXPL_IMPL_CLONE_ON_COPY,\n         derive::UNSAFE_DERIVE_DESERIALIZE,\n         disallowed_method::DISALLOWED_METHOD,\n+        disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS,\n+        disallowed_type::DISALLOWED_TYPE,\n         doc::DOC_MARKDOWN,\n         doc::MISSING_ERRORS_DOC,\n         doc::MISSING_PANICS_DOC,\n@@ -705,7 +715,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         manual_unwrap_or::MANUAL_UNWRAP_OR,\n         map_clone::MAP_CLONE,\n         map_err_ignore::MAP_ERR_IGNORE,\n-        map_identity::MAP_IDENTITY,\n         map_unit_fn::OPTION_MAP_UNIT_FN,\n         map_unit_fn::RESULT_MAP_UNIT_FN,\n         match_on_vec_items::MATCH_ON_VEC_ITEMS,\n@@ -730,6 +739,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n         mem_replace::MEM_REPLACE_WITH_DEFAULT,\n         mem_replace::MEM_REPLACE_WITH_UNINIT,\n+        methods::APPEND_INSTEAD_OF_EXTEND,\n         methods::BIND_INSTEAD_OF_MAP,\n         methods::BYTES_NTH,\n         methods::CHARS_LAST_CMP,\n@@ -765,6 +775,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::MANUAL_STR_REPEAT,\n         methods::MAP_COLLECT_RESULT_UNIT,\n         methods::MAP_FLATTEN,\n+        methods::MAP_IDENTITY,\n         methods::MAP_UNWRAP_OR,\n         methods::NEW_RET_NO_SELF,\n         methods::OK_EXPECT,\n@@ -810,6 +821,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         misc_early::ZERO_PREFIXED_LITERAL,\n         missing_const_for_fn::MISSING_CONST_FOR_FN,\n         missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n+        missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES,\n         missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS,\n         modulo_arithmetic::MODULO_ARITHMETIC,\n         multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n@@ -843,6 +855,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         non_expressive_names::MANY_SINGLE_CHAR_NAMES,\n         non_expressive_names::SIMILAR_NAMES,\n         non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS,\n+        nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n         open_options::NONSENSICAL_OPEN_OPTIONS,\n         option_env_unwrap::OPTION_ENV_UNWRAP,\n         option_if_let_else::OPTION_IF_LET_ELSE,\n@@ -989,6 +1002,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(create_dir::CREATE_DIR),\n         LintId::of(dbg_macro::DBG_MACRO),\n         LintId::of(default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n+        LintId::of(disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS),\n         LintId::of(else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n         LintId::of(exhaustive_items::EXHAUSTIVE_ENUMS),\n         LintId::of(exhaustive_items::EXHAUSTIVE_STRUCTS),\n@@ -1013,6 +1027,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(misc::FLOAT_CMP_CONST),\n         LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n         LintId::of(missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n+        LintId::of(missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES),\n         LintId::of(missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n         LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n         LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n@@ -1090,6 +1105,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::CLONED_INSTEAD_OF_COPIED),\n         LintId::of(methods::FILTER_MAP_NEXT),\n         LintId::of(methods::FLAT_MAP_OPTION),\n+        LintId::of(methods::FROM_ITER_INSTEAD_OF_COLLECT),\n         LintId::of(methods::IMPLICIT_CLONE),\n         LintId::of(methods::INEFFICIENT_TO_STRING),\n         LintId::of(methods::MAP_FLATTEN),\n@@ -1260,7 +1276,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(manual_strip::MANUAL_STRIP),\n         LintId::of(manual_unwrap_or::MANUAL_UNWRAP_OR),\n         LintId::of(map_clone::MAP_CLONE),\n-        LintId::of(map_identity::MAP_IDENTITY),\n         LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n@@ -1276,6 +1291,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n         LintId::of(mem_replace::MEM_REPLACE_WITH_DEFAULT),\n         LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n+        LintId::of(methods::APPEND_INSTEAD_OF_EXTEND),\n         LintId::of(methods::BIND_INSTEAD_OF_MAP),\n         LintId::of(methods::BYTES_NTH),\n         LintId::of(methods::CHARS_LAST_CMP),\n@@ -1286,7 +1302,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::FILTER_MAP_IDENTITY),\n         LintId::of(methods::FILTER_NEXT),\n         LintId::of(methods::FLAT_MAP_IDENTITY),\n-        LintId::of(methods::FROM_ITER_INSTEAD_OF_COLLECT),\n         LintId::of(methods::INSPECT_FOR_EACH),\n         LintId::of(methods::INTO_ITER_ON_REF),\n         LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n@@ -1301,6 +1316,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n         LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n+        LintId::of(methods::MAP_IDENTITY),\n         LintId::of(methods::NEW_RET_NO_SELF),\n         LintId::of(methods::OK_EXPECT),\n         LintId::of(methods::OPTION_AS_REF_DEREF),\n@@ -1359,6 +1375,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n         LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n         LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n+        LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n         LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n         LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n         LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n@@ -1447,7 +1464,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n         LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n         LintId::of(assign_ops::ASSIGN_OP_PATTERN),\n-        LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n@@ -1465,9 +1481,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(eq_op::OP_REF),\n         LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n         LintId::of(float_literal::EXCESSIVE_PRECISION),\n-        LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n-        LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n-        LintId::of(formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n         LintId::of(from_over_into::FROM_OVER_INTO),\n         LintId::of(from_str_radix_10::FROM_STR_RADIX_10),\n         LintId::of(functions::DOUBLE_MUST_USE),\n@@ -1480,7 +1493,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(len_zero::LEN_ZERO),\n         LintId::of(literal_representation::INCONSISTENT_DIGIT_GROUPING),\n         LintId::of(literal_representation::UNUSUAL_BYTE_GROUPINGS),\n-        LintId::of(loops::EMPTY_LOOP),\n         LintId::of(loops::FOR_KV_MAP),\n         LintId::of(loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(loops::SAME_ITEM_PUSH),\n@@ -1501,7 +1513,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::BYTES_NTH),\n         LintId::of(methods::CHARS_LAST_CMP),\n         LintId::of(methods::CHARS_NEXT_CMP),\n-        LintId::of(methods::FROM_ITER_INSTEAD_OF_COLLECT),\n         LintId::of(methods::INTO_ITER_ON_REF),\n         LintId::of(methods::ITER_CLONED_COLLECT),\n         LintId::of(methods::ITER_NEXT_SLICE),\n@@ -1535,6 +1546,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n         LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n         LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n+        LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n         LintId::of(ptr::CMP_NULL),\n         LintId::of(ptr::PTR_ARG),\n         LintId::of(ptr_eq::PTR_EQ),\n@@ -1560,7 +1572,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n \n     store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec![\n-        LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n         LintId::of(attrs::DEPRECATED_CFG_ATTR),\n         LintId::of(booleans::NONMINIMAL_BOOL),\n         LintId::of(casts::CHAR_LIT_AS_U8),\n@@ -1570,7 +1581,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(double_parens::DOUBLE_PARENS),\n         LintId::of(duration_subsec::DURATION_SUBSEC),\n         LintId::of(eval_order_dependence::DIVERGING_SUB_EXPRESSION),\n-        LintId::of(eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n         LintId::of(explicit_write::EXPLICIT_WRITE),\n         LintId::of(format::USELESS_FORMAT),\n         LintId::of(functions::TOO_MANY_ARGUMENTS),\n@@ -1581,12 +1591,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(lifetimes::NEEDLESS_LIFETIMES),\n         LintId::of(loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(loops::MANUAL_FLATTEN),\n-        LintId::of(loops::MUT_RANGE_BOUND),\n         LintId::of(loops::SINGLE_ELEMENT_LOOP),\n         LintId::of(loops::WHILE_LET_LOOP),\n         LintId::of(manual_strip::MANUAL_STRIP),\n         LintId::of(manual_unwrap_or::MANUAL_UNWRAP_OR),\n-        LintId::of(map_identity::MAP_IDENTITY),\n         LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(matches::MATCH_AS_REF),\n@@ -1601,11 +1609,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::ITER_COUNT),\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n+        LintId::of(methods::MAP_IDENTITY),\n         LintId::of(methods::OPTION_AS_REF_DEREF),\n         LintId::of(methods::OPTION_FILTER_MAP),\n         LintId::of(methods::SEARCH_IS_SOME),\n         LintId::of(methods::SKIP_WHILE_NEXT),\n-        LintId::of(methods::SUSPICIOUS_MAP),\n         LintId::of(methods::UNNECESSARY_FILTER_MAP),\n         LintId::of(methods::USELESS_ASREF),\n         LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n@@ -1674,7 +1682,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n         LintId::of(eq_op::EQ_OP),\n         LintId::of(erasing_op::ERASING_OP),\n-        LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n         LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n         LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n         LintId::of(if_let_mutex::IF_LET_MUTEX),\n@@ -1684,7 +1691,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(inline_fn_without_body::INLINE_FN_WITHOUT_BODY),\n         LintId::of(let_underscore::LET_UNDERSCORE_LOCK),\n         LintId::of(literal_representation::MISTYPED_LITERAL_SUFFIXES),\n-        LintId::of(loops::FOR_LOOPS_OVER_FALLIBLES),\n         LintId::of(loops::ITER_NEXT_LOOP),\n         LintId::of(loops::NEVER_LOOP),\n         LintId::of(loops::WHILE_IMMUTABLE_CONDITION),\n@@ -1699,7 +1705,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(misc::CMP_NAN),\n         LintId::of(misc::FLOAT_CMP),\n         LintId::of(misc::MODULO_ONE),\n-        LintId::of(mut_key::MUTABLE_KEY_TYPE),\n         LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n         LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n         LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n@@ -1710,8 +1715,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(self_assignment::SELF_ASSIGNMENT),\n         LintId::of(serde_api::SERDE_API_MISUSE),\n         LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n-        LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n-        LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(swap::ALMOST_SWAPPED),\n         LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n         LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n@@ -1728,13 +1731,31 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n     ]);\n \n+    store.register_group(true, \"clippy::suspicious\", None, vec![\n+        LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n+        LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n+        LintId::of(eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n+        LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n+        LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n+        LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n+        LintId::of(formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n+        LintId::of(loops::EMPTY_LOOP),\n+        LintId::of(loops::FOR_LOOPS_OVER_FALLIBLES),\n+        LintId::of(loops::MUT_RANGE_BOUND),\n+        LintId::of(methods::SUSPICIOUS_MAP),\n+        LintId::of(mut_key::MUTABLE_KEY_TYPE),\n+        LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n+        LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n+    ]);\n+\n     store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n         LintId::of(entry::MAP_ENTRY),\n         LintId::of(escape::BOXED_LOCAL),\n         LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n         LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n         LintId::of(loops::MANUAL_MEMCPY),\n         LintId::of(loops::NEEDLESS_COLLECT),\n+        LintId::of(methods::APPEND_INSTEAD_OF_EXTEND),\n         LintId::of(methods::EXPECT_FUN_CALL),\n         LintId::of(methods::ITER_NTH),\n         LintId::of(methods::MANUAL_STR_REPEAT),\n@@ -1761,6 +1782,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n         LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n         LintId::of(disallowed_method::DISALLOWED_METHOD),\n+        LintId::of(disallowed_type::DISALLOWED_TYPE),\n         LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n         LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),\n         LintId::of(floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n@@ -2038,8 +2060,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold,\n     });\n+    let macro_matcher = conf.standard_macro_braces.iter().cloned().collect::<FxHashSet<_>>();\n+    store.register_early_pass(move || box nonstandard_macro_braces::MacroBraces::new(&macro_matcher));\n     store.register_late_pass(|| box macro_use::MacroUseImports::default());\n-    store.register_late_pass(|| box map_identity::MapIdentity);\n     store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n     store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n@@ -2066,7 +2089,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box if_then_some_else_none::IfThenSomeElseNone::new(msrv));\n     store.register_early_pass(|| box bool_assert_comparison::BoolAssertComparison);\n     store.register_late_pass(|| box unused_async::UnusedAsync);\n-\n+    let disallowed_types = conf.disallowed_types.iter().cloned().collect::<FxHashSet<_>>();\n+    store.register_late_pass(move || box disallowed_type::DisallowedType::new(&disallowed_types));\n+    let import_renames = conf.enforced_import_renames.clone();\n+    store.register_late_pass(move || box missing_enforced_import_rename::ImportRename::new(import_renames.clone()));\n+    let scripts = conf.allowed_scripts.clone();\n+    store.register_early_pass(move || box disallowed_script_idents::DisallowedScriptIdents::new(&scripts));\n }\n \n #[rustfmt::skip]"}, {"sha": "7d5ed3ab0a751ff67101324c4479fdf138981f04", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -118,7 +118,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n         if_chain! {\n             if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n-            if method.ident.name == sym!(len);\n+            if method.ident.name == sym::len;\n             if len_args.len() == 1;\n             if let Some(arg) = len_args.get(0);\n             if path_to_local(arg) == path_to_local(base);\n@@ -204,11 +204,8 @@ struct MinifyingSugg<'a>(Sugg<'a>);\n \n impl<'a> MinifyingSugg<'a> {\n     fn as_str(&self) -> &str {\n-        // HACK: Don't sync to Clippy! Required because something with the `or_patterns` feature\n-        // changed and this would now require parentheses.\n-        match &self.0 {\n-            Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) => s.as_ref(),\n-        }\n+        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n+        s.as_ref()\n     }\n \n     fn into_sugg(self) -> Sugg<'a> {"}, {"sha": "56a123b69c6aec1de3d3bf1ea6140a13c29da0eb", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -199,7 +199,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub FOR_LOOPS_OVER_FALLIBLES,\n-    correctness,\n+    suspicious,\n     \"for-looping over an `Option` or a `Result`, which is more clearly expressed as an `if let`\"\n }\n \n@@ -313,7 +313,7 @@ declare_clippy_lint! {\n     /// loop {}\n     /// ```\n     pub EMPTY_LOOP,\n-    style,\n+    suspicious,\n     \"empty `loop {}`, which should block or sleep\"\n }\n \n@@ -401,7 +401,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub MUT_RANGE_BOUND,\n-    complexity,\n+    suspicious,\n     \"for loop over a range where one of the bounds is a mutable variable\"\n }\n "}, {"sha": "51d7def137e409eea10816378e774726fb29e026", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 36, "deletions": 61, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -7,10 +7,10 @@ use clippy_utils::{is_trait_method, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, GenericArg, GenericArgs, HirId, Local, Pat, PatKind, QPath, StmtKind, Ty};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n@@ -24,10 +24,8 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n         if let ExprKind::MethodCall(chain_method, method0_span, _, _) = args[0].kind;\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n-        if let Some(generic_args) = chain_method.args;\n-        if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n-        if let Some(ty) = cx.typeck_results().node_type_opt(ty.hir_id);\n         then {\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n             let mut applicability = Applicability::MachineApplicable;\n             let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = &*method.ident.name.as_str();\n@@ -72,40 +70,25 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n }\n \n fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    fn get_hir_id<'tcx>(ty: Option<&Ty<'tcx>>, method_args: Option<&GenericArgs<'tcx>>) -> Option<HirId> {\n-        if let Some(ty) = ty {\n-            return Some(ty.hir_id);\n-        }\n-\n-        if let Some(generic_args) = method_args {\n-            if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0) {\n-                return Some(ty.hir_id);\n-            }\n-        }\n-\n-        None\n-    }\n     if let ExprKind::Block(block, _) = expr.kind {\n         for stmt in block.stmts {\n             if_chain! {\n-                if let StmtKind::Local(\n-                    Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n-                    init: Some(init_expr), ty, .. }\n-                ) = stmt.kind;\n+                if let StmtKind::Local(local) = stmt.kind;\n+                if let PatKind::Binding(_, id, ..) = local.pat.kind;\n+                if let Some(init_expr) = local.init;\n                 if let ExprKind::MethodCall(method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n-                if let Some(hir_id) = get_hir_id(*ty, method_name.args);\n-                if let Some(ty) = cx.typeck_results().node_type_opt(hir_id);\n+                let ty = cx.typeck_results().expr_ty(init_expr);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n                     is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, id);\n                 if let [iter_call] = &*iter_calls;\n                 then {\n                     let mut used_count_visitor = UsedCountVisitor {\n                         cx,\n-                        id: *pat_id,\n+                        id,\n                         count: 0,\n                     };\n                     walk_block(&mut used_count_visitor, block);\n@@ -187,48 +170,40 @@ enum IterFunctionKind {\n struct IterFunctionVisitor {\n     uses: Vec<IterFunction>,\n     seen_other: bool,\n-    target: Ident,\n+    target: HirId,\n }\n impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n-        if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n-            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. }) = args.get(0);\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                let len = sym!(len);\n-                let is_empty = sym!(is_empty);\n-                let contains = sym!(contains);\n-                match method_name.ident.name {\n-                    sym::into_iter => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n-                    ),\n-                    name if name == len => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n-                    ),\n-                    name if name == is_empty => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n-                    ),\n-                    name if name == contains => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n-                    ),\n+        if let ExprKind::MethodCall(method_name, _, [recv, args @ ..], _) = &expr.kind {\n+            if path_to_local_id(recv, self.target) {\n+                match &*method_name.ident.name.as_str() {\n+                    \"into_iter\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::IntoIter,\n+                        span: expr.span,\n+                    }),\n+                    \"len\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::Len,\n+                        span: expr.span,\n+                    }),\n+                    \"is_empty\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::IsEmpty,\n+                        span: expr.span,\n+                    }),\n+                    \"contains\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::Contains(args[0].span),\n+                        span: expr.span,\n+                    }),\n                     _ => self.seen_other = true,\n                 }\n-                return\n+                return;\n             }\n         }\n         // Check if the collection is used for anything else\n-        if_chain! {\n-            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. } = expr;\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                self.seen_other = true;\n-            } else {\n-                walk_expr(self, expr);\n-            }\n+        if path_to_local_id(expr, self.target) {\n+            self.seen_other = true;\n+        } else {\n+            walk_expr(self, expr);\n         }\n     }\n \n@@ -262,10 +237,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n \n /// Detect the occurrences of calls to `iter` or `into_iter` for the\n /// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, id: HirId) -> Option<Vec<IterFunction>> {\n     let mut visitor = IterFunctionVisitor {\n         uses: Vec::new(),\n-        target: identifier,\n+        target: id,\n         seen_other: false,\n     };\n     visitor.visit_block(block);"}, {"sha": "3810d0dcc051a7da141bcb8cb775df071184d1fe", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -192,7 +192,7 @@ fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n         if let ExprKind::MethodCall(method, _, len_args, _) = expr.kind;\n         if len_args.len() == 1;\n-        if method.ident.name == sym!(len);\n+        if method.ident.name == sym::len;\n         if let ExprKind::Path(QPath::Resolved(_, path)) = len_args[0].kind;\n         if path.segments.len() == 1;\n         if path.segments[0].ident.name == var;"}, {"sha": "d57588716a5bf16c8f4b28d0b75ceb251718837e", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,7 +1,9 @@\n use super::WHILE_LET_ON_ITERATOR;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{get_enclosing_loop, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used};\n+use clippy_utils::{\n+    get_enclosing_loop_or_closure, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n@@ -315,9 +317,10 @@ fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr:\n         }\n     }\n \n-    if let Some(e) = get_enclosing_loop(cx.tcx, loop_expr) {\n-        // The iterator expression will be used on the next iteration unless it is declared within the outer\n-        // loop.\n+    if let Some(e) = get_enclosing_loop_or_closure(cx.tcx, loop_expr) {\n+        // The iterator expression will be used on the next iteration (for loops), or on the next call (for\n+        // closures) unless it is declared within the enclosing expression. TODO: Check for closures\n+        // used where an `FnOnce` type is expected.\n         let local_id = match iter_expr.path {\n             Res::Local(id) => id,\n             _ => return true,"}, {"sha": "97e4a983f32ea3ca4542d17cf63223d2aeca2303", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -3,19 +3,17 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n-    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs,\n+    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, path_to_local_id,\n+    peel_hir_expr_refs,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{\n-    symbol::{sym, Ident},\n-    SyntaxContext,\n-};\n+use rustc_span::{sym, SyntaxContext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usages of `match` which could be implemented using `map`\n@@ -141,13 +139,13 @@ impl LateLintPass<'_> for ManualMap {\n                     scrutinee_str.into()\n                 };\n \n-            let body_str = if let PatKind::Binding(annotation, _, some_binding, None) = some_pat.kind {\n-                match can_pass_as_func(cx, some_binding, some_expr) {\n+            let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+                match can_pass_as_func(cx, id, some_expr) {\n                     Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n                         snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n                     },\n                     _ => {\n-                        if match_var(some_expr, some_binding.name)\n+                        if path_to_local_id(some_expr, id)\n                             && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n                             && binding_ref.is_some()\n                         {\n@@ -199,10 +197,10 @@ impl LateLintPass<'_> for ManualMap {\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if match_var(arg, binding.name) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n         {\n             Some(func)\n         },"}, {"sha": "41cda23510ea2f9e19e694e534ebf0f98d5e8834", "filename": "clippy_lints/src/map_identity.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=abc9a46868b75f1f9b1c5046c3abfab1ec3d44b9", "patch": "@@ -1,126 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_adjusted, is_qpath_def_path, is_trait_method, match_var, paths, remove_blocks};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Body, Expr, ExprKind, Pat, PatKind, QPath, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for instances of `map(f)` where `f` is the identity function.\n-    ///\n-    /// **Why is this bad?** It can be written more concisely without the call to `map`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let x = [1, 2, 3];\n-    /// let y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let x = [1, 2, 3];\n-    /// let y: Vec<_> = x.iter().map(|x| 2*x).collect();\n-    /// ```\n-    pub MAP_IDENTITY,\n-    complexity,\n-    \"using iterator.map(|x| x)\"\n-}\n-\n-declare_lint_pass!(MapIdentity => [MAP_IDENTITY]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MapIdentity {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let Some([caller, func]) = get_map_argument(cx, expr);\n-            if is_expr_identity_function(cx, func);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MAP_IDENTITY,\n-                    expr.span.trim_start(caller.span).unwrap(),\n-                    \"unnecessary map of the identity function\",\n-                    \"remove the call to `map`\",\n-                    String::new(),\n-                    Applicability::MachineApplicable\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-/// Returns the arguments passed into map() if the expression is a method call to\n-/// map(). Otherwise, returns None.\n-fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a [Expr<'a>]> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n-        if args.len() == 2 && method.ident.name == sym::map;\n-        let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n-        if is_trait_method(cx, expr, sym::Iterator)\n-            || is_type_diagnostic_item(cx, caller_ty, sym::result_type)\n-            || is_type_diagnostic_item(cx, caller_ty, sym::option_type);\n-        then {\n-            Some(args)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Checks if an expression represents the identity function\n-/// Only examines closures and `std::convert::identity`\n-fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n-        ExprKind::Path(ref path) => is_qpath_def_path(cx, path, expr.hir_id, &paths::CONVERT_IDENTITY),\n-        _ => false,\n-    }\n-}\n-\n-/// Checks if a function's body represents the identity function\n-/// Looks for bodies of the form `|x| x`, `|x| return x`, `|x| { return x }` or `|x| {\n-/// return x; }`\n-fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n-    let params = func.params;\n-    let body = remove_blocks(&func.value);\n-\n-    // if there's less/more than one parameter, then it is not the identity function\n-    if params.len() != 1 {\n-        return false;\n-    }\n-\n-    match body.kind {\n-        ExprKind::Path(QPath::Resolved(None, _)) => match_expr_param(cx, body, params[0].pat),\n-        ExprKind::Ret(Some(ret_val)) => match_expr_param(cx, ret_val, params[0].pat),\n-        ExprKind::Block(block, _) => {\n-            if_chain! {\n-                if block.stmts.len() == 1;\n-                if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = block.stmts[0].kind;\n-                if let ExprKind::Ret(Some(ret_val)) = expr.kind;\n-                then {\n-                    match_expr_param(cx, ret_val, params[0].pat)\n-                } else {\n-                    false\n-                }\n-            }\n-        },\n-        _ => false,\n-    }\n-}\n-\n-/// Returns true iff an expression returns the same thing as a parameter's pattern\n-fn match_expr_param(cx: &LateContext<'_>, expr: &Expr<'_>, pat: &Pat<'_>) -> bool {\n-    if let PatKind::Binding(_, _, ident, _) = pat.kind {\n-        match_var(expr, ident.name) && !(cx.typeck_results().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr))\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "f1e3492c4ecc5fdc3f698545376b9a3cb912fdfb", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -992,9 +992,9 @@ impl CommonPrefixSearcher<'a> {\n     }\n }\n \n-fn is_doc_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n+fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n     let attrs = cx.tcx.get_attrs(variant_def.def_id);\n-    clippy_utils::attrs::is_doc_hidden(attrs)\n+    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n }\n \n #[allow(clippy::too_many_lines)]\n@@ -1033,7 +1033,8 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n \n     // Accumulate the variants which should be put in place of the wildcard because they're not\n     // already covered.\n-    let mut missing_variants: Vec<_> = adt_def.variants.iter().collect();\n+    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n+    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n \n     let mut path_prefix = CommonPrefixSearcher::None;\n     for arm in arms {\n@@ -1118,7 +1119,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n \n     match missing_variants.as_slice() {\n         [] => (),\n-        [x] if !adt_def.is_variant_list_non_exhaustive() && !is_doc_hidden(cx, x) => span_lint_and_sugg(\n+        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n             cx,\n             MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n             wildcard_span,\n@@ -1129,7 +1130,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n         ),\n         variants => {\n             let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n-            let message = if adt_def.is_variant_list_non_exhaustive() {\n+            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n                 suggestions.push(\"_\".into());\n                 \"wildcard matches known variants and will also match future added variants\"\n             } else {\n@@ -2266,7 +2267,8 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n                             ),\n                         );\n                     } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n+                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n+                            .help(\"...or consider changing the match arm bodies\");\n                     }\n                 },\n             );"}, {"sha": "e39a5a1efd1e18f2a76bc64ab5cb76ef84e806a7", "filename": "clippy_lints/src/methods/append_instead_of_extend.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Fappend_instead_of_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Fappend_instead_of_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fappend_instead_of_extend.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,41 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, LangItem};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::APPEND_INSTEAD_OF_EXTEND;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+    if_chain! {\n+        if is_type_diagnostic_item(cx, ty, sym::vec_type);\n+        //check source object\n+        if let ExprKind::MethodCall(src_method, _, [drain_vec, drain_arg], _) = &arg.kind;\n+        if src_method.ident.as_str() == \"drain\";\n+        if let src_ty = cx.typeck_results().expr_ty(drain_vec).peel_refs();\n+        if is_type_diagnostic_item(cx, src_ty, sym::vec_type);\n+        //check drain range\n+        if let src_ty_range = cx.typeck_results().expr_ty(drain_arg).peel_refs();\n+        if is_type_lang_item(cx, src_ty_range, LangItem::RangeFull);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                APPEND_INSTEAD_OF_EXTEND,\n+                expr.span,\n+                \"use of `extend` instead of `append` for adding the full range of a second vector\",\n+                \"try this\",\n+                format!(\n+                    \"{}.append(&mut {})\",\n+                    snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, drain_vec.span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "d1b5e945dfdaa83a85b5ce13d776b0d438b88579", "filename": "clippy_lints/src/methods/filter_map_identity.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{is_expr_path_def_path, is_trait_method, path_to_local_id, paths};\n-use if_chain::if_chain;\n+use clippy_utils::{is_expr_identity_function, is_trait_method};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -9,32 +8,15 @@ use rustc_span::{source_map::Span, sym};\n use super::FILTER_MAP_IDENTITY;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, filter_map_arg: &hir::Expr<'_>, filter_map_span: Span) {\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let apply_lint = |message: &str| {\n-            span_lint_and_sugg(\n-                cx,\n-                FILTER_MAP_IDENTITY,\n-                filter_map_span.with_hi(expr.span.hi()),\n-                message,\n-                \"try\",\n-                \"flatten()\".to_string(),\n-                Applicability::MachineApplicable,\n-            );\n-        };\n-\n-        if_chain! {\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = filter_map_arg.kind;\n-            let body = cx.tcx.hir().body(body_id);\n-\n-            if let hir::PatKind::Binding(_, binding_id, ..) = body.params[0].pat.kind;\n-            if path_to_local_id(&body.value, binding_id);\n-            then {\n-                apply_lint(\"called `filter_map(|x| x)` on an `Iterator`\");\n-            }\n-        }\n-\n-        if is_expr_path_def_path(cx, filter_map_arg, &paths::CONVERT_IDENTITY) {\n-            apply_lint(\"called `filter_map(std::convert::identity)` on an `Iterator`\");\n-        }\n+    if is_trait_method(cx, expr, sym::Iterator) && is_expr_identity_function(cx, filter_map_arg) {\n+        span_lint_and_sugg(\n+            cx,\n+            FILTER_MAP_IDENTITY,\n+            filter_map_span.with_hi(expr.span.hi()),\n+            \"use of `filter_map` with an identity function\",\n+            \"try\",\n+            \"flatten()\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n     }\n }"}, {"sha": "6f911d79d0bc50880628e5de6f2711802601d58d", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{is_expr_path_def_path, is_trait_method, paths};\n-use if_chain::if_chain;\n+use clippy_utils::{is_expr_identity_function, is_trait_method};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -15,36 +14,15 @@ pub(super) fn check<'tcx>(\n     flat_map_arg: &'tcx hir::Expr<'_>,\n     flat_map_span: Span,\n ) {\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let apply_lint = |message: &str| {\n-            span_lint_and_sugg(\n-                cx,\n-                FLAT_MAP_IDENTITY,\n-                flat_map_span.with_hi(expr.span.hi()),\n-                message,\n-                \"try\",\n-                \"flatten()\".to_string(),\n-                Applicability::MachineApplicable,\n-            );\n-        };\n-\n-        if_chain! {\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = flat_map_arg.kind;\n-            let body = cx.tcx.hir().body(body_id);\n-\n-            if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = body.value.kind;\n-\n-            if path.segments.len() == 1;\n-            if path.segments[0].ident.name == binding_ident.name;\n-\n-            then {\n-                apply_lint(\"called `flat_map(|x| x)` on an `Iterator`\");\n-            }\n-        }\n-\n-        if is_expr_path_def_path(cx, flat_map_arg, &paths::CONVERT_IDENTITY) {\n-            apply_lint(\"called `flat_map(std::convert::identity)` on an `Iterator`\");\n-        }\n+    if is_trait_method(cx, expr, sym::Iterator) && is_expr_identity_function(cx, flat_map_arg) {\n+        span_lint_and_sugg(\n+            cx,\n+            FLAT_MAP_IDENTITY,\n+            flat_map_span.with_hi(expr.span.hi()),\n+            \"use of `flat_map` with an identity function\",\n+            \"try\",\n+            \"flatten()\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n     }\n }"}, {"sha": "538a12566e3031880a9400f3a1f294cf491a0556", "filename": "clippy_lints/src/methods/map_identity.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,38 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_expr_identity_function, is_trait_method};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::{source_map::Span, sym};\n+\n+use super::MAP_IDENTITY;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    caller: &hir::Expr<'_>,\n+    map_arg: &hir::Expr<'_>,\n+    _map_span: Span,\n+) {\n+    let caller_ty = cx.typeck_results().expr_ty(caller);\n+\n+    if_chain! {\n+        if is_trait_method(cx, expr, sym::Iterator)\n+            || is_type_diagnostic_item(cx, caller_ty, sym::result_type)\n+            || is_type_diagnostic_item(cx, caller_ty, sym::option_type);\n+        if is_expr_identity_function(cx, map_arg);\n+        if let Some(sugg_span) = expr.span.trim_start(caller.span);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_IDENTITY,\n+                sugg_span,\n+                \"unnecessary map of the identity function\",\n+                \"remove the call to `map`\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+        }\n+    }\n+}"}, {"sha": "283fcf281df181359cd3948c6e6389919b77cf00", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,3 +1,4 @@\n+mod append_instead_of_extend;\n mod bind_instead_of_map;\n mod bytes_nth;\n mod chars_cmp;\n@@ -35,6 +36,7 @@ mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n+mod map_identity;\n mod map_unwrap_or;\n mod ok_expect;\n mod option_as_ref_deref;\n@@ -1031,6 +1033,30 @@ declare_clippy_lint! {\n     \"using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for occurrences where one vector gets extended instead of append\n+    ///\n+    /// **Why is this bad?** Using `append` instead of `extend` is more concise and faster\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let mut a = vec![1, 2, 3];\n+    /// let mut b = vec![4, 5, 6];\n+    ///\n+    /// // Bad\n+    /// a.extend(b.drain(..));\n+    ///\n+    /// // Good\n+    /// a.append(&mut b);\n+    /// ```\n+    pub APPEND_INSTEAD_OF_EXTEND,\n+    perf,\n+    \"using vec.append(&mut vec) to move the full range of a vecor to another\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `.extend(s.chars())` where s is a\n     /// `&str` or `String`.\n@@ -1222,7 +1248,7 @@ declare_clippy_lint! {\n     /// let _ = (0..3).map(|x| x + 2).count();\n     /// ```\n     pub SUSPICIOUS_MAP,\n-    complexity,\n+    suspicious,\n     \"suspicious usage of map\"\n }\n \n@@ -1504,7 +1530,7 @@ declare_clippy_lint! {\n     /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n     /// ```\n     pub FROM_ITER_INSTEAD_OF_COLLECT,\n-    style,\n+    pedantic,\n     \"use `.collect()` instead of `::from_iter()`\"\n }\n \n@@ -1561,6 +1587,29 @@ declare_clippy_lint! {\n     \"call to `filter_map` where `flatten` is sufficient\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `map(f)` where `f` is the identity function.\n+    ///\n+    /// **Why is this bad?** It can be written more concisely without the call to `map`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = [1, 2, 3];\n+    /// let y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = [1, 2, 3];\n+    /// let y: Vec<_> = x.iter().map(|x| 2*x).collect();\n+    /// ```\n+    pub MAP_IDENTITY,\n+    complexity,\n+    \"using iterator.map(|x| x)\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `.bytes().nth()`.\n     ///\n@@ -1728,6 +1777,7 @@ impl_lint_pass!(Methods => [\n     FILTER_NEXT,\n     SKIP_WHILE_NEXT,\n     FILTER_MAP_IDENTITY,\n+    MAP_IDENTITY,\n     MANUAL_FILTER_MAP,\n     MANUAL_FIND_MAP,\n     OPTION_FILTER_MAP,\n@@ -1760,7 +1810,8 @@ impl_lint_pass!(Methods => [\n     INSPECT_FOR_EACH,\n     IMPLICIT_CLONE,\n     SUSPICIOUS_SPLITN,\n-    MANUAL_STR_REPEAT\n+    MANUAL_STR_REPEAT,\n+    APPEND_INSTEAD_OF_EXTEND\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -1985,7 +2036,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Option<&RustcVersion>) {\n     if let Some((name, [recv, args @ ..], span)) = method_call!(expr) {\n         match (name, args) {\n-            (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [recv, _]) => {\n+            (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                 zst_offset::check(cx, expr, recv);\n             },\n             (\"and_then\", [arg]) => {\n@@ -2022,7 +2073,10 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n                 _ => expect_used::check(cx, expr, recv),\n             },\n-            (\"extend\", [arg]) => string_extend_chars::check(cx, expr, recv, arg),\n+            (\"extend\", [arg]) => {\n+                string_extend_chars::check(cx, expr, recv, arg);\n+                append_instead_of_extend::check(cx, expr, recv, arg);\n+            },\n             (\"filter_map\", [arg]) => {\n                 unnecessary_filter_map::check(cx, expr, arg);\n                 filter_map_identity::check(cx, expr, arg, span);\n@@ -2058,6 +2112,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                         _ => {},\n                     }\n                 }\n+                map_identity::check(cx, expr, recv, m_arg, span);\n             },\n             (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n             (\"next\", []) => {"}, {"sha": "073c5570a88776e8c396bcc69284a3f5735cd2e6", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -87,7 +87,7 @@ pub(super) fn check<'tcx>(\n         ];\n \n         if let hir::ExprKind::MethodCall(path, _, args, _) = &arg.kind {\n-            if path.ident.as_str() == \"len\" {\n+            if path.ident.name == sym::len {\n                 let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n \n                 match ty.kind() {"}, {"sha": "ec1572c26c262acc21ace9b4e95479828d4d86cd", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -7,7 +7,8 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -55,6 +56,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.kind;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.name == sym::include\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n@@ -80,7 +95,7 @@ impl MissingDoc {\n \n         let has_doc = attrs\n             .iter()\n-            .any(|a| a.doc_str().is_some());\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "59565350f72966260ad0913d0c208e8b498acb4b", "filename": "clippy_lints/src/missing_enforced_import_rename.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,102 @@\n+use clippy_utils::{diagnostics::span_lint_and_sugg, source::snippet_opt};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def::Res, def_id::DefId, Crate, Item, ItemKind, UseKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Symbol;\n+\n+use crate::utils::conf::Rename;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for imports that do not rename the item as specified\n+    /// in the `enforce-import-renames` config option.\n+    ///\n+    /// **Why is this bad?** Consistency is important, if a project has defined import\n+    /// renames they should be followed. More practically, some item names are too\n+    /// vague outside of their defining scope this can enforce a more meaningful naming.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// An example clippy.toml configuration:\n+    /// ```toml\n+    /// # clippy.toml\n+    /// enforced-import-renames = [ { path = \"serde_json::Value\", rename = \"JsonValue\" }]\n+    /// ```\n+    ///\n+    /// ```rust,ignore\n+    /// use serde_json::Value;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use serde_json::Value as JsonValue;\n+    /// ```\n+    pub MISSING_ENFORCED_IMPORT_RENAMES,\n+    restriction,\n+    \"enforce import renames\"\n+}\n+\n+pub struct ImportRename {\n+    conf_renames: Vec<Rename>,\n+    renames: FxHashMap<DefId, Symbol>,\n+}\n+\n+impl ImportRename {\n+    pub fn new(conf_renames: Vec<Rename>) -> Self {\n+        Self {\n+            conf_renames,\n+            renames: FxHashMap::default(),\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(ImportRename => [MISSING_ENFORCED_IMPORT_RENAMES]);\n+\n+impl LateLintPass<'_> for ImportRename {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        for Rename { path, rename } in &self.conf_renames {\n+            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &path.split(\"::\").collect::<Vec<_>>()) {\n+                self.renames.insert(id, Symbol::intern(rename));\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if_chain! {\n+            if let ItemKind::Use(path, UseKind::Single) = &item.kind;\n+            if let Res::Def(_, id) = path.res;\n+            if let Some(name) = self.renames.get(&id);\n+            // Remove semicolon since it is not present for nested imports\n+            let span_without_semi = cx.sess().source_map().span_until_char(item.span, ';');\n+            if let Some(snip) = snippet_opt(cx, span_without_semi);\n+            if let Some(import) = match snip.split_once(\" as \") {\n+                None => Some(snip.as_str()),\n+                Some((import, rename)) => {\n+                    if rename.trim() == &*name.as_str() {\n+                        None\n+                    } else {\n+                        Some(import.trim())\n+                    }\n+                },\n+            };\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MISSING_ENFORCED_IMPORT_RENAMES,\n+                    span_without_semi,\n+                    \"this import should be renamed\",\n+                    \"try\",\n+                    format!(\n+                        \"{} as {}\",\n+                        import,\n+                        name,\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "6c87136e5e14e0a235e697e4bd071d7f1cefcff3", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -50,7 +50,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub MUTABLE_KEY_TYPE,\n-    correctness,\n+    suspicious,\n     \"Check for mutable `Map`/`Set` key type\"\n }\n "}, {"sha": "81bf853300fe5aa4014612ec533aa55e572ea1a9", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -87,10 +87,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "910b05360925d53dd6a6fd39aa14dbc8066d5cd0", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -167,7 +167,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n                         BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) => None,\n                         BlockCheckMode::DefaultBlock => Some(vec![&**e]),\n                         // in case of compiler-inserted signaling blocks\n-                        _ => reduce_expression(cx, e),\n+                        BlockCheckMode::UnsafeBlock(_) => reduce_expression(cx, e),\n                     }\n                 })\n             } else {"}, {"sha": "b81f8d24a33e98a9dfd166fc0dc865e8269812ba", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use rustc_ast::ast::{\n-    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat,\n-    PatKind,\n+    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat, PatKind,\n };\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};"}, {"sha": "1adad5be6ddc591f2cf11944e4b98f8c1d5554fb", "filename": "clippy_lints/src/nonstandard_macro_braces.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,276 @@\n+use std::{\n+    fmt,\n+    hash::{Hash, Hasher},\n+};\n+\n+use clippy_utils::{diagnostics::span_lint_and_help, in_macro, is_direct_expn_of, source::snippet_opt};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n+use serde::{de, Deserialize};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks that common macros are used with consistent bracing.\n+    ///\n+    /// **Why is this bad?** This is mostly a consistency lint although using () or []\n+    /// doesn't give you a semicolon in item position, which can be unexpected.\n+    ///\n+    /// **Known problems:**\n+    /// None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// vec!{1, 2, 3};\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// vec![1, 2, 3];\n+    /// ```\n+    pub NONSTANDARD_MACRO_BRACES,\n+    style,\n+    \"check consistent use of braces in macro\"\n+}\n+\n+const BRACES: &[(&str, &str)] = &[(\"(\", \")\"), (\"{\", \"}\"), (\"[\", \"]\")];\n+\n+/// The (name, (open brace, close brace), source snippet)\n+type MacroInfo<'a> = (&'a str, &'a (String, String), String);\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct MacroBraces {\n+    macro_braces: FxHashMap<String, (String, String)>,\n+    done: FxHashSet<Span>,\n+}\n+\n+impl MacroBraces {\n+    pub fn new(conf: &FxHashSet<MacroMatcher>) -> Self {\n+        let macro_braces = macro_braces(conf.clone());\n+        Self {\n+            macro_braces,\n+            done: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(MacroBraces => [NONSTANDARD_MACRO_BRACES]);\n+\n+impl EarlyLintPass for MacroBraces {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        if let Some((name, braces, snip)) = is_offending_macro(cx, item.span, self) {\n+            let span = item.span.ctxt().outer_expn_data().call_site;\n+            emit_help(cx, snip, braces, name, span);\n+            self.done.insert(span);\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &ast::Stmt) {\n+        if let Some((name, braces, snip)) = is_offending_macro(cx, stmt.span, self) {\n+            let span = stmt.span.ctxt().outer_expn_data().call_site;\n+            emit_help(cx, snip, braces, name, span);\n+            self.done.insert(span);\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n+        if let Some((name, braces, snip)) = is_offending_macro(cx, expr.span, self) {\n+            let span = expr.span.ctxt().outer_expn_data().call_site;\n+            emit_help(cx, snip, braces, name, span);\n+            self.done.insert(span);\n+        }\n+    }\n+\n+    fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n+        if let Some((name, braces, snip)) = is_offending_macro(cx, ty.span, self) {\n+            let span = ty.span.ctxt().outer_expn_data().call_site;\n+            emit_help(cx, snip, braces, name, span);\n+            self.done.insert(span);\n+        }\n+    }\n+}\n+\n+fn is_offending_macro<'a>(cx: &EarlyContext<'_>, span: Span, this: &'a MacroBraces) -> Option<MacroInfo<'a>> {\n+    if_chain! {\n+        if in_macro(span);\n+        if let Some((name, braces)) = find_matching_macro(span, &this.macro_braces);\n+        if let Some(snip) = snippet_opt(cx, span.ctxt().outer_expn_data().call_site);\n+        let c = snip.replace(\" \", \"\"); // make formatting consistent\n+        if !c.starts_with(&format!(\"{}!{}\", name, braces.0));\n+        if !this.done.contains(&span.ctxt().outer_expn_data().call_site);\n+        then {\n+            Some((name, braces, snip))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn emit_help(cx: &EarlyContext<'_>, snip: String, braces: &(String, String), name: &str, span: Span) {\n+    let with_space = &format!(\"! {}\", braces.0);\n+    let without_space = &format!(\"!{}\", braces.0);\n+    let mut help = snip;\n+    for b in BRACES.iter().filter(|b| b.0 != braces.0) {\n+        help = help.replace(b.0, &braces.0).replace(b.1, &braces.1);\n+        // Only `{` traditionally has space before the brace\n+        if braces.0 != \"{\" && help.contains(with_space) {\n+            help = help.replace(with_space, without_space);\n+        } else if braces.0 == \"{\" && help.contains(without_space) {\n+            help = help.replace(without_space, with_space);\n+        }\n+    }\n+    span_lint_and_help(\n+        cx,\n+        NONSTANDARD_MACRO_BRACES,\n+        span,\n+        &format!(\"use of irregular braces for `{}!` macro\", name),\n+        Some(span),\n+        &format!(\"consider writing `{}`\", help),\n+    );\n+}\n+\n+fn find_matching_macro(\n+    span: Span,\n+    braces: &FxHashMap<String, (String, String)>,\n+) -> Option<(&String, &(String, String))> {\n+    braces\n+        .iter()\n+        .find(|(macro_name, _)| is_direct_expn_of(span, macro_name).is_some())\n+}\n+\n+fn macro_braces(conf: FxHashSet<MacroMatcher>) -> FxHashMap<String, (String, String)> {\n+    let mut braces = vec![\n+        macro_matcher!(\n+            name: \"print\",\n+            braces: (\"(\", \")\"),\n+        ),\n+        macro_matcher!(\n+            name: \"println\",\n+            braces: (\"(\", \")\"),\n+        ),\n+        macro_matcher!(\n+            name: \"eprint\",\n+            braces: (\"(\", \")\"),\n+        ),\n+        macro_matcher!(\n+            name: \"eprintln\",\n+            braces: (\"(\", \")\"),\n+        ),\n+        macro_matcher!(\n+            name: \"write\",\n+            braces: (\"(\", \")\"),\n+        ),\n+        macro_matcher!(\n+            name: \"writeln\",\n+            braces: (\"(\", \")\"),\n+        ),\n+        macro_matcher!(\n+            name: \"format\",\n+            braces: (\"(\", \")\"),\n+        ),\n+        macro_matcher!(\n+            name: \"format_args\",\n+            braces: (\"(\", \")\"),\n+        ),\n+        macro_matcher!(\n+            name: \"vec\",\n+            braces: (\"[\", \"]\"),\n+        ),\n+    ]\n+    .into_iter()\n+    .collect::<FxHashMap<_, _>>();\n+    // We want users items to override any existing items\n+    for it in conf {\n+        braces.insert(it.name, it.braces);\n+    }\n+    braces\n+}\n+\n+macro_rules! macro_matcher {\n+    (name: $name:expr, braces: ($open:expr, $close:expr) $(,)?) => {\n+        ($name.to_owned(), ($open.to_owned(), $close.to_owned()))\n+    };\n+}\n+pub(crate) use macro_matcher;\n+\n+#[derive(Clone, Debug)]\n+pub struct MacroMatcher {\n+    name: String,\n+    braces: (String, String),\n+}\n+\n+impl Hash for MacroMatcher {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.name.hash(state);\n+    }\n+}\n+\n+impl PartialEq for MacroMatcher {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name\n+    }\n+}\n+impl Eq for MacroMatcher {}\n+\n+impl<'de> Deserialize<'de> for MacroMatcher {\n+    fn deserialize<D>(deser: D) -> Result<Self, D::Error>\n+    where\n+        D: de::Deserializer<'de>,\n+    {\n+        #[derive(Deserialize)]\n+        #[serde(field_identifier, rename_all = \"lowercase\")]\n+        enum Field {\n+            Name,\n+            Brace,\n+        }\n+        struct MacVisitor;\n+        impl<'de> de::Visitor<'de> for MacVisitor {\n+            type Value = MacroMatcher;\n+\n+            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                formatter.write_str(\"struct MacroMatcher\")\n+            }\n+\n+            fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error>\n+            where\n+                V: de::MapAccess<'de>,\n+            {\n+                let mut name = None;\n+                let mut brace: Option<&str> = None;\n+                while let Some(key) = map.next_key()? {\n+                    match key {\n+                        Field::Name => {\n+                            if name.is_some() {\n+                                return Err(de::Error::duplicate_field(\"name\"));\n+                            }\n+                            name = Some(map.next_value()?);\n+                        },\n+                        Field::Brace => {\n+                            if brace.is_some() {\n+                                return Err(de::Error::duplicate_field(\"brace\"));\n+                            }\n+                            brace = Some(map.next_value()?);\n+                        },\n+                    }\n+                }\n+                let name = name.ok_or_else(|| de::Error::missing_field(\"name\"))?;\n+                let brace = brace.ok_or_else(|| de::Error::missing_field(\"brace\"))?;\n+                Ok(MacroMatcher {\n+                    name,\n+                    braces: BRACES\n+                        .iter()\n+                        .find(|b| b.0 == brace)\n+                        .map(|(o, c)| ((*o).to_owned(), (*c).to_owned()))\n+                        .ok_or_else(|| {\n+                            de::Error::custom(&format!(\"expected one of `(`, `{{`, `[` found `{}`\", brace))\n+                        })?,\n+                })\n+            }\n+        }\n+\n+        const FIELDS: &[&str] = &[\"name\", \"brace\"];\n+        deser.deserialize_struct(\"MacroMatcher\", FIELDS, MacVisitor)\n+    }\n+}"}, {"sha": "b41c478c266157d5295155ffdc4103aed7847452", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -329,7 +329,7 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n         if let ExprKind::MethodCall(len_path, _, len_args, _) = end.kind;\n-        if len_path.ident.name == sym!(len) && len_args.len() == 1;\n+        if len_path.ident.name == sym::len && len_args.len() == 1;\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n         if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;"}, {"sha": "380557c81a19a9d1162e5fb0b3ad03784846664a", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 }\n             }\n \n-            // `{ cloned = &arg; clone(move cloned); }` or `{ cloned = &arg; to_path_buf(cloned); }`\n+            // `{ arg = &cloned; clone(move arg); }` or `{ arg = &cloned; to_path_buf(arg); }`\n             let (cloned, cannot_move_out) = unwrap_or_continue!(find_stmt_assigns_to(cx, mir, arg, from_borrow, bb));\n \n             let loc = mir::Location {\n@@ -628,7 +628,7 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n         BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n             visit_op(lhs);\n             visit_op(rhs);\n-        }\n+        },\n         _ => (),\n     }\n }"}, {"sha": "da3e30af35ca4ffd7e2a8de07ef16ce6e028e04c", "filename": "clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,3 +1,4 @@\n+use crate::rustc_lint::LintContext;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::{in_macro, sugg};\n@@ -45,6 +46,7 @@ impl LateLintPass<'_> for SemicolonIfNothingReturned {\n             if t_expr.is_unit();\n             if let snippet = snippet_with_macro_callsite(cx, expr.span, \"}\");\n             if !snippet.ends_with('}');\n+            if cx.sess().source_map().is_multiline(block.span);\n             then {\n                 // filter out the desugared `for` loop\n                 if let ExprKind::DropTemps(..) = &expr.kind {"}, {"sha": "2203ab57b10820c626e99c0c0d1411b1d70004ca", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -26,7 +26,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub SUSPICIOUS_ARITHMETIC_IMPL,\n-    correctness,\n+    suspicious,\n     \"suspicious use of operators in impl of arithmetic trait\"\n }\n \n@@ -47,7 +47,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub SUSPICIOUS_OP_ASSIGN_IMPL,\n-    correctness,\n+    suspicious,\n     \"suspicious use of operators in impl of OpAssign trait\"\n }\n "}, {"sha": "07a4e294049791f7256e41810c31ed22088a3426", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::wildcard_imports, clippy::enum_glob_use)]\n \n-use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path, eq_maybe_qself};\n+use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_maybe_qself, eq_pat, eq_path};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{meets_msrv, msrvs, over};\n use rustc_ast::mut_visit::*;\n@@ -277,7 +277,8 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n             ps1, start, alternatives,\n             |k, ps1, idx| matches!(\n                 k,\n-                TupleStruct(qself2, path2, ps2) if eq_maybe_qself(qself1, qself2) && eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n+                TupleStruct(qself2, path2, ps2)\n+                    if eq_maybe_qself(qself1, qself2) && eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n             ),\n             |k| always_pat!(k, TupleStruct(_, _, ps) => ps),\n         ),"}, {"sha": "906ac10f4610b92f0c548f2445064dde896b6a87", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 100, "deletions": 263, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,23 +1,22 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::same_type_and_consts;\n use clippy_utils::{in_macro, meets_msrv, msrvs};\n use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::{\n     self as hir,\n-    def::{self, DefKind},\n+    def::{CtorOf, DefKind, Res},\n     def_id::LocalDefId,\n     intravisit::{walk_ty, NestedVisitorMap, Visitor},\n-    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, PathSegment,\n-    QPath, TyKind,\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Path, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::{AssocKind, Ty};\n+use rustc_middle::ty::AssocKind;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;\n \n declare_clippy_lint! {\n@@ -75,10 +74,9 @@ impl UseSelf {\n #[derive(Debug)]\n enum StackItem {\n     Check {\n-        hir_id: HirId,\n-        impl_trait_ref_def_id: Option<LocalDefId>,\n-        types_to_skip: Vec<HirId>,\n-        types_to_lint: Vec<HirId>,\n+        impl_id: LocalDefId,\n+        in_body: u32,\n+        types_to_skip: FxHashSet<HirId>,\n     },\n     NoCheck,\n }\n@@ -88,60 +86,41 @@ impl_lint_pass!(UseSelf => [USE_SELF]);\n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n impl<'tcx> LateLintPass<'tcx> for UseSelf {\n-    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+    fn check_item(&mut self, _cx: &LateContext<'_>, item: &Item<'_>) {\n+        if !is_item_interesting(item) {\n+            // This does two things:\n+            //  1) Reduce needless churn on `self.stack`\n+            //  2) Don't push `StackItem::NoCheck` when entering `ItemKind::OpaqueTy`,\n+            //     in order to lint `foo() -> impl <..>`\n+            return;\n+        }\n         // We push the self types of `impl`s on a stack here. Only the top type on the stack is\n         // relevant for linting, since this is the self type of the `impl` we're currently in. To\n         // avoid linting on nested items, we push `StackItem::NoCheck` on the stack to signal, that\n         // we're in an `impl` or nested item, that we don't want to lint\n-        //\n-        // NB: If you push something on the stack in this method, remember to also pop it in the\n-        // `check_item_post` method.\n-        match &item.kind {\n-            ItemKind::Impl(Impl {\n-                self_ty: hir_self_ty,\n-                of_trait,\n-                ..\n-            }) => {\n-                let should_check = if let TyKind::Path(QPath::Resolved(_, item_path)) = hir_self_ty.kind {\n-                    let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n-                    parameters.as_ref().map_or(true, |params| {\n-                        !params.parenthesized && !params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n-                    })\n-                } else {\n-                    false\n-                };\n-                let impl_trait_ref_def_id = of_trait.as_ref().map(|_| cx.tcx.hir().local_def_id(item.hir_id()));\n-                if should_check {\n-                    self.stack.push(StackItem::Check {\n-                        hir_id: hir_self_ty.hir_id,\n-                        impl_trait_ref_def_id,\n-                        types_to_lint: Vec::new(),\n-                        types_to_skip: Vec::new(),\n-                    });\n-                } else {\n-                    self.stack.push(StackItem::NoCheck);\n+        let stack_item = if_chain! {\n+            if let ItemKind::Impl(Impl { self_ty, .. }) = item.kind;\n+            if let TyKind::Path(QPath::Resolved(_, item_path)) = self_ty.kind;\n+            let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n+            if parameters.as_ref().map_or(true, |params| {\n+                !params.parenthesized && !params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n+            });\n+            then {\n+                StackItem::Check {\n+                    impl_id: item.def_id,\n+                    in_body: 0,\n+                    types_to_skip: std::iter::once(self_ty.hir_id).collect(),\n                 }\n-            },\n-            ItemKind::Static(..)\n-            | ItemKind::Const(..)\n-            | ItemKind::Fn(..)\n-            | ItemKind::Enum(..)\n-            | ItemKind::Struct(..)\n-            | ItemKind::Union(..)\n-            | ItemKind::Trait(..) => {\n-                self.stack.push(StackItem::NoCheck);\n-            },\n-            _ => (),\n-        }\n+            } else {\n+                StackItem::NoCheck\n+            }\n+        };\n+        self.stack.push(stack_item);\n     }\n \n     fn check_item_post(&mut self, _: &LateContext<'_>, item: &Item<'_>) {\n-        use ItemKind::{Const, Enum, Fn, Impl, Static, Struct, Trait, Union};\n-        match item.kind {\n-            Impl { .. } | Static(..) | Const(..) | Fn(..) | Enum(..) | Struct(..) | Union(..) | Trait(..) => {\n-                self.stack.pop();\n-            },\n-            _ => (),\n+        if is_item_interesting(item) {\n+            self.stack.pop();\n         }\n     }\n \n@@ -151,11 +130,11 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n         if_chain! {\n             if let ImplItemKind::Fn(FnSig { decl, .. }, ..) = impl_item.kind;\n             if let Some(&mut StackItem::Check {\n-                impl_trait_ref_def_id: Some(def_id),\n+                impl_id,\n                 ref mut types_to_skip,\n                 ..\n             }) = self.stack.last_mut();\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(def_id);\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_id);\n             then {\n                 // `self_ty` is the semantic self type of `impl <trait> for <type>`. This cannot be\n                 // `Self`.\n@@ -203,142 +182,76 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n         }\n     }\n \n-    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) {\n+    fn check_body(&mut self, _: &LateContext<'_>, _: &hir::Body<'_>) {\n         // `hir_ty_to_ty` cannot be called in `Body`s or it will panic (sometimes). But in bodies\n         // we can use `cx.typeck_results.node_type(..)` to get the `ty::Ty` from a `hir::Ty`.\n         // However the `node_type()` method can *only* be called in bodies.\n-        //\n-        // This method implementation determines which types should get linted in a `Body` and\n-        // which shouldn't, with a visitor. We could directly lint in the visitor, but then we\n-        // could only allow this lint on item scope. And we would have to check if those types are\n-        // already dealt with in `check_ty` anyway.\n-        if let Some(StackItem::Check {\n-            hir_id,\n-            types_to_lint,\n-            types_to_skip,\n-            ..\n-        }) = self.stack.last_mut()\n-        {\n-            let self_ty = ty_from_hir_id(cx, *hir_id);\n-\n-            let mut visitor = LintTyCollector {\n-                cx,\n-                self_ty,\n-                types_to_lint: vec![],\n-                types_to_skip: vec![],\n-            };\n-            visitor.visit_expr(&body.value);\n-            types_to_lint.extend(visitor.types_to_lint);\n-            types_to_skip.extend(visitor.types_to_skip);\n+        if let Some(&mut StackItem::Check { ref mut in_body, .. }) = self.stack.last_mut() {\n+            *in_body = in_body.saturating_add(1);\n         }\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n-        if in_macro(hir_ty.span)\n-            || in_impl(cx, hir_ty)\n-            || !meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS)\n-        {\n-            return;\n+    fn check_body_post(&mut self, _: &LateContext<'_>, _: &hir::Body<'_>) {\n+        if let Some(&mut StackItem::Check { ref mut in_body, .. }) = self.stack.last_mut() {\n+            *in_body = in_body.saturating_sub(1);\n         }\n+    }\n \n-        let lint_dependend_on_expr_kind = if let Some(StackItem::Check {\n-            hir_id,\n-            types_to_lint,\n-            types_to_skip,\n-            ..\n-        }) = self.stack.last()\n-        {\n-            if types_to_skip.contains(&hir_ty.hir_id) {\n-                false\n-            } else if types_to_lint.contains(&hir_ty.hir_id) {\n-                true\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n+        if_chain! {\n+            if !in_macro(hir_ty.span);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(&StackItem::Check {\n+                impl_id,\n+                in_body,\n+                ref types_to_skip,\n+            }) = self.stack.last();\n+            if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+            if !matches!(path.res, Res::SelfTy(..) | Res::Def(DefKind::TyParam, _));\n+            if !types_to_skip.contains(&hir_ty.hir_id);\n+            let ty = if in_body > 0 {\n+                cx.typeck_results().node_type(hir_ty.hir_id)\n             } else {\n-                let self_ty = ty_from_hir_id(cx, *hir_id);\n-                should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n-            }\n-        } else {\n-            false\n-        };\n-\n-        if lint_dependend_on_expr_kind {\n-            // FIXME: this span manipulation should not be necessary\n-            // @flip1995 found an ast lowering issue in\n-            // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n+                hir_ty_to_ty(cx.tcx, hir_ty)\n+            };\n+            if same_type_and_consts(ty, cx.tcx.type_of(impl_id));\n             let hir = cx.tcx.hir();\n             let id = hir.get_parent_node(hir_ty.hir_id);\n-\n-            if !hir.opt_span(id).map_or(false, in_macro) {\n-                match hir.find(id) {\n-                    Some(Node::Expr(Expr {\n-                        kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n-                        ..\n-                    })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n-                    _ => span_lint(cx, hir_ty.span),\n-                }\n+            if !hir.opt_span(id).map_or(false, in_macro);\n+            then {\n+                span_lint(cx, hir_ty.span);\n             }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        fn expr_ty_matches(cx: &LateContext<'_>, expr: &Expr<'_>, self_ty: Ty<'_>) -> bool {\n-            let def_id = expr.hir_id.owner;\n-            if cx.tcx.has_typeck_results(def_id) {\n-                cx.tcx.typeck(def_id).expr_ty_opt(expr) == Some(self_ty)\n-            } else {\n-                false\n-            }\n-        }\n-\n-        if in_macro(expr.span) || !meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS) {\n-            return;\n+        if_chain! {\n+            if !in_macro(expr.span);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(&StackItem::Check { impl_id, .. }) = self.stack.last();\n+            if cx.typeck_results().expr_ty(expr) == cx.tcx.type_of(impl_id);\n+            then {} else { return; }\n         }\n-\n-        if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n-            let self_ty = ty_from_hir_id(cx, *hir_id);\n-\n-            match &expr.kind {\n-                ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n-                    if expr_ty_matches(cx, expr, self_ty) {\n-                        match path.res {\n-                            def::Res::SelfTy(..) => (),\n-                            def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(cx, path),\n-                            _ => {\n-                                span_lint(cx, path.span);\n-                            },\n-                        }\n-                    }\n-                },\n-                // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n-                ExprKind::Call(fun, _) => {\n-                    if let Expr {\n-                        kind: ExprKind::Path(ref qpath),\n-                        ..\n-                    } = fun\n-                    {\n-                        if expr_ty_matches(cx, expr, self_ty) {\n-                            let res = cx.qpath_res(qpath, fun.hir_id);\n-\n-                            if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n-                                match ctor_of {\n-                                    def::CtorOf::Variant => {\n-                                        span_lint_on_qpath_resolved(cx, qpath, true);\n-                                    },\n-                                    def::CtorOf::Struct => {\n-                                        span_lint_on_qpath_resolved(cx, qpath, false);\n-                                    },\n-                                }\n-                            }\n+        match expr.kind {\n+            ExprKind::Struct(QPath::Resolved(_, path), ..) => match path.res {\n+                Res::SelfTy(..) => (),\n+                Res::Def(DefKind::Variant, _) => lint_path_to_variant(cx, path),\n+                _ => span_lint(cx, path.span),\n+            },\n+            // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+            ExprKind::Call(fun, _) => {\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = fun.kind {\n+                    if let Res::Def(DefKind::Ctor(ctor_of, _), ..) = path.res {\n+                        match ctor_of {\n+                            CtorOf::Variant => lint_path_to_variant(cx, path),\n+                            CtorOf::Struct => span_lint(cx, path.span),\n                         }\n                     }\n-                },\n-                // unit enum variants (`Enum::A`)\n-                ExprKind::Path(qpath) => {\n-                    if expr_ty_matches(cx, expr, self_ty) {\n-                        span_lint_on_qpath_resolved(cx, qpath, true);\n-                    }\n-                },\n-                _ => (),\n-            }\n+                }\n+            },\n+            // unit enum variants (`Enum::A`)\n+            ExprKind::Path(QPath::Resolved(_, path)) => lint_path_to_variant(cx, path),\n+            _ => (),\n         }\n     }\n \n@@ -364,35 +277,6 @@ impl<'tcx> Visitor<'tcx> for SkipTyCollector {\n     }\n }\n \n-struct LintTyCollector<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    self_ty: Ty<'tcx>,\n-    types_to_lint: Vec<HirId>,\n-    types_to_skip: Vec<HirId>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for LintTyCollector<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n-        if_chain! {\n-            if let Some(ty) = self.cx.typeck_results().node_type_opt(hir_ty.hir_id);\n-            if should_lint_ty(hir_ty, ty, self.self_ty);\n-            then {\n-                self.types_to_lint.push(hir_ty.hir_id);\n-            } else {\n-                self.types_to_skip.push(hir_ty.hir_id);\n-            }\n-        }\n-\n-        walk_ty(self, hir_ty);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n fn span_lint(cx: &LateContext<'_>, span: Span) {\n     span_lint_and_sugg(\n         cx,\n@@ -405,66 +289,19 @@ fn span_lint(cx: &LateContext<'_>, span: Span) {\n     );\n }\n \n-#[allow(clippy::cast_possible_truncation)]\n-fn span_lint_until_last_segment(cx: &LateContext<'_>, span: Span, segment: &PathSegment<'_>) {\n-    let sp = span.with_hi(segment.ident.span.lo());\n-    // remove the trailing ::\n-    let span_without_last_segment = match snippet_opt(cx, sp) {\n-        Some(snippet) => match snippet.rfind(\"::\") {\n-            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n-            None => sp,\n-        },\n-        None => sp,\n-    };\n-    span_lint(cx, span_without_last_segment);\n-}\n-\n-fn span_lint_on_path_until_last_segment(cx: &LateContext<'_>, path: &Path<'_>) {\n-    if path.segments.len() > 1 {\n-        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n-    }\n-}\n-\n-fn span_lint_on_qpath_resolved(cx: &LateContext<'_>, qpath: &QPath<'_>, until_last_segment: bool) {\n-    if let QPath::Resolved(_, path) = qpath {\n-        if until_last_segment {\n-            span_lint_on_path_until_last_segment(cx, path);\n-        } else {\n-            span_lint(cx, path.span);\n-        }\n-    }\n-}\n-\n-fn ty_from_hir_id<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Ty<'tcx> {\n-    if let Some(Node::Ty(hir_ty)) = cx.tcx.hir().find(hir_id) {\n-        hir_ty_to_ty(cx.tcx, hir_ty)\n-    } else {\n-        unreachable!(\"This function should only be called with `HirId`s that are for sure `Node::Ty`\")\n-    }\n-}\n-\n-fn in_impl(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> bool {\n-    let map = cx.tcx.hir();\n-    let parent = map.get_parent_node(hir_ty.hir_id);\n-    if_chain! {\n-        if let Some(Node::Item(item)) = map.find(parent);\n-        if let ItemKind::Impl { .. } = item.kind;\n-        then {\n-            true\n-        } else {\n-            false\n-        }\n+fn lint_path_to_variant(cx: &LateContext<'_>, path: &Path<'_>) {\n+    if let [.., self_seg, _variant] = path.segments {\n+        let span = path\n+            .span\n+            .with_hi(self_seg.args().span_ext().unwrap_or(self_seg.ident.span).hi());\n+        span_lint(cx, span);\n     }\n }\n \n-fn should_lint_ty(hir_ty: &hir::Ty<'_>, ty: Ty<'_>, self_ty: Ty<'_>) -> bool {\n-    if_chain! {\n-        if same_type_and_consts(ty, self_ty);\n-        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n-        then {\n-            !matches!(path.res, def::Res::SelfTy(..))\n-        } else {\n-            false\n-        }\n-    }\n+fn is_item_interesting(item: &Item<'_>) -> bool {\n+    use rustc_hir::ItemKind::{Const, Enum, Fn, Impl, Static, Struct, Trait, Union};\n+    matches!(\n+        item.kind,\n+        Impl { .. } | Static(..) | Const(..) | Fn(..) | Enum(..) | Struct(..) | Union(..) | Trait(..)\n+    )\n }"}, {"sha": "c97f7e1626e76291df3ecea23dfd579116950dc0", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     }\n                 }\n                 if_chain! {\n-                    if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\";\n+                    if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && name.ident.name == sym::try_into;\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(&args[0]);\n                     if is_type_diagnostic_item(cx, a, sym::result_type);"}, {"sha": "44d3d4563428d4f4de8a937a1e85263d70a4b558", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -8,6 +8,13 @@ use std::error::Error;\n use std::path::{Path, PathBuf};\n use std::{env, fmt, fs, io};\n \n+/// Holds information used by `MISSING_ENFORCED_IMPORT_RENAMES` lint.\n+#[derive(Clone, Debug, Deserialize)]\n+pub struct Rename {\n+    pub path: String,\n+    pub rename: String,\n+}\n+\n /// Conf with parse errors\n #[derive(Default)]\n pub struct TryConf {\n@@ -24,6 +31,9 @@ impl TryConf {\n     }\n }\n \n+/// Note that the configuration parsing currently doesn't support documentation that will\n+/// that spans over several lines. This will be possible with the new implementation\n+/// See (rust-clippy#7172)\n macro_rules! define_Conf {\n     ($(\n         #[doc = $doc:literal]\n@@ -149,7 +159,7 @@ define_Conf! {\n         \"WebGL\",\n         \"TensorFlow\",\n         \"TrueType\",\n-        \"iOS\", \"macOS\",\n+        \"iOS\", \"macOS\", \"FreeBSD\",\n         \"TeX\", \"LaTeX\", \"BibTeX\", \"BibLaTeX\",\n         \"MinGW\",\n         \"CamelCase\",\n@@ -182,20 +192,28 @@ define_Conf! {\n     (vec_box_size_threshold: u64 = 4096),\n     /// Lint: TYPE_REPETITION_IN_BOUNDS. The maximum number of bounds a trait can have to be linted\n     (max_trait_bounds: u64 = 3),\n-    /// Lint: STRUCT_EXCESSIVE_BOOLS. The maximum number of bools a struct can have\n+    /// Lint: STRUCT_EXCESSIVE_BOOLS. The maximum number of bool fields a struct can have\n     (max_struct_bools: u64 = 3),\n-    /// Lint: FN_PARAMS_EXCESSIVE_BOOLS. The maximum number of bools function parameters can have\n+    /// Lint: FN_PARAMS_EXCESSIVE_BOOLS. The maximum number of bool parameters a function can have\n     (max_fn_params_bools: u64 = 3),\n     /// Lint: WILDCARD_IMPORTS. Whether to allow certain wildcard imports (prelude, super in tests).\n     (warn_on_all_wildcard_imports: bool = false),\n     /// Lint: DISALLOWED_METHOD. The list of disallowed methods, written as fully qualified paths.\n     (disallowed_methods: Vec<String> = Vec::new()),\n+    /// Lint: DISALLOWED_TYPE. The list of disallowed types, written as fully qualified paths.\n+    (disallowed_types: Vec<String> = Vec::new()),\n     /// Lint: UNREADABLE_LITERAL. Should the fraction of a decimal be linted to include separators.\n     (unreadable_literal_lint_fractions: bool = true),\n     /// Lint: UPPER_CASE_ACRONYMS. Enables verbose mode. Triggers if there is more than one uppercase char next to each other\n     (upper_case_acronyms_aggressive: bool = false),\n     /// Lint: _CARGO_COMMON_METADATA. For internal testing only, ignores the current `publish` settings in the Cargo manifest.\n     (cargo_ignore_publish: bool = false),\n+    /// Lint: NONSTANDARD_MACRO_BRACES. Enforce the named macros always use the braces specified. <br> A `MacroMatcher` can be added like so `{ name = \"macro_name\", brace = \"(\" }`. If the macro is could be used with a full path two `MacroMatcher`s have to be added one with the full path `crate_name::macro_name` and one with just the macro name.\n+    (standard_macro_braces: Vec<crate::nonstandard_macro_braces::MacroMatcher> = Vec::new()),\n+    /// Lint: MISSING_ENFORCED_IMPORT_RENAMES. The list of imports to always rename, a fully qualified path followed by the rename.\n+    (enforced_import_renames: Vec<crate::utils::conf::Rename> = Vec::new()),\n+    /// Lint: RESTRICTED_SCRIPTS. The list of unicode scripts allowed to be used in the scope.\n+    (allowed_scripts: Vec<String> = vec![\"Latin\".to_string()]),\n }\n \n /// Search for the configuration file."}, {"sha": "e877af09e28900d94f5491a828b93bffabed4388", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -9,6 +9,7 @@\n //! a simple mistake)\n \n use if_chain::if_chain;\n+use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{\n     self as hir, def::DefKind, intravisit, intravisit::Visitor, ExprKind, Item, ItemKind, Mutability, QPath,\n@@ -46,8 +47,9 @@ const DEPRECATED_LINT_GROUP_STR: &str = \"deprecated\";\n const DEPRECATED_LINT_LEVEL: &str = \"none\";\n /// This array holds Clippy's lint groups with their corresponding default lint level. The\n /// lint level for deprecated lints is set in `DEPRECATED_LINT_LEVEL`.\n-const DEFAULT_LINT_LEVELS: [(&str, &str); 8] = [\n+const DEFAULT_LINT_LEVELS: &[(&str, &str)] = &[\n     (\"correctness\", \"deny\"),\n+    (\"suspicious\", \"warn\"),\n     (\"restriction\", \"allow\"),\n     (\"style\", \"warn\"),\n     (\"pedantic\", \"allow\"),\n@@ -485,16 +487,32 @@ fn extract_attr_docs_or_lint(cx: &LateContext<'_>, item: &Item<'_>) -> Option<St\n ///\n /// Would result in `Hello world!\\n=^.^=\\n`\n fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n-    cx.tcx\n-        .hir()\n-        .attrs(item.hir_id())\n-        .iter()\n-        .filter_map(|x| x.doc_str().map(|sym| sym.as_str().to_string()))\n-        .reduce(|mut acc, sym| {\n-            acc.push_str(&sym);\n-            acc.push('\\n');\n-            acc\n-        })\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    let mut lines = attrs.iter().filter_map(ast::Attribute::doc_str);\n+    let mut docs = String::from(&*lines.next()?.as_str());\n+    let mut in_code_block = false;\n+    for line in lines {\n+        docs.push('\\n');\n+        let line = line.as_str();\n+        let line = &*line;\n+        if let Some(info) = line.trim_start().strip_prefix(\"```\") {\n+            in_code_block = !in_code_block;\n+            if in_code_block {\n+                let lang = info\n+                    .trim()\n+                    .split(',')\n+                    // remove rustdoc directives\n+                    .find(|&s| !matches!(s, \"\" | \"ignore\" | \"no_run\" | \"should_panic\"))\n+                    // if no language is present, fill in \"rust\"\n+                    .unwrap_or(\"rust\");\n+                docs.push_str(\"```\");\n+                docs.push_str(lang);\n+                continue;\n+            }\n+        }\n+        docs.push_str(line);\n+    }\n+    Some(docs)\n }\n \n fn get_lint_group_and_level_or_lint("}, {"sha": "520586b3a1f426e093a18dc1a4dafd10739c7e3f", "filename": "clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::{in_macro, is_test_module_or_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -106,7 +106,7 @@ impl_lint_pass!(WildcardImports => [ENUM_GLOB_USE, WILDCARD_IMPORTS]);\n \n impl LateLintPass<'_> for WildcardImports {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n-        if is_test_module_or_function(item) {\n+        if is_test_module_or_function(cx.tcx, item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n         }\n         if item.vis.node.is_pub() || item.vis.node.is_pub_restricted() {\n@@ -183,8 +183,8 @@ impl LateLintPass<'_> for WildcardImports {\n         }\n     }\n \n-    fn check_item_post(&mut self, _: &LateContext<'_>, item: &Item<'_>) {\n-        if is_test_module_or_function(item) {\n+    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_test_module_or_function(cx.tcx, item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_sub(1);\n         }\n     }\n@@ -208,7 +208,3 @@ fn is_prelude_import(segments: &[PathSegment<'_>]) -> bool {\n fn is_super_only_import(segments: &[PathSegment<'_>]) -> bool {\n     segments.len() == 1 && segments[0].ident.name == kw::Super\n }\n-\n-fn is_test_module_or_function(item: &Item<'_>) -> bool {\n-    matches!(item.kind, ItemKind::Mod(..)) && item.ident.name.as_str().contains(\"test\")\n-}"}, {"sha": "6ede9011208305f5905f25435744c1bf8e735ce2", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.54\"\n+version = \"0.1.55\"\n authors = [\"The Rust Clippy Developers\"]\n edition = \"2018\"\n publish = false"}, {"sha": "30c2260d15cacdeb05d30416ff5d0c6276c2ecb2", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -47,9 +47,14 @@ pub fn eq_pat(l: &Pat, r: &Pat) -> bool {\n         | (Ref(l, Mutability::Mut), Ref(r, Mutability::Mut)) => eq_pat(l, r),\n         (Tuple(l), Tuple(r)) | (Slice(l), Slice(r)) => over(l, r, |l, r| eq_pat(l, r)),\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n-        (TupleStruct(lqself, lp, lfs), TupleStruct(rqself, rp, rfs)) => eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r)),\n+        (TupleStruct(lqself, lp, lfs), TupleStruct(rqself, rp, rfs)) => {\n+            eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r))\n+        },\n         (Struct(lqself, lp, lfs, lr), Struct(rqself, rp, rfs, rr)) => {\n-            lr == rr && eq_maybe_qself(lqself, rqself) &&eq_path(lp, rp) && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n+            lr == rr\n+                && eq_maybe_qself(lqself, rqself)\n+                && eq_path(lp, rp)\n+                && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n         },\n         (Or(ls), Or(rs)) => unordered_over(ls, rs, |l, r| eq_pat(l, r)),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -82,7 +87,7 @@ pub fn eq_maybe_qself(l: &Option<QSelf>, r: &Option<QSelf>) -> bool {\n     match (l, r) {\n         (Some(l), Some(r)) => eq_qself(l, r),\n         (None, None) => true,\n-        _ => false\n+        _ => false,\n     }\n }\n "}, {"sha": "c19b558cd8c6e044902c2713e8f169fd2113920d", "filename": "clippy_utils/src/attrs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -157,3 +157,8 @@ pub fn is_doc_hidden(attrs: &[ast::Attribute]) -> bool {\n         .filter_map(ast::Attribute::meta_item_list)\n         .any(|l| attr::list_contains_name(&l, sym::hidden))\n }\n+\n+/// Return true if the attributes contain `#[unstable]`\n+pub fn is_unstable(attrs: &[ast::Attribute]) -> bool {\n+    attrs.iter().any(|attr| attr.has_name(sym::unstable))\n+}"}, {"sha": "15c27d1a996d74e97abfc58d4f9752405b8f727a", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::float_cmp)]\n \n-use crate::{clip, sext, unsext};\n+use crate::{clip, is_direct_expn_of, sext, unsext};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitFloatType, LitKind};\n use rustc_data_structures::sync::Lrc;\n@@ -230,7 +230,13 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         match e.kind {\n             ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n             ExprKind::Block(block, _) => self.block(block),\n-            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n+            ExprKind::Lit(ref lit) => {\n+                if is_direct_expn_of(e.span, \"cfg\").is_some() {\n+                    None\n+                } else {\n+                    Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e)))\n+                }\n+            },\n             ExprKind::Array(vec) => self.multi(vec).map(Constant::Vec),\n             ExprKind::Tup(tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(value, _) => {"}, {"sha": "ef4854afc83cedeabf594430b3a2ad0d24ac5990", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 81, "deletions": 25, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -72,7 +72,7 @@ use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n     ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    PathSegment, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -326,16 +326,6 @@ pub fn is_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol)\n         .map_or(false, |did| is_diag_trait_item(cx, did, diag_item))\n }\n \n-/// Checks if an expression references a variable of the given name.\n-pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n-    if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n-        if let [p] = path.segments {\n-            return p.ident.name == var;\n-        }\n-    }\n-    false\n-}\n-\n pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     match *path {\n         QPath::Resolved(_, path) => path.segments.last().expect(\"A path must have at least one segment\"),\n@@ -707,16 +697,6 @@ pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n     }\n }\n \n-/// Gets the name of a `Pat`, if any.\n-pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n-    match pat.kind {\n-        PatKind::Binding(.., ref spname, _) => Some(spname.name),\n-        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        PatKind::Box(p) | PatKind::Ref(p, _) => get_pat_name(&*p),\n-        _ => None,\n-    }\n-}\n-\n pub struct ContainsName {\n     pub name: Symbol,\n     pub result: bool,\n@@ -861,14 +841,16 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     })\n }\n \n-/// Gets the loop enclosing the given expression, if any.\n-pub fn get_enclosing_loop(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+/// Gets the loop or closure enclosing the given expression, if any.\n+pub fn get_enclosing_loop_or_closure(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     let map = tcx.hir();\n     for (_, node) in map.parent_iter(expr.hir_id) {\n         match node {\n             Node::Expr(\n-                e @ Expr {\n-                    kind: ExprKind::Loop(..),\n+                e\n+                @\n+                Expr {\n+                    kind: ExprKind::Loop(..) | ExprKind::Closure(..),\n                     ..\n                 },\n             ) => return Some(e),\n@@ -1399,6 +1381,55 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     did.map_or(false, |did| must_use_attr(cx.tcx.get_attrs(did)).is_some())\n }\n \n+/// Checks if an expression represents the identity function\n+/// Only examines closures and `std::convert::identity`\n+pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    /// Checks if a function's body represents the identity function. Looks for bodies of the form:\n+    /// * `|x| x`\n+    /// * `|x| return x`\n+    /// * `|x| { return x }`\n+    /// * `|x| { return x; }`\n+    fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n+        let id = if_chain! {\n+            if let [param] = func.params;\n+            if let PatKind::Binding(_, id, _, _) = param.pat.kind;\n+            then {\n+                id\n+            } else {\n+                return false;\n+            }\n+        };\n+\n+        let mut expr = &func.value;\n+        loop {\n+            match expr.kind {\n+                #[rustfmt::skip]\n+                ExprKind::Block(&Block { stmts: [], expr: Some(e), .. }, _, )\n+                | ExprKind::Ret(Some(e)) => expr = e,\n+                #[rustfmt::skip]\n+                ExprKind::Block(&Block { stmts: [stmt], expr: None, .. }, _) => {\n+                    if_chain! {\n+                        if let StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind;\n+                        if let ExprKind::Ret(Some(ret_val)) = e.kind;\n+                        then {\n+                            expr = ret_val;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                },\n+                _ => return path_to_local_id(expr, id) && cx.typeck_results().expr_adjustments(expr).is_empty(),\n+            }\n+        }\n+    }\n+\n+    match expr.kind {\n+        ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n+        ExprKind::Path(ref path) => is_qpath_def_path(cx, path, expr.hir_id, &paths::CONVERT_IDENTITY),\n+        _ => false,\n+    }\n+}\n+\n /// Gets the node where an expression is either used, or it's type is unified with another branch.\n pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n     let map = tcx.hir();\n@@ -1654,6 +1685,19 @@ pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     (e, count)\n }\n \n+/// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n+/// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n+pub fn peel_ref_operators<'hir>(cx: &LateContext<'_>, mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    loop {\n+        match expr.kind {\n+            ExprKind::AddrOf(_, _, e) => expr = e,\n+            ExprKind::Unary(UnOp::Deref, e) if cx.typeck_results().expr_ty(e).is_ref() => expr = e,\n+            _ => break,\n+        }\n+    }\n+    expr\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{\n@@ -1683,3 +1727,15 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n         }\n     }\n }\n+\n+/// Checks whether item either has `test` attribute applied, or\n+/// is a module with `test` in its name.\n+pub fn is_test_module_or_function(tcx: TyCtxt<'_>, item: &Item<'_>) -> bool {\n+    if let Some(def_id) = tcx.hir().opt_local_def_id(item.hir_id()) {\n+        if tcx.has_attr(def_id.to_def_id(), sym::test) {\n+            return true;\n+        }\n+    }\n+\n+    matches!(item.kind, ItemKind::Mod(..)) && item.ident.name.as_str().contains(\"test\")\n+}"}, {"sha": "8adb691595213fd80cd036f1aa50fa20cadd97a1", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,10 +1,10 @@\n use crate::source::snippet;\n-use crate::{get_pat_name, match_var};\n+use crate::{path_to_local_id, strip_pat_refs};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Body, BodyId, Expr, ExprKind, Param};\n+use rustc_hir::{Body, BodyId, Expr, ExprKind, HirId, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use std::borrow::Cow;\n \n pub fn get_spans(\n@@ -14,24 +14,25 @@ pub fn get_spans(\n     replacements: &[(&'static str, &'static str)],\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     if let Some(body) = opt_body_id.map(|id| cx.tcx.hir().body(id)) {\n-        get_binding_name(&body.params[idx]).map_or_else(\n-            || Some(vec![]),\n-            |name| extract_clone_suggestions(cx, name, replacements, body),\n-        )\n+        if let PatKind::Binding(_, binding_id, _, _) = strip_pat_refs(body.params[idx].pat).kind {\n+            extract_clone_suggestions(cx, binding_id, replacements, body)\n+        } else {\n+            Some(vec![])\n+        }\n     } else {\n         Some(vec![])\n     }\n }\n \n fn extract_clone_suggestions<'tcx>(\n     cx: &LateContext<'tcx>,\n-    name: Symbol,\n+    id: HirId,\n     replace: &[(&'static str, &'static str)],\n     body: &'tcx Body<'_>,\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     let mut visitor = PtrCloneVisitor {\n         cx,\n-        name,\n+        id,\n         replace,\n         spans: vec![],\n         abort: false,\n@@ -42,7 +43,7 @@ fn extract_clone_suggestions<'tcx>(\n \n struct PtrCloneVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    name: Symbol,\n+    id: HirId,\n     replace: &'a [(&'static str, &'static str)],\n     spans: Vec<(Span, Cow<'static, str>)>,\n     abort: bool,\n@@ -55,16 +56,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprKind::MethodCall(seg, _, args, _) = expr.kind {\n-            if args.len() == 1 && match_var(&args[0], self.name) {\n+        if let ExprKind::MethodCall(seg, _, [recv], _) = expr.kind {\n+            if path_to_local_id(recv, self.id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     self.abort = true;\n                     return;\n                 }\n                 for &(fn_name, suffix) in self.replace {\n                     if seg.ident.name.as_str() == fn_name {\n-                        self.spans\n-                            .push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n+                        self.spans.push((expr.span, snippet(self.cx, recv.span, \"_\") + suffix));\n                         return;\n                     }\n                 }\n@@ -77,7 +77,3 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n }\n-\n-fn get_binding_name(arg: &Param<'_>) -> Option<Symbol> {\n-    get_pat_name(arg.pat)\n-}"}, {"sha": "e98354358af62a10c91ea9992426928b35131323", "filename": "doc/basics.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/doc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/doc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbasics.md?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -90,8 +90,10 @@ cargo dev fmt\n cargo dev update_lints\n # create a new lint and register it\n cargo dev new_lint\n+# automatically formatting all code before each commit\n+cargo dev setup git-hook\n # (experimental) Setup Clippy to work with IntelliJ-Rust\n-cargo dev ide_setup\n+cargo dev setup intellij\n ```\n \n ## lintcheck"}, {"sha": "0a85f65001101c4fa5a172ac462b73d781e5e125", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -6,7 +6,7 @@ You may need following tooltips to catch up with common operations.\n   - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n   - [Checking if an expression is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n   - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n-  - [Checking if a type defines a method](#checking-if-a-type-defines-a-method)\n+  - [Checking if a type defines a specific method](#checking-if-a-type-defines-a-specific-method)\n   - [Dealing with macros](#dealing-with-macros)\n \n Useful Rustc dev guide links:"}, {"sha": "afe3033c288cffd8d95b06ea2e833989455cb81a", "filename": "doc/release.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/doc%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/doc%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frelease.md?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -101,6 +101,21 @@ After this, the release should be available on the Clippy [release page].\n \n [release page]: https://github.com/rust-lang/rust-clippy/releases\n \n+## Update the `stable` branch\n+\n+At this step you should have already checked out the commit of the `rust-1.XX.0`\n+tag. Updating the stable branch from here is as easy as:\n+\n+```bash\n+# Assuming the current directory corresponds to the Clippy repository and the\n+# commit of the just created rust-1.XX.0 tag is checked out.\n+$ git push upstream rust-1.XX.0:stable  # `upstream` is the `rust-lang/rust-clippy` remote\n+```\n+\n+_NOTE: Usually there are no stable backports for Clippy, so this update should\n+be possible without force pushing or anything like this. If there should have\n+happened a stable backport, make sure to re-merge those changes just as with the\n+`beta` branch._\n \n ## Update `CHANGELOG.md`\n "}, {"sha": "8c169506e533d7b7892ff558924ca46c784529ca", "filename": "lintcheck/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/lintcheck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/lintcheck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FREADME.md?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -69,7 +69,7 @@ is checked.\n is explicitly specified in the options.\n \n ### Fix mode\n-You can run `./lintcheck/target/debug/lintcheck --fix` which will run Clippy with `-Zunstable-options --fix` and\n+You can run `./lintcheck/target/debug/lintcheck --fix` which will run Clippy with `--fix` and\n print a warning if Clippys suggestions fail to apply (if the resulting code does not build).  \n This lets us spot bad suggestions or false positives automatically in some cases.  \n "}, {"sha": "7d2f3173fb0e7cd4d5d475decac18787b14f60b0", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -260,14 +260,7 @@ impl Crate {\n         let shared_target_dir = clippy_project_root().join(\"target/lintcheck/shared_target_dir\");\n \n         let mut args = if fix {\n-            vec![\n-                \"-Zunstable-options\",\n-                \"--fix\",\n-                \"-Zunstable-options\",\n-                \"--allow-no-vcs\",\n-                \"--\",\n-                \"--cap-lints=warn\",\n-            ]\n+            vec![\"--fix\", \"--allow-no-vcs\", \"--\", \"--cap-lints=warn\"]\n         } else {\n             vec![\"--\", \"--message-format=json\", \"--\", \"--cap-lints=warn\"]\n         };"}, {"sha": "cd73478715aeec179ae00f0e24c8d121fee7a1e3", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-06-03\"\n+channel = \"nightly-2021-06-17\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "6bd4123ddeb45d92917f1dd043fa9d09ecf208de", "filename": "src/main.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -70,7 +70,6 @@ impl ClippyCmd {\n         I: Iterator<Item = String>,\n     {\n         let mut cargo_subcommand = \"check\";\n-        let mut unstable_options = false;\n         let mut args = vec![];\n \n         for arg in old_args.by_ref() {\n@@ -80,18 +79,12 @@ impl ClippyCmd {\n                     continue;\n                 },\n                 \"--\" => break,\n-                // Cover -Zunstable-options and -Z unstable-options\n-                s if s.ends_with(\"unstable-options\") => unstable_options = true,\n                 _ => {},\n             }\n \n             args.push(arg);\n         }\n \n-        if cargo_subcommand == \"fix\" && !unstable_options {\n-            panic!(\"Usage of `--fix` requires `-Z unstable-options`\");\n-        }\n-\n         let mut clippy_args: Vec<String> = old_args.collect();\n         if cargo_subcommand == \"fix\" && !clippy_args.iter().any(|arg| arg == \"--no-deps\") {\n             clippy_args.push(\"--no-deps\".into());\n@@ -176,34 +169,23 @@ mod tests {\n     use super::ClippyCmd;\n \n     #[test]\n-    #[should_panic]\n-    fn fix_without_unstable() {\n+    fn fix() {\n         let args = \"cargo clippy --fix\".split_whitespace().map(ToString::to_string);\n-        ClippyCmd::new(args);\n-    }\n-\n-    #[test]\n-    fn fix_unstable() {\n-        let args = \"cargo clippy --fix -Zunstable-options\"\n-            .split_whitespace()\n-            .map(ToString::to_string);\n         let cmd = ClippyCmd::new(args);\n         assert_eq!(\"fix\", cmd.cargo_subcommand);\n-        assert!(cmd.args.iter().any(|arg| arg.ends_with(\"unstable-options\")));\n+        assert!(!cmd.args.iter().any(|arg| arg.ends_with(\"unstable-options\")));\n     }\n \n     #[test]\n     fn fix_implies_no_deps() {\n-        let args = \"cargo clippy --fix -Zunstable-options\"\n-            .split_whitespace()\n-            .map(ToString::to_string);\n+        let args = \"cargo clippy --fix\".split_whitespace().map(ToString::to_string);\n         let cmd = ClippyCmd::new(args);\n         assert!(cmd.clippy_args.iter().any(|arg| arg == \"--no-deps\"));\n     }\n \n     #[test]\n     fn no_deps_not_duplicated_with_fix() {\n-        let args = \"cargo clippy --fix -Zunstable-options -- --no-deps\"\n+        let args = \"cargo clippy --fix -- --no-deps\"\n             .split_whitespace()\n             .map(ToString::to_string);\n         let cmd = ClippyCmd::new(args);"}, {"sha": "caa19e39ccd3af1baad8a61ad79688cabee02c8d", "filename": "tests/compile-test.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -48,7 +48,24 @@ fn third_party_crates() -> String {\n                     && name.rsplit('.').next().map(|ext| ext.eq_ignore_ascii_case(\"rlib\")) == Some(true)\n                 {\n                     if let Some(old) = crates.insert(dep, path.clone()) {\n-                        panic!(\"Found multiple rlibs for crate `{}`: `{:?}` and `{:?}\", dep, old, path);\n+                        // Check which action should be done in order to remove compiled deps.\n+                        // If pre-installed version of compiler is used, `cargo clean` will do.\n+                        // Otherwise (for bootstrapped compiler), the dependencies directory\n+                        // must be removed manually.\n+                        let suggested_action = if std::env::var_os(\"RUSTC_BOOTSTRAP\").is_some() {\n+                            \"remove the stageN-tools directory\"\n+                        } else {\n+                            \"run `cargo clean`\"\n+                        };\n+\n+                        panic!(\n+                            \"\\n---------------------------------------------------\\n\\n \\\n+                            Found multiple rlibs for crate `{}`: `{:?}` and `{:?}`.\\n \\\n+                            Probably, you need to {} before running tests again.\\n \\\n+                            \\nFor details on that error see https://github.com/rust-lang/rust-clippy/issues/7343 \\\n+                            \\n---------------------------------------------------\\n\",\n+                            dep, old, path, suggested_action\n+                        );\n                     }\n                     break;\n                 }"}, {"sha": "05ba822874d596f86c1acff77e0a9a285bb49d44", "filename": "tests/ui-toml/missing_enforced_import_rename/clippy.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fclippy.toml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,10 @@\n+enforced-import-renames = [\n+    { path = \"std::option::Option\", rename = \"Maybe\" },\n+    { path = \"std::process::Child\", rename = \"Kid\" },\n+    { path = \"std::process::exit\", rename = \"goodbye\" },\n+    { path = \"std::collections::BTreeMap\", rename = \"Map\" },\n+    { path = \"std::clone\", rename = \"foo\" },\n+    { path = \"std::thread::sleep\", rename = \"thread_sleep\" },\n+    { path = \"std::any::type_name\", rename = \"ident\" },\n+    { path = \"std::sync::Mutex\", rename = \"StdMutie\" }\n+]"}, {"sha": "f60058c862888670b741b9229c8ff6d3ce549f38", "filename": "tests/ui-toml/missing_enforced_import_rename/conf_missing_enforced_import_rename.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fconf_missing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fconf_missing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fconf_missing_enforced_import_rename.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,16 @@\n+#![warn(clippy::missing_enforced_import_renames)]\n+\n+use std::alloc as colla;\n+use std::option::Option as Maybe;\n+use std::process::{exit as wrong_exit, Child as Kid};\n+use std::thread::sleep;\n+#[rustfmt::skip]\n+use std::{\n+    any::{type_name, Any},\n+    clone,\n+    sync :: Mutex,\n+};\n+\n+fn main() {\n+    use std::collections::BTreeMap as OopsWrongRename;\n+}"}, {"sha": "45de8fdffef76d3e22687d9becc41b61d0a9590e", "filename": "tests/ui-toml/missing_enforced_import_rename/conf_missing_enforced_import_rename.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fconf_missing_enforced_import_rename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fconf_missing_enforced_import_rename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmissing_enforced_import_rename%2Fconf_missing_enforced_import_rename.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,40 @@\n+error: this import should be renamed\n+  --> $DIR/conf_missing_enforced_import_rename.rs:5:20\n+   |\n+LL | use std::process::{exit as wrong_exit, Child as Kid};\n+   |                    ^^^^^^^^^^^^^^^^^^ help: try: `exit as goodbye`\n+   |\n+   = note: `-D clippy::missing-enforced-import-renames` implied by `-D warnings`\n+\n+error: this import should be renamed\n+  --> $DIR/conf_missing_enforced_import_rename.rs:6:1\n+   |\n+LL | use std::thread::sleep;\n+   | ^^^^^^^^^^^^^^^^^^^^^^ help: try: `use std::thread::sleep as thread_sleep`\n+\n+error: this import should be renamed\n+  --> $DIR/conf_missing_enforced_import_rename.rs:9:11\n+   |\n+LL |     any::{type_name, Any},\n+   |           ^^^^^^^^^ help: try: `type_name as ident`\n+\n+error: this import should be renamed\n+  --> $DIR/conf_missing_enforced_import_rename.rs:10:5\n+   |\n+LL |     clone,\n+   |     ^^^^^ help: try: `clone as foo`\n+\n+error: this import should be renamed\n+  --> $DIR/conf_missing_enforced_import_rename.rs:11:5\n+   |\n+LL |     sync :: Mutex,\n+   |     ^^^^^^^^^^^^^ help: try: `sync :: Mutex as StdMutie`\n+\n+error: this import should be renamed\n+  --> $DIR/conf_missing_enforced_import_rename.rs:15:5\n+   |\n+LL |     use std::collections::BTreeMap as OopsWrongRename;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `use std::collections::BTreeMap as Map`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "bced8948a02412124fda554499a11a82e99ffc9f", "filename": "tests/ui-toml/nonstandard_macro_braces/clippy.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fclippy.toml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,6 @@\n+standard-macro-braces = [\n+    { name = \"quote\", brace = \"{\" },\n+    { name = \"quote::quote\", brace = \"{\" },\n+    { name = \"eprint\", brace = \"[\" },\n+    { name = \"type_pos\", brace = \"[\" },\n+]"}, {"sha": "4ae6864cbb0b8b23f5a9c6d6213fea82b53aea73", "filename": "tests/ui-toml/nonstandard_macro_braces/conf_nonstandard_macro_braces.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,44 @@\n+// #![warn(clippy::nonstandard_macro_braces)]\n+\n+extern crate quote;\n+\n+use quote::quote;\n+\n+#[rustfmt::skip]\n+macro_rules! test {\n+    () => {\n+        vec!{0, 0, 0}\n+    };\n+}\n+\n+#[rustfmt::skip]\n+macro_rules! test2 {\n+    ($($arg:tt)*) => {\n+        format_args!($($arg)*)\n+    };\n+}\n+\n+macro_rules! type_pos {\n+    ($what:ty) => {\n+        Vec<$what>\n+    };\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    let _ = vec! {1, 2, 3};\n+    let _ = format![\"ugh {} stop being such a good compiler\", \"hello\"];\n+    let _ = quote!(let x = 1;);\n+    let _ = quote::quote!(match match match);\n+    let _ = test!();\n+    let _ = vec![1,2,3];\n+\n+    let _ = quote::quote! {true || false};\n+    let _ = vec! [0 ,0 ,0];\n+    let _ = format!(\"fds{}fds\", 10);\n+    let _ = test2![\"{}{}{}\", 1, 2, 3];\n+\n+    let _: type_pos!(usize) = vec![];\n+\n+    eprint!(\"test if user config overrides defaults\");\n+}"}, {"sha": "7bcd1829524ddcb208ae6e791a26c6fb2757e1ad", "filename": "tests/ui-toml/nonstandard_macro_braces/conf_nonstandard_macro_braces.stderr", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,94 @@\n+error: use of irregular braces for `vec!` macro\n+  --> $DIR/conf_nonstandard_macro_braces.rs:29:13\n+   |\n+LL |     let _ = vec! {1, 2, 3};\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::nonstandard-macro-braces` implied by `-D warnings`\n+help: consider writing `vec![1, 2, 3]`\n+  --> $DIR/conf_nonstandard_macro_braces.rs:29:13\n+   |\n+LL |     let _ = vec! {1, 2, 3};\n+   |             ^^^^^^^^^^^^^^\n+\n+error: use of irregular braces for `format!` macro\n+  --> $DIR/conf_nonstandard_macro_braces.rs:30:13\n+   |\n+LL |     let _ = format![\"ugh {} stop being such a good compiler\", \"hello\"];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider writing `format!(\"ugh () stop being such a good compiler\", \"hello\")`\n+  --> $DIR/conf_nonstandard_macro_braces.rs:30:13\n+   |\n+LL |     let _ = format![\"ugh {} stop being such a good compiler\", \"hello\"];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: use of irregular braces for `quote!` macro\n+  --> $DIR/conf_nonstandard_macro_braces.rs:31:13\n+   |\n+LL |     let _ = quote!(let x = 1;);\n+   |             ^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider writing `quote! {let x = 1;}`\n+  --> $DIR/conf_nonstandard_macro_braces.rs:31:13\n+   |\n+LL |     let _ = quote!(let x = 1;);\n+   |             ^^^^^^^^^^^^^^^^^^\n+\n+error: use of irregular braces for `quote::quote!` macro\n+  --> $DIR/conf_nonstandard_macro_braces.rs:32:13\n+   |\n+LL |     let _ = quote::quote!(match match match);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider writing `quote::quote! {match match match}`\n+  --> $DIR/conf_nonstandard_macro_braces.rs:32:13\n+   |\n+LL |     let _ = quote::quote!(match match match);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: use of irregular braces for `vec!` macro\n+  --> $DIR/conf_nonstandard_macro_braces.rs:10:9\n+   |\n+LL |         vec!{0, 0, 0}\n+   |         ^^^^^^^^^^^^^\n+...\n+LL |     let _ = test!();\n+   |             ------- in this macro invocation\n+   |\n+help: consider writing `vec![0, 0, 0]`\n+  --> $DIR/conf_nonstandard_macro_braces.rs:10:9\n+   |\n+LL |         vec!{0, 0, 0}\n+   |         ^^^^^^^^^^^^^\n+...\n+LL |     let _ = test!();\n+   |             ------- in this macro invocation\n+   = note: this error originates in the macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: use of irregular braces for `type_pos!` macro\n+  --> $DIR/conf_nonstandard_macro_braces.rs:41:12\n+   |\n+LL |     let _: type_pos!(usize) = vec![];\n+   |            ^^^^^^^^^^^^^^^^\n+   |\n+help: consider writing `type_pos![usize]`\n+  --> $DIR/conf_nonstandard_macro_braces.rs:41:12\n+   |\n+LL |     let _: type_pos!(usize) = vec![];\n+   |            ^^^^^^^^^^^^^^^^\n+\n+error: use of irregular braces for `eprint!` macro\n+  --> $DIR/conf_nonstandard_macro_braces.rs:43:5\n+   |\n+LL |     eprint!(\"test if user config overrides defaults\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider writing `eprint![\"test if user config overrides defaults\"];`\n+  --> $DIR/conf_nonstandard_macro_braces.rs:43:5\n+   |\n+LL |     eprint!(\"test if user config overrides defaults\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "a3245da68250c3d28939ddb5da02dc08fbb938ce", "filename": "tests/ui-toml/toml_disallowed_method/clippy.toml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1 +1,5 @@\n-disallowed-methods = [\"core::iter::traits::iterator::Iterator::sum\", \"regex::re_unicode::Regex::is_match\", \"regex::re_unicode::Regex::new\"]\n+disallowed-methods = [\n+    \"std::iter::Iterator::sum\",\n+    \"regex::Regex::is_match\",\n+    \"regex::Regex::new\"\n+]"}, {"sha": "2eff854c22c3078e55432a8297c3b52190041de1", "filename": "tests/ui-toml/toml_disallowed_type/clippy.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,9 @@\n+disallowed-types = [\n+    \"std::collections::HashMap\",\n+    \"std::sync::atomic::AtomicU32\",\n+    \"syn::TypePath\",\n+    \"proc_macro2::Ident\",\n+    \"std::thread::Thread\",\n+    \"std::time::Instant\",\n+    \"std::io::Read\",\n+]"}, {"sha": "567afb5aec1df83290478d785c28621b15c619fb", "filename": "tests/ui-toml/toml_disallowed_type/conf_disallowed_type.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,35 @@\n+#![warn(clippy::disallowed_type)]\n+\n+extern crate quote;\n+extern crate syn;\n+\n+use std::sync as foo;\n+use std::sync::atomic::AtomicU32;\n+use std::time::Instant as Sneaky;\n+\n+struct HashMap;\n+\n+fn bad_return_type() -> fn() -> Sneaky {\n+    todo!()\n+}\n+\n+fn bad_arg_type(_: impl Fn(Sneaky) -> foo::atomic::AtomicU32) {\n+    todo!()\n+}\n+\n+fn trait_obj(_: &dyn std::io::Read) {\n+    todo!()\n+}\n+\n+static BAD: foo::atomic::AtomicPtr<()> = foo::atomic::AtomicPtr::new(std::ptr::null_mut());\n+\n+#[allow(clippy::diverging_sub_expression)]\n+fn main() {\n+    let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();\n+    let _ = Sneaky::now();\n+    let _ = foo::atomic::AtomicU32::new(0);\n+    static FOO: std::sync::atomic::AtomicU32 = foo::atomic::AtomicU32::new(1);\n+    let _: std::collections::BTreeMap<(), syn::TypePath> = Default::default();\n+    let _ = syn::Ident::new(\"\", todo!());\n+    let _ = HashMap;\n+}"}, {"sha": "4e6fd91fba1192d8d27702073679acbd609aff01", "filename": "tests/ui-toml/toml_disallowed_type/conf_disallowed_type.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,88 @@\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:7:1\n+   |\n+LL | use std::sync::atomic::AtomicU32;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::disallowed-type` implied by `-D warnings`\n+\n+error: `std::time::Instant` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:8:1\n+   |\n+LL | use std::time::Instant as Sneaky;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::time::Instant` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:12:33\n+   |\n+LL | fn bad_return_type() -> fn() -> Sneaky {\n+   |                                 ^^^^^^\n+\n+error: `std::time::Instant` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:16:28\n+   |\n+LL | fn bad_arg_type(_: impl Fn(Sneaky) -> foo::atomic::AtomicU32) {\n+   |                            ^^^^^^\n+\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:16:39\n+   |\n+LL | fn bad_arg_type(_: impl Fn(Sneaky) -> foo::atomic::AtomicU32) {\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::io::Read` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:20:22\n+   |\n+LL | fn trait_obj(_: &dyn std::io::Read) {\n+   |                      ^^^^^^^^^^^^^\n+\n+error: `std::collections::HashMap` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:28:48\n+   |\n+LL |     let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();\n+   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::collections::HashMap` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:28:12\n+   |\n+LL |     let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::time::Instant` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:29:13\n+   |\n+LL |     let _ = Sneaky::now();\n+   |             ^^^^^^\n+\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:30:13\n+   |\n+LL |     let _ = foo::atomic::AtomicU32::new(0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:31:17\n+   |\n+LL |     static FOO: std::sync::atomic::AtomicU32 = foo::atomic::AtomicU32::new(1);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:31:48\n+   |\n+LL |     static FOO: std::sync::atomic::AtomicU32 = foo::atomic::AtomicU32::new(1);\n+   |                                                ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `syn::TypePath` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:32:43\n+   |\n+LL |     let _: std::collections::BTreeMap<(), syn::TypePath> = Default::default();\n+   |                                           ^^^^^^^^^^^^^\n+\n+error: `proc_macro2::Ident` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:33:13\n+   |\n+LL |     let _ = syn::Ident::new(\"\", todo!());\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "e0029ebeb27ac4ad94966097b9c02f5914e9a4b5", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `disallowed-types`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `standard-macro-braces`, `enforced-import-renames`, `allowed-scripts`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "283358333cdfd30bb4dfef176b0c25c54cc65519", "filename": "tests/ui/append_instead_of_extend.fixed", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fappend_instead_of_extend.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fappend_instead_of_extend.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fappend_instead_of_extend.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,55 @@\n+// run-rustfix\n+#![warn(clippy::append_instead_of_extend)]\n+use std::collections::BinaryHeap;\n+fn main() {\n+    //gets linted\n+    let mut vec1 = vec![0u8; 1024];\n+    let mut vec2: std::vec::Vec<u8> = Vec::new();\n+\n+    vec2.append(&mut vec1);\n+\n+    let mut vec3 = vec![0u8; 1024];\n+    let mut vec4: std::vec::Vec<u8> = Vec::new();\n+\n+    vec4.append(&mut vec3);\n+\n+    let mut vec11: std::vec::Vec<u8> = Vec::new();\n+\n+    vec11.append(&mut return_vector());\n+\n+    //won't get linted it dosen't move the entire content of a vec into another\n+    let mut test1 = vec![0u8, 10];\n+    let mut test2: std::vec::Vec<u8> = Vec::new();\n+\n+    test2.extend(test1.drain(4..10));\n+\n+    let mut vec3 = vec![0u8; 104];\n+    let mut vec7: std::vec::Vec<u8> = Vec::new();\n+\n+    vec3.append(&mut vec7);\n+\n+    let mut vec5 = vec![0u8; 1024];\n+    let mut vec6: std::vec::Vec<u8> = Vec::new();\n+\n+    vec5.extend(vec6.drain(..4));\n+\n+    let mut vec9: std::vec::Vec<u8> = Vec::new();\n+\n+    return_vector().append(&mut vec9);\n+\n+    //won't get linted because it is not a vec\n+\n+    let mut heap = BinaryHeap::from(vec![1, 3]);\n+    let mut heap2 = BinaryHeap::from(vec![]);\n+    heap2.extend(heap.drain())\n+}\n+\n+fn return_vector() -> Vec<u8> {\n+    let mut new_vector = vec![];\n+\n+    for i in 1..10 {\n+        new_vector.push(i)\n+    }\n+\n+    new_vector\n+}"}, {"sha": "abde5cdac5cf7f6079c3d1b77c3595b515c13d19", "filename": "tests/ui/append_instead_of_extend.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fappend_instead_of_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fappend_instead_of_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fappend_instead_of_extend.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,55 @@\n+// run-rustfix\n+#![warn(clippy::append_instead_of_extend)]\n+use std::collections::BinaryHeap;\n+fn main() {\n+    //gets linted\n+    let mut vec1 = vec![0u8; 1024];\n+    let mut vec2: std::vec::Vec<u8> = Vec::new();\n+\n+    vec2.extend(vec1.drain(..));\n+\n+    let mut vec3 = vec![0u8; 1024];\n+    let mut vec4: std::vec::Vec<u8> = Vec::new();\n+\n+    vec4.extend(vec3.drain(..));\n+\n+    let mut vec11: std::vec::Vec<u8> = Vec::new();\n+\n+    vec11.extend(return_vector().drain(..));\n+\n+    //won't get linted it dosen't move the entire content of a vec into another\n+    let mut test1 = vec![0u8, 10];\n+    let mut test2: std::vec::Vec<u8> = Vec::new();\n+\n+    test2.extend(test1.drain(4..10));\n+\n+    let mut vec3 = vec![0u8; 104];\n+    let mut vec7: std::vec::Vec<u8> = Vec::new();\n+\n+    vec3.append(&mut vec7);\n+\n+    let mut vec5 = vec![0u8; 1024];\n+    let mut vec6: std::vec::Vec<u8> = Vec::new();\n+\n+    vec5.extend(vec6.drain(..4));\n+\n+    let mut vec9: std::vec::Vec<u8> = Vec::new();\n+\n+    return_vector().append(&mut vec9);\n+\n+    //won't get linted because it is not a vec\n+\n+    let mut heap = BinaryHeap::from(vec![1, 3]);\n+    let mut heap2 = BinaryHeap::from(vec![]);\n+    heap2.extend(heap.drain())\n+}\n+\n+fn return_vector() -> Vec<u8> {\n+    let mut new_vector = vec![];\n+\n+    for i in 1..10 {\n+        new_vector.push(i)\n+    }\n+\n+    new_vector\n+}"}, {"sha": "9d309d981def99cbbc86ceeae681ed097a315b5b", "filename": "tests/ui/append_instead_of_extend.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fappend_instead_of_extend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fappend_instead_of_extend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fappend_instead_of_extend.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,22 @@\n+error: use of `extend` instead of `append` for adding the full range of a second vector\n+  --> $DIR/append_instead_of_extend.rs:9:5\n+   |\n+LL |     vec2.extend(vec1.drain(..));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `vec2.append(&mut vec1)`\n+   |\n+   = note: `-D clippy::append-instead-of-extend` implied by `-D warnings`\n+\n+error: use of `extend` instead of `append` for adding the full range of a second vector\n+  --> $DIR/append_instead_of_extend.rs:14:5\n+   |\n+LL |     vec4.extend(vec3.drain(..));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `vec4.append(&mut vec3)`\n+\n+error: use of `extend` instead of `append` for adding the full range of a second vector\n+  --> $DIR/append_instead_of_extend.rs:18:5\n+   |\n+LL |     vec11.extend(return_vector().drain(..));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `vec11.append(&mut return_vector())`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "6617ca183a8cb2cbd37c0fa60c3b4fe1a1eb23cc", "filename": "tests/ui/assertions_on_constants.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassertions_on_constants.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -28,4 +28,7 @@ fn main() {\n     debug_assert!(false); // #3948\n     assert_const!(3);\n     assert_const!(-1);\n+\n+    // Don't lint on this:\n+    assert!(cfg!(feature = \"hey\") || cfg!(not(feature = \"asdf\")));\n }"}, {"sha": "170955e726cc573853764fbaaf16b187450bada7", "filename": "tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -106,3 +106,10 @@ macro_rules! field_reassign_with_default {\n         }\n     };\n }\n+\n+#[macro_export]\n+macro_rules! default_numeric_fallback {\n+    () => {\n+        let x = 22;\n+    };\n+}"}, {"sha": "420232f9f8d89706353f530900e223ed53a7187b", "filename": "tests/ui/auxiliary/non-exhaustive-enum.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fauxiliary%2Fnon-exhaustive-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fauxiliary%2Fnon-exhaustive-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fnon-exhaustive-enum.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,8 @@\n+// Stripped down version of the ErrorKind enum of std\n+#[non_exhaustive]\n+pub enum ErrorKind {\n+    NotFound,\n+    PermissionDenied,\n+    #[doc(hidden)]\n+    Uncategorized,\n+}"}, {"sha": "57d7139fef5683d7652d5a7c968b25326564fd6a", "filename": "tests/ui/blacklisted_name.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblacklisted_name.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -43,3 +43,15 @@ fn issue_1647_ref_mut() {\n     let ref mut baz = 0;\n     if let Some(ref mut quux) = Some(42) {}\n }\n+\n+mod tests {\n+    fn issue_7305() {\n+        // `blackisted_name` lint should not be triggered inside of the test code.\n+        let foo = 0;\n+\n+        // Check that even in nested functions warning is still not triggere.\n+        fn nested() {\n+            let foo = 0;\n+        }\n+    }\n+}"}, {"sha": "c0625fd1b75e8af15b1e2af3f9d43f749963974b", "filename": "tests/ui/default_numeric_fallback.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,10 +1,15 @@\n+// aux-build:macro_rules.rs\n+\n #![warn(clippy::default_numeric_fallback)]\n #![allow(unused)]\n #![allow(clippy::never_loop)]\n #![allow(clippy::no_effect)]\n #![allow(clippy::unnecessary_operation)]\n #![allow(clippy::branches_sharing_code)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n mod basic_expr {\n     fn test() {\n         // Should lint unsuffixed literals typed `i32`.\n@@ -133,4 +138,22 @@ mod method_calls {\n     }\n }\n \n+mod in_macro {\n+    macro_rules! internal_macro {\n+        () => {\n+            let x = 22;\n+        };\n+    }\n+\n+    // Should lint in internal macro.\n+    fn internal() {\n+        internal_macro!();\n+    }\n+\n+    // Should NOT lint in external macro.\n+    fn external() {\n+        default_numeric_fallback!();\n+    }\n+}\n+\n fn main() {}"}, {"sha": "5862cd936ac104ac03822912e75bed4dd4130c61", "filename": "tests/ui/default_numeric_fallback.stderr", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdefault_numeric_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdefault_numeric_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,148 +1,159 @@\n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:11:17\n+  --> $DIR/default_numeric_fallback.rs:16:17\n    |\n LL |         let x = 22;\n    |                 ^^ help: consider adding suffix: `22_i32`\n    |\n    = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:18\n+  --> $DIR/default_numeric_fallback.rs:17:18\n    |\n LL |         let x = [1, 2, 3];\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:21\n+  --> $DIR/default_numeric_fallback.rs:17:21\n    |\n LL |         let x = [1, 2, 3];\n    |                     ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:24\n+  --> $DIR/default_numeric_fallback.rs:17:24\n    |\n LL |         let x = [1, 2, 3];\n    |                        ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:28\n+  --> $DIR/default_numeric_fallback.rs:18:28\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:31\n+  --> $DIR/default_numeric_fallback.rs:18:31\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                               ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:44\n+  --> $DIR/default_numeric_fallback.rs:18:44\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                            ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:47\n+  --> $DIR/default_numeric_fallback.rs:18:47\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                               ^ help: consider adding suffix: `4_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:14:23\n+  --> $DIR/default_numeric_fallback.rs:19:23\n    |\n LL |         let x = match 1 {\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:15:13\n+  --> $DIR/default_numeric_fallback.rs:20:13\n    |\n LL |             1 => 1,\n    |             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:15:18\n+  --> $DIR/default_numeric_fallback.rs:20:18\n    |\n LL |             1 => 1,\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:16:18\n+  --> $DIR/default_numeric_fallback.rs:21:18\n    |\n LL |             _ => 2,\n    |                  ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:20:17\n+  --> $DIR/default_numeric_fallback.rs:25:17\n    |\n LL |         let x = 0.12;\n    |                 ^^^^ help: consider adding suffix: `0.12_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:38:21\n+  --> $DIR/default_numeric_fallback.rs:43:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:46:21\n+  --> $DIR/default_numeric_fallback.rs:51:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:52:21\n+  --> $DIR/default_numeric_fallback.rs:57:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:64:9\n+  --> $DIR/default_numeric_fallback.rs:69:9\n    |\n LL |         1\n    |         ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:70:27\n+  --> $DIR/default_numeric_fallback.rs:75:27\n    |\n LL |         let f = || -> _ { 1 };\n    |                           ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:74:29\n+  --> $DIR/default_numeric_fallback.rs:79:29\n    |\n LL |         let f = || -> i32 { 1 };\n    |                             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:88:21\n+  --> $DIR/default_numeric_fallback.rs:93:21\n    |\n LL |         generic_arg(1);\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:91:32\n+  --> $DIR/default_numeric_fallback.rs:96:32\n    |\n LL |         let x: _ = generic_arg(1);\n    |                                ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:109:28\n+  --> $DIR/default_numeric_fallback.rs:114:28\n    |\n LL |         GenericStruct { x: 1 };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:112:36\n+  --> $DIR/default_numeric_fallback.rs:117:36\n    |\n LL |         let _ = GenericStruct { x: 1 };\n    |                                    ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:132:23\n+  --> $DIR/default_numeric_fallback.rs:137:23\n    |\n LL |         s.generic_arg(1);\n    |                       ^ help: consider adding suffix: `1_i32`\n \n-error: aborting due to 24 previous errors\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:144:21\n+   |\n+LL |             let x = 22;\n+   |                     ^^ help: consider adding suffix: `22_i32`\n+...\n+LL |         internal_macro!();\n+   |         ------------------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `internal_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 25 previous errors\n "}, {"sha": "0af6b500115dc1ae828261e7f38baa9cf6281ebf", "filename": "tests/ui/deprecated.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -84,13 +84,13 @@ error: lint `clippy::filter_map` has been removed: this lint has been replaced b\n LL | #[warn(clippy::filter_map)]\n    |        ^^^^^^^^^^^^^^^^^^\n \n-error: lint `clippy::pub_enum_variant_names` has been removed: set the `avoid_breaking_exported_api` config option to `false` to enable the `enum_variant_names` lint for public items\n+error: lint `clippy::pub_enum_variant_names` has been removed: set the `avoid-breaking-exported-api` config option to `false` to enable the `enum_variant_names` lint for public items\n   --> $DIR/deprecated.rs:15:8\n    |\n LL | #[warn(clippy::pub_enum_variant_names)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: lint `clippy::wrong_pub_self_convention` has been removed: set the `avoid_breaking_exported_api` config option to `false` to enable the `wrong_self_convention` lint for public items\n+error: lint `clippy::wrong_pub_self_convention` has been removed: set the `avoid-breaking-exported-api` config option to `false` to enable the `wrong_self_convention` lint for public items\n   --> $DIR/deprecated.rs:16:8\n    |\n LL | #[warn(clippy::wrong_pub_self_convention)]"}, {"sha": "cfdda35971fb617829cfd0bb8c2bc46c72efc7e6", "filename": "tests/ui/disallowed_script_idents.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdisallowed_script_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdisallowed_script_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdisallowed_script_idents.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,10 @@\n+#![deny(clippy::disallowed_script_idents)]\n+#![allow(dead_code)]\n+\n+fn main() {\n+    let counter = 10; // OK, latin is allowed.\n+    let z\u00e4hler = 10; // OK, it's still latin.\n+\n+    let \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // Cyrillic is not allowed by default.\n+    let \u30ab\u30a6\u30f3\u30bf = 10; // Same for japanese.\n+}"}, {"sha": "cc84dc1d43c59839d04b2497529344c85daa1f45", "filename": "tests/ui/disallowed_script_idents.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdisallowed_script_idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdisallowed_script_idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdisallowed_script_idents.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,20 @@\n+error: identifier `\u0441\u0447\u0451\u0442\u0447\u0438\u043a` has a Unicode script that is not allowed by configuration: Cyrillic\n+  --> $DIR/disallowed_script_idents.rs:8:9\n+   |\n+LL |     let \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // Cyrillic is not allowed by default.\n+   |         ^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/disallowed_script_idents.rs:1:9\n+   |\n+LL | #![deny(clippy::disallowed_script_idents)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: identifier `\u30ab\u30a6\u30f3\u30bf` has a Unicode script that is not allowed by configuration: Katakana\n+  --> $DIR/disallowed_script_idents.rs:9:9\n+   |\n+LL |     let \u30ab\u30a6\u30f3\u30bf = 10; // Same for japanese.\n+   |         ^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "8afef6b23d47653c27a9f2d2398ed411fd08667a", "filename": "tests/ui/doc/doc.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc%2Fdoc.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -64,7 +64,7 @@ fn test_units() {\n /// WebGL\n /// TensorFlow\n /// TrueType\n-/// iOS macOS\n+/// iOS macOS FreeBSD\n /// TeX LaTeX BibTeX BibLaTeX\n /// MinGW\n /// CamelCase (see also #2395)", "previous_filename": "tests/ui/doc.rs"}, {"sha": "7eab8a85f093d6f1de5a51e517605338f98fee33", "filename": "tests/ui/doc/doc.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdoc%2Fdoc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdoc%2Fdoc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc%2Fdoc.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "previous_filename": "tests/ui/doc.stderr"}, {"sha": "78e87bc69062a351c4e3bccbd5e773b8b277c443", "filename": "tests/ui/doc/unbalanced_ticks.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdoc%2Funbalanced_ticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdoc%2Funbalanced_ticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc%2Funbalanced_ticks.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,36 @@\n+//! This file tests for the `DOC_MARKDOWN` lint, specifically cases\n+//! where ticks are unbalanced (see issue #6753).\n+\n+#![allow(dead_code)]\n+#![warn(clippy::doc_markdown)]\n+\n+/// This is a doc comment with `unbalanced_tick marks and several words that\n+/// should be `encompassed_by` tick marks because they `contain_underscores`.\n+/// Because of the initial `unbalanced_tick` pair, the error message is\n+/// very `confusing_and_misleading`.\n+fn main() {}\n+\n+/// This paragraph has `unbalanced_tick marks and should stop_linting.\n+///\n+/// This paragraph is fine and should_be linted normally.\n+///\n+/// Double unbalanced backtick from ``here to here` should lint.\n+///\n+/// Double balanced back ticks ``start end`` is fine.\n+fn multiple_paragraphs() {}\n+\n+/// ```\n+/// // Unbalanced tick mark in code block shouldn't warn:\n+/// `\n+/// ```\n+fn in_code_block() {}\n+\n+/// # `Fine`\n+///\n+/// ## not_fine\n+///\n+/// ### `unbalanced\n+///\n+/// - This `item has unbalanced tick marks\n+/// - This item needs backticks_here\n+fn other_markdown() {}"}, {"sha": "45ca34e2a8c8b34a2e6ede2509ad9367abac2709", "filename": "tests/ui/doc/unbalanced_ticks.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdoc%2Funbalanced_ticks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fdoc%2Funbalanced_ticks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc%2Funbalanced_ticks.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,64 @@\n+error: backticks are unbalanced\n+  --> $DIR/unbalanced_ticks.rs:7:1\n+   |\n+LL | / /// This is a doc comment with `unbalanced_tick marks and several words that\n+LL | | /// should be `encompassed_by` tick marks because they `contain_underscores`.\n+LL | | /// Because of the initial `unbalanced_tick` pair, the error message is\n+LL | | /// very `confusing_and_misleading`.\n+   | |____________________________________^\n+   |\n+   = note: `-D clippy::doc-markdown` implied by `-D warnings`\n+   = help: a backtick may be missing a pair\n+\n+error: backticks are unbalanced\n+  --> $DIR/unbalanced_ticks.rs:13:1\n+   |\n+LL | /// This paragraph has `unbalanced_tick marks and should stop_linting.\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: a backtick may be missing a pair\n+\n+error: you should put `should_be` between ticks in the documentation\n+  --> $DIR/unbalanced_ticks.rs:15:32\n+   |\n+LL | /// This paragraph is fine and should_be linted normally.\n+   |                                ^^^^^^^^^\n+\n+error: backticks are unbalanced\n+  --> $DIR/unbalanced_ticks.rs:17:1\n+   |\n+LL | /// Double unbalanced backtick from ``here to here` should lint.\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: a backtick may be missing a pair\n+\n+error: you should put `not_fine` between ticks in the documentation\n+  --> $DIR/unbalanced_ticks.rs:30:8\n+   |\n+LL | /// ## not_fine\n+   |        ^^^^^^^^\n+\n+error: backticks are unbalanced\n+  --> $DIR/unbalanced_ticks.rs:32:1\n+   |\n+LL | /// ### `unbalanced\n+   | ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: a backtick may be missing a pair\n+\n+error: backticks are unbalanced\n+  --> $DIR/unbalanced_ticks.rs:34:1\n+   |\n+LL | /// - This `item has unbalanced tick marks\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: a backtick may be missing a pair\n+\n+error: you should put `backticks_here` between ticks in the documentation\n+  --> $DIR/unbalanced_ticks.rs:35:23\n+   |\n+LL | /// - This item needs backticks_here\n+   |                       ^^^^^^^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "787053fb00064c861a75c37410ae26767ab2322e", "filename": "tests/ui/field_reassign_with_default.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffield_reassign_with_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffield_reassign_with_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -29,6 +29,21 @@ struct C {\n     i: Vec<i32>,\n     j: i64,\n }\n+\n+#[derive(Default)]\n+struct D {\n+    a: Option<i32>,\n+    b: Option<i32>,\n+}\n+\n+macro_rules! m {\n+    ($key:ident: $value:tt) => {{\n+        let mut data = $crate::D::default();\n+        data.$key = Some($value);\n+        data\n+    }};\n+}\n+\n /// Implements .next() that returns a different number each time.\n struct SideEffect(i32);\n \n@@ -143,6 +158,11 @@ fn main() {\n \n     let mut a: WrapperMulti<i32, i64> = Default::default();\n     a.i = 42;\n+\n+    // Don't lint in macros\n+    m! {\n+        a: 42\n+    };\n }\n \n mod m {"}, {"sha": "b56db08ec8a787f63c3edc31fde93178a0237982", "filename": "tests/ui/field_reassign_with_default.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffield_reassign_with_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffield_reassign_with_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,108 +1,108 @@\n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:48:5\n+  --> $DIR/field_reassign_with_default.rs:63:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::field-reassign-with-default` implied by `-D warnings`\n note: consider initializing the variable with `main::A { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:47:5\n+  --> $DIR/field_reassign_with_default.rs:62:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:88:5\n+  --> $DIR/field_reassign_with_default.rs:103:5\n    |\n LL |     a.j = 43;\n    |     ^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { j: 43, i: 42 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:87:5\n+  --> $DIR/field_reassign_with_default.rs:102:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:93:5\n+  --> $DIR/field_reassign_with_default.rs:108:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { i: 42, j: 44 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:92:5\n+  --> $DIR/field_reassign_with_default.rs:107:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:99:5\n+  --> $DIR/field_reassign_with_default.rs:114:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:98:5\n+  --> $DIR/field_reassign_with_default.rs:113:5\n    |\n LL |     let mut a = A::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:109:5\n+  --> $DIR/field_reassign_with_default.rs:124:5\n    |\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { i: Default::default(), ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:108:5\n+  --> $DIR/field_reassign_with_default.rs:123:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:113:5\n+  --> $DIR/field_reassign_with_default.rs:128:5\n    |\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { i: Default::default(), j: 45 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:112:5\n+  --> $DIR/field_reassign_with_default.rs:127:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:135:5\n+  --> $DIR/field_reassign_with_default.rs:150:5\n    |\n LL |     a.i = vec![1];\n    |     ^^^^^^^^^^^^^^\n    |\n note: consider initializing the variable with `C { i: vec![1], ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:134:5\n+  --> $DIR/field_reassign_with_default.rs:149:5\n    |\n LL |     let mut a: C = C::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:142:5\n+  --> $DIR/field_reassign_with_default.rs:157:5\n    |\n LL |     a.i = true;\n    |     ^^^^^^^^^^^\n    |\n note: consider initializing the variable with `Wrapper::<bool> { i: true }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:141:5\n+  --> $DIR/field_reassign_with_default.rs:156:5\n    |\n LL |     let mut a: Wrapper<bool> = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:145:5\n+  --> $DIR/field_reassign_with_default.rs:160:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n note: consider initializing the variable with `WrapperMulti::<i32, i64> { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:144:5\n+  --> $DIR/field_reassign_with_default.rs:159:5\n    |\n LL |     let mut a: WrapperMulti<i32, i64> = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "a5860aa49b3bb7f909aeee04e130285188fd0ae8", "filename": "tests/ui/filter_map_identity.fixed", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffilter_map_identity.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffilter_map_identity.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_identity.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, clippy::needless_return)]\n #![warn(clippy::filter_map_identity)]\n \n fn main() {\n@@ -13,4 +13,7 @@ fn main() {\n     use std::convert::identity;\n     let iterator = vec![Some(1), None, Some(2)].into_iter();\n     let _ = iterator.flatten();\n+\n+    let iterator = vec![Some(1), None, Some(2)].into_iter();\n+    let _ = iterator.flatten();\n }"}, {"sha": "7e998b9cdf7010f4cd6e1fa84af582a3450dd6eb", "filename": "tests/ui/filter_map_identity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffilter_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffilter_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_identity.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, clippy::needless_return)]\n #![warn(clippy::filter_map_identity)]\n \n fn main() {\n@@ -13,4 +13,7 @@ fn main() {\n     use std::convert::identity;\n     let iterator = vec![Some(1), None, Some(2)].into_iter();\n     let _ = iterator.filter_map(identity);\n+\n+    let iterator = vec![Some(1), None, Some(2)].into_iter();\n+    let _ = iterator.filter_map(|x| return x);\n }"}, {"sha": "43c9fdca4fbe0251b54e6e6c70f4ab2fe3873eb8", "filename": "tests/ui/filter_map_identity.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffilter_map_identity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ffilter_map_identity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_identity.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,22 +1,28 @@\n-error: called `filter_map(|x| x)` on an `Iterator`\n+error: use of `filter_map` with an identity function\n   --> $DIR/filter_map_identity.rs:8:22\n    |\n LL |     let _ = iterator.filter_map(|x| x);\n    |                      ^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n    |\n    = note: `-D clippy::filter-map-identity` implied by `-D warnings`\n \n-error: called `filter_map(std::convert::identity)` on an `Iterator`\n+error: use of `filter_map` with an identity function\n   --> $DIR/filter_map_identity.rs:11:22\n    |\n LL |     let _ = iterator.filter_map(std::convert::identity);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n \n-error: called `filter_map(std::convert::identity)` on an `Iterator`\n+error: use of `filter_map` with an identity function\n   --> $DIR/filter_map_identity.rs:15:22\n    |\n LL |     let _ = iterator.filter_map(identity);\n    |                      ^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n \n-error: aborting due to 3 previous errors\n+error: use of `filter_map` with an identity function\n+  --> $DIR/filter_map_identity.rs:18:22\n+   |\n+LL |     let _ = iterator.filter_map(|x| return x);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "1f4b880ef5bcd8fa1cea502a8b9bd5efae1d7ba9", "filename": "tests/ui/flat_map_identity.fixed", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fflat_map_identity.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fflat_map_identity.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_identity.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, clippy::needless_return)]\n #![warn(clippy::flat_map_identity)]\n \n use std::convert;\n@@ -11,4 +11,7 @@ fn main() {\n \n     let iterator = [[0, 1], [2, 3], [4, 5]].iter();\n     let _ = iterator.flatten();\n+\n+    let iterator = [[0, 1], [2, 3], [4, 5]].iter();\n+    let _ = iterator.flatten();\n }"}, {"sha": "de14a06d4e6b3377a40d277105d073005e68229a", "filename": "tests/ui/flat_map_identity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_identity.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, clippy::needless_return)]\n #![warn(clippy::flat_map_identity)]\n \n use std::convert;\n@@ -11,4 +11,7 @@ fn main() {\n \n     let iterator = [[0, 1], [2, 3], [4, 5]].iter();\n     let _ = iterator.flat_map(convert::identity);\n+\n+    let iterator = [[0, 1], [2, 3], [4, 5]].iter();\n+    let _ = iterator.flat_map(|x| return x);\n }"}, {"sha": "e776c9fdf512e2bda03316138086e2eabd4e2dcf", "filename": "tests/ui/flat_map_identity.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fflat_map_identity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fflat_map_identity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_identity.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,16 +1,22 @@\n-error: called `flat_map(|x| x)` on an `Iterator`\n+error: use of `flat_map` with an identity function\n   --> $DIR/flat_map_identity.rs:10:22\n    |\n LL |     let _ = iterator.flat_map(|x| x);\n    |                      ^^^^^^^^^^^^^^^ help: try: `flatten()`\n    |\n    = note: `-D clippy::flat-map-identity` implied by `-D warnings`\n \n-error: called `flat_map(std::convert::identity)` on an `Iterator`\n+error: use of `flat_map` with an identity function\n   --> $DIR/flat_map_identity.rs:13:22\n    |\n LL |     let _ = iterator.flat_map(convert::identity);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n \n-error: aborting due to 2 previous errors\n+error: use of `flat_map` with an identity function\n+  --> $DIR/flat_map_identity.rs:16:22\n+   |\n+LL |     let _ = iterator.flat_map(|x| return x);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "e48451acfe8f5f4c67f76c65298e40b9a463e9f5", "filename": "tests/ui/match_same_arms.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmatch_same_arms.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmatch_same_arms.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -32,6 +32,7 @@ help: consider refactoring into `(1, .., 3) | (.., 3)`\n    |\n LL |         (1, .., 3) => 42,\n    |         ^^^^^^^^^^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms.rs:24:15\n@@ -49,6 +50,7 @@ help: consider refactoring into `42 | 51`\n    |\n LL |         42 => 1,\n    |         ^^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms.rs:26:15\n@@ -66,6 +68,7 @@ help: consider refactoring into `41 | 52`\n    |\n LL |         41 => 2,\n    |         ^^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms.rs:32:14\n@@ -83,6 +86,7 @@ help: consider refactoring into `1 | 2`\n    |\n LL |         1 => 2,\n    |         ^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms.rs:33:14\n@@ -100,6 +104,7 @@ help: consider refactoring into `1 | 3`\n    |\n LL |         1 => 2,\n    |         ^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms.rs:33:14\n@@ -117,6 +122,7 @@ help: consider refactoring into `2 | 3`\n    |\n LL |         2 => 2, //~ ERROR 2nd matched arms have same body\n    |         ^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms.rs:50:55\n@@ -134,6 +140,7 @@ help: consider refactoring into `CommandInfo::BuiltIn { name, .. } | CommandInfo\n    |\n LL |                 CommandInfo::BuiltIn { name, .. } => name.to_string(),\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ...or consider changing the match arm bodies\n \n error: aborting due to 8 previous errors\n "}, {"sha": "e1ed12f9370877b8b0d59411ce345529cf64b84e", "filename": "tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -53,6 +53,7 @@ help: consider refactoring into `42 | 51`\n    |\n LL |         42 => foo(),\n    |         ^^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms2.rs:40:17\n@@ -70,6 +71,7 @@ help: consider refactoring into `Some(_) | None`\n    |\n LL |         Some(_) => 24,\n    |         ^^^^^^^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms2.rs:62:28\n@@ -87,6 +89,7 @@ help: consider refactoring into `(Some(a), None) | (None, Some(a))`\n    |\n LL |         (Some(a), None) => bar(a),\n    |         ^^^^^^^^^^^^^^^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms2.rs:68:26\n@@ -104,6 +107,7 @@ help: consider refactoring into `(Some(a), ..) | (.., Some(a))`\n    |\n LL |         (Some(a), ..) => bar(a),\n    |         ^^^^^^^^^^^^^\n+   = help: ...or consider changing the match arm bodies\n \n error: this `match` has identical arm bodies\n   --> $DIR/match_same_arms2.rs:102:29\n@@ -121,6 +125,7 @@ help: consider refactoring into `(Ok(x), Some(_)) | (Ok(_), Some(x))`\n    |\n LL |         (Ok(x), Some(_)) => println!(\"ok {}\", x),\n    |         ^^^^^^^^^^^^^^^^\n+   = help: ...or consider changing the match arm bodies\n    = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: this `match` has identical arm bodies\n@@ -139,6 +144,7 @@ help: consider refactoring into `Ok(3) | Ok(_)`\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n+   = help: ...or consider changing the match arm bodies\n    = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: this `match` has identical arm bodies\n@@ -163,6 +169,7 @@ help: consider refactoring into `0 | 1`\n    |\n LL |         0 => {\n    |         ^\n+   = help: ...or consider changing the match arm bodies\n \n error: match expression looks like `matches!` macro\n   --> $DIR/match_same_arms2.rs:162:16"}, {"sha": "e675c183ea7117c646b99e04438c524f07fec3dc", "filename": "tests/ui/match_wildcard_for_single_variants.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -115,9 +115,16 @@ fn main() {\n         pub enum Enum {\n             A,\n             B,\n+            C,\n             #[doc(hidden)]\n             __Private,\n         }\n+        match Enum::A {\n+            Enum::A => (),\n+            Enum::B => (),\n+            Enum::C => (),\n+            _ => (),\n+        }\n         match Enum::A {\n             Enum::A => (),\n             Enum::B => (),"}, {"sha": "38c3ffc00c71b4bc8cad9251ad1aa4b674899203", "filename": "tests/ui/match_wildcard_for_single_variants.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -115,9 +115,16 @@ fn main() {\n         pub enum Enum {\n             A,\n             B,\n+            C,\n             #[doc(hidden)]\n             __Private,\n         }\n+        match Enum::A {\n+            Enum::A => (),\n+            Enum::B => (),\n+            Enum::C => (),\n+            _ => (),\n+        }\n         match Enum::A {\n             Enum::A => (),\n             Enum::B => (),"}, {"sha": "a8460b06ca6038ef3b976e9b6867ca33049cfcc1", "filename": "tests/ui/mut_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmut_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fmut_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_key.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -4,7 +4,7 @@ error: mutable key type\n LL | fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<Key> {\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `#[deny(clippy::mutable_key_type)]` on by default\n+   = note: `-D clippy::mutable-key-type` implied by `-D warnings`\n \n error: mutable key type\n   --> $DIR/mut_key.rs:27:72"}, {"sha": "79ba7402f1f49285a79b0de83952e5f46c272333", "filename": "tests/ui/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -17,6 +17,24 @@ fn basic101(x: i32) {\n     y = x + 1\n }\n \n+#[rustfmt::skip]\n+fn closure_error() {\n+    let _d = || {\n+        hello()\n+    };\n+}\n+\n+#[rustfmt::skip]\n+fn unsafe_checks_error() {\n+    use std::mem::MaybeUninit;\n+    use std::ptr;\n+\n+    let mut s = MaybeUninit::<String>::uninit();\n+    let _d = || unsafe { \n+        ptr::drop_in_place(s.as_mut_ptr()) \n+    };\n+}\n+\n // this is fine\n fn print_sum(a: i32, b: i32) {\n     println!(\"{}\", a + b);\n@@ -53,3 +71,29 @@ fn loop_test(x: i32) {\n         println!(\"{}\", ext);\n     }\n }\n+\n+fn closure() {\n+    let _d = || hello();\n+}\n+\n+#[rustfmt::skip]\n+fn closure_block() {\n+    let _d = || { hello() };\n+}\n+\n+unsafe fn some_unsafe_op() {}\n+unsafe fn some_other_unsafe_fn() {}\n+\n+fn do_something() {\n+    unsafe { some_unsafe_op() };\n+\n+    unsafe { some_other_unsafe_fn() };\n+}\n+\n+fn unsafe_checks() {\n+    use std::mem::MaybeUninit;\n+    use std::ptr;\n+\n+    let mut s = MaybeUninit::<String>::uninit();\n+    let _d = || unsafe { ptr::drop_in_place(s.as_mut_ptr()) };\n+}"}, {"sha": "e88ebe2ad35f0bcacf64ed5f8ee3bc57e1227ae7", "filename": "tests/ui/semicolon_if_nothing_returned.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -18,5 +18,17 @@ error: consider adding a `;` to the last statement for consistent formatting\n LL |     y = x + 1\n    |     ^^^^^^^^^ help: add a `;` here: `y = x + 1;`\n \n-error: aborting due to 3 previous errors\n+error: consider adding a `;` to the last statement for consistent formatting\n+  --> $DIR/semicolon_if_nothing_returned.rs:23:9\n+   |\n+LL |         hello()\n+   |         ^^^^^^^ help: add a `;` here: `hello();`\n+\n+error: consider adding a `;` to the last statement for consistent formatting\n+  --> $DIR/semicolon_if_nothing_returned.rs:34:9\n+   |\n+LL |         ptr::drop_in_place(s.as_mut_ptr()) \n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add a `;` here: `ptr::drop_in_place(s.as_mut_ptr());`\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "63fc9ecb79a987923cc00f0cb5589e7b5020afa4", "filename": "tests/ui/suspicious_arithmetic_impl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -12,7 +12,7 @@ error: suspicious use of binary operator in `AddAssign` impl\n LL |         *self = *self - other;\n    |                       ^\n    |\n-   = note: `#[deny(clippy::suspicious_op_assign_impl)]` on by default\n+   = note: `-D clippy::suspicious-op-assign-impl` implied by `-D warnings`\n \n error: suspicious use of binary operator in `MulAssign` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:32:16"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "bda0f2c47cdd525a97a62f5e080334dc20e627c8", "filename": "tests/ui/unnecessary_cast_fixable.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Funnecessary_cast_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Funnecessary_cast_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast_fixable.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::unnecessary_cast)]\n-#![allow(clippy::no_effect, clippy::unnecessary_operation)]\n+#![allow(clippy::no_effect, clippy::unnecessary_operation, clippy::nonstandard_macro_braces)]\n \n fn main() {\n     // casting integer literal to float is unnecessary"}, {"sha": "f7a4f2a5988fd42c38fc5dca1c255a7a556e07ba", "filename": "tests/ui/unnecessary_cast_fixable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Funnecessary_cast_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Funnecessary_cast_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast_fixable.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::unnecessary_cast)]\n-#![allow(clippy::no_effect, clippy::unnecessary_operation)]\n+#![allow(clippy::no_effect, clippy::unnecessary_operation, clippy::nonstandard_macro_braces)]\n \n fn main() {\n     // casting integer literal to float is unnecessary"}, {"sha": "e2c28542efc76e38c89aec06fc9bf7d670800dd6", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -492,3 +492,26 @@ mod issue7206 {\n         }\n     }\n }\n+\n+mod self_is_ty_param {\n+    trait Trait {\n+        type Type;\n+        type Hi;\n+\n+        fn test();\n+    }\n+\n+    impl<I> Trait for I\n+    where\n+        I: Iterator,\n+        I::Item: Trait, // changing this to Self would require <Self as Iterator>\n+    {\n+        type Type = I;\n+        type Hi = I::Item;\n+\n+        fn test() {\n+            let _: I::Item;\n+            let _: I; // this could lint, but is questionable\n+        }\n+    }\n+}"}, {"sha": "3cd99b9f5cd88775aaa07a061c5c8092fd852b96", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -279,7 +279,7 @@ mod generics {\n     impl<T> Foo<T> {\n         // `Self` is applicable here\n         fn foo(value: T) -> Foo<T> {\n-            Foo { value }\n+            Foo::<T> { value }\n         }\n \n         // `Cannot` use `Self` as a return type as the generic types are different\n@@ -492,3 +492,26 @@ mod issue7206 {\n         }\n     }\n }\n+\n+mod self_is_ty_param {\n+    trait Trait {\n+        type Type;\n+        type Hi;\n+\n+        fn test();\n+    }\n+\n+    impl<I> Trait for I\n+    where\n+        I: Iterator,\n+        I::Item: Trait, // changing this to Self would require <Self as Iterator>\n+    {\n+        type Type = I;\n+        type Hi = I::Item;\n+\n+        fn test() {\n+            let _: I::Item;\n+            let _: I; // this could lint, but is questionable\n+        }\n+    }\n+}"}, {"sha": "6ac26c9e5a9cece3a876924c17595799c6efca9d", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -153,8 +153,8 @@ LL |         fn foo(value: T) -> Foo<T> {\n error: unnecessary structure name repetition\n   --> $DIR/use_self.rs:282:13\n    |\n-LL |             Foo { value }\n-   |             ^^^ help: use the applicable keyword: `Self`\n+LL |             Foo::<T> { value }\n+   |             ^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n   --> $DIR/use_self.rs:454:13"}, {"sha": "318f9c2dceb641a206a821a81e96473648e9551d", "filename": "tests/ui/vec.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fvec.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fvec.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-\n+#![allow(clippy::nonstandard_macro_braces)]\n #![warn(clippy::useless_vec)]\n \n #[derive(Debug)]"}, {"sha": "d7673ce3e6437dbf7422cc218c5e17084afb857d", "filename": "tests/ui/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-\n+#![allow(clippy::nonstandard_macro_braces)]\n #![warn(clippy::useless_vec)]\n \n #[derive(Debug)]"}, {"sha": "52e80ceee83cf31439c07cfff967fc46a03e09fd", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -320,6 +320,20 @@ fn issue1924() {\n     println!(\"iterator field {}\", it.1);\n }\n \n+fn issue7249() {\n+    let mut it = 0..10;\n+    let mut x = || {\n+        // Needs &mut, the closure can be called multiple times\n+        for x in &mut it {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    };\n+    x();\n+    x();\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     for _ in it {"}, {"sha": "5078a3c9028c4762f9d7ea09e3b1baf5c837c7c5", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -320,6 +320,20 @@ fn issue1924() {\n     println!(\"iterator field {}\", it.1);\n }\n \n+fn issue7249() {\n+    let mut it = 0..10;\n+    let mut x = || {\n+        // Needs &mut, the closure can be called multiple times\n+        while let Some(x) = it.next() {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    };\n+    x();\n+    x();\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     while let Some(..) = it.next() {"}, {"sha": "cb0afeae15ee0ead89f0bbe769e7af04660ccd72", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -105,10 +105,16 @@ LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in &mut it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:325:5\n+  --> $DIR/while_let_on_iterator.rs:327:9\n+   |\n+LL |         while let Some(x) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:339:5\n    |\n LL |     while let Some(..) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 19 previous errors\n "}, {"sha": "3ee4ab48ac84b215c6a21d34e4be0e85f74fa414", "filename": "tests/ui/wildcard_enum_match_arm.fixed", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.fixed?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+// aux-build:non-exhaustive-enum.rs\n \n #![deny(clippy::wildcard_enum_match_arm)]\n #![allow(\n@@ -11,7 +12,9 @@\n     clippy::diverging_sub_expression\n )]\n \n-use std::io::ErrorKind;\n+extern crate non_exhaustive_enum;\n+\n+use non_exhaustive_enum::ErrorKind;\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n enum Color {\n@@ -77,29 +80,25 @@ fn main() {\n     let error_kind = ErrorKind::NotFound;\n     match error_kind {\n         ErrorKind::NotFound => {},\n-        ErrorKind::PermissionDenied | ErrorKind::ConnectionRefused | ErrorKind::ConnectionReset | ErrorKind::ConnectionAborted | ErrorKind::NotConnected | ErrorKind::AddrInUse | ErrorKind::AddrNotAvailable | ErrorKind::BrokenPipe | ErrorKind::AlreadyExists | ErrorKind::WouldBlock | ErrorKind::InvalidInput | ErrorKind::InvalidData | ErrorKind::TimedOut | ErrorKind::WriteZero | ErrorKind::Interrupted | ErrorKind::Other | ErrorKind::UnexpectedEof | ErrorKind::Unsupported | ErrorKind::OutOfMemory | _ => {},\n+        ErrorKind::PermissionDenied | _ => {},\n     }\n     match error_kind {\n         ErrorKind::NotFound => {},\n         ErrorKind::PermissionDenied => {},\n-        ErrorKind::ConnectionRefused => {},\n-        ErrorKind::ConnectionReset => {},\n-        ErrorKind::ConnectionAborted => {},\n-        ErrorKind::NotConnected => {},\n-        ErrorKind::AddrInUse => {},\n-        ErrorKind::AddrNotAvailable => {},\n-        ErrorKind::BrokenPipe => {},\n-        ErrorKind::AlreadyExists => {},\n-        ErrorKind::WouldBlock => {},\n-        ErrorKind::InvalidInput => {},\n-        ErrorKind::InvalidData => {},\n-        ErrorKind::TimedOut => {},\n-        ErrorKind::WriteZero => {},\n-        ErrorKind::Interrupted => {},\n-        ErrorKind::Other => {},\n-        ErrorKind::UnexpectedEof => {},\n-        ErrorKind::Unsupported => {},\n-        ErrorKind::OutOfMemory => {},\n         _ => {},\n     }\n+\n+    {\n+        #![allow(clippy::manual_non_exhaustive)]\n+        pub enum Enum {\n+            A,\n+            B,\n+            #[doc(hidden)]\n+            __Private,\n+        }\n+        match Enum::A {\n+            Enum::A => (),\n+            Enum::B | _ => (),\n+        }\n+    }\n }"}, {"sha": "46886550453308a340353c5a8c9c8b143a0877a9", "filename": "tests/ui/wildcard_enum_match_arm.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwildcard_enum_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwildcard_enum_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+// aux-build:non-exhaustive-enum.rs\n \n #![deny(clippy::wildcard_enum_match_arm)]\n #![allow(\n@@ -11,7 +12,9 @@\n     clippy::diverging_sub_expression\n )]\n \n-use std::io::ErrorKind;\n+extern crate non_exhaustive_enum;\n+\n+use non_exhaustive_enum::ErrorKind;\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n enum Color {\n@@ -82,24 +85,20 @@ fn main() {\n     match error_kind {\n         ErrorKind::NotFound => {},\n         ErrorKind::PermissionDenied => {},\n-        ErrorKind::ConnectionRefused => {},\n-        ErrorKind::ConnectionReset => {},\n-        ErrorKind::ConnectionAborted => {},\n-        ErrorKind::NotConnected => {},\n-        ErrorKind::AddrInUse => {},\n-        ErrorKind::AddrNotAvailable => {},\n-        ErrorKind::BrokenPipe => {},\n-        ErrorKind::AlreadyExists => {},\n-        ErrorKind::WouldBlock => {},\n-        ErrorKind::InvalidInput => {},\n-        ErrorKind::InvalidData => {},\n-        ErrorKind::TimedOut => {},\n-        ErrorKind::WriteZero => {},\n-        ErrorKind::Interrupted => {},\n-        ErrorKind::Other => {},\n-        ErrorKind::UnexpectedEof => {},\n-        ErrorKind::Unsupported => {},\n-        ErrorKind::OutOfMemory => {},\n         _ => {},\n     }\n+\n+    {\n+        #![allow(clippy::manual_non_exhaustive)]\n+        pub enum Enum {\n+            A,\n+            B,\n+            #[doc(hidden)]\n+            __Private,\n+        }\n+        match Enum::A {\n+            Enum::A => (),\n+            _ => (),\n+        }\n+    }\n }"}, {"sha": "d63f2090353151a55ec431d50b814d8e2c6c7bc2", "filename": "tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,38 +1,44 @@\n error: wildcard match will also match any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:39:9\n+  --> $DIR/wildcard_enum_match_arm.rs:42:9\n    |\n LL |         _ => eprintln!(\"Not red\"),\n    |         ^ help: try this: `Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n    |\n note: the lint level is defined here\n-  --> $DIR/wildcard_enum_match_arm.rs:3:9\n+  --> $DIR/wildcard_enum_match_arm.rs:4:9\n    |\n LL | #![deny(clippy::wildcard_enum_match_arm)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wildcard match will also match any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:43:9\n+  --> $DIR/wildcard_enum_match_arm.rs:46:9\n    |\n LL |         _not_red => eprintln!(\"Not red\"),\n    |         ^^^^^^^^ help: try this: `_not_red @ Color::Green | _not_red @ Color::Blue | _not_red @ Color::Rgb(..) | _not_red @ Color::Cyan`\n \n error: wildcard match will also match any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:47:9\n+  --> $DIR/wildcard_enum_match_arm.rs:50:9\n    |\n LL |         not_red => format!(\"{:?}\", not_red),\n    |         ^^^^^^^ help: try this: `not_red @ Color::Green | not_red @ Color::Blue | not_red @ Color::Rgb(..) | not_red @ Color::Cyan`\n \n error: wildcard match will also match any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:63:9\n+  --> $DIR/wildcard_enum_match_arm.rs:66:9\n    |\n LL |         _ => \"No red\",\n    |         ^ help: try this: `Color::Red | Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n \n error: wildcard matches known variants and will also match future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:80:9\n+  --> $DIR/wildcard_enum_match_arm.rs:83:9\n    |\n LL |         _ => {},\n-   |         ^ help: try this: `ErrorKind::PermissionDenied | ErrorKind::ConnectionRefused | ErrorKind::ConnectionReset | ErrorKind::ConnectionAborted | ErrorKind::NotConnected | ErrorKind::AddrInUse | ErrorKind::AddrNotAvailable | ErrorKind::BrokenPipe | ErrorKind::AlreadyExists | ErrorKind::WouldBlock | ErrorKind::InvalidInput | ErrorKind::InvalidData | ErrorKind::TimedOut | ErrorKind::WriteZero | ErrorKind::Interrupted | ErrorKind::Other | ErrorKind::UnexpectedEof | ErrorKind::Unsupported | ErrorKind::OutOfMemory | _`\n+   |         ^ help: try this: `ErrorKind::PermissionDenied | _`\n \n-error: aborting due to 5 previous errors\n+error: wildcard matches known variants and will also match future added variants\n+  --> $DIR/wildcard_enum_match_arm.rs:101:13\n+   |\n+LL |             _ => (),\n+   |             ^ help: try this: `Enum::B | _`\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "6c190a4c86c48a3175f5b94a0c22312757de088d", "filename": "tests/ui/zero_offset.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fzero_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fzero_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fzero_offset.rs?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,12 +1,18 @@\n fn main() {\n     unsafe {\n-        let x = &() as *const ();\n-        x.offset(0);\n-        x.wrapping_add(0);\n-        x.sub(0);\n-        x.wrapping_sub(0);\n+        let m = &mut () as *mut ();\n+        m.offset(0);\n+        m.wrapping_add(0);\n+        m.sub(0);\n+        m.wrapping_sub(0);\n \n-        let y = &1 as *const u8;\n-        y.offset(0);\n+        let c = &() as *const ();\n+        c.offset(0);\n+        c.wrapping_add(0);\n+        c.sub(0);\n+        c.wrapping_sub(0);\n+\n+        let sized = &1 as *const i32;\n+        sized.offset(0);\n     }\n }"}, {"sha": "b12c8e9a73c6dab3692dc2bc97cbce8ea81b3bc2", "filename": "tests/ui/zero_offset.stderr", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fzero_offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/tests%2Fui%2Fzero_offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fzero_offset.stderr?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -1,9 +1,52 @@\n-error[E0606]: casting `&i32` as `*const u8` is invalid\n-  --> $DIR/zero_offset.rs:9:17\n+error: offset calculation on zero-sized value\n+  --> $DIR/zero_offset.rs:4:9\n    |\n-LL |         let y = &1 as *const u8;\n-   |                 ^^^^^^^^^^^^^^^\n+LL |         m.offset(0);\n+   |         ^^^^^^^^^^^\n+   |\n+   = note: `#[deny(clippy::zst_offset)]` on by default\n+\n+error: offset calculation on zero-sized value\n+  --> $DIR/zero_offset.rs:5:9\n+   |\n+LL |         m.wrapping_add(0);\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: offset calculation on zero-sized value\n+  --> $DIR/zero_offset.rs:6:9\n+   |\n+LL |         m.sub(0);\n+   |         ^^^^^^^^\n+\n+error: offset calculation on zero-sized value\n+  --> $DIR/zero_offset.rs:7:9\n+   |\n+LL |         m.wrapping_sub(0);\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: offset calculation on zero-sized value\n+  --> $DIR/zero_offset.rs:10:9\n+   |\n+LL |         c.offset(0);\n+   |         ^^^^^^^^^^^\n+\n+error: offset calculation on zero-sized value\n+  --> $DIR/zero_offset.rs:11:9\n+   |\n+LL |         c.wrapping_add(0);\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: offset calculation on zero-sized value\n+  --> $DIR/zero_offset.rs:12:9\n+   |\n+LL |         c.sub(0);\n+   |         ^^^^^^^^\n+\n+error: offset calculation on zero-sized value\n+  --> $DIR/zero_offset.rs:13:9\n+   |\n+LL |         c.wrapping_sub(0);\n+   |         ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 8 previous errors\n \n-For more information about this error, try `rustc --explain E0606`."}, {"sha": "528f8953b25d8b81b40633a399def3fd9762726e", "filename": "util/etc/pre-commit.sh", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/util%2Fetc%2Fpre-commit.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/util%2Fetc%2Fpre-commit.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fetc%2Fpre-commit.sh?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,21 @@\n+#!/bin/sh\n+\n+# hide output\n+set -e\n+\n+# Update lints\n+cargo dev update_lints\n+git add clippy_lints/src/lib.rs\n+\n+# Formatting:\n+#     Git will not automatically add the formatted code to the staged changes once\n+#     fmt was executed. This collects all staged files rs files that are currently staged.\n+#     They will later be added back.\n+#\n+#     This was proudly stolen and adjusted from here:\n+#     https://medium.com/@harshitbangar/automatic-code-formatting-with-git-66c3c5c26798\n+files=$( (git diff --cached --name-only --diff-filter=ACMR | grep -Ei \"\\.rs$\") || true)\n+if [ ! -z \"${files}\" ]; then\n+    cargo dev fmt\n+    git add $(echo \"$files\" | paste -s -d \" \" -)\n+fi"}, {"sha": "a4bb26b9f900587151545521e862ec67db9701b2", "filename": "util/etc/vscode-tasks.json", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/util%2Fetc%2Fvscode-tasks.json", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/util%2Fetc%2Fvscode-tasks.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fetc%2Fvscode-tasks.json?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -0,0 +1,57 @@\n+{\n+    \"version\": \"2.0.0\",\n+    \"tasks\": [\n+        {\n+            \"label\": \"cargo check\",\n+            \"type\": \"shell\",\n+            \"command\": \"cargo check\",\n+            \"problemMatcher\": [],\n+            \"group\": {\n+                \"kind\": \"build\",\n+                \"isDefault\": true,\n+            },\n+        },\n+        {\n+            \"label\": \"cargo dev fmt\",\n+            \"type\": \"shell\",\n+            \"command\": \"cargo dev fmt\",\n+            \"problemMatcher\": [],\n+            \"group\": \"none\",\n+        },\n+        {\n+            \"label\": \"cargo uitest\",\n+            \"type\": \"shell\",\n+            \"command\": \"cargo uitest\",\n+            \"options\": {\n+                \"env\": {\n+                    \"RUST_BACKTRACE\": \"1\",\n+                    // This task will usually execute all UI tests inside `tests/ui` you can\n+                    // optionally uncomment the line below and only run a specific test.\n+                    //\n+                    // See: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md#testing\n+                    //\n+                    // \"TESTNAME\": \"<TODO>\",\n+                },\n+            },\n+            \"problemMatcher\": [],\n+            \"group\": {\n+                \"kind\": \"test\",\n+                \"isDefault\": true,\n+            }\n+        },\n+        {\n+            \"label\": \"cargo test\",\n+            \"type\": \"shell\",\n+            \"command\": \"cargo test\",\n+            \"problemMatcher\": [],\n+            \"group\": \"test\",\n+        },\n+        {\n+            \"label\": \"cargo dev bless\",\n+            \"type\": \"shell\",\n+            \"command\": \"cargo dev bless\",\n+            \"problemMatcher\": [],\n+            \"group\": \"none\",\n+        },\n+    ],\n+}"}, {"sha": "9cefb2dbb197caffafcc0ae1cd7c6f40f1fa450c", "filename": "util/lintlib.py", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/util%2Flintlib.py", "raw_url": "https://github.com/rust-lang/rust/raw/a82a744155d8f2f1d4874d6257a3bbf6f5e01e08/util%2Flintlib.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Flintlib.py?ref=a82a744155d8f2f1d4874d6257a3bbf6f5e01e08", "patch": "@@ -12,13 +12,14 @@\n \n lintname_re = re.compile(r'''pub\\s+([A-Z_][A-Z_0-9]*)''')\n group_re = re.compile(r'''\\s*([a-z_][a-z_0-9]+)''')\n-conf_re = re.compile(r'''define_Conf! {\\n([^}]*)\\n}''', re.MULTILINE)\n+conf_re = re.compile(r'''define_Conf! {\\n((?!\\n})[\\s\\S])*\\n}''', re.MULTILINE)\n confvar_re = re.compile(\n     r'''/// Lint: ([\\w,\\s]+)\\. (.*)\\n\\s*\\(([^:]+):\\s*([^\\s=]+)\\s*=\\s*([^\\.\\)]+).*\\),''', re.MULTILINE)\n comment_re = re.compile(r'''\\s*/// ?(.*)''')\n \n lint_levels = {\n     \"correctness\": 'Deny',\n+    \"suspicious\": 'Warn',\n     \"style\": 'Warn',\n     \"complexity\": 'Warn',\n     \"perf\": 'Warn',\n@@ -91,7 +92,7 @@ def parse_configs(path):\n         contents = fp.read()\n \n     match = re.search(conf_re, contents)\n-    confvars = re.findall(confvar_re, match.group(1))\n+    confvars = re.findall(confvar_re, match.group(0))\n \n     for (lints, doc, name, ty, default) in confvars:\n         for lint in lints.split(','):"}]}