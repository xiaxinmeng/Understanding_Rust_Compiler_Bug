{"sha": "56e15de9f9c15d967d5a538b8dc37710354ae893", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZTE1ZGU5ZjljMTVkOTY3ZDVhNTM4YjhkYzM3NzEwMzU0YWU4OTM=", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2018-02-11T23:13:12Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2018-02-12T02:53:30Z"}, "message": "Make primitive types docs relevant (unsigned)", "tree": {"sha": "6560f92a9a21155cdc6cc5d751e08a56f215527c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6560f92a9a21155cdc6cc5d751e08a56f215527c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56e15de9f9c15d967d5a538b8dc37710354ae893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56e15de9f9c15d967d5a538b8dc37710354ae893", "html_url": "https://github.com/rust-lang/rust/commit/56e15de9f9c15d967d5a538b8dc37710354ae893", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56e15de9f9c15d967d5a538b8dc37710354ae893/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9931583468c197fe8b3c9e15abb793457134757f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9931583468c197fe8b3c9e15abb793457134757f", "html_url": "https://github.com/rust-lang/rust/commit/9931583468c197fe8b3c9e15abb793457134757f"}], "stats": {"total": 1562, "additions": 821, "deletions": 741}, "files": [{"sha": "da46eeb44bfa3af4ac49948fbc25213b11023832", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 821, "deletions": 741, "changes": 1562, "blob_url": "https://github.com/rust-lang/rust/blob/56e15de9f9c15d967d5a538b8dc37710354ae893/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e15de9f9c15d967d5a538b8dc37710354ae893/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=56e15de9f9c15d967d5a538b8dc37710354ae893", "patch": "@@ -1330,92 +1330,102 @@ impl isize {\n \n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n-    ($SelfT:ty, $ActualT:ty, $BITS:expr) => {\n-        /// Returns the smallest value that can be represented by this integer type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(u8::min_value(), 0);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub const fn min_value() -> Self { 0 }\n+    ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr) => {\n+        doc_comment! {\n+            concat!(\"Returns the smallest value that can be represented by this integer type.\n \n-        /// Returns the largest value that can be represented by this integer type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(u8::max_value(), 255);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub const fn max_value() -> Self { !0 }\n+# Examples\n \n-        /// Converts a string slice in a given base to an integer.\n-        ///\n-        /// The string is expected to be an optional `+` sign\n-        /// followed by digits.\n-        /// Leading and trailing whitespace represent an error.\n-        /// Digits are a subset of these characters, depending on `radix`:\n-        ///\n-        /// * `0-9`\n-        /// * `a-z`\n-        /// * `A-Z`\n-        ///\n-        /// # Panics\n-        ///\n-        /// This function panics if `radix` is not in the range from 2 to 36.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(u32::from_str_radix(\"A\", 16), Ok(10));\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n-            from_str_radix(src, radix)\n+Basic usage:\n+\n+```\n+assert_eq!(\", stringify!($SelfT), \"::min_value(), 0);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub const fn min_value() -> Self { 0 }\n         }\n \n-        /// Returns the number of ones in the binary representation of `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0b01001100u8;\n-        ///\n-        /// assert_eq!(n.count_ones(), 3);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn count_ones(self) -> u32 {\n-            unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n+        doc_comment! {\n+            concat!(\"Returns the largest value that can be represented by this integer type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(\", stringify!($SelfT), \"::max_value(), \", stringify!($MaxV), \");\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub const fn max_value() -> Self { !0 }\n         }\n \n-        /// Returns the number of zeros in the binary representation of `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0b01001100u8;\n-        ///\n-        /// assert_eq!(n.count_zeros(), 5);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn count_zeros(self) -> u32 {\n-            (!self).count_ones()\n+        doc_comment! {\n+            concat!(\"Converts a string slice in a given base to an integer.\n+\n+The string is expected to be an optional `+` sign\n+followed by digits.\n+Leading and trailing whitespace represent an error.\n+Digits are a subset of these characters, depending on `radix`:\n+\n+* `0-9`\n+* `a-z`\n+* `A-Z`\n+\n+# Panics\n+\n+This function panics if `radix` is not in the range from 2 to 36.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n+                from_str_radix(src, radix)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0b01001100\", stringify!($SelfT), \";\n+\n+assert_eq!(n.count_ones(), 3);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn count_ones(self) -> u32 {\n+                unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0b01001100\", stringify!($SelfT), \";\n+\n+assert_eq!(n.count_zeros(), 5);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n         }\n \n         /// Returns the number of leading zeros in the binary representation\n@@ -1436,33 +1446,35 @@ macro_rules! uint_impl {\n             unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n         }\n \n-        /// Returns the number of trailing zeros in the binary representation\n-        /// of `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0b0101000u16;\n-        ///\n-        /// assert_eq!(n.trailing_zeros(), 3);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn trailing_zeros(self) -> u32 {\n-            // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n-            // emits two conditional moves on x86_64. By promoting the value to\n-            // u16 and setting bit 8, we get better code without any conditional\n-            // operations.\n-            // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n-            // pending, remove this workaround once LLVM generates better code\n-            // for cttz8.\n-            unsafe {\n-                if $BITS == 8 {\n-                    intrinsics::cttz(self as u16 | 0x100) as u32\n-                } else {\n-                    intrinsics::cttz(self) as u32\n+        doc_comment! {\n+            concat!(\"Returns the number of trailing zeros in the binary representation\n+of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0b0101000\", stringify!($SelfT), \";\n+\n+assert_eq!(n.trailing_zeros(), 3);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn trailing_zeros(self) -> u32 {\n+                // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n+                // emits two conditional moves on x86_64. By promoting the value to\n+                // u16 and setting bit 8, we get better code without any conditional\n+                // operations.\n+                // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n+                // pending, remove this workaround once LLVM generates better code\n+                // for cttz8.\n+                unsafe {\n+                    if $BITS == 8 {\n+                        intrinsics::cttz(self as u16 | 0x100) as u32\n+                    } else {\n+                        intrinsics::cttz(self) as u32\n+                    }\n                 }\n             }\n         }\n@@ -1535,347 +1547,382 @@ macro_rules! uint_impl {\n             unsafe { intrinsics::bswap(self as $ActualT) as Self }\n         }\n \n-        /// Converts an integer from big endian to the target's endianness.\n-        ///\n-        /// On big endian this is a no-op. On little endian the bytes are\n-        /// swapped.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        ///\n-        /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(u64::from_be(n), n)\n-        /// } else {\n-        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n-        /// }\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn from_be(x: Self) -> Self {\n-            if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n-        }\n+        doc_comment! {\n+            concat!(\"Converts an integer from big endian to the target's endianness.\n \n-        /// Converts an integer from little endian to the target's endianness.\n-        ///\n-        /// On little endian this is a no-op. On big endian the bytes are\n-        /// swapped.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        ///\n-        /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(u64::from_le(n), n)\n-        /// } else {\n-        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n-        /// }\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn from_le(x: Self) -> Self {\n-            if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n-        }\n+On big endian this is a no-op. On little endian the bytes are\n+swapped.\n \n-        /// Converts `self` to big endian from the target's endianness.\n-        ///\n-        /// On big endian this is a no-op. On little endian the bytes are\n-        /// swapped.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        ///\n-        /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(n.to_be(), n)\n-        /// } else {\n-        ///     assert_eq!(n.to_be(), n.swap_bytes())\n-        /// }\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn to_be(self) -> Self { // or not to be?\n-            if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n-        }\n+# Examples\n \n-        /// Converts `self` to little endian from the target's endianness.\n-        ///\n-        /// On little endian this is a no-op. On big endian the bytes are\n-        /// swapped.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFu64;\n-        ///\n-        /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(n.to_le(), n)\n-        /// } else {\n-        ///     assert_eq!(n.to_le(), n.swap_bytes())\n-        /// }\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn to_le(self) -> Self {\n-            if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n-        }\n+Basic usage:\n \n-        /// Checked integer addition. Computes `self + rhs`, returning `None`\n-        /// if overflow occurred.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(5u16.checked_add(65530), Some(65535));\n-        /// assert_eq!(6u16.checked_add(65530), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_add(rhs);\n-            if b {None} else {Some(a)}\n-        }\n+```\n+let n = 0xA1\", stringify!($SelfT), \";\n \n-        /// Checked integer subtraction. Computes `self - rhs`, returning\n-        /// `None` if overflow occurred.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(1u8.checked_sub(1), Some(0));\n-        /// assert_eq!(0u8.checked_sub(1), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_sub(rhs);\n-            if b {None} else {Some(a)}\n+if cfg!(target_endian = \\\"big\\\") {\n+    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\n+} else {\n+    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\n+}\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn from_be(x: Self) -> Self {\n+                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+            }\n         }\n \n-        /// Checked integer multiplication. Computes `self * rhs`, returning\n-        /// `None` if overflow occurred.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(5u8.checked_mul(51), Some(255));\n-        /// assert_eq!(5u8.checked_mul(52), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_mul(rhs);\n-            if b {None} else {Some(a)}\n-        }\n+        doc_comment! {\n+            concat!(\"Converts an integer from little endian to the target's endianness.\n \n-        /// Checked integer division. Computes `self / rhs`, returning `None`\n-        /// if `rhs == 0`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(128u8.checked_div(2), Some(64));\n-        /// assert_eq!(1u8.checked_div(0), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n-            match rhs {\n-                0 => None,\n-                rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n+On little endian this is a no-op. On big endian the bytes are\n+swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0xA1\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"little\\\") {\n+    assert_eq!(u64::from_le(n), n)\n+} else {\n+    assert_eq!(u64::from_le(n), n.swap_bytes())\n+}\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn from_le(x: Self) -> Self {\n+                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n             }\n         }\n \n-        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n-        /// if `rhs == 0`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(5u32.checked_rem(2), Some(1));\n-        /// assert_eq!(5u32.checked_rem(0), None);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n-            if rhs == 0 {\n-                None\n-            } else {\n-                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n+        doc_comment! {\n+            concat!(\"Converts `self` to big endian from the target's endianness.\n+\n+On big endian this is a no-op. On little endian the bytes are\n+swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0xA1\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"big\\\") {\n+    assert_eq!(n.to_be(), n)\n+} else {\n+    assert_eq!(n.to_be(), n.swap_bytes())\n+}\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn to_be(self) -> Self { // or not to be?\n+                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n             }\n         }\n \n-        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n-        /// 0`.\n-        ///\n-        /// Note that negating any positive integer will overflow.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(0u32.checked_neg(), Some(0));\n-        /// assert_eq!(1u32.checked_neg(), None);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn checked_neg(self) -> Option<Self> {\n-            let (a, b) = self.overflowing_neg();\n-            if b {None} else {Some(a)}\n+        doc_comment! {\n+            concat!(\"Converts `self` to little endian from the target's endianness.\n+\n+On little endian this is a no-op. On big endian the bytes are\n+swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0xA1\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"little\\\") {\n+    assert_eq!(n.to_le(), n)\n+} else {\n+    assert_eq!(n.to_le(), n.swap_bytes())\n+}\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn to_le(self) -> Self {\n+                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+            }\n         }\n \n-        /// Checked shift left. Computes `self << rhs`, returning `None`\n-        /// if `rhs` is larger than or equal to the number of bits in `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(0x10u32.checked_shl(4), Some(0x100));\n-        /// assert_eq!(0x10u32.checked_shl(33), None);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n-            let (a, b) = self.overflowing_shl(rhs);\n-            if b {None} else {Some(a)}\n+        doc_comment! {\n+            concat!(\"Checked integer addition. Computes `self + rhs`, returning `None`\n+if overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(1), \",\n+\"Some(\", stringify!($SelfT), \"::max_value() - 1));\n+assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3),None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_add(rhs);\n+                if b {None} else {Some(a)}\n+            }\n         }\n \n-        /// Checked shift right. Computes `self >> rhs`, returning `None`\n-        /// if `rhs` is larger than or equal to the number of bits in `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(0x10u32.checked_shr(4), Some(0x1));\n-        /// assert_eq!(0x10u32.checked_shr(33), None);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n-            let (a, b) = self.overflowing_shr(rhs);\n-            if b {None} else {Some(a)}\n+        doc_comment! {\n+            concat!(\"Checked integer subtraction. Computes `self - rhs`, returning\n+`None` if overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\n+assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_sub(rhs);\n+                if b {None} else {Some(a)}\n+            }\n         }\n \n-        /// Saturating integer addition. Computes `self + rhs`, saturating at\n-        /// the numeric bounds instead of overflowing.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100u8.saturating_add(1), 101);\n-        /// assert_eq!(200u8.saturating_add(127), 255);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn saturating_add(self, rhs: Self) -> Self {\n-            match self.checked_add(rhs) {\n-                Some(x) => x,\n-                None => Self::max_value(),\n+        doc_comment! {\n+            concat!(\"Checked integer multiplication. Computes `self * rhs`, returning\n+`None` if overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\n+assert_eq!(5\", stringify!($SelfT), \".checked_mul(2), None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_mul(rhs);\n+                if b {None} else {Some(a)}\n             }\n         }\n \n-        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n-        /// at the numeric bounds instead of overflowing.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100u8.saturating_sub(27), 73);\n-        /// assert_eq!(13u8.saturating_sub(127), 0);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn saturating_sub(self, rhs: Self) -> Self {\n-            match self.checked_sub(rhs) {\n-                Some(x) => x,\n-                None => Self::min_value(),\n+        doc_comment! {\n+            concat!(\"Checked integer division. Computes `self / rhs`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\n+assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+                match rhs {\n+                    0 => None,\n+                    rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n+                }\n             }\n         }\n \n-        /// Saturating integer multiplication. Computes `self * rhs`,\n-        /// saturating at the numeric bounds instead of overflowing.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// use std::u32;\n-        ///\n-        /// assert_eq!(100u32.saturating_mul(127), 12700);\n-        /// assert_eq!((1u32 << 23).saturating_mul(1 << 23), u32::MAX);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn saturating_mul(self, rhs: Self) -> Self {\n-            self.checked_mul(rhs).unwrap_or(Self::max_value())\n+        doc_comment! {\n+            concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 {\n+                    None\n+                } else {\n+                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n+                }\n+            }\n         }\n \n-        /// Wrapping (modular) addition. Computes `self + rhs`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(200u8.wrapping_add(55), 255);\n-        /// assert_eq!(200u8.wrapping_add(155), 99);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn wrapping_add(self, rhs: Self) -> Self {\n-            unsafe {\n-                intrinsics::overflowing_add(self, rhs)\n+        doc_comment! {\n+            concat!(\"Checked negation. Computes `-self`, returning `None` unless `self ==\n+0`.\n+\n+Note that negating any positive integer will overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\n+assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn checked_neg(self) -> Option<Self> {\n+                let (a, b) = self.overflowing_neg();\n+                if b {None} else {Some(a)}\n             }\n         }\n \n-        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100u8.wrapping_sub(100), 0);\n-        /// assert_eq!(100u8.wrapping_sub(155), 201);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn wrapping_sub(self, rhs: Self) -> Self {\n-            unsafe {\n-                intrinsics::overflowing_sub(self, rhs)\n+        doc_comment! {\n+            concat!(\"Checked shift left. Computes `self << rhs`, returning `None`\n+if `rhs` is larger than or equal to the number of bits in `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(4), Some(0x100));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n+                let (a, b) = self.overflowing_shl(rhs);\n+                if b {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked shift right. Computes `self >> rhs`, returning `None`\n+if `rhs` is larger than or equal to the number of bits in `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n+                let (a, b) = self.overflowing_shr(rhs);\n+                if b {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at\n+the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(200\", stringify!($SelfT), \".saturating_add(127), 255);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn saturating_add(self, rhs: Self) -> Self {\n+                match self.checked_add(rhs) {\n+                    Some(x) => x,\n+                    None => Self::max_value(),\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating\n+at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\n+assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn saturating_sub(self, rhs: Self) -> Self {\n+                match self.checked_sub(rhs) {\n+                    Some(x) => x,\n+                    None => Self::min_value(),\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer multiplication. Computes `self * rhs`,\n+saturating at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(100\", stringify!($SelfT), \".saturating_mul(127), 12700);\n+assert_eq!((1\", stringify!($SelfT), \" << 23).saturating_mul(1 << 23), \", stringify!($SelfT), \"::MAX);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn saturating_mul(self, rhs: Self) -> Self {\n+                self.checked_mul(rhs).unwrap_or(Self::max_value())\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) addition. Computes `self + rhs`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\n+assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::max_value()), 199);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn wrapping_add(self, rhs: Self) -> Self {\n+                unsafe {\n+                    intrinsics::overflowing_add(self, rhs)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) subtraction. Computes `self - rhs`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100u8.wrapping_sub(100), 0);\n+assert_eq!(100u8.wrapping_sub(\", stringify!($SelfT), \"::max_value()), 101);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn wrapping_sub(self, rhs: Self) -> Self {\n+                unsafe {\n+                    intrinsics::overflowing_sub(self, rhs)\n+                }\n             }\n         }\n \n@@ -1898,175 +1945,190 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / rhs`.\n-        /// Wrapped division on unsigned types is just normal division.\n-        /// There's no way wrapping could ever happen.\n-        /// This function exists, so that all operations\n-        /// are accounted for in the wrapping operations.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100u8.wrapping_div(10), 10);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_div(self, rhs: Self) -> Self {\n-            self / rhs\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) division. Computes `self / rhs`.\n+Wrapped division on unsigned types is just normal division.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_div(self, rhs: Self) -> Self {\n+                self / rhs\n+            }\n         }\n \n-        /// Wrapping (modular) remainder. Computes `self % rhs`.\n-        /// Wrapped remainder calculation on unsigned types is\n-        /// just the regular remainder calculation.\n-        /// There's no way wrapping could ever happen.\n-        /// This function exists, so that all operations\n-        /// are accounted for in the wrapping operations.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100u8.wrapping_rem(10), 0);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_rem(self, rhs: Self) -> Self {\n-            self % rhs\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) remainder. Computes `self % rhs`.\n+Wrapped remainder calculation on unsigned types is\n+just the regular remainder calculation.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_rem(self, rhs: Self) -> Self {\n+                self % rhs\n+            }\n         }\n \n-        /// Wrapping (modular) negation. Computes `-self`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// Since unsigned types do not have negative equivalents\n-        /// all applications of this function will wrap (except for `-0`).\n-        /// For values smaller than the corresponding signed type's maximum\n-        /// the result is the same as casting the corresponding signed value.\n-        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n-        /// `MAX` is the corresponding signed type's maximum.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100u8.wrapping_neg(), 156);\n-        /// assert_eq!(0u8.wrapping_neg(), 0);\n-        /// assert_eq!(180u8.wrapping_neg(), 76);\n-        /// assert_eq!(180u8.wrapping_neg(), (127 + 1) - (180u8 - (127 + 1)));\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_neg(self) -> Self {\n-            self.overflowing_neg().0\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) negation. Computes `-self`,\n+wrapping around at the boundary of the type.\n+\n+Since unsigned types do not have negative equivalents\n+all applications of this function will wrap (except for `-0`).\n+For values smaller than the corresponding signed type's maximum\n+the result is the same as casting the corresponding signed value.\n+Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n+`MAX` is the corresponding signed type's maximum.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), \", stringify!($SelfT), \"::max_value() - 100 + 1);\n+assert_eq!(0\", stringify!($SelfT), \".wrapping_neg(), 0);\n+assert_eq!(180\", stringify!($SelfT), \".wrapping_neg(), \", stringify!($SelfT), \"::max_value() - 180 + 1);\n+assert_eq!(180\", stringify!($SelfT), \".wrapping_neg(), (\", stringify!($SelfT), \"::max_value() / 2\",\n+\"+ 1) - (180\", stringify!($SelfT), \" - (\", stringify!($SelfT), \"::max_value() / 2 + 1)));\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_neg(self) -> Self {\n+                self.overflowing_neg().0\n+            }\n         }\n \n-        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n-        /// where `mask` removes any high-order bits of `rhs` that\n-        /// would cause the shift to exceed the bitwidth of the type.\n-        ///\n-        /// Note that this is *not* the same as a rotate-left; the\n-        /// RHS of a wrapping shift-left is restricted to the range\n-        /// of the type, rather than the bits shifted out of the LHS\n-        /// being returned to the other end. The primitive integer\n-        /// types all implement a `rotate_left` function, which may\n-        /// be what you want instead.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(1u8.wrapping_shl(7), 128);\n-        /// assert_eq!(1u8.wrapping_shl(8), 1);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_shl(self, rhs: u32) -> Self {\n-            unsafe {\n-                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+        doc_comment! {\n+            concat!(\"Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n+where `mask` removes any high-order bits of `rhs` that\n+would cause the shift to exceed the bitwidth of the type.\n+\n+Note that this is *not* the same as a rotate-left; the\n+RHS of a wrapping shift-left is restricted to the range\n+of the type, rather than the bits shifted out of the LHS\n+being returned to the other end. The primitive integer\n+types all implement a `rotate_left` function, which may\n+be what you want instead.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\n+assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(\", stringify!($BITS), \"), 1);\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_shl(self, rhs: u32) -> Self {\n+                unsafe {\n+                    intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+                }\n             }\n         }\n \n-        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n-        /// where `mask` removes any high-order bits of `rhs` that\n-        /// would cause the shift to exceed the bitwidth of the type.\n-        ///\n-        /// Note that this is *not* the same as a rotate-right; the\n-        /// RHS of a wrapping shift-right is restricted to the range\n-        /// of the type, rather than the bits shifted out of the LHS\n-        /// being returned to the other end. The primitive integer\n-        /// types all implement a `rotate_right` function, which may\n-        /// be what you want instead.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(128u8.wrapping_shr(7), 1);\n-        /// assert_eq!(128u8.wrapping_shr(8), 128);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_shr(self, rhs: u32) -> Self {\n-            unsafe {\n-                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+        doc_comment! {\n+            concat!(\"Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n+where `mask` removes any high-order bits of `rhs` that\n+would cause the shift to exceed the bitwidth of the type.\n+\n+Note that this is *not* the same as a rotate-right; the\n+RHS of a wrapping shift-right is restricted to the range\n+of the type, rather than the bits shifted out of the LHS\n+being returned to the other end. The primitive integer\n+types all implement a `rotate_right` function, which may\n+be what you want instead.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\n+assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(\", stringify!($BITS), \"), 128);\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_shr(self, rhs: u32) -> Self {\n+                unsafe {\n+                    intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+                }\n             }\n         }\n \n-        /// Calculates `self` + `rhs`\n-        ///\n-        /// Returns a tuple of the addition along with a boolean indicating\n-        /// whether an arithmetic overflow would occur. If an overflow would\n-        /// have occurred then the wrapped value is returned.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// use std::u32;\n-        ///\n-        /// assert_eq!(5u32.overflowing_add(2), (7, false));\n-        /// assert_eq!(u32::MAX.overflowing_add(1), (0, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n-            let (a, b) = unsafe {\n-                intrinsics::add_with_overflow(self as $ActualT,\n-                                              rhs as $ActualT)\n-            };\n-            (a as Self, b)\n+        doc_comment! {\n+            concat!(\"Calculates `self` + `rhs`\n+\n+Returns a tuple of the addition along with a boolean indicating\n+whether an arithmetic overflow would occur. If an overflow would\n+have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+use std::u32;\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = unsafe {\n+                    intrinsics::add_with_overflow(self as $ActualT,\n+                                                  rhs as $ActualT)\n+                };\n+                (a as Self, b)\n+            }\n         }\n \n-        /// Calculates `self` - `rhs`\n-        ///\n-        /// Returns a tuple of the subtraction along with a boolean indicating\n-        /// whether an arithmetic overflow would occur. If an overflow would\n-        /// have occurred then the wrapped value is returned.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// use std::u32;\n-        ///\n-        /// assert_eq!(5u32.overflowing_sub(2), (3, false));\n-        /// assert_eq!(0u32.overflowing_sub(1), (u32::MAX, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n-            let (a, b) = unsafe {\n-                intrinsics::sub_with_overflow(self as $ActualT,\n-                                              rhs as $ActualT)\n-            };\n-            (a as Self, b)\n+        doc_comment! {\n+            concat!(\"Calculates `self` - `rhs`\n+\n+Returns a tuple of the subtraction along with a boolean indicating\n+whether an arithmetic overflow would occur. If an overflow would\n+have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+use std::u32;\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\n+assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = unsafe {\n+                    intrinsics::sub_with_overflow(self as $ActualT,\n+                                                  rhs as $ActualT)\n+                };\n+                (a as Self, b)\n+            }\n         }\n \n         /// Calculates the multiplication of `self` and `rhs`.\n@@ -2093,129 +2155,140 @@ macro_rules! uint_impl {\n             (a as Self, b)\n         }\n \n-        /// Calculates the divisor when `self` is divided by `rhs`.\n-        ///\n-        /// Returns a tuple of the divisor along with a boolean indicating\n-        /// whether an arithmetic overflow would occur. Note that for unsigned\n-        /// integers overflow never occurs, so the second value is always\n-        /// `false`.\n-        ///\n-        /// # Panics\n-        ///\n-        /// This function will panic if `rhs` is 0.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// assert_eq!(5u32.overflowing_div(2), (2, false));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n-            (self / rhs, false)\n+        doc_comment! {\n+            concat!(\"Calculates the divisor when `self` is divided by `rhs`.\n+\n+Returns a tuple of the divisor along with a boolean indicating\n+whether an arithmetic overflow would occur. Note that for unsigned\n+integers overflow never occurs, so the second value is always\n+`false`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+                (self / rhs, false)\n+            }\n         }\n \n-        /// Calculates the remainder when `self` is divided by `rhs`.\n-        ///\n-        /// Returns a tuple of the remainder after dividing along with a boolean\n-        /// indicating whether an arithmetic overflow would occur. Note that for\n-        /// unsigned integers overflow never occurs, so the second value is\n-        /// always `false`.\n-        ///\n-        /// # Panics\n-        ///\n-        /// This function will panic if `rhs` is 0.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// assert_eq!(5u32.overflowing_rem(2), (1, false));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n-            (self % rhs, false)\n+        doc_comment! {\n+            concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n+\n+Returns a tuple of the remainder after dividing along with a boolean\n+indicating whether an arithmetic overflow would occur. Note that for\n+unsigned integers overflow never occurs, so the second value is\n+always `false`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+                (self % rhs, false)\n+            }\n         }\n \n-        /// Negates self in an overflowing fashion.\n-        ///\n-        /// Returns `!self + 1` using wrapping operations to return the value\n-        /// that represents the negation of this unsigned value. Note that for\n-        /// positive unsigned values overflow always occurs, but negating 0 does\n-        /// not overflow.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// assert_eq!(0u32.overflowing_neg(), (0, false));\n-        /// assert_eq!(2u32.overflowing_neg(), (-2i32 as u32, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_neg(self) -> (Self, bool) {\n-            ((!self).wrapping_add(1), self != 0)\n+        doc_comment! {\n+            concat!(\"Negates self in an overflowing fashion.\n+\n+Returns `!self + 1` using wrapping operations to return the value\n+that represents the negation of this unsigned value. Note that for\n+positive unsigned values overflow always occurs, but negating 0 does\n+not overflow.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\n+assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_neg(self) -> (Self, bool) {\n+                ((!self).wrapping_add(1), self != 0)\n+            }\n         }\n \n-        /// Shifts self left by `rhs` bits.\n-        ///\n-        /// Returns a tuple of the shifted version of self along with a boolean\n-        /// indicating whether the shift value was larger than or equal to the\n-        /// number of bits. If the shift value is too large, then value is\n-        /// masked (N-1) where N is the number of bits, and this value is then\n-        /// used to perform the shift.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// assert_eq!(0x10u32.overflowing_shl(4), (0x100, false));\n-        /// assert_eq!(0x10u32.overflowing_shl(36), (0x100, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        doc_comment! {\n+            concat!(\"Shifts self left by `rhs` bits.\n+\n+Returns a tuple of the shifted version of self along with a boolean\n+indicating whether the shift value was larger than or equal to the\n+number of bits. If the shift value is too large, then value is\n+masked (N-1) where N is the number of bits, and this value is then\n+used to perform the shift.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(4), (0x100, false));\n+assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(132), (0x100, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+                (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+            }\n         }\n \n-        /// Shifts self right by `rhs` bits.\n-        ///\n-        /// Returns a tuple of the shifted version of self along with a boolean\n-        /// indicating whether the shift value was larger than or equal to the\n-        /// number of bits. If the shift value is too large, then value is\n-        /// masked (N-1) where N is the number of bits, and this value is then\n-        /// used to perform the shift.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// assert_eq!(0x10u32.overflowing_shr(4), (0x1, false));\n-        /// assert_eq!(0x10u32.overflowing_shr(36), (0x1, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+        doc_comment! {\n+            concat!(\"Shifts self right by `rhs` bits.\n+\n+Returns a tuple of the shifted version of self along with a boolean\n+indicating whether the shift value was larger than or equal to the\n+number of bits. If the shift value is too large, then value is\n+masked (N-1) where N is the number of bits, and this value is then\n+used to perform the shift.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n+assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+                (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+            }\n \n         }\n \n-        /// Raises self to the power of `exp`, using exponentiation by squaring.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(2u32.pow(4), 16);\n-        /// ```\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(2\", stringify!($SelfT), \".pow(4), 16);\n+```\"),\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n@@ -2240,21 +2313,24 @@ macro_rules! uint_impl {\n \n             acc\n         }\n+    }\n \n-        /// Returns `true` if and only if `self == 2^k` for some `k`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert!(16u8.is_power_of_two());\n-        /// assert!(!10u8.is_power_of_two());\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn is_power_of_two(self) -> bool {\n-            (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n+        doc_comment! {\n+            concat!(\"Returns `true` if and only if `self == 2^k` for some `k`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert!(16\", stringify!($SelfT), \".is_power_of_two());\n+assert!(!10\", stringify!($SelfT), \".is_power_of_two());\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn is_power_of_two(self) -> bool {\n+                (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n+            }\n         }\n \n         // Returns one less than next power of two.\n@@ -2279,50 +2355,54 @@ macro_rules! uint_impl {\n             <$SelfT>::max_value() >> z\n         }\n \n-        /// Returns the smallest power of two greater than or equal to `self`.\n-        ///\n-        /// When return value overflows (i.e. `self > (1 << (N-1))` for type\n-        /// `uN`), it panics in debug mode and return value is wrapped to 0 in\n-        /// release mode (the only situation in which method can return 0).\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(2u8.next_power_of_two(), 2);\n-        /// assert_eq!(3u8.next_power_of_two(), 4);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn next_power_of_two(self) -> Self {\n-            // Call the trait to get overflow checks\n-            ops::Add::add(self.one_less_than_next_power_of_two(), 1)\n+        doc_comment! {\n+            concat!(\"Returns the smallest power of two greater than or equal to `self`.\n+\n+When return value overflows (i.e. `self > (1 << (N-1))` for type\n+`uN`), it panics in debug mode and return value is wrapped to 0 in\n+release mode (the only situation in which method can return 0).\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\n+assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn next_power_of_two(self) -> Self {\n+                // Call the trait to get overflow checks\n+                ops::Add::add(self.one_less_than_next_power_of_two(), 1)\n+            }\n         }\n \n-        /// Returns the smallest power of two greater than or equal to `n`. If\n-        /// the next power of two is greater than the type's maximum value,\n-        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(2u8.checked_next_power_of_two(), Some(2));\n-        /// assert_eq!(3u8.checked_next_power_of_two(), Some(4));\n-        /// assert_eq!(200u8.checked_next_power_of_two(), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn checked_next_power_of_two(self) -> Option<Self> {\n-            self.one_less_than_next_power_of_two().checked_add(1)\n+        doc_comment! {\n+            concat!(\"Returns the smallest power of two greater than or equal to `n`. If\n+the next power of two is greater than the type's maximum value,\n+`None` is returned, otherwise the power of two is wrapped in `Some`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\n+assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_next_power_of_two(), None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            pub fn checked_next_power_of_two(self) -> Option<Self> {\n+                self.one_less_than_next_power_of_two().checked_add(1)\n+            }\n         }\n     }\n }\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, u8, 8 }\n+    uint_impl! { u8, u8, 8, 255 }\n \n \n     /// Checks if the value is within the ASCII range.\n@@ -2868,39 +2948,39 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, u16, 16 }\n+    uint_impl! { u16, u16, 16, 65535 }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, u32, 32 }\n+    uint_impl! { u32, u32, 32, 4294967295 }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, u64, 64 }\n+    uint_impl! { u64, u64, 64, 18446744073709551615 }\n }\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, 128 }\n+    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455 }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u16, 16 }\n+    uint_impl! { usize, u16, 16, 65536 }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u32, 32 }\n+    uint_impl! { usize, u32, 32, 4294967295 }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u64, 64 }\n+    uint_impl! { usize, u64, 64, 18446744073709551615 }\n }\n \n /// A classification of floating point numbers."}]}