{"sha": "37a72a2e3e548c6bdecdf425b1616a7d6edcec0c", "node_id": "C_kwDOAAsO6NoAKDM3YTcyYTJlM2U1NDhjNmJkZWNkZjQyNWIxNjE2YTdkNmVkY2VjMGM", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-11T18:51:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-11T19:23:17Z"}, "message": "rustc_ast: Merge impls and reorder methods for attributes and meta items", "tree": {"sha": "2a00ea2b5d30765e48ba262e67b4829444688227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a00ea2b5d30765e48ba262e67b4829444688227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37a72a2e3e548c6bdecdf425b1616a7d6edcec0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37a72a2e3e548c6bdecdf425b1616a7d6edcec0c", "html_url": "https://github.com/rust-lang/rust/commit/37a72a2e3e548c6bdecdf425b1616a7d6edcec0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37a72a2e3e548c6bdecdf425b1616a7d6edcec0c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dabf5da9e0318f8c324dc224ad49dc91472c2ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dabf5da9e0318f8c324dc224ad49dc91472c2ec", "html_url": "https://github.com/rust-lang/rust/commit/8dabf5da9e0318f8c324dc224ad49dc91472c2ec"}], "stats": {"total": 626, "additions": 311, "deletions": 315}, "files": [{"sha": "e75d2f77dbbad8eb9491e338e76d5258a3461d9f", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 311, "deletions": 315, "changes": 626, "blob_url": "https://github.com/rust-lang/rust/blob/37a72a2e3e548c6bdecdf425b1616a7d6edcec0c/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a72a2e3e548c6bdecdf425b1616a7d6edcec0c/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=37a72a2e3e548c6bdecdf425b1616a7d6edcec0c", "patch": "@@ -40,84 +40,65 @@ impl MarkedAttrs {\n     }\n }\n \n-impl NestedMetaItem {\n-    /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n-    pub fn meta_item(&self) -> Option<&MetaItem> {\n-        match self {\n-            NestedMetaItem::MetaItem(item) => Some(item),\n-            _ => None,\n-        }\n-    }\n+pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n \n-    /// Returns the `MetaItemLit` if `self` is a `NestedMetaItem::Literal`s.\n-    pub fn lit(&self) -> Option<&MetaItemLit> {\n-        match self {\n-            NestedMetaItem::Lit(lit) => Some(lit),\n-            _ => None,\n-        }\n-    }\n+#[cfg(debug_assertions)]\n+static MAX_ATTR_ID: AtomicU32 = AtomicU32::new(u32::MAX);\n \n-    /// Returns `true` if this list item is a MetaItem with a name of `name`.\n-    pub fn has_name(&self, name: Symbol) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.has_name(name))\n-    }\n+impl AttrIdGenerator {\n+    pub fn new() -> Self {\n+        // We use `(index as u32).reverse_bits()` to initialize the\n+        // starting value of AttrId in each worker thread.\n+        // The `index` is the index of the worker thread.\n+        // This ensures that the AttrId generated in each thread is unique.\n+        AttrIdGenerator(WorkerLocal::new(|index| {\n+            let index: u32 = index.try_into().unwrap();\n \n-    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n-    pub fn ident(&self) -> Option<Ident> {\n-        self.meta_item().and_then(|meta_item| meta_item.ident())\n-    }\n-    pub fn name_or_empty(&self) -> Symbol {\n-        self.ident().unwrap_or_else(Ident::empty).name\n-    }\n+            #[cfg(debug_assertions)]\n+            {\n+                let max_id = ((index + 1).next_power_of_two() - 1).bitxor(u32::MAX).reverse_bits();\n+                MAX_ATTR_ID.fetch_min(max_id, Ordering::Release);\n+            }\n \n-    /// Gets the string value if `self` is a `MetaItem` and the `MetaItem` is a\n-    /// `MetaItemKind::NameValue` variant containing a string, otherwise `None`.\n-    pub fn value_str(&self) -> Option<Symbol> {\n-        self.meta_item().and_then(|meta_item| meta_item.value_str())\n+            Cell::new(index.reverse_bits())\n+        }))\n     }\n \n-    /// Returns a name and single literal value tuple of the `MetaItem`.\n-    pub fn name_value_literal(&self) -> Option<(Symbol, &MetaItemLit)> {\n-        self.meta_item().and_then(|meta_item| {\n-            meta_item.meta_item_list().and_then(|meta_item_list| {\n-                if meta_item_list.len() == 1\n-                    && let Some(ident) = meta_item.ident()\n-                    && let Some(lit) = meta_item_list[0].lit()\n-                {\n-                    return Some((ident.name, lit));\n-                }\n-                None\n-            })\n-        })\n-    }\n+    pub fn mk_attr_id(&self) -> AttrId {\n+        let id = self.0.get();\n \n-    /// Gets a list of inner meta items from a list `MetaItem` type.\n-    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        self.meta_item().and_then(|meta_item| meta_item.meta_item_list())\n-    }\n+        // Ensure the assigned attr_id does not overlap the bits\n+        // representing the number of threads.\n+        #[cfg(debug_assertions)]\n+        assert!(id <= MAX_ATTR_ID.load(Ordering::Acquire));\n \n-    /// Returns `true` if the variant is `MetaItem`.\n-    pub fn is_meta_item(&self) -> bool {\n-        self.meta_item().is_some()\n+        self.0.set(id + 1);\n+        AttrId::from_u32(id)\n     }\n+}\n \n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n-    pub fn is_word(&self) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n+impl Attribute {\n+    pub fn get_normal_item(&self) -> &AttrItem {\n+        match &self.kind {\n+            AttrKind::Normal(normal) => &normal.item,\n+            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n+        }\n     }\n \n-    /// See [`MetaItem::name_value_literal_span`].\n-    pub fn name_value_literal_span(&self) -> Option<Span> {\n-        self.meta_item()?.name_value_literal_span()\n+    pub fn unwrap_normal_item(self) -> AttrItem {\n+        match self.kind {\n+            AttrKind::Normal(normal) => normal.into_inner().item,\n+            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n+        }\n     }\n-}\n \n-impl Attribute {\n-    #[inline]\n-    pub fn has_name(&self, name: Symbol) -> bool {\n-        match &self.kind {\n-            AttrKind::Normal(normal) => normal.item.path == name,\n-            AttrKind::DocComment(..) => false,\n+    /// Returns `true` if it is a sugared doc comment (`///` or `//!` for example).\n+    /// So `#[doc = \"doc\"]` (which is a doc comment) and `#[doc(...)]` (which is not\n+    /// a doc comment) will return `false`.\n+    pub fn is_doc_comment(&self) -> bool {\n+        match self.kind {\n+            AttrKind::Normal(..) => false,\n+            AttrKind::DocComment(..) => true,\n         }\n     }\n \n@@ -138,17 +119,11 @@ impl Attribute {\n         self.ident().unwrap_or_else(Ident::empty).name\n     }\n \n-    pub fn value_str(&self) -> Option<Symbol> {\n-        match &self.kind {\n-            AttrKind::Normal(normal) => normal.item.value_str(),\n-            AttrKind::DocComment(..) => None,\n-        }\n-    }\n-\n-    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+    #[inline]\n+    pub fn has_name(&self, name: Symbol) -> bool {\n         match &self.kind {\n-            AttrKind::Normal(normal) => normal.item.meta_item_list(),\n-            AttrKind::DocComment(..) => None,\n+            AttrKind::Normal(normal) => normal.item.path == name,\n+            AttrKind::DocComment(..) => false,\n         }\n     }\n \n@@ -159,112 +134,18 @@ impl Attribute {\n             false\n         }\n     }\n-}\n \n-impl MetaItem {\n-    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n-    pub fn ident(&self) -> Option<Ident> {\n-        if self.path.segments.len() == 1 { Some(self.path.segments[0].ident) } else { None }\n-    }\n-    pub fn name_or_empty(&self) -> Symbol {\n-        self.ident().unwrap_or_else(Ident::empty).name\n-    }\n-\n-    /// ```text\n-    /// Example:\n-    ///     #[attribute(name = \"value\")]\n-    ///                 ^^^^^^^^^^^^^^\n-    /// ```\n-    pub fn name_value_literal(&self) -> Option<&MetaItemLit> {\n+    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n         match &self.kind {\n-            MetaItemKind::NameValue(v) => Some(v),\n-            _ => None,\n+            AttrKind::Normal(normal) => normal.item.meta_item_list(),\n+            AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        self.kind.value_str()\n-    }\n-\n-    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n         match &self.kind {\n-            MetaItemKind::List(l) => Some(&**l),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn is_word(&self) -> bool {\n-        matches!(self.kind, MetaItemKind::Word)\n-    }\n-\n-    pub fn has_name(&self, name: Symbol) -> bool {\n-        self.path == name\n-    }\n-\n-    /// This is used in case you want the value span instead of the whole attribute. Example:\n-    ///\n-    /// ```text\n-    /// #[doc(alias = \"foo\")]\n-    /// ```\n-    ///\n-    /// In here, it'll return a span for `\"foo\"`.\n-    pub fn name_value_literal_span(&self) -> Option<Span> {\n-        Some(self.name_value_literal()?.span)\n-    }\n-}\n-\n-impl AttrArgsEq {\n-    fn value_str(&self) -> Option<Symbol> {\n-        match self {\n-            AttrArgsEq::Ast(expr) => match expr.kind {\n-                ExprKind::Lit(token_lit) => {\n-                    LitKind::from_token_lit(token_lit).ok().and_then(|lit| lit.str())\n-                }\n-                _ => None,\n-            },\n-            AttrArgsEq::Hir(lit) => lit.kind.str(),\n-        }\n-    }\n-}\n-\n-impl AttrItem {\n-    pub fn span(&self) -> Span {\n-        self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n-    }\n-\n-    pub fn meta(&self, span: Span) -> Option<MetaItem> {\n-        Some(MetaItem { path: self.path.clone(), kind: self.meta_kind()?, span })\n-    }\n-\n-    pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        MetaItemKind::from_attr_args(&self.args)\n-    }\n-\n-    fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n-        match &self.args {\n-            AttrArgs::Delimited(args) if args.delim == MacDelimiter::Parenthesis => {\n-                MetaItemKind::list_from_tokens(args.tokens.clone())\n-            }\n-            AttrArgs::Delimited(_) | AttrArgs::Eq(..) | AttrArgs::Empty => None,\n-        }\n-    }\n-\n-    fn value_str(&self) -> Option<Symbol> {\n-        match &self.args {\n-            AttrArgs::Eq(_, args) => args.value_str(),\n-            AttrArgs::Delimited(_) | AttrArgs::Empty => None,\n-        }\n-    }\n-}\n-\n-impl Attribute {\n-    /// Returns `true` if it is a sugared doc comment (`///` or `//!` for example).\n-    /// So `#[doc = \"doc\"]` (which is a doc comment) and `#[doc(...)]` (which is not\n-    /// a doc comment) will return `false`.\n-    pub fn is_doc_comment(&self) -> bool {\n-        match self.kind {\n-            AttrKind::Normal(..) => false,\n-            AttrKind::DocComment(..) => true,\n+            AttrKind::Normal(normal) => normal.item.value_str(),\n+            AttrKind::DocComment(..) => None,\n         }\n     }\n \n@@ -299,20 +180,6 @@ impl Attribute {\n         self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n     }\n \n-    pub fn get_normal_item(&self) -> &AttrItem {\n-        match &self.kind {\n-            AttrKind::Normal(normal) => &normal.item,\n-            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n-        }\n-    }\n-\n-    pub fn unwrap_normal_item(self) -> AttrItem {\n-        match self.kind {\n-            AttrKind::Normal(normal) => normal.into_inner().item,\n-            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n-        }\n-    }\n-\n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n         match &self.kind {\n@@ -344,130 +211,102 @@ impl Attribute {\n     }\n }\n \n-pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n-\n-#[cfg(debug_assertions)]\n-static MAX_ATTR_ID: AtomicU32 = AtomicU32::new(u32::MAX);\n-\n-impl AttrIdGenerator {\n-    pub fn new() -> Self {\n-        // We use `(index as u32).reverse_bits()` to initialize the\n-        // starting value of AttrId in each worker thread.\n-        // The `index` is the index of the worker thread.\n-        // This ensures that the AttrId generated in each thread is unique.\n-        AttrIdGenerator(WorkerLocal::new(|index| {\n-            let index: u32 = index.try_into().unwrap();\n+impl AttrItem {\n+    pub fn span(&self) -> Span {\n+        self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n+    }\n \n-            #[cfg(debug_assertions)]\n-            {\n-                let max_id = ((index + 1).next_power_of_two() - 1).bitxor(u32::MAX).reverse_bits();\n-                MAX_ATTR_ID.fetch_min(max_id, Ordering::Release);\n+    fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+        match &self.args {\n+            AttrArgs::Delimited(args) if args.delim == MacDelimiter::Parenthesis => {\n+                MetaItemKind::list_from_tokens(args.tokens.clone())\n             }\n-\n-            Cell::new(index.reverse_bits())\n-        }))\n+            AttrArgs::Delimited(_) | AttrArgs::Eq(..) | AttrArgs::Empty => None,\n+        }\n     }\n \n-    pub fn mk_attr_id(&self) -> AttrId {\n-        let id = self.0.get();\n-\n-        // Ensure the assigned attr_id does not overlap the bits\n-        // representing the number of threads.\n-        #[cfg(debug_assertions)]\n-        assert!(id <= MAX_ATTR_ID.load(Ordering::Acquire));\n-\n-        self.0.set(id + 1);\n-        AttrId::from_u32(id)\n+    fn value_str(&self) -> Option<Symbol> {\n+        match &self.args {\n+            AttrArgs::Eq(_, args) => args.value_str(),\n+            AttrArgs::Delimited(_) | AttrArgs::Empty => None,\n+        }\n     }\n-}\n \n-pub fn mk_attr(\n-    g: &AttrIdGenerator,\n-    style: AttrStyle,\n-    path: Path,\n-    args: AttrArgs,\n-    span: Span,\n-) -> Attribute {\n-    mk_attr_from_item(g, AttrItem { path, args, tokens: None }, None, style, span)\n-}\n-\n-pub fn mk_attr_from_item(\n-    g: &AttrIdGenerator,\n-    item: AttrItem,\n-    tokens: Option<LazyAttrTokenStream>,\n-    style: AttrStyle,\n-    span: Span,\n-) -> Attribute {\n-    Attribute {\n-        kind: AttrKind::Normal(P(NormalAttr { item, tokens })),\n-        id: g.mk_attr_id(),\n-        style,\n-        span,\n+    pub fn meta(&self, span: Span) -> Option<MetaItem> {\n+        Some(MetaItem { path: self.path.clone(), kind: self.meta_kind()?, span })\n     }\n-}\n \n-pub fn mk_attr_word(g: &AttrIdGenerator, style: AttrStyle, name: Symbol, span: Span) -> Attribute {\n-    let path = Path::from_ident(Ident::new(name, span));\n-    let args = AttrArgs::Empty;\n-    mk_attr(g, style, path, args, span)\n-}\n-\n-pub fn mk_attr_name_value_str(\n-    g: &AttrIdGenerator,\n-    style: AttrStyle,\n-    name: Symbol,\n-    val: Symbol,\n-    span: Span,\n-) -> Attribute {\n-    let lit = token::Lit::new(token::Str, escape_string_symbol(val), None);\n-    let expr = P(Expr {\n-        id: DUMMY_NODE_ID,\n-        kind: ExprKind::Lit(lit),\n-        span,\n-        attrs: AttrVec::new(),\n-        tokens: None,\n-    });\n-    let path = Path::from_ident(Ident::new(name, span));\n-    let args = AttrArgs::Eq(span, AttrArgsEq::Ast(expr));\n-    mk_attr(g, style, path, args, span)\n+    pub fn meta_kind(&self) -> Option<MetaItemKind> {\n+        MetaItemKind::from_attr_args(&self.args)\n+    }\n }\n \n-pub fn mk_attr_nested_word(\n-    g: &AttrIdGenerator,\n-    style: AttrStyle,\n-    outer: Symbol,\n-    inner: Symbol,\n-    span: Span,\n-) -> Attribute {\n-    let inner_tokens = TokenStream::new(vec![TokenTree::Token(\n-        Token::from_ast_ident(Ident::new(inner, span)),\n-        Spacing::Alone,\n-    )]);\n-    let outer_ident = Ident::new(outer, span);\n-    let path = Path::from_ident(outer_ident);\n-    let attr_args = AttrArgs::Delimited(DelimArgs {\n-        dspan: DelimSpan::from_single(span),\n-        delim: MacDelimiter::Parenthesis,\n-        tokens: inner_tokens,\n-    });\n-    mk_attr(g, style, path, attr_args, span)\n+impl AttrArgsEq {\n+    fn value_str(&self) -> Option<Symbol> {\n+        match self {\n+            AttrArgsEq::Ast(expr) => match expr.kind {\n+                ExprKind::Lit(token_lit) => {\n+                    LitKind::from_token_lit(token_lit).ok().and_then(|lit| lit.str())\n+                }\n+                _ => None,\n+            },\n+            AttrArgsEq::Hir(lit) => lit.kind.str(),\n+        }\n+    }\n }\n \n-pub fn mk_doc_comment(\n-    g: &AttrIdGenerator,\n-    comment_kind: CommentKind,\n-    style: AttrStyle,\n-    data: Symbol,\n-    span: Span,\n-) -> Attribute {\n-    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: g.mk_attr_id(), style, span }\n-}\n+impl MetaItem {\n+    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        if self.path.segments.len() == 1 { Some(self.path.segments[0].ident) } else { None }\n+    }\n \n-pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n-    items.iter().any(|item| item.has_name(name))\n-}\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or_else(Ident::empty).name\n+    }\n+\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        self.path == name\n+    }\n+\n+    pub fn is_word(&self) -> bool {\n+        matches!(self.kind, MetaItemKind::Word)\n+    }\n+\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n+        match &self.kind {\n+            MetaItemKind::List(l) => Some(&**l),\n+            _ => None,\n+        }\n+    }\n+\n+    /// ```text\n+    /// Example:\n+    ///     #[attribute(name = \"value\")]\n+    ///                 ^^^^^^^^^^^^^^\n+    /// ```\n+    pub fn name_value_literal(&self) -> Option<&MetaItemLit> {\n+        match &self.kind {\n+            MetaItemKind::NameValue(v) => Some(v),\n+            _ => None,\n+        }\n+    }\n+\n+    /// This is used in case you want the value span instead of the whole attribute. Example:\n+    ///\n+    /// ```text\n+    /// #[doc(alias = \"foo\")]\n+    /// ```\n+    ///\n+    /// In here, it'll return a span for `\"foo\"`.\n+    pub fn name_value_literal_span(&self) -> Option<Span> {\n+        Some(self.name_value_literal()?.span)\n+    }\n+\n+    pub fn value_str(&self) -> Option<Symbol> {\n+        self.kind.value_str()\n+    }\n \n-impl MetaItem {\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n     where\n         I: Iterator<Item = TokenTree>,\n@@ -564,6 +403,24 @@ impl MetaItemKind {\n         }\n     }\n \n+    fn from_tokens(\n+        tokens: &mut iter::Peekable<impl Iterator<Item = TokenTree>>,\n+    ) -> Option<MetaItemKind> {\n+        match tokens.peek() {\n+            Some(TokenTree::Delimited(_, Delimiter::Parenthesis, inner_tokens)) => {\n+                let inner_tokens = inner_tokens.clone();\n+                tokens.next();\n+                MetaItemKind::list_from_tokens(inner_tokens).map(MetaItemKind::List)\n+            }\n+            Some(TokenTree::Delimited(..)) => None,\n+            Some(TokenTree::Token(Token { kind: token::Eq, .. }, _)) => {\n+                tokens.next();\n+                MetaItemKind::name_value_from_tokens(tokens)\n+            }\n+            _ => Some(MetaItemKind::Word),\n+        }\n+    }\n+\n     fn from_attr_args(args: &AttrArgs) -> Option<MetaItemKind> {\n         match args {\n             AttrArgs::Empty => Some(MetaItemKind::Word),\n@@ -585,24 +442,6 @@ impl MetaItemKind {\n             AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n         }\n     }\n-\n-    fn from_tokens(\n-        tokens: &mut iter::Peekable<impl Iterator<Item = TokenTree>>,\n-    ) -> Option<MetaItemKind> {\n-        match tokens.peek() {\n-            Some(TokenTree::Delimited(_, Delimiter::Parenthesis, inner_tokens)) => {\n-                let inner_tokens = inner_tokens.clone();\n-                tokens.next();\n-                MetaItemKind::list_from_tokens(inner_tokens).map(MetaItemKind::List)\n-            }\n-            Some(TokenTree::Delimited(..)) => None,\n-            Some(TokenTree::Token(Token { kind: token::Eq, .. }, _)) => {\n-                tokens.next();\n-                MetaItemKind::name_value_from_tokens(tokens)\n-            }\n-            _ => Some(MetaItemKind::Word),\n-        }\n-    }\n }\n \n impl NestedMetaItem {\n@@ -613,6 +452,77 @@ impl NestedMetaItem {\n         }\n     }\n \n+    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        self.meta_item().and_then(|meta_item| meta_item.ident())\n+    }\n+\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or_else(Ident::empty).name\n+    }\n+\n+    /// Returns `true` if this list item is a MetaItem with a name of `name`.\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.has_name(name))\n+    }\n+\n+    /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n+    pub fn is_word(&self) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n+    }\n+\n+    /// Gets a list of inner meta items from a list `MetaItem` type.\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n+        self.meta_item().and_then(|meta_item| meta_item.meta_item_list())\n+    }\n+\n+    /// Returns a name and single literal value tuple of the `MetaItem`.\n+    pub fn name_value_literal(&self) -> Option<(Symbol, &MetaItemLit)> {\n+        self.meta_item().and_then(|meta_item| {\n+            meta_item.meta_item_list().and_then(|meta_item_list| {\n+                if meta_item_list.len() == 1\n+                    && let Some(ident) = meta_item.ident()\n+                    && let Some(lit) = meta_item_list[0].lit()\n+                {\n+                    return Some((ident.name, lit));\n+                }\n+                None\n+            })\n+        })\n+    }\n+\n+    /// See [`MetaItem::name_value_literal_span`].\n+    pub fn name_value_literal_span(&self) -> Option<Span> {\n+        self.meta_item()?.name_value_literal_span()\n+    }\n+\n+    /// Gets the string value if `self` is a `MetaItem` and the `MetaItem` is a\n+    /// `MetaItemKind::NameValue` variant containing a string, otherwise `None`.\n+    pub fn value_str(&self) -> Option<Symbol> {\n+        self.meta_item().and_then(|meta_item| meta_item.value_str())\n+    }\n+\n+    /// Returns the `MetaItemLit` if `self` is a `NestedMetaItem::Literal`s.\n+    pub fn lit(&self) -> Option<&MetaItemLit> {\n+        match self {\n+            NestedMetaItem::Lit(lit) => Some(lit),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n+    pub fn meta_item(&self) -> Option<&MetaItem> {\n+        match self {\n+            NestedMetaItem::MetaItem(item) => Some(item),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns `true` if the variant is `MetaItem`.\n+    pub fn is_meta_item(&self) -> bool {\n+        self.meta_item().is_some()\n+    }\n+\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItem>\n     where\n         I: Iterator<Item = TokenTree>,\n@@ -634,3 +544,89 @@ impl NestedMetaItem {\n         MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }\n+\n+pub fn mk_doc_comment(\n+    g: &AttrIdGenerator,\n+    comment_kind: CommentKind,\n+    style: AttrStyle,\n+    data: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: g.mk_attr_id(), style, span }\n+}\n+\n+pub fn mk_attr(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    path: Path,\n+    args: AttrArgs,\n+    span: Span,\n+) -> Attribute {\n+    mk_attr_from_item(g, AttrItem { path, args, tokens: None }, None, style, span)\n+}\n+\n+pub fn mk_attr_from_item(\n+    g: &AttrIdGenerator,\n+    item: AttrItem,\n+    tokens: Option<LazyAttrTokenStream>,\n+    style: AttrStyle,\n+    span: Span,\n+) -> Attribute {\n+    Attribute {\n+        kind: AttrKind::Normal(P(NormalAttr { item, tokens })),\n+        id: g.mk_attr_id(),\n+        style,\n+        span,\n+    }\n+}\n+\n+pub fn mk_attr_word(g: &AttrIdGenerator, style: AttrStyle, name: Symbol, span: Span) -> Attribute {\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Empty;\n+    mk_attr(g, style, path, args, span)\n+}\n+\n+pub fn mk_attr_nested_word(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    outer: Symbol,\n+    inner: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let inner_tokens = TokenStream::new(vec![TokenTree::Token(\n+        Token::from_ast_ident(Ident::new(inner, span)),\n+        Spacing::Alone,\n+    )]);\n+    let outer_ident = Ident::new(outer, span);\n+    let path = Path::from_ident(outer_ident);\n+    let attr_args = AttrArgs::Delimited(DelimArgs {\n+        dspan: DelimSpan::from_single(span),\n+        delim: MacDelimiter::Parenthesis,\n+        tokens: inner_tokens,\n+    });\n+    mk_attr(g, style, path, attr_args, span)\n+}\n+\n+pub fn mk_attr_name_value_str(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    name: Symbol,\n+    val: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let lit = token::Lit::new(token::Str, escape_string_symbol(val), None);\n+    let expr = P(Expr {\n+        id: DUMMY_NODE_ID,\n+        kind: ExprKind::Lit(lit),\n+        span,\n+        attrs: AttrVec::new(),\n+        tokens: None,\n+    });\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Eq(span, AttrArgsEq::Ast(expr));\n+    mk_attr(g, style, path, args, span)\n+}\n+\n+pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n+    items.iter().any(|item| item.has_name(name))\n+}"}]}