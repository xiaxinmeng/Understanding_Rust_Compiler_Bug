{"sha": "5cef1243a21c162cb9968f9bc14d1a23ba88426e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZWYxMjQzYTIxYzE2MmNiOTk2OGY5YmMxNGQxYTIzYmE4ODQyNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-01T02:51:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-01T02:51:33Z"}, "message": "auto merge of #15242 : pcwalton/rust/self-in-trait-methods, r=alexcrichton\n\nI can't believe this worked! I believe that the way the ABI and\r\nimmediates work mean that this Just Works.\r\n\r\nCloses #10672.\r\n\r\nr? @alexcrichton", "tree": {"sha": "9166dd2ea1cd0d7544ab07da3e8de93e0d689cda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9166dd2ea1cd0d7544ab07da3e8de93e0d689cda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cef1243a21c162cb9968f9bc14d1a23ba88426e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cef1243a21c162cb9968f9bc14d1a23ba88426e", "html_url": "https://github.com/rust-lang/rust/commit/5cef1243a21c162cb9968f9bc14d1a23ba88426e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cef1243a21c162cb9968f9bc14d1a23ba88426e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90ab2f8b616634cff8e02f12c529504c088d52e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ab2f8b616634cff8e02f12c529504c088d52e8", "html_url": "https://github.com/rust-lang/rust/commit/90ab2f8b616634cff8e02f12c529504c088d52e8"}, {"sha": "68ead460f9029fd8de508a46fe944afb83e99da3", "url": "https://api.github.com/repos/rust-lang/rust/commits/68ead460f9029fd8de508a46fe944afb83e99da3", "html_url": "https://github.com/rust-lang/rust/commit/68ead460f9029fd8de508a46fe944afb83e99da3"}], "stats": {"total": 330, "additions": 309, "deletions": 21}, "files": [{"sha": "75271804b7911b32be2380cbfffc9d8015e824dc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5cef1243a21c162cb9968f9bc14d1a23ba88426e", "patch": "@@ -1220,7 +1220,7 @@ pub fn init_function<'a>(fcx: &'a FunctionContext<'a>,\n //  - new_fn_ctxt\n //  - trans_args\n \n-fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n+pub fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n     use middle::trans::datum::{ByRef, ByValue};\n \n     datum::Rvalue {"}, {"sha": "a9c1adac3d7cf01e07c3926d4706708e8a087367", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=5cef1243a21c162cb9968f9bc14d1a23ba88426e", "patch": "@@ -159,6 +159,14 @@ impl<'a> Builder<'a> {\n                   attributes: &[(uint, u64)])\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n+\n+        debug!(\"Invoke {} with args ({})\",\n+               self.ccx.tn.val_to_str(llfn),\n+               args.iter()\n+                   .map(|&v| self.ccx.tn.val_to_str(v))\n+                   .collect::<Vec<String>>()\n+                   .connect(\", \"));\n+\n         unsafe {\n             let v = llvm::LLVMBuildInvoke(self.llbuilder,\n                                           llfn,"}, {"sha": "116b2e6b421b81e41e1c5a94064853528c57897a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 134, "deletions": 6, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5cef1243a21c162cb9968f9bc14d1a23ba88426e", "patch": "@@ -16,7 +16,9 @@\n  * closure.\n  */\n \n+use arena::TypedArena;\n use back::abi;\n+use back::link;\n use driver::session;\n use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n@@ -33,28 +35,26 @@ use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n-use middle::trans::datum::Datum;\n+use middle::trans::datum::{Datum, KindOps};\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::inline;\n+use middle::trans::foreign;\n use middle::trans::meth;\n use middle::trans::monomorphize;\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n-use middle::trans::foreign;\n use middle::ty;\n use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n \n-use middle::trans::type_::Type;\n-\n+use std::gc::Gc;\n use syntax::ast;\n use synabi = syntax::abi;\n use syntax::ast_map;\n \n-use std::gc::Gc;\n-\n pub struct MethodData {\n     pub llfn: ValueRef,\n     pub llself: ValueRef,\n@@ -224,6 +224,134 @@ fn resolve_default_method_vtables(bcx: &Block,\n     param_vtables\n }\n \n+/// Translates the adapter that deconstructs a `Box<Trait>` object into\n+/// `Trait` so that a by-value self method can be called.\n+pub fn trans_unboxing_shim(bcx: &Block,\n+                           llshimmedfn: ValueRef,\n+                           method: &ty::Method,\n+                           method_id: ast::DefId,\n+                           substs: subst::Substs)\n+                           -> ValueRef {\n+    let _icx = push_ctxt(\"trans_unboxing_shim\");\n+    let ccx = bcx.ccx();\n+    let tcx = bcx.tcx();\n+\n+    // Transform the self type to `Box<self_type>`.\n+    let self_type = *method.fty.sig.inputs.get(0);\n+    let boxed_self_type = ty::mk_uniq(tcx, self_type);\n+    let boxed_function_type = ty::FnSig {\n+        binder_id: method.fty.sig.binder_id,\n+        inputs: method.fty.sig.inputs.iter().enumerate().map(|(i, typ)| {\n+            if i == 0 {\n+                boxed_self_type\n+            } else {\n+                *typ\n+            }\n+        }).collect(),\n+        output: method.fty.sig.output,\n+        variadic: false,\n+    };\n+    let boxed_function_type = ty::BareFnTy {\n+        fn_style: method.fty.fn_style,\n+        abi: method.fty.abi,\n+        sig: boxed_function_type,\n+    };\n+    let boxed_function_type =\n+        ty::mk_bare_fn(tcx, boxed_function_type).subst(tcx, &substs);\n+    let function_type =\n+        ty::mk_bare_fn(tcx, method.fty.clone()).subst(tcx, &substs);\n+\n+    let function_name = tcx.map.with_path(method_id.node, |path| {\n+        link::mangle_internal_name_by_path_and_seq(path, \"unboxing_shim\")\n+    });\n+    let llfn = decl_internal_rust_fn(ccx,\n+                                     boxed_function_type,\n+                                     function_name.as_slice());\n+\n+    let block_arena = TypedArena::new();\n+    let empty_param_substs = param_substs::empty();\n+    let return_type = ty::ty_fn_ret(boxed_function_type);\n+    let fcx = new_fn_ctxt(ccx,\n+                          llfn,\n+                          -1,\n+                          false,\n+                          return_type,\n+                          &empty_param_substs,\n+                          None,\n+                          &block_arena);\n+    init_function(&fcx, false, return_type);\n+\n+    // Create the substituted versions of the self type.\n+    let mut bcx = fcx.entry_bcx.borrow().clone().unwrap();\n+    let arg_scope = fcx.push_custom_cleanup_scope();\n+    let arg_scope_id = cleanup::CustomScope(arg_scope);\n+    let boxed_arg_types = ty::ty_fn_args(boxed_function_type);\n+    let boxed_self_type = *boxed_arg_types.get(0);\n+    let arg_types = ty::ty_fn_args(function_type);\n+    let self_type = *arg_types.get(0);\n+    let boxed_self_kind = arg_kind(&fcx, boxed_self_type);\n+\n+    // Create a datum for self.\n+    let llboxedself = unsafe {\n+        llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(0) as u32)\n+    };\n+    let llboxedself = Datum::new(llboxedself,\n+                                 boxed_self_type,\n+                                 boxed_self_kind);\n+    let boxed_self =\n+        unpack_datum!(bcx,\n+                      llboxedself.to_lvalue_datum_in_scope(bcx,\n+                                                           \"boxedself\",\n+                                                           arg_scope_id));\n+\n+    // This `Load` is needed because lvalue data are always by-ref.\n+    let llboxedself = Load(bcx, boxed_self.val);\n+\n+    let llself = if type_is_immediate(ccx, self_type) {\n+        let llboxedself = Load(bcx, llboxedself);\n+        immediate_rvalue(llboxedself, self_type)\n+    } else {\n+        let llself = rvalue_scratch_datum(bcx, self_type, \"self\");\n+        memcpy_ty(bcx, llself.val, llboxedself, self_type);\n+        llself\n+    };\n+\n+    // Make sure we don't free the box twice!\n+    boxed_self.kind.post_store(bcx, boxed_self.val, boxed_self_type);\n+\n+    // Schedule a cleanup to free the box.\n+    fcx.schedule_free_value(arg_scope_id,\n+                            llboxedself,\n+                            cleanup::HeapExchange,\n+                            self_type);\n+\n+    // Now call the function.\n+    let mut llshimmedargs = vec!(llself.val);\n+    for i in range(1, arg_types.len()) {\n+        llshimmedargs.push(unsafe {\n+            llvm::LLVMGetParam(fcx.llfn, fcx.arg_pos(i) as u32)\n+        });\n+    }\n+    bcx = trans_call_inner(bcx,\n+                           None,\n+                           function_type,\n+                           |bcx, _| {\n+                               Callee {\n+                                   bcx: bcx,\n+                                   data: Fn(llshimmedfn),\n+                               }\n+                           },\n+                           ArgVals(llshimmedargs.as_slice()),\n+                           match fcx.llretptr.get() {\n+                               None => None,\n+                               Some(llretptr) => Some(expr::SaveIn(llretptr)),\n+                           }).bcx;\n+\n+    bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n+    finish_fn(&fcx, bcx);\n+\n+    llfn\n+}\n \n pub fn trans_fn_ref_with_vtables(\n     bcx: &Block,                 //"}, {"sha": "e1d43c5240059ee03fd51e40f451269ec123f17d", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=5cef1243a21c162cb9968f9bc14d1a23ba88426e", "patch": "@@ -492,14 +492,24 @@ fn emit_vtable_methods(bcx: &Block,\n                m.repr(tcx),\n                substs.repr(tcx));\n         if m.generics.has_type_params(subst::FnSpace) ||\n-           ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone()))\n-        {\n+           ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n             debug!(\"(making impl vtable) method has self or type params: {}\",\n                    token::get_ident(ident));\n             C_null(Type::nil(ccx).ptr_to())\n         } else {\n-            trans_fn_ref_with_vtables(bcx, m_id, ExprId(0),\n-                                      substs.clone(), vtables.clone())\n+            let mut fn_ref = trans_fn_ref_with_vtables(bcx,\n+                                                       m_id,\n+                                                       ExprId(0),\n+                                                       substs.clone(),\n+                                                       vtables.clone());\n+            if m.explicit_self == ast::SelfValue {\n+                fn_ref = trans_unboxing_shim(bcx,\n+                                             fn_ref,\n+                                             &*m,\n+                                             m_id,\n+                                             substs.clone());\n+            }\n+            fn_ref\n         }\n     }).collect()\n }"}, {"sha": "c3b2756bdbff2f7f165af2718ec6a1fe293a7452", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5cef1243a21c162cb9968f9bc14d1a23ba88426e", "patch": "@@ -271,7 +271,9 @@ fn construct_transformed_self_ty_for_object(\n             tcx.sess.span_bug(span, \"static method for object type receiver\");\n         }\n         ast::SelfValue => {\n-            ty::mk_err() // error reported in `enforce_object_limitations()`\n+            let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n+                                  ty::empty_builtin_bounds());\n+            ty::mk_uniq(tcx, tr)\n         }\n         ast::SelfRegion(..) | ast::SelfUniq => {\n             let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n@@ -1225,14 +1227,7 @@ impl<'a> LookupContext<'a> {\n                      through an object\");\n             }\n \n-            ast::SelfValue => { // reason (a) above\n-                self.tcx().sess.span_err(\n-                    self.span,\n-                    \"cannot call a method with a by-value receiver \\\n-                     through an object\");\n-            }\n-\n-            ast::SelfRegion(..) | ast::SelfUniq => {}\n+            ast::SelfValue | ast::SelfRegion(..) | ast::SelfUniq => {}\n         }\n \n         // reason (a) above\n@@ -1302,7 +1297,26 @@ impl<'a> LookupContext<'a> {\n             }\n \n             SelfValue => {\n-                rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n+                debug!(\"(is relevant?) explicit self is by-value\");\n+                match ty::get(rcvr_ty).sty {\n+                    ty::ty_uniq(typ) => {\n+                        match ty::get(typ).sty {\n+                            ty::ty_trait(box ty::TyTrait {\n+                                def_id: self_did,\n+                                ..\n+                            }) => {\n+                                rcvr_matches_object(self_did, candidate) ||\n+                                    rcvr_matches_ty(self.fcx,\n+                                                    rcvr_ty,\n+                                                    candidate)\n+                            }\n+                            _ => {\n+                                rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n+                            }\n+                        }\n+                    }\n+                    _ => rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n+                }\n             }\n \n             SelfRegion(_, m) => {"}, {"sha": "74889263cc8a2a2c7c05f8dc990f0bd81da5357e", "filename": "src/test/run-fail/by-value-self-objects-fail.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fby-value-self-objects-fail.rs?ref=5cef1243a21c162cb9968f9bc14d1a23ba88426e", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:explicit failure\n+\n+trait Foo {\n+    fn foo(self, x: int);\n+}\n+\n+struct S {\n+    x: int,\n+    y: int,\n+    z: int,\n+    s: String,\n+}\n+\n+impl Foo for S {\n+    fn foo(self, x: int) {\n+        fail!()\n+    }\n+}\n+\n+impl Drop for S {\n+    fn drop(&mut self) {\n+        println!(\"bye 1!\");\n+    }\n+}\n+\n+fn f() {\n+    let s = S {\n+        x: 2,\n+        y: 3,\n+        z: 4,\n+        s: \"hello\".to_string(),\n+    };\n+    let st = box s as Box<Foo>;\n+    st.foo(5);\n+}\n+\n+fn main() {\n+    f();\n+}\n+\n+"}, {"sha": "3a588367a9709a4f074a151d6d623d05f74fbc41", "filename": "src/test/run-pass/by-value-self-objects.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Ftest%2Frun-pass%2Fby-value-self-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cef1243a21c162cb9968f9bc14d1a23ba88426e/src%2Ftest%2Frun-pass%2Fby-value-self-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fby-value-self-objects.rs?ref=5cef1243a21c162cb9968f9bc14d1a23ba88426e", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut destructor_count: uint = 0;\n+\n+trait Foo {\n+    fn foo(self, x: int);\n+}\n+\n+struct S {\n+    x: int,\n+    y: int,\n+    z: int,\n+    s: String,\n+}\n+\n+impl Foo for S {\n+    fn foo(self, x: int) {\n+        assert!(self.x == 2);\n+        assert!(self.y == 3);\n+        assert!(self.z == 4);\n+        assert!(self.s.as_slice() == \"hello\");\n+        assert!(x == 5);\n+    }\n+}\n+\n+impl Drop for S {\n+    fn drop(&mut self) {\n+        println!(\"bye 1!\");\n+        unsafe {\n+            destructor_count += 1;\n+        }\n+    }\n+}\n+\n+impl Foo for int {\n+    fn foo(self, x: int) {\n+        println!(\"{}\", x * x);\n+    }\n+}\n+\n+fn f() {\n+    let s = S {\n+        x: 2,\n+        y: 3,\n+        z: 4,\n+        s: \"hello\".to_string(),\n+    };\n+    let st = box s as Box<Foo>;\n+    st.foo(5);\n+    println!(\"bye 2!\");\n+}\n+\n+fn g() {\n+    let s = 2i;\n+    let st = box s as Box<Foo>;\n+    st.foo(3);\n+    println!(\"bye 3!\");\n+}\n+\n+fn main() {\n+    f();\n+\n+    unsafe {\n+        assert!(destructor_count == 1);\n+    }\n+\n+    g();\n+}\n+"}]}