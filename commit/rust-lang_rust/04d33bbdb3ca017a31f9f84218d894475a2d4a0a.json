{"sha": "04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZDMzYmJkYjNjYTAxN2EzMWY5Zjg0MjE4ZDg5NDQ3NWEyZDRhMGE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-07T23:38:31Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:03:02Z"}, "message": "Refactor generic argument count check in check/mod.rs", "tree": {"sha": "338ca06f3765e9ff1f8d49accbf091fe7714bd6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/338ca06f3765e9ff1f8d49accbf091fe7714bd6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "html_url": "https://github.com/rust-lang/rust/commit/04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68b0e7dd99ff374adf1babc481e415bad133cba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/68b0e7dd99ff374adf1babc481e415bad133cba7", "html_url": "https://github.com/rust-lang/rust/commit/68b0e7dd99ff374adf1babc481e415bad133cba7"}], "stats": {"total": 228, "additions": 65, "deletions": 163}, "files": [{"sha": "3cd435e756e485d541dbd80a8fd679dbdfeda922", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -90,6 +90,11 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n+pub struct GenericArgMismatchErrorCode {\n+    pub lifetimes: (&'static str, &'static str),\n+    pub types: (&'static str, &'static str),\n+}\n+\n /// Dummy type used for the `Self` of a `TraitRef` created for converting\n /// a trait object, and which gets removed in `ExistentialTraitRef`.\n /// This type must not appear anywhere in other converted types.\n@@ -199,6 +204,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         is_method_call: bool,\n         has_self: bool,\n         infer_types: bool,\n+        error_codes: GenericArgMismatchErrorCode,\n     ) -> bool {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n@@ -243,8 +249,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             }\n         }\n \n-        let check_kind_count = |error_code_less: &str,\n-                                error_code_more: &str,\n+        let check_kind_count = |error_code: (&str, &str),\n                                 kind,\n                                 required,\n                                 permitted,\n@@ -296,9 +301,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 ),\n                 DiagnosticId::Error({\n                     if provided <= permitted {\n-                        error_code_less\n+                        error_code.0\n                     } else {\n-                        error_code_more\n+                        error_code.1\n                     }\n                 }.into())\n             ).span_label(span, label).emit();\n@@ -308,8 +313,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n         if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n             check_kind_count(\n-                \"E0107\",\n-                \"E0107\",\n+                error_codes.lifetimes,\n                 \"lifetime\",\n                 param_counts.lifetimes,\n                 param_counts.lifetimes,\n@@ -319,8 +323,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         if !infer_types\n             || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n             check_kind_count(\n-                \"E0243\",\n-                \"E0244\", // FIXME: E0243 and E0244 should be unified.\n+                error_codes.types,\n                 \"type\",\n                 param_counts.types - defaults.types - has_self as usize,\n                 param_counts.types - has_self as usize,\n@@ -508,6 +511,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             false, // `is_method_call` (irrelevant here)\n             has_self,\n             infer_types,\n+            GenericArgMismatchErrorCode {\n+                lifetimes: (\"E0107\", \"E0107\"),\n+                types: (\"E0243\", \"E0244\"), // FIXME: E0243 and E0244 should be unified.\n+            },\n         );\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);"}, {"sha": "88c540915af00b2d602da7599deaac279c6bc684", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -10,7 +10,7 @@\n \n use super::{probe, MethodCallee};\n \n-use astconv::AstConv;\n+use astconv::{AstConv, GenericArgMismatchErrorCode};\n use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::GenericArg;\n use hir::def_id::DefId;\n@@ -329,9 +329,11 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             true, // `is_method_call`\n             method_generics.parent.is_none() && method_generics.has_self,\n             segment.infer_types || suppress_mismatch,\n+            GenericArgMismatchErrorCode {\n+                lifetimes: (\"E0090\", \"E0088\"),\n+                types: (\"E0089\", \"E0087\"),\n+            },\n         );\n-        // self.fcx.check_generic_arg_count(self.span, &segment, &method_generics, true,\n-                                        //  supress_mismatch);\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method."}, {"sha": "17adfda0bac0e7cf4fb7b42758c2a31d09756d12", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 128, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -84,9 +84,10 @@ pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n-use astconv::AstConv;\n+use astconv::{AstConv, GenericArgMismatchErrorCode};\n use hir::GenericArg;\n use hir::def::Def;\n+use hir::HirVec;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n use namespace::Namespace;\n@@ -4937,16 +4938,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n \n-        let mut supress_errors = FxHashMap();\n+        let mut suppress_errors = FxHashMap();\n         for &PathSeg(def_id, index) in &path_segs {\n             let seg = &segments[index];\n             let generics = self.tcx.generics_of(def_id);\n             // `impl Trait` is treated as a normal generic parameter internally,\n             // but we don't allow users to specify the parameter's value\n             // explicitly, so we have to do some error-checking here.\n-            let supress_mismatch = self.check_impl_trait(span, seg, &generics);\n-            supress_errors.insert(index,\n-                self.check_generic_arg_count(span, seg, &generics, false, supress_mismatch));\n+            let suppress_mismatch = self.check_impl_trait(span, seg, &generics);\n+            suppress_errors.insert(index, AstConv::check_generic_arg_count(\n+                self.tcx,\n+                span,\n+                &generics,\n+                &seg.args.clone().unwrap_or_else(|| P(hir::GenericArgs {\n+                    args: HirVec::new(), bindings: HirVec::new(), parenthesized: false,\n+                })),\n+                false, // `is_declaration`\n+                false, // `is_method_call`\n+                generics.parent.is_none() && generics.has_self,\n+                seg.infer_types || suppress_mismatch,\n+                GenericArgMismatchErrorCode {\n+                    lifetimes: (\"E0090\", \"E0088\"), // FIXME: E0090 and E0088 should be unified.\n+                    types: (\"E0089\", \"E0087\"), // FIXME: E0089 and E0087 should be unified.\n+                },\n+            ));\n         }\n \n         let has_self = path_segs.last().map(|PathSeg(def_id, _)| {\n@@ -4968,7 +4983,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }) {\n                     // If we've encountered an `impl Trait`-related error, we're just\n                     // going to infer the arguments for better error messages.\n-                    if !supress_errors[&index] {\n+                    if !suppress_errors[&index] {\n                         // Check whether the user has provided generic arguments.\n                         if let Some(ref data) = segments[index].args {\n                             return (Some(data), segments[index].infer_types);\n@@ -5097,128 +5112,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       directly, not through a function pointer\");\n     }\n \n-    /// Report errors if the provided parameters are too few or too many.\n-    fn check_generic_arg_count(&self,\n-                               span: Span,\n-                               segment: &hir::PathSegment,\n-                               generics: &ty::Generics,\n-                               is_method_call: bool,\n-                               supress_mismatch_error: bool)\n-                               -> bool {\n-        let mut supress_errors = false;\n-        let (mut lifetimes, mut types) = (vec![], vec![]);\n-        let infer_types = segment.infer_types;\n-        let mut bindings = vec![];\n-        if let Some(ref data) = segment.args {\n-            data.args.iter().for_each(|arg| match arg {\n-                GenericArg::Lifetime(lt) => lifetimes.push(lt.clone()),\n-                GenericArg::Type(ty) => types.push(ty.clone()),\n-            });\n-            bindings = data.bindings.clone().to_vec();\n-        }\n-\n-        struct ParamRange {\n-            required: usize,\n-            accepted: usize\n-        };\n-\n-        let mut lt_accepted = 0;\n-        let mut ty_params = ParamRange { required: 0, accepted: 0 };\n-        for param in &generics.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => lt_accepted += 1,\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    ty_params.accepted += 1;\n-                    if !has_default {\n-                        ty_params.required += 1;\n-                    }\n-                }\n-            };\n-        }\n-        if generics.parent.is_none() && generics.has_self {\n-            ty_params.required -= 1;\n-            ty_params.accepted -= 1;\n-        }\n-        let ty_accepted = ty_params.accepted;\n-        let ty_required = ty_params.required;\n-\n-        let count_ty_params = |n| format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" });\n-        let expected_text = count_ty_params(ty_accepted);\n-        let actual_text = count_ty_params(types.len());\n-        if let Some((mut err, span)) = if types.len() > ty_accepted {\n-            // To prevent derived errors to accumulate due to extra\n-            // type parameters, we force instantiate_value_path to\n-            // use inference variables instead of the provided types.\n-            supress_errors = true;\n-            let span = types[ty_accepted].span;\n-            Some((struct_span_err!(self.tcx.sess, span, E0087,\n-                                  \"too many type parameters provided: \\\n-                                  expected at most {}, found {}\",\n-                                  expected_text, actual_text), span))\n-        } else if types.len() < ty_required && !infer_types && !supress_mismatch_error {\n-            Some((struct_span_err!(self.tcx.sess, span, E0089,\n-                                  \"too few type parameters provided: \\\n-                                  expected {}, found {}\",\n-                                  expected_text, actual_text), span))\n-        } else {\n-            None\n-        } {\n-            self.set_tainted_by_errors(); // #53251\n-            err.span_label(span, format!(\"expected {}\", expected_text)).emit();\n-        }\n-\n-        if !bindings.is_empty() {\n-            AstConv::prohibit_assoc_ty_binding(self.tcx, bindings[0].span);\n-        }\n-\n-        let infer_lifetimes = lifetimes.len() == 0;\n-        // Prohibit explicit lifetime arguments if late bound lifetime parameters are present.\n-        let has_late_bound_lifetime_defs = generics.has_late_bound_regions;\n-        if let (Some(span_late), false) = (has_late_bound_lifetime_defs, lifetimes.is_empty()) {\n-            // Report this as a lint only if no error was reported previously.\n-            let primary_msg = \"cannot specify lifetime arguments explicitly \\\n-                               if late bound lifetime parameters are present\";\n-            let note_msg = \"the late bound lifetime parameter is introduced here\";\n-            if !is_method_call && (lifetimes.len() > lt_accepted ||\n-                                   lifetimes.len() < lt_accepted && !infer_lifetimes) {\n-                supress_errors = true;\n-                let mut err = self.tcx.sess.struct_span_err(lifetimes[0].span, primary_msg);\n-                err.span_note(span_late, note_msg);\n-                err.emit();\n-            } else {\n-                let mut multispan = MultiSpan::from_span(lifetimes[0].span);\n-                multispan.push_span_label(span_late, note_msg.to_string());\n-                self.tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n-                                   lifetimes[0].id, multispan, primary_msg);\n-            }\n-            return supress_errors;\n-        }\n-\n-        let count_lifetime_params = |n| {\n-            format!(\"{} lifetime parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n-        };\n-        let expected_text = count_lifetime_params(lt_accepted);\n-        let actual_text = count_lifetime_params(lifetimes.len());\n-        if let Some((mut err, span)) = if lifetimes.len() > lt_accepted {\n-            let span = lifetimes[lt_accepted].span;\n-            Some((struct_span_err!(self.tcx.sess, span, E0088,\n-                                  \"too many lifetime parameters provided: \\\n-                                  expected at most {}, found {}\",\n-                                  expected_text, actual_text), span))\n-        } else if lifetimes.len() < lt_accepted && !infer_lifetimes {\n-            Some((struct_span_err!(self.tcx.sess, span, E0090,\n-                                  \"too few lifetime parameters provided: \\\n-                                  expected {}, found {}\",\n-                                  expected_text, actual_text), span))\n-        } else {\n-            None\n-        } {\n-            err.span_label(span, format!(\"expected {}\", expected_text)).emit();\n-        }\n-\n-        supress_errors\n-    }\n-\n     /// Report error if there is an explicit type parameter when using `impl Trait`.\n     fn check_impl_trait(&self,\n                         span: Span,"}, {"sha": "bea76f34220ef7dfa324c5785f21f312b0eb8256", "filename": "src/test/ui/error-codes/E0087.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0087.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0087.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0087.rs?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -12,7 +12,7 @@ fn foo() {}\n fn bar<T>() {}\n \n fn main() {\n-    foo::<f64>(); //~ ERROR expected at most 0 type parameters, found 1 type parameter [E0087]\n+    foo::<f64>(); //~ ERROR wrong number of type arguments: expected 0, found 1 [E0087]\n \n-    bar::<f64, u64>(); //~ ERROR expected at most 1 type parameter, found 2 type parameters [E0087]\n+    bar::<f64, u64>(); //~ ERROR wrong number of type arguments: expected 1, found 2 [E0087]\n }"}, {"sha": "7170a6f2cda129523dbaf5a5d6812eddc72fd0f8", "filename": "src/test/ui/error-codes/E0087.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0087.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0087.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0087.stderr?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -1,14 +1,14 @@\n-error[E0087]: too many type parameters provided: expected at most 0 type parameters, found 1 type parameter\n-  --> $DIR/E0087.rs:15:11\n+error[E0087]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/E0087.rs:15:5\n    |\n-LL |     foo::<f64>(); //~ ERROR expected at most 0 type parameters, found 1 type parameter [E0087]\n-   |           ^^^ expected 0 type parameters\n+LL |     foo::<f64>(); //~ ERROR wrong number of type arguments: expected 0, found 1 [E0087]\n+   |     ^^^^^^^^^^ unexpected type argument\n \n-error[E0087]: too many type parameters provided: expected at most 1 type parameter, found 2 type parameters\n-  --> $DIR/E0087.rs:17:16\n+error[E0087]: wrong number of type arguments: expected 1, found 2\n+  --> $DIR/E0087.rs:17:5\n    |\n-LL |     bar::<f64, u64>(); //~ ERROR expected at most 1 type parameter, found 2 type parameters [E0087]\n-   |                ^^^ expected 1 type parameter\n+LL |     bar::<f64, u64>(); //~ ERROR wrong number of type arguments: expected 1, found 2 [E0087]\n+   |     ^^^^^^^^^^^^^^^ unexpected type argument\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4666702e1ebf3dc9c588b3e77f430b7312f8ca50", "filename": "src/test/ui/error-codes/E0088.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0088.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0088.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0088.stderr?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -1,14 +1,14 @@\n-error[E0088]: too many lifetime parameters provided: expected at most 0 lifetime parameters, found 1 lifetime parameter\n-  --> $DIR/E0088.rs:15:9\n+error[E0088]: wrong number of lifetime arguments: expected 0, found 1\n+  --> $DIR/E0088.rs:15:5\n    |\n LL |     f::<'static>(); //~ ERROR E0088\n-   |         ^^^^^^^ expected 0 lifetime parameters\n+   |     ^^^^^^^^^^^^ unexpected lifetime argument\n \n-error[E0088]: too many lifetime parameters provided: expected at most 1 lifetime parameter, found 2 lifetime parameters\n-  --> $DIR/E0088.rs:16:18\n+error[E0088]: wrong number of lifetime arguments: expected 1, found 2\n+  --> $DIR/E0088.rs:16:5\n    |\n LL |     g::<'static, 'static>(); //~ ERROR E0088\n-   |                  ^^^^^^^ expected 1 lifetime parameter\n+   |     ^^^^^^^^^^^^^^^^^^^^^ unexpected lifetime argument\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4e6196a7b89dbce7ea1a518f618418c87e0bb021", "filename": "src/test/ui/error-codes/E0089.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0089.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0089.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0089.rs?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -11,5 +11,5 @@\n fn foo<T, U>() {}\n \n fn main() {\n-    foo::<f64>(); //~ ERROR expected 2 type parameters, found 1 type parameter [E0089]\n+    foo::<f64>(); //~ ERROR wrong number of type arguments: expected 2, found 1 [E0089]\n }"}, {"sha": "f79c478b733f6d780873263ecba85eceaffb126b", "filename": "src/test/ui/error-codes/E0089.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0089.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0089.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0089.stderr?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -1,8 +1,8 @@\n-error[E0089]: too few type parameters provided: expected 2 type parameters, found 1 type parameter\n+error[E0089]: wrong number of type arguments: expected 2, found 1\n   --> $DIR/E0089.rs:14:5\n    |\n-LL |     foo::<f64>(); //~ ERROR expected 2 type parameters, found 1 type parameter [E0089]\n-   |     ^^^^^^^^^^ expected 2 type parameters\n+LL |     foo::<f64>(); //~ ERROR wrong number of type arguments: expected 2, found 1 [E0089]\n+   |     ^^^^^^^^^^ expected 2 type arguments\n \n error: aborting due to previous error\n "}, {"sha": "26be4c12f075e4088610de44784e6e9da6454d46", "filename": "src/test/ui/error-codes/E0090.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0090.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0090.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0090.rs?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -11,5 +11,5 @@\n fn foo<'a: 'b, 'b: 'a>() {}\n \n fn main() {\n-    foo::<'static>(); //~ ERROR expected 2 lifetime parameters, found 1 lifetime parameter [E0090]\n+    foo::<'static>(); //~ ERROR wrong number of lifetime arguments: expected 2, found 1 [E0090]\n }"}, {"sha": "9029b6c2708bd3d6fe6c9443ce25721cb29923d4", "filename": "src/test/ui/error-codes/E0090.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0090.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04d33bbdb3ca017a31f9f84218d894475a2d4a0a/src%2Ftest%2Fui%2Ferror-codes%2FE0090.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0090.stderr?ref=04d33bbdb3ca017a31f9f84218d894475a2d4a0a", "patch": "@@ -1,8 +1,8 @@\n-error[E0090]: too few lifetime parameters provided: expected 2 lifetime parameters, found 1 lifetime parameter\n+error[E0090]: wrong number of lifetime arguments: expected 2, found 1\n   --> $DIR/E0090.rs:14:5\n    |\n-LL |     foo::<'static>(); //~ ERROR expected 2 lifetime parameters, found 1 lifetime parameter [E0090]\n-   |     ^^^^^^^^^^^^^^ expected 2 lifetime parameters\n+LL |     foo::<'static>(); //~ ERROR wrong number of lifetime arguments: expected 2, found 1 [E0090]\n+   |     ^^^^^^^^^^^^^^ expected 2 lifetime arguments\n \n error: aborting due to previous error\n "}]}