{"sha": "5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMjgyZWMyNmZjNzU4N2I5NGUwZDg2YTAwM2FiY2YxY2ZkMjE0YzE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-27T04:05:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-29T05:50:09Z"}, "message": "core: Convert some records to structs", "tree": {"sha": "61bb48bf508ab3f8be705ec907577992b686076d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61bb48bf508ab3f8be705ec907577992b686076d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "html_url": "https://github.com/rust-lang/rust/commit/5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a2a375fbfb02abdf51e598660c44dda6032d282", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a2a375fbfb02abdf51e598660c44dda6032d282", "html_url": "https://github.com/rust-lang/rust/commit/4a2a375fbfb02abdf51e598660c44dda6032d282"}], "stats": {"total": 164, "additions": 85, "deletions": 79}, "files": [{"sha": "44cdb40c3aacbb55b79746d7061e5585be1d9f0d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -339,22 +339,22 @@ fn scan_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let {ch, next} = str::char_range_at(haystack, *idx);\n-    if ch != needle {\n+    let range = str::char_range_at(haystack, *idx);\n+    if range.ch != needle {\n         return false;\n     }\n-    *idx = next;\n+    *idx = range.next;\n     return true;\n }\n \n fn scan_integer(haystack: ~str, idx: &mut uint) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n-        let {ch, next} = str::char_range_at(haystack, i);\n-        if ch < '0' || '9' < ch {\n+        let range = str::char_range_at(haystack, i);\n+        if range.ch < '0' || '9' < range.ch {\n             break;\n         }\n-        i = next;\n+        i = range.next;\n     }\n     if i == *idx {\n         return false;\n@@ -370,9 +370,9 @@ fn scan_string(haystack: ~str, needle: ~str, idx: &mut uint) -> bool {\n         if haystack_i >= haystack.len() {\n             return false;\n         }\n-        let {ch, next} = str::char_range_at(haystack, haystack_i);\n-        haystack_i = next;\n-        if !scan_char(needle, ch, &mut needle_i) {\n+        let range = str::char_range_at(haystack, haystack_i);\n+        haystack_i = range.next;\n+        if !scan_char(needle, range.ch, &mut needle_i) {\n             return false;\n         }\n     }"}, {"sha": "c885d241659d00487a02b33f58ba5167307ed23c", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -47,32 +47,28 @@ use ptr::null;\n  * pointers achieved about 103 million pushes/second.  Using an option\n  * type could only produce 47 million pushes/second.\n  */\n-type DVec_<A> = {\n+pub struct DVec<A> {\n     mut data: ~[A]\n-};\n-\n-pub enum DVec<A> {\n-    DVec_(DVec_<A>)\n }\n \n /// Creates a new, empty dvec\n pub pure fn DVec<A>() -> DVec<A> {\n-    DVec_({mut data: ~[]})\n+    DVec {mut data: ~[]}\n }\n \n /// Creates a new dvec with a single element\n pub fn from_elem<A>(e: A) -> DVec<A> {\n-    DVec_({mut data: ~[move e]})\n+    DVec {mut data: ~[move e]}\n }\n \n /// Creates a new dvec with the contents of a vector\n pub fn from_vec<A>(v: ~[A]) -> DVec<A> {\n-    DVec_({mut data: move v})\n+    DVec {mut data: move v}\n }\n \n /// Consumes the vector and returns its contents\n pub fn unwrap<A>(d: DVec<A>) -> ~[A] {\n-    let DVec_({data: v}) = move d;\n+    let DVec {data: v} = move d;\n     move v\n }\n "}, {"sha": "124213bd3033888ecd4d32caa4d43d1889ea6eb4", "filename": "src/libcore/either.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -57,7 +57,7 @@ pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n \n // XXX bad copies. take arg by val\n pub fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n-    -> {lefts: ~[T], rights: ~[U]} {\n+    -> (~[T], ~[U]) {\n     /*!\n      * Extracts from a vector of either all the left values and right values\n      *\n@@ -73,7 +73,7 @@ pub fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n           Right(copy r) => rights.push(r)\n         }\n     }\n-    return {lefts: move lefts, rights: move rights};\n+    return (move lefts, move rights);\n }\n \n // XXX bad copies\n@@ -212,36 +212,36 @@ fn test_rights_empty() {\n #[test]\n fn test_partition() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-    let result = partition(input);\n-    assert (result.lefts[0] == 10);\n-    assert (result.lefts[1] == 12);\n-    assert (result.lefts[2] == 14);\n-    assert (result.rights[0] == 11);\n-    assert (result.rights[1] == 13);\n+    let (lefts, rights) = partition(input);\n+    assert (lefts[0] == 10);\n+    assert (lefts[1] == 12);\n+    assert (lefts[2] == 14);\n+    assert (rights[0] == 11);\n+    assert (rights[1] == 13);\n }\n \n #[test]\n fn test_partition_no_lefts() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n-    let result = partition(input);\n-    assert (vec::len(result.lefts) == 0u);\n-    assert (vec::len(result.rights) == 2u);\n+    let (lefts, rights) = partition(input);\n+    assert (vec::len(lefts) == 0u);\n+    assert (vec::len(rights) == 2u);\n }\n \n #[test]\n fn test_partition_no_rights() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n-    let result = partition(input);\n-    assert (vec::len(result.lefts) == 2u);\n-    assert (vec::len(result.rights) == 0u);\n+    let (lefts, rights) = partition(input);\n+    assert (vec::len(lefts) == 2u);\n+    assert (vec::len(rights) == 0u);\n }\n \n #[test]\n fn test_partition_empty() {\n     let input: ~[Either<int, int>] = ~[];\n-    let result = partition(input);\n-    assert (vec::len(result.lefts) == 0u);\n-    assert (vec::len(result.rights) == 0u);\n+    let (lefts, rights) = partition(input);\n+    assert (vec::len(lefts) == 0u);\n+    assert (vec::len(rights) == 0u);\n }\n \n //"}, {"sha": "2cbd1173a6eb690b14b4ce48edca7474f9548430", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -269,16 +269,16 @@ impl<T:Ord> &const T : Ord {\n #[test]\n pub fn test() {\n     unsafe {\n-        type Pair = {mut fst: int, mut snd: int};\n-        let p = {mut fst: 10, mut snd: 20};\n+        struct Pair {mut fst: int, mut snd: int};\n+        let p = Pair {mut fst: 10, mut snd: 20};\n         let pptr: *mut Pair = mut_addr_of(&p);\n         let iptr: *mut int = cast::reinterpret_cast(&pptr);\n         assert (*iptr == 10);;\n         *iptr = 30;\n         assert (*iptr == 30);\n         assert (p.fst == 30);;\n \n-        *pptr = {mut fst: 50, mut snd: 60};\n+        *pptr = Pair {mut fst: 50, mut snd: 60};\n         assert (*iptr == 50);\n         assert (p.fst == 50);\n         assert (p.snd == 60);"}, {"sha": "825d314d58e8f54b2ffa59c0cd2bb249e1532a6d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -224,8 +224,8 @@ Section: Adding to and removing from a string\n pub fn pop_char(s: &mut ~str) -> char {\n     let end = len(*s);\n     assert end > 0u;\n-    let {ch, prev} = char_range_at_reverse(*s, end);\n-    unsafe { raw::set_len(s, prev); }\n+    let CharRange {ch, next} = char_range_at_reverse(*s, end);\n+    unsafe { raw::set_len(s, next); }\n     return ch;\n }\n \n@@ -237,7 +237,7 @@ pub fn pop_char(s: &mut ~str) -> char {\n  * If the string does not contain any characters\n  */\n pub fn shift_char(s: &mut ~str) -> char {\n-    let {ch, next} = char_range_at(*s, 0u);\n+    let CharRange {ch, next} = char_range_at(*s, 0u);\n     *s = unsafe { raw::slice_bytes(*s, next, len(*s)) };\n     return ch;\n }\n@@ -253,7 +253,7 @@ pub fn shift_char(s: &mut ~str) -> char {\n  */\n #[inline]\n pub fn view_shift_char(s: &a/str) -> (char, &a/str) {\n-    let {ch, next} = char_range_at(s, 0u);\n+    let CharRange {ch, next} = char_range_at(s, 0u);\n     let next_s = unsafe { raw::view_bytes(s, next, len(s)) };\n     return (ch, next_s);\n }\n@@ -296,7 +296,7 @@ pub pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n     match rfind(s, |c| !chars_to_trim.contains(&c)) {\n       None => ~\"\",\n       Some(last) => {\n-        let {next, _} = char_range_at(s, last);\n+        let next = char_range_at(s, last).next;\n         unsafe { raw::slice_bytes(s, 0u, next) }\n       }\n     }\n@@ -328,7 +328,7 @@ pub pure fn trim_right(s: &str) -> ~str {\n     match rfind(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n       Some(last) => {\n-        let {next, _} = char_range_at(s, last);\n+        let next = char_range_at(s, last).next;\n         unsafe { raw::slice_bytes(s, 0u, next) }\n       }\n     }\n@@ -365,7 +365,7 @@ pub pure fn chars(s: &str) -> ~[char] {\n     let mut buf = ~[], i = 0;\n     let len = len(s);\n     while i < len {\n-        let {ch, next} = char_range_at(s, i);\n+        let CharRange {ch, next} = char_range_at(s, i);\n         unsafe { buf.push(ch); }\n         i = next;\n     }\n@@ -475,7 +475,7 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n     let l = len(s);\n     let mut result = ~[], i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n-        let {ch, next} = char_range_at(s, i);\n+        let CharRange {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i unsafe {\n                 result.push(unsafe { raw::slice_bytes(s, start, i)});\n@@ -866,7 +866,7 @@ pub pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n     let mut pos = 0u, ch_pos = 0u;\n     let len = len(s);\n     while pos < len {\n-        let {ch, next} = char_range_at(s, pos);\n+        let CharRange {ch, next} = char_range_at(s, pos);\n         pos = next;\n         if !it(ch_pos, ch) { break; }\n         ch_pos += 1u;\n@@ -878,7 +878,7 @@ pub pure fn chars_each(s: &str, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n-        let {ch, next} = char_range_at(s, pos);\n+        let CharRange {ch, next} = char_range_at(s, pos);\n         pos = next;\n         if !it(ch) { return; }\n     }\n@@ -1144,7 +1144,7 @@ pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     assert is_char_boundary(s, start);\n     let mut i = start;\n     while i < end {\n-        let {ch, next} = char_range_at(s, i);\n+        let CharRange {ch, next} = char_range_at(s, i);\n         if f(ch) { return Some(i); }\n         i = next;\n     }\n@@ -1224,7 +1224,7 @@ pub pure fn rfind_between(s: &str, start: uint, end: uint,\n     assert is_char_boundary(s, start);\n     let mut i = start;\n     while i > end {\n-        let {ch, prev} = char_range_at_reverse(s, i);\n+        let CharRange {ch, next: prev} = char_range_at_reverse(s, i);\n         if f(ch) { return Some(prev); }\n         i = prev;\n     }\n@@ -1538,7 +1538,7 @@ pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, end);\n     let mut i = start, len = 0u;\n     while i < end {\n-        let {next, _} = char_range_at(s, i);\n+        let next = char_range_at(s, i).next;\n         len += 1u;\n         i = next;\n     }\n@@ -1552,7 +1552,7 @@ pub pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n     let l = len(s);\n     while cnt > 0u {\n         assert end < l;\n-        let {next, _} = char_range_at(s, end);\n+        let next = char_range_at(s, end).next;\n         cnt -= 1u;\n         end = next;\n     }\n@@ -1595,7 +1595,7 @@ pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n  * let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n  * let i = 0u;\n  * while i < str::len(s) {\n- *     let {ch, next} = str::char_range_at(s, i);\n+ *     let CharRange {ch, next} = str::char_range_at(s, i);\n  *     std::io::println(fmt!(\"%u: %c\",i,ch));\n  *     i = next;\n  * }\n@@ -1631,11 +1631,11 @@ pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n  * If `i` is greater than or equal to the length of the string.\n  * If `i` is not the index of the beginning of a valid UTF-8 character.\n  */\n-pub pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n+pub pure fn char_range_at(s: &str, i: uint) -> CharRange {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n-    if w == 1u { return {ch: b0 as char, next: i + 1u}; }\n+    if w == 1u { return CharRange {ch: b0 as char, next: i + 1u}; }\n     let mut val = 0u;\n     let end = i + w;\n     let mut i = i + 1u;\n@@ -1650,21 +1650,26 @@ pub pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n     // the first to clip off the marker bits at the left of the byte, and then\n     // a second (as uint) to get it to the right position.\n     val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n-    return {ch: val as char, next: i};\n+    return CharRange {ch: val as char, next: i};\n }\n \n /// Pluck a character out of a string\n pub pure fn char_at(s: &str, i: uint) -> char {\n     return char_range_at(s, i).ch;\n }\n \n+pub struct CharRange {\n+    ch: char,\n+    next: uint\n+}\n+\n /**\n  * Given a byte position and a str, return the previous char and its position\n  *\n  * This function can be used to iterate over a unicode string in reverse.\n  */\n pure fn char_range_at_reverse(ss: &str, start: uint)\n-    -> {ch: char, prev: uint} {\n+    -> CharRange {\n \n     let mut prev = start;\n \n@@ -1677,7 +1682,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint)\n     prev -= 1u;\n \n     let ch = char_at(ss, prev);\n-    return {ch:ch, prev:prev};\n+    return CharRange {ch:ch, next:prev};\n }\n \n /**\n@@ -1707,7 +1712,7 @@ pub pure fn all_between(s: &str, start: uint, end: uint,\n     assert is_char_boundary(s, start);\n     let mut i = start;\n     while i < end {\n-        let {ch, next} = char_range_at(s, i);\n+        let CharRange {ch, next} = char_range_at(s, i);\n         if !it(ch) { return false; }\n         i = next;\n     }"}, {"sha": "f6040ef8d295c48a250847a02d81c988bc2b8cec", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -59,7 +59,7 @@ fn warn_if_multiple_versions(e: env, diag: span_handler,\n \n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(*crate_cache.last().metas);\n-        let {lefts: matches, rights: non_matches} =\n+        let (matches, non_matches) =\n             partition(crate_cache.map_to_vec(|entry| {\n                 let othername = loader::crate_name_from_metas(*entry.metas);\n                 if name == othername {"}, {"sha": "5aa19c4f7856c3310c110c461d47d8b2a3a71fb1", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -1206,9 +1206,11 @@ mod node {\n                     (*it).leaf = option::None;\n                     return option::None\n                 } else {\n-                    let {ch, next} =\n+                    let range =\n                         str::char_range_at(*aleaf.content,\n                                      (*it).leaf_byte_pos + aleaf.byte_offset);\n+                    let ch = range.ch;\n+                    let next = range.next;\n                     (*it).leaf_byte_pos = next - aleaf.byte_offset;\n                     return option::Some(ch)\n                 }\n@@ -1283,9 +1285,9 @@ mod tests {\n                     equal = false;\n                 } break; }\n               option::Some(c) => {\n-                let {ch, next} = str::char_range_at(*sample, string_iter);\n-                string_iter = next;\n-                if ch != c { equal = false; break; }\n+                let range = str::char_range_at(*sample, string_iter);\n+                string_iter = range.next;\n+                if range.ch != c { equal = false; break; }\n               }\n             }\n         }"}, {"sha": "3b8d2996146a5bd09212ee232d4bc732b37249fd", "filename": "src/libstd/time.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -277,12 +277,12 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n \n         let mut i = 0u;\n         while i < digits {\n-            let {ch, next} = str::char_range_at(str::from_slice(ss), pos);\n-            pos = next;\n+            let range = str::char_range_at(str::from_slice(ss), pos);\n+            pos = range.next;\n \n-            match ch {\n+            match range.ch {\n               '0' .. '9' => {\n-                value = value * 10_i32 + (ch as i32 - '0' as i32);\n+                value = value * 10_i32 + (range.ch as i32 - '0' as i32);\n               }\n               ' ' if ws => (),\n               _ => return None\n@@ -294,14 +294,14 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n \n     fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, ~str> {\n-        let {ch, next} = str::char_range_at(s, pos);\n+        let range = str::char_range_at(s, pos);\n \n-        if c == ch {\n-            Ok(next)\n+        if c == range.ch {\n+            Ok(range.next)\n         } else {\n             Err(fmt!(\"Expected %?, found %?\",\n                 str::from_char(c),\n-                str::from_char(ch)))\n+                str::from_char(range.ch)))\n         }\n     }\n \n@@ -619,19 +619,19 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 let mut pos = pos;\n                 let len = str::len(s);\n                 while pos < len {\n-                    let {ch, next} = str::char_range_at(s, pos);\n-                    pos = next;\n-                    if ch == ' ' { break; }\n+                    let range = str::char_range_at(s, pos);\n+                    pos = range.next;\n+                    if range.ch == ' ' { break; }\n                 }\n \n                 Ok(pos)\n             }\n           }\n           'z' => {\n-            let {ch, next} = str::char_range_at(s, pos);\n+            let range = str::char_range_at(s, pos);\n \n-            if ch == '+' || ch == '-' {\n-                match match_digits(s, next, 4u, false) {\n+            if range.ch == '+' || range.ch == '-' {\n+                match match_digits(s, range.next, 4u, false) {\n                   Some(item) => {\n                     let (v, pos) = item;\n                     if v == 0_i32 {\n@@ -674,7 +674,9 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         let mut result = Err(~\"Invalid time\");\n \n         while !rdr.eof() && pos < len {\n-            let {ch, next} = str::char_range_at(s, pos);\n+            let range = str::char_range_at(s, pos);\n+            let ch = range.ch;\n+            let next = range.next;\n \n             match rdr.read_char() {\n                 '%' => {"}, {"sha": "4ddd7be5272826d3f0caaa5fbdd0375ebdab7983", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a282ec26fc7587b94e0d86a003abcf1cfd214c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5a282ec26fc7587b94e0d86a003abcf1cfd214c1", "patch": "@@ -1773,6 +1773,7 @@ impl Parser {\n             fields.push(self.parse_field(token::COLON));\n         }\n         self.expect(token::RBRACE);\n+        //self.warn(~\"REC\");\n         return expr_rec(fields, base);\n     }\n "}]}