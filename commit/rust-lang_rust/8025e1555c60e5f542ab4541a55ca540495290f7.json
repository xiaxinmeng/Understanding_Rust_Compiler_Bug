{"sha": "8025e1555c60e5f542ab4541a55ca540495290f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMjVlMTU1NWM2MGU1ZjU0MmFiNDU0MWE1NWNhNTQwNDk1MjkwZjc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-01T07:33:32Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-01T17:29:40Z"}, "message": "Rollup merge of #48572 - alexcrichton:noexcept-msvc2, r=eddyb\n\nrustc: Tweak funclet cleanups of ffi functions\n\nThis commit is targeted at addressing #48251 by specifically fixing a case where\na longjmp over Rust frames on MSVC runs cleanups, accidentally running the\n\"abort the program\" cleanup as well. Added in #46833 `extern` ABI functions in\nRust will abort the process if Rust panics, and currently this is modeled as a\nnormal cleanup like all other destructors.\n\nUnfortunately it turns out that `longjmp` on MSVC is implemented with SEH, the\nsame mechanism used to implement panics in Rust. This means that `longjmp` over\nRust frames will run Rust cleanups (even though we don't necessarily want it\nto). Notably this means that if you `longjmp` over a Rust stack frame then that\nprobably means you'll abort the program because one of the cleanups will abort\nthe process.\n\nAfter some discussion on IRC it turns out that `longjmp` doesn't run cleanups\nfor *caught* exceptions, it only runs cleanups for cleanup pads. Using this\ninformation this commit tweaks the codegen for an `extern` function to\na catch-all clause for exceptions instead of a cleanup block. This catch-all is\nequivalent to the C++ code:\n\n    try {\n        foo();\n    } catch (...) {\n        bar();\n    }\n\nand in fact our codegen here is designed to match exactly what clang emits for\nthat C++ code!\n\nWith this tweak a longjmp over Rust code will no longer abort the process. A\nlongjmp will continue to \"accidentally\" run Rust cleanups (destructors) on MSVC.\nOther non-MSVC platforms will not rust destructors with a longjmp, so we'll\nprobably still recommend \"don't have destructors on the stack\", but in any case\nthis is a more surgical fix than #48567 and should help us stick to standard\npersonality functions a bit longer.", "tree": {"sha": "6515e08e83f88d5e59a7211d12b97425b4640907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6515e08e83f88d5e59a7211d12b97425b4640907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8025e1555c60e5f542ab4541a55ca540495290f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8025e1555c60e5f542ab4541a55ca540495290f7", "html_url": "https://github.com/rust-lang/rust/commit/8025e1555c60e5f542ab4541a55ca540495290f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8025e1555c60e5f542ab4541a55ca540495290f7/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b8c103912f1d5a38d4f4ecb2564a0010444902", "url": "https://api.github.com/repos/rust-lang/rust/commits/75b8c103912f1d5a38d4f4ecb2564a0010444902", "html_url": "https://github.com/rust-lang/rust/commit/75b8c103912f1d5a38d4f4ecb2564a0010444902"}, {"sha": "804666f4ad5a66e6a1bae3b2e326efa030135a05", "url": "https://api.github.com/repos/rust-lang/rust/commits/804666f4ad5a66e6a1bae3b2e326efa030135a05", "html_url": "https://github.com/rust-lang/rust/commit/804666f4ad5a66e6a1bae3b2e326efa030135a05"}], "stats": {"total": 133, "additions": 127, "deletions": 6}, "files": [{"sha": "99e3a59e2c4f42c8dfa08491446aad33e0aa0269", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8025e1555c60e5f542ab4541a55ca540495290f7/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8025e1555c60e5f542ab4541a55ca540495290f7/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=8025e1555c60e5f542ab4541a55ca540495290f7", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use common::{C_i32, C_null};\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n@@ -23,6 +24,7 @@ use common::{CodegenCx, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n use abi::{ArgAttribute, FnType, PassMode};\n+use type_::Type;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -222,7 +224,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n     // Compute debuginfo scopes from MIR scopes.\n     let scopes = debuginfo::create_mir_scopes(cx, mir, &debug_context);\n-    let (landing_pads, funclets) = create_funclets(&bx, &cleanup_kinds, &block_bxs);\n+    let (landing_pads, funclets) = create_funclets(mir, &bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n         mir,\n@@ -333,6 +335,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n }\n \n fn create_funclets<'a, 'tcx>(\n+    mir: &'a Mir<'tcx>,\n     bx: &Builder<'a, 'tcx>,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n     block_bxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n@@ -341,14 +344,59 @@ fn create_funclets<'a, 'tcx>(\n {\n     block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n         match *cleanup_kind {\n-            CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {\n+            CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}\n+            _ => return (None, None)\n+        }\n+\n+        let cleanup;\n+        let ret_llbb;\n+        match mir[bb].terminator.as_ref().map(|t| &t.kind) {\n+            // This is a basic block that we're aborting the program for,\n+            // notably in an `extern` function. These basic blocks are inserted\n+            // so that we assert that `extern` functions do indeed not panic,\n+            // and if they do we abort the process.\n+            //\n+            // On MSVC these are tricky though (where we're doing funclets). If\n+            // we were to do a cleanuppad (like below) the normal functions like\n+            // `longjmp` would trigger the abort logic, terminating the\n+            // program. Instead we insert the equivalent of `catch(...)` for C++\n+            // which magically doesn't trigger when `longjmp` files over this\n+            // frame.\n+            //\n+            // Lots more discussion can be found on #48251 but this codegen is\n+            // modeled after clang's for:\n+            //\n+            //      try {\n+            //          foo();\n+            //      } catch (...) {\n+            //          bar();\n+            //      }\n+            Some(&mir::TerminatorKind::Abort) => {\n+                let cs_bx = bx.build_sibling_block(&format!(\"cs_funclet{:?}\", bb));\n+                let cp_bx = bx.build_sibling_block(&format!(\"cp_funclet{:?}\", bb));\n+                ret_llbb = cs_bx.llbb();\n+\n+                let cs = cs_bx.catch_switch(None, None, 1);\n+                cs_bx.add_handler(cs, cp_bx.llbb());\n+\n+                // The \"null\" here is actually a RTTI type descriptor for the\n+                // C++ personality function, but `catch (...)` has no type so\n+                // it's null. The 64 here is actually a bitfield which\n+                // represents that this is a catch-all block.\n+                let null = C_null(Type::i8p(bx.cx));\n+                let sixty_four = C_i32(bx.cx, 64);\n+                cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n+                cp_bx.br(llbb);\n+            }\n+            _ => {\n                 let cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n-                let cleanup = cleanup_bx.cleanup_pad(None, &[]);\n+                ret_llbb = cleanup_bx.llbb();\n+                cleanup = cleanup_bx.cleanup_pad(None, &[]);\n                 cleanup_bx.br(llbb);\n-                (Some(cleanup_bx.llbb()), Some(Funclet::new(cleanup)))\n             }\n-            _ => (None, None)\n-        }\n+        };\n+\n+        (Some(ret_llbb), Some(Funclet::new(cleanup)))\n     }).unzip()\n }\n "}, {"sha": "9d71ed8fcf3ab6223d4c9b2cbbb82298f6ca39df", "filename": "src/test/run-make/longjmp-across-rust/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8025e1555c60e5f542ab4541a55ca540495290f7/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8025e1555c60e5f542ab4541a55ca540495290f7/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2FMakefile?ref=8025e1555c60e5f542ab4541a55ca540495290f7", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all: $(call NATIVE_STATICLIB,foo)\n+\t$(RUSTC) main.rs\n+\t$(call RUN,main)"}, {"sha": "eb9939576741bad7c11d008b190fd2bf246b973b", "filename": "src/test/run-make/longjmp-across-rust/foo.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8025e1555c60e5f542ab4541a55ca540495290f7/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/8025e1555c60e5f542ab4541a55ca540495290f7/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Ffoo.c?ref=8025e1555c60e5f542ab4541a55ca540495290f7", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <assert.h>\n+#include <setjmp.h>\n+\n+static jmp_buf ENV;\n+\n+extern void test_middle();\n+\n+void test_start(void(*f)()) {\n+  if (setjmp(ENV) != 0)\n+    return;\n+  f();\n+  assert(0);\n+}\n+\n+void test_end() {\n+  longjmp(ENV, 1);\n+  assert(0);\n+}"}, {"sha": "c420473a560eb2a340414a750b7d4c75155034fe", "filename": "src/test/run-make/longjmp-across-rust/main.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8025e1555c60e5f542ab4541a55ca540495290f7/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8025e1555c60e5f542ab4541a55ca540495290f7/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Fmain.rs?ref=8025e1555c60e5f542ab4541a55ca540495290f7", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[link(name = \"foo\", kind = \"static\")]\n+extern {\n+    fn test_start(f: extern fn());\n+    fn test_end();\n+}\n+\n+fn main() {\n+    unsafe {\n+        test_start(test_middle);\n+    }\n+}\n+\n+struct A;\n+\n+impl Drop for A {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+extern fn test_middle() {\n+    let _a = A;\n+    foo();\n+}\n+\n+fn foo() {\n+    let _a = A;\n+    unsafe {\n+        test_end();\n+    }\n+}"}]}