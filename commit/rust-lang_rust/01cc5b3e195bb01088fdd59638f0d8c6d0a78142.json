{"sha": "01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxY2M1YjNlMTk1YmIwMTA4OGZkZDU5NjM4ZjBkOGM2ZDBhNzgxNDI=", "commit": {"author": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-03-13T15:46:55Z"}, "committer": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-03-13T15:47:48Z"}, "message": "add intrinsics for portable packed simd vector reductions", "tree": {"sha": "417854020d43543e214bd8695a29114537fdae12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/417854020d43543e214bd8695a29114537fdae12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "html_url": "https://github.com/rust-lang/rust/commit/01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/comments", "author": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5acb0c8f69d615b46c8e3eed4c84c3abd6fd0cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5acb0c8f69d615b46c8e3eed4c84c3abd6fd0cd", "html_url": "https://github.com/rust-lang/rust/commit/e5acb0c8f69d615b46c8e3eed4c84c3abd6fd0cd"}], "stats": {"total": 528, "additions": 525, "deletions": 3}, "files": [{"sha": "00547017349d4d6629fa6f96b269c5e9fe231a28", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "patch": "@@ -1201,6 +1201,46 @@ extern \"C\" {\n                                 Name: *const c_char)\n                                 -> ValueRef;\n \n+    pub fn LLVMRustBuildVectorReduceFAdd(B: BuilderRef,\n+                                         Acc: ValueRef,\n+                                         Src: ValueRef)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMul(B: BuilderRef,\n+                                         Acc: ValueRef,\n+                                         Src: ValueRef)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceAdd(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMul(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceAnd(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceOr(B: BuilderRef,\n+                                       Src: ValueRef)\n+                                       -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceXor(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMin(B: BuilderRef,\n+                                        Src: ValueRef,\n+                                        IsSigned: bool)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMax(B: BuilderRef,\n+                                        Src: ValueRef,\n+                                        IsSigned: bool)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMin(B: BuilderRef,\n+                                         Src: ValueRef,\n+                                         IsNaN: bool)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMax(B: BuilderRef,\n+                                         Src: ValueRef,\n+                                         IsNaN: bool)\n+                                         -> ValueRef;\n+\n     pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char) -> ValueRef;\n     pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char) -> ValueRef;\n     pub fn LLVMBuildPtrDiff(B: BuilderRef,"}, {"sha": "2c38197d68ecfaa972f1c8dae30077e5a4e35367", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "patch": "@@ -955,6 +955,81 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn vector_reduce_fadd_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fadd_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmul_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmul_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_add(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.add\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src)\n+        }\n+    }\n+    pub fn vector_reduce_mul(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.mul\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src)\n+        }\n+    }\n+    pub fn vector_reduce_and(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.and\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src)\n+        }\n+    }\n+    pub fn vector_reduce_or(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.or\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src)\n+        }\n+    }\n+    pub fn vector_reduce_xor(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.xor\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src)\n+        }\n+    }\n+    pub fn vector_reduce_fmin_fast(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmin_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, false);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmax_fast(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmax_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, false);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_min(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+        self.count_insn(\"vector.reduce.min\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed)\n+        }\n+    }\n+    pub fn vector_reduce_max(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+        self.count_insn(\"vector.reduce.max\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed)\n+        }\n+    }\n+\n     pub fn extract_value(&self, agg_val: ValueRef, idx: u64) -> ValueRef {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);"}, {"sha": "011273f02e116dd65656d26923d4309b1670cfae", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 216, "deletions": 3, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "patch": "@@ -1018,14 +1018,22 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                          name, $($fmt)*));\n         }\n     }\n-    macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n-            if !$cond {\n+    macro_rules! return_error {\n+        ($($fmt: tt)*) => {\n+            {\n                 emit_error!($($fmt)*);\n                 return Err(());\n             }\n         }\n     }\n+\n+    macro_rules! require {\n+        ($cond: expr, $($fmt: tt)*) => {\n+            if !$cond {\n+                return_error!($($fmt)*);\n+            }\n+        };\n+    }\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n             require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n@@ -1142,6 +1150,211 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()))\n     }\n \n+    if name == \"simd_reduce_add\" {\n+        require!(ret_ty == in_elem,\n+                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, ret_ty);\n+        return match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                Ok(bx.vector_reduce_add(args[0].immediate()))\n+            },\n+            ty::TyUint(_u) => {\n+                Ok(bx.vector_reduce_add(args[0].immediate()))\n+            },\n+            ty::TyFloat(f) => {\n+                // undef as accumulator makes the reduction unordered:\n+                let acc = match f.bit_width() {\n+                    32 => C_undef(Type::f32(bx.cx)),\n+                    64 => C_undef(Type::f64(bx.cx)),\n+                    v => {\n+                        return_error!(\n+                            \"unsupported {} from `{}` with element `{}` of size `{}` to `{}`\",\n+                            \"simd_reduce_add\", in_ty, in_elem, v, ret_ty)\n+                    }\n+                };\n+                Ok(bx.vector_reduce_fadd_fast(acc, args[0].immediate()))\n+            }\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_add\", in_ty, in_elem, ret_ty)\n+            },\n+        }\n+    }\n+\n+    if name == \"simd_reduce_mul\" {\n+        require!(ret_ty == in_elem,\n+                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, ret_ty);\n+        return match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                Ok(bx.vector_reduce_mul(args[0].immediate()))\n+            },\n+            ty::TyUint(_u) => {\n+                Ok(bx.vector_reduce_mul(args[0].immediate()))\n+            },\n+            ty::TyFloat(f) => {\n+                // undef as accumulator makes the reduction unordered:\n+                let acc = match f.bit_width() {\n+                    32 => C_undef(Type::f32(bx.cx)),\n+                    64 => C_undef(Type::f64(bx.cx)),\n+                    v => {\n+                        return_error!(\n+                            \"unsupported {} from `{}` with element `{}` of size `{}` to `{}`\",\n+                            \"simd_reduce_mul\", in_ty, in_elem, v, ret_ty)\n+                    }\n+                };\n+                Ok(bx.vector_reduce_fmul_fast(acc, args[0].immediate()))\n+            }\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_mul\", in_ty, in_elem, ret_ty)\n+            },\n+        }\n+    }\n+\n+    if name == \"simd_reduce_min\" {\n+        require!(ret_ty == in_elem,\n+                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, ret_ty);\n+        return match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                Ok(bx.vector_reduce_min(args[0].immediate(), true))\n+            },\n+            ty::TyUint(_u) => {\n+                Ok(bx.vector_reduce_min(args[0].immediate(), false))\n+            },\n+            ty::TyFloat(_f) => {\n+                Ok(bx.vector_reduce_fmin_fast(args[0].immediate()))\n+            }\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_min\", in_ty, in_elem, ret_ty)\n+            },\n+        }\n+    }\n+\n+    if name == \"simd_reduce_max\" {\n+        require!(ret_ty == in_elem,\n+                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, ret_ty);\n+        return match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                Ok(bx.vector_reduce_max(args[0].immediate(), true))\n+            },\n+            ty::TyUint(_u) => {\n+                Ok(bx.vector_reduce_max(args[0].immediate(), false))\n+            },\n+            ty::TyFloat(_f) => {\n+                Ok(bx.vector_reduce_fmax_fast(args[0].immediate()))\n+            }\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_max\", in_ty, in_elem, ret_ty)\n+            },\n+        }\n+    }\n+\n+    if name == \"simd_reduce_and\" {\n+        require!(ret_ty == in_elem,\n+                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, ret_ty);\n+        return match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                Ok(bx.vector_reduce_and(args[0].immediate()))\n+            },\n+            ty::TyUint(_u) => {\n+                Ok(bx.vector_reduce_and(args[0].immediate()))\n+            },\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_and\", in_ty, in_elem, ret_ty)\n+            },\n+        }\n+    }\n+\n+    if name == \"simd_reduce_or\" {\n+        require!(ret_ty == in_elem,\n+                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, ret_ty);\n+        return match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                Ok(bx.vector_reduce_or(args[0].immediate()))\n+            },\n+            ty::TyUint(_u) => {\n+                Ok(bx.vector_reduce_or(args[0].immediate()))\n+            },\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_or\", in_ty, in_elem, ret_ty)\n+            },\n+        }\n+    }\n+\n+    if name == \"simd_reduce_xor\" {\n+        require!(ret_ty == in_elem,\n+                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                 in_elem, in_ty, ret_ty);\n+        return match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                Ok(bx.vector_reduce_xor(args[0].immediate()))\n+            },\n+            ty::TyUint(_u) => {\n+                Ok(bx.vector_reduce_xor(args[0].immediate()))\n+            },\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_xor\", in_ty, in_elem, ret_ty)\n+            },\n+        }\n+    }\n+\n+    if name == \"simd_reduce_all\" {\n+        //require!(ret_ty == in_elem,\n+        //         \"expected return type `{}` (element of input `{}`), found `{}`\",\n+        //         in_elem, in_ty, ret_ty);\n+        let i1 = Type::i1(bx.cx);\n+        let i1xn = Type::vector(&i1, in_len as u64);\n+        let v = bx.trunc(args[0].immediate(), i1xn);\n+\n+        let red = match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                bx.vector_reduce_and(v)\n+            },\n+            ty::TyUint(_u) => {\n+                bx.vector_reduce_and(v)\n+            },\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_and\", in_ty, in_elem, ret_ty)\n+            },\n+        };\n+        return Ok(bx.zext(red, Type::bool(bx.cx)));\n+    }\n+\n+    if name == \"simd_reduce_any\" {\n+        //require!(ret_ty == in_elem,\n+        //         \"expected return type `{}` (element of input `{}`), found `{}`\",\n+        //         in_elem, in_ty, ret_ty);\n+        let i1 = Type::i1(bx.cx);\n+        let i1xn = Type::vector(&i1, in_len as u64);\n+        let v = bx.trunc(args[0].immediate(), i1xn);\n+\n+        let red = match in_elem.sty {\n+            ty::TyInt(_i) => {\n+                bx.vector_reduce_or(v)\n+            },\n+            ty::TyUint(_u) => {\n+                bx.vector_reduce_or(v)\n+            },\n+            _ => {\n+                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                              \"simd_reduce_and\", in_ty, in_elem, ret_ty)\n+            },\n+        };\n+        return Ok(bx.zext(red, Type::bool(bx.cx)));\n+    }\n+\n+\n     if name == \"simd_cast\" {\n         require_simd!(ret_ty, \"return\");\n         let out_len = ret_ty.simd_size(tcx);"}, {"sha": "f2d01c57f298e60d38895cf1fa0de053fe8078ab", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "patch": "@@ -361,6 +361,11 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n         \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n         \"simd_cast\" => (2, vec![param(0)], param(1)),\n+        \"simd_reduce_all\" | \"simd_reduce_any\" => (1, vec![param(0)], tcx.types.bool),\n+        \"simd_reduce_add\" | \"simd_reduce_mul\" |\n+        \"simd_reduce_and\" | \"simd_reduce_or\"  | \"simd_reduce_xor\" |\n+        \"simd_reduce_min\" | \"simd_reduce_max\"\n+            => (2, vec![param(0)], param(1)),\n         name if name.starts_with(\"simd_shuffle\") => {\n             match name[\"simd_shuffle\".len()..].parse() {\n                 Ok(n) => {"}, {"sha": "e749549201e69fd196ece8c94133272ba1bf2301", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "patch": "@@ -1395,3 +1395,49 @@ LLVMRustModuleCost(LLVMModuleRef M) {\n   auto f = unwrap(M)->functions();\n   return std::distance(std::begin(f), std::end(f));\n }\n+\n+// Vector reductions:\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateFAddReduce(unwrap(Acc),unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMul(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateFMulReduce(unwrap(Acc),unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAdd(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateAddReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMul(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateMulReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAnd(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateAndReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceOr(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateOrReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceXor(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateXorReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMin(LLVMBuilderRef B, LLVMValueRef Src, bool IsSigned) {\n+    return wrap(unwrap(B)->CreateIntMinReduce(unwrap(Src), IsSigned));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMax(LLVMBuilderRef B, LLVMValueRef Src, bool IsSigned) {\n+    return wrap(unwrap(B)->CreateIntMaxReduce(unwrap(Src), IsSigned));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMin(LLVMBuilderRef B, LLVMValueRef Src, bool NoNaN) {\n+   return wrap(unwrap(B)->CreateFPMinReduce(unwrap(Src), NoNaN));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMax(LLVMBuilderRef B, LLVMValueRef Src, bool NoNaN) {\n+  return wrap(unwrap(B)->CreateFPMaxReduce(unwrap(Src), NoNaN));\n+}"}, {"sha": "15b291ae179c5d034f4e9eb15305f30c9a5e4012", "filename": "src/test/run-pass/simd-intrinsic-generic-reduction.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cc5b3e195bb01088fdd59638f0d8c6d0a78142/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs?ref=01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "patch": "@@ -0,0 +1,143 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the simd_reduce_{op} intrinsics produce the correct results.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#[allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct b8x4(pub i8, pub i8, pub i8, pub i8);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct b8x16(\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8\n+);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_reduce_add<T, U>(x: T) -> U;\n+    fn simd_reduce_mul<T, U>(x: T) -> U;\n+    fn simd_reduce_min<T, U>(x: T) -> U;\n+    fn simd_reduce_max<T, U>(x: T) -> U;\n+    fn simd_reduce_and<T, U>(x: T) -> U;\n+    fn simd_reduce_or<T, U>(x: T) -> U;\n+    fn simd_reduce_xor<T, U>(x: T) -> U;\n+    fn simd_reduce_all<T>(x: T) -> bool;\n+    fn simd_reduce_any<T>(x: T) -> bool;\n+}\n+\n+fn main() {\n+    unsafe {\n+        let x = i32x4(1, -2, 3, 4);\n+        let r: i32 = simd_reduce_add(x);\n+        assert!(r == 6_i32);\n+        let r: i32 = simd_reduce_mul(x);\n+        assert!(r == -24_i32);\n+        let r: i32 = simd_reduce_min(x);\n+        assert!(r == -21_i32);\n+        let r: i32 = simd_reduce_max(x);\n+        assert!(r == 4_i32);\n+\n+        let x = i32x4(-1, -1, -1, -1);\n+        let r: i32 = simd_reduce_and(x);\n+        assert!(r == -1_i32);\n+        let r: i32 = simd_reduce_or(x);\n+        assert!(r == -1_i32);\n+        let r: i32 = simd_reduce_xor(x);\n+        assert!(r == 0_i32);\n+\n+        let x = i32x4(-1, -1, 0, -1);\n+        let r: i32 = simd_reduce_and(x);\n+        assert!(r == 0_i32);\n+        let r: i32 = simd_reduce_or(x);\n+        assert!(r == -1_i32);\n+        let r: i32 = simd_reduce_xor(x);\n+        assert!(r == -1_i32);\n+    }\n+\n+    unsafe {\n+        let x = u32x4(1, 2, 3, 4);\n+        let r: u32 = simd_reduce_add(x);\n+        assert!(r == 10_u32);\n+        let r: u32 = simd_reduce_mul(x);\n+        assert!(r == 24_u32);\n+        let r: u32 = simd_reduce_min(x);\n+        assert!(r == 1_u32);\n+        let r: u32 = simd_reduce_max(x);\n+        assert!(r == 4_u32);\n+\n+        let t = u32::max_value();\n+        let x = u32x4(t, t, t, t);\n+        let r: u32 = simd_reduce_and(x);\n+        assert!(r == t);\n+        let r: u32 = simd_reduce_or(x);\n+        assert!(r == t);\n+        let r: u32 = simd_reduce_xor(x);\n+        assert!(r == 0_u32);\n+\n+        let x = u32x4(t, t, 0, t);\n+        let r: u32 = simd_reduce_and(x);\n+        assert!(r == 0_u32);\n+        let r: u32 = simd_reduce_or(x);\n+        assert!(r == t);\n+        let r: u32 = simd_reduce_xor(x);\n+        assert!(r == t);\n+    }\n+\n+    unsafe {\n+        let x = f32x4(1., -2., 3., 4.);\n+        let r: f32 = simd_reduce_add(x);\n+        assert!(r == 6_f32);\n+        let r: f32 = simd_reduce_mul(x);\n+        assert!(r == -24_f32);\n+        let r: f32 = simd_reduce_min(x);\n+        assert!(r == -2_f32);\n+        let r: f32 = simd_reduce_max(x);\n+        assert!(r == 4_f32);\n+    }\n+\n+    unsafe {\n+        let x = b8x4(!0, !0, !0, !0);\n+        let r: bool = simd_reduce_all(x);\n+        //let r: bool = foobar(x);\n+        assert!(r);\n+        let r: bool = simd_reduce_any(x);\n+        assert!(r);\n+\n+        let x = b8x4(!0, !0, 0, !0);\n+        let r: bool = simd_reduce_all(x);\n+        assert!(!r);\n+        let r: bool = simd_reduce_any(x);\n+        assert!(r);\n+\n+        let x = b8x4(0, 0, 0, 0);\n+        let r: bool = simd_reduce_all(x);\n+        assert!(!r);\n+        let r: bool = simd_reduce_any(x);\n+        assert!(!r);\n+    }\n+}"}]}