{"sha": "ba77c602707fe7adba2c631db87ba7ad7f4dc812", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNzdjNjAyNzA3ZmU3YWRiYTJjNjMxZGI4N2JhN2FkN2Y0ZGM4MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-26T07:16:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-26T07:16:27Z"}, "message": "auto merge of #14300 : cmr/rust/enum-size-lint, r=kballard\n\nSee commits for details.", "tree": {"sha": "261f466073c7117fe27dc91dc6e55d27109f821f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/261f466073c7117fe27dc91dc6e55d27109f821f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba77c602707fe7adba2c631db87ba7ad7f4dc812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba77c602707fe7adba2c631db87ba7ad7f4dc812", "html_url": "https://github.com/rust-lang/rust/commit/ba77c602707fe7adba2c631db87ba7ad7f4dc812", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba77c602707fe7adba2c631db87ba7ad7f4dc812/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7ab73344dcf3bf0973317ae165f751f6bb42766", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7ab73344dcf3bf0973317ae165f751f6bb42766", "html_url": "https://github.com/rust-lang/rust/commit/a7ab73344dcf3bf0973317ae165f751f6bb42766"}, {"sha": "d8467e23e74fba8447c4a48f75cc9fa78d66b1c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8467e23e74fba8447c4a48f75cc9fa78d66b1c3", "html_url": "https://github.com/rust-lang/rust/commit/d8467e23e74fba8447c4a48f75cc9fa78d66b1c3"}], "stats": {"total": 337, "additions": 239, "deletions": 98}, "files": [{"sha": "eba0bc03bf77654a3be74faf52205da95dc4bde3", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 96, "deletions": 54, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ba77c602707fe7adba2c631db87ba7ad7f4dc812/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba77c602707fe7adba2c631db87ba7ad7f4dc812/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ba77c602707fe7adba2c631db87ba7ad7f4dc812", "patch": "@@ -72,7 +72,7 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::{ast, ast_util, visit};\n \n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+#[deriving(Clone, Show, Eq, Ord, TotalEq, TotalOrd, Hash)]\n pub enum Lint {\n     CTypes,\n     UnusedImports,\n@@ -94,6 +94,7 @@ pub enum Lint {\n     UnknownFeatures,\n     UnknownCrateType,\n     UnsignedNegate,\n+    VariantSizeDifference,\n \n     ManagedHeapMemory,\n     OwnedHeapMemory,\n@@ -147,8 +148,9 @@ pub struct LintSpec {\n \n pub type LintDict = HashMap<&'static str, LintSpec>;\n \n+// this is public for the lints that run in trans\n #[deriving(Eq)]\n-enum LintSource {\n+pub enum LintSource {\n     Node(Span),\n     Default,\n     CommandLine\n@@ -407,6 +409,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: Warn\n     }),\n \n+    (\"variant_size_difference\",\n+    LintSpec {\n+        lint: VariantSizeDifference,\n+        desc: \"detects enums with widely varying variant sizes\",\n+        default: Allow,\n+    }),\n+\n     (\"unused_must_use\",\n     LintSpec {\n         lint: UnusedMustUse,\n@@ -445,30 +454,78 @@ pub fn get_lint_dict() -> LintDict {\n }\n \n struct Context<'a> {\n-    // All known lint modes (string versions)\n+    /// All known lint modes (string versions)\n     dict: LintDict,\n-    // Current levels of each lint warning\n+    /// Current levels of each lint warning\n     cur: SmallIntMap<(Level, LintSource)>,\n-    // context we're checking in (used to access fields like sess)\n+    /// Context we're checking in (used to access fields like sess)\n     tcx: &'a ty::ctxt,\n-    // Items exported by the crate; used by the missing_doc lint.\n+    /// Items exported by the crate; used by the missing_doc lint.\n     exported_items: &'a privacy::ExportedItems,\n-    // The id of the current `ast::StructDef` being walked.\n+    /// The id of the current `ast::StructDef` being walked.\n     cur_struct_def_id: ast::NodeId,\n-    // Whether some ancestor of the current node was marked\n-    // #[doc(hidden)].\n+    /// Whether some ancestor of the current node was marked\n+    /// #[doc(hidden)].\n     is_doc_hidden: bool,\n \n-    // When recursing into an attributed node of the ast which modifies lint\n-    // levels, this stack keeps track of the previous lint levels of whatever\n-    // was modified.\n+    /// When recursing into an attributed node of the ast which modifies lint\n+    /// levels, this stack keeps track of the previous lint levels of whatever\n+    /// was modified.\n     lint_stack: Vec<(Lint, Level, LintSource)>,\n \n-    // id of the last visited negated expression\n+    /// Id of the last visited negated expression\n     negated_expr_id: ast::NodeId,\n \n-    // ids of structs/enums which have been checked for raw_pointer_deriving\n+    /// Ids of structs/enums which have been checked for raw_pointer_deriving\n     checked_raw_pointers: NodeSet,\n+\n+    /// Level of lints for certain NodeIds, stored here because the body of\n+    /// the lint needs to run in trans.\n+    node_levels: HashMap<(ast::NodeId, Lint), (Level, LintSource)>,\n+}\n+\n+pub fn emit_lint(level: Level, src: LintSource, msg: &str, span: Span,\n+                 lint_str: &str, tcx: &ty::ctxt) {\n+    if level == Allow { return }\n+\n+    let mut note = None;\n+    let msg = match src {\n+        Default => {\n+            format!(\"{}, \\\\#[{}({})] on by default\", msg,\n+                level_to_str(level), lint_str)\n+        },\n+        CommandLine => {\n+            format!(\"{} [-{} {}]\", msg,\n+                match level {\n+                    Warn => 'W', Deny => 'D', Forbid => 'F',\n+                    Allow => fail!()\n+                }, lint_str.replace(\"_\", \"-\"))\n+        },\n+        Node(src) => {\n+            note = Some(src);\n+            msg.to_str()\n+        }\n+    };\n+\n+    match level {\n+        Warn =>          { tcx.sess.span_warn(span, msg.as_slice()); }\n+        Deny | Forbid => { tcx.sess.span_err(span, msg.as_slice());  }\n+        Allow => fail!(),\n+    }\n+\n+    for &span in note.iter() {\n+        tcx.sess.span_note(span, \"lint level defined here\");\n+    }\n+}\n+\n+pub fn lint_to_str(lint: Lint) -> &'static str {\n+    for &(name, lspec) in lint_table.iter() {\n+        if lspec.lint == lint {\n+            return name;\n+        }\n+    }\n+\n+    fail!(\"unrecognized lint: {}\", lint);\n }\n \n impl<'a> Context<'a> {\n@@ -500,7 +557,7 @@ impl<'a> Context<'a> {\n                 return *k;\n             }\n         }\n-        fail!(\"unregistered lint {:?}\", lint);\n+        fail!(\"unregistered lint {}\", lint);\n     }\n \n     fn span_lint(&self, lint: Lint, span: Span, msg: &str) {\n@@ -509,37 +566,8 @@ impl<'a> Context<'a> {\n             Some(&(Warn, src)) => (self.get_level(Warnings), src),\n             Some(&pair) => pair,\n         };\n-        if level == Allow { return }\n-\n-        let mut note = None;\n-        let msg = match src {\n-            Default => {\n-                format_strbuf!(\"{}, \\\\#[{}({})] on by default\",\n-                               msg,\n-                               level_to_str(level),\n-                               self.lint_to_str(lint))\n-            },\n-            CommandLine => {\n-                format!(\"{} [-{} {}]\", msg,\n-                    match level {\n-                        Warn => 'W', Deny => 'D', Forbid => 'F',\n-                        Allow => fail!()\n-                    }, self.lint_to_str(lint).replace(\"_\", \"-\"))\n-            },\n-            Node(src) => {\n-                note = Some(src);\n-                msg.to_str()\n-            }\n-        };\n-        match level {\n-            Warn => self.tcx.sess.span_warn(span, msg.as_slice()),\n-            Deny | Forbid => self.tcx.sess.span_err(span, msg.as_slice()),\n-            Allow => fail!(),\n-        }\n \n-        for &span in note.iter() {\n-            self.tcx.sess.span_note(span, \"lint level defined here\");\n-        }\n+        emit_lint(level, src, msg, span, self.lint_to_str(lint), self.tcx);\n     }\n \n     /**\n@@ -618,8 +646,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-// Check that every lint from the list of attributes satisfies `f`.\n-// Return true if that's the case. Otherwise return false.\n+/// Check that every lint from the list of attributes satisfies `f`.\n+/// Return true if that's the case. Otherwise return false.\n pub fn each_lint(sess: &session::Session,\n                  attrs: &[ast::Attribute],\n                  f: |@ast::MetaItem, Level, InternedString| -> bool)\n@@ -653,8 +681,8 @@ pub fn each_lint(sess: &session::Session,\n     true\n }\n \n-// Check from a list of attributes if it contains the appropriate\n-// `#[level(lintname)]` attribute (e.g. `#[allow(dead_code)]).\n+/// Check from a list of attributes if it contains the appropriate\n+/// `#[level(lintname)]` attribute (e.g. `#[allow(dead_code)]).\n pub fn contains_lint(attrs: &[ast::Attribute],\n                      level: Level,\n                      lintname: &'static str)\n@@ -1739,9 +1767,24 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n     cx.span_lint(lint, e.span, msg.as_slice());\n }\n \n+fn check_enum_variant_sizes(cx: &mut Context, it: &ast::Item) {\n+    match it.node {\n+        ast::ItemEnum(..) => {\n+            match cx.cur.find(&(VariantSizeDifference as uint)) {\n+                Some(&(lvl, src)) if lvl != Allow => {\n+                    cx.node_levels.insert((it.id, VariantSizeDifference), (lvl, src));\n+                },\n+                _ => { }\n+            }\n+        },\n+        _ => { }\n+    }\n+}\n+\n impl<'a> Visitor<()> for Context<'a> {\n     fn visit_item(&mut self, it: &ast::Item, _: ()) {\n         self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+            check_enum_variant_sizes(cx, it);\n             check_item_ctypes(cx, it);\n             check_item_non_camel_case_types(cx, it);\n             check_item_non_uppercase_statics(cx, it);\n@@ -1933,6 +1976,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         lint_stack: Vec::new(),\n         negated_expr_id: -1,\n         checked_raw_pointers: NodeSet::new(),\n+        node_levels: HashMap::new(),\n     };\n \n     // Install default lint levels, followed by the command line levels, and\n@@ -1969,13 +2013,11 @@ pub fn check_crate(tcx: &ty::ctxt,\n     // in the iteration code.\n     for (id, v) in tcx.sess.lints.borrow().iter() {\n         for &(lint, span, ref msg) in v.iter() {\n-            tcx.sess.span_bug(span,\n-                              format!(\"unprocessed lint {:?} at {}: {}\",\n-                                      lint,\n-                                      tcx.map.node_to_str(*id),\n-                                      *msg).as_slice())\n+            tcx.sess.span_bug(span, format!(\"unprocessed lint {} at {}: {}\",\n+                                            lint, tcx.map.node_to_str(*id), *msg).as_slice())\n         }\n     }\n \n     tcx.sess.abort_if_errors();\n+    *tcx.node_lint_levels.borrow_mut() = cx.node_levels;\n }"}, {"sha": "def521fd49b1ffecef3929257399fbaae6568118", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ba77c602707fe7adba2c631db87ba7ad7f4dc812/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba77c602707fe7adba2c631db87ba7ad7f4dc812/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ba77c602707fe7adba2c631db87ba7ad7f4dc812", "patch": "@@ -36,6 +36,7 @@ use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, Vector};\n use lib;\n use metadata::{csearch, encoder};\n+use middle::lint;\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n@@ -57,7 +58,7 @@ use middle::trans::foreign;\n use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::machine;\n-use middle::trans::machine::{llalign_of_min, llsize_of};\n+use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n@@ -1489,7 +1490,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n }\n \n fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n-                  id: ast::NodeId, vi: &[Rc<ty::VariantInfo>],\n+                  sp: Span, id: ast::NodeId, vi: &[Rc<ty::VariantInfo>],\n                   i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n         let disr_val = vi[*i].disr_val;\n@@ -1509,6 +1510,57 @@ fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n             }\n         }\n     }\n+\n+    enum_variant_size_lint(ccx, enum_definition, sp, id);\n+}\n+\n+fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {\n+    let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n+\n+    let (lvl, src) = ccx.tcx.node_lint_levels.borrow()\n+                        .find(&(id, lint::VariantSizeDifference))\n+                        .map_or((lint::Allow, lint::Default), |&(lvl,src)| (lvl, src));\n+\n+    if lvl != lint::Allow {\n+        let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n+        match *avar {\n+            adt::General(_, ref variants) => {\n+                for var in variants.iter() {\n+                    let mut size = 0;\n+                    for field in var.fields.iter().skip(1) {\n+                        // skip the dicriminant\n+                        size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n+                    }\n+                    sizes.push(size);\n+                }\n+            },\n+            _ => { /* its size is either constant or unimportant */ }\n+        }\n+\n+        let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n+            |(l, s, li), (idx, &size)|\n+                if size > l {\n+                    (size, l, idx)\n+                } else if size > s {\n+                    (l, size, li)\n+                } else {\n+                    (l, s, li)\n+                }\n+        );\n+\n+        // we only warn if the largest variant is at least thrice as large as\n+        // the second-largest.\n+        if largest > slargest * 3 && slargest > 0 {\n+            lint::emit_lint(lvl, src,\n+                            format!(\"enum variant is more than three times larger \\\n+                                    ({} bytes) than the next largest (ignoring padding)\",\n+                                    largest).as_slice(),\n+                            sp, lint::lint_to_str(lint::VariantSizeDifference), ccx.tcx());\n+\n+            ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n+                                 \"this variant is the largest\");\n+        }\n+    }\n }\n \n pub struct TransItemVisitor<'a> {\n@@ -1555,7 +1607,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n         if !generics.is_type_parameterized() {\n             let vi = ty::enum_variants(ccx.tcx(), local_def(item.id));\n             let mut i = 0;\n-            trans_enum_def(ccx, enum_definition, item.id, vi.as_slice(), &mut i);\n+            trans_enum_def(ccx, enum_definition, item.span, item.id, vi.as_slice(), &mut i);\n         }\n       }\n       ast::ItemStatic(_, m, expr) => {"}, {"sha": "d907b52f0c91247dbf81cc44525bd96eed703c25", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ba77c602707fe7adba2c631db87ba7ad7f4dc812/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba77c602707fe7adba2c631db87ba7ad7f4dc812/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ba77c602707fe7adba2c631db87ba7ad7f4dc812", "patch": "@@ -14,6 +14,7 @@ use back::svh::Svh;\n use driver::session::Session;\n use metadata::csearch;\n use mc = middle::mem_categorization;\n+use middle::lint;\n use middle::const_eval;\n use middle::dependency_format;\n use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n@@ -237,8 +238,8 @@ pub enum AutoRef {\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n pub struct ctxt {\n-    // Specifically use a speedy hash algorithm for this hash map, it's used\n-    // quite often.\n+    /// Specifically use a speedy hash algorithm for this hash map, it's used\n+    /// quite often.\n     pub interner: RefCell<FnvHashMap<intern_key, Box<t_box_>>>,\n     pub next_id: Cell<uint>,\n     pub sess: Session,\n@@ -248,24 +249,24 @@ pub struct ctxt {\n \n     pub region_maps: middle::region::RegionMaps,\n \n-    // Stores the types for various nodes in the AST.  Note that this table\n-    // is not guaranteed to be populated until after typeck.  See\n-    // typeck::check::fn_ctxt for details.\n+    /// Stores the types for various nodes in the AST.  Note that this table\n+    /// is not guaranteed to be populated until after typeck.  See\n+    /// typeck::check::fn_ctxt for details.\n     pub node_types: node_type_table,\n \n-    // Stores the type parameters which were substituted to obtain the type\n-    // of this node.  This only applies to nodes that refer to entities\n-    // param<eterized by type parameters, such as generic fns, types, or\n-    // other items.\n+    /// Stores the type parameters which were substituted to obtain the type\n+    /// of this node.  This only applies to nodes that refer to entities\n+    /// param<eterized by type parameters, such as generic fns, types, or\n+    /// other items.\n     pub item_substs: RefCell<NodeMap<ItemSubsts>>,\n \n-    // Maps from a method to the method \"descriptor\"\n+    /// Maps from a method to the method \"descriptor\"\n     pub methods: RefCell<DefIdMap<Rc<Method>>>,\n \n-    // Maps from a trait def-id to a list of the def-ids of its methods\n+    /// Maps from a trait def-id to a list of the def-ids of its methods\n     pub trait_method_def_ids: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n \n-    // A cache for the trait_methods() routine\n+    /// A cache for the trait_methods() routine\n     pub trait_methods_cache: RefCell<DefIdMap<Rc<Vec<Rc<Method>>>>>,\n \n     pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef>>>>,\n@@ -287,71 +288,74 @@ pub struct ctxt {\n     pub adjustments: RefCell<NodeMap<AutoAdjustment>>,\n     pub normalized_cache: RefCell<HashMap<t, t>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n-    // A mapping of fake provided method def_ids to the default implementation\n+    /// A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n     pub supertraits: RefCell<DefIdMap<Rc<Vec<Rc<TraitRef>>>>>,\n     pub superstructs: RefCell<DefIdMap<Option<ast::DefId>>>,\n     pub struct_fields: RefCell<DefIdMap<Rc<Vec<field_ty>>>>,\n \n-    // Maps from def-id of a type or region parameter to its\n-    // (inferred) variance.\n+    /// Maps from def-id of a type or region parameter to its\n+    /// (inferred) variance.\n     pub item_variance_map: RefCell<DefIdMap<Rc<ItemVariances>>>,\n \n-    // A mapping from the def ID of an enum or struct type to the def ID\n-    // of the method that implements its destructor. If the type is not\n-    // present in this map, it does not have a destructor. This map is\n-    // populated during the coherence phase of typechecking.\n+    /// A mapping from the def ID of an enum or struct type to the def ID\n+    /// of the method that implements its destructor. If the type is not\n+    /// present in this map, it does not have a destructor. This map is\n+    /// populated during the coherence phase of typechecking.\n     pub destructor_for_type: RefCell<DefIdMap<ast::DefId>>,\n \n-    // A method will be in this list if and only if it is a destructor.\n+    /// A method will be in this list if and only if it is a destructor.\n     pub destructors: RefCell<DefIdSet>,\n \n-    // Maps a trait onto a list of impls of that trait.\n+    /// Maps a trait onto a list of impls of that trait.\n     pub trait_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n-    // Maps a DefId of a type to a list of its inherent impls.\n-    // Contains implementations of methods that are inherent to a type.\n-    // Methods in these implementations don't need to be exported.\n+    /// Maps a DefId of a type to a list of its inherent impls.\n+    /// Contains implementations of methods that are inherent to a type.\n+    /// Methods in these implementations don't need to be exported.\n     pub inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n-    // Maps a DefId of an impl to a list of its methods.\n-    // Note that this contains all of the impls that we know about,\n-    // including ones in other crates. It's not clear that this is the best\n-    // way to do it.\n+    /// Maps a DefId of an impl to a list of its methods.\n+    /// Note that this contains all of the impls that we know about,\n+    /// including ones in other crates. It's not clear that this is the best\n+    /// way to do it.\n     pub impl_methods: RefCell<DefIdMap<Vec<ast::DefId>>>,\n \n-    // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n-    // present in this set can be warned about.\n+    /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n+    /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n \n-    // Set of nodes which mark locals as mutable which end up getting used at\n-    // some point. Local variable definitions not in this set can be warned\n-    // about.\n+    /// Set of nodes which mark locals as mutable which end up getting used at\n+    /// some point. Local variable definitions not in this set can be warned\n+    /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    // vtable resolution information for impl declarations\n+    /// vtable resolution information for impl declarations\n     pub impl_vtables: typeck::impl_vtable_map,\n \n-    // The set of external nominal types whose implementations have been read.\n-    // This is used for lazy resolution of methods.\n+    /// The set of external nominal types whose implementations have been read.\n+    /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n \n-    // The set of external traits whose implementations have been read. This\n-    // is used for lazy resolution of traits.\n+    /// The set of external traits whose implementations have been read. This\n+    /// is used for lazy resolution of traits.\n     pub populated_external_traits: RefCell<DefIdSet>,\n \n-    // Borrows\n+    /// Borrows\n     pub upvar_borrow_map: RefCell<UpvarBorrowMap>,\n \n-    // These two caches are used by const_eval when decoding external statics\n-    // and variants that are found.\n+    /// These two caches are used by const_eval when decoding external statics\n+    /// and variants that are found.\n     pub extern_const_statics: RefCell<DefIdMap<Option<@ast::Expr>>>,\n     pub extern_const_variants: RefCell<DefIdMap<Option<@ast::Expr>>>,\n \n     pub method_map: typeck::MethodMap,\n     pub vtable_map: typeck::vtable_map,\n \n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n+\n+    pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::Lint),\n+                                          (lint::Level, lint::LintSource)>>,\n }\n \n pub enum tbox_flag {\n@@ -1134,6 +1138,7 @@ pub fn mk_ctxt(s: Session,\n         method_map: RefCell::new(FnvHashMap::new()),\n         vtable_map: RefCell::new(FnvHashMap::new()),\n         dependency_formats: RefCell::new(HashMap::new()),\n+        node_lint_levels: RefCell::new(HashMap::new()),\n     }\n }\n "}, {"sha": "39ab8316958a65b653ce9a83b157d791027d7a1a", "filename": "src/test/run-pass/enum-size-variance.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ba77c602707fe7adba2c631db87ba7ad7f4dc812/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba77c602707fe7adba2c631db87ba7ad7f4dc812/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs?ref=ba77c602707fe7adba2c631db87ba7ad7f4dc812", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-pretty\n+\n+#![deny(enum_size_variance)]\n+#![allow(dead_code)]\n+\n+enum Enum1 { }\n+\n+enum Enum2 { A, B, C }\n+\n+enum Enum3 { D(int), E, F }\n+\n+enum Enum4 { H(int), I(int), J }\n+\n+enum Enum5 { //~ ERROR three times larger\n+    L(int, int, int, int), //~ NOTE this variant is the largest\n+    M(int),\n+    N\n+}\n+\n+enum Enum6<T, U> {\n+    O(T),\n+    P(U),\n+    Q(int)\n+}\n+\n+#[allow(enum_size_variance)]\n+enum Enum7 {\n+    R(int, int, int, int),\n+    S(int),\n+    T\n+}\n+pub fn main() { }"}]}