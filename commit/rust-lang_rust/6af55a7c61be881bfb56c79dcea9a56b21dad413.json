{"sha": "6af55a7c61be881bfb56c79dcea9a56b21dad413", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZjU1YTdjNjFiZTg4MWJmYjU2Yzc5ZGNlYTlhNTZiMjFkYWQ0MTM=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2018-05-17T04:27:19Z"}, "committer": {"name": "Jonathan Behrens", "email": "fintelia@gmail.com", "date": "2018-09-05T16:10:09Z"}, "message": "WIP: add raw_entry API to HashMap", "tree": {"sha": "18d8cc96813e06580be3cfad25cc43030f618a6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18d8cc96813e06580be3cfad25cc43030f618a6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6af55a7c61be881bfb56c79dcea9a56b21dad413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6af55a7c61be881bfb56c79dcea9a56b21dad413", "html_url": "https://github.com/rust-lang/rust/commit/6af55a7c61be881bfb56c79dcea9a56b21dad413", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6af55a7c61be881bfb56c79dcea9a56b21dad413/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fintelia", "id": 4943209, "node_id": "MDQ6VXNlcjQ5NDMyMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/4943209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fintelia", "html_url": "https://github.com/fintelia", "followers_url": "https://api.github.com/users/fintelia/followers", "following_url": "https://api.github.com/users/fintelia/following{/other_user}", "gists_url": "https://api.github.com/users/fintelia/gists{/gist_id}", "starred_url": "https://api.github.com/users/fintelia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fintelia/subscriptions", "organizations_url": "https://api.github.com/users/fintelia/orgs", "repos_url": "https://api.github.com/users/fintelia/repos", "events_url": "https://api.github.com/users/fintelia/events{/privacy}", "received_events_url": "https://api.github.com/users/fintelia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0297f3043e4ed592c63c0bcc11df3655ec8cf46", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0297f3043e4ed592c63c0bcc11df3655ec8cf46", "html_url": "https://github.com/rust-lang/rust/commit/b0297f3043e4ed592c63c0bcc11df3655ec8cf46"}], "stats": {"total": 741, "additions": 704, "deletions": 37}, "files": [{"sha": "82bd2c695b18f69405622dbd38d681adcf583c1c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 703, "deletions": 37, "changes": 740, "blob_url": "https://github.com/rust-lang/rust/blob/6af55a7c61be881bfb56c79dcea9a56b21dad413/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af55a7c61be881bfb56c79dcea9a56b21dad413/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=6af55a7c61be881bfb56c79dcea9a56b21dad413", "patch": "@@ -20,7 +20,7 @@ use fmt::{self, Debug};\n use hash::{Hash, Hasher, BuildHasher, SipHasher13};\n use iter::{FromIterator, FusedIterator};\n use mem::{self, replace};\n-use ops::{Deref, Index};\n+use ops::{Deref, DerefMut, Index};\n use sys;\n \n use super::table::{self, Bucket, EmptyBucket, Fallibility, FullBucket, FullBucketMut, RawTable,\n@@ -438,6 +438,23 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalE\n     search_hashed_nonempty(table, hash, is_match)\n }\n \n+/// Search for a pre-hashed key.\n+/// If you don't already know the hash, use search or search_mut instead\n+#[inline]\n+fn search_hashed_mut<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalEntry<K, V, M>\n+    where M: DerefMut<Target = RawTable<K, V>>,\n+          F: FnMut(&mut K) -> bool\n+{\n+    // This is the only function where capacity can be zero. To avoid\n+    // undefined behavior when Bucket::new gets the raw bucket in this\n+    // case, immediately return the appropriate search result.\n+    if table.capacity() == 0 {\n+        return InternalEntry::TableIsEmpty;\n+    }\n+\n+    search_hashed_nonempty_mut(table, hash, is_match)\n+}\n+\n /// Search for a pre-hashed key when the hash map is known to be non-empty.\n #[inline]\n fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n@@ -488,6 +505,56 @@ fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n     }\n }\n \n+/// Search for a pre-hashed key when the hash map is known to be non-empty.\n+#[inline]\n+fn search_hashed_nonempty_mut<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n+    -> InternalEntry<K, V, M>\n+    where M: DerefMut<Target = RawTable<K, V>>,\n+          F: FnMut(&mut K) -> bool\n+{\n+    // Do not check the capacity as an extra branch could slow the lookup.\n+\n+    let size = table.size();\n+    let mut probe = Bucket::new(table, hash);\n+    let mut displacement = 0;\n+\n+    loop {\n+        let mut full = match probe.peek() {\n+            Empty(bucket) => {\n+                // Found a hole!\n+                return InternalEntry::Vacant {\n+                    hash,\n+                    elem: NoElem(bucket, displacement),\n+                };\n+            }\n+            Full(bucket) => bucket,\n+        };\n+\n+        let probe_displacement = full.displacement();\n+\n+        if probe_displacement < displacement {\n+            // Found a luckier bucket than me.\n+            // We can finish the search early if we hit any bucket\n+            // with a lower distance to initial bucket than we've probed.\n+            return InternalEntry::Vacant {\n+                hash,\n+                elem: NeqElem(full, probe_displacement),\n+            };\n+        }\n+\n+        // If the hash doesn't match, it can't be this one..\n+        if hash == full.hash() {\n+            // If the key doesn't match, it can't be this one..\n+            if is_match(full.read_mut().0) {\n+                return InternalEntry::Occupied { elem: full };\n+            }\n+        }\n+        displacement += 1;\n+        probe = full.next();\n+        debug_assert!(displacement <= size);\n+    }\n+}\n+\n fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>)\n     -> (K, V, &mut RawTable<K, V>)\n {\n@@ -1484,6 +1551,47 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n }\n \n+impl<K, V, S> HashMap<K, V, S>\n+    where K: Eq + Hash,\n+          S: BuildHasher\n+{\n+    /// Creates a raw entry builder for the HashMap.\n+    ///\n+    /// Raw entries provide the lowest level of control for searching and\n+    /// manipulating a map. They must be manually initialized with hash and\n+    /// then manually searched. After this, insertions into the entry also\n+    /// still require an owned key to be provided.\n+    ///\n+    /// Raw entries are useful for such exotic situations as:\n+    ///\n+    /// * Hash memoization\n+    /// * Deferring the creation of an owned key until it is known to be required\n+    /// * Using a HashMap where the key type can't or shouldn't be hashed and/or compared\n+    ///\n+    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n+    /// `entry` should be preferred.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn raw_entry(&mut self) -> RawEntryBuilder<K, V, S> {\n+        self.reserve(1);\n+        RawEntryBuilder { map: self }\n+    }\n+\n+    /// Creates a raw immutable entry builder for the HashMap.\n+    ///\n+    /// This is useful for\n+    /// * Hash memoization\n+    /// * Querying a HashMap where the key type can't or shouldn't be hashed and/or compared\n+    ///\n+    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n+    /// `entry` should be preferred.\n+    ///\n+    /// Immutable raw entries have very limited use; you might instead want `raw_entry`.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn raw_entry_immut(&self) -> RawImmutableEntryBuilder<K, V, S> {\n+        RawImmutableEntryBuilder { map: self }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> PartialEq for HashMap<K, V, S>\n     where K: Eq + Hash,\n@@ -1709,21 +1817,598 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n             InternalEntry::Occupied { elem } => {\n                 Some(Occupied(OccupiedEntry {\n                     key: Some(key),\n-                    elem,\n+                    entry: RawOccupiedEntry { elem },\n                 }))\n             }\n             InternalEntry::Vacant { hash, elem } => {\n                 Some(Vacant(VacantEntry {\n-                    hash,\n                     key,\n-                    elem,\n+                    entry: RawVacantEntry { hash, elem }\n                 }))\n             }\n             InternalEntry::TableIsEmpty => None,\n         }\n     }\n }\n \n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n+    map: &'a mut HashMap<K, V, S>,\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+pub struct RawEntryBuilderHashed<'a, K: 'a, V: 'a> {\n+    map: &'a mut RawTable<K, V>,\n+    hash: SafeHash,\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+pub enum RawEntry<'a, K: 'a, V: 'a> {\n+    /// WIP\n+    Occupied(RawOccupiedEntry<'a, K, V>),\n+    /// WIP\n+    Vacant(RawVacantEntry<'a, K, V>),\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+pub struct RawOccupiedEntry<'a, K: 'a, V: 'a> {\n+    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+pub struct RawVacantEntry<'a, K: 'a, V: 'a> {\n+    hash: SafeHash,\n+    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+pub struct RawImmutableEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n+    map: &'a HashMap<K, V, S>,\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+pub struct RawImmutableEntryBuilderHashed<'a, K: 'a, V: 'a> {\n+    map: &'a RawTable<K, V>,\n+    hash: SafeHash,\n+}\n+\n+impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n+    where S: BuildHasher,\n+{\n+    /// Initializes the raw entry builder with the hash of the given query value.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn hash_by<Q: ?Sized>(self, k: &Q) -> RawEntryBuilderHashed<'a, K, V>\n+        where Q: Hash\n+    {\n+        self.hash_with(|mut hasher| {\n+            k.hash(&mut hasher);\n+            hasher.finish()\n+        })\n+    }\n+\n+    /// Initializes the raw entry builder with the hash yielded by the given function.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn hash_with<F>(self, func: F) -> RawEntryBuilderHashed<'a, K, V>\n+        where F: FnOnce(S::Hasher) -> u64\n+    {\n+        let hasher = self.map.hash_builder.build_hasher();\n+        let hash = SafeHash::new(func(hasher));\n+\n+        RawEntryBuilderHashed { map: &mut self.map.table, hash }\n+    }\n+\n+    /// Searches for the location of the raw entry with the given query value.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn search_by<Q: ?Sized>(self, k: &Q) -> RawEntry<'a, K, V>\n+        where K: Borrow<Q>,\n+              Q: Eq + Hash\n+    {\n+        self.hash_by(k).search_by(k)\n+    }\n+}\n+\n+impl<'a, K, V> RawEntryBuilderHashed<'a, K, V>\n+{\n+    /// Searches for the location of the raw entry with the given query value.\n+    ///\n+    /// Note that it isn't required that the query value be hashable, as the\n+    /// builder's hash is used.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn search_by<Q: ?Sized>(self, k: &Q) -> RawEntry<'a, K, V>\n+        where K: Borrow<Q>,\n+              Q: Eq,\n+    {\n+        // I don't know why we need this `&mut -> &` transform to resolve Borrow, but we do\n+        self.search_with(|key| (&*key).borrow() == k)\n+    }\n+\n+    /// Searches for the location of the raw entry with the given comparison function.\n+    ///\n+    /// Note that mutable access is given to each key that is visited, because\n+    /// this land is truly godless, and *someone* might have a use for this.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn search_with<F>(self, func: F) -> RawEntry<'a, K, V>\n+        where F: FnMut(&mut K) -> bool,\n+    {\n+        match search_hashed_mut(self.map, self.hash, func) {\n+            InternalEntry::Occupied { elem } => {\n+                RawEntry::Occupied(RawOccupiedEntry { elem })\n+            }\n+            InternalEntry::Vacant { hash, elem } => {\n+                RawEntry::Vacant(RawVacantEntry { hash, elem })\n+            }\n+            InternalEntry::TableIsEmpty => {\n+                unreachable!()\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, K, V, S> RawImmutableEntryBuilder<'a, K, V, S>\n+    where S: BuildHasher,\n+{\n+    /// Initializes the raw entry builder with the hash of the given query value.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn hash_by<Q: ?Sized>(self, k: &Q) -> RawImmutableEntryBuilderHashed<'a, K, V>\n+        where Q: Hash\n+    {\n+        self.hash_with(|mut hasher| {\n+            k.hash(&mut hasher);\n+            hasher.finish()\n+        })\n+    }\n+\n+    /// Initializes the raw entry builder with the hash yielded by the given function.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn hash_with<F>(self, func: F) -> RawImmutableEntryBuilderHashed<'a, K, V>\n+        where F: FnOnce(S::Hasher) -> u64\n+    {\n+        let hasher = self.map.hash_builder.build_hasher();\n+        let hash = SafeHash::new(func(hasher));\n+\n+        RawImmutableEntryBuilderHashed { map: &self.map.table, hash }\n+    }\n+\n+    /// Searches for the location of the raw entry with the given query value.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn search_by<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n+        where K: Borrow<Q>,\n+              Q: Eq + Hash\n+    {\n+        self.hash_by(k).search_by(k)\n+    }\n+}\n+\n+impl<'a, K, V> RawImmutableEntryBuilderHashed<'a, K, V>\n+{\n+    /// Searches for the location of the raw entry with the given query value.\n+    ///\n+    /// Note that it isn't required that the query value be hashable, as the\n+    /// builder's hash is used.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn search_by<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n+        where K: Borrow<Q>,\n+              Q: Eq,\n+    {\n+        self.search_with(|key| key.borrow() == k)\n+    }\n+\n+    /// Searches for the location of the raw entry with the given comparison function.\n+    ///\n+    /// Note that mutable access is given to each key that is visited, because\n+    /// this land is truly godless, and *someone* might have a use for this.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn search_with<F>(self, func: F) -> Option<(&'a K, &'a V)>\n+        where F: FnMut(&K) -> bool,\n+    {\n+        match search_hashed(self.map, self.hash, func) {\n+            InternalEntry::Occupied { elem } => {\n+                Some(elem.into_refs())\n+            }\n+            InternalEntry::Vacant { .. } | InternalEntry::TableIsEmpty  => {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> RawEntry<'a, K, V> {\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    ///\n+    /// *map.entry(\"poneyland\").or_insert(12) += 10;\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V) {\n+        match self {\n+            RawEntry::Occupied(entry) => entry.into_kv(),\n+            RawEntry::Vacant(entry) => entry.insert(default_key, default_val),\n+        }\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, String> = HashMap::new();\n+    /// let s = \"hoho\".to_string();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n+        where F: FnOnce() -> (K, V),\n+    {\n+        match self {\n+            RawEntry::Occupied(entry) => entry.into_kv(),\n+            RawEntry::Vacant(entry) => {\n+                let (k, v) = default();\n+                entry.insert(k, v)\n+            }\n+        }\n+    }\n+\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 42);\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 43);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn and_modify<F>(self, f: F) -> Self\n+        where F: FnOnce(&mut K, &mut V)\n+    {\n+        match self {\n+            RawEntry::Occupied(mut entry) => {\n+                {\n+                    let (k, v) = entry.kv_mut();\n+                    f(k, v);\n+                }\n+                RawEntry::Occupied(entry)\n+            },\n+            RawEntry::Vacant(entry) => RawEntry::Vacant(entry),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> RawOccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn key(&self) -> &K {\n+        self.elem.read().0\n+    }\n+\n+    /// Gets a mutable reference to the key in the entry.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn key_mut(&mut self) -> &mut K {\n+        self.elem.read_mut().0\n+    }\n+\n+    /// Converts the entry into a mutable reference to the key in the entry\n+    /// with a lifetime bound to the map itself.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn into_key(self) -> &'a mut K {\n+        self.elem.into_mut_refs().0\n+    }\n+\n+    /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn get(&self) -> &V {\n+        self.elem.read().1\n+    }\n+\n+    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n+    /// with a lifetime bound to the map itself.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.elem.into_mut_refs().1\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///      *o.get_mut() += 10;\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.elem.read_mut().1\n+    }\n+\n+    /// Gets a reference to the key and value in the entry.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn kv(&mut self) -> (&K, &V) {\n+        self.elem.read()\n+    }\n+\n+    /// Gets a mutable reference to the key and value in the entry.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n+        self.elem.read_mut()\n+    }\n+\n+    /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n+    /// with a lifetime bound to the map itself.\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn into_kv(self) -> (&'a mut K, &'a mut V) {\n+        self.elem.into_mut_refs()\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn insert(&mut self, value: V) -> V {\n+        mem::replace(self.get_mut(), value)\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn insert_key(&mut self, key: K) -> K {\n+        mem::replace(self.key_mut(), key)\n+    }\n+\n+    /// Takes the value out of the entry, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    ///\n+    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn remove(self) -> V {\n+        pop_internal(self.elem).1\n+    }\n+\n+\n+    /// Take the ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_entry();\n+    /// }\n+    ///\n+    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn remove_entry(self) -> (K, V) {\n+        let (k, v, _) = pop_internal(self.elem);\n+        (k, v)\n+    }\n+}\n+\n+impl<'a, K, V> RawVacantEntry<'a, K, V> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 37);\n+    /// ```\n+    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V) {\n+        let b = match self.elem {\n+            NeqElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                robin_hood(bucket, disp, self.hash, key, value)\n+            },\n+            NoElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                bucket.put(self.hash, key, value)\n+            },\n+        };\n+        b.into_mut_refs()\n+    }\n+}\n+\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+impl<'a, K, V, S> Debug for RawEntryBuilder<'a, K, V, S> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        unimplemented!()\n+    }\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+impl<'a, K, V> Debug for RawEntryBuilderHashed<'a, K, V> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        unimplemented!()\n+    }\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+impl<'a, K, V> Debug for RawEntry<'a, K, V> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        unimplemented!()\n+    }\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+impl<'a, K, V> Debug for RawOccupiedEntry<'a, K, V> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        unimplemented!()\n+    }\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+impl<'a, K, V> Debug for RawVacantEntry<'a, K, V> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        unimplemented!()\n+    }\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+impl<'a, K, V, S> Debug for RawImmutableEntryBuilder<'a, K, V, S> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        unimplemented!()\n+    }\n+}\n+\n+/// WIP\n+#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+impl<'a, K, V> Debug for RawImmutableEntryBuilderHashed<'a, K, V> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        unimplemented!()\n+    }\n+}\n+\n /// A view into a single entry in a map, which may either be vacant or occupied.\n ///\n /// This `enum` is constructed from the [`entry`] method on [`HashMap`].\n@@ -1768,7 +2453,7 @@ impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for Entry<'a, K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     key: Option<K>,\n-    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+    entry: RawOccupiedEntry<'a, K, V>,\n }\n \n #[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n@@ -1787,9 +2472,8 @@ impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n /// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    hash: SafeHash,\n     key: K,\n-    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+    entry: RawVacantEntry<'a, K, V>,\n }\n \n #[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n@@ -2213,7 +2897,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n-        self.elem.read().0\n+        self.entry.key()\n     }\n \n     /// Take the ownership of the key and value from the map.\n@@ -2236,8 +2920,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n     pub fn remove_entry(self) -> (K, V) {\n-        let (k, v, _) = pop_internal(self.elem);\n-        (k, v)\n+        self.entry.remove_entry()\n     }\n \n     /// Gets a reference to the value in the entry.\n@@ -2257,7 +2940,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n-        self.elem.read().1\n+        self.entry.get()\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n@@ -2289,7 +2972,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n-        self.elem.read_mut().1\n+        self.entry.get_mut()\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n@@ -2317,7 +3000,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n-        self.elem.into_mut_refs().1\n+        self.entry.into_mut()\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n@@ -2338,10 +3021,8 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// assert_eq!(map[\"poneyland\"], 15);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, mut value: V) -> V {\n-        let old_value = self.get_mut();\n-        mem::swap(&mut value, old_value);\n-        value\n+    pub fn insert(&mut self, value: V) -> V {\n+        self.entry.insert(value)\n     }\n \n     /// Takes the value out of the entry, and returns it.\n@@ -2363,7 +3044,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n-        pop_internal(self.elem).1\n+        self.entry.remove()\n     }\n \n     /// Returns a key that was used for search.\n@@ -2396,7 +3077,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n     pub fn replace_entry(mut self, value: V) -> (K, V) {\n-        let (old_key, old_value) = self.elem.read_mut();\n+        let (old_key, old_value) = self.entry.kv_mut();\n \n         let old_key = mem::replace(old_key, self.key.unwrap());\n         let old_value = mem::replace(old_value, value);\n@@ -2431,8 +3112,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n     pub fn replace_key(mut self) -> K {\n-        let (old_key, _) = self.elem.read_mut();\n-        mem::replace(old_key, self.key.unwrap())\n+        mem::replace(self.entry.key_mut(), self.key.unwrap())\n     }\n }\n \n@@ -2490,21 +3170,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        let b = match self.elem {\n-            NeqElem(mut bucket, disp) => {\n-                if disp >= DISPLACEMENT_THRESHOLD {\n-                    bucket.table_mut().set_tag(true);\n-                }\n-                robin_hood(bucket, disp, self.hash, self.key, value)\n-            },\n-            NoElem(mut bucket, disp) => {\n-                if disp >= DISPLACEMENT_THRESHOLD {\n-                    bucket.table_mut().set_tag(true);\n-                }\n-                bucket.put(self.hash, self.key, value)\n-            },\n-        };\n-        b.into_mut_refs().1\n+        self.entry.insert(self.key, value).1\n     }\n }\n \n@@ -2715,7 +3381,7 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n         match self.entry(key) {\n             Occupied(mut occupied) => {\n                 let key = occupied.take_key().unwrap();\n-                Some(mem::replace(occupied.elem.read_mut().0, key))\n+                Some(mem::replace(occupied.entry.key_mut(), key))\n             }\n             Vacant(vacant) => {\n                 vacant.insert(());"}, {"sha": "591d51184cf5099ee2772163481b7cdca23cb21e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6af55a7c61be881bfb56c79dcea9a56b21dad413/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af55a7c61be881bfb56c79dcea9a56b21dad413/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6af55a7c61be881bfb56c79dcea9a56b21dad413", "patch": "@@ -284,6 +284,7 @@\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]\n+#![feature(raw_entry)]\n #![feature(rustc_attrs)]\n #![feature(rustc_const_unstable)]\n #![feature(std_internals)]"}]}