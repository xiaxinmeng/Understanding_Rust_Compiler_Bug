{"sha": "3f1d57fcdede5c436c8b788691b9e25b289f9a27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMWQ1N2ZjZGVkZTVjNDM2YzhiNzg4NjkxYjllMjViMjg5ZjlhMjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T19:43:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T19:43:59Z"}, "message": "rollup merge of #23285: steveklabnik/gh11794\n\nFixes #11794\n\nI mostly removed superflous examples which use the standard library.\n\nI have one more quesiton here though: threads. They're mostly a library thing, at this point, right?", "tree": {"sha": "3e6ae2da5db360fb352fdd212249afd6f06dd15a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e6ae2da5db360fb352fdd212249afd6f06dd15a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f1d57fcdede5c436c8b788691b9e25b289f9a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f1d57fcdede5c436c8b788691b9e25b289f9a27", "html_url": "https://github.com/rust-lang/rust/commit/3f1d57fcdede5c436c8b788691b9e25b289f9a27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f1d57fcdede5c436c8b788691b9e25b289f9a27/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01560112b8dda59d7e45b33d4d344dfdea589ea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/01560112b8dda59d7e45b33d4d344dfdea589ea2", "html_url": "https://github.com/rust-lang/rust/commit/01560112b8dda59d7e45b33d4d344dfdea589ea2"}, {"sha": "ac67729baf168b92790785585a80fb2467bc6934", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac67729baf168b92790785585a80fb2467bc6934", "html_url": "https://github.com/rust-lang/rust/commit/ac67729baf168b92790785585a80fb2467bc6934"}], "stats": {"total": 261, "additions": 22, "deletions": 239}, "files": [{"sha": "edd16da5d70064017118e400b84780ff3fbd1336", "filename": "src/doc/reference.md", "status": "modified", "additions": 22, "deletions": 239, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/3f1d57fcdede5c436c8b788691b9e25b289f9a27/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/3f1d57fcdede5c436c8b788691b9e25b289f9a27/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=3f1d57fcdede5c436c8b788691b9e25b289f9a27", "patch": "@@ -645,18 +645,7 @@ fn bar() {\n \n A number of minor features of Rust are not central enough to have their own\n syntax, and yet are not implementable as functions. Instead, they are given\n-names, and invoked through a consistent syntax: `name!(...)`. Examples include:\n-\n-* `format!` : format data into a string\n-* `env!` : look up an environment variable's value at compile time\n-* `file!`: return the path to the file being compiled\n-* `stringify!` : pretty-print the Rust expression given as an argument\n-* `include!` : include the Rust expression in the given file\n-* `include_str!` : include the contents of the given file as a string\n-* `include_bytes!` : include the contents of the given file as a binary blob\n-* `error!`, `warn!`, `info!`, `debug!` : provide diagnostic information.\n-\n-All of the above extensions are expressions with values.\n+names, and invoked through a consistent syntax: `some_extension!(...)`.\n \n Users of `rustc` can define new syntax extensions in two ways:\n \n@@ -744,38 +733,6 @@ Rust syntax is restricted in two ways:\n    pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n    requiring a distinctive token in front can solve the problem.\n \n-## Syntax extensions useful in macros\n-\n-* `stringify!` : turn the identifier argument into a string literal\n-* `concat!` : concatenates a comma-separated list of literals\n-\n-## Syntax extensions for macro debugging\n-\n-* `log_syntax!` : print out the arguments at compile time\n-* `trace_macros!` : supply `true` or `false` to enable or disable macro expansion logging\n-\n-## Quasiquoting\n-\n-The following syntax extensions are used for quasiquoting Rust syntax trees,\n-usually in [procedural macros](book/plugins.html#syntax-extensions):\n-\n-* `quote_expr!`\n-* `quote_item!`\n-* `quote_pat!`\n-* `quote_stmt!`\n-* `quote_tokens!`\n-* `quote_matcher!`\n-* `quote_ty!`\n-* `quote_attr!`\n-\n-Keep in mind that when `$name : ident` appears in the input to\n-`quote_tokens!`, the result contains unquoted `name` followed by two tokens.\n-However, input of the same form passed to `quote_matcher!` becomes a\n-quasiquoted MBE-matcher of a nonterminal. No unquotation happens. Otherwise\n-the result of `quote_matcher!` is identical to that of `quote_tokens!`.\n-\n-Documentation is very limited at the moment.\n-\n # Crates and source files\n \n Rust is a *compiled* language. Its semantics obey a *phase distinction*\n@@ -1521,22 +1478,6 @@ statics:\n Constants should in general be preferred over statics, unless large amounts of\n data are being stored, or single-address and mutability properties are required.\n \n-```\n-use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n-\n-// Note that ATOMIC_USIZE_INIT is a *const*, but it may be used to initialize a\n-// static. This static can be modified, so it is not placed in read-only memory.\n-static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n-\n-// This table is a candidate to be placed in read-only memory.\n-static TABLE: &'static [usize] = &[1, 2, 3, /* ... */];\n-\n-for slot in TABLE.iter() {\n-    println!(\"{}\", slot);\n-}\n-COUNTER.fetch_add(1, Ordering::SeqCst);\n-```\n-\n #### Mutable statics\n \n If a static item is declared with the `mut` keyword, then it is allowed to\n@@ -2376,18 +2317,6 @@ impl<T: PartialEq> PartialEq for Foo<T> {\n }\n ```\n \n-Supported traits for `derive` are:\n-\n-* Comparison traits: `PartialEq`, `Eq`, `PartialOrd`, `Ord`.\n-* Serialization: `Encodable`, `Decodable`. These require `serialize`.\n-* `Clone`, to create `T` from `&T` via a copy.\n-* `Default`, to create an empty instance of a data type.\n-* `FromPrimitive`, to create an instance from a numeric primitive.\n-* `Hash`, to iterate over the bytes in a data type.\n-* `Rand`, to create a random instance of a data type.\n-* `Debug`, to format a value using the `{:?}` formatter.\n-* `Copy`, for \"Plain Old Data\" types which can be copied by simply moving bits.\n-\n ### Compiler Features\n \n Certain aspects of Rust may be implemented in the compiler, but they're not\n@@ -3883,75 +3812,27 @@ impl Printable for String {\n `self` refers to the value of type `String` that is the receiver for a call to\n the method `make_string`.\n \n-## Type kinds\n-\n-Types in Rust are categorized into kinds, based on various properties of the\n-components of the type. The kinds are:\n-\n-* `Send`\n-  : Types of this kind can be safely sent between threads.\n-    This kind includes scalars, boxes, procs, and\n-    structural types containing only other owned types.\n-    All `Send` types are `'static`.\n-* `Copy`\n-  : Types of this kind consist of \"Plain Old Data\"\n-    which can be copied by simply moving bits.\n-    All values of this kind can be implicitly copied.\n-    This kind includes scalars and immutable references,\n-    as well as structural types containing other `Copy` types.\n-* `'static`\n-  : Types of this kind do not contain any references (except for\n-    references with the `static` lifetime, which are allowed).\n-    This can be a useful guarantee for code\n-    that breaks borrowing assumptions\n-    using [`unsafe` operations](#unsafe-functions).\n-* `Drop`\n-  : This is not strictly a kind,\n-    but its presence interacts with kinds:\n-    the `Drop` trait provides a single method `drop`\n-    that takes no parameters,\n-    and is run when values of the type are dropped.\n-    Such a method is called a \"destructor\",\n-    and are always executed in \"top-down\" order:\n-    a value is completely destroyed\n-    before any of the values it owns run their destructors.\n-    Only `Send` types can implement `Drop`.\n-\n-* _Default_\n-  : Types with destructors, closure environments,\n-    and various other _non-first-class_ types,\n-    are not copyable at all.\n-    Such types can usually only be accessed through pointers,\n-    or in some cases, moved between mutable locations.\n-\n-Kinds can be supplied as _bounds_ on type parameters, like traits, in which\n-case the parameter is constrained to types satisfying that kind.\n-\n-By default, type parameters do not carry any assumed kind-bounds at all. When\n-instantiating a type parameter, the kind bounds on the parameter are checked to\n-be the same or narrower than the kind of the type that it is instantiated with.\n-\n-Sending operations are not part of the Rust language, but are implemented in\n-the library. Generic functions that send values bound the kind of these values\n-to sendable.\n-\n-# Memory and concurrency models\n-\n-Rust has a memory model centered around concurrently-executing _threads_. Thus\n-its memory model and its concurrency model are best discussed simultaneously,\n-as parts of each only make sense when considered from the perspective of the\n-other.\n-\n-When reading about the memory model, keep in mind that it is partitioned in\n-order to support threads; and when reading about threads, keep in mind that their\n-isolation and communication mechanisms are only possible due to the ownership\n-and lifetime semantics of the memory model.\n-\n-## Memory model\n-\n-A Rust program's memory consists of a static set of *items*, a set of\n-[threads](#threads) each with its own *stack*, and a *heap*. Immutable portions of\n-the heap may be shared between threads, mutable portions may not.\n+# The `Copy` trait\n+\n+Rust has a special trait, `Copy`, which when implemented changes the semantics\n+of a value. Values whose type implements `Copy` are copied rather than moved\n+upon assignment.\n+\n+# The `Sized` trait\n+\n+`Sized` is a special trait which indicates that the size of this type is known\n+at compile-time.\n+\n+# The `Drop` trait\n+\n+The `Drop` trait provides a destructor, to be run whenever a value of this type\n+is to be destroyed.\n+\n+# Memory model\n+\n+A Rust program's memory consists of a static set of *items* and a *heap*.\n+Immutable portions of the heap may be shared between threads, mutable portions\n+may not.\n \n Allocations in the stack consist of *slots*, and allocations in the heap\n consist of *boxes*.\n@@ -3962,36 +3843,18 @@ The _items_ of a program are those functions, modules and types that have their\n value calculated at compile-time and stored uniquely in the memory image of the\n rust process. Items are neither dynamically allocated nor freed.\n \n-A thread's _stack_ consists of activation frames automatically allocated on entry\n-to each function as the thread executes. A stack allocation is reclaimed when\n-control leaves the frame containing it.\n-\n The _heap_ is a general term that describes boxes.  The lifetime of an\n allocation in the heap depends on the lifetime of the box values pointing to\n it. Since box values may themselves be passed in and out of frames, or stored\n in the heap, heap allocations may outlive the frame they are allocated within.\n \n ### Memory ownership\n \n-A thread owns all memory it can *safely* reach through local variables, as well\n-as boxes and references.\n-\n-When a thread sends a value that has the `Send` trait to another thread, it loses\n-ownership of the value sent and can no longer refer to it. This is statically\n-guaranteed by the combined use of \"move semantics\", and the compiler-checked\n-_meaning_ of the `Send` trait: it is only instantiated for (transitively)\n-sendable kinds of data constructor and pointers, never including references.\n-\n When a stack frame is exited, its local allocations are all released, and its\n references to boxes are dropped.\n \n-When a thread finishes, its stack is necessarily empty and it therefore has no\n-references to any boxes; the remainder of its heap is immediately freed.\n-\n ### Memory slots\n \n-A thread's stack contains slots.\n-\n A _slot_ is a component of a stack frame, either a function parameter, a\n [temporary](#lvalues,-rvalues-and-temporaries), or a local variable.\n \n@@ -4021,86 +3884,6 @@ state. Subsequent statements within a function may or may not initialize the\n local variables. Local variables can be used only after they have been\n initialized; this is enforced by the compiler.\n \n-### Boxes\n-\n-A _box_ is a reference to a heap allocation holding another value, which is\n-constructed by the prefix operator `box`. When the standard library is in use,\n-the type of a box is `std::owned::Box<T>`.\n-\n-An example of a box type and value:\n-\n-```\n-let x: Box<i32> = Box::new(10);\n-```\n-\n-Box values exist in 1:1 correspondence with their heap allocation, copying a\n-box value makes a shallow copy of the pointer. Rust will consider a shallow\n-copy of a box to move ownership of the value. After a value has been moved,\n-the source location cannot be used unless it is reinitialized.\n-\n-```\n-let x: Box<i32> = Box::new(10);\n-let y = x;\n-// attempting to use `x` will result in an error here\n-```\n-\n-## Threads\n-\n-Rust's primary concurrency mechanism is called a **thread**.\n-\n-### Communication between threads\n-\n-Rust threads are isolated and generally unable to interfere with one another's\n-memory directly, except through [`unsafe` code](#unsafe-functions).  All\n-contact between threads is mediated by safe forms of ownership transfer, and data\n-races on memory are prohibited by the type system.\n-\n-When you wish to send data between threads, the values are restricted to the\n-[`Send` type-kind](#type-kinds). Restricting communication interfaces to this\n-kind ensures that no references move between threads. Thus access to an entire\n-data structure can be mediated through its owning \"root\" value; no further\n-locking or copying is required to avoid data races within the substructure of\n-such a value.\n-\n-### Thread\n-\n-The _lifecycle_ of a threads consists of a finite set of states and events that\n-cause transitions between the states. The lifecycle states of a thread are:\n-\n-* running\n-* blocked\n-* panicked\n-* dead\n-\n-A thread begins its lifecycle &mdash; once it has been spawned &mdash; in the\n-*running* state. In this state it executes the statements of its entry\n-function, and any functions called by the entry function.\n-\n-A thread may transition from the *running* state to the *blocked* state any time\n-it makes a blocking communication call. When the call can be completed &mdash;\n-when a message arrives at a sender, or a buffer opens to receive a message\n-&mdash; then the blocked thread will unblock and transition back to *running*.\n-\n-A thread may transition to the *panicked* state at any time, due being killed by\n-some external event or internally, from the evaluation of a `panic!()` macro.\n-Once *panicking*, a thread unwinds its stack and transitions to the *dead* state.\n-Unwinding the stack of a thread is done by the thread itself, on its own control\n-stack. If a value with a destructor is freed during unwinding, the code for the\n-destructor is run, also on the thread's control stack. Running the destructor\n-code causes a temporary transition to a *running* state, and allows the\n-destructor code to cause any subsequent state transitions. The original thread\n-of unwinding and panicking thereby may suspend temporarily, and may involve\n-(recursive) unwinding of the stack of a failed destructor. Nonetheless, the\n-outermost unwinding activity will continue until the stack is unwound and the\n-thread transitions to the *dead* state. There is no way to \"recover\" from thread\n-panics. Once a thread has temporarily suspended its unwinding in the *panicking*\n-state, a panic occurring from within this destructor results in *hard* panic.\n-A hard panic currently results in the process aborting.\n-\n-A thread in the *dead* state cannot transition to other states; it exists only to\n-have its termination status inspected by other threads, and/or to await\n-reclamation when the last reference to it drops.\n-\n # Runtime services, linkage and debugging\n \n The Rust _runtime_ is a relatively compact collection of Rust code that"}]}