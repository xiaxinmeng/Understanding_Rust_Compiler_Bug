{"sha": "52c8084f912e3728b8b06ae7e077521dba89d326", "node_id": "C_kwDOAAsO6NoAKDUyYzgwODRmOTEyZTM3MjhiOGIwNmFlN2UwNzc1MjFkYmE4OWQzMjY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-03-27T16:56:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-27T16:56:19Z"}, "message": "Rollup merge of #109330 - GuillaumeGomez:intermediate-reexport-intra-doc-ice, r=petrochenkov\n\nrustdoc: Fix ICE for intra-doc link on intermediate re-export\n\nFixes https://github.com/rust-lang/rust/issues/109282.\n\nThis PR is based on #109266 as it includes its commit to make this work.\n\n`@petrochenkov:` It was exactly as you predicted, adding the `DefId` to the attributes fixed the error for intermediate re-exports as well. Thanks a lot!\n\nr? `@petrochenkov`", "tree": {"sha": "93b909364d3835c37eb63e41953eb3d9d1bde956", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93b909364d3835c37eb63e41953eb3d9d1bde956"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52c8084f912e3728b8b06ae7e077521dba89d326", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkIcqzCRBK7hj4Ov3rIwAABNYIAJ5kbIdCegRRwVei4MJqNiYT\nKTrRHkwOUz2cJtQJjU7A9yW20lmEw+0q3FcomfmkHjMH2v7vJxa3/PFxl3l2ZJVC\nZIeYQ9jSgYbcfjo/+682TqgG26kZTEadFpvVNv00hizd+Lea0yJyyp2R9gfFOigO\nTvPGIrtqrgvIqYxrbQqSFdS+ua4jRDGtNip+bg4hS3CAf5ChPr78hjKGrXvFyqre\nKb5l1z/U9tpHveGdPSnTKJHHMarVEk6Q7Qb8rZEzCPQYNsKv3NYzXYt3dZfv4rAy\n9ylPqjabloaFH6eRJZaefizQxKwX2VEKyVjJxnSFrE+NBcpJoiA787ZRczrDIk8=\n=qy4e\n-----END PGP SIGNATURE-----\n", "payload": "tree 93b909364d3835c37eb63e41953eb3d9d1bde956\nparent dd19135b044cd21a9c3ae7ae87620bf41a208066\nparent 87ea9941d530194f9d04ed3bb1472509f786dd4e\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1679936179 +0200\ncommitter GitHub <noreply@github.com> 1679936179 +0200\n\nRollup merge of #109330 - GuillaumeGomez:intermediate-reexport-intra-doc-ice, r=petrochenkov\n\nrustdoc: Fix ICE for intra-doc link on intermediate re-export\n\nFixes https://github.com/rust-lang/rust/issues/109282.\n\nThis PR is based on #109266 as it includes its commit to make this work.\n\n`@petrochenkov:` It was exactly as you predicted, adding the `DefId` to the attributes fixed the error for intermediate re-exports as well. Thanks a lot!\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52c8084f912e3728b8b06ae7e077521dba89d326", "html_url": "https://github.com/rust-lang/rust/commit/52c8084f912e3728b8b06ae7e077521dba89d326", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52c8084f912e3728b8b06ae7e077521dba89d326/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd19135b044cd21a9c3ae7ae87620bf41a208066", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd19135b044cd21a9c3ae7ae87620bf41a208066", "html_url": "https://github.com/rust-lang/rust/commit/dd19135b044cd21a9c3ae7ae87620bf41a208066"}, {"sha": "87ea9941d530194f9d04ed3bb1472509f786dd4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/87ea9941d530194f9d04ed3bb1472509f786dd4e", "html_url": "https://github.com/rust-lang/rust/commit/87ea9941d530194f9d04ed3bb1472509f786dd4e"}], "stats": {"total": 168, "additions": 117, "deletions": 51}, "files": [{"sha": "5f5521caf68b925d2f5b8a8358ea75616997cae2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/52c8084f912e3728b8b06ae7e077521dba89d326/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c8084f912e3728b8b06ae7e077521dba89d326/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=52c8084f912e3728b8b06ae7e077521dba89d326", "patch": "@@ -32,14 +32,14 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, ExpnKind};\n \n use std::assert_matches::assert_matches;\n+use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::collections::BTreeMap;\n use std::default::Default;\n use std::hash::Hash;\n use std::mem;\n use thin_vec::ThinVec;\n \n-use crate::clean::inline::merge_attrs;\n use crate::core::{self, DocContext, ImplTraitParam};\n use crate::formats::item_type::ItemType;\n use crate::visit_ast::Module as DocModule;\n@@ -2168,32 +2168,39 @@ impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n /// documentation. Otherwise, we repeat the same operation until we find the \"end item\".\n fn get_all_import_attributes<'hir>(\n     mut item: &hir::Item<'hir>,\n-    tcx: TyCtxt<'hir>,\n+    cx: &mut DocContext<'hir>,\n     target_def_id: LocalDefId,\n-    attributes: &mut Vec<ast::Attribute>,\n     is_inline: bool,\n-) {\n+    mut prev_import: LocalDefId,\n+) -> Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)> {\n+    let mut attributes: Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)> = Vec::new();\n     let mut first = true;\n-    let hir_map = tcx.hir();\n+    let hir_map = cx.tcx.hir();\n     let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n     let mut visited = FxHashSet::default();\n \n     // If the item is an import and has at least a path with two parts, we go into it.\n     while let hir::ItemKind::Use(path, _) = item.kind && visited.insert(item.hir_id()) {\n+        let import_parent = cx.tcx.opt_local_parent(prev_import).map(|def_id| def_id.to_def_id());\n         if first {\n             // This is the \"original\" reexport so we get all its attributes without filtering them.\n-            attributes.extend_from_slice(hir_map.attrs(item.hir_id()));\n+            attributes = hir_map.attrs(item.hir_id())\n+                .iter()\n+                .map(|attr| (Cow::Borrowed(attr), import_parent))\n+                .collect::<Vec<_>>();\n             first = false;\n         } else {\n-            add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n+            add_without_unwanted_attributes(&mut attributes, hir_map.attrs(item.hir_id()), is_inline, import_parent);\n         }\n \n-        if let Some(i) = visitor.find_target(tcx, item.owner_id.def_id.to_def_id(), path) {\n+        if let Some(i) = visitor.find_target(cx.tcx, item.owner_id.def_id.to_def_id(), path) {\n             item = i;\n         } else {\n             break;\n         }\n+        prev_import = item.owner_id.def_id;\n     }\n+    attributes\n }\n \n fn filter_tokens_from_list(\n@@ -2239,17 +2246,24 @@ fn filter_tokens_from_list(\n /// * `doc(inline)`\n /// * `doc(no_inline)`\n /// * `doc(hidden)`\n-fn add_without_unwanted_attributes(\n-    attrs: &mut Vec<ast::Attribute>,\n-    new_attrs: &[ast::Attribute],\n+fn add_without_unwanted_attributes<'hir>(\n+    attrs: &mut Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)>,\n+    new_attrs: &'hir [ast::Attribute],\n     is_inline: bool,\n+    import_parent: Option<DefId>,\n ) {\n-    // If it's `#[doc(inline)]`, we don't want all attributes, otherwise we keep everything.\n+    // If it's not `#[doc(inline)]`, we don't want all attributes, otherwise we keep everything.\n     if !is_inline {\n-        attrs.extend_from_slice(new_attrs);\n+        for attr in new_attrs {\n+            attrs.push((Cow::Borrowed(attr), import_parent));\n+        }\n         return;\n     }\n     for attr in new_attrs {\n+        if matches!(attr.kind, ast::AttrKind::DocComment(..)) {\n+            attrs.push((Cow::Borrowed(attr), import_parent));\n+            continue;\n+        }\n         let mut attr = attr.clone();\n         match attr.kind {\n             ast::AttrKind::Normal(ref mut normal) => {\n@@ -2276,18 +2290,15 @@ fn add_without_unwanted_attributes(\n                                     )\n                                 });\n                             args.tokens = TokenStream::new(tokens);\n-                            attrs.push(attr);\n+                            attrs.push((Cow::Owned(attr), import_parent));\n                         }\n                         ast::AttrArgs::Empty | ast::AttrArgs::Eq(..) => {\n-                            attrs.push(attr);\n-                            continue;\n+                            attrs.push((Cow::Owned(attr), import_parent));\n                         }\n                     }\n                 }\n             }\n-            ast::AttrKind::DocComment(..) => {\n-                attrs.push(attr);\n-            }\n+            _ => unreachable!(),\n         }\n     }\n }\n@@ -2374,26 +2385,43 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let mut import_attrs = Vec::new();\n-        let mut target_attrs = Vec::new();\n-        if let Some(import_id) = import_id &&\n+        let attrs = if let Some(import_id) = import_id &&\n             let Some(hir::Node::Item(use_node)) = cx.tcx.hir().find_by_def_id(import_id)\n         {\n-            let is_inline = inline::load_attrs(cx, import_id.to_def_id()).lists(sym::doc).get_word_attr(sym::inline).is_some();\n+            let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n+                .lists(sym::doc)\n+                .get_word_attr(sym::inline)\n+                .is_some();\n             // Then we get all the various imports' attributes.\n-            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut import_attrs, is_inline);\n-            add_without_unwanted_attributes(&mut target_attrs, inline::load_attrs(cx, def_id), is_inline);\n+            let mut attrs = get_all_import_attributes(\n+                use_node,\n+                cx,\n+                item.owner_id.def_id,\n+                is_inline,\n+                import_id,\n+            );\n+\n+            add_without_unwanted_attributes(\n+                &mut attrs,\n+                inline::load_attrs(cx, def_id),\n+                is_inline,\n+                None\n+            );\n+            attrs\n         } else {\n             // We only keep the item's attributes.\n-            target_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n-        }\n+            inline::load_attrs(cx, def_id).iter().map(|attr| (Cow::Borrowed(attr), None)).collect::<Vec<_>>()\n+        };\n \n-        let import_id = import_id.map(|def_id| def_id.to_def_id());\n-        let (attrs, cfg) =  merge_attrs(cx, &target_attrs, Some((&import_attrs, import_id)));\n+        let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+        let attrs = Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| match attr {\n+            Cow::Borrowed(attr) => (*attr, *did),\n+            Cow::Owned(attr) => (attr, *did)\n+        }), false);\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n-        item.inline_stmt_id = import_id;\n+        item.inline_stmt_id = import_id.map(|local| local.to_def_id());\n         vec![item]\n     })\n }"}, {"sha": "9019a6c49ecc59171e48055606f0615874e95836", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/52c8084f912e3728b8b06ae7e077521dba89d326/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c8084f912e3728b8b06ae7e077521dba89d326/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=52c8084f912e3728b8b06ae7e077521dba89d326", "patch": "@@ -1,3 +1,4 @@\n+use std::borrow::Cow;\n use std::cell::RefCell;\n use std::default::Default;\n use std::hash::Hash;\n@@ -867,30 +868,15 @@ pub(crate) struct Module {\n \n pub(crate) trait AttributesExt {\n     type AttributeIterator<'a>: Iterator<Item = ast::NestedMetaItem>\n+    where\n+        Self: 'a;\n+    type Attributes<'a>: Iterator<Item = &'a ast::Attribute>\n     where\n         Self: 'a;\n \n     fn lists<'a>(&'a self, name: Symbol) -> Self::AttributeIterator<'a>;\n \n-    fn span(&self) -> Option<rustc_span::Span>;\n-\n-    fn cfg(&self, tcx: TyCtxt<'_>, hidden_cfg: &FxHashSet<Cfg>) -> Option<Arc<Cfg>>;\n-}\n-\n-impl AttributesExt for [ast::Attribute] {\n-    type AttributeIterator<'a> = impl Iterator<Item = ast::NestedMetaItem> + 'a;\n-\n-    fn lists<'a>(&'a self, name: Symbol) -> Self::AttributeIterator<'a> {\n-        self.iter()\n-            .filter(move |attr| attr.has_name(name))\n-            .filter_map(ast::Attribute::meta_item_list)\n-            .flatten()\n-    }\n-\n-    /// Return the span of the first doc-comment, if it exists.\n-    fn span(&self) -> Option<rustc_span::Span> {\n-        self.iter().find(|attr| attr.doc_str().is_some()).map(|attr| attr.span)\n-    }\n+    fn iter<'a>(&'a self) -> Self::Attributes<'a>;\n \n     fn cfg(&self, tcx: TyCtxt<'_>, hidden_cfg: &FxHashSet<Cfg>) -> Option<Arc<Cfg>> {\n         let sess = tcx.sess;\n@@ -980,6 +966,43 @@ impl AttributesExt for [ast::Attribute] {\n     }\n }\n \n+impl AttributesExt for [ast::Attribute] {\n+    type AttributeIterator<'a> = impl Iterator<Item = ast::NestedMetaItem> + 'a;\n+    type Attributes<'a> = impl Iterator<Item = &'a ast::Attribute> + 'a;\n+\n+    fn lists<'a>(&'a self, name: Symbol) -> Self::AttributeIterator<'a> {\n+        self.iter()\n+            .filter(move |attr| attr.has_name(name))\n+            .filter_map(ast::Attribute::meta_item_list)\n+            .flatten()\n+    }\n+\n+    fn iter<'a>(&'a self) -> Self::Attributes<'a> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl AttributesExt for [(Cow<'_, ast::Attribute>, Option<DefId>)] {\n+    type AttributeIterator<'a> = impl Iterator<Item = ast::NestedMetaItem> + 'a\n+        where Self: 'a;\n+    type Attributes<'a> = impl Iterator<Item = &'a ast::Attribute> + 'a\n+        where Self: 'a;\n+\n+    fn lists<'a>(&'a self, name: Symbol) -> Self::AttributeIterator<'a> {\n+        AttributesExt::iter(self)\n+            .filter(move |attr| attr.has_name(name))\n+            .filter_map(ast::Attribute::meta_item_list)\n+            .flatten()\n+    }\n+\n+    fn iter<'a>(&'a self) -> Self::Attributes<'a> {\n+        self.into_iter().map(move |(attr, _)| match attr {\n+            Cow::Borrowed(attr) => *attr,\n+            Cow::Owned(attr) => attr,\n+        })\n+    }\n+}\n+\n pub(crate) trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `word`\n     fn has_word(self, word: Symbol) -> bool"}, {"sha": "1a896b411ab0691fd78b4614e604bc4826fea8e8", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52c8084f912e3728b8b06ae7e077521dba89d326/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c8084f912e3728b8b06ae7e077521dba89d326/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=52c8084f912e3728b8b06ae7e077521dba89d326", "patch": "@@ -1239,8 +1239,9 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         if let Some(doc) = attrs.collapsed_doc_value() {\n             // Use the outermost invocation, so that doctest names come from where the docs were written.\n             let span = ast_attrs\n-                .span()\n-                .map(|span| span.ctxt().outer_expn().expansion_cause().unwrap_or(span))\n+                .iter()\n+                .find(|attr| attr.doc_str().is_some())\n+                .map(|attr| attr.span.ctxt().outer_expn().expansion_cause().unwrap_or(attr.span))\n                 .unwrap_or(DUMMY_SP);\n             self.collector.set_position(span);\n             markdown::find_testable_code("}, {"sha": "0ec8523222fbef9277446022a482d886d7ffd7d4", "filename": "tests/rustdoc-ui/issue-109282-import-inline-merge.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52c8084f912e3728b8b06ae7e077521dba89d326/tests%2Frustdoc-ui%2Fissue-109282-import-inline-merge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c8084f912e3728b8b06ae7e077521dba89d326/tests%2Frustdoc-ui%2Fissue-109282-import-inline-merge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-109282-import-inline-merge.rs?ref=52c8084f912e3728b8b06ae7e077521dba89d326", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/109282>.\n+// Import for `ValueEnum` is inlined and doc comments on the import and `ValueEnum` itself are\n+// merged. After the merge they still have correct parent scopes to resolve both `[ValueEnum]`.\n+\n+// check-pass\n+\n+mod m {\n+    pub enum ValueEnum {}\n+}\n+mod m2 {\n+    /// [`ValueEnum`]\n+    pub use crate::m::ValueEnum;\n+}\n+pub use m2::ValueEnum;"}]}