{"sha": "5bac0c39857c786bdda68c3b48082668835da933", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYWMwYzM5ODU3Yzc4NmJkZGE2OGMzYjQ4MDgyNjY4ODM1ZGE5MzM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-06-16T23:12:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-16T23:12:04Z"}, "message": "Rollup merge of #34307 - nagisa:more-cache, r=arielb1\n\n[MIR] Cache drops for early scope exits\n\nPreviously we would rebuild all drops on every early exit from a scope, which for code like:\n\n```rust\nmatch x {\n    A => return 1,\n    B => return 2,\n    ...\n    C => return 27\n}\n```\n\nwould produce 27 exactly same chains of drops for each return, basically a `O(n*m)` explosion. [This](https://cloud.githubusercontent.com/assets/679122/16125192/3355e32c-33fb-11e6-8564-c37cab2477a0.png) is such a case for a match on 80-variant enum with 3 droppable variables in scope.\n\nFor [`::core::iter::Iterator::partial_cmp`](https://github.com/rust-lang/rust/blob/6edea2cfda2818f0a76f4bac2d18a30feb54c137/src/libcore/iter/iterator.rs#L1909) the CFG looked like [this](https://cloud.githubusercontent.com/assets/679122/16122708/ce0024d8-33f0-11e6-93c2-e1c44b910db2.png) (after initial SimplifyCfg). With this patch the CFG looks like [this](https://cloud.githubusercontent.com/assets/679122/16122806/294fb16e-33f1-11e6-95f6-16c5438231af.png) instead.\n\nSome numbers (overall very small wins, however neither of the crates have many cases which abuse this corner case):\n\n|                         | old time | old rss | new time | new rss  |\n|-------------------------|----------|---------|----------|----------|\n| core dump               | 0.879        |   224MB     |   0.871  |  223MB   |\n| core MIR passes         | 0.759        | 224MB       | 0.718    | 223MB    |\n| core MIR codegen passes | 1.762        | 230MB       | 1.442    | 228MB    |\n| core trans              | 3.263        | 279MB       | 3.116    | 278MB    |\n| core llvm passes        | 5.611        | 263MB       | 5.565    | 263MB    |\n| std dump                | 0.487        |   190MB     |   0.475  |  192MB   |\n| std MIR passes          | 0.311       | 190MB       | 0.288    | 192MB    |\n| std MIR codegen passes  | 0.753        | 195MB       | 0.720    | 197MB    |\n| std trans               | 2.589        | 287MB       | 2.523    | 287MB    |\n| std llvm passes         | 7.268        | 245MB       | 7.447    | 246MB    |", "tree": {"sha": "32df8df5471625cff24224e11481cabece8d0cf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32df8df5471625cff24224e11481cabece8d0cf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bac0c39857c786bdda68c3b48082668835da933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bac0c39857c786bdda68c3b48082668835da933", "html_url": "https://github.com/rust-lang/rust/commit/5bac0c39857c786bdda68c3b48082668835da933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bac0c39857c786bdda68c3b48082668835da933/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51b20bcbf4c8990d31b8acbc5071db7eaecac560", "url": "https://api.github.com/repos/rust-lang/rust/commits/51b20bcbf4c8990d31b8acbc5071db7eaecac560", "html_url": "https://github.com/rust-lang/rust/commit/51b20bcbf4c8990d31b8acbc5071db7eaecac560"}, {"sha": "04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe", "html_url": "https://github.com/rust-lang/rust/commit/04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe"}], "stats": {"total": 57, "additions": 30, "deletions": 27}, "files": [{"sha": "65457a9cc80d6e8c57dc96e1fcffd9cb0bb4456b", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5bac0c39857c786bdda68c3b48082668835da933/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bac0c39857c786bdda68c3b48082668835da933/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=5bac0c39857c786bdda68c3b48082668835da933", "patch": "@@ -94,6 +94,7 @@ use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::fnv::FnvHashMap;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n@@ -127,12 +128,8 @@ pub struct Scope<'tcx> {\n     /// stage.\n     free: Option<FreeData<'tcx>>,\n \n-    /// The cached block for the cleanups-on-diverge path. This block\n-    /// contains a block that will just do a RESUME to an appropriate\n-    /// place. This block does not execute any of the drops or free:\n-    /// each of those has their own cached-blocks, which will branch\n-    /// to this point.\n-    cached_block: Option<BasicBlock>\n+    /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n+    cached_exits: FnvHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -172,7 +169,7 @@ pub struct LoopScope {\n     pub continue_block: BasicBlock,\n     /// Block to branch into when the loop terminates (either by being `break`-en out from, or by\n     /// having its condition to become false)\n-    pub break_block: BasicBlock, // where to go on a `break\n+    pub break_block: BasicBlock,\n     /// Indicates the reachability of the break_block for this loop\n     pub might_break: bool\n }\n@@ -183,7 +180,7 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     fn invalidate_cache(&mut self) {\n-        self.cached_block = None;\n+        self.cached_exits = FnvHashMap();\n         for dropdata in &mut self.drops {\n             dropdata.cached_block = None;\n         }\n@@ -192,7 +189,7 @@ impl<'tcx> Scope<'tcx> {\n         }\n     }\n \n-    /// Returns the cached block for this scope.\n+    /// Returns the cached entrypoint for diverging exit from this scope.\n     ///\n     /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n     /// this method to work correctly.\n@@ -270,7 +267,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             extent: extent,\n             drops: vec![],\n             free: None,\n-            cached_block: None,\n+            cached_exits: FnvHashMap()\n         });\n         self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,\n@@ -314,13 +311,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                       .unwrap_or_else(||{\n             span_bug!(span, \"extent {:?} does not enclose\", extent)\n         });\n-\n+        let len = self.scopes.len();\n+        assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n         let tmp = self.get_unit_temp();\n-        for (idx, ref scope) in self.scopes.iter().enumerate().rev().take(scope_count) {\n-            unpack!(block = build_scope_drops(&mut self.cfg,\n-                                              scope,\n-                                              &self.scopes[..idx],\n-                                              block));\n+        {\n+        let mut rest = &mut self.scopes[(len - scope_count)..];\n+        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n+            rest = rest_;\n+            block = if let Some(&e) = scope.cached_exits.get(&(target, extent)) {\n+                self.cfg.terminate(block, scope.source_info(span),\n+                                   TerminatorKind::Goto { target: e });\n+                return;\n+            } else {\n+                let b = self.cfg.start_new_block();\n+                self.cfg.terminate(block, scope.source_info(span),\n+                                   TerminatorKind::Goto { target: b });\n+                scope.cached_exits.insert((target, extent), b);\n+                b\n+            };\n+            unpack!(block = build_scope_drops(&mut self.cfg, scope, rest, block));\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n@@ -331,14 +340,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 .postdoms\n                 .push(self.cfg.current_location(block));\n         }\n-\n-        assert!(scope_count < self.scopes.len(),\n-                \"should never use `exit_scope` to pop *ALL* scopes\");\n-        let scope = self.scopes.iter().rev().skip(scope_count)\n-                                            .next()\n-                                            .unwrap();\n-        self.cfg.terminate(block,\n-                           scope.source_info(span),\n+        }\n+        let scope = &self.scopes[len - scope_count];\n+        self.cfg.terminate(block, scope.source_info(span),\n                            TerminatorKind::Goto { target: target });\n     }\n \n@@ -506,10 +510,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             resumeblk\n         };\n \n-        for scope in scopes {\n+        for scope in scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some()) {\n             target = build_diverge_scope(hir.tcx(), cfg, &unit_temp, scope, target);\n         }\n-\n         Some(target)\n     }\n \n@@ -534,7 +537,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         next_target.unit()\n     }\n \n-\n+    /// Utility function for *non*-scope code to build their own drops\n     pub fn build_drop_and_replace(&mut self,\n                                   block: BasicBlock,\n                                   span: Span,"}]}