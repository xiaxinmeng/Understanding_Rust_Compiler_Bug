{"sha": "6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "node_id": "C_kwDOAAsO6NoAKDZhYzhhZGFkMWY3ZDczM2I1Yjk3ZDFkZjRlN2Y5NmU3M2E0NmRiNDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-25T01:12:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-25T01:12:54Z"}, "message": "Auto merge of #97365 - klensy:rustdoc-vs-clippy, r=notriddle\n\nrustdoc: fix few clippy lints\n\nFix few clippy lints: second commit - perf ones, first - other ones.", "tree": {"sha": "b38e4f7965d942c137750bf8837af62301c22372", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b38e4f7965d942c137750bf8837af62301c22372"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "html_url": "https://github.com/rust-lang/rust/commit/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f80e454450c891c075617d23532c6eb317f4471d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f80e454450c891c075617d23532c6eb317f4471d", "html_url": "https://github.com/rust-lang/rust/commit/f80e454450c891c075617d23532c6eb317f4471d"}, {"sha": "2a326bcc748edf03a2f64a7a154eab593688c0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a326bcc748edf03a2f64a7a154eab593688c0f6", "html_url": "https://github.com/rust-lang/rust/commit/2a326bcc748edf03a2f64a7a154eab593688c0f6"}], "stats": {"total": 209, "additions": 104, "deletions": 105}, "files": [{"sha": "79d7c414bd39bcd230742ac154596559f17f21df", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -643,11 +643,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     /// both for visual consistency between 'rustdoc' runs, and to\n     /// make writing tests much easier\n     #[inline]\n-    fn sort_where_predicates(&self, mut predicates: &mut Vec<WherePredicate>) {\n+    fn sort_where_predicates(&self, predicates: &mut Vec<WherePredicate>) {\n         // We should never have identical bounds - and if we do,\n         // they're visually identical as well. Therefore, using\n         // an unstable sort is fine.\n-        self.unstable_debug_sort(&mut predicates);\n+        self.unstable_debug_sort(predicates);\n     }\n \n     /// Ensure that the bounds are in a consistent order. The precise\n@@ -656,11 +656,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     /// both for visual consistency between 'rustdoc' runs, and to\n     /// make writing tests much easier\n     #[inline]\n-    fn sort_where_bounds(&self, mut bounds: &mut Vec<GenericBound>) {\n+    fn sort_where_bounds(&self, bounds: &mut Vec<GenericBound>) {\n         // We should never have identical bounds - and if we do,\n         // they're visually identical as well. Therefore, using\n         // an unstable sort is fine.\n-        self.unstable_debug_sort(&mut bounds);\n+        self.unstable_debug_sort(bounds);\n     }\n \n     /// This might look horrendously hacky, but it's actually not that bad."}, {"sha": "c725cf93be2f40e6138674f4971cd5576c93ed26", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -248,7 +248,7 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n             hir::WherePredicate::BoundPredicate(ref wbp) => {\n                 let bound_params = wbp\n                     .bound_generic_params\n-                    .into_iter()\n+                    .iter()\n                     .map(|param| {\n                         // Higher-ranked params must be lifetimes.\n                         // Higher-ranked lifetimes can't have bounds.\n@@ -525,7 +525,7 @@ fn clean_generic_param<'tcx>(\n                 },\n             )\n         }\n-        hir::GenericParamKind::Const { ref ty, default } => (\n+        hir::GenericParamKind::Const { ty, default } => (\n             param.name.ident().name,\n             GenericParamDefKind::Const {\n                 did: cx.tcx.hir().local_def_id(param.hir_id).to_def_id(),\n@@ -947,7 +947,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n     // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,\n     // but shouldn't change any code meaning.\n     let output = match sig.skip_binder().output().clean(cx) {\n-        Type::Tuple(inner) if inner.len() == 0 => DefaultReturn,\n+        Type::Tuple(inner) if inner.is_empty() => DefaultReturn,\n         ty => Return(ty),\n     };\n \n@@ -972,7 +972,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> FnRetTy {\n         match *self {\n-            Self::Return(ref typ) => Return(typ.clean(cx)),\n+            Self::Return(typ) => Return(typ.clean(cx)),\n             Self::DefaultReturn(..) => DefaultReturn,\n         }\n     }\n@@ -1013,13 +1013,13 @@ impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n-                hir::TraitItemKind::Const(ref ty, Some(default)) => AssocConstItem(\n+                hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n                     ty.clean(cx),\n                     ConstantKind::Local { def_id: local_did, body: default },\n                 ),\n-                hir::TraitItemKind::Const(ref ty, None) => TyAssocConstItem(ty.clean(cx)),\n+                hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(ty.clean(cx)),\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    let m = clean_function(cx, sig, &self.generics, body);\n+                    let m = clean_function(cx, sig, self.generics, body);\n                     MethodItem(m, None)\n                 }\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n@@ -1060,16 +1060,16 @@ impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n-                hir::ImplItemKind::Const(ref ty, expr) => {\n+                hir::ImplItemKind::Const(ty, expr) => {\n                     let default = ConstantKind::Local { def_id: local_did, body: expr };\n                     AssocConstItem(ty.clean(cx), default)\n                 }\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n-                    let m = clean_function(cx, sig, &self.generics, body);\n+                    let m = clean_function(cx, sig, self.generics, body);\n                     let defaultness = cx.tcx.associated_item(self.def_id).defaultness;\n                     MethodItem(m, Some(defaultness))\n                 }\n-                hir::ImplItemKind::TyAlias(ref hir_ty) => {\n+                hir::ImplItemKind::TyAlias(hir_ty) => {\n                     let type_ = hir_ty.clean(cx);\n                     let generics = self.generics.clean(cx);\n                     let item_type = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n@@ -1292,7 +1292,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n     let hir::TyKind::Path(qpath) = kind else { unreachable!() };\n \n     match qpath {\n-        hir::QPath::Resolved(None, ref path) => {\n+        hir::QPath::Resolved(None, path) => {\n             if let Res::Def(DefKind::TyParam, did) = path.res {\n                 if let Some(new_ty) = cx.substs.get(&did).and_then(|p| p.as_ty()).cloned() {\n                     return new_ty;\n@@ -1309,7 +1309,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 resolve_type(cx, path)\n             }\n         }\n-        hir::QPath::Resolved(Some(ref qself), p) => {\n+        hir::QPath::Resolved(Some(qself), p) => {\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let Some(normalized_value) = normalize(cx, ty) {\n@@ -1333,7 +1333,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 trait_,\n             }\n         }\n-        hir::QPath::TypeRelative(ref qself, segment) => {\n+        hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             let res = match ty.kind() {\n                 ty::Projection(proj) => Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id),\n@@ -1463,8 +1463,8 @@ impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n                 let lifetime = if elided { None } else { Some(l.clean(cx)) };\n                 BorrowedRef { lifetime, mutability: m.mutbl, type_: box m.ty.clean(cx) }\n             }\n-            TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n-            TyKind::Array(ref ty, ref length) => {\n+            TyKind::Slice(ty) => Slice(box ty.clean(cx)),\n+            TyKind::Array(ty, ref length) => {\n                 let length = match length {\n                     hir::ArrayLen::Infer(_, _) => \"_\".to_string(),\n                     hir::ArrayLen::Body(anon_const) => {\n@@ -1499,7 +1499,7 @@ impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n                 let lifetime = if !lifetime.is_elided() { Some(lifetime.clean(cx)) } else { None };\n                 DynTrait(bounds, lifetime)\n             }\n-            TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n+            TyKind::BareFn(barefn) => BareFunction(box barefn.clean(cx)),\n             // Rustdoc handles `TyKind::Err`s by turning them into `Type::Infer`s.\n             TyKind::Infer | TyKind::Err => Infer,\n             TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.kind),\n@@ -1908,7 +1908,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 bounds: ty.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n                 generics: ty.generics.clean(cx),\n             }),\n-            ItemKind::TyAlias(hir_ty, ref generics) => {\n+            ItemKind::TyAlias(hir_ty, generics) => {\n                 let rustdoc_ty = hir_ty.clean(cx);\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n                 TypedefItem(Typedef {\n@@ -1917,26 +1917,26 @@ fn clean_maybe_renamed_item<'tcx>(\n                     item_type: Some(ty),\n                 })\n             }\n-            ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n+            ItemKind::Enum(ref def, generics) => EnumItem(Enum {\n                 variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n                 generics: generics.clean(cx),\n             }),\n-            ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n+            ItemKind::TraitAlias(generics, bounds) => TraitAliasItem(TraitAlias {\n                 generics: generics.clean(cx),\n                 bounds: bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n             }),\n-            ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n+            ItemKind::Union(ref variant_data, generics) => UnionItem(Union {\n                 generics: generics.clean(cx),\n                 fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n             }),\n-            ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n+            ItemKind::Struct(ref variant_data, generics) => StructItem(Struct {\n                 struct_type: CtorKind::from_hir(variant_data),\n                 generics: generics.clean(cx),\n                 fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n             }),\n-            ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n+            ItemKind::Impl(impl_) => return clean_impl(impl_, item.hir_id(), cx),\n             // proc macros can have a name set by attributes\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+            ItemKind::Fn(ref sig, generics, body_id) => {\n                 clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n             }\n             ItemKind::Macro(ref macro_def, _) => {\n@@ -1945,7 +1945,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                     source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n                 })\n             }\n-            ItemKind::Trait(is_auto, unsafety, ref generics, bounds, item_ids) => {\n+            ItemKind::Trait(is_auto, unsafety, generics, bounds, item_ids) => {\n                 let items =\n                     item_ids.iter().map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx)).collect();\n                 TraitItem(Trait {\n@@ -2192,7 +2192,7 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n     let def_id = item.def_id.to_def_id();\n     cx.with_param_env(def_id, |cx| {\n         let kind = match item.kind {\n-            hir::ForeignItemKind::Fn(decl, names, ref generics) => {\n+            hir::ForeignItemKind::Fn(decl, names, generics) => {\n                 let (generics, decl) = enter_impl_trait(cx, |cx| {\n                     // NOTE: generics must be cleaned before args\n                     let generics = generics.clean(cx);\n@@ -2202,7 +2202,7 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n                 });\n                 ForeignFunctionItem(Function { decl, generics })\n             }\n-            hir::ForeignItemKind::Static(ref ty, mutability) => {\n+            hir::ForeignItemKind::Static(ty, mutability) => {\n                 ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: None })\n             }\n             hir::ForeignItemKind::Type => ForeignTypeItem,\n@@ -2232,7 +2232,7 @@ impl<'tcx> Clean<'tcx, TypeBindingKind> for hir::TypeBindingKind<'tcx> {\n             hir::TypeBindingKind::Equality { ref term } => {\n                 TypeBindingKind::Equality { term: term.clean(cx) }\n             }\n-            hir::TypeBindingKind::Constraint { ref bounds } => TypeBindingKind::Constraint {\n+            hir::TypeBindingKind::Constraint { bounds } => TypeBindingKind::Constraint {\n                 bounds: bounds.iter().filter_map(|b| b.clean(cx)).collect(),\n             },\n         }"}, {"sha": "f7700c433532d40473ced933b1ca3532abf73b1c", "filename": "src/librustdoc/clean/render_macro_matchers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -171,7 +171,7 @@ fn print_tts(printer: &mut Printer<'_>, tts: &TokenStream) {\n         if state != Start && needs_space {\n             printer.space();\n         }\n-        print_tt(printer, &tt);\n+        print_tt(printer, tt);\n         state = next_state;\n     }\n }"}, {"sha": "e10c61901d05a77aca755465b3e3021fc6330f77", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -880,7 +880,7 @@ impl AttributesExt for [ast::Attribute] {\n             let mut doc_cfg = self\n                 .iter()\n                 .filter(|attr| attr.has_name(sym::doc))\n-                .flat_map(|attr| attr.meta_item_list().unwrap_or_else(Vec::new))\n+                .flat_map(|attr| attr.meta_item_list().unwrap_or_default())\n                 .filter(|attr| attr.has_name(sym::cfg))\n                 .peekable();\n             if doc_cfg.peek().is_some() && doc_cfg_active {\n@@ -1011,7 +1011,7 @@ pub(crate) enum DocFragmentKind {\n fn add_doc_fragment(out: &mut String, frag: &DocFragment) {\n     let s = frag.doc.as_str();\n     let mut iter = s.lines();\n-    if s == \"\" {\n+    if s.is_empty() {\n         out.push('\\n');\n         return;\n     }\n@@ -1594,17 +1594,17 @@ impl Type {\n         match (self, other) {\n             // Recursive cases.\n             (Type::Tuple(a), Type::Tuple(b)) => {\n-                a.len() == b.len() && a.iter().zip(b).all(|(a, b)| a.is_same(&b, cache))\n+                a.len() == b.len() && a.iter().zip(b).all(|(a, b)| a.is_same(b, cache))\n             }\n-            (Type::Slice(a), Type::Slice(b)) => a.is_same(&b, cache),\n-            (Type::Array(a, al), Type::Array(b, bl)) => al == bl && a.is_same(&b, cache),\n+            (Type::Slice(a), Type::Slice(b)) => a.is_same(b, cache),\n+            (Type::Array(a, al), Type::Array(b, bl)) => al == bl && a.is_same(b, cache),\n             (Type::RawPointer(mutability, type_), Type::RawPointer(b_mutability, b_type_)) => {\n-                mutability == b_mutability && type_.is_same(&b_type_, cache)\n+                mutability == b_mutability && type_.is_same(b_type_, cache)\n             }\n             (\n                 Type::BorrowedRef { mutability, type_, .. },\n                 Type::BorrowedRef { mutability: b_mutability, type_: b_type_, .. },\n-            ) => mutability == b_mutability && type_.is_same(&b_type_, cache),\n+            ) => mutability == b_mutability && type_.is_same(b_type_, cache),\n             // Placeholders and generics are equal to all other types.\n             (Type::Infer, _) | (_, Type::Infer) => true,\n             (Type::Generic(_), _) | (_, Type::Generic(_)) => true,\n@@ -1667,7 +1667,7 @@ impl Type {\n \n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath { self_type, trait_, assoc, .. } = self {\n-            Some((&self_type, trait_.def_id(), *assoc.clone()))\n+            Some((self_type, trait_.def_id(), *assoc.clone()))\n         } else {\n             None\n         }"}, {"sha": "caea2544b54503a5b8ce3a7894eace5e8d520862", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -106,7 +106,7 @@ fn external_generic_args<'tcx>(\n     bindings: Vec<TypeBinding>,\n     substs: SubstsRef<'tcx>,\n ) -> GenericArgs {\n-    let args = substs_to_args(cx, &substs, has_self);\n+    let args = substs_to_args(cx, substs, has_self);\n \n     if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() {\n         let inputs ="}, {"sha": "e59324331ae340033e019cd0fed8970140173b22", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -667,7 +667,7 @@ impl Options {\n             return Err(1);\n         }\n \n-        let scrape_examples_options = ScrapeExamplesOptions::new(&matches, &diag)?;\n+        let scrape_examples_options = ScrapeExamplesOptions::new(matches, &diag)?;\n         let with_examples = matches.opt_strs(\"with-examples\");\n         let call_locations = crate::scrape_examples::load_call_locations(with_examples, &diag)?;\n "}, {"sha": "a4ec4052e0567ac0c61c25814c9f49aab34f9688", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -228,7 +228,7 @@ fn scrape_test_config(attrs: &[ast::Attribute]) -> GlobalTestOptions {\n     let test_attrs: Vec<_> = attrs\n         .iter()\n         .filter(|a| a.has_name(sym::doc))\n-        .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n+        .flat_map(|a| a.meta_item_list().unwrap_or_default())\n         .filter(|a| a.has_name(sym::test))\n         .collect();\n     let attrs = test_attrs.iter().flat_map(|a| a.meta_item_list().unwrap_or(&[]));\n@@ -738,7 +738,7 @@ fn check_if_attr_is_complete(source: &str, edition: Edition) -> bool {\n             }\n         };\n         // If a parsing error happened, it's very likely that the attribute is incomplete.\n-        if !parser.parse_attribute(InnerAttrPolicy::Permitted).is_ok() {\n+        if parser.parse_attribute(InnerAttrPolicy::Permitted).is_err() {\n             return false;\n         }\n         // We now check if there is an unclosed delimiter for the attribute. To do so, we look at"}, {"sha": "09aa042b1d02f5309893a5d5615ea2cdd226535c", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -456,7 +456,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         let ty::Adt(adt, _) = self.tcx.type_of(path.def_id()).kind() &&\n                         adt.is_fundamental() {\n                         for ty in generics {\n-                            if let Some(did) = ty.def_id(&self.cache) {\n+                            if let Some(did) = ty.def_id(self.cache) {\n                                 dids.insert(did);\n                             }\n                         }"}, {"sha": "30946834583213b4fd7275eaf17d1e1a2b28b9e8", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -5,6 +5,7 @@\n //! assume that HTML output is desired, although it may be possible to redesign\n //! them in the future to instead emit any format desired.\n \n+use std::borrow::Cow;\n use std::cell::Cell;\n use std::fmt;\n use std::iter;\n@@ -545,10 +546,10 @@ pub(crate) enum HrefError {\n // Panics if `syms` is empty.\n pub(crate) fn join_with_double_colon(syms: &[Symbol]) -> String {\n     let mut s = String::with_capacity(estimate_item_path_byte_length(syms.len()));\n-    s.push_str(&syms[0].as_str());\n+    s.push_str(syms[0].as_str());\n     for sym in &syms[1..] {\n         s.push_str(\"::\");\n-        s.push_str(&sym.as_str());\n+        s.push_str(sym.as_str());\n     }\n     s\n }\n@@ -1069,7 +1070,7 @@ impl clean::Impl {\n                 write!(f, \" for \")?;\n             }\n \n-            if let Some(ref ty) = self.kind.as_blanket_ty() {\n+            if let Some(ty) = self.kind.as_blanket_ty() {\n                 fmt_type(ty, f, use_absolute, cx)?;\n             } else {\n                 fmt_type(&self.for_, f, use_absolute, cx)?;\n@@ -1295,27 +1296,28 @@ impl clean::Visibility {\n         item_did: ItemId,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        let to_print = match self {\n-            clean::Public => \"pub \".to_owned(),\n-            clean::Inherited => String::new(),\n+        use std::fmt::Write as _;\n+\n+        let to_print: Cow<'static, str> = match self {\n+            clean::Public => \"pub \".into(),\n+            clean::Inherited => \"\".into(),\n             clean::Visibility::Restricted(vis_did) => {\n                 // FIXME(camelid): This may not work correctly if `item_did` is a module.\n                 //                 However, rustdoc currently never displays a module's\n                 //                 visibility, so it shouldn't matter.\n                 let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_def_id());\n \n                 if vis_did.is_crate_root() {\n-                    \"pub(crate) \".to_owned()\n+                    \"pub(crate) \".into()\n                 } else if parent_module == Some(vis_did) {\n                     // `pub(in foo)` where `foo` is the parent module\n                     // is the same as no visibility modifier\n-                    String::new()\n+                    \"\".into()\n                 } else if parent_module\n-                    .map(|parent| find_nearest_parent_module(cx.tcx(), parent))\n-                    .flatten()\n+                    .and_then(|parent| find_nearest_parent_module(cx.tcx(), parent))\n                     == Some(vis_did)\n                 {\n-                    \"pub(super) \".to_owned()\n+                    \"pub(super) \".into()\n                 } else {\n                     let path = cx.tcx().def_path(vis_did);\n                     debug!(\"path={:?}\", path);\n@@ -1325,14 +1327,14 @@ impl clean::Visibility {\n \n                     let mut s = \"pub(in \".to_owned();\n                     for seg in &path.data[..path.data.len() - 1] {\n-                        s.push_str(&format!(\"{}::\", seg.data.get_opt_name().unwrap()));\n+                        let _ = write!(s, \"{}::\", seg.data.get_opt_name().unwrap());\n                     }\n-                    s.push_str(&format!(\"{}) \", anchor));\n-                    s\n+                    let _ = write!(s, \"{}) \", anchor);\n+                    s.into()\n                 }\n             }\n         };\n-        display_fn(move |f| f.write_str(&to_print))\n+        display_fn(move |f| write!(f, \"{}\", to_print))\n     }\n \n     /// This function is the same as print_with_space, except that it renders no links.\n@@ -1358,9 +1360,7 @@ impl clean::Visibility {\n                     // `pub(in foo)` where `foo` is the parent module\n                     // is the same as no visibility modifier\n                     String::new()\n-                } else if parent_module\n-                    .map(|parent| find_nearest_parent_module(tcx, parent))\n-                    .flatten()\n+                } else if parent_module.and_then(|parent| find_nearest_parent_module(tcx, parent))\n                     == Some(vis_did)\n                 {\n                     \"pub(super) \".to_owned()"}, {"sha": "91733004e44c3517285250a51ceff1fb4c6938d7", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -1023,7 +1023,7 @@ impl Markdown<'_> {\n         let Markdown {\n             content: md,\n             links,\n-            mut ids,\n+            ids,\n             error_codes: codes,\n             edition,\n             playground,\n@@ -1046,7 +1046,7 @@ impl Markdown<'_> {\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        let p = HeadingLinks::new(p, None, &mut ids, heading_offset);\n+        let p = HeadingLinks::new(p, None, ids, heading_offset);\n         let p = Footnotes::new(p);\n         let p = LinkReplacer::new(p.map(|(ev, _)| ev), links);\n         let p = TableWrapper::new(p);\n@@ -1059,7 +1059,7 @@ impl Markdown<'_> {\n \n impl MarkdownWithToc<'_> {\n     pub(crate) fn into_string(self) -> String {\n-        let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n+        let MarkdownWithToc(md, ids, codes, edition, playground) = self;\n \n         let p = Parser::new_ext(md, main_body_opts()).into_offset_iter();\n \n@@ -1068,7 +1068,7 @@ impl MarkdownWithToc<'_> {\n         let mut toc = TocBuilder::new();\n \n         {\n-            let p = HeadingLinks::new(p, Some(&mut toc), &mut ids, HeadingOffset::H1);\n+            let p = HeadingLinks::new(p, Some(&mut toc), ids, HeadingOffset::H1);\n             let p = Footnotes::new(p);\n             let p = TableWrapper::new(p.map(|(ev, _)| ev));\n             let p = CodeBlocks::new(p, codes, edition, playground);\n@@ -1081,7 +1081,7 @@ impl MarkdownWithToc<'_> {\n \n impl MarkdownHtml<'_> {\n     pub(crate) fn into_string(self) -> String {\n-        let MarkdownHtml(md, mut ids, codes, edition, playground) = self;\n+        let MarkdownHtml(md, ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n         if md.is_empty() {\n@@ -1097,7 +1097,7 @@ impl MarkdownHtml<'_> {\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        let p = HeadingLinks::new(p, None, &mut ids, HeadingOffset::H1);\n+        let p = HeadingLinks::new(p, None, ids, HeadingOffset::H1);\n         let p = Footnotes::new(p);\n         let p = TableWrapper::new(p.map(|(ev, _)| ev));\n         let p = CodeBlocks::new(p, codes, edition, playground);"}, {"sha": "da4273345cb0353157c5e7a800806e556949ac32", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -232,18 +232,18 @@ impl<'tcx> Context<'tcx> {\n \n                     let mut path = String::new();\n                     for name in &names[..names.len() - 1] {\n-                        path.push_str(&name.as_str());\n+                        path.push_str(name.as_str());\n                         path.push('/');\n                     }\n-                    path.push_str(&item_path(ty, &names.last().unwrap().as_str()));\n+                    path.push_str(&item_path(ty, names.last().unwrap().as_str()));\n                     match self.shared.redirections {\n                         Some(ref redirections) => {\n                             let mut current_path = String::new();\n                             for name in &self.current {\n-                                current_path.push_str(&name.as_str());\n+                                current_path.push_str(name.as_str());\n                                 current_path.push('/');\n                             }\n-                            current_path.push_str(&item_path(ty, &names.last().unwrap().as_str()));\n+                            current_path.push_str(&item_path(ty, names.last().unwrap().as_str()));\n                             redirections.borrow_mut().insert(current_path, path);\n                         }\n                         None => return layout::redirect(&format!(\"{}{}\", self.root_path(), path)),"}, {"sha": "3809738cc336659a717dabe048902602aa04a547", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -840,7 +840,7 @@ fn render_stability_since_raw(\n     let mut stability = String::new();\n \n     if let Some(ver) = stable_version {\n-        stability.push_str(&ver.as_str());\n+        stability.push_str(ver.as_str());\n         title.push_str(&format!(\"Stable since Rust version {}\", ver));\n     }\n \n@@ -2299,7 +2299,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n                 buf,\n                 \"foreign-impls\",\n                 \"Implementations on Foreign Types\",\n-                res.iter().map(|(name, id)| format!(\"<a href=\\\"#{}\\\">{}</a>\", id, Escape(&name))),\n+                res.iter().map(|(name, id)| format!(\"<a href=\\\"#{}\\\">{}</a>\", id, Escape(name))),\n             );\n         }\n     }\n@@ -2537,6 +2537,8 @@ fn item_ty_to_section(ty: ItemType) -> ItemSection {\n }\n \n fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n+    use std::fmt::Write as _;\n+\n     let mut sidebar = String::new();\n \n     let item_sections_in_use: FxHashSet<_> = items\n@@ -2554,7 +2556,7 @@ fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n         .map(|it| item_ty_to_section(it.type_()))\n         .collect();\n     for &sec in ItemSection::ALL.iter().filter(|sec| item_sections_in_use.contains(sec)) {\n-        sidebar.push_str(&format!(\"<li><a href=\\\"#{}\\\">{}</a></li>\", sec.id(), sec.name()));\n+        let _ = write!(sidebar, \"<li><a href=\\\"#{}\\\">{}</a></li>\", sec.id(), sec.name());\n     }\n \n     if !sidebar.is_empty() {\n@@ -2798,7 +2800,7 @@ fn render_call_locations(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item) {\n             hi - lo\n         };\n \n-        let mut locs = call_locations.into_iter().collect::<Vec<_>>();\n+        let mut locs = call_locations.iter().collect::<Vec<_>>();\n         locs.sort_by_key(sort_criterion);\n         locs\n     };\n@@ -2842,7 +2844,7 @@ fn render_call_locations(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item) {\n         if it.peek().is_some() {\n             write!(w, r#\"<div class=\"example-links\">Additional examples can be found in:<br><ul>\"#);\n             it.for_each(|(_, call_data)| {\n-                let (url, _) = link_to_loc(&call_data, &call_data.locations[0]);\n+                let (url, _) = link_to_loc(call_data, &call_data.locations[0]);\n                 write!(\n                     w,\n                     r#\"<li><a href=\"{url}\">{name}</a></li>\"#,"}, {"sha": "3daef3dbb79471e148b75ecfbe514d0ad55d140d", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -37,7 +37,7 @@ pub(crate) fn build_index<'tcx>(\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_function_type_for_search(item, tcx, &cache),\n+                search_type: get_function_type_for_search(item, tcx, cache),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -182,8 +182,8 @@ pub(crate) fn build_index<'tcx>(\n         })\n         .expect(\"failed serde conversion\")\n         // All these `replace` calls are because we have to go through JS string for JSON content.\n-        .replace(r#\"\\\"#, r\"\\\\\")\n-        .replace(r#\"'\"#, r\"\\'\")\n+        .replace('\\\\', r\"\\\\\")\n+        .replace('\\'', r\"\\'\")\n         // We need to escape double quotes for the JSON.\n         .replace(\"\\\\\\\"\", \"\\\\\\\\\\\"\")\n     )"}, {"sha": "86961dc3bf149ed48f01ecbec6a05697b989c731", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -49,7 +49,7 @@ pub(crate) fn collect_spans_and_sources(\n         if generate_link_to_definition {\n             tcx.hir().walk_toplevel_module(&mut visitor);\n         }\n-        let sources = sources::collect_local_sources(tcx, src_root, &krate);\n+        let sources = sources::collect_local_sources(tcx, src_root, krate);\n         (sources, visitor.matches)\n     } else {\n         (Default::default(), Default::default())"}, {"sha": "a12c2a6a16c32f15ba951310a5af304f855bf3e0", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -163,15 +163,18 @@ impl TocBuilder {\n \n impl Toc {\n     fn print_inner(&self, v: &mut String) {\n+        use std::fmt::Write as _;\n+\n         v.push_str(\"<ul>\");\n         for entry in &self.entries {\n             // recursively format this table of contents\n-            v.push_str(&format!(\n+            let _ = write!(\n+                v,\n                 \"\\n<li><a href=\\\"#{id}\\\">{num} {name}</a>\",\n                 id = entry.id,\n                 num = entry.sec_number,\n                 name = entry.name\n-            ));\n+            );\n             entry.children.print_inner(&mut *v);\n             v.push_str(\"</li>\");\n         }"}, {"sha": "4c6e3eb040d270cc061b8e49f01909b80ca91f8d", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -265,7 +265,7 @@ impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n                 self.items.entry(filename).or_default().count_item(\n                     has_docs,\n                     has_doc_example,\n-                    should_have_doc_example(self.ctx, &i),\n+                    should_have_doc_example(self.ctx, i),\n                     should_have_docs,\n                 );\n             }"}, {"sha": "9cc006b10ffc4358ecce8ece565b21314b4a5d94", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -160,7 +160,7 @@ impl<'a, 'tcx> DocVisitor for SyntaxChecker<'a, 'tcx> {\n                 sp,\n             );\n             for code_block in markdown::rust_code_blocks(dox, &extra) {\n-                self.check_rust_syntax(&item, dox, code_block);\n+                self.check_rust_syntax(item, dox, code_block);\n             }\n         }\n "}, {"sha": "735a077fe1f6b249add3f5bd38109ef623edf156", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -35,9 +35,9 @@ pub(crate) fn check_doc_test_visibility(krate: Crate, cx: &mut DocContext<'_>) -\n \n impl<'a, 'tcx> DocVisitor for DocTestVisibilityLinter<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n+        let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n \n-        look_for_tests(self.cx, &dox, &item);\n+        look_for_tests(self.cx, &dox, item);\n \n         self.visit_item_recur(item)\n     }"}, {"sha": "ab57005abc4fd9b604ea6c5da4934c7973546b13", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -494,7 +494,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Variant,\n                     def_id,\n                 ) => (Res::from_def_id(self.cx.tcx, self.cx.tcx.parent(def_id)), Some(def_id)),\n-                _ => ((res, None)),\n+                _ => (res, None),\n             });\n         } else if ns == MacroNS {\n             return Err(UnresolvedPath {\n@@ -636,10 +636,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             Res::Primitive(prim) => {\n                 self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n                     self.primitive_type_to_ty(prim)\n-                        .map(|ty| {\n+                        .and_then(|ty| {\n                             resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n                         })\n-                        .flatten()\n                         .map(|item| (root_res, item.def_id))\n                 })\n             }\n@@ -903,7 +902,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n                 tmp_links.insert(doc.clone(), preprocessed_markdown_links(&doc));\n             }\n             for md_link in &tmp_links[&doc] {\n-                let link = self.resolve_link(&item, &doc, parent_node, md_link);\n+                let link = self.resolve_link(item, &doc, parent_node, md_link);\n                 if let Some(link) = link {\n                     self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n                 }\n@@ -1136,7 +1135,7 @@ impl LinkCollector<'_, '_> {\n                     let kind = self.cx.tcx.def_kind(id);\n                     self.verify_disambiguator(\n                         path_str,\n-                        &ori_link,\n+                        ori_link,\n                         kind,\n                         id,\n                         disambiguator,\n@@ -1150,14 +1149,14 @@ impl LinkCollector<'_, '_> {\n                         && item.item_id.is_local()\n                         && !self.cx.tcx.features().intra_doc_pointers\n                     {\n-                        self.report_rawptr_assoc_feature_gate(dox, &ori_link, item);\n+                        self.report_rawptr_assoc_feature_gate(dox, ori_link, item);\n                     }\n                 } else {\n                     match disambiguator {\n                         Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n                         Some(other) => {\n                             self.report_disambiguator_mismatch(\n-                                path_str, &ori_link, other, res, &diag_info,\n+                                path_str, ori_link, other, res, &diag_info,\n                             );\n                             return None;\n                         }\n@@ -1180,7 +1179,7 @@ impl LinkCollector<'_, '_> {\n                     };\n                 self.verify_disambiguator(\n                     path_str,\n-                    &ori_link,\n+                    ori_link,\n                     kind_for_dis,\n                     id_for_dis,\n                     disambiguator,\n@@ -1274,7 +1273,7 @@ impl LinkCollector<'_, '_> {\n             }\n             suggest_disambiguator(resolved, diag, path_str, &ori_link.link, sp);\n         };\n-        report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, callback);\n+        report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, diag_info, callback);\n     }\n \n     fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &MarkdownLink, item: &Item) {\n@@ -1930,7 +1929,7 @@ fn anchor_failure(\n     msg: &str,\n     anchor_idx: usize,\n ) {\n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, sp| {\n         if let Some(mut sp) = sp {\n             if let Some((fragment_offset, _)) =\n                 diag_info.ori_link.char_indices().filter(|(_, x)| *x == '#').nth(anchor_idx)"}, {"sha": "d8ad299c3d38b51476eeab57f639896d45b57570", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -91,11 +91,7 @@ fn extract_path_backwards(text: &str, end_pos: usize) -> Option<usize> {\n         }\n         break;\n     }\n-    if current_pos == end_pos {\n-        return None;\n-    } else {\n-        return Some(current_pos);\n-    }\n+    if current_pos == end_pos { None } else { Some(current_pos) }\n }\n \n fn extract_html_tag("}, {"sha": "75e1dd41a63e335a70c9d90c4a338be536fd039d", "filename": "src/librustdoc/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -11,7 +11,6 @@ pub(crate) trait DocVisitor: Sized {\n             StrippedItem(..) => unreachable!(),\n             ModuleItem(i) => {\n                 self.visit_mod(i);\n-                return;\n             }\n             StructItem(i) => i.fields.iter().for_each(|x| self.visit_item(x)),\n             UnionItem(i) => i.fields.iter().for_each(|x| self.visit_item(x)),"}, {"sha": "d57868caf7a3af7c621763089958e5d60f0f3d66", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac8adad1f7d733b5b97d1df4e7f96e73a46db42/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6ac8adad1f7d733b5b97d1df4e7f96e73a46db42", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     om.items.push((item, renamed));\n                 }\n             }\n-            hir::ItemKind::Impl(ref impl_) => {\n+            hir::ItemKind::Impl(impl_) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && impl_.of_trait.is_none() {"}]}