{"sha": "fc06f7922db0b4d1063f4f29157635117d853426", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMDZmNzkyMmRiMGI0ZDEwNjNmNGYyOTE1NzYzNTExN2Q4NTM0MjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-13T03:00:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-16T05:27:10Z"}, "message": "Build a few extra features into format! parsing\n\n* Allow named parameters to specify width/precision\n* Intepret the format string '0$' as \"width is the 0th argument\" instead of\n  thinking the lone '0' was the sign-aware-zero-padding flag. To get both you'd\n  need to put '00$' which makes more sense if you want both to happen.\n\nCloses #9669", "tree": {"sha": "ab33cac38ef9012c89c84a28054eab7bd364cabc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab33cac38ef9012c89c84a28054eab7bd364cabc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc06f7922db0b4d1063f4f29157635117d853426", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc06f7922db0b4d1063f4f29157635117d853426", "html_url": "https://github.com/rust-lang/rust/commit/fc06f7922db0b4d1063f4f29157635117d853426", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc06f7922db0b4d1063f4f29157635117d853426/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a84c2999c91f6ea43291006288ea6dd8c4852c3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a84c2999c91f6ea43291006288ea6dd8c4852c3b", "html_url": "https://github.com/rust-lang/rust/commit/a84c2999c91f6ea43291006288ea6dd8c4852c3b"}], "stats": {"total": 178, "additions": 155, "deletions": 23}, "files": [{"sha": "4032515f985e3b1a0a5d9d2f24d55057b6bfcadf", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fc06f7922db0b4d1063f4f29157635117d853426/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06f7922db0b4d1063f4f29157635117d853426/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=fc06f7922db0b4d1063f4f29157635117d853426", "patch": "@@ -647,21 +647,6 @@ impl<'self> Formatter<'self> {\n     // the format! syntax extension.\n \n     fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n-        let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {\n-            match *cnt {\n-                parse::CountIs(n) => { *slot = Some(n); }\n-                parse::CountImplied => { *slot = None; }\n-                parse::CountIsParam(i) => {\n-                    let v = self.args[i].value;\n-                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }\n-                }\n-                parse::CountIsNextParam => {\n-                    let v = self.curarg.next().unwrap().value;\n-                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }\n-                }\n-            }\n-        };\n-\n         match *piece {\n             rt::String(s) => { self.buf.write(s.as_bytes()); }\n             rt::CurrentArgument(()) => { self.buf.write(cur.unwrap().as_bytes()); }\n@@ -670,8 +655,8 @@ impl<'self> Formatter<'self> {\n                 self.fill = arg.format.fill;\n                 self.align = arg.format.align;\n                 self.flags = arg.format.flags;\n-                setcount(&mut self.width, &arg.format.width);\n-                setcount(&mut self.precision, &arg.format.precision);\n+                self.width = self.getcount(&arg.format.width);\n+                self.precision = self.getcount(&arg.format.precision);\n \n                 // Extract the correct argument\n                 let value = match arg.position {\n@@ -688,6 +673,39 @@ impl<'self> Formatter<'self> {\n         }\n     }\n \n+    #[cfg(stage0)]\n+    fn getcount(&mut self, cnt: &parse::Count) -> Option<uint> {\n+        match *cnt {\n+            parse::CountIs(n) => { Some(n) }\n+            parse::CountImplied => { None }\n+            parse::CountIsParam(i) => {\n+                let v = self.args[i].value;\n+                unsafe { Some(*(v as *util::Void as *uint)) }\n+            }\n+            parse::CountIsNextParam => {\n+                let v = self.curarg.next().unwrap().value;\n+                unsafe { Some(*(v as *util::Void as *uint)) }\n+            }\n+            parse::CountIsName(*) => unreachable!()\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n+        match *cnt {\n+            rt::CountIs(n) => { Some(n) }\n+            rt::CountImplied => { None }\n+            rt::CountIsParam(i) => {\n+                let v = self.args[i].value;\n+                unsafe { Some(*(v as *util::Void as *uint)) }\n+            }\n+            rt::CountIsNextParam => {\n+                let v = self.curarg.next().unwrap().value;\n+                unsafe { Some(*(v as *util::Void as *uint)) }\n+            }\n+        }\n+    }\n+\n     fn execute(&mut self, method: &rt::Method, arg: Argument) {\n         match *method {\n             // Pluralization is selection upon a numeric value specified as the"}, {"sha": "11b869c930ef446504d0aa8122d85fafa6491be3", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fc06f7922db0b4d1063f4f29157635117d853426/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06f7922db0b4d1063f4f29157635117d853426/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=fc06f7922db0b4d1063f4f29157635117d853426", "patch": "@@ -48,6 +48,7 @@ pub struct Argument<'self> {\n \n /// Specification for the formatting of an argument in the format string.\n #[deriving(Eq)]\n+#[cfg(stage0)]\n pub struct FormatSpec<'self> {\n     /// Optionally specified character to fill alignment with\n     fill: Option<char>,\n@@ -65,6 +66,26 @@ pub struct FormatSpec<'self> {\n     ty: &'self str\n }\n \n+/// Specification for the formatting of an argument in the format string.\n+#[deriving(Eq)]\n+#[cfg(not(stage0))]\n+pub struct FormatSpec<'self> {\n+    /// Optionally specified character to fill alignment with\n+    fill: Option<char>,\n+    /// Optionally specified alignment\n+    align: Alignment,\n+    /// Packed version of various flags provided\n+    flags: uint,\n+    /// The integer precision to use\n+    precision: Count<'self>,\n+    /// The string width requested for the resulting format\n+    width: Count<'self>,\n+    /// The descriptor string representing the name of the format desired for\n+    /// this argument, this can be empty or any number of characters, although\n+    /// it is required to be one word.\n+    ty: &'self str\n+}\n+\n /// Enum describing where an argument for a format can be located.\n #[deriving(Eq)]\n #[allow(missing_doc)]\n@@ -92,9 +113,22 @@ pub enum Flag {\n /// can reference either an argument or a literal integer.\n #[deriving(Eq)]\n #[allow(missing_doc)]\n+#[cfg(stage0)]\n pub enum Count {\n     CountIs(uint),\n     CountIsParam(uint),\n+    CountIsName(&'static str), // not actually used, see stage1\n+    CountIsNextParam,\n+    CountImplied,\n+}\n+\n+#[deriving(Eq)]\n+#[allow(missing_doc)]\n+#[cfg(not(stage0))]\n+pub enum Count<'self> {\n+    CountIs(uint),\n+    CountIsName(&'self str),\n+    CountIsParam(uint),\n     CountIsNextParam,\n     CountImplied,\n }\n@@ -344,10 +378,22 @@ impl<'self> Parser<'self> {\n             spec.flags |= 1 << (FlagAlternate as uint);\n         }\n         // Width and precision\n+        let mut havewidth = false;\n         if self.consume('0') {\n-            spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+            // small ambiguity with '0$' as a format string. In theory this is a\n+            // '0' flag and then an ill-formatted format string with just a '$'\n+            // and no count, but this is better if we instead interpret this as\n+            // no '0' flag and '0$' as the width instead.\n+            if self.consume('$') {\n+                spec.width = CountIsParam(0);\n+                havewidth = true;\n+            } else {\n+                spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+            }\n+        }\n+        if !havewidth {\n+            spec.width = self.count();\n         }\n-        spec.width = self.count();\n         if self.consume('.') {\n             if self.consume('*') {\n                 spec.precision = CountIsNextParam;\n@@ -548,6 +594,7 @@ impl<'self> Parser<'self> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n+    #[cfg(stage0)]\n     fn count(&mut self) -> Count {\n         match self.integer() {\n             Some(i) => {\n@@ -560,6 +607,30 @@ impl<'self> Parser<'self> {\n             None => { CountImplied }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn count(&mut self) -> Count<'self> {\n+        match self.integer() {\n+            Some(i) => {\n+                if self.consume('$') {\n+                    CountIsParam(i)\n+                } else {\n+                    CountIs(i)\n+                }\n+            }\n+            None => {\n+                let tmp = self.cur.clone();\n+                match self.word() {\n+                    word if word.len() > 0 && self.consume('$') => {\n+                        CountIsName(word)\n+                    }\n+                    _ => {\n+                        self.cur = tmp;\n+                        CountImplied\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n     /// Parses a word starting at the current position. A word is considered to\n     /// be an alphabetic character followed by any number of alphanumeric\n@@ -783,6 +854,18 @@ mod tests {\n             },\n             method: None,\n         })]);\n+        same(\"{:a$.b$s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsName(\"b\"),\n+                width: CountIsName(\"a\"),\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n     }\n     #[test]\n     fn format_flags() {"}, {"sha": "063d712dfa9fe3492753e9091a5853b323bfb4b7", "filename": "src/libstd/fmt/rt.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fc06f7922db0b4d1063f4f29157635117d853426/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06f7922db0b4d1063f4f29157635117d853426/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=fc06f7922db0b4d1063f4f29157635117d853426", "patch": "@@ -34,6 +34,7 @@ pub struct Argument<'self> {\n     method: Option<&'self Method<'self>>\n }\n \n+#[cfg(stage0)]\n pub struct FormatSpec {\n     fill: char,\n     align: parse::Alignment,\n@@ -42,6 +43,20 @@ pub struct FormatSpec {\n     width: parse::Count,\n }\n \n+#[cfg(not(stage0))]\n+pub struct FormatSpec {\n+    fill: char,\n+    align: parse::Alignment,\n+    flags: uint,\n+    precision: Count,\n+    width: Count,\n+}\n+\n+#[cfg(not(stage0))]\n+pub enum Count {\n+    CountIs(uint), CountIsParam(uint), CountIsNextParam, CountImplied,\n+}\n+\n pub enum Position {\n     ArgumentNext, ArgumentIs(uint)\n }"}, {"sha": "31befed6c0cd4f1e195a35d80cdca81290448812", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc06f7922db0b4d1063f4f29157635117d853426/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06f7922db0b4d1063f4f29157635117d853426/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=fc06f7922db0b4d1063f4f29157635117d853426", "patch": "@@ -177,6 +177,9 @@ impl Context {\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Left(i), Unsigned);\n             }\n+            parse::CountIsName(s) => {\n+                self.verify_arg_type(Right(s.to_managed()), Unsigned);\n+            }\n             parse::CountIsNextParam => {\n                 if self.check_positional_ok() {\n                     self.verify_arg_type(Left(self.next_arg), Unsigned);\n@@ -361,21 +364,31 @@ impl Context {\n         let trans_count = |c: parse::Count| {\n             match c {\n                 parse::CountIs(i) => {\n-                    self.ecx.expr_call_global(sp, ctpath(\"CountIs\"),\n+                    self.ecx.expr_call_global(sp, rtpath(\"CountIs\"),\n                                               ~[self.ecx.expr_uint(sp, i)])\n                 }\n                 parse::CountIsParam(i) => {\n-                    self.ecx.expr_call_global(sp, ctpath(\"CountIsParam\"),\n+                    self.ecx.expr_call_global(sp, rtpath(\"CountIsParam\"),\n                                               ~[self.ecx.expr_uint(sp, i)])\n                 }\n                 parse::CountImplied => {\n-                    let path = self.ecx.path_global(sp, ctpath(\"CountImplied\"));\n+                    let path = self.ecx.path_global(sp, rtpath(\"CountImplied\"));\n                     self.ecx.expr_path(path)\n                 }\n                 parse::CountIsNextParam => {\n-                    let path = self.ecx.path_global(sp, ctpath(\"CountIsNextParam\"));\n+                    let path = self.ecx.path_global(sp, rtpath(\"CountIsNextParam\"));\n                     self.ecx.expr_path(path)\n                 }\n+                parse::CountIsName(n) => {\n+                    let n = n.to_managed();\n+                    let i = match self.name_positions.find_copy(&n) {\n+                        Some(i) => i,\n+                        None => 0, // error already emitted elsewhere\n+                    };\n+                    let i = i + self.args.len();\n+                    self.ecx.expr_call_global(sp, rtpath(\"CountIsParam\"),\n+                                              ~[self.ecx.expr_uint(sp, i)])\n+                }\n             }\n         };\n         let trans_method = |method: &parse::Method| {"}, {"sha": "75d11eddb1bc68a0fc80016c5fed0ed7c4231031", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc06f7922db0b4d1063f4f29157635117d853426/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06f7922db0b4d1063f4f29157635117d853426/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=fc06f7922db0b4d1063f4f29157635117d853426", "patch": "@@ -119,7 +119,10 @@ pub fn main() {\n     t!(format!(\"{:0>2s}\", \"a\"), \"0a\");\n     t!(format!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n     t!(format!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(format!(\"{:.a$s}\", \"aaaaaaaaaaaaaaaaaa\", a=4), \"aaaa\");\n     t!(format!(\"{:1$s}\", \"a\", 4), \"a   \");\n+    t!(format!(\"{1:0$s}\", 4, \"a\"), \"a   \");\n+    t!(format!(\"{:a$s}\", \"a\", a=4), \"a   \");\n     t!(format!(\"{:-#s}\", \"a\"), \"a\");\n     t!(format!(\"{:+#s}\", \"a\"), \"a\");\n "}]}