{"sha": "97214eecc5a6c35c6cd8d9798207175cc2e15812", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MjE0ZWVjYzVhNmMzNWM2Y2Q4ZDk3OTgyMDcxNzVjYzJlMTU4MTI=", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-09-01T22:04:28Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-09-05T17:13:32Z"}, "message": "Add query `own_existential_vtable_entries`", "tree": {"sha": "6c85449f45111d88588b3ac8013242c4bd06b59a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c85449f45111d88588b3ac8013242c4bd06b59a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97214eecc5a6c35c6cd8d9798207175cc2e15812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97214eecc5a6c35c6cd8d9798207175cc2e15812", "html_url": "https://github.com/rust-lang/rust/commit/97214eecc5a6c35c6cd8d9798207175cc2e15812", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97214eecc5a6c35c6cd8d9798207175cc2e15812/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "871eb6233ed4b5c3a3c5fe96e88e4dacc046e45f", "url": "https://api.github.com/repos/rust-lang/rust/commits/871eb6233ed4b5c3a3c5fe96e88e4dacc046e45f", "html_url": "https://github.com/rust-lang/rust/commit/871eb6233ed4b5c3a3c5fe96e88e4dacc046e45f"}], "stats": {"total": 115, "additions": 70, "deletions": 45}, "files": [{"sha": "c93996162e3e372b491ce58f55d3927a39fe67d2", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97214eecc5a6c35c6cd8d9798207175cc2e15812/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97214eecc5a6c35c6cd8d9798207175cc2e15812/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=97214eecc5a6c35c6cd8d9798207175cc2e15812", "patch": "@@ -996,6 +996,12 @@ rustc_queries! {\n         desc { |tcx| \"checking if item has mir available: `{}`\", tcx.def_path_str(key) }\n     }\n \n+    query own_existential_vtable_entries(\n+        key: ty::PolyExistentialTraitRef<'tcx>\n+    ) -> &'tcx [DefId] {\n+        desc { |tcx| \"finding all existential vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n+    }\n+\n     query vtable_entries(key: ty::PolyTraitRef<'tcx>)\n                         -> &'tcx [ty::VtblEntry<'tcx>] {\n         desc { |tcx| \"finding all vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }"}, {"sha": "42e8b4023cfad489c219d106031baaf804cfdc79", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97214eecc5a6c35c6cd8d9798207175cc2e15812/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97214eecc5a6c35c6cd8d9798207175cc2e15812/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=97214eecc5a6c35c6cd8d9798207175cc2e15812", "patch": "@@ -294,6 +294,16 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for ty::PolyExistentialTraitRef<'tcx> {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.def_id().krate == LOCAL_CRATE\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n impl<'tcx> Key for (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "44c675243838a11e1213f6f5131af5edc5803db0", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/97214eecc5a6c35c6cd8d9798207175cc2e15812/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97214eecc5a6c35c6cd8d9798207175cc2e15812/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=97214eecc5a6c35c6cd8d9798207175cc2e15812", "patch": "@@ -625,6 +625,31 @@ fn dump_vtable_entries<'tcx>(\n     tcx.sess.struct_span_err(sp, &msg).emit();\n }\n \n+fn own_existential_vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n+) -> &'tcx [DefId] {\n+    let trait_methods = tcx\n+        .associated_items(trait_ref.def_id())\n+        .in_definition_order()\n+        .filter(|item| item.kind == ty::AssocKind::Fn);\n+    // Now list each method's DefId (for within its trait).\n+    let own_entries = trait_methods.filter_map(move |trait_method| {\n+        debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n+        let def_id = trait_method.def_id;\n+\n+        // Some methods cannot be called on an object; skip those.\n+        if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n+            debug!(\"own_existential_vtable_entry: not vtable safe\");\n+            return None;\n+        }\n+\n+        Some(def_id)\n+    });\n+\n+    tcx.arena.alloc_from_iter(own_entries.into_iter())\n+}\n+\n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n fn vtable_entries<'tcx>(\n@@ -641,21 +666,15 @@ fn vtable_entries<'tcx>(\n                 entries.extend(COMMON_VTABLE_ENTRIES);\n             }\n             VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                let trait_methods = tcx\n-                    .associated_items(trait_ref.def_id())\n-                    .in_definition_order()\n-                    .filter(|item| item.kind == ty::AssocKind::Fn);\n-                // Now list each method's DefId and InternalSubsts (for within its trait).\n-                // If the method can never be called from this object, produce `Vacant`.\n-                let own_entries = trait_methods.filter_map(move |trait_method| {\n-                    debug!(\"vtable_entries: trait_method={:?}\", trait_method);\n-                    let def_id = trait_method.def_id;\n-\n-                    // Some methods cannot be called on an object; skip those.\n-                    if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n-                        debug!(\"vtable_entries: not vtable safe\");\n-                        return None;\n-                    }\n+                let existential_trait_ref = trait_ref\n+                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+\n+                // Lookup the shape of vtable for the trait.\n+                let own_existential_entries =\n+                    tcx.own_existential_vtable_entries(existential_trait_ref);\n+\n+                let own_entries = own_existential_entries.iter().copied().map(|def_id| {\n+                    debug!(\"vtable_entries: trait_method={:?}\", def_id);\n \n                     // The method may have some early-bound lifetimes; add regions for those.\n                     let substs = trait_ref.map_bound(|trait_ref| {\n@@ -681,7 +700,7 @@ fn vtable_entries<'tcx>(\n                     let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n                     if impossible_predicates(tcx, predicates.predicates) {\n                         debug!(\"vtable_entries: predicates do not hold\");\n-                        return Some(VtblEntry::Vacant);\n+                        return VtblEntry::Vacant;\n                     }\n \n                     let instance = ty::Instance::resolve_for_vtable(\n@@ -691,7 +710,7 @@ fn vtable_entries<'tcx>(\n                         substs,\n                     )\n                     .expect(\"resolution failed during building vtable representation\");\n-                    Some(VtblEntry::Method(instance))\n+                    VtblEntry::Method(instance)\n                 });\n \n                 entries.extend(own_entries);\n@@ -804,6 +823,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n         codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n+        own_existential_vtable_entries,\n         vtable_entries,\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,"}, {"sha": "b108d85bb20c9afc2184fab8be73133fc8d05289", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/97214eecc5a6c35c6cd8d9798207175cc2e15812/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97214eecc5a6c35c6cd8d9798207175cc2e15812/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=97214eecc5a6c35c6cd8d9798207175cc2e15812", "patch": "@@ -285,17 +285,10 @@ pub fn upcast_choices(\n /// that come from `trait_ref`, excluding its supertraits. Used in\n /// computing the vtable base for an upcast trait of a trait object.\n pub fn count_own_vtable_entries(tcx: TyCtxt<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n-    let mut entries = 0;\n-    // Count number of methods and add them to the total offset.\n-    // Skip over associated types and constants.\n-    for trait_item in tcx.associated_items(trait_ref.def_id()).in_definition_order() {\n-        let is_vtable_safe_method = trait_item.kind == ty::AssocKind::Fn\n-            && super::is_vtable_safe_method(tcx, trait_ref.def_id(), trait_item);\n-        if is_vtable_safe_method {\n-            entries += 1;\n-        }\n-    }\n-    entries\n+    let existential_trait_ref =\n+        trait_ref.map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+    let existential_trait_ref = tcx.erase_regions(existential_trait_ref);\n+    tcx.own_existential_vtable_entries(existential_trait_ref).len()\n }\n \n /// Given an upcast trait object described by `object`, returns the\n@@ -306,25 +299,21 @@ pub fn get_vtable_index_of_object_method<N>(\n     object: &super::ImplSourceObjectData<'tcx, N>,\n     method_def_id: DefId,\n ) -> usize {\n+    let existential_trait_ref = object\n+        .upcast_trait_ref\n+        .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+    let existential_trait_ref = tcx.erase_regions(existential_trait_ref);\n     // Count number of methods preceding the one we are selecting and\n     // add them to the total offset.\n-    // Skip over associated types and constants, as those aren't stored in the vtable.\n-    let mut entries = object.vtable_base;\n-    let trait_def_id = object.upcast_trait_ref.def_id();\n-    for trait_item in tcx.associated_items(trait_def_id).in_definition_order() {\n-        let is_vtable_safe_method = trait_item.kind == ty::AssocKind::Fn\n-            && super::is_vtable_safe_method(tcx, trait_def_id, trait_item);\n-        if trait_item.def_id == method_def_id {\n-            // The item with the ID we were given really ought to be a method.\n-            assert!(is_vtable_safe_method);\n-            return entries;\n-        }\n-        if is_vtable_safe_method {\n-            entries += 1;\n-        }\n-    }\n-\n-    bug!(\"get_vtable_index_of_object_method: {:?} was not found\", method_def_id);\n+    let index = tcx\n+        .own_existential_vtable_entries(existential_trait_ref)\n+        .iter()\n+        .copied()\n+        .position(|def_id| def_id == method_def_id)\n+        .unwrap_or_else(|| {\n+            bug!(\"get_vtable_index_of_object_method: {:?} was not found\", method_def_id);\n+        });\n+    object.vtable_base + index\n }\n \n pub fn closure_trait_ref_and_return_type("}]}