{"sha": "0547d0cc5b2615cac47f5e03a8a1ca78347139c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NDdkMGNjNWIyNjE1Y2FjNDdmNWUwM2E4YTFjYTc4MzQ3MTM5YzU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-08T09:05:44Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-08T09:45:50Z"}, "message": "Monomorphize resource and variant constructors\n\nIssue #1736", "tree": {"sha": "a1f09d93d7b544b56ebbfe3914dfe3f82ff81048", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1f09d93d7b544b56ebbfe3914dfe3f82ff81048"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0547d0cc5b2615cac47f5e03a8a1ca78347139c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0547d0cc5b2615cac47f5e03a8a1ca78347139c5", "html_url": "https://github.com/rust-lang/rust/commit/0547d0cc5b2615cac47f5e03a8a1ca78347139c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c8d128e1fd6a5ebeae962ff4a656fe18461ebbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8d128e1fd6a5ebeae962ff4a656fe18461ebbd", "html_url": "https://github.com/rust-lang/rust/commit/7c8d128e1fd6a5ebeae962ff4a656fe18461ebbd"}], "stats": {"total": 163, "additions": 87, "deletions": 76}, "files": [{"sha": "423b6ab218ddbcd787b68e2d2a211d96c36f60bd", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=0547d0cc5b2615cac47f5e03a8a1ca78347139c5", "patch": "@@ -11,6 +11,7 @@ enum ast_node {\n     node_item(@item, @path),\n     node_native_item(@native_item, @path),\n     node_method(@method, @path),\n+    node_variant(variant, def_id, @path),\n     node_expr(@expr),\n     // Locals are numbered, because the alias analysis needs to know in which\n     // order they are introduced.\n@@ -74,6 +75,13 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         cx.map.insert(ctor_id, node_res_ctor(i));\n         cx.map.insert(dtor_id, node_item(i, @cx.path));\n       }\n+      item_enum(vs, _) {\n+        for v in vs {\n+            cx.map.insert(v.node.id, node_variant(\n+                v, ast_util::local_def(i.id),\n+                @(cx.path + [path_name(i.ident)])));\n+        }\n+      }\n       _ { }\n     }\n     alt i.node {"}, {"sha": "ae90d2b8cedd9d78fe7ba4d3cec13dc7ddccccb8", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 75, "deletions": 67, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=0547d0cc5b2615cac47f5e03a8a1ca78347139c5", "patch": "@@ -2429,7 +2429,7 @@ fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n \n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n                   dicts: option<typeck::dict_res>)\n-    -> {llfn: ValueRef, fty: ty::t} {\n+    -> option<{llfn: ValueRef, fty: ty::t}> {\n     let substs = vec::map(substs, {|t|\n         alt ty::get(t).struct {\n           ty::ty_box(mt) {\n@@ -2447,29 +2447,47 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       none { [] }\n     }};\n     alt ccx.monomorphized.find(hash_id) {\n-      some(val) { ret val; }\n+      some(val) { ret some(val); }\n       none {}\n     }\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let mono_ty = ty::substitute_type_params(ccx.tcx, substs, tpt.ty);\n-    let (item, pt) = alt ccx.tcx.items.get(fn_id.node) {\n-      ast_map::node_item(i, p) { (i, p) } _ { fail; }\n-    };\n-    let pt = *pt + [path_name(item.ident)];\n-    let result = alt item.node {\n-      ast::item_fn(decl, _, body) {\n-        let llfty = type_of_fn_from_ty(ccx, mono_ty, []);\n+    let llfty = type_of_fn_from_ty(ccx, mono_ty, []);\n+    let lldecl;\n+    alt ccx.tcx.items.get(fn_id.node) {\n+      ast_map::node_item(item, pt) {\n+        let pt = *pt + [path_name(item.ident)];\n+        let s = mangle_exported_name(ccx, pt, mono_ty);\n+        lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n+        alt item.node {\n+          ast::item_fn(decl, _, body) {\n+            trans_fn(ccx, pt, decl, body, lldecl, no_self, [],\n+                     some(substs), fn_id.node);\n+          }\n+          ast::item_res(decl, _, _, _, ctor_id) {\n+            trans_res_ctor(ccx, pt, decl, ctor_id, [], some(substs), lldecl);\n+          }\n+          _ { fail \"Unexpected item type\"; }\n+        }\n+      }\n+      ast_map::node_variant(v, enum_id, pt) {\n+        let pt = *pt + [path_name(v.node.name)];\n         let s = mangle_exported_name(ccx, pt, mono_ty);\n-        let lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n-        trans_fn(ccx, pt, decl, body, lldecl, no_self, [],\n-                 some(substs), fn_id.node);\n-        lldecl\n+        lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n+        let tvs = ty::enum_variants(ccx.tcx, enum_id);\n+        let this_tv = option::get(vec::find(*tvs, {|tv|\n+            tv.id.node == fn_id.node}));\n+        trans_enum_variant(ccx, enum_id.node, v, this_tv.disr_val,\n+                           vec::len(*tvs) == 1u, [], some(substs), lldecl);\n       }\n-      _ { fail \"FIXME[mono] handle other constructs\"; }\n-    };\n-    let val = {llfn: result, fty: mono_ty};\n+      ast_map::node_native_item(_, _) {\n+        ret none;\n+      }\n+      _ { fail \"Unexpected node type\"; }\n+    }\n+    let val = {llfn: lldecl, fty: mono_ty};\n     ccx.monomorphized.insert(hash_id, val);\n-    val\n+    some(val)\n }\n \n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n@@ -2484,10 +2502,14 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n            alt b { ty::bound_iface(_) { false } _ { true } }\n        })}) {\n         let dicts = ccx.dict_map.find(id);\n-        let {llfn, fty} = monomorphic_fn(ccx, fn_id, tys, dicts);\n-        ret {bcx: bcx, val: llfn,\n-             kind: owned, env: null_env,\n-             generic: generic_mono(fty)};\n+        alt monomorphic_fn(ccx, fn_id, tys, dicts) {\n+          some({llfn, fty}) {\n+            ret {bcx: bcx, val: llfn,\n+                 kind: owned, env: null_env,\n+                 generic: generic_mono(fty)};\n+          }\n+          none {}\n+        }\n     }\n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n@@ -4362,15 +4384,6 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n     ret bcx;\n }\n \n-fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n-    let tt = ty::node_id_to_type(ccx.tcx, id);\n-    alt ty::get(tt).struct {\n-      ty::ty_fn({inputs, _}) { inputs }\n-      _ { ccx.sess.bug(#fmt(\"arg_tys_of_fn called on non-function\\\n-            type %s\", ty_to_str(ccx.tcx, tt)));}\n-    }\n-}\n-\n // Ties up the llstaticallocas -> llloadenv -> llderivedtydescs ->\n // lldynamicallocas -> lltop edges, and builds the return block.\n fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n@@ -4407,7 +4420,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     let lltop = bcx.llbb;\n     let block_ty = node_id_type(bcx, body.node.id);\n \n-    let arg_tys = arg_tys_of_fn(fcx.ccx, id);\n+    let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n     alt param_substs {\n       some(ts) {\n         arg_tys = vec::map(arg_tys, {|a|\n@@ -4459,23 +4472,23 @@ fn trans_fn(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n }\n \n fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n-                  ctor_id: ast::node_id, ty_params: [ast::ty_param]) {\n+                  ctor_id: ast::node_id, ty_params: [ast::ty_param],\n+                  param_substs: option<[ty::t]>, llfndecl: ValueRef) {\n     // Create a function for the constructor\n-    let llctor_decl = ccx.item_ids.get(ctor_id);\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id, none, none);\n-    let ret_t = ty::ret_ty_of_fn(ccx.tcx, ctor_id);\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id,\n+                               param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, dtor.inputs, ty_params);\n-    let bcx = new_top_block_ctxt(fcx, none);\n-    let lltop = bcx.llbb;\n-    let arg_t = arg_tys_of_fn(ccx, ctor_id)[0].ty;\n+    let bcx = new_top_block_ctxt(fcx, none), lltop = bcx.llbb;\n+    let fty = node_id_type(bcx, ctor_id);\n+    let arg_t = ty::ty_fn_args(fty)[0].ty;\n     let tup_t = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), arg_t]);\n     let arg = alt fcx.llargs.find(dtor.inputs[0].id) {\n       some(local_mem(x)) { x }\n       _ { ccx.sess.bug(\"Someone forgot to document an invariant \\\n             in trans_res_ctor\"); }\n     };\n     let llretptr = fcx.llretptr;\n-    if ty::type_has_dynamic_size(ccx.tcx, ret_t) {\n+    if ty::type_has_dynamic_size(ccx.tcx, ty::ty_fn_ret(fty)) {\n         let llret_t = T_ptr(T_struct([ccx.int_type, llvm::LLVMTypeOf(arg)]));\n         llretptr = BitCast(bcx, llretptr, llret_t);\n     }\n@@ -4495,11 +4508,8 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n fn trans_enum_variant(ccx: @crate_ctxt,\n                       enum_id: ast::node_id,\n                       variant: ast::variant, disr: int, is_degen: bool,\n-                      ty_params: [ast::ty_param]) {\n-    if vec::len(variant.node.args) == 0u {\n-        ret; // nullary constructors are just constants\n-    }\n-\n+                      ty_params: [ast::ty_param],\n+                      param_substs: option<[ty::t]>, llfndecl: ValueRef) {\n     // Translate variant arguments to function arguments.\n     let fn_args = [], i = 0u;\n     for varg in variant.node.args {\n@@ -4508,27 +4518,21 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                      ident: \"arg\" + uint::to_str(i, 10u),\n                      id: varg.id}];\n     }\n-    assert (ccx.item_ids.contains_key(variant.node.id));\n-    let llfndecl: ValueRef;\n-    alt ccx.item_ids.find(variant.node.id) {\n-      some(x) { llfndecl = x; }\n-      _ {\n-        ccx.sess.span_fatal(variant.span,\n-                            \"unbound variant id in trans_enum_variant\");\n-      }\n-    }\n-    let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id, none,\n-                               none);\n+    let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id,\n+                               param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n-    let ty_param_substs = [], i = 0u;\n-    for tp: ast::ty_param in ty_params {\n-        ty_param_substs += [ty::mk_param(ccx.tcx, i,\n-                                         local_def(tp.id))];\n-        i += 1u;\n-    }\n-    let arg_tys = arg_tys_of_fn(ccx, variant.node.id);\n-    let bcx = new_top_block_ctxt(fcx, none);\n-    let lltop = bcx.llbb;\n+    let ty_param_substs = alt param_substs {\n+      some(ts) { ts }\n+      none {\n+        let i = 0u;\n+        vec::map(ty_params, {|tp|\n+            i += 1u;\n+            ty::mk_param(ccx.tcx, i - 1u, local_def(tp.id))\n+        })\n+      }\n+    };\n+    let bcx = new_top_block_ctxt(fcx, none), lltop = bcx.llbb;\n+    let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n     // Cast the enum to a type we can GEP into.\n@@ -4852,7 +4856,8 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         impl::trans_impl(ccx, *path, item.ident, ms, item.id, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n-        trans_res_ctor(ccx, *path, decl, ctor_id, tps);\n+        let llctor_decl = ccx.item_ids.get(ctor_id);\n+        trans_res_ctor(ccx, *path, decl, ctor_id, tps, none, llctor_decl);\n \n         // Create a function for the destructor\n         alt ccx.item_ids.find(item.id) {\n@@ -4873,8 +4878,11 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n         let i = 0;\n         for variant: ast::variant in variants {\n-            trans_enum_variant(ccx, item.id, variant,\n-                               vi[i].disr_val, degen, tps);\n+            if vec::len(variant.node.args) > 0u {\n+                trans_enum_variant(ccx, item.id, variant,\n+                                   vi[i].disr_val, degen, tps,\n+                                   none, ccx.item_ids.get(variant.node.id));\n+            }\n             i += 1;\n         }\n       }"}, {"sha": "a3acad64a8029c596a27c03c161aad1adc8dafeb", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=0547d0cc5b2615cac47f5e03a8a1ca78347139c5", "patch": "@@ -3,9 +3,8 @@ import syntax::ast;\n import ast::{stmt, fn_ident, node_id, crate, return_val, noreturn, expr};\n import syntax::{visit, print};\n import syntax::codemap::span;\n-import middle::ty::{type_is_nil, ret_ty_of_fn};\n-import tstate::ann::{\n-                     precond, prestate,\n+import middle::ty;\n+import tstate::ann::{precond, prestate,\n                      implies, ann_precond, ann_prestate};\n import option;\n import aux::*;\n@@ -113,7 +112,8 @@ fn check_states_against_conditions(fcx: fn_ctxt,\n     /* Check that the return value is initialized */\n     let post = aux::block_poststate(fcx.ccx, f_body);\n     if !promises(fcx, post, fcx.enclosing.i_return) &&\n-       !type_is_nil(ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n+       !ty::type_is_nil(ty::ty_fn_ret(ty::node_id_to_type(\n+           fcx.ccx.tcx, id))) &&\n        f_decl.cf == return_val {\n         fcx.ccx.tcx.sess.span_err(f_body.span,\n                                   \"In function \" + fcx.name +"}, {"sha": "0fe35a31b780336ee27a29c74e42ad2e6259ec61", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547d0cc5b2615cac47f5e03a8a1ca78347139c5/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0547d0cc5b2615cac47f5e03a8a1ca78347139c5", "patch": "@@ -53,7 +53,6 @@ export mk_named, type_name;\n export mt;\n export node_type_table;\n export pat_ty;\n-export ret_ty_of_fn;\n export sequence_element_type;\n export sort_methods;\n export stmt_node_id;\n@@ -2429,10 +2428,6 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     }\n }\n \n-fn ret_ty_of_fn(cx: ctxt, id: ast::node_id) -> t {\n-    ty_fn_ret(node_id_to_type(cx, id))\n-}\n-\n fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     const tycat_other: int = 0;\n     const tycat_bool: int = 1;"}]}