{"sha": "5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYzYxNjU3YzlkM2ViNWU4ZmUxNDAxNDliMDVhYTJmZjhlYzI4Y2Y=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-08T21:50:21Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-12T18:27:20Z"}, "message": "Make more use of autoderef in librustc_front", "tree": {"sha": "b3daa119aca3e6dfe980d22d43d649beec05851c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3daa119aca3e6dfe980d22d43d649beec05851c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf", "html_url": "https://github.com/rust-lang/rust/commit/5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c4d81f9bc9bb39963ded050b821347ae214d734", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c4d81f9bc9bb39963ded050b821347ae214d734", "html_url": "https://github.com/rust-lang/rust/commit/0c4d81f9bc9bb39963ded050b821347ae214d734"}], "stats": {"total": 217, "additions": 108, "deletions": 109}, "files": [{"sha": "1425fbe9511a340b2666a14ab10778525a9d8fb6", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 100, "deletions": 101, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf", "patch": "@@ -456,7 +456,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n-        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) -> io::Result<()> {\n@@ -492,7 +492,7 @@ impl<'a> State<'a> {\n         match ty.node {\n             hir::TyVec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             hir::TyPtr(ref mt) => {\n@@ -501,7 +501,7 @@ impl<'a> State<'a> {\n                     hir::MutMutable => try!(self.word_nbsp(\"mut\")),\n                     hir::MutImmutable => try!(self.word_nbsp(\"const\")),\n                 }\n-                try!(self.print_type(&*mt.ty));\n+                try!(self.print_type(&mt.ty));\n             }\n             hir::TyRptr(ref lifetime, ref mt) => {\n                 try!(word(&mut self.s, \"&\"));\n@@ -510,7 +510,7 @@ impl<'a> State<'a> {\n             }\n             hir::TyTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&**ty)));\n+                try!(self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n@@ -525,7 +525,7 @@ impl<'a> State<'a> {\n                         predicates: hir::HirVec::new(),\n                     },\n                 };\n-                try!(self.print_ty_fn(f.abi, f.unsafety, &*f.decl, None, &generics, None));\n+                try!(self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics, None));\n             }\n             hir::TyPath(None, ref path) => {\n                 try!(self.print_path(path, false, 0));\n@@ -534,22 +534,22 @@ impl<'a> State<'a> {\n                 try!(self.print_qpath(path, qself, false))\n             }\n             hir::TyObjectSum(ref ty, ref bounds) => {\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(self.print_bounds(\"+\", &bounds[..]));\n             }\n             hir::TyPolyTraitRef(ref bounds) => {\n                 try!(self.print_bounds(\"\", &bounds[..]));\n             }\n             hir::TyFixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \"; \"));\n-                try!(self.print_expr(&**v));\n+                try!(self.print_expr(&v));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             hir::TyTypeof(ref e) => {\n                 try!(word(&mut self.s, \"typeof(\"));\n-                try!(self.print_expr(&**e));\n+                try!(self.print_expr(&e));\n                 try!(word(&mut self.s, \")\"));\n             }\n             hir::TyInfer => {\n@@ -585,7 +585,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**t));\n+                try!(self.print_type(&t));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -667,7 +667,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemUse(ref vp) => {\n                 try!(self.head(&visibility_qualified(item.vis, \"use\")));\n-                try!(self.print_view_path(&**vp));\n+                try!(self.print_view_path(&vp));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n@@ -679,25 +679,25 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n             hir::ItemConst(ref ty, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis, \"const\")));\n                 try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n@@ -712,7 +712,7 @@ impl<'a> State<'a> {\n                                    None,\n                                    item.vis));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(&**body, &item.attrs));\n+                try!(self.print_block_with_attrs(&body, &item.attrs));\n             }\n             hir::ItemMod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis, \"mod\")));\n@@ -740,7 +740,7 @@ impl<'a> State<'a> {\n                 try!(self.print_where_clause(&params.where_clause));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n@@ -796,7 +796,7 @@ impl<'a> State<'a> {\n                     &None => {}\n                 }\n \n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(self.print_where_clause(&generics.where_clause));\n \n                 try!(space(&mut self.s));\n@@ -920,7 +920,7 @@ impl<'a> State<'a> {\n                         hir::UnnamedField(vis) => {\n                             try!(s.print_visibility(vis));\n                             try!(s.maybe_print_comment(field.span.lo));\n-                            s.print_type(&*field.node.ty)\n+                            s.print_type(&field.node.ty)\n                         }\n                     }\n                 }));\n@@ -948,7 +948,7 @@ impl<'a> State<'a> {\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_name(name));\n                         try!(self.word_nbsp(\":\"));\n-                        try!(self.print_type(&*field.node.ty));\n+                        try!(self.print_type(&field.node.ty));\n                         try!(word(&mut self.s, \",\"));\n                     }\n                 }\n@@ -966,12 +966,11 @@ impl<'a> State<'a> {\n             Some(ref d) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_expr(&**d)\n+                self.print_expr(&d)\n             }\n             _ => Ok(()),\n         }\n     }\n-\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n                             m: &hir::MethodSig,\n@@ -1046,15 +1045,15 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n             hir::StmtDecl(ref decl, _) => {\n-                try!(self.print_decl(&**decl));\n+                try!(self.print_decl(&decl));\n             }\n             hir::StmtExpr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n             }\n             hir::StmtSemi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n             }\n         }\n@@ -1112,7 +1111,7 @@ impl<'a> State<'a> {\n         match blk.expr {\n             Some(ref expr) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n             _ => (),\n@@ -1130,17 +1129,17 @@ impl<'a> State<'a> {\n                         try!(self.cbox(indent_unit - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n-                        try!(self.print_expr(&**i));\n+                        try!(self.print_expr(&i));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(&**then));\n+                        try!(self.print_block(&then));\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     hir::ExprBlock(ref b) => {\n                         try!(self.cbox(indent_unit - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n-                        self.print_block(&**b)\n+                        self.print_block(&b)\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n@@ -1230,7 +1229,7 @@ impl<'a> State<'a> {\n                                     try!(s.ibox(indent_unit));\n                                     try!(s.print_name(field.name.node));\n                                     try!(s.word_space(\":\"));\n-                                    try!(s.print_expr(&*field.expr));\n+                                    try!(s.print_expr(&field.expr));\n                                     s.end()\n                                 },\n                                 |f| f.span));\n@@ -1242,7 +1241,7 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s));\n                 }\n                 try!(word(&mut self.s, \"..\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.end());\n             }\n             _ => if !fields.is_empty() {\n@@ -1273,12 +1272,12 @@ impl<'a> State<'a> {\n                               args: &[P<hir::Expr>])\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n-        try!(self.print_expr(&*args[0]));\n+        try!(self.print_expr(&args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_name(name.node));\n         if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n-            try!(self.commasep(Inconsistent, tys, |s, ty| s.print_type(&**ty)));\n+            try!(self.commasep(Inconsistent, tys, |s, ty| s.print_type(&ty)));\n             try!(word(&mut self.s, \">\"));\n         }\n         self.print_call_post(base_args)\n@@ -1322,7 +1321,7 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_vec(&exprs[..]));\n             }\n             hir::ExprRepeat(ref element, ref count) => {\n-                try!(self.print_expr_repeat(&**element, &**count));\n+                try!(self.print_expr_repeat(&element, &count));\n             }\n             hir::ExprStruct(ref path, ref fields, ref wth) => {\n                 try!(self.print_expr_struct(path, &fields[..], wth));\n@@ -1331,46 +1330,46 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_tup(&exprs[..]));\n             }\n             hir::ExprCall(ref func, ref args) => {\n-                try!(self.print_expr_call(&**func, &args[..]));\n+                try!(self.print_expr_call(&func, &args[..]));\n             }\n             hir::ExprMethodCall(name, ref tys, ref args) => {\n                 try!(self.print_expr_method_call(name, &tys[..], &args[..]));\n             }\n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr_binary(op, &**lhs, &**rhs));\n+                try!(self.print_expr_binary(op, &lhs, &rhs));\n             }\n             hir::ExprUnary(op, ref expr) => {\n-                try!(self.print_expr_unary(op, &**expr));\n+                try!(self.print_expr_unary(op, &expr));\n             }\n             hir::ExprAddrOf(m, ref expr) => {\n-                try!(self.print_expr_addr_of(m, &**expr));\n+                try!(self.print_expr_addr_of(m, &expr));\n             }\n             hir::ExprLit(ref lit) => {\n-                try!(self.print_literal(&**lit));\n+                try!(self.print_literal(&lit));\n             }\n             hir::ExprCast(ref expr, ref ty) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"as\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n             }\n             hir::ExprType(ref expr, ref ty) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n             }\n             hir::ExprIf(ref test, ref blk, ref elseopt) => {\n-                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e)));\n+                try!(self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             hir::ExprWhile(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_name(ident.name));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while\"));\n-                try!(self.print_expr(&**test));\n+                try!(self.print_expr(&test));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block(&blk));\n             }\n             hir::ExprLoop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -1379,13 +1378,13 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.head(\"loop\"));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block(&blk));\n             }\n             hir::ExprMatch(ref expr, ref arms, _) => {\n                 try!(self.cbox(indent_unit));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 for arm in arms {\n@@ -1396,7 +1395,7 @@ impl<'a> State<'a> {\n             hir::ExprClosure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n-                try!(self.print_fn_block_args(&**decl));\n+                try!(self.print_fn_block_args(&decl));\n                 try!(space(&mut self.s));\n \n                 let default_return = match decl.output {\n@@ -1405,12 +1404,12 @@ impl<'a> State<'a> {\n                 };\n \n                 if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    try!(self.print_block_unclosed(&**body));\n+                    try!(self.print_block_unclosed(&body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n                     match body.expr.as_ref().unwrap().node {\n                         hir::ExprBlock(ref blk) => {\n-                            try!(self.print_block_unclosed(&**blk));\n+                            try!(self.print_block_unclosed(&blk));\n                         }\n                         _ => {\n                             // this is a bare expression\n@@ -1429,44 +1428,44 @@ impl<'a> State<'a> {\n                 try!(self.cbox(indent_unit));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block(&blk));\n             }\n             hir::ExprAssign(ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n+                try!(self.print_expr(&lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr(&rhs));\n             }\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n+                try!(self.print_expr(&lhs));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, ::util::binop_to_string(op.node)));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr(&rhs));\n             }\n             hir::ExprField(ref expr, name) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_name(name.node));\n             }\n             hir::ExprTupField(ref expr, id) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_usize(id.node));\n             }\n             hir::ExprIndex(ref expr, ref index) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(&**index));\n+                try!(self.print_expr(&index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             hir::ExprRange(ref start, ref end) => {\n                 if let &Some(ref e) = start {\n-                    try!(self.print_expr(&**e));\n+                    try!(self.print_expr(&e));\n                 }\n                 try!(word(&mut self.s, \"..\"));\n                 if let &Some(ref e) = end {\n-                    try!(self.print_expr(&**e));\n+                    try!(self.print_expr(&e));\n                 }\n             }\n             hir::ExprPath(None, ref path) => {\n@@ -1496,7 +1495,7 @@ impl<'a> State<'a> {\n                 match *result {\n                     Some(ref expr) => {\n                         try!(word(&mut self.s, \" \"));\n-                        try!(self.print_expr(&**expr));\n+                        try!(self.print_expr(&expr));\n                     }\n                     _ => (),\n                 }\n@@ -1515,7 +1514,7 @@ impl<'a> State<'a> {\n                         _ => try!(s.print_string(&out.constraint, ast::StrStyle::Cooked)),\n                     }\n                     try!(s.popen());\n-                    try!(s.print_expr(&*out.expr));\n+                    try!(s.print_expr(&out.expr));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -1525,7 +1524,7 @@ impl<'a> State<'a> {\n                 try!(self.commasep(Inconsistent, &a.inputs, |s, &(ref co, ref o)| {\n                     try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     try!(s.popen());\n-                    try!(s.print_expr(&**o));\n+                    try!(s.print_expr(&o));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -1551,7 +1550,7 @@ impl<'a> State<'a> {\n                 if !options.is_empty() {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n-                    try!(self.commasep(Inconsistent, &*options, |s, &co| {\n+                    try!(self.commasep(Inconsistent, &options, |s, &co| {\n                         try!(s.print_string(co, ast::StrStyle::Cooked));\n                         Ok(())\n                     }));\n@@ -1565,10 +1564,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_local_decl(&mut self, loc: &hir::Local) -> io::Result<()> {\n-        try!(self.print_pat(&*loc.pat));\n+        try!(self.print_pat(&loc.pat));\n         if let Some(ref ty) = loc.ty {\n             try!(self.word_space(\":\"));\n-            try!(self.print_type(&**ty));\n+            try!(self.print_type(&ty));\n         }\n         Ok(())\n     }\n@@ -1582,12 +1581,12 @@ impl<'a> State<'a> {\n                 try!(self.word_nbsp(\"let\"));\n \n                 try!(self.ibox(indent_unit));\n-                try!(self.print_local_decl(&**loc));\n+                try!(self.print_local_decl(&loc));\n                 try!(self.end());\n                 if let Some(ref init) = loc.init {\n                     try!(self.nbsp());\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_expr(&**init));\n+                    try!(self.print_expr(&init));\n                 }\n                 self.end()\n             }\n@@ -1685,7 +1684,7 @@ impl<'a> State<'a> {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n-                    try!(self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&**ty)));\n+                    try!(self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&ty)));\n                     comma = true;\n                 }\n \n@@ -1696,7 +1695,7 @@ impl<'a> State<'a> {\n                     try!(self.print_name(binding.name));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_type(&*binding.ty));\n+                    try!(self.print_type(&binding.ty));\n                     comma = true;\n                 }\n \n@@ -1705,15 +1704,15 @@ impl<'a> State<'a> {\n \n             hir::ParenthesizedParameters(ref data) => {\n                 try!(word(&mut self.s, \"(\"));\n-                try!(self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&**ty)));\n+                try!(self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&ty)));\n                 try!(word(&mut self.s, \")\"));\n \n                 match data.output {\n                     None => {}\n                     Some(ref ty) => {\n                         try!(self.space_if_not_bol());\n                         try!(self.word_space(\"->\"));\n-                        try!(self.print_type(&**ty));\n+                        try!(self.print_type(&ty));\n                     }\n                 }\n             }\n@@ -1744,7 +1743,7 @@ impl<'a> State<'a> {\n                 match *sub {\n                     Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n-                        try!(self.print_pat(&**p));\n+                        try!(self.print_pat(&p));\n                     }\n                     None => (),\n                 }\n@@ -1756,7 +1755,7 @@ impl<'a> State<'a> {\n                     Some(ref args) => {\n                         if !args.is_empty() {\n                             try!(self.popen());\n-                            try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&**p)));\n+                            try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&p)));\n                             try!(self.pclose());\n                         }\n                     }\n@@ -1777,7 +1776,7 @@ impl<'a> State<'a> {\n                                                 try!(s.print_name(f.node.name));\n                                                 try!(s.word_nbsp(\":\"));\n                                             }\n-                                            try!(s.print_pat(&*f.node.pat));\n+                                            try!(s.print_pat(&f.node.pat));\n                                             s.end()\n                                         },\n                                         |f| f.node.pat.span));\n@@ -1792,46 +1791,46 @@ impl<'a> State<'a> {\n             }\n             hir::PatTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             hir::PatBox(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n-                try!(self.print_pat(&**inner));\n+                try!(self.print_pat(&inner));\n             }\n             hir::PatRegion(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n                 if mutbl == hir::MutMutable {\n                     try!(word(&mut self.s, \"mut \"));\n                 }\n-                try!(self.print_pat(&**inner));\n+                try!(self.print_pat(&inner));\n             }\n-            hir::PatLit(ref e) => try!(self.print_expr(&**e)),\n+            hir::PatLit(ref e) => try!(self.print_expr(&e)),\n             hir::PatRange(ref begin, ref end) => {\n-                try!(self.print_expr(&**begin));\n+                try!(self.print_expr(&begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"...\"));\n-                try!(self.print_expr(&**end));\n+                try!(self.print_expr(&end));\n             }\n             hir::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p)));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() {\n                         try!(self.word_space(\",\"));\n                     }\n                     if p.node != hir::PatWild {\n-                        try!(self.print_pat(&**p));\n+                        try!(self.print_pat(&p));\n                     }\n                     try!(word(&mut self.s, \"..\"));\n                     if !after.is_empty() {\n                         try!(self.word_space(\",\"));\n                     }\n                 }\n-                try!(self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n         }\n@@ -1855,20 +1854,20 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"|\"));\n             }\n-            try!(self.print_pat(&**p));\n+            try!(self.print_pat(&p));\n         }\n         try!(space(&mut self.s));\n         if let Some(ref e) = arm.guard {\n             try!(self.word_space(\"if\"));\n-            try!(self.print_expr(&**e));\n+            try!(self.print_expr(&e));\n             try!(space(&mut self.s));\n         }\n         try!(self.word_space(\"=>\"));\n \n         match arm.body.node {\n             hir::ExprBlock(ref blk) => {\n                 // the block will close the pattern's ibox\n-                try!(self.print_block_unclosed_indent(&**blk, indent_unit));\n+                try!(self.print_block_unclosed_indent(&blk, indent_unit));\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::UnsafeBlock(hir::UserProvided) = blk.rules {\n@@ -1877,7 +1876,7 @@ impl<'a> State<'a> {\n             }\n             _ => {\n                 try!(self.end()); // close the ibox for the pattern\n-                try!(self.print_expr(&*arm.body));\n+                try!(self.print_expr(&arm.body));\n                 try!(word(&mut self.s, \",\"));\n             }\n         }\n@@ -1906,7 +1905,7 @@ impl<'a> State<'a> {\n             hir::SelfExplicit(ref typ, _) => {\n                 try!(word(&mut self.s, \"self\"));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**typ));\n+                try!(self.print_type(&typ));\n             }\n         }\n         return Ok(true);\n@@ -1999,7 +1998,7 @@ impl<'a> State<'a> {\n         try!(self.word_space(\"->\"));\n         match decl.output {\n             hir::Return(ref ty) => {\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             hir::DefaultReturn(..) => unreachable!(),\n@@ -2098,7 +2097,7 @@ impl<'a> State<'a> {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_type(&**default)\n+                self.print_type(&default)\n             }\n             _ => Ok(()),\n         }\n@@ -2123,7 +2122,7 @@ impl<'a> State<'a> {\n                                                                               ref bounds,\n                                                                               ..}) => {\n                     try!(self.print_formal_lifetime_list(bound_lifetimes));\n-                    try!(self.print_type(&**bounded_ty));\n+                    try!(self.print_type(&bounded_ty));\n                     try!(self.print_bounds(\":\", bounds));\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n@@ -2144,7 +2143,7 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false, 0));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_type(&**ty));\n+                    try!(self.print_type(&ty));\n                 }\n             }\n         }\n@@ -2202,13 +2201,13 @@ impl<'a> State<'a> {\n \n     pub fn print_mt(&mut self, mt: &hir::MutTy) -> io::Result<()> {\n         try!(self.print_mutability(mt.mutbl));\n-        self.print_type(&*mt.ty)\n+        self.print_type(&mt.ty)\n     }\n \n     pub fn print_arg(&mut self, input: &hir::Arg, is_closure: bool) -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n         match input.ty.node {\n-            hir::TyInfer if is_closure => try!(self.print_pat(&*input.pat)),\n+            hir::TyInfer if is_closure => try!(self.print_pat(&input.pat)),\n             _ => {\n                 match input.pat.node {\n                     hir::PatIdent(_, ref path1, _) if\n@@ -2217,12 +2216,12 @@ impl<'a> State<'a> {\n                         // Do nothing.\n                     }\n                     _ => {\n-                        try!(self.print_pat(&*input.pat));\n+                        try!(self.print_pat(&input.pat));\n                         try!(word(&mut self.s, \":\"));\n                         try!(space(&mut self.s));\n                     }\n                 }\n-                try!(self.print_type(&*input.ty));\n+                try!(self.print_type(&input.ty));\n             }\n         }\n         self.end()\n@@ -2239,7 +2238,7 @@ impl<'a> State<'a> {\n         match decl.output {\n             hir::NoReturn(_) => try!(self.word_nbsp(\"!\")),\n             hir::DefaultReturn(..) => unreachable!(),\n-            hir::Return(ref ty) => try!(self.print_type(&**ty)),\n+            hir::Return(ref ty) => try!(self.print_type(&ty)),\n         }\n         try!(self.end());\n \n@@ -2414,7 +2413,7 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n             }\n         }\n         hir::StmtExpr(ref e, _) => {\n-            expr_requires_semi_to_be_stmt(&**e)\n+            expr_requires_semi_to_be_stmt(&e)\n         }\n         hir::StmtSemi(..) => {\n             false"}, {"sha": "5d936fae6ec0a6c695cf56cf822ef0628a0de3ae", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=5fc61657c9d3eb5e8fe140149b05aa2ff8ec28cf", "patch": "@@ -23,25 +23,25 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n     fn walk_pat_<G>(pat: &Pat, it: &mut G) -> bool\n         where G: FnMut(&Pat) -> bool\n     {\n-        if !(*it)(pat) {\n+        if !it(pat) {\n             return false;\n         }\n \n         match pat.node {\n-            PatIdent(_, _, Some(ref p)) => walk_pat_(&**p, it),\n+            PatIdent(_, _, Some(ref p)) => walk_pat_(&p, it),\n             PatStruct(_, ref fields, _) => {\n-                fields.iter().all(|field| walk_pat_(&*field.node.pat, it))\n+                fields.iter().all(|field| walk_pat_(&field.node.pat, it))\n             }\n             PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n-                s.iter().all(|p| walk_pat_(&**p, it))\n+                s.iter().all(|p| walk_pat_(&p, it))\n             }\n             PatBox(ref s) | PatRegion(ref s, _) => {\n-                walk_pat_(&**s, it)\n+                walk_pat_(&s, it)\n             }\n             PatVec(ref before, ref slice, ref after) => {\n-                before.iter().all(|p| walk_pat_(&**p, it)) &&\n-                slice.iter().all(|p| walk_pat_(&**p, it)) &&\n-                after.iter().all(|p| walk_pat_(&**p, it))\n+                before.iter().all(|p| walk_pat_(&p, it)) &&\n+                slice.iter().all(|p| walk_pat_(&p, it)) &&\n+                after.iter().all(|p| walk_pat_(&p, it))\n             }\n             PatWild |\n             PatLit(_) |"}]}