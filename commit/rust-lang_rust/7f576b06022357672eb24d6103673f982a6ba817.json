{"sha": "7f576b06022357672eb24d6103673f982a6ba817", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNTc2YjA2MDIyMzU3NjcyZWIyNGQ2MTAzNjczZjk4MmE2YmE4MTc=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-10T22:53:21Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-10T22:53:21Z"}, "message": "General cleanup after rebase", "tree": {"sha": "3ed01a4ac586c7c4cb3528d7532fc9a4dd22701f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ed01a4ac586c7c4cb3528d7532fc9a4dd22701f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f576b06022357672eb24d6103673f982a6ba817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f576b06022357672eb24d6103673f982a6ba817", "html_url": "https://github.com/rust-lang/rust/commit/7f576b06022357672eb24d6103673f982a6ba817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f576b06022357672eb24d6103673f982a6ba817/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03c660633fbac0492f891aed6c47731be90f23ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/03c660633fbac0492f891aed6c47731be90f23ca", "html_url": "https://github.com/rust-lang/rust/commit/03c660633fbac0492f891aed6c47731be90f23ca"}], "stats": {"total": 221, "additions": 105, "deletions": 116}, "files": [{"sha": "ff7558131d209501aaac92b7b5ebdfe9fee22258", "filename": "src/comment.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -41,43 +41,44 @@ pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usiz\n     let line_breaks = s.chars().filter(|&c| c == '\\n').count();\n \n     let (_, mut s) = s.lines()\n-                         .enumerate()\n-                         .map(|(i, mut line)| {\n-                             line = line.trim();\n-            // Drop old closer.\n-                 if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n-                     line = &line[..(line.len() - 2)];\n-                 }\n-\n-                 line.trim_right()\n-             })\n-        .map(left_trim_comment_line)\n-        .map(|line| {\n-            if line_breaks == 0 {\n-                line.trim_left()\n-            } else {\n-                line\n-            }\n-        })\n-        .fold((true, opener.to_owned()), |(first, mut acc), line| {\n-            if !first {\n-                acc.push('\\n');\n-                acc.push_str(&indent_str);\n-                acc.push_str(line_start);\n-            }\n-\n-            if line.len() > max_chars {\n-                acc.push_str(&rewrite_string(line, &fmt));\n-            } else {\n-                if line.len() == 0 {\n-                    acc.pop(); // Remove space if this is an empty comment.\n-                } else {\n-                    acc.push_str(line);\n-                }\n-            }\n-\n-            (false, acc)\n-        });\n+                      .enumerate()\n+                      .map(|(i, mut line)| {\n+                          line = line.trim();\n+                          // Drop old closer.\n+                          if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n+                              line = &line[..(line.len() - 2)];\n+                          }\n+\n+                          line.trim_right()\n+                      })\n+                      .map(left_trim_comment_line)\n+                      .map(|line| {\n+                          if line_breaks == 0 {\n+                              line.trim_left()\n+                          } else {\n+                              line\n+                          }\n+                      })\n+                      .fold((true, opener.to_owned()),\n+                            |(first, mut acc), line| {\n+                                if !first {\n+                                    acc.push('\\n');\n+                                    acc.push_str(&indent_str);\n+                                    acc.push_str(line_start);\n+                                }\n+\n+                                if line.len() > max_chars {\n+                                    acc.push_str(&rewrite_string(line, &fmt));\n+                                } else {\n+                                    if line.len() == 0 {\n+                                        acc.pop(); // Remove space if this is an empty comment.\n+                                    } else {\n+                                        acc.push_str(line);\n+                                    }\n+                                }\n+\n+                                (false, acc)\n+                            });\n \n     s.push_str(closer);\n "}, {"sha": "c7dad3d2ccff0c8cccd12c7384e745ba3ebf64f2", "filename": "src/expr.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -18,7 +18,7 @@ use StructLitStyle;\n use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width, wrap_str,\n             binary_search};\n use visitor::FmtVisitor;\n-use config::{BlockIndentStyle, MultilineStyle};\n+use config::MultilineStyle;\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg, rewrite_fn_input};\n@@ -40,12 +40,6 @@ impl Rewrite for ast::Expr {\n                 }\n             }\n             ast::Expr_::ExprCall(ref callee, ref args) => {\n-                // FIXME using byte lens instead of char lens (and probably all over the place too)\n-                // 2 is for parens\n-                let max_callee_width = try_opt!(width.checked_sub(2));\n-                let callee_str = try_opt!(callee.rewrite(context, max_callee_width, offset));\n-                let span = mk_sp(callee.span.hi, self.span.hi);\n-\n                 rewrite_call(context, &**callee, args, self.span, width, offset)\n             }\n             ast::Expr_::ExprParen(ref subexpr) => {\n@@ -214,8 +208,6 @@ fn rewrite_closure(capture: ast::CaptureClause,\n         prefix.push_str(&ret_str);\n     }\n \n-    let closure_indent = closure_indent(context, offset);\n-\n     // Try to format closure body as a single line expression without braces.\n     if is_simple_block(body, context.codemap) && !prefix.contains('\\n') {\n         let (spacer, closer) = if ret_str.is_empty() {\n@@ -246,17 +238,16 @@ fn rewrite_closure(capture: ast::CaptureClause,\n \n     // We couldn't format the closure body as a single line expression; fall\n     // back to block formatting.\n-    let inner_context = context.overflow_context(closure_indent - context.block_indent);\n     let body_rewrite = body.expr\n                            .as_ref()\n                            .and_then(|body_expr| {\n                                if let ast::Expr_::ExprBlock(ref inner) = body_expr.node {\n-                                   Some(inner.rewrite(&inner_context, 2, 0))\n+                                   Some(inner.rewrite(&context, 2, 0))\n                                } else {\n                                    None\n                                }\n                            })\n-                           .unwrap_or_else(|| body.rewrite(&inner_context, 2, 0));\n+                           .unwrap_or_else(|| body.rewrite(&context, 2, 0));\n \n     Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n }\n@@ -876,25 +867,21 @@ fn rewrite_string_lit(context: &RewriteContext,\n }\n \n pub fn rewrite_call<R>(context: &RewriteContext,\n-                   callee: &R,\n-                   args: &[ptr::P<ast::Expr>],\n-                   span: Span,\n-                   width: usize,\n-                   offset: usize)\n-                   -> Option<String>\n+                       callee: &R,\n+                       args: &[ptr::P<ast::Expr>],\n+                       span: Span,\n+                       width: usize,\n+                       offset: usize)\n+                       -> Option<String>\n     where R: Rewrite\n {\n+    let closure = |callee_max_width| {\n+        rewrite_call_inner(context, callee, callee_max_width, args, span, width, offset)\n+    };\n+\n     // 2 is for parens\n     let max_width = try_opt!(width.checked_sub(2));\n-    binary_search(1, max_width, |callee_max_width| {\n-        rewrite_call_inner(context,\n-                           callee,\n-                           callee_max_width,\n-                           args,\n-                           span,\n-                           width,\n-                           offset)\n-    })\n+    binary_search(1, max_width, closure)\n }\n \n fn rewrite_call_inner<R>(context: &RewriteContext,\n@@ -1021,10 +1008,9 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => field.span.lo,\n                                      StructLitField::Base(ref expr) => {\n-                                         let last_field_hi = fields.last().map_or(span.lo,\n-                                                                                  |field| {\n-                                                                                      field.span.hi\n-                                                                                  });\n+                                         let last_field_hi = fields.last()\n+                                                                   .map_or(span.lo,\n+                                                                           |field| field.span.hi);\n                                          let snippet = context.snippet(mk_sp(last_field_hi,\n                                                                              expr.span.lo));\n                                          let pos = snippet.find_uncommented(\"..\").unwrap();\n@@ -1074,11 +1060,10 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     let fields_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n     let format_on_newline = || {\n-                                let inner_indent = make_indent(context.block_indent +\n-                                                               context.config.tab_spaces);\n-                                let outer_indent = make_indent(context.block_indent);\n-                                Some(format!(\"{} {{\\n{}{}\\n{}}}\", path_str, inner_indent, fields_str, outer_indent))\n-                            };\n+        let inner_indent = make_indent(context.block_indent + context.config.tab_spaces);\n+        let outer_indent = make_indent(context.block_indent);\n+        Some(format!(\"{} {{\\n{}{}\\n{}}}\", path_str, inner_indent, fields_str, outer_indent))\n+    };\n \n     match (context.config.struct_lit_style, context.config.struct_lit_multiline_style) {\n         (StructLitStyle::Block, _) if fields_str.contains('\\n') => format_on_newline(),"}, {"sha": "1d215d022d12e6f54652d49c08bf6a9c4b6f8b4d", "filename": "src/imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -150,10 +150,10 @@ pub fn rewrite_use_list(width: usize,\n     let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n \n     Some(if path_str.is_empty() {\n-            format!(\"{{{}}}\", list_str)\n-        } else {\n-            format!(\"{}::{{{}}}\", path_str, list_str)\n-        })\n+        format!(\"{{{}}}\", list_str)\n+    } else {\n+        format!(\"{}::{{{}}}\", path_str, list_str)\n+    })\n }\n \n // Returns true when self item was found."}, {"sha": "958dbb20df048349e5c1d0e7cc44ebe4a0d790b6", "filename": "src/items.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -211,10 +211,8 @@ impl<'a> FmtVisitor<'a> {\n         let ret_str = fd.output.rewrite(&context, self.config.max_width - indent, indent).unwrap();\n \n         // Args.\n-        let (one_line_budget, multi_line_budget, mut arg_indent) = self.compute_budgets_for_args(&result,\n-                                                                                                 indent,\n-                                                                                                 ret_str.len(),\n-                                                                                                 newline_brace);\n+        let (one_line_budget, multi_line_budget, mut arg_indent) =\n+            self.compute_budgets_for_args(&result, indent, ret_str.len(), newline_brace);\n \n         debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {}\",\n                one_line_budget, multi_line_budget, arg_indent);\n@@ -239,7 +237,10 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         // A conservative estimation, to goal is to be over all parens in generics\n-        let args_start = generics.ty_params.last().map(|tp| end_typaram(tp)).unwrap_or(span.lo);\n+        let args_start = generics.ty_params\n+                                 .last()\n+                                 .map(|tp| end_typaram(tp))\n+                                 .unwrap_or(span.lo);\n         let args_span = codemap::mk_sp(span_after(codemap::mk_sp(args_start, span.hi),\n                                                   \"(\",\n                                                   self.codemap),"}, {"sha": "973f0fa56ab4d50ba8264884384cd429a41af940", "filename": "src/utils.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -211,8 +211,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n \n impl Rewrite for String {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n-        // FIXME: unnecessary clone\n-        wrap_str(self.clone(), context.config.max_width, width, offset)\n+        wrap_str(self, context.config.max_width, width, offset).map(ToOwned::to_owned)\n     }\n }\n \n@@ -245,13 +244,13 @@ pub fn binary_search<C, T>(mut lo: usize, mut hi: usize, callback: C) -> Option<\n #[test]\n fn bin_search_test() {\n     let closure = |i| {\n-                      match i {\n-                          4 => Ok(()),\n-                          j if j > 4 => Err(Ordering::Less),\n-                          j if j < 4 => Err(Ordering::Greater),\n-                          _ => unreachable!(),\n-                      }\n-                  };\n+        match i {\n+            4 => Ok(()),\n+            j if j > 4 => Err(Ordering::Less),\n+            j if j < 4 => Err(Ordering::Greater),\n+            _ => unreachable!(),\n+        }\n+    };\n \n     assert_eq!(Some(()), binary_search(1, 10, &closure));\n     assert_eq!(None, binary_search(1, 3, &closure));"}, {"sha": "b94ca21b2588a069a4ff25319938ec32095c2d09", "filename": "tests/source/chains-no-overflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/tests%2Fsource%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/tests%2Fsource%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains-no-overflow.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -21,9 +21,8 @@ fn main() {\n                                         {\n                                             SCRIPT_TASK_ROOT\n                                             .with(|root| {\n-                                                                // Another case of write_list failing us.\n-                                                *root.borrow_mut()  =   Some(&script_task);\n-                                            });\n+                                                        *root.borrow_mut()  =   Some(&script_task);\n+                                                    });\n                                         });                                        \n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx"}, {"sha": "f53afaa0c286f30716404348dba24ea7999f2304", "filename": "tests/source/chains.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -1,7 +1,7 @@\n // Test chain formatting.\n \n fn main() {\n-    // Don't put chains on a single list if it wasn't so in source.\n+    // Don't put chains on a single line if it wasn't so in source.\n     let a = b .c\n     .d.1\n                 .foo(|x| x + 1);\n@@ -11,6 +11,8 @@ fn main() {\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd.eeeeeeee();\n \n+    // Test case where first chain element isn't a path, but is shorter than\n+    // the size of a tab.\n     x()\n         .y(|| match cond() { true => (), false => () });\n "}, {"sha": "35d8ec072c2a8765fc2ffb37379837f45413b75d", "filename": "tests/source/string-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/tests%2Fsource%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/tests%2Fsource%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstring-lit.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -30,5 +30,5 @@ formatting\"#;\n     let unicode3 = \"\u4e2d\u534eVi\u1ec7t Nam\";\n     let unicode4 = \"\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\";\n \n-    \"stuff\"\n+    \"stuffin'\"\n }"}, {"sha": "9086697978ed393db14e0ed34c6fe562a2e7903d", "filename": "tests/system.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -26,9 +26,9 @@ use rustfmt::rustfmt_diff::*;\n static DIFF_CONTEXT_SIZE: usize = 3;\n \n fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> String {\n-    let path = dir_entry.ok().expect(\"Couldn\\'t get DirEntry.\").path();\n+    let path = dir_entry.ok().expect(\"Couldn't get DirEntry.\").path();\n \n-    path.to_str().expect(\"Couldn\\'t stringify path.\").to_owned()\n+    path.to_str().expect(\"Couldn't stringify path.\").to_owned()\n }\n \n // Integration tests. The files in the tests/source are formatted and compared\n@@ -40,7 +40,7 @@ fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> String {\n #[test]\n fn system_tests() {\n     // Get all files in the tests/source directory\n-    let files = fs::read_dir(\"tests/source\").ok().expect(\"Couldn\\'t read source dir.\");\n+    let files = fs::read_dir(\"tests/source\").ok().expect(\"Couldn't read source dir.\");\n     // turn a DirEntry into a String that represents the relative path to the file\n     let files = files.map(get_path_string);\n \n@@ -56,9 +56,9 @@ fn system_tests() {\n #[test]\n fn idempotence_tests() {\n     // Get all files in the tests/target directory\n-    let files = fs::read_dir(\"tests/target\").ok().expect(\"Couldn\\'t read target dir.\");\n-    let files = files.chain(fs::read_dir(\"tests\").ok().expect(\"Couldn\\'t read tests dir.\"));\n-    let files = files.chain(fs::read_dir(\"src/bin\").ok().expect(\"Couldn\\'t read src dir.\"));\n+    let files = fs::read_dir(\"tests/target\").ok().expect(\"Couldn't read target dir.\");\n+    let files = files.chain(fs::read_dir(\"tests\").ok().expect(\"Couldn't read tests dir.\"));\n+    let files = files.chain(fs::read_dir(\"src/bin\").ok().expect(\"Couldn't read src dir.\"));\n     // turn a DirEntry into a String that represents the relative path to the file\n     let files = files.map(get_path_string);\n     // hack because there's no `IntoIterator` impl for `[T; N]`\n@@ -139,9 +139,9 @@ fn get_config(config_file: Option<&str>) -> Box<Config> {\n \n     let mut def_config_file = fs::File::open(config_file_name)\n                                   .ok()\n-                                  .expect(\"Couldn\\'t open config.\");\n+                                  .expect(\"Couldn't open config.\");\n     let mut def_config = String::new();\n-    def_config_file.read_to_string(&mut def_config).ok().expect(\"Couldn\\'t read config.\");\n+    def_config_file.read_to_string(&mut def_config).ok().expect(\"Couldn't read config.\");\n \n     Box::new(Config::from_toml(&def_config))\n }\n@@ -151,7 +151,7 @@ fn get_config(config_file: Option<&str>) -> Box<Config> {\n fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n     let file = fs::File::open(file_name)\n                    .ok()\n-                   .expect(&format!(\"Couldn\\'t read file {}.\", file_name));\n+                   .expect(&format!(\"Couldn't read file {}.\", file_name));\n     let reader = BufReader::new(file);\n     let pattern = r\"^\\s*//\\s*rustfmt-([^:]+):\\s*(\\S+)\";\n     let regex = regex::Regex::new(&pattern).ok().expect(\"Failed creating pattern 1.\");\n@@ -166,8 +166,8 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n           .take_while(|line| line_regex.is_match(&line))\n           .filter_map(|line| {\n               regex.captures_iter(&line).next().map(|capture| {\n-                  (capture.at(1).expect(\"Couldn\\'t unwrap capture.\").to_owned(),\n-                   capture.at(2).expect(\"Couldn\\'t unwrap capture.\").to_owned())\n+                  (capture.at(1).expect(\"Couldn't unwrap capture.\").to_owned(),\n+                   capture.at(2).expect(\"Couldn't unwrap capture.\").to_owned())\n               })\n           })\n           .collect()\n@@ -185,7 +185,7 @@ fn handle_result(result: HashMap<String, String>) {\n \n         // If file is in tests/source, compare to file with same name in tests/target.\n         let target = get_target(&file_name, sig_comments.get(\"target\").map(|x| &(*x)[..]));\n-        let mut f = fs::File::open(&target).ok().expect(\"Couldn\\'t open target.\");\n+        let mut f = fs::File::open(&target).ok().expect(\"Couldn't open target.\");\n \n         let mut text = String::new();\n         // TODO: speedup by running through bytes iterator"}, {"sha": "9b1f244637dd48558146b4a36202e9758e78aa6a", "filename": "tests/target/chains-no-overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/tests%2Ftarget%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/tests%2Ftarget%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overflow.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -27,8 +27,8 @@ fn main() {\n     fffffffffffffffffffffffffffffffffff(a,\n                                         {\n                                             SCRIPT_TASK_ROOT.with(|root| {\n-                                                                // Another case of write_list failing us.\n-                                                                *root.borrow_mut() = Some(&script_task);\n+                                                                *root.borrow_mut() =\n+                                                                    Some(&script_task);\n                                                             });\n                                         });\n "}, {"sha": "590f0a5b1569d9237fac7cb6a2bc3ace0b5a8383", "filename": "tests/target/chains.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -1,7 +1,7 @@\n // Test chain formatting.\n \n fn main() {\n-    // Don't put chains on a single list if it wasn't so in source.\n+    // Don't put chains on a single line if it wasn't so in source.\n     let a = b.c\n              .d\n              .1\n@@ -13,6 +13,8 @@ fn main() {\n                        .ddddddddddddddddddddddddddd\n                        .eeeeeeee();\n \n+    // Test case where first chain element isn't a path, but is shorter than\n+    // the size of a tab.\n     x().y(|| {\n         match cond() {\n             true => (),"}, {"sha": "b42296487bede1b00820c7b7abdd5b5fc0de7192", "filename": "tests/target/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -39,8 +39,8 @@ fn main() {\n     let empty = |arg| {};\n \n     let simple = |arg| { /* TODO(#27): comment formatting */\n-                     foo(arg)\n-                 };\n+        foo(arg)\n+    };\n \n     let test = || {\n         do_something();\n@@ -62,8 +62,8 @@ fn main() {\n     let closure_with_return_type = |aaaaaaaaaaaaaaaaaaaaaaarg1,\n                                     aaaaaaaaaaaaaaaaaaaaaaarg2|\n                                     -> Strong {\n-                                       \"sup\".to_owned()\n-                                   };\n+        \"sup\".to_owned()\n+    };\n \n     |arg1, arg2, _, _, arg3, arg4| {\n         let temp = arg4 + arg3;"}, {"sha": "36f8f6a48f9307518168ac162c1afe8d85f50037", "filename": "tests/target/string-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f576b06022357672eb24d6103673f982a6ba817/tests%2Ftarget%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f576b06022357672eb24d6103673f982a6ba817/tests%2Ftarget%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring-lit.rs?ref=7f576b06022357672eb24d6103673f982a6ba817", "patch": "@@ -36,5 +36,5 @@ formatting\"#;\n     let unicode4 = \"\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\\\n                     \u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\";\n \n-    \"stuff\"\n+    \"stuffin'\"\n }"}]}