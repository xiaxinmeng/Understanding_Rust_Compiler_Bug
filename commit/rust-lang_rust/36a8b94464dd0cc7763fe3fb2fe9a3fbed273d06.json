{"sha": "36a8b94464dd0cc7763fe3fb2fe9a3fbed273d06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YThiOTQ0NjRkZDBjYzc3NjNmZTNmYjJmZTlhM2ZiZWQyNzNkMDY=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-27T01:12:36Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-27T01:12:36Z"}, "message": "expand lifetime splitting to show IterMut is totally safe", "tree": {"sha": "853b40e78fcd6aceefd396969ca590c3766e53bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/853b40e78fcd6aceefd396969ca590c3766e53bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36a8b94464dd0cc7763fe3fb2fe9a3fbed273d06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36a8b94464dd0cc7763fe3fb2fe9a3fbed273d06", "html_url": "https://github.com/rust-lang/rust/commit/36a8b94464dd0cc7763fe3fb2fe9a3fbed273d06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36a8b94464dd0cc7763fe3fb2fe9a3fbed273d06/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f54c5ad5660e81972b772be1c8852e1ef2969f28", "url": "https://api.github.com/repos/rust-lang/rust/commits/f54c5ad5660e81972b772be1c8852e1ef2969f28", "html_url": "https://github.com/rust-lang/rust/commit/f54c5ad5660e81972b772be1c8852e1ef2969f28"}], "stats": {"total": 247, "additions": 194, "deletions": 53}, "files": [{"sha": "9b6b769520facc6d18df2893c5b078773dc4c131", "filename": "src/doc/tarpl/lifetime-splitting.md", "status": "modified", "additions": 194, "deletions": 53, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/36a8b94464dd0cc7763fe3fb2fe9a3fbed273d06/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md", "raw_url": "https://github.com/rust-lang/rust/raw/36a8b94464dd0cc7763fe3fb2fe9a3fbed273d06/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md?ref=36a8b94464dd0cc7763fe3fb2fe9a3fbed273d06", "patch": "@@ -1,10 +1,10 @@\n % Splitting Lifetimes\n \n The mutual exclusion property of mutable references can be very limiting when\n-working with a composite structure. The borrow checker understands some basic stuff, but\n-will fall over pretty easily. It *does* understand structs sufficiently to\n-know that it's possible to borrow disjoint fields of a struct simultaneously.\n-So this works today:\n+working with a composite structure. The borrow checker understands some basic\n+stuff, but will fall over pretty easily. It *does* understand structs\n+sufficiently to know that it's possible to borrow disjoint fields of a struct\n+simultaneously. So this works today:\n \n ```rust\n struct Foo {\n@@ -49,11 +49,11 @@ container types like a tree, especially if distinct keys actually *do* map\n to the same value.\n \n In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n-to unsafe code. For instance, mutable slices expose a `split_at_mut` function that\n-consumes the slice and returns *two* mutable slices. One for everything to the\n-left of the index, and one for everything to the right. Intuitively we know this\n-is safe because the slices don't alias. However the implementation requires some\n-unsafety:\n+to unsafe code. For instance, mutable slices expose a `split_at_mut` function\n+that consumes the slice and returns *two* mutable slices. One for everything to\n+the left of the index, and one for everything to the right. Intuitively we know\n+this is safe because the slices don't alias. However the implementation requires\n+some unsafety:\n \n ```rust,ignore\n fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n@@ -66,9 +66,9 @@ fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n }\n ```\n \n-This is pretty plainly dangerous. We use transmute to duplicate the slice with an\n-*unbounded* lifetime, so that it can be treated as disjoint from the other until\n-we unify them when we return.\n+This is pretty plainly dangerous. We use transmute to duplicate the slice with\n+an *unbounded* lifetime, so that it can be treated as disjoint from the other\n+until we unify them when we return.\n \n However more subtle is how iterators that yield mutable references work.\n The iterator trait is defined as follows:\n@@ -81,60 +81,201 @@ trait Iterator {\n }\n ```\n \n-Given this definition, Self::Item has *no* connection to `self`. This means\n-that we can call `next` several times in a row, and hold onto all the results\n-*concurrently*. This is perfectly fine for by-value iterators, which have exactly\n-these semantics. It's also actually fine for shared references, as they admit\n-arbitrarily many references to the same thing (although the\n-iterator needs to be a separate object from the thing being shared). But mutable\n-references make this a mess. At first glance, they might seem completely\n-incompatible with this API, as it would produce multiple mutable references to\n-the same object!\n+Given this definition, Self::Item has *no* connection to `self`. This means that\n+we can call `next` several times in a row, and hold onto all the results\n+*concurrently*. This is perfectly fine for by-value iterators, which have\n+exactly these semantics. It's also actually fine for shared references, as they\n+admit arbitrarily many references to the same thing (although the iterator needs\n+to be a separate object from the thing being shared).\n+\n+But mutable references make this a mess. At first glance, they might seem\n+completely incompatible with this API, as it would produce multiple mutable\n+references to the same object!\n \n However it actually *does* work, exactly because iterators are one-shot objects.\n-Everything an IterMut yields will be yielded *at most* once, so we don't *actually*\n-ever yield multiple mutable references to the same piece of data.\n+Everything an IterMut yields will be yielded *at most* once, so we don't\n+*actually* ever yield multiple mutable references to the same piece of data.\n \n-In general all mutable iterators require *some* unsafe code *somewhere*, though.\n-Whether it's raw pointers, or safely composing on top of *another* IterMut.\n+Perhaps surprisingly, mutable iterators *don't* require unsafe code to be\n+implemented for many types!\n \n-For instance, VecDeque's IterMut:\n+For instance here's a singly linked list:\n \n-```rust,ignore\n-struct IterMut<'a, T:'a> {\n-    // The whole backing array. Some of these indices are initialized!\n-    ring: &'a mut [T],\n-    tail: usize,\n-    head: usize,\n+```rust\n+# fn main() {}\n+type Link<T> = Option<Box<Node<T>>>;\n+\n+struct Node<T> {\n+    elem: T,\n+    next: Link<T>,\n+}\n+\n+pub struct LinkedList<T> {\n+    head: Link<T>,\n+}\n+\n+pub struct IterMut<'a, T: 'a>(Option<&'a mut Node<T>>);\n+\n+impl<T> LinkedList<T> {\n+    fn iter_mut(&mut self) -> IterMut<T> {\n+        IterMut(self.head.as_mut().map(|node| &mut **node))\n+    }\n }\n \n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n-    fn next(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.take().map(|node| {\n+            self.0 = node.next.as_mut().map(|node| &mut **node);\n+            &mut node.elem\n+        })\n+    }\n+}\n+```\n+\n+Here's a mutable slice:\n+\n+```rust\n+use std::mem;\n+\n+pub struct IterMut<'a, T: 'a>(&'a mut[T]);\n+\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        if slice.is_empty() { return None; }\n+\n+        let (l, r) = slice.split_at_mut(1);\n+        self.0 = r;\n+        l.get_mut(0)\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        if slice.is_empty() { return None; }\n+\n+        let new_len = slice.len() - 1;\n+        let (l, r) = slice.split_at_mut(new_len);\n+        self.0 = l;\n+        r.get_mut(0)\n+    }\n+}\n+```\n+\n+And here's a binary tree:\n+\n+```rust\n+use std::collections::VecDeque;\n+\n+type Link<T> = Option<Box<Node<T>>>;\n+\n+struct Node<T> {\n+    elem: T,\n+    left: Link<T>,\n+    right: Link<T>,\n+}\n+\n+pub struct Tree<T> {\n+    root: Link<T>,\n+}\n+\n+struct NodeIterMut<'a, T: 'a> {\n+    elem: Option<&'a mut T>,\n+    left: Option<&'a mut Node<T>>,\n+    right: Option<&'a mut Node<T>>,\n+}\n+\n+enum State<'a, T: 'a> {\n+    Elem(&'a mut T),\n+    Node(&'a mut Node<T>),\n+}\n+\n+pub struct IterMut<'a, T: 'a>(VecDeque<NodeIterMut<'a, T>>);\n+\n+impl<T> Tree<T> {\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        let mut deque = VecDeque::new();\n+        self.root.as_mut().map(|root| deque.push_front(root.iter_mut()));\n+        IterMut(deque)\n+    }\n+}\n+\n+impl<T> Node<T> {\n+    pub fn iter_mut(&mut self) -> NodeIterMut<T> {\n+        NodeIterMut {\n+            elem: Some(&mut self.elem),\n+            left: self.left.as_mut().map(|node| &mut **node),\n+            right: self.right.as_mut().map(|node| &mut **node),\n+        }\n+    }\n+}\n+\n+\n+impl<'a, T> Iterator for NodeIterMut<'a, T> {\n+    type Item = State<'a, T>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.left.take() {\n+            Some(node) => Some(State::Node(node)),\n+            None => match self.elem.take() {\n+                Some(elem) => Some(State::Elem(elem)),\n+                None => match self.right.take() {\n+                    Some(node) => Some(State::Node(node)),\n+                    None => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for NodeIterMut<'a, T> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        match self.right.take() {\n+            Some(node) => Some(State::Node(node)),\n+            None => match self.elem.take() {\n+                Some(elem) => Some(State::Elem(elem)),\n+                None => match self.left.take() {\n+                    Some(node) => Some(State::Node(node)),\n+                    None => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            match self.0.front_mut().and_then(|node_it| node_it.next()) {\n+                Some(State::Elem(elem)) => return Some(elem),\n+                Some(State::Node(node)) => self.0.push_front(node.iter_mut()),\n+                None => if let None = self.0.pop_front() { return None },\n+            }\n         }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-\n-        unsafe {\n-            // might as well do unchecked indexing since wrap_index has us\n-            // in-bounds, and many of the \"middle\" indices are uninitialized\n-            // anyway.\n-            let elem = self.ring.get_unchecked_mut(tail);\n-\n-            // round-trip through a raw pointer to unbound the lifetime from\n-            // ourselves\n-            Some(&mut *(elem as *mut _))\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            match self.0.back_mut().and_then(|node_it| node_it.next_back()) {\n+                Some(State::Elem(elem)) => return Some(elem),\n+                Some(State::Node(node)) => self.0.push_back(node.iter_mut()),\n+                None => if let None = self.0.pop_back() { return None },\n+            }\n         }\n     }\n }\n ```\n \n-A very subtle but interesting detail in this design is that it *relies on\n-privacy to be sound*. Borrowck works on some very simple rules. One of those rules\n-is that if we have a live &mut Foo and Foo contains an &mut Bar, then that &mut\n-Bar is *also* live. Since IterMut is always live when `next` can be called, if\n-`ring` were public then we could mutate `ring` while outstanding mutable borrows\n-to it exist!\n+All of these are completely safe and work on stable Rust! This ultimately\n+falls out of the simple struct case we saw before: Rust understands that you\n+can safely split a mutable reference into subfields. We can then encode\n+permanently consuming a reference via Options (or in the case of slices,\n+replacing with an empty slice)."}]}