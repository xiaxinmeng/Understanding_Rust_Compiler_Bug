{"sha": "ca1e94b131eec4795f1a8dcacdb12f574e7a4a74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMWU5NGIxMzFlZWM0Nzk1ZjFhOGRjYWNkYjEyZjU3NGU3YTRhNzQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-07T06:42:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-11T10:04:49Z"}, "message": "warn for more cases", "tree": {"sha": "5af7873e5a7bd5d18a442b705a6b421f4207a446", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5af7873e5a7bd5d18a442b705a6b421f4207a446"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74", "html_url": "https://github.com/rust-lang/rust/commit/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da6fbb18951547da08c2e353838e6b1d47d9b3be", "url": "https://api.github.com/repos/rust-lang/rust/commits/da6fbb18951547da08c2e353838e6b1d47d9b3be", "html_url": "https://github.com/rust-lang/rust/commit/da6fbb18951547da08c2e353838e6b1d47d9b3be"}], "stats": {"total": 220, "additions": 204, "deletions": 16}, "files": [{"sha": "c652c196afd0d16eaef1bcd6c09c675dfda85ea7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ca1e94b131eec4795f1a8dcacdb12f574e7a4a74", "patch": "@@ -23,7 +23,7 @@\n \n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, layout::VariantIdx};\n use rustc::{lint, util};\n use hir::Node;\n use util::nodemap::HirIdSet;\n@@ -1879,11 +1879,40 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n \n         /// Return `false` only if we are sure this type does *not*\n         /// allow zero initialization.\n-        fn ty_maybe_allows_zero_init(ty: Ty<'_>) -> bool {\n+        fn ty_maybe_allows_zero_init<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n             use rustc::ty::TyKind::*;\n             match ty.sty {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) | FnPtr(..) | Never => false,\n+                Adt(..) if ty.is_box() => false,\n+                // Recurse for some compound types.\n+                Adt(adt_def, substs) if !adt_def.is_union() => {\n+                    match adt_def.variants.len() {\n+                        0 => false, // Uninhabited enum!\n+                        1 => {\n+                            // Struct, or enum with exactly one variant.\n+                            // Proceed recursively, check all fields.\n+                            let variant = &adt_def.variants[VariantIdx::from_u32(0)];\n+                            variant.fields.iter().all(|field| {\n+                                ty_maybe_allows_zero_init(\n+                                    tcx,\n+                                    field.ty(tcx, substs),\n+                                )\n+                            })\n+                        }\n+                        _ => true, // Conservative fallback for multi-variant enum.\n+                    }\n+                }\n+                Tuple(substs) => {\n+                    // Proceed recursively, check all fields.\n+                    substs.iter().all(|field| {\n+                        ty_maybe_allows_zero_init(\n+                            tcx,\n+                            field.expect_ty(),\n+                        )\n+                    })\n+                }\n+                // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n                 // Conservative fallback.\n                 _ => true,\n             }\n@@ -1900,8 +1929,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                         // We are extremely conservative with what we warn about.\n                         let conjured_ty = cx.tables.expr_ty(expr);\n \n-                        if !ty_maybe_allows_zero_init(conjured_ty) {\n-                            cx.span_lint(\n+                        if !ty_maybe_allows_zero_init(cx.tcx, conjured_ty) {\n+                            cx.struct_span_lint(\n                                 INVALID_VALUE,\n                                 expr.span,\n                                 &format!(\n@@ -1913,7 +1942,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                         \"being left uninitialized\"\n                                     }\n                                 ),\n-                            );\n+                            )\n+                            .note(\"this means that this code causes undefined behavior \\\n+                                when executed\")\n+                            .help(\"use `MaybeUninit` instead\")\n+                            .emit();\n                         }\n                     }\n                 }"}, {"sha": "8f9ca8717bda6b1ed77847b7247b3d9c636f2c52", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=ca1e94b131eec4795f1a8dcacdb12f574e7a4a74", "patch": "@@ -6,22 +6,52 @@\n #![allow(deprecated)]\n #![deny(invalid_value)]\n \n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n+\n+enum Void {}\n+\n+struct Ref(&'static i32);\n+\n+struct Wrap<T> { wrapped: T }\n+\n+#[allow(unused)]\n+fn generic<T: 'static>() {\n+    unsafe {\n+        let _val: &'static T = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static T = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<&'static T> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Wrap<&'static T> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+    }\n+}\n \n fn main() {\n     unsafe {\n         let _val: ! = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: ! = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: (i32, !) = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: (i32, !) = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Void = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Void = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         let _val: &'static i32 = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: &'static i32 = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: Ref = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Ref = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         let _val: fn() = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: fn() = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: Wrap<fn()> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Wrap<fn()> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Some types that should work just fine.\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();\n+        let _val: MaybeUninit<&'static i32> = mem::zeroed();\n         let _val: bool = mem::zeroed();\n         let _val: i32 = mem::zeroed();\n     }"}, {"sha": "af54b16bd0b242552b7766bfcf41c85561f16fd8", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 135, "deletions": 10, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e94b131eec4795f1a8dcacdb12f574e7a4a74/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=ca1e94b131eec4795f1a8dcacdb12f574e7a4a74", "patch": "@@ -1,44 +1,169 @@\n-error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:15:23\n+error: the type `&'static T` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:20:32\n    |\n-LL |         let _val: ! = mem::zeroed();\n-   |                       ^^^^^^^^^^^^^\n+LL |         let _val: &'static T = mem::zeroed();\n+   |                                ^^^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/uninitialized-zeroed.rs:7:9\n    |\n LL | #![deny(invalid_value)]\n    |         ^^^^^^^^^^^^^\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `&'static T` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:21:32\n+   |\n+LL |         let _val: &'static T = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<&'static T>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:23:38\n+   |\n+LL |         let _val: Wrap<&'static T> = mem::zeroed();\n+   |                                      ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<&'static T>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:24:38\n+   |\n+LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `!` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:30:23\n+   |\n+LL |         let _val: ! = mem::zeroed();\n+   |                       ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:16:23\n+  --> $DIR/uninitialized-zeroed.rs:31:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `(i32, !)` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:33:30\n+   |\n+LL |         let _val: (i32, !) = mem::zeroed();\n+   |                              ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `(i32, !)` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:34:30\n+   |\n+LL |         let _val: (i32, !) = mem::uninitialized();\n+   |                              ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Void` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:36:26\n+   |\n+LL |         let _val: Void = mem::zeroed();\n+   |                          ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Void` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:37:26\n+   |\n+LL |         let _val: Void = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n \n error: the type `&'static i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:21:34\n+  --> $DIR/uninitialized-zeroed.rs:39:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n \n error: the type `&'static i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:22:34\n+  --> $DIR/uninitialized-zeroed.rs:40:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Ref` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:42:25\n+   |\n+LL |         let _val: Ref = mem::zeroed();\n+   |                         ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Ref` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:43:25\n+   |\n+LL |         let _val: Ref = mem::uninitialized();\n+   |                         ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:24:26\n+  --> $DIR/uninitialized-zeroed.rs:45:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:25:26\n+  --> $DIR/uninitialized-zeroed.rs:46:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<fn()>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:48:32\n+   |\n+LL |         let _val: Wrap<fn()> = mem::zeroed();\n+   |                                ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<fn()>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:49:32\n+   |\n+LL |         let _val: Wrap<fn()> = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 18 previous errors\n "}]}