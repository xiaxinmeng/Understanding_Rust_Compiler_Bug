{"sha": "c9bacb70f0b19d324a548bd7942692ab18d159a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YmFjYjcwZjBiMTlkMzI0YTU0OGJkNzk0MjY5MmFiMThkMTU5YTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-25T01:20:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-25T01:20:38Z"}, "message": "Auto merge of #66671 - matthewjasper:ast-address-of, r=Centril\n\nAst address-of\n\nThis is the parts of #64588 that don't affect MIR. If an address-of expression makes it to MIR lowering we error and lower to the best currently expressible approximation to limit further errors.\n\nr? @Centril", "tree": {"sha": "66f7ee078e270f46163da47516b38139204476bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66f7ee078e270f46163da47516b38139204476bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9bacb70f0b19d324a548bd7942692ab18d159a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bacb70f0b19d324a548bd7942692ab18d159a4", "html_url": "https://github.com/rust-lang/rust/commit/c9bacb70f0b19d324a548bd7942692ab18d159a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9bacb70f0b19d324a548bd7942692ab18d159a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "388ffd9df83cfac20b3fbf7128eb44d5b1526f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/388ffd9df83cfac20b3fbf7128eb44d5b1526f8c", "html_url": "https://github.com/rust-lang/rust/commit/388ffd9df83cfac20b3fbf7128eb44d5b1526f8c"}, {"sha": "f4efc5de8a91c8322f83fe07ced5ab119a457ade", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4efc5de8a91c8322f83fe07ced5ab119a457ade", "html_url": "https://github.com/rust-lang/rust/commit/f4efc5de8a91c8322f83fe07ced5ab119a457ade"}], "stats": {"total": 819, "additions": 678, "deletions": 141}, "files": [{"sha": "a4557a0776ca4dad56f6317cd4554d8722114696", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -1024,7 +1024,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n         ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {"}, {"sha": "f8465baeb1305e917a1b4757f2b173fa3163beb0", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -65,9 +65,9 @@ impl LoweringContext<'_> {\n                 let expr = P(self.lower_expr(expr));\n                 hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n             }\n-            ExprKind::AddrOf(m, ref ohs) => {\n+            ExprKind::AddrOf(k, m, ref ohs) => {\n                 let ohs = P(self.lower_expr(ohs));\n-                hir::ExprKind::AddrOf(m, ohs)\n+                hir::ExprKind::AddrOf(k, m, ohs)\n             }\n             ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n@@ -1339,7 +1339,11 @@ impl LoweringContext<'_> {\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n-        self.expr(span, hir::ExprKind::AddrOf(hir::Mutability::Mutable, e), ThinVec::new())\n+        self.expr(\n+            span,\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mutable, e),\n+            ThinVec::new(),\n+        )\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> hir::Expr {"}, {"sha": "66bb3a8d883a4670136cf944604725aaa1557777", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -21,7 +21,8 @@ use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n-pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy, IsAuto, ImplPolarity};\n+pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy};\n+pub use syntax::ast::{IsAuto, ImplPolarity, BorrowKind};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n@@ -1493,8 +1494,20 @@ impl Expr {\n         }\n     }\n \n-    pub fn is_place_expr(&self) -> bool {\n-         match self.kind {\n+    // Whether this looks like a place expr, without checking for deref\n+    // adjustments.\n+    // This will return `true` in some potentially surprising cases such as\n+    // `CONSTANT.field`.\n+    pub fn is_syntactic_place_expr(&self) -> bool {\n+        self.is_place_expr(|_| true)\n+    }\n+\n+    // Whether this is a place expression.\n+    // `allow_projections_from` should return `true` if indexing a field or\n+    // index expression based on the given expression should be considered a\n+    // place expression.\n+    pub fn is_place_expr(&self, mut allow_projections_from: impl FnMut(&Self) -> bool) -> bool {\n+        match self.kind {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => {\n                 match path.res {\n                     Res::Local(..)\n@@ -1504,14 +1517,19 @@ impl Expr {\n                 }\n             }\n \n+            // Type ascription inherits its place expression kind from its\n+            // operand. See:\n+            // https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md#type-ascription-and-temporaries\n             ExprKind::Type(ref e, _) => {\n-                e.is_place_expr()\n+                e.is_place_expr(allow_projections_from)\n             }\n \n-            ExprKind::Unary(UnDeref, _) |\n-            ExprKind::Field(..) |\n-            ExprKind::Index(..) => {\n-                true\n+            ExprKind::Unary(UnDeref, _) => true,\n+\n+            ExprKind::Field(ref base, _) |\n+            ExprKind::Index(ref base, _) => {\n+                allow_projections_from(base)\n+                    || base.is_place_expr(allow_projections_from)\n             }\n \n             // Partially qualified paths in expressions can only legally\n@@ -1646,8 +1664,8 @@ pub enum ExprKind {\n     /// Path to a definition, possibly containing lifetime or type parameters.\n     Path(QPath),\n \n-    /// A referencing operation (i.e., `&a` or `&mut a`).\n-    AddrOf(Mutability, P<Expr>),\n+    /// A referencing operation (i.e., `&a`, `&mut a`, `&raw const a`, or `&raw mut a`).\n+    AddrOf(BorrowKind, Mutability, P<Expr>),\n     /// A `break`, with an optional label to break.\n     Break(Destination, Option<P<Expr>>),\n     /// A `continue`, with an optional label."}, {"sha": "a069331582ea67096a8f0c8c34f8aad58e59b045", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -294,16 +294,12 @@ impl<'a> State<'a> {\n             }\n             hir::TyKind::Ptr(ref mt) => {\n                 self.s.word(\"*\");\n-                match mt.mutbl {\n-                    hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-                    hir::Mutability::Immutable => self.word_nbsp(\"const\"),\n-                }\n-                self.print_type(&mt.ty);\n+                self.print_mt(mt, true);\n             }\n             hir::TyKind::Rptr(ref lifetime, ref mt) => {\n                 self.s.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n-                self.print_mt(mt);\n+                self.print_mt(mt, false);\n             }\n             hir::TyKind::Never => {\n                 self.s.word(\"!\");\n@@ -1178,11 +1174,18 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_addr_of(&mut self,\n+                          kind: hir::BorrowKind,\n                           mutability: hir::Mutability,\n                           expr: &hir::Expr)\n-                          {\n+    {\n         self.s.word(\"&\");\n-        self.print_mutability(mutability);\n+        match kind {\n+            hir::BorrowKind::Ref => self.print_mutability(mutability, false),\n+            hir::BorrowKind::Raw => {\n+                self.word_nbsp(\"raw\");\n+                self.print_mutability(mutability, true);\n+            }\n+        }\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n@@ -1225,8 +1228,8 @@ impl<'a> State<'a> {\n             hir::ExprKind::Unary(op, ref expr) => {\n                 self.print_expr_unary(op, &expr);\n             }\n-            hir::ExprKind::AddrOf(m, ref expr) => {\n-                self.print_expr_addr_of(m, &expr);\n+            hir::ExprKind::AddrOf(k, m, ref expr) => {\n+                self.print_expr_addr_of(k, m, &expr);\n             }\n             hir::ExprKind::Lit(ref lit) => {\n                 self.print_literal(&lit);\n@@ -1629,11 +1632,11 @@ impl<'a> State<'a> {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Immutable);\n+                        self.print_mutability(hir::Mutability::Immutable, false);\n                     }\n                     hir::BindingAnnotation::RefMut => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Mutable);\n+                        self.print_mutability(hir::Mutability::Mutable, false);\n                     }\n                     hir::BindingAnnotation::Unannotated => {}\n                     hir::BindingAnnotation::Mutable => {\n@@ -2060,15 +2063,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_mutability(&mut self, mutbl: hir::Mutability) {\n+    pub fn print_mutability(&mut self, mutbl: hir::Mutability, print_const: bool) {\n         match mutbl {\n             hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-            hir::Mutability::Immutable => {},\n+            hir::Mutability::Immutable => if print_const { self.word_nbsp(\"const\") },\n         }\n     }\n \n-    pub fn print_mt(&mut self, mt: &hir::MutTy) {\n-        self.print_mutability(mt.mutbl);\n+    pub fn print_mt(&mut self, mt: &hir::MutTy, print_const: bool) {\n+        self.print_mutability(mt.mutbl, print_const);\n         self.print_type(&mt.ty)\n     }\n "}, {"sha": "00bddf50c293e27826662855b2e2b8fe10cd6628", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprKind::AddrOf(m, ref base) => {   // &base\n+            hir::ExprKind::AddrOf(_, m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let bk = ty::BorrowKind::from_mutbl(m);"}, {"sha": "aa6f28398289fa77e55681f568610682d703bae2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -1241,7 +1241,7 @@ fn resolve_local<'tcx>(\n         blk_id: Option<Scope>,\n     ) {\n         match expr.kind {\n-            hir::ExprKind::AddrOf(_, ref subexpr) => {\n+            hir::ExprKind::AddrOf(_, _, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 record_rvalue_scope(visitor, &subexpr, blk_id);\n             }\n@@ -1301,7 +1301,7 @@ fn resolve_local<'tcx>(\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n             match expr.kind {\n-                hir::ExprKind::AddrOf(_, ref subexpr) |\n+                hir::ExprKind::AddrOf(_, _, ref subexpr) |\n                 hir::ExprKind::Unary(hir::UnDeref, ref subexpr) |\n                 hir::ExprKind::Field(ref subexpr, _) |\n                 hir::ExprKind::Index(ref subexpr, _) => {"}, {"sha": "709ccce517a36a2ea70f9c1234e0de7aa05f6fa7", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -409,6 +409,7 @@ E0741: include_str!(\"./error_codes/E0741.md\"),\n E0742: include_str!(\"./error_codes/E0742.md\"),\n E0743: include_str!(\"./error_codes/E0743.md\"),\n E0744: include_str!(\"./error_codes/E0744.md\"),\n+E0745: include_str!(\"./error_codes/E0745.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "7c478a1e0c8b1d0cfb239dff72a970b6a8ffbe17", "filename": "src/librustc_error_codes/error_codes/E0745.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,20 @@\n+Cannot take address of temporary value.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0745\n+# #![feature(raw_ref_op)]\n+fn temp_address() {\n+    let ptr = &raw const 2;   // ERROR\n+}\n+```\n+\n+To avoid the error, first bind the temporary to a named local variable.\n+\n+```ignore\n+# #![feature(raw_ref_op)]\n+fn temp_address() {\n+    let val = 2;\n+    let ptr = &raw const val;\n+}\n+```"}, {"sha": "afc4e461c0df5c55d5e1366a4e1042085dbd5eaf", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 79, "deletions": 52, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -137,55 +137,8 @@ fn apply_adjustment<'a, 'tcx>(\n                 arg: expr.to_ref(),\n             }\n         }\n-        Adjust::Borrow(AutoBorrow::RawPtr(m)) => {\n-            // Convert this to a suitable `&foo` and\n-            // then an unsafe coercion.\n-            expr = Expr {\n-                temp_lifetime,\n-                ty: cx.tcx.mk_ref(cx.tcx.lifetimes.re_erased,\n-                                  ty::TypeAndMut {\n-                                    ty: expr.ty,\n-                                    mutbl: m,\n-                                  }),\n-                span,\n-                kind: ExprKind::Borrow {\n-                    borrow_kind: m.to_borrow_kind(),\n-                    arg: expr.to_ref(),\n-                },\n-            };\n-            let cast_expr = Expr {\n-                temp_lifetime,\n-                ty: adjustment.target,\n-                span,\n-                kind: ExprKind::Cast { source: expr.to_ref() }\n-            };\n-\n-            // To ensure that both implicit and explicit coercions are\n-            // handled the same way, we insert an extra layer of indirection here.\n-            // For explicit casts (e.g., 'foo as *const T'), the source of the 'Use'\n-            // will be an ExprKind::Hair with the appropriate cast expression. Here,\n-            // we make our Use source the generated Cast from the original coercion.\n-            //\n-            // In both cases, this outer 'Use' ensures that the inner 'Cast' is handled by\n-            // as_operand, not by as_rvalue - causing the cast result to be stored in a temporary.\n-            // Ordinary, this is identical to using the cast directly as an rvalue. However, if the\n-            // source of the cast was previously borrowed as mutable, storing the cast in a\n-            // temporary gives the source a chance to expire before the cast is used. For\n-            // structs with a self-referential *mut ptr, this allows assignment to work as\n-            // expected.\n-            //\n-            // For example, consider the type 'struct Foo { field: *mut Foo }',\n-            // The method 'fn bar(&mut self) { self.field = self }'\n-            // triggers a coercion from '&mut self' to '*mut self'. In order\n-            // for the assignment to be valid, the implicit borrow\n-            // of 'self' involved in the coercion needs to end before the local\n-            // containing the '*mut T' is assigned to 'self.field' - otherwise,\n-            // we end up trying to assign to 'self.field' while we have another mutable borrow\n-            // active.\n-            //\n-            // We only need to worry about this kind of thing for coercions from refs to ptrs,\n-            // since they get rid of a borrow implicitly.\n-            ExprKind::Use { source: cast_expr.to_ref() }\n+        Adjust::Borrow(AutoBorrow::RawPtr(mutbl)) => {\n+            raw_ref_shim(cx, expr.to_ref(), adjustment.target, mutbl, span, temp_lifetime)\n         }\n     };\n \n@@ -302,13 +255,26 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             }\n         }\n \n-        hir::ExprKind::AddrOf(mutbl, ref expr) => {\n+        hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, ref arg) => {\n             ExprKind::Borrow {\n                 borrow_kind: mutbl.to_borrow_kind(),\n-                arg: expr.to_ref(),\n+                arg: arg.to_ref(),\n             }\n         }\n \n+        hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutbl, ref arg) => {\n+            cx.tcx.sess\n+                .struct_span_err(\n+                    expr.span,\n+                    \"raw borrows are not yet implemented\"\n+                )\n+                .note(\"for more information, see https://github.com/rust-lang/rust/issues/64490\")\n+                .emit();\n+\n+            // Lower to an approximation to avoid further errors.\n+            raw_ref_shim(cx, arg.to_ref(), expr_ty, mutbl, expr.span, temp_lifetime)\n+        }\n+\n         hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: &blk },\n \n         hir::ExprKind::Assign(ref lhs, ref rhs) => {\n@@ -742,7 +708,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             let user_provided_types = cx.tables.user_provided_types();\n             let user_ty = user_provided_types.get(ty.hir_id).map(|u_ty| *u_ty);\n             debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n-            if source.is_place_expr() {\n+            if source.is_syntactic_place_expr() {\n                 ExprKind::PlaceTypeAscription {\n                     source: source.to_ref(),\n                     user_ty,\n@@ -1123,6 +1089,67 @@ fn convert_var(\n }\n \n \n+/// Fake `&raw [mut|const] expr` using a borrow and a cast until `AddressOf`\n+/// exists in MIR.\n+fn raw_ref_shim<'tcx>(\n+    cx: &mut Cx<'_, 'tcx>,\n+    arg: ExprRef<'tcx>,\n+    ty: Ty<'tcx>,\n+    mutbl: hir::Mutability,\n+    span: Span,\n+    temp_lifetime: Option<region::Scope>,\n+) -> ExprKind<'tcx> {\n+    let arg_tm = if let ty::RawPtr(type_mutbl) = ty.kind {\n+        type_mutbl\n+    } else {\n+        bug!(\"raw_ref_shim called with non-raw pointer type\");\n+    };\n+    // Convert this to a suitable `&foo` and\n+    // then an unsafe coercion.\n+    let borrow_expr = Expr {\n+        temp_lifetime,\n+        ty: cx.tcx.mk_ref(cx.tcx.lifetimes.re_erased, arg_tm),\n+        span,\n+        kind: ExprKind::Borrow {\n+            borrow_kind: mutbl.to_borrow_kind(),\n+            arg,\n+        },\n+    };\n+    let cast_expr = Expr {\n+        temp_lifetime,\n+        ty,\n+        span,\n+        kind: ExprKind::Cast { source: borrow_expr.to_ref() }\n+    };\n+\n+    // To ensure that both implicit and explicit coercions are\n+    // handled the same way, we insert an extra layer of indirection here.\n+    // For explicit casts (e.g., 'foo as *const T'), the source of the 'Use'\n+    // will be an ExprKind::Hair with the appropriate cast expression. Here,\n+    // we make our Use source the generated Cast from the original coercion.\n+    //\n+    // In both cases, this outer 'Use' ensures that the inner 'Cast' is handled by\n+    // as_operand, not by as_rvalue - causing the cast result to be stored in a temporary.\n+    // Ordinary, this is identical to using the cast directly as an rvalue. However, if the\n+    // source of the cast was previously borrowed as mutable, storing the cast in a\n+    // temporary gives the source a chance to expire before the cast is used. For\n+    // structs with a self-referential *mut ptr, this allows assignment to work as\n+    // expected.\n+    //\n+    // For example, consider the type 'struct Foo { field: *mut Foo }',\n+    // The method 'fn bar(&mut self) { self.field = self }'\n+    // triggers a coercion from '&mut self' to '*mut self'. In order\n+    // for the assignment to be valid, the implicit borrow\n+    // of 'self' involved in the coercion needs to end before the local\n+    // containing the '*mut T' is assigned to 'self.field' - otherwise,\n+    // we end up trying to assign to 'self.field' while we have another mutable borrow\n+    // active.\n+    //\n+    // We only need to worry about this kind of thing for coercions from refs to ptrs,\n+    // since they get rid of a borrow implicitly.\n+    ExprKind::Use { source: cast_expr.to_ref() }\n+}\n+\n fn bin_op(op: hir::BinOpKind) -> BinOp {\n     match op {\n         hir::BinOpKind::Add => BinOp::Add,"}, {"sha": "fc334a558f5b6040cf381d57f993884d735b59e5", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -739,7 +739,7 @@ impl<'a> Parser<'a> {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     s.s.word(\"&\");\n                     s.print_opt_lifetime(lifetime);\n-                    s.print_mutability(mut_ty.mutbl);\n+                    s.print_mutability(mut_ty.mutbl, false);\n                     s.popen();\n                     s.print_type(&mut_ty.ty);\n                     s.print_type_bounds(\" +\", &bounds);"}, {"sha": "43c740f7f93f101dff5b478985cc746b1adce9c5", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -442,11 +442,7 @@ impl<'a> Parser<'a> {\n                 (lo.to(span), self.mk_unary(UnOp::Deref, e))\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n-                self.expect_and()?;\n-                let m = self.parse_mutability();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), ExprKind::AddrOf(m, e))\n+                self.parse_address_of(lo)?\n             }\n             token::Ident(..) if self.token.is_keyword(kw::Box) => {\n                 self.bump();\n@@ -596,6 +592,25 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n+    fn parse_address_of(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+        self.expect_and()?;\n+        let (k, m) = if self.check_keyword(kw::Raw)\n+            && self.look_ahead(1, Token::is_mutability)\n+        {\n+            let found_raw = self.eat_keyword(kw::Raw);\n+            assert!(found_raw);\n+            let mutability = self.parse_const_or_mut().unwrap();\n+            self.sess.gated_spans.gate(sym::raw_ref_op, lo.to(self.prev_span));\n+            (ast::BorrowKind::Raw, mutability)\n+        } else {\n+            (ast::BorrowKind::Ref, self.parse_mutability())\n+        };\n+        let e = self.parse_prefix_expr(None);\n+        let (span, e) = self.interpolated_or_expr_span(e)?;\n+        Ok((lo.to(span), ExprKind::AddrOf(k, m, e)))\n+    }\n+\n     /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n     fn parse_dot_or_call_expr(\n         &mut self,"}, {"sha": "81a39edf215600cb309c0c229192e239ed5ff8e4", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -1174,7 +1174,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Box(ref e) |\n-            hir::ExprKind::AddrOf(_, ref e) |\n+            hir::ExprKind::AddrOf(_, _, ref e) |\n             hir::ExprKind::Cast(ref e, _) |\n             hir::ExprKind::Type(ref e, _) |\n             hir::ExprKind::DropTemps(ref e) |"}, {"sha": "eda19a1a2dad697d66fa422e4aff59af24ed76b3", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -500,7 +500,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             },\n-            (hir::ExprKind::AddrOf(_, ref expr), _, &ty::Ref(_, checked, _)) if {\n+            (\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n+                _,\n+                &ty::Ref(_, checked, _)\n+            ) if {\n                 self.infcx.can_sub(self.param_env, checked, &expected).is_ok() && !is_macro\n             } => {\n                 // We have `&T`, check if what was expected was `T`. If so,"}, {"sha": "6c24f3184ca141c84a5f60049c23207a066ec9cc", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -238,8 +238,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Unary(unop, ref oprnd) => {\n                 self.check_expr_unary(unop, oprnd, expected, needs, expr)\n             }\n-            ExprKind::AddrOf(mutbl, ref oprnd) => {\n-                self.check_expr_addr_of(mutbl, oprnd, expected, expr)\n+            ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n+                self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(ref qpath) => {\n                 self.check_expr_path(qpath, expr)\n@@ -424,6 +424,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_addr_of(\n         &self,\n+        kind: hir::BorrowKind,\n         mutbl: hir::Mutability,\n         oprnd: &'tcx hir::Expr,\n         expected: Expectation<'tcx>,\n@@ -432,7 +433,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n             match ty.kind {\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    if oprnd.is_place_expr() {\n+                    if oprnd.is_syntactic_place_expr() {\n                         // Places may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n@@ -448,24 +449,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n \n         let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n-        if tm.ty.references_error() {\n-            self.tcx.types.err\n-        } else {\n-            // Note: at this point, we cannot say what the best lifetime\n-            // is to use for resulting pointer.  We want to use the\n-            // shortest lifetime possible so as to avoid spurious borrowck\n-            // errors.  Moreover, the longest lifetime will depend on the\n-            // precise details of the value whose address is being taken\n-            // (and how long it is valid), which we don't know yet until type\n-            // inference is complete.\n+        match kind {\n+            _ if tm.ty.references_error() => self.tcx.types.err,\n+            hir::BorrowKind::Raw => {\n+                self.check_named_place_expr(oprnd);\n+                self.tcx.mk_ptr(tm)\n+            }\n+            hir::BorrowKind::Ref => {\n+                // Note: at this point, we cannot say what the best lifetime\n+                // is to use for resulting pointer.  We want to use the\n+                // shortest lifetime possible so as to avoid spurious borrowck\n+                // errors.  Moreover, the longest lifetime will depend on the\n+                // precise details of the value whose address is being taken\n+                // (and how long it is valid), which we don't know yet until\n+                // type inference is complete.\n+                //\n+                // Therefore, here we simply generate a region variable. The\n+                // region inferencer will then select a suitable value.\n+                // Finally, borrowck will infer the value of the region again,\n+                // this time with enough precision to check that the value\n+                // whose address was taken can actually be made to live as long\n+                // as it needs to live.\n+                let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n+                self.tcx.mk_ref(region, tm)\n+            }\n+        }\n+    }\n+\n+    /// Does this expression refer to a place that either:\n+    /// * Is based on a local or static.\n+    /// * Contains a dereference\n+    /// Note that the adjustments for the children of `expr` should already\n+    /// have been resolved.\n+    fn check_named_place_expr(&self, oprnd: &'tcx hir::Expr) {\n+        let is_named = oprnd.is_place_expr(|base| {\n+            // Allow raw borrows if there are any deref adjustments.\n             //\n-            // Therefore, here we simply generate a region variable.  The\n-            // region inferencer will then select the ultimate value.\n-            // Finally, borrowck is charged with guaranteeing that the\n-            // value whose address was taken can actually be made to live\n-            // as long as it needs to live.\n-            let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-            self.tcx.mk_ref(region, tm)\n+            // const VAL: (i32,) = (0,);\n+            // const REF: &(i32,) = &(0,);\n+            //\n+            // &raw const VAL.0;            // ERROR\n+            // &raw const REF.0;            // OK, same as &raw const (*REF).0;\n+            //\n+            // This is maybe too permissive, since it allows\n+            // `let u = &raw const Box::new((1,)).0`, which creates an\n+            // immediately dangling raw pointer.\n+            self.tables.borrow().adjustments().get(base.hir_id).map_or(false, |x| {\n+                x.iter().any(|adj| if let Adjust::Deref(_) = adj.kind {\n+                    true\n+                } else {\n+                    false\n+                })\n+            })\n+        });\n+        if !is_named {\n+            struct_span_err!(self.tcx.sess, oprnd.span, E0745, \"cannot take address of a temporary\")\n+                .span_label(oprnd.span, \"temporary value\")\n+                .emit();\n         }\n     }\n \n@@ -740,7 +780,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.help(msg);\n             }\n             err.emit();\n-        } else if !lhs.is_place_expr() {\n+        } else if !lhs.is_syntactic_place_expr() {\n             struct_span_err!(self.tcx.sess, expr.span, E0070,\n                                 \"invalid left-hand side expression\")\n                 .span_label(expr.span, \"left-hand of expression not valid\")"}, {"sha": "321faa4a3228549e58f0cac3ed2ebee96f9e329c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return_ty\n         };\n \n-        if !lhs_expr.is_place_expr() {\n+        if !lhs_expr.is_syntactic_place_expr() {\n             struct_span_err!(\n                 self.tcx.sess, lhs_expr.span,\n                 E0067, \"invalid left-hand side expression\")"}, {"sha": "f4fdc2882e7026781bf46f3692284769ca6ab8c5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -645,7 +645,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprKind::AddrOf(m, ref base) => {\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref base) => {\n                 self.link_addr_of(expr, m, &base);\n \n                 // Require that when you write a `&expr` expression, the"}, {"sha": "dc26929100a6b33cc16d982439bdb60998456a7e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -754,6 +754,21 @@ impl Mutability {\n     }\n }\n \n+/// The kind of borrow in an `AddrOf` expression,\n+/// e.g., `&place` or `&raw const place`.\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+pub enum BorrowKind {\n+    /// A raw borrow, `&raw const $expr` or `&raw mut $expr`.\n+    /// The resulting type is either `*const T` or `*mut T`\n+    /// where `T = typeof($expr)`.\n+    Ref,\n+    /// A normal borrow, `&$expr` or `&mut $expr`.\n+    /// The resulting type is either `&'a T` or `&'a mut T`\n+    /// where `T = typeof($expr)` and `'a` is some lifetime.\n+    Raw,\n+}\n+\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BinOpKind {\n     /// The `+` operator (addition)\n@@ -1071,7 +1086,7 @@ impl Expr {\n \n             ExprKind::Paren(expr) => expr.to_ty().map(TyKind::Paren)?,\n \n-            ExprKind::AddrOf(mutbl, expr) => expr\n+            ExprKind::AddrOf(BorrowKind::Ref, mutbl, expr) => expr\n                 .to_ty()\n                 .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n \n@@ -1262,8 +1277,8 @@ pub enum ExprKind {\n     /// Optionally \"qualified\" (e.g., `<Vec<T> as SomeTrait>::SomeType`).\n     Path(Option<QSelf>, Path),\n \n-    /// A referencing operation (`&a` or `&mut a`).\n-    AddrOf(Mutability, P<Expr>),\n+    /// A referencing operation (`&a`, `&mut a`, `&raw const a` or `&raw mut a`).\n+    AddrOf(BorrowKind, Mutability, P<Expr>),\n     /// A `break`, with an optional label to break, and an optional expression.\n     Break(Option<Label>, Option<P<Expr>>),\n     /// A `continue`, with an optional label."}, {"sha": "b04b30aa6bc18ab775b893a8476ca53b968846bb", "filename": "src/libsyntax/feature_gate/active.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -520,13 +520,16 @@ declare_features! (\n     /// Allows using the `efiapi` ABI.\n     (active, abi_efiapi, \"1.40.0\", Some(65815), None),\n \n+    /// Allows `&raw const $place_expr` and `&raw mut $place_expr` expressions.\n+    (active, raw_ref_op, \"1.41.0\", Some(64490), None),\n+\n     /// Allows diverging expressions to fall back to `!` rather than `()`.\n     (active, never_type_fallback, \"1.41.0\", Some(65992), None),\n \n     /// Allows using the `#[register_attr]` attribute.\n     (active, register_attr, \"1.41.0\", Some(66080), None),\n \n-    /// Allows using the `#[register_attr]` attribute.\n+    /// Allows using the `#[register_tool]` attribute.\n     (active, register_tool, \"1.41.0\", Some(66079), None),\n \n     /// Allows the use of `if` and `match` in constants."}, {"sha": "846508bd0cd155a42a65da855f48172e9c21a1e9", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -866,6 +866,7 @@ pub fn check_crate(krate: &ast::Crate,\n     gate_all!(generators, \"yield syntax is experimental\");\n     gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n     gate_all!(const_extern_fn, \"`const extern fn` definitions are unstable\");\n+    gate_all!(raw_ref_op, \"raw address of syntax is experimental\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "fbe28215a56c8175b96a527439daf2d33b003468", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -1128,7 +1128,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { kind, id, span, attrs }: &mut Expr,\n             vis.visit_expr(expr);\n             vis.visit_ty(ty);\n         }\n-        ExprKind::AddrOf(_m, ohs) => vis.visit_expr(ohs),\n+        ExprKind::AddrOf(_, _, ohs) => vis.visit_expr(ohs),\n         ExprKind::Let(pat, scrutinee) => {\n             vis.visit_pat(pat);\n             vis.visit_expr(scrutinee);"}, {"sha": "0d2e8dddce671dd5a1df766e65c6781c510e1518", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -984,16 +984,12 @@ impl<'a> State<'a> {\n             }\n             ast::TyKind::Ptr(ref mt) => {\n                 self.s.word(\"*\");\n-                match mt.mutbl {\n-                    ast::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-                    ast::Mutability::Immutable => self.word_nbsp(\"const\"),\n-                }\n-                self.print_type(&mt.ty);\n+                self.print_mt(mt, true);\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n                 self.s.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n-                self.print_mt(mt);\n+                self.print_mt(mt, false);\n             }\n             ast::TyKind::Never => {\n                 self.s.word(\"!\");\n@@ -1974,10 +1970,17 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_addr_of(&mut self,\n+                          kind: ast::BorrowKind,\n                           mutability: ast::Mutability,\n                           expr: &ast::Expr) {\n         self.s.word(\"&\");\n-        self.print_mutability(mutability);\n+        match kind {\n+            ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n+            ast::BorrowKind::Raw => {\n+                self.word_nbsp(\"raw\");\n+                self.print_mutability(mutability, true);\n+            }\n+        }\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n@@ -2028,8 +2031,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::Unary(op, ref expr) => {\n                 self.print_expr_unary(op, expr);\n             }\n-            ast::ExprKind::AddrOf(m, ref expr) => {\n-                self.print_expr_addr_of(m, expr);\n+            ast::ExprKind::AddrOf(k, m, ref expr) => {\n+                self.print_expr_addr_of(k, m, expr);\n             }\n             ast::ExprKind::Lit(ref lit) => {\n                 self.print_literal(lit);\n@@ -2361,7 +2364,7 @@ impl<'a> State<'a> {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(mutbl);\n+                        self.print_mutability(mutbl, false);\n                     }\n                     ast::BindingMode::ByValue(ast::Mutability::Immutable) => {}\n                     ast::BindingMode::ByValue(ast::Mutability::Mutable) => {\n@@ -2504,17 +2507,17 @@ impl<'a> State<'a> {\n     fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n-                self.print_mutability(m);\n+                self.print_mutability(m, false);\n                 self.s.word(\"self\")\n             }\n             SelfKind::Region(ref lt, m) => {\n                 self.s.word(\"&\");\n                 self.print_opt_lifetime(lt);\n-                self.print_mutability(m);\n+                self.print_mutability(m, false);\n                 self.s.word(\"self\")\n             }\n             SelfKind::Explicit(ref typ, m) => {\n-                self.print_mutability(m);\n+                self.print_mutability(m, false);\n                 self.s.word(\"self\");\n                 self.word_space(\":\");\n                 self.print_type(typ)\n@@ -2746,15 +2749,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_mutability(&mut self, mutbl: ast::Mutability) {\n+    pub fn print_mutability(&mut self, mutbl: ast::Mutability, print_const: bool) {\n         match mutbl {\n             ast::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-            ast::Mutability::Immutable => {},\n+            ast::Mutability::Immutable => if print_const { self.word_nbsp(\"const\"); },\n         }\n     }\n \n-    crate fn print_mt(&mut self, mt: &ast::MutTy) {\n-        self.print_mutability(mt.mutbl);\n+    crate fn print_mt(&mut self, mt: &ast::MutTy, print_const: bool) {\n+        self.print_mutability(mt.mutbl, print_const);\n         self.print_type(&mt.ty)\n     }\n "}, {"sha": "5ff337fb60e284ced465195c4f5338a3397f105b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -708,7 +708,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n         ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {"}, {"sha": "3d082101c41084e1d61cbeee6ac87ef14c94ba0c", "filename": "src/libsyntax_expand/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbuild.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -270,7 +270,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))\n+        self.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Immutable, e))\n     }\n \n     pub fn expr_call("}, {"sha": "70ca9c0f7ca82e391ce801c6c73b1d0649622cff", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -98,6 +98,7 @@ symbols! {\n         Auto:               \"auto\",\n         Catch:              \"catch\",\n         Default:            \"default\",\n+        Raw:                \"raw\",\n         Union:              \"union\",\n     }\n \n@@ -546,6 +547,7 @@ symbols! {\n         RangeToInclusive,\n         raw_dylib,\n         raw_identifiers,\n+        raw_ref_op,\n         Ready,\n         reason,\n         recursion_limit,"}, {"sha": "f19d13ff5c5c309ea02771b31c66b36cec2b0b8c", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -139,7 +139,10 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                             Some(make_x()), Some(e), RangeLimits::HalfOpen)));\n             },\n             15 => {\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::AddrOf(Mutability::Immutable, e)));\n+                iter_exprs(\n+                    depth - 1,\n+                    &mut |e| g(ExprKind::AddrOf(BorrowKind::Ref, Mutability::Immutable, e)),\n+                );\n             },\n             16 => {\n                 g(ExprKind::Ret(None));"}, {"sha": "0a44b1cde40b745a2c617587f9f3770ad9ffe7c0", "filename": "src/test/ui/raw-ref-op/feature-raw-ref-op.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Ffeature-raw-ref-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Ffeature-raw-ref-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Ffeature-raw-ref-op.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,21 @@\n+// gate-test-raw_ref_op\n+\n+macro_rules! is_expr {\n+    ($e:expr) => {}\n+}\n+\n+is_expr!(&raw const a);         //~ ERROR raw address of syntax is experimental\n+is_expr!(&raw mut a);           //~ ERROR raw address of syntax is experimental\n+\n+#[cfg(FALSE)]\n+fn cfgd_out() {\n+    let mut a = 0;\n+    &raw const a;               //~ ERROR raw address of syntax is experimental\n+    &raw mut a;                 //~ ERROR raw address of syntax is experimental\n+}\n+\n+fn main() {\n+    let mut y = 123;\n+    let x = &raw const y;       //~ ERROR raw address of syntax is experimental\n+    let x = &raw mut y;         //~ ERROR raw address of syntax is experimental\n+}"}, {"sha": "cbd413aec7bd0c0b98925cca7de6531848a94b1a", "filename": "src/test/ui/raw-ref-op/feature-raw-ref-op.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Ffeature-raw-ref-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Ffeature-raw-ref-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Ffeature-raw-ref-op.stderr?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: raw address of syntax is experimental\n+  --> $DIR/feature-raw-ref-op.rs:13:5\n+   |\n+LL |     &raw const a;\n+   |     ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+   = help: add `#![feature(raw_ref_op)]` to the crate attributes to enable\n+\n+error[E0658]: raw address of syntax is experimental\n+  --> $DIR/feature-raw-ref-op.rs:14:5\n+   |\n+LL |     &raw mut a;\n+   |     ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+   = help: add `#![feature(raw_ref_op)]` to the crate attributes to enable\n+\n+error[E0658]: raw address of syntax is experimental\n+  --> $DIR/feature-raw-ref-op.rs:19:13\n+   |\n+LL |     let x = &raw const y;\n+   |             ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+   = help: add `#![feature(raw_ref_op)]` to the crate attributes to enable\n+\n+error[E0658]: raw address of syntax is experimental\n+  --> $DIR/feature-raw-ref-op.rs:20:13\n+   |\n+LL |     let x = &raw mut y;\n+   |             ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+   = help: add `#![feature(raw_ref_op)]` to the crate attributes to enable\n+\n+error[E0658]: raw address of syntax is experimental\n+  --> $DIR/feature-raw-ref-op.rs:7:10\n+   |\n+LL | is_expr!(&raw const a);\n+   |          ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+   = help: add `#![feature(raw_ref_op)]` to the crate attributes to enable\n+\n+error[E0658]: raw address of syntax is experimental\n+  --> $DIR/feature-raw-ref-op.rs:8:10\n+   |\n+LL | is_expr!(&raw mut a);\n+   |          ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+   = help: add `#![feature(raw_ref_op)]` to the crate attributes to enable\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "de847909eb3712a1a6164d346aafe1c02b96c631", "filename": "src/test/ui/raw-ref-op/raw-ref-op.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,13 @@\n+// FIXME(#64490): make this run-pass\n+\n+#![feature(raw_ref_op)]\n+\n+fn main() {\n+    let mut x = 123;\n+    let c_p = &raw const x;                     //~ ERROR not yet implemented\n+    let m_p = &raw mut x;                       //~ ERROR not yet implemented\n+    let i_r = &x;\n+    assert!(c_p == i_r);\n+    assert!(c_p == m_p);\n+    unsafe { assert!(*c_p == *i_r ); }\n+}"}, {"sha": "04c59c95fca1eba606186ec23aa508809da44e9c", "filename": "src/test/ui/raw-ref-op/raw-ref-op.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-op.stderr?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,18 @@\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-op.rs:7:15\n+   |\n+LL |     let c_p = &raw const x;\n+   |               ^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-op.rs:8:15\n+   |\n+LL |     let m_p = &raw mut x;\n+   |               ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d251586de5595d199cf43d716019d55373754183", "filename": "src/test/ui/raw-ref-op/raw-ref-temp-deref.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,24 @@\n+// FIXME(#64490) This should be check-pass\n+// Check that taking the address of a place that contains a dereference is\n+// allowed.\n+#![feature(raw_ref_op, type_ascription)]\n+\n+const PAIR_REF: &(i32, i64) = &(1, 2);\n+\n+const ARRAY_REF: &[i32; 2] = &[3, 4];\n+const SLICE_REF: &[i32] = &[5, 6];\n+\n+fn main() {\n+    // These are all OK, we're not taking the address of the temporary\n+    let deref_ref = &raw const *PAIR_REF;                       //~ ERROR not yet implemented\n+    let field_deref_ref = &raw const PAIR_REF.0;                //~ ERROR not yet implemented\n+    let deref_ref = &raw const *ARRAY_REF;                      //~ ERROR not yet implemented\n+    let index_deref_ref = &raw const ARRAY_REF[0];              //~ ERROR not yet implemented\n+    let deref_ref = &raw const *SLICE_REF;                      //~ ERROR not yet implemented\n+    let index_deref_ref = &raw const SLICE_REF[1];              //~ ERROR not yet implemented\n+\n+    let x = 0;\n+    let ascribe_ref = &raw const (x: i32);                      //~ ERROR not yet implemented\n+    let ascribe_deref = &raw const (*ARRAY_REF: [i32; 2]);      //~ ERROR not yet implemented\n+    let ascribe_index_deref = &raw const (ARRAY_REF[0]: i32);   //~ ERROR not yet implemented\n+}"}, {"sha": "b0bfc74903b0ce68f97c35a5ab79121a96b41285", "filename": "src/test/ui/raw-ref-op/raw-ref-temp-deref.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.stderr?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,74 @@\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:13:21\n+   |\n+LL |     let deref_ref = &raw const *PAIR_REF;\n+   |                     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:14:27\n+   |\n+LL |     let field_deref_ref = &raw const PAIR_REF.0;\n+   |                           ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:15:21\n+   |\n+LL |     let deref_ref = &raw const *ARRAY_REF;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:16:27\n+   |\n+LL |     let index_deref_ref = &raw const ARRAY_REF[0];\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:17:21\n+   |\n+LL |     let deref_ref = &raw const *SLICE_REF;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:18:27\n+   |\n+LL |     let index_deref_ref = &raw const SLICE_REF[1];\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:21:23\n+   |\n+LL |     let ascribe_ref = &raw const (x: i32);\n+   |                       ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:22:25\n+   |\n+LL |     let ascribe_deref = &raw const (*ARRAY_REF: [i32; 2]);\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/raw-ref-temp-deref.rs:23:31\n+   |\n+LL |     let ascribe_index_deref = &raw const (ARRAY_REF[0]: i32);\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "ac2445f049c66df83e0941b840d9ec2d1756a68e", "filename": "src/test/ui/raw-ref-op/raw-ref-temp.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,29 @@\n+// Ensure that we don't allow taking the address of temporary values\n+#![feature(raw_ref_op, type_ascription)]\n+\n+const PAIR: (i32, i64) = (1, 2);\n+\n+const ARRAY: [i32; 2] = [1, 2];\n+\n+fn main() {\n+    let ref_expr = &raw const 2;                        //~ ERROR cannot take address\n+    let mut_ref_expr = &raw mut 3;                      //~ ERROR cannot take address\n+    let ref_const = &raw const 4;                       //~ ERROR cannot take address\n+    let mut_ref_const = &raw mut 5;                     //~ ERROR cannot take address\n+\n+    let field_ref_expr = &raw const (1, 2).0;           //~ ERROR cannot take address\n+    let mut_field_ref_expr = &raw mut (1, 2).0;         //~ ERROR cannot take address\n+    let field_ref = &raw const PAIR.0;                  //~ ERROR cannot take address\n+    let mut_field_ref = &raw mut PAIR.0;                //~ ERROR cannot take address\n+\n+    let index_ref_expr = &raw const [1, 2][0];          //~ ERROR cannot take address\n+    let mut_index_ref_expr = &raw mut [1, 2][0];        //~ ERROR cannot take address\n+    let index_ref = &raw const ARRAY[0];                //~ ERROR cannot take address\n+    let mut_index_ref = &raw mut ARRAY[1];              //~ ERROR cannot take address\n+\n+    let ref_ascribe = &raw const (2: i32);              //~ ERROR cannot take address\n+    let mut_ref_ascribe = &raw mut (3: i32);            //~ ERROR cannot take address\n+\n+    let ascribe_field_ref = &raw const (PAIR.0: i32);   //~ ERROR cannot take address\n+    let ascribe_index_ref = &raw mut (ARRAY[0]: i32);   //~ ERROR cannot take address\n+}"}, {"sha": "de07073373506a572053f619db642ce4cf2e2a4d", "filename": "src/test/ui/raw-ref-op/raw-ref-temp.stderr", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp.stderr?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,99 @@\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:9:31\n+   |\n+LL |     let ref_expr = &raw const 2;\n+   |                               ^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:10:33\n+   |\n+LL |     let mut_ref_expr = &raw mut 3;\n+   |                                 ^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:11:32\n+   |\n+LL |     let ref_const = &raw const 4;\n+   |                                ^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:12:34\n+   |\n+LL |     let mut_ref_const = &raw mut 5;\n+   |                                  ^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:14:37\n+   |\n+LL |     let field_ref_expr = &raw const (1, 2).0;\n+   |                                     ^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:15:39\n+   |\n+LL |     let mut_field_ref_expr = &raw mut (1, 2).0;\n+   |                                       ^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:16:32\n+   |\n+LL |     let field_ref = &raw const PAIR.0;\n+   |                                ^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:17:34\n+   |\n+LL |     let mut_field_ref = &raw mut PAIR.0;\n+   |                                  ^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:19:37\n+   |\n+LL |     let index_ref_expr = &raw const [1, 2][0];\n+   |                                     ^^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:20:39\n+   |\n+LL |     let mut_index_ref_expr = &raw mut [1, 2][0];\n+   |                                       ^^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:21:32\n+   |\n+LL |     let index_ref = &raw const ARRAY[0];\n+   |                                ^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:22:34\n+   |\n+LL |     let mut_index_ref = &raw mut ARRAY[1];\n+   |                                  ^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:24:34\n+   |\n+LL |     let ref_ascribe = &raw const (2: i32);\n+   |                                  ^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:25:36\n+   |\n+LL |     let mut_ref_ascribe = &raw mut (3: i32);\n+   |                                    ^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:27:40\n+   |\n+LL |     let ascribe_field_ref = &raw const (PAIR.0: i32);\n+   |                                        ^^^^^^^^^^^^^ temporary value\n+\n+error[E0745]: cannot take address of a temporary\n+  --> $DIR/raw-ref-temp.rs:28:38\n+   |\n+LL |     let ascribe_index_ref = &raw mut (ARRAY[0]: i32);\n+   |                                      ^^^^^^^^^^^^^^^ temporary value\n+\n+error: aborting due to 16 previous errors\n+\n+For more information about this error, try `rustc --explain E0745`."}, {"sha": "f0a6bcce2ac8a109a5c628eec4d698d1acc81462", "filename": "src/test/ui/raw-ref-op/unusual_locations.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.rs?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,25 @@\n+// FIXME(#64490): make this check-pass\n+\n+#![feature(raw_ref_op)]\n+\n+const USES_PTR: () = { let u = (); &raw const u; };         //~ ERROR not yet implemented\n+static ALSO_USES_PTR: () = { let u = (); &raw const u; };   //~ ERROR not yet implemented\n+\n+fn main() {\n+    #[cfg(FALSE)]\n+    {\n+        let x: [i32; { let u = 2; let x = &raw const u; 4 }]\n+            = [2; { let v = 3; let y = &raw const v; 4 }];\n+        let mut one = 1;\n+        let two = 2;\n+        if &raw const one == &raw mut one {\n+            match &raw const two {\n+                _ => {}\n+            }\n+        }\n+        let three = 3;\n+        let mut four = 4;\n+        println!(\"{:p}\", &raw const three);\n+        unsafe { &raw mut four; }\n+    }\n+}"}, {"sha": "3fae5db3d51a16080644f88af22895e9059d27cb", "filename": "src/test/ui/raw-ref-op/unusual_locations.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bacb70f0b19d324a548bd7942692ab18d159a4/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Funusual_locations.stderr?ref=c9bacb70f0b19d324a548bd7942692ab18d159a4", "patch": "@@ -0,0 +1,18 @@\n+error: raw borrows are not yet implemented\n+  --> $DIR/unusual_locations.rs:5:36\n+   |\n+LL | const USES_PTR: () = { let u = (); &raw const u; };\n+   |                                    ^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: raw borrows are not yet implemented\n+  --> $DIR/unusual_locations.rs:6:42\n+   |\n+LL | static ALSO_USES_PTR: () = { let u = (); &raw const u; };\n+   |                                          ^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64490\n+\n+error: aborting due to 2 previous errors\n+"}]}