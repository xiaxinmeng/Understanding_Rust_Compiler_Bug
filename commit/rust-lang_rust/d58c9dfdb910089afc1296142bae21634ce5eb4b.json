{"sha": "d58c9dfdb910089afc1296142bae21634ce5eb4b", "node_id": "C_kwDOAAsO6NoAKGQ1OGM5ZGZkYjkxMDA4OWFmYzEyOTYxNDJiYWUyMTYzNGNlNWViNGI", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2022-01-25T01:32:33Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2022-03-28T01:10:50Z"}, "message": "Only highlight identifier in scraped examples, not arguments", "tree": {"sha": "e6355e14483580c885158e62e8e9c56b4679379d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6355e14483580c885158e62e8e9c56b4679379d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d58c9dfdb910089afc1296142bae21634ce5eb4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d58c9dfdb910089afc1296142bae21634ce5eb4b", "html_url": "https://github.com/rust-lang/rust/commit/d58c9dfdb910089afc1296142bae21634ce5eb4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d58c9dfdb910089afc1296142bae21634ce5eb4b/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e81b0a3173470cbc77273b2f984913dd3c02ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e81b0a3173470cbc77273b2f984913dd3c02ef8", "html_url": "https://github.com/rust-lang/rust/commit/7e81b0a3173470cbc77273b2f984913dd3c02ef8"}], "stats": {"total": 93, "additions": 44, "deletions": 49}, "files": [{"sha": "6b57ff5eeba3287527b4abe39e6f74324bd8e84f", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d58c9dfdb910089afc1296142bae21634ce5eb4b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c9dfdb910089afc1296142bae21634ce5eb4b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d58c9dfdb910089afc1296142bae21634ce5eb4b", "patch": "@@ -2717,45 +2717,20 @@ fn render_call_locations(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item) {\n         // The output code is limited to that byte range.\n         let contents_subset = &contents[(byte_min as usize)..(byte_max as usize)];\n \n-        // Given a call-site range, return the set of sub-ranges that exclude leading whitespace\n-        // when the range spans multiple lines.\n-        let strip_leading_whitespace = |(lo, hi): (u32, u32)| -> Vec<(u32, u32)> {\n-            let contents_range = &contents_subset[(lo as usize)..(hi as usize)];\n-            let mut ignoring_whitespace = false;\n-            let mut ranges = Vec::new();\n-            let mut cur_lo = 0;\n-            for (idx, chr) in contents_range.char_indices() {\n-                let idx = idx as u32;\n-                if ignoring_whitespace {\n-                    if !chr.is_whitespace() {\n-                        ignoring_whitespace = false;\n-                        cur_lo = idx;\n-                    }\n-                } else if chr == '\\n' {\n-                    ranges.push((lo + cur_lo, lo + idx));\n-                    cur_lo = idx;\n-                    ignoring_whitespace = true;\n-                }\n-            }\n-            ranges.push((lo + cur_lo, hi));\n-            ranges\n-        };\n-\n         // The call locations need to be updated to reflect that the size of the program has changed.\n         // Specifically, the ranges are all subtracted by `byte_min` since that's the new zero point.\n         let (mut byte_ranges, line_ranges): (Vec<_>, Vec<_>) = call_data\n             .locations\n             .iter()\n             .map(|loc| {\n-                let (byte_lo, byte_hi) = loc.call_expr.byte_span;\n+                let (byte_lo, byte_hi) = loc.call_ident.byte_span;\n                 let (line_lo, line_hi) = loc.call_expr.line_span;\n                 let byte_range = (byte_lo - byte_min, byte_hi - byte_min);\n-                let byte_ranges = strip_leading_whitespace(byte_range);\n \n                 let line_range = (line_lo - line_min, line_hi - line_min);\n                 let (line_url, line_title) = link_to_loc(call_data, loc);\n \n-                (byte_ranges, (line_range, line_url, line_title))\n+                (byte_range, (line_range, line_url, line_title))\n             })\n             .unzip();\n \n@@ -2810,8 +2785,8 @@ fn render_call_locations(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item) {\n         let root_path = vec![\"../\"; cx.current.len() - 1].join(\"\");\n \n         let mut decoration_info = FxHashMap::default();\n-        decoration_info.insert(\"highlight focus\", byte_ranges.remove(0));\n-        decoration_info.insert(\"highlight\", byte_ranges.into_iter().flatten().collect());\n+        decoration_info.insert(\"highlight focus\", vec![byte_ranges.remove(0)]);\n+        decoration_info.insert(\"highlight\", byte_ranges);\n \n         sources::print_src(\n             w,"}, {"sha": "21af26a1c913ee8cc92a4a75e4408797511b97da", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d58c9dfdb910089afc1296142bae21634ce5eb4b/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c9dfdb910089afc1296142bae21634ce5eb4b/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=d58c9dfdb910089afc1296142bae21634ce5eb4b", "patch": "@@ -85,17 +85,20 @@ impl SyntaxRange {\n #[derive(Encodable, Decodable, Debug, Clone)]\n crate struct CallLocation {\n     crate call_expr: SyntaxRange,\n+    crate call_ident: SyntaxRange,\n     crate enclosing_item: SyntaxRange,\n }\n \n impl CallLocation {\n     fn new(\n         expr_span: rustc_span::Span,\n+        ident_span: rustc_span::Span,\n         enclosing_item_span: rustc_span::Span,\n         source_file: &SourceFile,\n     ) -> Self {\n         CallLocation {\n             call_expr: SyntaxRange::new(expr_span, source_file),\n+            call_ident: SyntaxRange::new(ident_span, source_file),\n             enclosing_item: SyntaxRange::new(enclosing_item_span, source_file),\n         }\n     }\n@@ -146,24 +149,39 @@ where\n         }\n \n         // Get type of function if expression is a function call\n-        let (ty, span) = match ex.kind {\n+        let (ty, call_span, ident_span) = match ex.kind {\n             hir::ExprKind::Call(f, _) => {\n                 let types = tcx.typeck(ex.hir_id.owner);\n \n                 if let Some(ty) = types.node_type_opt(f.hir_id) {\n-                    (ty, ex.span)\n+                    (ty, ex.span, f.span)\n                 } else {\n                     trace!(\"node_type_opt({}) = None\", f.hir_id);\n                     return;\n                 }\n             }\n-            hir::ExprKind::MethodCall(_, _, span) => {\n+            hir::ExprKind::MethodCall(_, args, call_span) => {\n                 let types = tcx.typeck(ex.hir_id.owner);\n                 let Some(def_id) = types.type_dependent_def_id(ex.hir_id) else {\n                     trace!(\"type_dependent_def_id({}) = None\", ex.hir_id);\n                     return;\n                 };\n-                (tcx.type_of(def_id), span)\n+\n+                // The MethodCall node doesn't directly contain a span for the\n+                // method identifier, so we have to compute it by trimming the full\n+                // span based on the arguments.\n+                let ident_span = match args.get(1) {\n+                    // If there is an argument, e.g. \"f(x)\", then\n+                    // get the span \"f(\" and delete the lparen.\n+                    Some(arg) => {\n+                        let with_paren = call_span.until(arg.span);\n+                        with_paren.with_hi(with_paren.hi() - BytePos(1))\n+                    }\n+                    // Otherwise, just delete both parens directly.\n+                    None => call_span.with_hi(call_span.hi() - BytePos(2)),\n+                };\n+\n+                (tcx.type_of(def_id), call_span, ident_span)\n             }\n             _ => {\n                 return;\n@@ -172,8 +190,8 @@ where\n \n         // If this span comes from a macro expansion, then the source code may not actually show\n         // a use of the given item, so it would be a poor example. Hence, we skip all uses in macros.\n-        if span.from_expansion() {\n-            trace!(\"Rejecting expr from macro: {:?}\", span);\n+        if call_span.from_expansion() {\n+            trace!(\"Rejecting expr from macro: {:?}\", call_span);\n             return;\n         }\n \n@@ -183,26 +201,29 @@ where\n             .hir()\n             .span_with_body(tcx.hir().local_def_id_to_hir_id(tcx.hir().get_parent_item(ex.hir_id)));\n         if enclosing_item_span.from_expansion() {\n-            trace!(\"Rejecting expr ({:?}) from macro item: {:?}\", span, enclosing_item_span);\n+            trace!(\"Rejecting expr ({:?}) from macro item: {:?}\", call_span, enclosing_item_span);\n             return;\n         }\n \n         assert!(\n-            enclosing_item_span.contains(span),\n-            \"Attempted to scrape call at [{:?}] whose enclosing item [{:?}] doesn't contain the span of the call.\",\n-            span,\n-            enclosing_item_span\n+            enclosing_item_span.contains(call_span),\n+            \"Attempted to scrape call at [{call_span:?}] whose enclosing item [{enclosing_item_span:?}] doesn't contain the span of the call.\",\n+        );\n+\n+        assert!(\n+            call_span.contains(ident_span),\n+            \"Attempted to scrape call at [{call_span:?}] whose identifier [{ident_span:?}] was not contained in the span of the call.\"\n         );\n \n         // Save call site if the function resolves to a concrete definition\n         if let ty::FnDef(def_id, _) = ty.kind() {\n             if self.target_crates.iter().all(|krate| *krate != def_id.krate) {\n-                trace!(\"Rejecting expr from crate not being documented: {:?}\", span);\n+                trace!(\"Rejecting expr from crate not being documented: {call_span:?}\");\n                 return;\n             }\n \n             let source_map = tcx.sess.source_map();\n-            let file = source_map.lookup_char_pos(span.lo()).file;\n+            let file = source_map.lookup_char_pos(call_span.lo()).file;\n             let file_path = match file.name.clone() {\n                 FileName::Real(real_filename) => real_filename.into_local_path(),\n                 _ => None,\n@@ -212,20 +233,20 @@ where\n                 let abs_path = fs::canonicalize(file_path.clone()).unwrap();\n                 let cx = &self.cx;\n                 let mk_call_data = || {\n-                    let clean_span = crate::clean::types::Span::new(span);\n+                    let clean_span = crate::clean::types::Span::new(call_span);\n                     let url = cx.href_from_span(clean_span, false).unwrap();\n                     let display_name = file_path.display().to_string();\n-                    let edition = span.edition();\n+                    let edition = call_span.edition();\n                     CallData { locations: Vec::new(), url, display_name, edition }\n                 };\n \n                 let fn_key = tcx.def_path_hash(*def_id);\n                 let fn_entries = self.calls.entry(fn_key).or_default();\n \n-                trace!(\"Including expr: {:?}\", span);\n+                trace!(\"Including expr: {:?}\", call_span);\n                 let enclosing_item_span =\n                     source_map.span_extend_to_prev_char(enclosing_item_span, '\\n', false);\n-                let location = CallLocation::new(span, enclosing_item_span, &file);\n+                let location = CallLocation::new(call_span, ident_span, enclosing_item_span, &file);\n                 fn_entries.entry(abs_path).or_insert_with(mk_call_data).locations.push(location);\n             }\n         }"}, {"sha": "7bd57609fa224609973680997fce640491ff4bba", "filename": "src/test/run-make/rustdoc-scrape-examples-ordering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d58c9dfdb910089afc1296142bae21634ce5eb4b/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-ordering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58c9dfdb910089afc1296142bae21634ce5eb4b/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-ordering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-ordering%2Fsrc%2Flib.rs?ref=d58c9dfdb910089afc1296142bae21634ce5eb4b", "patch": "@@ -1,7 +1,6 @@\n // @has foobar/fn.ok.html '//*[@class=\"docblock scraped-example-list\"]' 'ex2'\n // @has foobar/fn.ok.html '//*[@class=\"more-scraped-examples\"]' 'ex1'\n-// @has foobar/fn.ok.html '//*[@class=\"highlight focus\"]' '1'\n-// @has foobar/fn.ok.html '//*[@class=\"highlight\"]' '2'\n-// @has foobar/fn.ok.html '//*[@class=\"highlight focus\"]' '0'\n+// @has foobar/fn.ok.html '//*[@class=\"highlight focus\"]' ''\n+// @has foobar/fn.ok.html '//*[@class=\"highlight\"]' ''\n \n pub fn ok(_x: i32) {}"}]}