{"sha": "e0ce9f8c0a97e5949c9cadd220279d6969289daa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwY2U5ZjhjMGE5N2U1OTQ5YzljYWRkMjIwMjc5ZDY5NjkyODlkYWE=", "commit": {"author": {"name": "Kevin Per", "email": "kevin.per@protonmail.com", "date": "2019-08-27T11:24:32Z"}, "committer": {"name": "Kevin Per", "email": "kevin.per@protonmail.com", "date": "2019-08-27T12:07:41Z"}, "message": "Cleanup: Consistently use `Param` instead of `Arg` #62426", "tree": {"sha": "6e30692f6705c9f8c01e6052df9494183d53a1a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e30692f6705c9f8c01e6052df9494183d53a1a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0ce9f8c0a97e5949c9cadd220279d6969289daa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ce9f8c0a97e5949c9cadd220279d6969289daa", "html_url": "https://github.com/rust-lang/rust/commit/e0ce9f8c0a97e5949c9cadd220279d6969289daa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0ce9f8c0a97e5949c9cadd220279d6969289daa/comments", "author": {"login": "kper", "id": 10795807, "node_id": "MDQ6VXNlcjEwNzk1ODA3", "avatar_url": "https://avatars.githubusercontent.com/u/10795807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kper", "html_url": "https://github.com/kper", "followers_url": "https://api.github.com/users/kper/followers", "following_url": "https://api.github.com/users/kper/following{/other_user}", "gists_url": "https://api.github.com/users/kper/gists{/gist_id}", "starred_url": "https://api.github.com/users/kper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kper/subscriptions", "organizations_url": "https://api.github.com/users/kper/orgs", "repos_url": "https://api.github.com/users/kper/repos", "events_url": "https://api.github.com/users/kper/events{/privacy}", "received_events_url": "https://api.github.com/users/kper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kper", "id": 10795807, "node_id": "MDQ6VXNlcjEwNzk1ODA3", "avatar_url": "https://avatars.githubusercontent.com/u/10795807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kper", "html_url": "https://github.com/kper", "followers_url": "https://api.github.com/users/kper/followers", "following_url": "https://api.github.com/users/kper/following{/other_user}", "gists_url": "https://api.github.com/users/kper/gists{/gist_id}", "starred_url": "https://api.github.com/users/kper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kper/subscriptions", "organizations_url": "https://api.github.com/users/kper/orgs", "repos_url": "https://api.github.com/users/kper/repos", "events_url": "https://api.github.com/users/kper/events{/privacy}", "received_events_url": "https://api.github.com/users/kper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0444b9f66acb5da23dc816e0d8eb59623ba9ea50", "url": "https://api.github.com/repos/rust-lang/rust/commits/0444b9f66acb5da23dc816e0d8eb59623ba9ea50", "html_url": "https://github.com/rust-lang/rust/commit/0444b9f66acb5da23dc816e0d8eb59623ba9ea50"}], "stats": {"total": 755, "additions": 379, "deletions": 376}, "files": [{"sha": "bbde3510e29f91cc3d89adc304a60379c7629640", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -210,8 +210,8 @@ pub trait Visitor<'v> : Sized {\n         }\n     }\n \n-    fn visit_arg(&mut self, arg: &'v Arg) {\n-        walk_arg(self, arg)\n+    fn visit_param(&mut self, param: &'v Param) {\n+        walk_param(self, param)\n     }\n \n     /// Visits the top-level item and (optionally) nested items / impl items. See\n@@ -400,7 +400,7 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_hir_id\n }\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n-    walk_list!(visitor, visit_arg, &body.arguments);\n+    walk_list!(visitor, visit_param, &body.params);\n     visitor.visit_expr(&body.value);\n }\n \n@@ -454,10 +454,10 @@ pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n     visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n }\n \n-pub fn walk_arg<'v, V: Visitor<'v>>(visitor: &mut V, arg: &'v Arg) {\n-    visitor.visit_id(arg.hir_id);\n-    visitor.visit_pat(&arg.pat);\n-    walk_list!(visitor, visit_attribute, &arg.attrs);\n+pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n+    visitor.visit_id(param.hir_id);\n+    visitor.visit_pat(&param.pat);\n+    walk_list!(visitor, visit_attribute, &param.attrs);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {"}, {"sha": "5e2aebfd3187ba9ab7981709fca5a382cc80fdc0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -510,12 +510,12 @@ impl<'a> LoweringContext<'a> {\n                             &f.generic_params\n                         );\n                         // Mirrors visit::walk_fn_decl\n-                        for argument in &f.decl.inputs {\n+                        for parameter in &f.decl.inputs {\n                             // We don't lower the ids of argument patterns\n                             self.with_hir_id_owner(None, |this| {\n-                                this.visit_pat(&argument.pat);\n+                                this.visit_pat(&parameter.pat);\n                             });\n-                            self.visit_ty(&argument.ty)\n+                            self.visit_ty(&parameter.ty)\n                         }\n                         self.visit_fn_ret_ty(&f.decl.output)\n                     }\n@@ -735,7 +735,7 @@ impl<'a> LoweringContext<'a> {\n     ///\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// argument while `f` is running (and restored afterwards).\n+    /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T, F>(\n         &mut self,\n         parent_id: DefId,\n@@ -880,7 +880,7 @@ impl<'a> LoweringContext<'a> {\n     ///\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// argument while `f` is running (and restored afterwards).\n+    /// parameter while `f` is running (and restored afterwards).\n     fn add_in_band_defs<F, T>(\n         &mut self,\n         generics: &Generics,\n@@ -1080,7 +1080,7 @@ impl<'a> LoweringContext<'a> {\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type =>\n                         (true, ImplTraitContext::OpaqueTy(None)),\n \n-                    // We are in the argument position, but not within a dyn type:\n+                    // We are in the parameter position, but not within a dyn type:\n                     //\n                     //     fn foo(x: impl Iterator<Item: Debug>)\n                     //\n@@ -1204,7 +1204,7 @@ impl<'a> LoweringContext<'a> {\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n                                 decl: this.lower_fn_decl(&f.decl, None, false, None),\n-                                arg_names: this.lower_fn_args_to_names(&f.decl),\n+                                param_names: this.lower_fn_params_to_names(&f.decl),\n                             }))\n                         },\n                     )\n@@ -2093,12 +2093,12 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_args_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n+    fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         decl.inputs\n             .iter()\n-            .map(|arg| match arg.pat.node {\n+            .map(|param| match param.pat.node {\n                 PatKind::Ident(_, ident, _) => ident,\n-                _ => Ident::new(kw::Invalid, arg.pat.span),\n+                _ => Ident::new(kw::Invalid, param.pat.span),\n             })\n             .collect()\n     }\n@@ -2136,11 +2136,11 @@ impl<'a> LoweringContext<'a> {\n         let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n             decl.inputs\n                 .iter()\n-                .map(|arg| {\n+                .map(|param| {\n                     if let Some((_, ibty)) = &mut in_band_ty_params {\n-                        this.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n+                        this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n                     } else {\n-                        this.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n+                        this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n                     }\n                 })\n                 .collect::<HirVec<_>>()\n@@ -2205,7 +2205,7 @@ impl<'a> LoweringContext<'a> {\n     //\n     //     type OpaqueTy<generics_from_parent_fn> = impl Future<Output = T>;\n     //\n-    // `inputs`: lowered types of arguments to the function (used to collect lifetimes)\n+    // `inputs`: lowered types of parameters to the function (used to collect lifetimes)\n     // `output`: unlowered output type (`T` in `-> T`)\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n     // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created"}, {"sha": "4e432f4981d23b8bea148b5b03542b27e6a48bd0", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -720,7 +720,7 @@ impl LoweringContext<'_> {\n                             (\n                                 // Disallow impl Trait in foreign items\n                                 this.lower_fn_decl(fdec, None, false, None),\n-                                this.lower_fn_args_to_names(fdec),\n+                                this.lower_fn_params_to_names(fdec),\n                             )\n                         },\n                     );\n@@ -827,7 +827,7 @@ impl LoweringContext<'_> {\n                 ),\n             ),\n             TraitItemKind::Method(ref sig, None) => {\n-                let names = self.lower_fn_args_to_names(&sig.decl);\n+                let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n                     sig,\n@@ -1028,10 +1028,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n+    fn record_body(&mut self, params: HirVec<hir::Param>, value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n             generator_kind: self.generator_kind,\n-            arguments,\n+            params,\n             value,\n         };\n         let id = body.id();\n@@ -1041,21 +1041,21 @@ impl LoweringContext<'_> {\n \n     fn lower_body(\n         &mut self,\n-        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Param>, hir::Expr),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n-        let (arguments, result) = f(self);\n-        let body_id = self.record_body(arguments, result);\n+        let (parameters, result) = f(self);\n+        let body_id = self.record_body(parameters, result);\n         self.generator_kind = prev_gen_kind;\n         body_id\n     }\n \n-    fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n-        hir::Arg {\n-            attrs: self.lower_attrs(&arg.attrs),\n-            hir_id: self.lower_node_id(arg.id),\n-            pat: self.lower_pat(&arg.pat),\n-            span: arg.span,\n+    fn lower_param(&mut self, param: &Param) -> hir::Param {\n+        hir::Param {\n+            attrs: self.lower_attrs(&param.attrs),\n+            hir_id: self.lower_node_id(param.id),\n+            pat: self.lower_pat(&param.pat),\n+            span: param.span,\n         }\n     }\n \n@@ -1065,7 +1065,7 @@ impl LoweringContext<'_> {\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::BodyId {\n         self.lower_body(|this| (\n-            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            decl.inputs.iter().map(|x| this.lower_param(x)).collect(),\n             body(this),\n         ))\n     }\n@@ -1093,10 +1093,10 @@ impl LoweringContext<'_> {\n         };\n \n         self.lower_body(|this| {\n-            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut parameters: Vec<hir::Param> = Vec::new();\n             let mut statements: Vec<hir::Stmt> = Vec::new();\n \n-            // Async function arguments are lowered into the closure body so that they are\n+            // Async function parameters are lowered into the closure body so that they are\n             // captured and so that the drop order matches the equivalent non-async functions.\n             //\n             // from:\n@@ -1121,13 +1121,13 @@ impl LoweringContext<'_> {\n             //\n             // If `<pattern>` is a simple ident, then it is lowered to a single\n             // `let <pattern> = <pattern>;` statement as an optimization.\n-            for (index, argument) in decl.inputs.iter().enumerate() {\n-                let argument = this.lower_arg(argument);\n-                let span = argument.pat.span;\n+            for (index, parameter) in decl.inputs.iter().enumerate() {\n+                let parameter = this.lower_param(parameter);\n+                let span = parameter.pat.span;\n \n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n-                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n-                let (ident, is_simple_argument) = match argument.pat.node {\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n+                let (ident, is_simple_parameter) = match parameter.pat.node {\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n                         (ident, true),\n                     _ => {\n@@ -1142,32 +1142,32 @@ impl LoweringContext<'_> {\n                 let desugared_span =\n                     this.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // Construct a parameter representing `__argN: <ty>` to replace the parameter of the\n                 // async function.\n                 //\n-                // If this is the simple case, this argument will end up being the same as the\n-                // original argument, but with a different pattern id.\n+                // If this is the simple case, this parameter will end up being the same as the\n+                // original parameter, but with a different pattern id.\n                 let mut stmt_attrs = ThinVec::new();\n-                stmt_attrs.extend(argument.attrs.iter().cloned());\n-                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n-                let new_argument = hir::Arg {\n-                    attrs: argument.attrs,\n-                    hir_id: argument.hir_id,\n-                    pat: new_argument_pat,\n-                    span: argument.span,\n+                stmt_attrs.extend(parameter.attrs.iter().cloned());\n+                let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n+                let new_parameter = hir::Param {\n+                    attrs: parameter.attrs,\n+                    hir_id: parameter.hir_id,\n+                    pat: new_parameter_pat,\n+                    span: parameter.span,\n                 };\n \n \n-                if is_simple_argument {\n+                if is_simple_parameter {\n                     // If this is the simple case, then we only insert one statement that is\n                     // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n                     // `HirId`s are densely assigned.\n-                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n                         Some(P(expr)),\n-                        argument.pat,\n+                        parameter.pat,\n                         hir::LocalSource::AsyncFn\n                     );\n                     statements.push(stmt);\n@@ -1179,7 +1179,7 @@ impl LoweringContext<'_> {\n                     // let <pat> = __argN;\n                     // ```\n                     //\n-                    // The first statement moves the argument into the closure and thus ensures\n+                    // The first statement moves the parameter into the closure and thus ensures\n                     // that the drop order is correct.\n                     //\n                     // The second statement creates the bindings that the user wrote.\n@@ -1189,7 +1189,7 @@ impl LoweringContext<'_> {\n                     // statement.\n                     let (move_pat, move_id) = this.pat_ident_binding_mode(\n                         desugared_span, ident, hir::BindingAnnotation::Mutable);\n-                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n                         ThinVec::new(),\n                         desugared_span,\n@@ -1199,21 +1199,21 @@ impl LoweringContext<'_> {\n                     );\n \n                     // Construct the `let <pat> = __argN;` statement. We re-use the original\n-                    // argument's pattern so that `HirId`s are densely assigned.\n+                    // parameter's pattern so that `HirId`s are densely assigned.\n                     let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n                     let pattern_stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n                         Some(P(pattern_expr)),\n-                        argument.pat,\n+                        parameter.pat,\n                         hir::LocalSource::AsyncFn\n                     );\n \n                     statements.push(move_stmt);\n                     statements.push(pattern_stmt);\n                 };\n \n-                arguments.push(new_argument);\n+                parameters.push(new_parameter);\n             }\n \n             let async_expr = this.make_async_expr(\n@@ -1222,7 +1222,7 @@ impl LoweringContext<'_> {\n                     let body = this.lower_block_with_stmts(body, false, statements);\n                     this.expr_block(body, ThinVec::new())\n                 });\n-            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n+            (HirVec::from(parameters), this.expr(body.span, async_expr, ThinVec::new()))\n         })\n     }\n "}, {"sha": "773bb8dde06902aa16b02824b544b5b21d324dde", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -363,11 +363,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.currently_in_body = prev_in_body;\n     }\n \n-    fn visit_arg(&mut self, arg: &'hir Arg) {\n-        let node = Node::Arg(arg);\n-        self.insert(arg.pat.span, arg.hir_id, node);\n-        self.with_parent(arg.hir_id, |this| {\n-            intravisit::walk_arg(this, arg);\n+    fn visit_param(&mut self, param: &'hir Param) {\n+        let node = Node::Param(param);\n+        self.insert(param.pat.span, param.hir_id, node);\n+        self.with_parent(param.hir_id, |this| {\n+            intravisit::walk_param(this, param);\n         });\n     }\n "}, {"sha": "eb8be6e6e3cbc36e3a4743ac84f833d387f7ea8d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -360,7 +360,7 @@ impl<'hir> Map<'hir> {\n             Node::Pat(_) |\n             Node::Binding(_) |\n             Node::Local(_) |\n-            Node::Arg(_) |\n+            Node::Param(_) |\n             Node::Arm(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n@@ -964,7 +964,7 @@ impl<'hir> Map<'hir> {\n     pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n-            Some(Node::Arg(a)) => Some(&a.attrs[..]),\n+            Some(Node::Param(a)) => Some(&a.attrs[..]),\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n@@ -1028,7 +1028,7 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n-            Some(Node::Arg(arg)) => arg.span,\n+            Some(Node::Param(param)) => param.span,\n             Some(Node::Item(item)) => item.span,\n             Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n             Some(Node::TraitItem(trait_method)) => trait_method.span,\n@@ -1223,15 +1223,15 @@ impl<'hir> print::PpAnn for Map<'hir> {\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat)\n         }\n     }\n }\n \n impl<'a> print::State<'a> {\n     pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n-            Node::Arg(a)          => self.print_arg(&a),\n+            Node::Param(a)        => self.print_param(&a),\n             Node::Item(a)         => self.print_item(&a),\n             Node::ForeignItem(a)  => self.print_foreign_item(&a),\n             Node::TraitItem(a)    => self.print_trait_item(a),\n@@ -1373,8 +1373,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         Some(Node::Pat(_)) => {\n             format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n-        Some(Node::Arg(_)) => {\n-            format!(\"arg {}{}\", map.hir_to_pretty_string(id), id_str)\n+        Some(Node::Param(_)) => {\n+            format!(\"param {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Arm(_)) => {\n             format!(\"arm {}{}\", map.hir_to_pretty_string(id), id_str)"}, {"sha": "d2c45a5af859884b9cc691291895ff0ccdb6f52a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1030,7 +1030,7 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Returns `MutMutable` only if both arguments are mutable.\n+    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n             MutMutable => other,\n@@ -1324,15 +1324,15 @@ pub struct BodyId {\n ///\n /// Here, the `Body` associated with `foo()` would contain:\n ///\n-/// - an `arguments` array containing the `(x, y)` pattern\n+/// - an `params` array containing the `(x, y)` pattern\n /// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n /// - `generator_kind` would be `None`\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Body {\n-    pub arguments: HirVec<Arg>,\n+    pub params: HirVec<Param>,\n     pub value: Expr,\n     pub generator_kind: Option<GeneratorKind>,\n }\n@@ -1644,7 +1644,7 @@ pub enum LocalSource {\n     /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n     /// When lowering async functions, we create locals within the `async move` so that\n-    /// all arguments are dropped after the future is polled.\n+    /// all parameters are dropped after the future is polled.\n     ///\n     /// ```ignore (pseudo-Rust)\n     /// async fn foo(<pattern> @ x: Type) {\n@@ -1940,7 +1940,7 @@ pub struct BareFnTy {\n     pub abi: Abi,\n     pub generic_params: HirVec<GenericParam>,\n     pub decl: P<FnDecl>,\n-    pub arg_names: HirVec<Ident>,\n+    pub param_names: HirVec<Ident>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2027,9 +2027,9 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect,\n }\n \n-/// Represents an argument in a function header.\n+/// Represents a parameter in a function header.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Arg {\n+pub struct Param {\n     pub attrs: HirVec<Attribute>,\n     pub hir_id: HirId,\n     pub pat: P<Pat>,\n@@ -2039,9 +2039,9 @@ pub struct Arg {\n /// Represents the header (not the body) of a function declaration.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n-    /// The types of the function's arguments.\n+    /// The types of the function's parameters.\n     ///\n-    /// Additional argument data is stored in the function's [body](Body::arguments).\n+    /// Additional argument data is stored in the function's [body](Body::parameters).\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n     pub c_variadic: bool,\n@@ -2721,7 +2721,7 @@ impl CodegenFnAttrs {\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n-    Arg(&'hir Arg),\n+    Param(&'hir Param),\n     Item(&'hir Item),\n     ForeignItem(&'hir ForeignItem),\n     TraitItem(&'hir TraitItem),"}, {"sha": "21cc72efee4a32b567e94ef9234844d82e2582ba", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -33,7 +33,7 @@ pub enum Nested {\n     TraitItem(hir::TraitItemId),\n     ImplItem(hir::ImplItemId),\n     Body(hir::BodyId),\n-    BodyArgPat(hir::BodyId, usize)\n+    BodyParamPat(hir::BodyId, usize)\n }\n \n pub trait PpAnn {\n@@ -62,7 +62,7 @@ impl PpAnn for hir::Crate {\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat)\n         }\n     }\n }\n@@ -318,7 +318,7 @@ impl<'a> State<'a> {\n             }\n             hir::TyKind::BareFn(ref f) => {\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &f.generic_params,\n-                                 &f.arg_names[..]);\n+                                 &f.param_names[..]);\n             }\n             hir::TyKind::Def(..) => {},\n             hir::TyKind::Path(ref qpath) => {\n@@ -1290,7 +1290,7 @@ impl<'a> State<'a> {\n             hir::ExprKind::Closure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n                 self.print_capture_clause(capture_clause);\n \n-                self.print_closure_args(&decl, body);\n+                self.print_closure_params(&decl, body);\n                 self.s.space();\n \n                 // this is a bare expression\n@@ -1775,7 +1775,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    pub fn print_arg(&mut self, arg: &hir::Arg) {\n+    pub fn print_param(&mut self, arg: &hir::Param) {\n         self.print_outer_attributes(&arg.attrs);\n         self.print_pat(&arg.pat);\n     }\n@@ -1864,7 +1864,7 @@ impl<'a> State<'a> {\n                 s.s.word(\":\");\n                 s.s.space();\n             } else if let Some(body_id) = body_id {\n-                s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n+                s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n                 s.s.word(\":\");\n                 s.s.space();\n             }\n@@ -1881,13 +1881,13 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n+    fn print_closure_params(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n         self.s.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n \n-            s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n+            s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n             i += 1;\n \n             if let hir::TyKind::Infer = ty.node {"}, {"sha": "fb981d961129f4252da997e33ec1975839f97e8d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -331,13 +331,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n-            arguments,\n+            params,\n             value,\n             generator_kind,\n         } = self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n-            arguments.hash_stable(hcx, hasher);\n+            params.hash_stable(hcx, hasher);\n             value.hash_stable(hcx, hasher);\n             generator_kind.hash_stable(hcx, hasher);\n         });"}, {"sha": "7068fe3601a62de8e562237094ce5afde888a230", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -78,12 +78,12 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_body(&mut self, body: &'tcx Body) {\n-        for argument in &body.arguments {\n+        for param in &body.params {\n             if let (None, Some(ty)) = (\n                 self.found_arg_pattern,\n-                self.node_matches_type(argument.hir_id),\n+                self.node_matches_type(param.hir_id),\n             ) {\n-                self.found_arg_pattern = Some(&*argument.pat);\n+                self.found_arg_pattern = Some(&*param.pat);\n                 self.found_ty = Some(ty);\n             }\n         }"}, {"sha": "979815fa7f1843199df09f4e141df8a246abf387", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -2,7 +2,7 @@\n //! where both the regions are anonymous.\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n+use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::util::common::ErrorReported;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -59,13 +59,13 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let ty_sub = self.find_anon_type(sub, &bregion_sub)?;\n \n         debug!(\n-            \"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n+            \"try_report_anon_anon_conflict: found_param1={:?} sup={:?} br1={:?}\",\n             ty_sub,\n             sup,\n             bregion_sup\n         );\n         debug!(\n-            \"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n+            \"try_report_anon_anon_conflict: found_param2={:?} sub={:?} br2={:?}\",\n             ty_sup,\n             sub,\n             bregion_sub\n@@ -74,24 +74,24 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let (ty_sup, ty_fndecl_sup) = ty_sup;\n         let (ty_sub, ty_fndecl_sub) = ty_sub;\n \n-        let AnonymousArgInfo {\n-            arg: anon_arg_sup, ..\n-        } = self.find_arg_with_region(sup, sup)?;\n-        let AnonymousArgInfo {\n-            arg: anon_arg_sub, ..\n-        } = self.find_arg_with_region(sub, sub)?;\n+        let AnonymousParamInfo {\n+            param: anon_param_sup, ..\n+        } = self.find_param_with_region(sup, sup)?;\n+        let AnonymousParamInfo {\n+            param: anon_param_sub, ..\n+        } = self.find_param_with_region(sub, sub)?;\n \n         let sup_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_arg_sup.pat.simple_ident() {\n+        let span_label_var1 = match anon_param_sup.pat.simple_ident() {\n             Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n             None => String::new(),\n         };\n \n-        let span_label_var2 = match anon_arg_sub.pat.simple_ident() {\n+        let span_label_var2 = match anon_param_sub.pat.simple_ident() {\n             Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n             None => String::new(),\n         };"}, {"sha": "604115cfc371157225e7ca912bdb6797a1cd41cd", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -6,7 +6,7 @@ use crate::ty;\n use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n+    /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n     pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n         let (span, sub, sup) = self.get_regions();\n@@ -24,23 +24,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n-        let (named, anon, anon_arg_info, region_info) = if self.is_named_region(sub)\n+        let (named, anon, anon_param_info, region_info) = if self.is_named_region(sub)\n             && self.tcx().is_suitable_region(sup).is_some()\n-            && self.find_arg_with_region(sup, sub).is_some()\n+            && self.find_param_with_region(sup, sub).is_some()\n         {\n             (\n                 sub,\n                 sup,\n-                self.find_arg_with_region(sup, sub).unwrap(),\n+                self.find_param_with_region(sup, sub).unwrap(),\n                 self.tcx().is_suitable_region(sup).unwrap(),\n             )\n         } else if self.is_named_region(sup) && self.tcx().is_suitable_region(sub).is_some()\n-            && self.find_arg_with_region(sub, sup).is_some()\n+            && self.find_param_with_region(sub, sup).is_some()\n         {\n             (\n                 sup,\n                 sub,\n-                self.find_arg_with_region(sub, sup).unwrap(),\n+                self.find_param_with_region(sub, sup).unwrap(),\n                 self.tcx().is_suitable_region(sub).unwrap(),\n             )\n         } else {\n@@ -49,20 +49,20 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n         debug!(\n-            \"try_report_named_anon_conflict: anon_arg_info = {:?}\",\n-            anon_arg_info\n+            \"try_report_named_anon_conflict: anon_param_info = {:?}\",\n+            anon_param_info\n         );\n         debug!(\n             \"try_report_named_anon_conflict: region_info = {:?}\",\n             region_info\n         );\n \n-        let (arg, new_ty, new_ty_span, br, is_first, scope_def_id, is_impl_item) = (\n-            anon_arg_info.arg,\n-            anon_arg_info.arg_ty,\n-            anon_arg_info.arg_ty_span,\n-            anon_arg_info.bound_region,\n-            anon_arg_info.is_first,\n+        let (param, new_ty, new_ty_span, br, is_first, scope_def_id, is_impl_item) = (\n+            anon_param_info.param,\n+            anon_param_info.param_ty,\n+            anon_param_info.param_ty_span,\n+            anon_param_info.bound_region,\n+            anon_param_info.is_first,\n             region_info.def_id,\n             region_info.is_impl_item,\n         );\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = match arg.pat.simple_ident() {\n+        let (error_var, span_label_var) = match param.pat.simple_ident() {\n             Some(simple_ident) => (\n                 format!(\"the type of `{}`\", simple_ident),\n                 format!(\"the type of `{}`\", simple_ident),"}, {"sha": "668c99da0034fa5bc05725fca3406c4a2bc60e0f", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -10,37 +10,37 @@ use syntax_pos::Span;\n // The struct contains the information about the anonymous region\n // we are searching for.\n #[derive(Debug)]\n-pub(super) struct AnonymousArgInfo<'tcx> {\n-    // the argument corresponding to the anonymous region\n-    pub arg: &'tcx hir::Arg,\n-    // the type corresponding to the anonymopus region argument\n-    pub arg_ty: Ty<'tcx>,\n+pub(super) struct AnonymousParamInfo<'tcx> {\n+    // the parameter corresponding to the anonymous region\n+    pub param: &'tcx hir::Param,\n+    // the type corresponding to the anonymopus region parameter\n+    pub param_ty: Ty<'tcx>,\n     // the ty::BoundRegion corresponding to the anonymous region\n     pub bound_region: ty::BoundRegion,\n-    // arg_ty_span contains span of argument type\n-    pub arg_ty_span : Span,\n+    // param_ty_span contains span of parameter type\n+    pub param_ty_span : Span,\n     // corresponds to id the argument is the first parameter\n     // in the declaration\n     pub is_first: bool,\n }\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    // This method walks the Type of the function body arguments using\n+    // This method walks the Type of the function body parameters using\n     // `fold_regions()` function and returns the\n-    // &hir::Arg of the function argument corresponding to the anonymous\n+    // &hir::Param of the function parameter corresponding to the anonymous\n     // region and the Ty corresponding to the named region.\n     // Currently only the case where the function declaration consists of\n     // one named region and one anonymous region is handled.\n     // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n-    // Here, we would return the hir::Arg for y, we return the type &'a\n+    // Here, we would return the hir::Param for y, we return the type &'a\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n-    // the hir::Arg is the first argument in the function declaration.\n-    pub(super) fn find_arg_with_region(\n+    // the hir::Param is the first parameter in the function declaration.\n+    pub(super) fn find_param_with_region(\n         &self,\n         anon_region: Region<'tcx>,\n         replace_region: Region<'tcx>,\n-    ) -> Option<AnonymousArgInfo<'_>> {\n+    ) -> Option<AnonymousParamInfo<'_>> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ebr) => (\n@@ -57,16 +57,16 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 let owner_id = hir.body_owner(body_id);\n                 let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n                 if let Some(tables) = self.tables {\n-                    body.arguments\n+                    body.params\n                         .iter()\n                         .enumerate()\n-                        .filter_map(|(index, arg)| {\n+                        .filter_map(|(index, param)| {\n                             // May return None; sometimes the tables are not yet populated.\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let arg_ty_span = hir.span(ty_hir_id);\n-                            let ty = tables.node_type_opt(arg.hir_id)?;\n+                            let param_ty_span = hir.span(ty_hir_id);\n+                            let ty = tables.node_type_opt(param.hir_id)?;\n                             let mut found_anon_region = false;\n-                            let new_arg_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n+                            let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n                                 if *r == *anon_region {\n                                     found_anon_region = true;\n                                     replace_region\n@@ -76,10 +76,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             });\n                             if found_anon_region {\n                                 let is_first = index == 0;\n-                                Some(AnonymousArgInfo {\n-                                    arg: arg,\n-                                    arg_ty: new_arg_ty,\n-                                    arg_ty_span : arg_ty_span,\n+                                Some(AnonymousParamInfo {\n+                                    param: param,\n+                                    param_ty: new_param_ty,\n+                                    param_ty_span : param_ty_span,\n                                     bound_region: bound_region,\n                                     is_first: is_first,\n                                 })"}, {"sha": "affda256322a492f8ca05373c9a9136cc475a5a6", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -966,10 +966,10 @@ for LateContextAndPass<'a, 'tcx, T> {\n         self.context.tables = old_tables;\n     }\n \n-    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n-        self.with_lint_attrs(arg.hir_id, &arg.attrs, |cx| {\n-            lint_callback!(cx, check_arg, arg);\n-            hir_visit::walk_arg(cx, arg);\n+    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n+            lint_callback!(cx, check_param, param);\n+            hir_visit::walk_param(cx, param);\n         });\n     }\n \n@@ -1163,10 +1163,10 @@ for LateContextAndPass<'a, 'tcx, T> {\n }\n \n impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n-    fn visit_arg(&mut self, arg: &'a ast::Arg) {\n-        self.with_lint_attrs(arg.id, &arg.attrs, |cx| {\n-            run_early_pass!(cx, check_arg, arg);\n-            ast_visit::walk_arg(cx, arg);\n+    fn visit_param(&mut self, param: &'a ast::Param) {\n+        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n+            run_early_pass!(cx, check_param, param);\n+            ast_visit::walk_param(cx, param);\n         });\n     }\n "}, {"sha": "a3518b2b478ad67c42ce426e2a352a32fd800ae2", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -206,7 +206,7 @@ macro_rules! declare_lint_pass {\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n         $macro!($args, [$hir], [\n-            fn check_arg(a: &$hir hir::Arg);\n+            fn check_param(a: &$hir hir::Param);\n             fn check_body(a: &$hir hir::Body);\n             fn check_body_post(a: &$hir hir::Body);\n             fn check_name(a: Span, b: ast::Name);\n@@ -349,7 +349,7 @@ macro_rules! declare_combined_late_lint_pass {\n macro_rules! early_lint_methods {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n-            fn check_arg(a: &ast::Arg);\n+            fn check_param(a: &ast::Param);\n             fn check_ident(a: ast::Ident);\n             fn check_crate(a: &ast::Crate);\n             fn check_crate_post(a: &ast::Crate);\n@@ -792,9 +792,9 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n-        self.with_lint_attrs(arg.hir_id, &arg.attrs, |builder| {\n-            intravisit::walk_arg(builder, arg);\n+    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n+            intravisit::walk_param(builder, param);\n         });\n     }\n "}, {"sha": "222c2a405d65b3944ec64173224a0ec8e971eba8", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -313,23 +313,23 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     pub fn consume_body(&mut self, body: &hir::Body) {\n         debug!(\"consume_body(body={:?})\", body);\n \n-        for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.pat_ty_adjusted(&arg.pat));\n-            debug!(\"consume_body: arg_ty = {:?}\", arg_ty);\n+        for param in &body.params {\n+            let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n+            debug!(\"consume_body: param_ty = {:?}\", param_ty);\n \n             let fn_body_scope_r =\n                 self.tcx().mk_region(ty::ReScope(\n                     region::Scope {\n                         id: body.value.hir_id.local_id,\n                         data: region::ScopeData::Node\n                 }));\n-            let arg_cmt = Rc::new(self.mc.cat_rvalue(\n-                arg.hir_id,\n-                arg.pat.span,\n-                fn_body_scope_r, // Args live only as long as the fn body.\n-                arg_ty));\n+            let param_cmt = Rc::new(self.mc.cat_rvalue(\n+                param.hir_id,\n+                param.pat.span,\n+                fn_body_scope_r, // Parameters live only as long as the fn body.\n+                param_ty));\n \n-            self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n+            self.walk_irrefutable_pat(param_cmt, &param.pat);\n         }\n \n         self.consume_expr(&body.value);"}, {"sha": "00013bfc574f4e108ce489807281d0c089fe4ecf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -242,7 +242,7 @@ struct LocalInfo {\n \n #[derive(Copy, Clone, Debug)]\n enum VarKind {\n-    Arg(HirId, ast::Name),\n+    Param(HirId, ast::Name),\n     Local(LocalInfo),\n     CleanExit\n }\n@@ -298,7 +298,7 @@ impl IrMaps<'tcx> {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n+            Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             },\n             CleanExit => {}\n@@ -320,7 +320,7 @@ impl IrMaps<'tcx> {\n \n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n-            Local(LocalInfo { name, .. }) | Arg(_, name) => {\n+            Local(LocalInfo { name, .. }) | Param(_, name) => {\n                 name.to_string()\n             },\n             CleanExit => \"<clean-exit>\".to_owned()\n@@ -330,7 +330,7 @@ impl IrMaps<'tcx> {\n     fn variable_is_shorthand(&self, var: Variable) -> bool {\n         match self.var_kinds[var.get()] {\n             Local(LocalInfo { is_shorthand, .. }) => is_shorthand,\n-            Arg(..) | CleanExit => false\n+            Param(..) | CleanExit => false\n         }\n     }\n \n@@ -371,21 +371,21 @@ fn visit_fn<'tcx>(\n \n     let body = ir.tcx.hir().body(body_id);\n \n-    for arg in &body.arguments {\n-        let is_shorthand = match arg.pat.node {\n+    for param in &body.params {\n+        let is_shorthand = match param.pat.node {\n             crate::hir::PatKind::Struct(..) => true,\n             _ => false,\n         };\n-        arg.pat.each_binding(|_bm, hir_id, _x, ident| {\n-            debug!(\"adding argument {:?}\", hir_id);\n+        param.pat.each_binding(|_bm, hir_id, _x, ident| {\n+            debug!(\"adding parameters {:?}\", hir_id);\n             let var = if is_shorthand {\n                 Local(LocalInfo {\n                     id: hir_id,\n                     name: ident.name,\n                     is_shorthand: true,\n                 })\n             } else {\n-                Arg(hir_id, ident.name)\n+                Param(hir_id, ident.name)\n             };\n             fn_maps.add_variable(var);\n         })\n@@ -1525,8 +1525,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n-        for arg in &body.arguments {\n-            arg.pat.each_binding(|_bm, hir_id, _, ident| {\n+        for param in &body.params {\n+            param.pat.each_binding(|_bm, hir_id, _, ident| {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self."}, {"sha": "28aa86ef9afb2706a0c449d64232b2fc237bebc0", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1383,8 +1383,8 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n-        for argument in &body.arguments {\n-            self.visit_pat(&argument.pat);\n+        for param in &body.params {\n+            self.visit_pat(&param.pat);\n         }\n \n         // The body of the every fn is a root scope."}, {"sha": "8836a632a7ca89bddb6cb710f696d0aa27debc74", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -2557,7 +2557,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } = info;\n \n             let help_name = if let Some(ident) = parent.and_then(|body| {\n-                self.tcx.hir().body(body).arguments[index].pat.simple_ident()\n+                self.tcx.hir().body(body).params[index].pat.simple_ident()\n             }) {\n                 format!(\"`{}`\", ident)\n             } else {"}, {"sha": "93742c83be440e1caaf6e1385c9591c82f655a51", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1044,7 +1044,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.source_map().def_span(span), self.tcx.hir().body(id).arguments.iter()\n+                (self.tcx.sess.source_map().def_span(span),\n+                 self.tcx.hir().body(id).params.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n                             node: hir::PatKind::Tuple(ref args, _),"}, {"sha": "3a4c8c924764eadcf2ad964e6ce0175446766555", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -186,8 +186,8 @@ fn build_local_id_to_index(body: Option<&hir::Body>,\n             index: &'a mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n-        for arg in &body.arguments {\n-            formals.visit_pat(&arg.pat);\n+        for param in &body.params {\n+            formals.visit_pat(&param.pat);\n         }\n         impl<'a, 'v> Visitor<'v> for Formals<'a> {\n             fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {"}, {"sha": "3fbd11bd22a7c786f7c677eabe79d986d0436fdc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -166,7 +166,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n     // This is only used by rustdoc anyway, which shouldn't have\n     // incremental recompilation ever enabled.\n-    fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n+    fn_arg_names => { cdata.get_fn_param_names(def_id.index) }\n     rendered_const => { cdata.get_rendered_const(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }"}, {"sha": "ede31fe69b6ffa14daeea7894b87d7568f57d241", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1150,14 +1150,14 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        let arg_names = match self.entry(id).kind {\n+    pub fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+        let param_names = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n-            EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n-            EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n+            EntryKind::ForeignFn(data) => data.decode(self).param_names,\n+            EntryKind::Method(data) => data.decode(self).fn_data.param_names,\n             _ => Lazy::empty(),\n         };\n-        arg_names.decode(self).collect()\n+        param_names.decode(self).collect()\n     }\n \n     pub fn exported_symbols("}, {"sha": "0eafcebefd745d06506a222f1f5aa2833800cd39", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -869,18 +869,18 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n-                    let arg_names = match *m {\n+                    let param_names = match *m {\n                         hir::TraitMethod::Required(ref names) => {\n-                            self.encode_fn_arg_names(names)\n+                            self.encode_fn_param_names(names)\n                         }\n                         hir::TraitMethod::Provided(body) => {\n-                            self.encode_fn_arg_names_for_body(body)\n+                            self.encode_fn_param_names_for_body(body)\n                         }\n                     };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names,\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n+                        param_names,\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -976,8 +976,8 @@ impl EncodeContext<'tcx> {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n                         constness: sig.header.constness,\n-                        arg_names: self.encode_fn_arg_names_for_body(body),\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n+                        param_names: self.encode_fn_param_names_for_body(body),\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -1033,11 +1033,11 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n+    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId)\n                                     -> Lazy<[ast::Name]> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n-            self.lazy(body.arguments.iter().map(|arg| {\n+            self.lazy(body.params.iter().map(|arg| {\n                 match arg.pat.node {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => kw::Invalid,\n@@ -1046,7 +1046,7 @@ impl EncodeContext<'tcx> {\n         })\n     }\n \n-    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n+    fn encode_fn_param_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n         self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n@@ -1122,7 +1122,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Fn(_, header, .., body) => {\n                 let data = FnData {\n                     constness: header.constness,\n-                    arg_names: self.encode_fn_arg_names_for_body(body),\n+                    param_names: self.encode_fn_param_names_for_body(body),\n                     sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n@@ -1663,7 +1663,7 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(names),\n+                    param_names: self.encode_fn_param_names(names),\n                     sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))"}, {"sha": "1a5887bbf4ed8df946e7eaeb4b940e9d0f44e33a", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -295,7 +295,7 @@ pub struct MacroDef {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n-    pub arg_names: Lazy<[ast::Name]>,\n+    pub param_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n "}, {"sha": "7ab0bf7d66a64a7850f3a46e8db1b3f112b876ea", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -94,7 +94,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n             let body = tcx.hir().body(body_id);\n             let explicit_arguments =\n-                body.arguments\n+                body.params\n                     .iter()\n                     .enumerate()\n                     .map(|(index, arg)| {\n@@ -511,7 +511,7 @@ fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: DefId, abi: Abi) -> bool {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Arg>, Option<ImplicitSelfKind>);\n+struct ArgInfo<'tcx>(Ty<'tcx>, Option<Span>, Option<&'tcx hir::Param>, Option<ImplicitSelfKind>);\n \n fn construct_fn<'a, 'tcx, A>(\n     hir: Cx<'a, 'tcx>,"}, {"sha": "5352888006c30318676f95501be485d7926b57f4", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -91,9 +91,9 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         intravisit::walk_body(self, body);\n \n-        for arg in &body.arguments {\n-            self.check_irrefutable(&arg.pat, \"function argument\");\n-            self.check_patterns(false, slice::from_ref(&arg.pat));\n+        for param in &body.params {\n+            self.check_irrefutable(&param.pat, \"function argument\");\n+            self.check_patterns(false, slice::from_ref(&param.pat));\n         }\n     }\n }"}, {"sha": "a5924efefc2af57db13ff21a4f8bf48d4a4929bf", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -94,9 +94,9 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n-    fn visit_arg(&mut self, arg: &'v hir::Arg) {\n-        self.record(\"Arg\", Id::Node(arg.hir_id), arg);\n-        hir_visit::walk_arg(self, arg)\n+    fn visit_param(&mut self, param: &'v hir::Param) {\n+        self.record(\"Param\", Id::Node(param.hir_id), param);\n+        hir_visit::walk_param(self, param)\n     }\n \n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'v> {"}, {"sha": "d1fd51a97f6834d26ff66b11cd9934bea0cf871e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -230,7 +230,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_formals(&mut self, formals: &'l [ast::Arg], qualname: &str) {\n+    fn process_formals(&mut self, formals: &'l [ast::Param], qualname: &str) {\n         for arg in formals {\n             self.visit_pat(&arg.pat);\n             let mut collector = PathCollector::new();"}, {"sha": "92ccd4f49f6b9b6ca574477e194933c679482d19", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -32,7 +32,7 @@ use syntax::source_map::Spanned;\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{arg_to_string, ty_to_string};\n+use syntax::print::pprust::{param_to_string, ty_to_string};\n use syntax_pos::*;\n \n use dump_visitor::DumpVisitor;\n@@ -934,7 +934,7 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     sig.push('(');\n     sig.push_str(&decl.inputs\n         .iter()\n-        .map(arg_to_string)\n+        .map(param_to_string)\n         .collect::<Vec<_>>()\n         .join(\", \"));\n     sig.push(')');"}, {"sha": "63137bad52ff84e6049991cc4843c6d6fc6f6461", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -224,13 +224,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// fn takes_ref(_: &Foo) {}\n     /// let ref opt = Some(Foo);\n     ///\n-    /// opt.map(|arg| takes_ref(arg));\n+    /// opt.map(|param| takes_ref(param));\n     /// ```\n-    /// Suggest using `opt.as_ref().map(|arg| takes_ref(arg));` instead.\n+    /// Suggest using `opt.as_ref().map(|param| takes_ref(param));` instead.\n     ///\n     /// It only checks for `Option` and `Result` and won't work with\n     /// ```\n-    /// opt.map(|arg| { takes_ref(arg) });\n+    /// opt.map(|param| { takes_ref(param) });\n     /// ```\n     fn can_use_as_ref(\n         &self,\n@@ -247,13 +247,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let local_parent = self.tcx.hir().get_parent_node(local_id);\n-        let arg_hir_id = match self.tcx.hir().find(local_parent) {\n-            Some(Node::Arg(hir::Arg { hir_id, .. })) => hir_id,\n+        let param_hir_id = match self.tcx.hir().find(local_parent) {\n+            Some(Node::Param(hir::Param { hir_id, .. })) => hir_id,\n             _ => return None\n         };\n \n-        let arg_parent = self.tcx.hir().get_parent_node(*arg_hir_id);\n-        let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(arg_parent) {\n+        let param_parent = self.tcx.hir().get_parent_node(*param_hir_id);\n+        let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(param_parent) {\n             Some(Node::Expr(\n                 hir::Expr { hir_id, node: hir::ExprKind::Closure(_, decl, ..), .. }\n             )) => (hir_id, decl),"}, {"sha": "2a3c422fe04380076717ffab5648222d5aa4176f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1102,19 +1102,19 @@ fn check_fn<'a, 'tcx>(\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id, }.visit_body(body);\n \n     // Add formal parameters.\n-    for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n+    for (param_ty, param) in fn_sig.inputs().iter().zip(&body.params) {\n         // Check the pattern.\n-        fcx.check_pat_top(&arg.pat, arg_ty, None);\n+        fcx.check_pat_top(&param.pat, param_ty, None);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if arg.pat.simple_ident().is_none() && !fcx.tcx.features().unsized_locals {\n-            fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::SizedArgumentType);\n+        if param.pat.simple_ident().is_none() && !fcx.tcx.features().unsized_locals {\n+            fcx.require_type_is_sized(param_ty, decl.output.span(), traits::SizedArgumentType);\n         }\n \n-        fcx.write_ty(arg.hir_id, arg_ty);\n+        fcx.write_ty(param.hir_id, param_ty);\n     }\n \n     inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n@@ -3952,8 +3952,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ..\n                 })) => {\n                     let body = hir.body(*body_id);\n-                    sugg_call = body.arguments.iter()\n-                        .map(|arg| match &arg.pat.node {\n+                    sugg_call = body.params.iter()\n+                        .map(|param| match &param.pat.node {\n                             hir::PatKind::Binding(_, _, ident, None)\n                             if ident.name != kw::SelfLower => ident.to_string(),\n                             _ => \"_\".to_string(),\n@@ -3970,8 +3970,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_label(*closure_span, \"closure defined here\");\n                     msg = \"call this closure\";\n                     let body = hir.body(*body_id);\n-                    sugg_call = body.arguments.iter()\n-                        .map(|arg| match &arg.pat.node {\n+                    sugg_call = body.params.iter()\n+                        .map(|param| match &param.pat.node {\n                             hir::PatKind::Binding(_, _, ident, None)\n                             if ident.name != kw::SelfLower => ident.to_string(),\n                             _ => \"_\".to_string(),"}, {"sha": "4cf0df308fb4c7efec9b19cabef93826b77a2bae", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -468,7 +468,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let binding_parent = tcx.hir().get(binding_parent_id);\n             debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n             match binding_parent {\n-                hir::Node::Arg(hir::Arg { span, .. }) => {\n+                hir::Node::Param(hir::Param { span, .. }) => {\n                     if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n                         err.span_suggestion(\n                             *span,"}, {"sha": "fc01a820e23591dcb6a5df0e0b0293f5e65ae6a5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -347,12 +347,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n         self.outlives_environment\n             .save_implied_bounds(body_id.hir_id);\n-        self.link_fn_args(\n+        self.link_fn_params(\n             region::Scope {\n                 id: body.value.hir_id.local_id,\n                 data: region::ScopeData::Node,\n             },\n-            &body.arguments,\n+            &body.params,\n         );\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n@@ -1078,16 +1078,16 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_args(&self, body_scope: region::Scope, args: &[hir::Arg]) {\n-        debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-        for arg in args {\n-            let arg_ty = self.node_ty(arg.hir_id);\n+    fn link_fn_params(&self, body_scope: region::Scope, params: &[hir::Param]) {\n+        debug!(\"regionck::link_fn_params(body_scope={:?})\", body_scope);\n+        for param in params {\n+            let param_ty = self.node_ty(param.hir_id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n-            let arg_cmt = self.with_mc(|mc| {\n-                Rc::new(mc.cat_rvalue(arg.hir_id, arg.pat.span, re_scope, arg_ty))\n+            let param_cmt = self.with_mc(|mc| {\n+                Rc::new(mc.cat_rvalue(param.hir_id, param.pat.span, re_scope, param_ty))\n             });\n-            debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\", arg_ty, arg_cmt, arg);\n-            self.link_pattern(arg_cmt, &arg.pat);\n+            debug!(\"param_ty={:?} param_cmt={:?} param={:?}\", param_ty, param_cmt, param);\n+            self.link_pattern(param_cmt, &param.pat);\n         }\n     }\n "}, {"sha": "487dc8ec2ae0ca75adc7230e72c3dcb308cee827", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -39,8 +39,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n-        for arg in &body.arguments {\n-            wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n+        for param in &body.params {\n+            wbcx.visit_node_id(param.pat.span, param.hir_id);\n         }\n         // Type only exists for constants and statics, not functions.\n         match self.tcx.hir().body_owner_kind(item_id) {\n@@ -245,8 +245,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         match e.node {\n             hir::ExprKind::Closure(_, _, body, _, _) => {\n                 let body = self.fcx.tcx.hir().body(body);\n-                for arg in &body.arguments {\n-                    self.visit_node_id(e.span, arg.hir_id);\n+                for param in &body.params {\n+                    self.visit_node_id(e.span, param.hir_id);\n                 }\n \n                 self.visit_body(body);"}, {"sha": "629892e60727bfb959fc385c5dad1490ae02bb25", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -2120,7 +2120,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n                 Argument {\n-                    name: name_from_pat(&body.arguments[i].pat),\n+                    name: name_from_pat(&body.params[i].pat),\n                     type_: ty.clean(cx),\n                 }\n             }).collect()\n@@ -3804,7 +3804,7 @@ pub struct BareFunctionDecl {\n impl Clean<BareFunctionDecl> for hir::BareFnTy {\n     fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n-            (self.generic_params.clean(cx), (&*self.decl, &self.arg_names[..]).clean(cx))\n+            (self.generic_params.clean(cx), (&*self.decl, &self.param_names[..]).clean(cx))\n         });\n         BareFunctionDecl {\n             unsafety: self.unsafety,"}, {"sha": "6be00bcef45c0eb4018dffd4871faa90b6554ed7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1789,11 +1789,11 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect,\n }\n \n-/// An argument in a function header.\n+/// A parameter in a function header.\n ///\n /// E.g., `bar: usize` as in `fn foo(bar: usize)`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Arg {\n+pub struct Param {\n     pub attrs: ThinVec<Attribute>,\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n@@ -1816,7 +1816,7 @@ pub enum SelfKind {\n \n pub type ExplicitSelf = Spanned<SelfKind>;\n \n-impl Arg {\n+impl Param {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n             if ident.name == kw::SelfLower {\n@@ -1843,14 +1843,14 @@ impl Arg {\n         }\n     }\n \n-    pub fn from_self(attrs: ThinVec<Attribute>, eself: ExplicitSelf, eself_ident: Ident) -> Arg {\n+    pub fn from_self(attrs: ThinVec<Attribute>, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n             node: TyKind::ImplicitSelf,\n             span,\n         });\n-        let arg = |mutbl, ty| Arg {\n+        let param = |mutbl, ty| Param {\n             attrs,\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n@@ -1862,9 +1862,9 @@ impl Arg {\n             id: DUMMY_NODE_ID,\n         };\n         match eself.node {\n-            SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n-            SelfKind::Value(mutbl) => arg(mutbl, infer_ty),\n-            SelfKind::Region(lt, mutbl) => arg(\n+            SelfKind::Explicit(ty, mutbl) => param(mutbl, ty),\n+            SelfKind::Value(mutbl) => param(mutbl, infer_ty),\n+            SelfKind::Region(lt, mutbl) => param(\n                 Mutability::Immutable,\n                 P(Ty {\n                     id: DUMMY_NODE_ID,\n@@ -1887,17 +1887,17 @@ impl Arg {\n /// E.g., `fn foo(bar: baz)`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Arg>,\n+    pub inputs: Vec<Param>,\n     pub output: FunctionRetTy,\n     pub c_variadic: bool,\n }\n \n impl FnDecl {\n     pub fn get_self(&self) -> Option<ExplicitSelf> {\n-        self.inputs.get(0).and_then(Arg::to_self)\n+        self.inputs.get(0).and_then(Param::to_self)\n     }\n     pub fn has_self(&self) -> bool {\n-        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n+        self.inputs.get(0).map(Param::is_self).unwrap_or(false)\n     }\n }\n "}, {"sha": "0e5cfa73a9e3afc29c5dbbc0b540a5e763107606", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -714,7 +714,7 @@ macro_rules! derive_has_attrs {\n \n derive_has_attrs! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm,\n-    ast::Field, ast::FieldPat, ast::Variant, ast::Arg\n+    ast::Field, ast::FieldPat, ast::Variant, ast::Param\n }\n \n pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {"}, {"sha": "e894fd17ff5870341a0e4e7c3db35c5a50dc45be", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -655,7 +655,7 @@ impl<'a> ExtCtxt<'a> {\n               body: P<ast::Expr>)\n               -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n-            ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n+            ids.iter().map(|id| self.param(span, *id, self.ty_infer(span))).collect(),\n             ast::FunctionRetTy::Default(span));\n \n         // FIXME -- We are using `span` as the span of the `|...|`\n@@ -693,9 +693,9 @@ impl<'a> ExtCtxt<'a> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n     }\n \n-    pub fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {\n+    pub fn param(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Param {\n         let arg_pat = self.pat_ident(span, ident);\n-        ast::Arg {\n+        ast::Param {\n             attrs: ThinVec::default(),\n             id: ast::DUMMY_NODE_ID,\n             pat: arg_pat,\n@@ -705,7 +705,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     // FIXME: unused `self`\n-    pub fn fn_decl(&self, inputs: Vec<ast::Arg>, output: ast::FunctionRetTy) -> P<ast::FnDecl> {\n+    pub fn fn_decl(&self, inputs: Vec<ast::Param>, output: ast::FunctionRetTy) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs,\n             output,\n@@ -731,7 +731,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    inputs: Vec<ast::Arg> ,\n+                    inputs: Vec<ast::Param> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n                     body: P<ast::Block>) -> P<ast::Item> {\n@@ -752,7 +752,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn item_fn(&self,\n                span: Span,\n                name: Ident,\n-               inputs: Vec<ast::Arg> ,\n+               inputs: Vec<ast::Param> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n               ) -> P<ast::Item> {"}, {"sha": "e14ca4b06a09e036e1dda4906c0a553bc1c1be98", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -225,8 +225,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_attribute(at, self);\n     }\n \n-    fn flat_map_arg(&mut self, arg: Arg) -> SmallVec<[Arg; 1]> {\n-        noop_flat_map_arg(arg, self)\n+    fn flat_map_param(&mut self, param: Param) -> SmallVec<[Param; 1]> {\n+        noop_flat_map_param(param, self)\n     }\n \n     fn visit_generics(&mut self, generics: &mut Generics) {\n@@ -587,14 +587,14 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_flat_map_arg<T: MutVisitor>(mut arg: Arg, vis: &mut T) -> SmallVec<[Arg; 1]> {\n-    let Arg { attrs, id, pat, span, ty } = &mut arg;\n+pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> SmallVec<[Param; 1]> {\n+    let Param { attrs, id, pat, span, ty } = &mut param;\n     vis.visit_id(id);\n     visit_thin_attrs(attrs, vis);\n     vis.visit_pat(pat);\n     vis.visit_span(span);\n     vis.visit_ty(ty);\n-    smallvec![arg]\n+    smallvec![param]\n }\n \n pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n@@ -720,7 +720,7 @@ pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T)\n \n pub fn noop_visit_fn_decl<T: MutVisitor>(decl: &mut P<FnDecl>, vis: &mut T) {\n     let FnDecl { inputs, output, c_variadic: _ } = decl.deref_mut();\n-    inputs.flat_map_in_place(|arg| vis.flat_map_arg(arg));\n+    inputs.flat_map_in_place(|param| vis.flat_map_param(param));\n     match output {\n         FunctionRetTy::Default(span) => vis.visit_span(span),\n         FunctionRetTy::Ty(ty) => vis.visit_ty(ty),"}, {"sha": "671178223f50377363980a63901b7286984e680b", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -19,7 +19,7 @@ const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &str = \"an inner attribute is not \\\n                                                      permitted in this context\";\n \n impl<'a> Parser<'a> {\n-    crate fn parse_arg_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n+    crate fn parse_param_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let attrs = self.parse_outer_attributes()?;\n         self.sess.gated_spans.param_attrs.borrow_mut()\n             .extend(attrs.iter().map(|a| a.span));"}, {"sha": "d4e661d1a38b78b2f08df50bc92ac343f7113f48", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1,5 +1,5 @@\n use crate::ast::{\n-    self, Arg, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Ident, Item, ItemKind,\n+    self, Param, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Ident, Item, ItemKind,\n     Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind, VariantData,\n };\n use crate::feature_gate::{feature_err, UnstableFeatures};\n@@ -18,7 +18,7 @@ use log::{debug, trace};\n use std::mem;\n \n /// Creates a placeholder argument.\n-crate fn dummy_arg(ident: Ident) -> Arg {\n+crate fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n         node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n@@ -29,7 +29,7 @@ crate fn dummy_arg(ident: Ident) -> Arg {\n         span: ident.span,\n         id: ast::DUMMY_NODE_ID\n     };\n-    Arg { attrs: ThinVec::default(), id: ast::DUMMY_NODE_ID, pat, span: ident.span, ty: P(ty) }\n+    Param { attrs: ThinVec::default(), id: ast::DUMMY_NODE_ID, pat, span: ident.span, ty: P(ty) }\n }\n \n pub enum Error {\n@@ -1183,7 +1183,7 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n-    crate fn eat_incorrect_doc_comment_for_arg_type(&mut self) {\n+    crate fn eat_incorrect_doc_comment_for_param_type(&mut self) {\n         if let token::DocComment(_) = self.token.kind {\n             self.struct_span_err(\n                 self.token.span,\n@@ -1211,7 +1211,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn argument_without_type(\n+    crate fn parameter_without_type(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_>,\n         pat: P<ast::Pat>,\n@@ -1286,13 +1286,13 @@ impl<'a> Parser<'a> {\n         Ok((pat, ty))\n     }\n \n-    crate fn recover_bad_self_arg(\n+    crate fn recover_bad_self_param(\n         &mut self,\n-        mut arg: ast::Arg,\n+        mut param: ast::Param,\n         is_trait_item: bool,\n-    ) -> PResult<'a, ast::Arg> {\n-        let sp = arg.pat.span;\n-        arg.ty.node = TyKind::Err;\n+    ) -> PResult<'a, ast::Param> {\n+        let sp = param.pat.span;\n+        param.ty.node = TyKind::Err;\n         let mut err = self.struct_span_err(sp, \"unexpected `self` parameter in function\");\n         if is_trait_item {\n             err.span_label(sp, \"must be the first associated function parameter\");\n@@ -1301,7 +1301,7 @@ impl<'a> Parser<'a> {\n             err.note(\"`self` is only valid as the first parameter of an associated function\");\n         }\n         err.emit();\n-        Ok(arg)\n+        Ok(param)\n     }\n \n     crate fn consume_block(&mut self, delim: token::DelimToken) {\n@@ -1344,15 +1344,15 @@ impl<'a> Parser<'a> {\n         err\n     }\n \n-    /// Replace duplicated recovered arguments with `_` pattern to avoid unecessary errors.\n+    /// Replace duplicated recovered parameters with `_` pattern to avoid unecessary errors.\n     ///\n     /// This is necessary because at this point we don't know whether we parsed a function with\n-    /// anonymous arguments or a function with names but no types. In order to minimize\n-    /// unecessary errors, we assume the arguments are in the shape of `fn foo(a, b, c)` where\n-    /// the arguments are *names* (so we don't emit errors about not being able to find `b` in\n+    /// anonymous parameters or a function with names but no types. In order to minimize\n+    /// unecessary errors, we assume the parameters are in the shape of `fn foo(a, b, c)` where\n+    /// the parameters are *names* (so we don't emit errors about not being able to find `b` in\n     /// the local scope), but if we find the same name multiple times, like in `fn foo(i8, i8)`,\n-    /// we deduplicate them to not complain about duplicated argument names.\n-    crate fn deduplicate_recovered_arg_names(&self, fn_inputs: &mut Vec<Arg>) {\n+    /// we deduplicate them to not complain about duplicated parameter names.\n+    crate fn deduplicate_recovered_params_names(&self, fn_inputs: &mut Vec<Param>) {\n         let mut seen_inputs = FxHashSet::default();\n         for input in fn_inputs.iter_mut() {\n             let opt_ident = if let (PatKind::Ident(_, ident, _), TyKind::Err) = ("}, {"sha": "bee47df942ae927593c9edd64206a5e33752f91d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -10,7 +10,7 @@ pub use path::PathStyle;\n mod stmt;\n mod generics;\n \n-use crate::ast::{self, AttrStyle, Attribute, Arg, BindingMode, StrStyle, SelfKind};\n+use crate::ast::{self, AttrStyle, Attribute, Param, BindingMode, StrStyle, SelfKind};\n use crate::ast::{FnDecl, Ident, IsAsync, MacDelimiter, Mutability, TyKind};\n use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n use crate::source_map::{self, respan};\n@@ -970,27 +970,27 @@ impl<'a> Parser<'a> {\n \n     /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n     /// error.\n-    /// This version of parse arg doesn't necessarily require identifier names.\n-    fn parse_arg_general(\n+    /// This version of parse param doesn't necessarily require identifier names.\n+    fn parse_param_general(\n         &mut self,\n         is_trait_item: bool,\n         allow_c_variadic: bool,\n         is_name_required: impl Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, Arg> {\n+    ) -> PResult<'a, Param> {\n         let lo = self.token.span;\n-        let attrs = self.parse_arg_attributes()?;\n-        if let Some(mut arg) = self.parse_self_arg()? {\n-            arg.attrs = attrs.into();\n-            return self.recover_bad_self_arg(arg, is_trait_item);\n+        let attrs = self.parse_param_attributes()?;\n+        if let Some(mut param) = self.parse_self_param()? {\n+            param.attrs = attrs.into();\n+            return self.recover_bad_self_param(param, is_trait_item);\n         }\n \n         let is_name_required = is_name_required(&self.token);\n         let (pat, ty) = if is_name_required || self.is_named_argument() {\n-            debug!(\"parse_arg_general parse_pat (is_name_required:{})\", is_name_required);\n+            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n \n             let pat = self.parse_fn_param_pat()?;\n             if let Err(mut err) = self.expect(&token::Colon) {\n-                if let Some(ident) = self.argument_without_type(\n+                if let Some(ident) = self.parameter_without_type(\n                     &mut err,\n                     pat,\n                     is_name_required,\n@@ -1003,12 +1003,12 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            self.eat_incorrect_doc_comment_for_arg_type();\n+            self.eat_incorrect_doc_comment_for_param_type();\n             (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n         } else {\n-            debug!(\"parse_arg_general ident_to_pat\");\n+            debug!(\"parse_param_general ident_to_pat\");\n             let parser_snapshot_before_ty = self.clone();\n-            self.eat_incorrect_doc_comment_for_arg_type();\n+            self.eat_incorrect_doc_comment_for_param_type();\n             let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n             if ty.is_ok() && self.token != token::Comma &&\n                self.token != token::CloseDelim(token::Paren) {\n@@ -1039,7 +1039,7 @@ impl<'a> Parser<'a> {\n \n         let span = lo.to(self.token.span);\n \n-        Ok(Arg { attrs: attrs.into(), id: ast::DUMMY_NODE_ID, pat, span, ty })\n+        Ok(Param { attrs: attrs.into(), id: ast::DUMMY_NODE_ID, pat, span, ty })\n     }\n \n     /// Parses mutability (`mut` or nothing).\n@@ -1185,37 +1185,37 @@ impl<'a> Parser<'a> {\n \n     }\n \n-    fn parse_fn_args(&mut self, named_args: bool, allow_c_variadic: bool)\n-                     -> PResult<'a, (Vec<Arg> , bool)> {\n+    fn parse_fn_params(&mut self, named_params: bool, allow_c_variadic: bool)\n+                     -> PResult<'a, (Vec<Param> , bool)> {\n         let sp = self.token.span;\n         let mut c_variadic = false;\n-        let (args, _): (Vec<Option<Arg>>, _) = self.parse_paren_comma_seq(|p| {\n+        let (params, _): (Vec<Option<Param>>, _) = self.parse_paren_comma_seq(|p| {\n             let do_not_enforce_named_arguments_for_c_variadic =\n                 |token: &token::Token| -> bool {\n                     if token == &token::DotDotDot {\n                         false\n                     } else {\n-                        named_args\n+                        named_params\n                     }\n                 };\n-            match p.parse_arg_general(\n+            match p.parse_param_general(\n                 false,\n                 allow_c_variadic,\n                 do_not_enforce_named_arguments_for_c_variadic\n             ) {\n-                Ok(arg) => {\n-                    if let TyKind::CVarArgs = arg.ty.node {\n+                Ok(param) => {\n+                    if let TyKind::CVarArgs = param.ty.node {\n                         c_variadic = true;\n                         if p.token != token::CloseDelim(token::Paren) {\n                             let span = p.token.span;\n                             p.span_err(span,\n                                 \"`...` must be the last argument of a C-variadic function\");\n                             Ok(None)\n                         } else {\n-                            Ok(Some(arg))\n+                            Ok(Some(param))\n                         }\n                     } else {\n-                        Ok(Some(arg))\n+                        Ok(Some(param))\n                     }\n                 },\n                 Err(mut e) => {\n@@ -1230,20 +1230,20 @@ impl<'a> Parser<'a> {\n             }\n         })?;\n \n-        let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n+        let params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n \n-        if c_variadic && args.len() <= 1 {\n+        if c_variadic && params.len() <= 1 {\n             self.span_err(sp,\n                           \"C-variadic function must be declared with at least one named argument\");\n         }\n \n-        Ok((args, c_variadic))\n+        Ok((params, c_variadic))\n     }\n \n-    /// Returns the parsed optional self argument and whether a self shortcut was used.\n+    /// Returns the parsed optional self parameter and whether a self shortcut was used.\n     ///\n-    /// See `parse_self_arg_with_attrs` to collect attributes.\n-    fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n+    /// See `parse_self_param_with_attrs` to collect attributes.\n+    fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n         let expect_ident = |this: &mut Self| match this.token.kind {\n             // Preserve hygienic context.\n             token::Ident(name, _) =>\n@@ -1348,58 +1348,60 @@ impl<'a> Parser<'a> {\n         };\n \n         let eself = source_map::respan(eself_lo.to(eself_hi), eself);\n-        Ok(Some(Arg::from_self(ThinVec::default(), eself, eself_ident)))\n+        Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n     }\n \n-    /// Returns the parsed optional self argument with attributes and whether a self\n+    /// Returns the parsed optional self parameter with attributes and whether a self\n     /// shortcut was used.\n-    fn parse_self_arg_with_attrs(&mut self) -> PResult<'a, Option<Arg>> {\n-        let attrs = self.parse_arg_attributes()?;\n-        let arg_opt = self.parse_self_arg()?;\n-        Ok(arg_opt.map(|mut arg| {\n-            arg.attrs = attrs.into();\n-            arg\n+    fn parse_self_parameter_with_attrs(&mut self) -> PResult<'a, Option<Param>> {\n+        let attrs = self.parse_param_attributes()?;\n+        let param_opt = self.parse_self_param()?;\n+        Ok(param_opt.map(|mut param| {\n+            param.attrs = attrs.into();\n+            param\n         }))\n     }\n \n     /// Parses the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self<F>(&mut self, parse_arg_fn: F) -> PResult<'a, P<FnDecl>>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n+    fn parse_fn_decl_with_self<F>(&mut self, parse_param_fn: F) -> PResult<'a, P<FnDecl>>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Param>,\n     {\n         self.expect(&token::OpenDelim(token::Paren))?;\n \n         // Parse optional self argument.\n-        let self_arg = self.parse_self_arg_with_attrs()?;\n+        let self_param = self.parse_self_parameter_with_attrs()?;\n \n         // Parse the rest of the function parameter list.\n         let sep = SeqSep::trailing_allowed(token::Comma);\n-        let (mut fn_inputs, recovered) = if let Some(self_arg) = self_arg {\n+        let (mut fn_inputs, recovered) = if let Some(self_param) = self_param {\n             if self.check(&token::CloseDelim(token::Paren)) {\n-                (vec![self_arg], false)\n+                (vec![self_param], false)\n             } else if self.eat(&token::Comma) {\n-                let mut fn_inputs = vec![self_arg];\n+                let mut fn_inputs = vec![self_param];\n                 let (mut input, _, recovered) = self.parse_seq_to_before_end(\n-                    &token::CloseDelim(token::Paren), sep, parse_arg_fn)?;\n+                    &token::CloseDelim(token::Paren), sep, parse_param_fn)?;\n                 fn_inputs.append(&mut input);\n                 (fn_inputs, recovered)\n             } else {\n                 match self.expect_one_of(&[], &[]) {\n                     Err(err) => return Err(err),\n-                    Ok(recovered) => (vec![self_arg], recovered),\n+                    Ok(recovered) => (vec![self_param], recovered),\n                 }\n             }\n         } else {\n             let (input, _, recovered) =\n-                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)?;\n+                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren),\n+                                             sep,\n+                                             parse_param_fn)?;\n             (input, recovered)\n         };\n \n         if !recovered {\n             // Parse closing paren and return type.\n             self.expect(&token::CloseDelim(token::Paren))?;\n         }\n-        // Replace duplicated recovered arguments with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_arg_names(&mut fn_inputs);\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut fn_inputs);\n \n         Ok(P(FnDecl {\n             inputs: fn_inputs,"}, {"sha": "5b9f0f1df671865804c7e97e52920762551a8169", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -7,7 +7,7 @@ use crate::maybe_recover_from_interpolated_ty_qpath;\n use crate::ptr::P;\n use crate::ast::{self, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode};\n use crate::ast::{Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm};\n-use crate::ast::{Ty, TyKind, FunctionRetTy, Arg, FnDecl};\n+use crate::ast::{Ty, TyKind, FunctionRetTy, Param, FnDecl};\n use crate::ast::{BinOpKind, BinOp, UnOp};\n use crate::ast::{Mac, AnonConst, Field};\n \n@@ -1157,7 +1157,7 @@ impl<'a> Parser<'a> {\n                     &[&token::BinOp(token::Or), &token::OrOr],\n                     SeqSep::trailing_allowed(token::Comma),\n                     TokenExpectType::NoExpect,\n-                    |p| p.parse_fn_block_arg()\n+                    |p| p.parse_fn_block_param()\n                 )?.0;\n                 self.expect_or()?;\n                 args\n@@ -1172,10 +1172,10 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n-    fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> {\n+    /// Parses a parameter in a lambda header (e.g., `|arg, arg|`).\n+    fn parse_fn_block_param(&mut self) -> PResult<'a, Param> {\n         let lo = self.token.span;\n-        let attrs = self.parse_arg_attributes()?;\n+        let attrs = self.parse_param_attributes()?;\n         let pat = self.parse_pat(PARAM_EXPECTED)?;\n         let t = if self.eat(&token::Colon) {\n             self.parse_ty()?\n@@ -1187,7 +1187,7 @@ impl<'a> Parser<'a> {\n             })\n         };\n         let span = lo.to(self.token.span);\n-        Ok(Arg {\n+        Ok(Param {\n             attrs: attrs.into(),\n             ty: t,\n             pat,"}, {"sha": "59a3ade9c30e59e2d648b83ebb466f172a9c3e63", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -422,7 +422,7 @@ impl<'a> Parser<'a> {\n             } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n                 let ident = self.parse_ident().unwrap();\n                 self.bump();  // `(`\n-                let kw_name = if let Ok(Some(_)) = self.parse_self_arg_with_attrs()\n+                let kw_name = if let Ok(Some(_)) = self.parse_self_parameter_with_attrs()\n                     .map_err(|mut e| e.cancel())\n                 {\n                     \"method\"\n@@ -475,7 +475,7 @@ impl<'a> Parser<'a> {\n                 self.eat_to_tokens(&[&token::Gt]);\n                 self.bump();  // `>`\n                 let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n-                    if let Ok(Some(_)) = self.parse_self_arg_with_attrs()\n+                    if let Ok(Some(_)) = self.parse_self_parameter_with_attrs()\n                         .map_err(|mut e| e.cancel())\n                     {\n                         (\"fn\", \"method\", false)\n@@ -861,7 +861,7 @@ impl<'a> Parser<'a> {\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n             let decl = self.parse_fn_decl_with_self(|p| {\n-                p.parse_arg_general(true, false, |_| true)\n+                p.parse_param_general(true, false, |_| true)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n             *at_end = true;\n@@ -1040,7 +1040,7 @@ impl<'a> Parser<'a> {\n \n                 // We don't allow argument names to be left off in edition 2018.\n                 let is_name_required = p.token.span.rust_2018();\n-                p.parse_arg_general(true, false, |_| is_name_required)\n+                p.parse_param_general(true, false, |_| is_name_required)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n \n@@ -1291,7 +1291,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses the argument list and result type of a function declaration.\n     fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n-        let (args, c_variadic) = self.parse_fn_args(true, allow_c_variadic)?;\n+        let (args, c_variadic) = self.parse_fn_params(true, allow_c_variadic)?;\n         let ret_ty = self.parse_ret_ty(true)?;\n \n         Ok(P(FnDecl {"}, {"sha": "465e31ac57e64a074bfb3bd80d0efc4f7ea58236", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -292,7 +292,7 @@ impl<'a> Parser<'a> {\n         };\n \n         self.expect_keyword(kw::Fn)?;\n-        let (inputs, c_variadic) = self.parse_fn_args(false, true)?;\n+        let (inputs, c_variadic) = self.parse_fn_params(false, true)?;\n         let ret_ty = self.parse_ret_ty(false)?;\n         let decl = P(FnDecl {\n             inputs,"}, {"sha": "bead941b20d5a1f6cc4235c9756c58be5ad89cb3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -418,8 +418,8 @@ pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n     to_string(|s| s.print_attribute(attr))\n }\n \n-pub fn arg_to_string(arg: &ast::Arg) -> String {\n-    to_string(|s| s.print_arg(arg, false))\n+pub fn param_to_string(arg: &ast::Param) -> String {\n+    to_string(|s| s.print_param(arg, false))\n }\n \n fn foreign_item_to_string(arg: &ast::ForeignItem) -> String {\n@@ -2101,7 +2101,7 @@ impl<'a> State<'a> {\n                 self.print_asyncness(asyncness);\n                 self.print_capture_clause(capture_clause);\n \n-                self.print_fn_block_args(decl);\n+                self.print_fn_block_params(decl);\n                 self.s.space();\n                 self.print_expr(body);\n                 self.end(); // need to close a box\n@@ -2536,21 +2536,21 @@ impl<'a> State<'a> {\n             self.print_ident(name);\n         }\n         self.print_generic_params(&generics.params);\n-        self.print_fn_args_and_ret(decl);\n+        self.print_fn_params_and_ret(decl);\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    crate fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl) {\n+    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl) {\n         self.popen();\n-        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false));\n+        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, false));\n         self.pclose();\n \n         self.print_fn_output(decl)\n     }\n \n-    crate fn print_fn_block_args(&mut self, decl: &ast::FnDecl) {\n+    crate fn print_fn_block_params(&mut self, decl: &ast::FnDecl) {\n         self.s.word(\"|\");\n-        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true));\n+        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, true));\n         self.s.word(\"|\");\n \n         if let ast::FunctionRetTy::Default(..) = decl.output {\n@@ -2759,7 +2759,7 @@ impl<'a> State<'a> {\n         self.print_type(&mt.ty)\n     }\n \n-    crate fn print_arg(&mut self, input: &ast::Arg, is_closure: bool) {\n+    crate fn print_param(&mut self, input: &ast::Param, is_closure: bool) {\n         self.ibox(INDENT_UNIT);\n \n         self.print_outer_attributes_inline(&input.attrs);"}, {"sha": "ce1568316f8d49eac326d1d39ff2113a998d8f67", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -66,7 +66,7 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_local(&mut self, l: &'ast Local) { walk_local(self, l) }\n     fn visit_block(&mut self, b: &'ast Block) { walk_block(self, b) }\n     fn visit_stmt(&mut self, s: &'ast Stmt) { walk_stmt(self, s) }\n-    fn visit_arg(&mut self, arg: &'ast Arg) { walk_arg(self, arg) }\n+    fn visit_param(&mut self, param: &'ast Param) { walk_param(self, param) }\n     fn visit_arm(&mut self, a: &'ast Arm) { walk_arm(self, a) }\n     fn visit_pat(&mut self, p: &'ast Pat) { walk_pat(self, p) }\n     fn visit_anon_const(&mut self, c: &'ast AnonConst) { walk_anon_const(self, c) }\n@@ -555,8 +555,8 @@ pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FunctionR\n }\n \n pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) {\n-    for arg in &function_declaration.inputs {\n-        visitor.visit_arg(arg);\n+    for param in &function_declaration.inputs {\n+        visitor.visit_param(param);\n     }\n     visitor.visit_fn_ret_ty(&function_declaration.output);\n }\n@@ -824,10 +824,10 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     visitor.visit_expr_post(expression)\n }\n \n-pub fn walk_arg<'a, V: Visitor<'a>>(visitor: &mut V, arg: &'a Arg) {\n-    walk_list!(visitor, visit_attribute, arg.attrs.iter());\n-    visitor.visit_pat(&arg.pat);\n-    visitor.visit_ty(&arg.ty);\n+pub fn walk_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Param) {\n+    walk_list!(visitor, visit_attribute, param.attrs.iter());\n+    visitor.visit_pat(&param.pat);\n+    visitor.visit_ty(&param.ty);\n }\n \n pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {"}, {"sha": "6fd763f5a9100bfc4b8affd0f1b95fe6f93cb824", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -929,10 +929,10 @@ impl<'a> MethodDef<'a> {\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(trait_.span);\n-                ast::Arg::from_self(ThinVec::default(), explicit_self, ident)\n+                ast::Param::from_self(ThinVec::default(), explicit_self, ident)\n             });\n             let nonself_args = arg_types.into_iter()\n-                .map(|(name, ty)| cx.arg(trait_.span, name, ty));\n+                .map(|(name, ty)| cx.param(trait_.span, name, ty));\n             self_args.into_iter().chain(nonself_args).collect()\n         };\n "}, {"sha": "f4af1699cd683f2e3d604342fd82bfe647ce453d", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1,5 +1,5 @@\n use syntax::ast::{ItemKind, Mutability, Stmt, Ty, TyKind, Unsafety};\n-use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident};\n+use syntax::ast::{self, Param, Attribute, Expr, FnHeader, Generics, Ident};\n use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -114,7 +114,7 @@ impl AllocFnFactory<'_, '_> {\n     fn arg_ty(\n         &self,\n         ty: &AllocatorTy,\n-        args: &mut Vec<Arg>,\n+        args: &mut Vec<Param>,\n         ident: &mut dyn FnMut() -> Ident,\n     ) -> P<Expr> {\n         match *ty {\n@@ -123,8 +123,8 @@ impl AllocFnFactory<'_, '_> {\n                 let ty_usize = self.cx.ty_path(usize);\n                 let size = ident();\n                 let align = ident();\n-                args.push(self.cx.arg(self.span, size, ty_usize.clone()));\n-                args.push(self.cx.arg(self.span, align, ty_usize));\n+                args.push(self.cx.param(self.span, size, ty_usize.clone()));\n+                args.push(self.cx.param(self.span, align, ty_usize));\n \n                 let layout_new = self.cx.std_path(&[\n                     Symbol::intern(\"alloc\"),\n@@ -140,14 +140,14 @@ impl AllocFnFactory<'_, '_> {\n \n             AllocatorTy::Ptr => {\n                 let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n+                args.push(self.cx.param(self.span, ident, self.ptr_u8()));\n                 let arg = self.cx.expr_ident(self.span, ident);\n                 self.cx.expr_cast(self.span, arg, self.ptr_u8())\n             }\n \n             AllocatorTy::Usize => {\n                 let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.usize()));\n+                args.push(self.cx.param(self.span, ident, self.usize()));\n                 self.cx.expr_ident(self.span, ident)\n             }\n "}, {"sha": "3b15f35c260dc81460c7421bd3d64980e3f02afc", "filename": "src/test/ui/async-await/no-args-non-move-async-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -4,5 +4,5 @@\n \n fn main() {\n     let _ = async |x: u8| {};\n-    //~^ ERROR `async` non-`move` closures with arguments are not currently supported\n+    //~^ ERROR `async` non-`move` closures with parameters are not currently supported\n }"}, {"sha": "c58210b997b66db169054c3651481f7661becc62", "filename": "src/test/ui/async-await/no-args-non-move-async-closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-args-non-move-async-closure.stderr?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1,4 +1,4 @@\n-error[E0708]: `async` non-`move` closures with arguments are not currently supported\n+error[E0708]: `async` non-`move` closures with parameters are not currently supported\n   --> $DIR/no-args-non-move-async-closure.rs:6:13\n    |\n LL |     let _ = async |x: u8| {};"}, {"sha": "a2632a4bd7d84be870780af5c3558ae815c3d734", "filename": "src/test/ui/generator/no-arguments-on-generators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.rs?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1,7 +1,7 @@\n #![feature(generators)]\n \n fn main() {\n-    let gen = |start| { //~ ERROR generators cannot have explicit arguments\n+    let gen = |start| { //~ ERROR generators cannot have explicit parameters\n         yield;\n     };\n }"}, {"sha": "8f993b27ce23617ec40647634de2309d329304df", "filename": "src/test/ui/generator/no-arguments-on-generators.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0ce9f8c0a97e5949c9cadd220279d6969289daa/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-arguments-on-generators.stderr?ref=e0ce9f8c0a97e5949c9cadd220279d6969289daa", "patch": "@@ -1,4 +1,4 @@\n-error[E0628]: generators cannot have explicit arguments\n+error[E0628]: generators cannot have explicit parameters\n   --> $DIR/no-arguments-on-generators.rs:4:15\n    |\n LL |     let gen = |start| {"}]}