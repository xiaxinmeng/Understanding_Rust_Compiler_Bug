{"sha": "1b58e3e410187470b1993114f9557b2181efb75a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNThlM2U0MTAxODc0NzBiMTk5MzExNGY5NTU3YjIxODFlZmI3NWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-21T16:21:00Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-21T16:21:58Z"}, "message": "cleanup", "tree": {"sha": "6d40e6984a6d91a015d9b876ff56df648352eb72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d40e6984a6d91a015d9b876ff56df648352eb72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b58e3e410187470b1993114f9557b2181efb75a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b58e3e410187470b1993114f9557b2181efb75a", "html_url": "https://github.com/rust-lang/rust/commit/1b58e3e410187470b1993114f9557b2181efb75a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b58e3e410187470b1993114f9557b2181efb75a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cae9ddeeb14aa81a911a0e69d9eec265cc364d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3", "html_url": "https://github.com/rust-lang/rust/commit/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3"}], "stats": {"total": 141, "additions": 73, "deletions": 68}, "files": [{"sha": "0690925284eff85b15cad05acc3eaa4d544952aa", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 73, "deletions": 68, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/1b58e3e410187470b1993114f9557b2181efb75a/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b58e3e410187470b1993114f9557b2181efb75a/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=1b58e3e410187470b1993114f9557b2181efb75a", "patch": "@@ -12,87 +12,41 @@ use ra_text_edit::{TextEdit, TextEditBuilder};\n use crate::{Diagnostic, FileId, FileSystemEdit, SourceChange, SourceFileEdit, db::RootDatabase};\n \n pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic> {\n-    let syntax = db.parse(file_id);\n+    let source_file = db.parse(file_id);\n+    let mut res = Vec::new();\n+\n+    syntax_errors(&mut res, &source_file);\n+\n+    for node in source_file.syntax().descendants() {\n+        check_unnecessary_braces_in_use_statement(&mut res, file_id, node);\n+        check_struct_shorthand_initialization(&mut res, file_id, node);\n+    }\n \n-    let mut res = syntax_diagnostics(file_id, &syntax);\n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n-        for (name_node, problem) in m.problems(db) {\n-            let source_root = db.file_source_root(file_id);\n-            let diag = match problem {\n-                Problem::UnresolvedModule { candidate } => {\n-                    let create_file =\n-                        FileSystemEdit::CreateFile { source_root, path: candidate.clone() };\n-                    let fix = SourceChange {\n-                        label: \"create module\".to_string(),\n-                        source_file_edits: Vec::new(),\n-                        file_system_edits: vec![create_file],\n-                        cursor_position: None,\n-                    };\n-                    Diagnostic {\n-                        range: name_node.range(),\n-                        message: \"unresolved module\".to_string(),\n-                        severity: Severity::Error,\n-                        fix: Some(fix),\n-                    }\n-                }\n-                Problem::NotDirOwner { move_to, candidate } => {\n-                    let move_file = FileSystemEdit::MoveFile {\n-                        src: file_id,\n-                        dst_source_root: source_root,\n-                        dst_path: move_to.clone(),\n-                    };\n-                    let create_file =\n-                        FileSystemEdit::CreateFile { source_root, path: move_to.join(candidate) };\n-                    let fix = SourceChange {\n-                        label: \"move file and create module\".to_string(),\n-                        source_file_edits: Vec::new(),\n-                        file_system_edits: vec![move_file, create_file],\n-                        cursor_position: None,\n-                    };\n-                    Diagnostic {\n-                        range: name_node.range(),\n-                        message: \"can't declare module at this location\".to_string(),\n-                        severity: Severity::Error,\n-                        fix: Some(fix),\n-                    }\n-                }\n-            };\n-            res.push(diag)\n-        }\n+        check_module(&mut res, db, file_id, m);\n     };\n     res\n }\n \n-fn syntax_diagnostics(file_id: FileId, file: &SourceFile) -> Vec<Diagnostic> {\n+fn syntax_errors(acc: &mut Vec<Diagnostic>, source_file: &SourceFile) {\n     fn location_to_range(location: Location) -> TextRange {\n         match location {\n             Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n             Location::Range(range) => range,\n         }\n     }\n \n-    let mut errors: Vec<Diagnostic> = file\n-        .errors()\n-        .into_iter()\n-        .map(|err| Diagnostic {\n-            range: location_to_range(err.location()),\n-            message: format!(\"Syntax Error: {}\", err),\n-            severity: Severity::Error,\n-            fix: None,\n-        })\n-        .collect();\n-\n-    for node in file.syntax().descendants() {\n-        check_unnecessary_braces_in_use_statement(file_id, &mut errors, node);\n-        check_struct_shorthand_initialization(file_id, &mut errors, node);\n-    }\n-\n-    errors\n+    acc.extend(source_file.errors().into_iter().map(|err| Diagnostic {\n+        range: location_to_range(err.location()),\n+        message: format!(\"Syntax Error: {}\", err),\n+        severity: Severity::Error,\n+        fix: None,\n+    }));\n }\n \n fn check_unnecessary_braces_in_use_statement(\n-    file_id: FileId,\n     acc: &mut Vec<Diagnostic>,\n+    file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(node)?;\n@@ -140,8 +94,8 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n }\n \n fn check_struct_shorthand_initialization(\n-    file_id: FileId,\n     acc: &mut Vec<Diagnostic>,\n+    file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<()> {\n     let struct_lit = ast::StructLit::cast(node)?;\n@@ -173,19 +127,70 @@ fn check_struct_shorthand_initialization(\n     Some(())\n }\n \n+fn check_module(\n+    acc: &mut Vec<Diagnostic>,\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    module: hir::Module,\n+) {\n+    let source_root = db.file_source_root(file_id);\n+    for (name_node, problem) in module.problems(db) {\n+        let diag = match problem {\n+            Problem::UnresolvedModule { candidate } => {\n+                let create_file =\n+                    FileSystemEdit::CreateFile { source_root, path: candidate.clone() };\n+                let fix = SourceChange {\n+                    label: \"create module\".to_string(),\n+                    source_file_edits: Vec::new(),\n+                    file_system_edits: vec![create_file],\n+                    cursor_position: None,\n+                };\n+                Diagnostic {\n+                    range: name_node.range(),\n+                    message: \"unresolved module\".to_string(),\n+                    severity: Severity::Error,\n+                    fix: Some(fix),\n+                }\n+            }\n+            Problem::NotDirOwner { move_to, candidate } => {\n+                let move_file = FileSystemEdit::MoveFile {\n+                    src: file_id,\n+                    dst_source_root: source_root,\n+                    dst_path: move_to.clone(),\n+                };\n+                let create_file =\n+                    FileSystemEdit::CreateFile { source_root, path: move_to.join(candidate) };\n+                let fix = SourceChange {\n+                    label: \"move file and create module\".to_string(),\n+                    source_file_edits: Vec::new(),\n+                    file_system_edits: vec![move_file, create_file],\n+                    cursor_position: None,\n+                };\n+                Diagnostic {\n+                    range: name_node.range(),\n+                    message: \"can't declare module at this location\".to_string(),\n+                    severity: Severity::Error,\n+                    fix: Some(fix),\n+                }\n+            }\n+        };\n+        acc.push(diag)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use test_utils::assert_eq_text;\n \n     use super::*;\n \n-    type DiagnosticChecker = fn(FileId, &mut Vec<Diagnostic>, &SyntaxNode) -> Option<()>;\n+    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, FileId, &SyntaxNode) -> Option<()>;\n \n     fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n         let file = SourceFile::parse(code);\n         let mut diagnostics = Vec::new();\n         for node in file.syntax().descendants() {\n-            func(FileId(0), &mut diagnostics, node);\n+            func(&mut diagnostics, FileId(0), node);\n         }\n         assert!(diagnostics.is_empty());\n     }\n@@ -194,7 +199,7 @@ mod tests {\n         let file = SourceFile::parse(before);\n         let mut diagnostics = Vec::new();\n         for node in file.syntax().descendants() {\n-            func(FileId(0), &mut diagnostics, node);\n+            func(&mut diagnostics, FileId(0), node);\n         }\n         let diagnostic =\n             diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));"}]}