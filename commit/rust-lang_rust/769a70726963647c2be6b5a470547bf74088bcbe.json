{"sha": "769a70726963647c2be6b5a470547bf74088bcbe", "node_id": "C_kwDOAAsO6NoAKDc2OWE3MDcyNjk2MzY0N2MyYmU2YjVhNDcwNTQ3YmY3NDA4OGJjYmU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2021-12-07T02:29:20Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2021-12-09T04:20:58Z"}, "message": "Improve the readability of `List<T>`.\n\nThis commit does the following.\n- Expands on some of the things already mentioned in comments.\n- Describes the uniqueness assumption, which is critical but wasn't\n  mentioned at all.\n- Rewrites `empty()` into a clearer form, as provided by Daniel\n  Henry-Mantilla on Zulip.\n- Reorders things slightly so that more important things\n  are higher up, and incidental things are lower down, which makes\n  reading the code easier.", "tree": {"sha": "2f98dc293c3f79ef420ba820af7c320dbba27f98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f98dc293c3f79ef420ba820af7c320dbba27f98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/769a70726963647c2be6b5a470547bf74088bcbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/769a70726963647c2be6b5a470547bf74088bcbe", "html_url": "https://github.com/rust-lang/rust/commit/769a70726963647c2be6b5a470547bf74088bcbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/769a70726963647c2be6b5a470547bf74088bcbe/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "772d51f887fa407216860bf8ecf3f1a32fb795b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/772d51f887fa407216860bf8ecf3f1a32fb795b4", "html_url": "https://github.com/rust-lang/rust/commit/772d51f887fa407216860bf8ecf3f1a32fb795b4"}], "stats": {"total": 140, "additions": 89, "deletions": 51}, "files": [{"sha": "adba7d131592ec81b11a1b4096499445edd57824", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 89, "deletions": 51, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/769a70726963647c2be6b5a470547bf74088bcbe/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769a70726963647c2be6b5a470547bf74088bcbe/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=769a70726963647c2be6b5a470547bf74088bcbe", "patch": "@@ -1,7 +1,5 @@\n use crate::arena::Arena;\n-\n use rustc_serialize::{Encodable, Encoder};\n-\n use std::alloc::Layout;\n use std::cmp::Ordering;\n use std::fmt;\n@@ -12,49 +10,69 @@ use std::ops::Deref;\n use std::ptr;\n use std::slice;\n \n-extern \"C\" {\n-    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n-    /// pointers.\n-    type OpaqueListContents;\n-}\n-\n-/// A wrapper for slices with the additional invariant\n-/// that the slice is interned and no other slice with\n-/// the same contents can exist in the same context.\n-/// This means we can use pointer for both\n-/// equality comparisons and hashing.\n-///\n-/// Unlike slices, the types contained in `List` are expected to be `Copy`\n-/// and iterating over a `List` returns `T` instead of a reference.\n-///\n-/// Note: `Slice` was already taken by the `Ty`.\n+/// `List<T>` is a bit like `&[T]`, but with some critical differences.\n+/// - IMPORTANT: Every `List<T>` is *required* to have unique contents. The\n+///   type's correctness relies on this, *but it does not enforce it*.\n+///   Therefore, any code that creates a `List<T>` must ensure uniqueness\n+///   itself. In practice this is achieved by interning.\n+/// - The length is stored within the `List<T>`, so `&List<Ty>` is a thin\n+///   pointer.\n+/// - Because of this, you cannot get a `List<T>` that is a sub-list of another\n+///   `List<T>`. You can get a sub-slice `&[T]`, however.\n+/// - `List<T>` can be used with `CopyTaggedPtr`, which is useful within\n+///   structs whose size must be minimized.\n+/// - Because of the uniqueness assumption, we can use the address of a\n+///   `List<T>` for faster equality comparisons and hashing.\n+/// - `T` must be `Copy`. This lets `List<T>` be stored in a dropless arena and\n+///   iterators return a `T` rather than a `&T`.\n+/// - `T` must not be zero-sized.\n #[repr(C)]\n pub struct List<T> {\n     len: usize,\n+\n+    /// Although this claims to be a zero-length array, in practice `len`\n+    /// elements are actually present.\n     data: [T; 0],\n+\n     opaque: OpaqueListContents,\n }\n \n-unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n-    const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n-    #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *const List<T> as usize\n-    }\n-    #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &*(ptr as *const List<T>)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        // Self: Copy so this is fine\n-        let ptr = Self::from_usize(ptr);\n-        f(&ptr)\n-    }\n+extern \"C\" {\n+    /// A dummy type used to force `List` to be unsized while not requiring\n+    /// references to it be wide pointers.\n+    type OpaqueListContents;\n }\n \n-unsafe impl<T: Sync> Sync for List<T> {}\n+impl<T> List<T> {\n+    /// Returns a reference to the (unique, static) empty list.\n+    #[inline(always)]\n+    pub fn empty<'a>() -> &'a List<T> {\n+        #[repr(align(64))]\n+        struct MaxAlign;\n+\n+        assert!(mem::align_of::<T>() <= mem::align_of::<MaxAlign>());\n+\n+        #[repr(C)]\n+        struct InOrder<T, U>(T, U);\n+\n+        // The empty slice is static and contains a single `0` usize (for the\n+        // length) that is 64-byte aligned, thus featuring the necessary\n+        // trailing padding for elements with up to 64-byte alignment.\n+        static EMPTY_SLICE: InOrder<usize, MaxAlign> = InOrder(0, MaxAlign);\n+        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+    }\n+}\n \n impl<T: Copy> List<T> {\n+    /// Allocates a list from `arena` and copies the contents of `slice` into it.\n+    ///\n+    /// WARNING: the contents *must be unique*, such that no list with these\n+    /// contents has been previously created. If not, operations such as `eq`\n+    /// and `hash` might give incorrect results.\n+    ///\n+    /// Panics if `T` is `Drop`, or `T` is zero-sized, or the slice is empty\n+    /// (because the empty list exists statically, and is available via\n+    /// `empty()`).\n     #[inline]\n     pub(super) fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n         assert!(!mem::needs_drop::<T>());\n@@ -73,7 +91,7 @@ impl<T: Copy> List<T> {\n                 .cast::<T>()\n                 .copy_from_nonoverlapping(slice.as_ptr(), slice.len());\n \n-            &mut *mem\n+            &*mem\n         }\n     }\n \n@@ -107,11 +125,24 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for &List<T> {\n     }\n }\n \n+impl<T: PartialEq> PartialEq for List<T> {\n+    #[inline]\n+    fn eq(&self, other: &List<T>) -> bool {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption).\n+        ptr::eq(self, other)\n+    }\n+}\n+\n+impl<T: Eq> Eq for List<T> {}\n+\n impl<T> Ord for List<T>\n where\n     T: Ord,\n {\n     fn cmp(&self, other: &List<T>) -> Ordering {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption), but the contents must be compared otherwise.\n         if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n     }\n }\n@@ -121,6 +152,8 @@ where\n     T: PartialOrd,\n {\n     fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n+        // Pointer equality implies list equality (due to the unique contents\n+        // assumption), but the contents must be compared otherwise.\n         if self == other {\n             Some(Ordering::Equal)\n         } else {\n@@ -129,17 +162,11 @@ where\n     }\n }\n \n-impl<T: PartialEq> PartialEq for List<T> {\n-    #[inline]\n-    fn eq(&self, other: &List<T>) -> bool {\n-        ptr::eq(self, other)\n-    }\n-}\n-impl<T: Eq> Eq for List<T> {}\n-\n impl<T> Hash for List<T> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n+        // Pointer hashing is sufficient (due to the unique contents\n+        // assumption).\n         (self as *const List<T>).hash(s)\n     }\n }\n@@ -168,13 +195,24 @@ impl<'a, T: Copy> IntoIterator for &'a List<T> {\n     }\n }\n \n-impl<T> List<T> {\n-    #[inline(always)]\n-    pub fn empty<'a>() -> &'a List<T> {\n-        #[repr(align(64), C)]\n-        struct EmptySlice([u8; 64]);\n-        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n-        assert!(mem::align_of::<T>() <= 64);\n-        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+unsafe impl<T: Sync> Sync for List<T> {}\n+\n+unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n+    const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n+\n+    #[inline]\n+    fn into_usize(self) -> usize {\n+        self as *const List<T> as usize\n+    }\n+\n+    #[inline]\n+    unsafe fn from_usize(ptr: usize) -> &'a List<T> {\n+        &*(ptr as *const List<T>)\n+    }\n+\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        // `Self` is `&'a List<T>` which impls `Copy`, so this is fine.\n+        let ptr = Self::from_usize(ptr);\n+        f(&ptr)\n     }\n }"}]}