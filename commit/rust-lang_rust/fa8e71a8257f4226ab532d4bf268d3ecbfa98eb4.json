{"sha": "fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhOGU3MWE4MjU3ZjQyMjZhYjUzMmQ0YmYyNjhkM2VjYmZhOThlYjQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-10-11T21:20:34Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-10-28T07:50:32Z"}, "message": "Allow fail messages to be caught, and introduce the Any trait\n\nSome code cleanup, sorting of import blocks\n\nRemoved std::unstable::UnsafeArc's use of Either\n\nAdded run-fail tests for the new FailWithCause impls\n\nChanged future_result and try to return Result<(), ~Any>.\n\n- Internally, there is an enum of possible fail messages passend around.\n- In case of linked failure or a string message, the ~Any gets\n  lazyly allocated in future_results recv method.\n- For that, future result now returns a wrapper around a Port.\n- Moved and renamed task::TaskResult into rt::task::UnwindResult\n  and made it an internal enum.\n- Introduced a replacement typedef `type TaskResult = Result<(), ~Any>`.", "tree": {"sha": "0b8051814dd8a5ef08e663c172e2b456065d625d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b8051814dd8a5ef08e663c172e2b456065d625d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "html_url": "https://github.com/rust-lang/rust/commit/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb5b21eba713ff3888b2741db4c9e7d841cfde02", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb5b21eba713ff3888b2741db4c9e7d841cfde02", "html_url": "https://github.com/rust-lang/rust/commit/cb5b21eba713ff3888b2741db4c9e7d841cfde02"}], "stats": {"total": 1126, "additions": 912, "deletions": 214}, "files": [{"sha": "1988da2b0bafc2827230ec583e0335230f03b106", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -918,7 +918,7 @@ mod tests {\n         let m = Mutex::new();\n         let m2 = m.clone();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(), ~Any> = do task::try {\n             do m2.lock {\n                 fail!();\n             }\n@@ -935,7 +935,7 @@ mod tests {\n         let m = Mutex::new();\n         let m2 = m.clone();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(), ~Any> = do task::try {\n             let (p, c) = comm::stream();\n             do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n@@ -963,7 +963,7 @@ mod tests {\n         let m2 = m.clone();\n         let (p, c) = comm::stream();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(), ~Any> = do task::try {\n             let mut sibling_convos = ~[];\n             do 2.times {\n                 let (p, c) = comm::stream();\n@@ -1272,7 +1272,7 @@ mod tests {\n         let x = RWLock::new();\n         let x2 = x.clone();\n \n-        let result: result::Result<(),()> = do task::try || {\n+        let result: result::Result<(), ~Any> = do task::try || {\n             do lock_rwlock_in_mode(&x2, mode1) {\n                 fail!();\n             }"}, {"sha": "070108ddf2e8ef1972fd69cbe8303a818fddecf7", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -873,8 +873,7 @@ pub fn run_test(force_ignore: bool,\n             task.spawn(testfn_cell.take());\n \n             let task_result = result_future.recv();\n-            let test_result = calc_result(&desc,\n-                                          task_result == task::Success);\n+            let test_result = calc_result(&desc, task_result.is_ok());\n             monitor_ch.send((desc.clone(), test_result));\n         }\n     }"}, {"sha": "f5973bff4fccf0d39a08c9a31938519a4a0e55b1", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -640,9 +640,8 @@ fn test_install_invalid() {\n                                   pkgid.clone());\n         ctxt.install(pkg_src, &WhatToBuild::new(MaybeCustom, Everything));\n     };\n-    // Not the best test -- doesn't test that we failed in the right way.\n-    // Best we can do for now.\n-    assert!(result == Err(()));\n+    assert!(result.unwrap_err()\n+            .to_str().contains(\"supplied path for package dir does not exist\"));\n }\n \n #[test]"}, {"sha": "a648c5e68783bb34c486988e7e0b6f5e6d103bba", "filename": "src/libstd/any.rs", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -0,0 +1,418 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module implements the `Any` trait, which enables dynamic typing\n+//! of any type.\n+\n+use cast::transmute;\n+use cmp::Eq;\n+use option::{Option, Some, None};\n+use to_str::ToStr;\n+use unstable::intrinsics::{TyDesc, get_tydesc, forget};\n+use util::Void;\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// TypeId\n+// FIXME: #9913 - Needs proper intrinsic support to work reliably cross crate\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// `TypeId` represents a globally unique identifier for a type\n+pub struct TypeId {\n+    priv t: *TyDesc\n+}\n+\n+impl TypeId {\n+    /// Returns the `TypeId` of the type this generic function has been instantiated with\n+    #[inline]\n+    pub fn of<T>() -> TypeId {\n+        TypeId{ t: unsafe { get_tydesc::<T>() } }\n+    }\n+}\n+\n+impl Eq for TypeId {\n+    #[inline]\n+    fn eq(&self, &other: &TypeId) -> bool {\n+        self.t == other.t\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Any trait\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// The `Any` trait is implemented by all types, and can be used as a trait object\n+/// for dynamic typing\n+pub trait Any {\n+    /// Get the `TypeId` of `self`\n+    fn get_type_id(&self) -> TypeId {\n+        TypeId::of::<Self>()\n+    }\n+\n+    /// Get a void pointer to `self`\n+    fn as_void_ptr(&self) -> *Void {\n+        self as *Self as *Void\n+    }\n+\n+    /// Get a mutable void pointer to `self`\n+    fn as_mut_void_ptr(&mut self) -> *mut Void {\n+        self as *mut Self as *mut Void\n+    }\n+}\n+impl<T> Any for T {}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Extension methods for Any trait objects.\n+// Implemented as three extension traits so that generics work.\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// Extension methods for a referenced `Any` trait object\n+pub trait AnyRefExt<'self> {\n+    /// Returns true if the boxed type is the same as `T`\n+    fn is<T>(self) -> bool;\n+\n+    /// Returns some reference to the boxed value if it is of type `T`, or\n+    /// `None` if it isn't.\n+    fn as_ref<T>(self) -> Option<&'self T>;\n+}\n+\n+impl<'self> AnyRefExt<'self> for &'self Any {\n+    #[inline]\n+    fn is<T>(self) -> bool {\n+        // Get TypeId of the type this function is instantiated with\n+        let t = TypeId::of::<T>();\n+\n+        // Get TypeId of the type in the trait object\n+        let boxed = self.get_type_id();\n+\n+        // Compare both TypeIds on equality\n+        t == boxed\n+    }\n+\n+    #[inline]\n+    fn as_ref<T>(self) -> Option<&'self T> {\n+        if self.is::<T>() {\n+            Some(unsafe { transmute(self.as_void_ptr()) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Extension methods for a mutable referenced `Any` trait object\n+pub trait AnyMutRefExt<'self> {\n+    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n+    /// `None` if it isn't.\n+    fn as_mut<T>(self) -> Option<&'self mut T>;\n+}\n+\n+impl<'self> AnyMutRefExt<'self> for &'self mut Any {\n+    #[inline]\n+    fn as_mut<T>(self) -> Option<&'self mut T> {\n+        if self.is::<T>() {\n+            Some(unsafe { transmute(self.as_mut_void_ptr()) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Extension methods for a owning `Any` trait object\n+pub trait AnyOwnExt {\n+    /// Returns the boxed value if it is of type `T`, or\n+    /// `None` if it isn't.\n+    fn move<T>(self) -> Option<~T>;\n+}\n+\n+impl AnyOwnExt for ~Any {\n+    #[inline]\n+    fn move<T>(self) -> Option<~T> {\n+        if self.is::<T>() {\n+            unsafe {\n+                // Extract the pointer to the boxed value, temporary alias with self\n+                let ptr: ~T = transmute(self.as_void_ptr());\n+\n+                // Prevent destructor on self being run\n+                forget(self);\n+\n+                Some(ptr)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Trait implementations\n+///////////////////////////////////////////////////////////////////////////////\n+\n+impl ToStr for ~Any {\n+    fn to_str(&self) -> ~str { ~\"~Any\" }\n+}\n+\n+impl<'self> ToStr for &'self Any {\n+    fn to_str(&self) -> ~str { ~\"&Any\" }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use super::AnyRefExt;\n+    use option::{Some, None};\n+\n+    #[deriving(Eq)]\n+    struct Test;\n+\n+    static TEST: &'static str = \"Test\";\n+\n+    #[test]\n+    fn type_id() {\n+        let (a, b, c) = (TypeId::of::<uint>(), TypeId::of::<&str>(), TypeId::of::<Test>());\n+        let (d, e, f) = (TypeId::of::<uint>(), TypeId::of::<&str>(), TypeId::of::<Test>());\n+\n+        assert!(a != b);\n+        assert!(a != c);\n+        assert!(b != c);\n+\n+        assert_eq!(a, d);\n+        assert_eq!(b, e);\n+        assert_eq!(c, f);\n+    }\n+\n+    #[test]\n+    fn any_as_void_ptr() {\n+        let (a, b, c) = (~5u as ~Any, ~TEST as ~Any, ~Test as ~Any);\n+        let a_r: &Any = a;\n+        let b_r: &Any = b;\n+        let c_r: &Any = c;\n+\n+        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n+        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n+        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n+\n+        let (a, b, c) = (@5u as @Any, @TEST as @Any, @Test as @Any);\n+        let a_r: &Any = a;\n+        let b_r: &Any = b;\n+        let c_r: &Any = c;\n+\n+        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n+        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n+        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n+\n+        let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n+        let a_r: &Any = a;\n+        let b_r: &Any = b;\n+        let c_r: &Any = c;\n+\n+        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n+        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n+        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n+\n+        let mut x = Test;\n+        let mut y: &'static str = \"Test\";\n+        let (a, b, c) = (&mut 5u as &mut Any,\n+                         &mut y as &mut Any,\n+                         &mut x as &mut Any);\n+        let a_r: &Any = a;\n+        let b_r: &Any = b;\n+        let c_r: &Any = c;\n+\n+        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n+        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n+        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n+\n+        let (a, b, c) = (5u, \"hello\", Test);\n+        let (a_r, b_r, c_r) = (&a as &Any, &b as &Any, &c as &Any);\n+\n+        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n+        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n+        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n+    }\n+\n+    #[test]\n+    fn any_as_mut_void_ptr() {\n+        let y: &'static str = \"Test\";\n+        let mut a = ~5u as ~Any;\n+        let mut b = ~y as ~Any;\n+        let mut c = ~Test as ~Any;\n+\n+        let a_ptr = a.as_mut_void_ptr();\n+        let b_ptr = b.as_mut_void_ptr();\n+        let c_ptr = c.as_mut_void_ptr();\n+\n+        let a_r: &mut Any = a;\n+        let b_r: &mut Any = b;\n+        let c_r: &mut Any = c;\n+\n+        assert_eq!(a_ptr, a_r.as_mut_void_ptr());\n+        assert_eq!(b_ptr, b_r.as_mut_void_ptr());\n+        assert_eq!(c_ptr, c_r.as_mut_void_ptr());\n+\n+        let mut x = Test;\n+        let mut y: &'static str = \"Test\";\n+        let a = &mut 5u as &mut Any;\n+        let b = &mut y as &mut Any;\n+        let c = &mut x as &mut Any;\n+\n+        let a_ptr = a.as_mut_void_ptr();\n+        let b_ptr = b.as_mut_void_ptr();\n+        let c_ptr = c.as_mut_void_ptr();\n+\n+        let a_r: &mut Any = a;\n+        let b_r: &mut Any = b;\n+        let c_r: &mut Any = c;\n+\n+        assert_eq!(a_ptr, a_r.as_mut_void_ptr());\n+        assert_eq!(b_ptr, b_r.as_mut_void_ptr());\n+        assert_eq!(c_ptr, c_r.as_mut_void_ptr());\n+\n+        let y: &'static str = \"Test\";\n+        let mut a = 5u;\n+        let mut b = y;\n+        let mut c = Test;\n+\n+        let a_ptr = a.as_mut_void_ptr();\n+        let b_ptr = b.as_mut_void_ptr();\n+        let c_ptr = c.as_mut_void_ptr();\n+\n+        let (a_r, b_r, c_r) = (&mut a as &mut Any, &mut b as &mut Any, &mut c as &mut Any);\n+\n+        assert_eq!(a_ptr, a_r.as_mut_void_ptr());\n+        assert_eq!(b_ptr, b_r.as_mut_void_ptr());\n+        assert_eq!(c_ptr, c_r.as_mut_void_ptr());\n+    }\n+\n+    #[test]\n+    fn any_referenced() {\n+        let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n+\n+        assert!(a.is::<uint>());\n+        assert!(!b.is::<uint>());\n+        assert!(!c.is::<uint>());\n+\n+        assert!(!a.is::<&'static str>());\n+        assert!(b.is::<&'static str>());\n+        assert!(!c.is::<&'static str>());\n+\n+        assert!(!a.is::<Test>());\n+        assert!(!b.is::<Test>());\n+        assert!(c.is::<Test>());\n+    }\n+\n+    #[test]\n+    fn any_owning() {\n+        let (a, b, c) = (~5u as ~Any, ~TEST as ~Any, ~Test as ~Any);\n+\n+        assert!(a.is::<uint>());\n+        assert!(!b.is::<uint>());\n+        assert!(!c.is::<uint>());\n+\n+        assert!(!a.is::<&'static str>());\n+        assert!(b.is::<&'static str>());\n+        assert!(!c.is::<&'static str>());\n+\n+        assert!(!a.is::<Test>());\n+        assert!(!b.is::<Test>());\n+        assert!(c.is::<Test>());\n+    }\n+\n+    #[test]\n+    fn any_managed() {\n+        let (a, b, c) = (@5u as @Any, @TEST as @Any, @Test as @Any);\n+\n+        assert!(a.is::<uint>());\n+        assert!(!b.is::<uint>());\n+        assert!(!c.is::<uint>());\n+\n+        assert!(!a.is::<&'static str>());\n+        assert!(b.is::<&'static str>());\n+        assert!(!c.is::<&'static str>());\n+\n+        assert!(!a.is::<Test>());\n+        assert!(!b.is::<Test>());\n+        assert!(c.is::<Test>());\n+    }\n+\n+    #[test]\n+    fn any_as_ref() {\n+        let a = &5u as &Any;\n+\n+        match a.as_ref::<uint>() {\n+            Some(&5) => {}\n+            x => fail!(\"Unexpected value {:?}\", x)\n+        }\n+\n+        match a.as_ref::<Test>() {\n+            None => {}\n+            x => fail!(\"Unexpected value {:?}\", x)\n+        }\n+    }\n+\n+    #[test]\n+    fn any_as_mut() {\n+        let mut a = 5u;\n+        let mut b = ~7u;\n+\n+        let a_r = &mut a as &mut Any;\n+        let tmp: &mut uint = b;\n+        let b_r = tmp as &mut Any;\n+\n+        match a_r.as_mut::<uint>() {\n+            Some(x) => {\n+                assert_eq!(*x, 5u);\n+                *x = 612;\n+            }\n+            x => fail!(\"Unexpected value {:?}\", x)\n+        }\n+\n+        match b_r.as_mut::<uint>() {\n+            Some(x) => {\n+                assert_eq!(*x, 7u);\n+                *x = 413;\n+            }\n+            x => fail!(\"Unexpected value {:?}\", x)\n+        }\n+\n+        match a_r.as_mut::<Test>() {\n+            None => (),\n+            x => fail!(\"Unexpected value {:?}\", x)\n+        }\n+\n+        match b_r.as_mut::<Test>() {\n+            None => (),\n+            x => fail!(\"Unexpected value {:?}\", x)\n+        }\n+\n+        match a_r.as_mut::<uint>() {\n+            Some(&612) => {}\n+            x => fail!(\"Unexpected value {:?}\", x)\n+        }\n+\n+        match b_r.as_mut::<uint>() {\n+            Some(&413) => {}\n+            x => fail!(\"Unexpected value {:?}\", x)\n+        }\n+    }\n+\n+    #[test]\n+    fn any_move() {\n+        let a = ~8u as ~Any;\n+        let b = ~Test as ~Any;\n+\n+        assert_eq!(a.move(), Some(~8u));\n+        assert_eq!(b.move(), Some(~Test));\n+\n+        let a = ~8u as ~Any;\n+        let b = ~Test as ~Any;\n+\n+        assert_eq!(a.move(), None::<~Test>);\n+        assert_eq!(b.move(), None::<~uint>);\n+    }\n+}"}, {"sha": "a15ef879e322d4fb1136345738d9ac872ce265dc", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -43,6 +43,8 @@ pub use iter::range;\n pub use rt::io::stdio::{print, println};\n \n // Reexported types and traits\n+\n+pub use any::{Any, AnyOwnExt, AnyRefExt, AnyMutRefExt};\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n pub use bool::Bool;\n pub use c_str::ToCStr;"}, {"sha": "234b46458b458a4d8843498deb93c09a75a03b58", "filename": "src/libstd/rt/io/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Foption.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -107,7 +107,7 @@ mod test {\n     use option::*;\n     use super::super::mem::*;\n     use rt::test::*;\n-    use super::super::{PreviousIoError, io_error, io_error};\n+    use super::super::{PreviousIoError, io_error};\n \n     #[test]\n     fn test_option_writer() {"}, {"sha": "4c6c675df0342c1faecdb3a91de264be5622a718", "filename": "src/libstd/rt/io/signal.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -145,10 +145,10 @@ impl Listener {\n \n #[cfg(test)]\n mod test {\n+    use super::*;\n+\n     use libc;\n     use rt::io::timer;\n-    use rt::io;\n-    use super::*;\n \n     // kill is only available on Unixes\n     #[cfg(unix)]\n@@ -206,6 +206,7 @@ mod test {\n     #[cfg(windows)]\n     #[test]\n     fn test_io_signal_invalid_signum() {\n+        use rt::io;\n         let mut s = Listener::new();\n         let mut called = false;\n         do io::io_error::cond.trap(|_| {"}, {"sha": "edf6ffb820b31f1615a2c1763c0438b7329331b8", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -152,14 +152,15 @@ There are two known issues with the current scheme for exit code propagation.\n \n use cast;\n use cell::Cell;\n-use either::{Either, Left, Right};\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n+use rt::task::UnwindReasonLinked;\n+use rt::task::{UnwindResult, Failure};\n use task::spawn::Taskgroup;\n use to_bytes::IterBytes;\n use unstable::atomics::{AtomicUint, Relaxed};\n-use unstable::sync::{UnsafeArc, LittleLock};\n+use unstable::sync::{UnsafeArc, UnsafeArcSelf, UnsafeArcT, LittleLock};\n use util;\n \n static KILLED_MSG: &'static str = \"killed by linked failure\";\n@@ -222,7 +223,7 @@ pub struct Death {\n     priv watching_parent: Option<KillHandle>,\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n-    on_exit:         Option<~fn(bool)>,\n+    on_exit:         Option<~fn(UnwindResult)>,\n     // nesting level counter for task::unkillable calls (0 == killable).\n     priv unkillable:      int,\n     // nesting level counter for unstable::atomically calls (0 == can deschedule).\n@@ -478,7 +479,7 @@ impl KillHandle {\n         match self.try_unwrap() {\n             // Couldn't unwrap; children still alive. Reparent entire handle as\n             // our own tombstone, to be unwrapped later.\n-            Left(this) => {\n+            UnsafeArcSelf(this) => {\n                 let this = Cell::new(this); // :(\n                 do add_lazy_tombstone(parent) |other_tombstones| {\n                     let this = Cell::new(this.take()); // :(\n@@ -494,14 +495,16 @@ impl KillHandle {\n                     }\n                 }\n             }\n+\n             // Whether or not all children exited, one or more already failed.\n-            Right(KillHandleInner { any_child_failed: true, _ }) => {\n+            UnsafeArcT(KillHandleInner { any_child_failed: true, _ }) => {\n                 parent.notify_immediate_failure();\n             }\n+\n             // All children exited, but some left behind tombstones that we\n             // don't want to wait on now. Give them to our parent.\n-            Right(KillHandleInner { any_child_failed: false,\n-                                    child_tombstones: Some(f), _ }) => {\n+            UnsafeArcT(KillHandleInner { any_child_failed: false,\n+                                         child_tombstones: Some(f), _ }) => {\n                 let f = Cell::new(f); // :(\n                 do add_lazy_tombstone(parent) |other_tombstones| {\n                     let f = Cell::new(f.take()); // :(\n@@ -513,9 +516,10 @@ impl KillHandle {\n                     }\n                 }\n             }\n+\n             // All children exited, none failed. Nothing to do!\n-            Right(KillHandleInner { any_child_failed: false,\n-                                    child_tombstones: None, _ }) => { }\n+            UnsafeArcT(KillHandleInner { any_child_failed: false,\n+                                         child_tombstones: None, _ }) => { }\n         }\n \n         // NB: Takes a pthread mutex -- 'blk' not allowed to reschedule.\n@@ -562,7 +566,7 @@ impl Death {\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, mut success: bool, group: Option<Taskgroup>) {\n+    pub fn collect_failure(&mut self, result: UnwindResult, group: Option<Taskgroup>) {\n         // This may run after the task has already failed, so even though the\n         // task appears to need to be killed, the scheduler should not fail us\n         // when we block to unwrap.\n@@ -576,19 +580,27 @@ impl Death {\n         // FIXME(#8192): Doesn't work with \"let _ = ...\"\n         { use util; util::ignore(group); }\n \n+        let mut success = result.is_success();\n+        let mut result = Cell::new(result);\n+\n         // Step 1. Decide if we need to collect child failures synchronously.\n         do self.on_exit.take().map |on_exit| {\n             if success {\n                 // We succeeded, but our children might not. Need to wait for them.\n                 let mut inner = self.kill_handle.take_unwrap().unwrap();\n+\n                 if inner.any_child_failed {\n                     success = false;\n                 } else {\n                     // Lockless access to tombstones protected by unwrap barrier.\n                     success = inner.child_tombstones.take().map_default(true, |f| f());\n                 }\n+\n+                if !success {\n+                    result = Cell::new(Failure(UnwindReasonLinked));\n+                }\n             }\n-            on_exit(success);\n+            on_exit(result.take());\n         };\n \n         // Step 2. Possibly alert possibly-watching parent to failure status."}, {"sha": "eaaf8c4328191655204e2cd4f6539392f5f23a70", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -66,12 +66,13 @@ use ptr::RawPtr;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown};\n use rt::sleeper_list::SleeperList;\n+use rt::task::UnwindResult;\n use rt::task::{Task, SchedTask, GreenTask, Sched};\n use rt::uv::uvio::UvEventLoop;\n use unstable::atomics::{AtomicInt, AtomicBool, SeqCst};\n use unstable::sync::UnsafeArc;\n-use vec;\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n+use vec;\n \n use self::thread::Thread;\n use self::work_queue::WorkQueue;\n@@ -343,7 +344,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     // When the main task exits, after all the tasks in the main\n     // task tree, shut down the schedulers and set the exit code.\n     let handles = Cell::new(handles);\n-    let on_exit: ~fn(bool) = |exit_success| {\n+    let on_exit: ~fn(UnwindResult) = |exit_success| {\n         unsafe {\n             assert!(!(*exited_already.get()).swap(true, SeqCst),\n                     \"the runtime already exited\");\n@@ -355,7 +356,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         }\n \n         unsafe {\n-            let exit_code = if exit_success {\n+            let exit_code = if exit_success.is_success() {\n                 use rt::util;\n \n                 // If we're exiting successfully, then return the global"}, {"sha": "d44264befc16f0938e81607d08166f1fef17a663", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -915,14 +915,14 @@ mod test {\n     use rt::test::*;\n     use unstable::run_in_bare_thread;\n     use borrow::to_uint;\n-    use rt::local::*;\n     use rt::sched::{Scheduler};\n     use cell::Cell;\n     use rt::thread::Thread;\n     use rt::task::{Task, Sched};\n     use rt::basic;\n     use rt::util;\n     use option::{Some};\n+    use rt::task::UnwindResult;\n \n     #[test]\n     fn trivial_run_in_newsched_task_test() {\n@@ -1007,7 +1007,7 @@ mod test {\n                 assert!(Task::on_appropriate_sched());\n             };\n \n-            let on_exit: ~fn(bool) = |exit_status| rtassert!(exit_status);\n+            let on_exit: ~fn(UnwindResult) = |exit_status| rtassert!(exit_status.is_success());\n             task.death.on_exit = Some(on_exit);\n \n             sched.bootstrap(task);"}, {"sha": "8f695763a255fcf1455828d1dcdf1d16c3ffcbcf", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 124, "deletions": 50, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -13,29 +13,31 @@\n //! local storage, and logging. Even a 'freestanding' Rust would likely want\n //! to implement this.\n \n+use super::local_heap::LocalHeap;\n+\n+use prelude::*;\n+\n use borrow;\n use cast::transmute;\n+use cell::Cell;\n use cleanup;\n-use local_data;\n use libc::{c_void, uintptr_t, c_char, size_t};\n-use prelude::*;\n+use local_data;\n use option::{Option, Some, None};\n-use rt::borrowck;\n use rt::borrowck::BorrowRecord;\n+use rt::borrowck;\n+use rt::context::Context;\n+use rt::context;\n use rt::env;\n use rt::io::Writer;\n use rt::kill::Death;\n use rt::local::Local;\n use rt::logging::StdErrLogger;\n-use super::local_heap::LocalHeap;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n-use rt::context;\n-use rt::context::Context;\n-use unstable::finally::Finally;\n-use task::spawn::Taskgroup;\n-use cell::Cell;\n use send_str::SendStr;\n+use task::spawn::Taskgroup;\n+use unstable::finally::Finally;\n \n // The Task struct represents all state associated with a rust\n // task. There are at this point two primary \"subtypes\" of task,\n@@ -85,8 +87,61 @@ pub enum SchedHome {\n pub struct GarbageCollector;\n pub struct LocalStorage(Option<local_data::Map>);\n \n+/// Represents the reason for the current unwinding process\n+pub enum UnwindResult {\n+    /// The task is ending successfully\n+    Success,\n+\n+    /// The Task is failing with reason `UnwindReason`\n+    Failure(UnwindReason),\n+}\n+\n+impl UnwindResult {\n+    /// Returns `true` if this `UnwindResult` is a failure\n+    #[inline]\n+    pub fn is_failure(&self) -> bool {\n+        match *self {\n+            Success => false,\n+            Failure(_) => true\n+        }\n+    }\n+\n+    /// Returns `true` if this `UnwindResult` is a success\n+    #[inline]\n+    pub fn is_success(&self) -> bool {\n+        match *self {\n+            Success => true,\n+            Failure(_) => false\n+        }\n+    }\n+}\n+\n+/// Represents the cause of a task failure\n+#[deriving(ToStr)]\n+pub enum UnwindReason {\n+    /// Failed with a string message\n+    UnwindReasonStr(SendStr),\n+\n+    /// Failed with an `~Any`\n+    UnwindReasonAny(~Any),\n+\n+    /// Failed because of linked failure\n+    UnwindReasonLinked\n+}\n+\n pub struct Unwinder {\n     unwinding: bool,\n+    cause: Option<UnwindReason>\n+}\n+\n+impl Unwinder {\n+    fn to_unwind_result(&mut self) -> UnwindResult {\n+        if self.unwinding {\n+            Failure(self.cause.take().unwrap())\n+        } else {\n+            Success\n+        }\n+    }\n }\n \n impl Task {\n@@ -135,7 +190,7 @@ impl Task {\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n             logger: StdErrLogger::new(),\n-            unwinder: Unwinder { unwinding: false },\n+            unwinder: Unwinder { unwinding: false, cause: None },\n             taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n@@ -170,7 +225,7 @@ impl Task {\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n             logger: StdErrLogger::new(),\n-            unwinder: Unwinder { unwinding: false },\n+            unwinder: Unwinder { unwinding: false, cause: None },\n             taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n@@ -193,7 +248,7 @@ impl Task {\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n             logger: StdErrLogger::new(),\n-            unwinder: Unwinder { unwinding: false },\n+            unwinder: Unwinder { unwinding: false, cause: None },\n             taskgroup: None,\n             // FIXME(#7544) make watching optional\n             death: self.death.new_child(),\n@@ -284,7 +339,7 @@ impl Task {\n         // the unkillable counter is set. This is necessary for when the\n         // taskgroup destruction code drops references on KillHandles, which\n         // might require using unkillable (to synchronize with an unwrapper).\n-        self.death.collect_failure(!self.unwinder.unwinding, self.taskgroup.take());\n+        self.death.collect_failure(self.unwinder.to_unwind_result(), self.taskgroup.take());\n         self.destroyed = true;\n     }\n \n@@ -469,10 +524,11 @@ impl Unwinder {\n         }\n     }\n \n-    pub fn begin_unwind(&mut self) -> ! {\n+    pub fn begin_unwind(&mut self, cause: UnwindReason) -> ! {\n         #[fixed_stack_segment]; #[inline(never)];\n \n         self.unwinding = true;\n+        self.cause = Some(cause);\n         unsafe {\n             rust_begin_unwind(UNWIND_TOKEN);\n             return transmute(());\n@@ -561,55 +617,73 @@ pub extern \"C\" fn rust_stack_exhausted() {\n }\n \n /// This is the entry point of unwinding for things like lang items and such.\n-/// The arguments are normally generated by the compiler.\n+/// The arguments are normally generated by the compiler, and need to\n+/// have static lifetimes.\n pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n+    use c_str::CString;\n+    use cast::transmute;\n+\n+    #[inline]\n+    fn static_char_ptr(p: *c_char) -> &'static str {\n+        let s = unsafe { CString::new(p, false) };\n+        match s.as_str() {\n+            Some(s) => unsafe { transmute::<&str, &'static str>(s) },\n+            None => rtabort!(\"message wasn't utf8?\")\n+        }\n+    }\n+\n+    let msg = static_char_ptr(msg);\n+    let file = static_char_ptr(file);\n+\n+    begin_unwind_reason(UnwindReasonStr(msg.into_send_str()), file, line as uint)\n+}\n+\n+/// This is the entry point of unwinding for fail!() and assert!().\n+pub fn begin_unwind_reason(reason: UnwindReason, file: &'static str, line: uint) -> ! {\n     use rt::in_green_task_context;\n     use rt::task::Task;\n     use rt::local::Local;\n     use str::Str;\n-    use c_str::CString;\n     use unstable::intrinsics;\n \n     unsafe {\n-        let msg = CString::new(msg, false);\n-        let file = CString::new(file, false);\n-        let msg = match msg.as_str() {\n-            Some(s) => s, None => rtabort!(\"message wasn't utf8?\")\n-        };\n+        // Be careful not to allocate in this block, if we're failing we may\n+        // have been failing due to a lack of memory in the first place...\n \n-        if !in_green_task_context() {\n-            match file.as_str() {\n-                Some(file) => {\n-                    rterrln!(\"failed in non-task context at '{}', {}:{}\",\n-                             msg, file, line as int);\n-                }\n-                None => rterrln!(\"failed in non-task context at '{}'\", msg)\n+        let task: *mut Task;\n+\n+        {\n+            let msg = match reason {\n+                UnwindReasonStr(ref s) => s.as_slice(),\n+                UnwindReasonAny(_)     => \"~Any\",\n+                UnwindReasonLinked     => \"linked failure\",\n+            };\n+\n+            if !in_green_task_context() {\n+                rterrln!(\"failed in non-task context at '{}', {}:{}\",\n+                        msg, file, line);\n+                intrinsics::abort();\n             }\n-            intrinsics::abort();\n-        }\n \n-        // Be careful not to allocate in this block, if we're failing we may\n-        // have been failing due to a lack of memory in the first place...\n-        let task: *mut Task = Local::unsafe_borrow();\n-        let n = (*task).name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-        // XXX: this should no get forcibly printed to the console, this should\n-        //      either be sent to the parent task (ideally), or get printed to\n-        //      the task's logger. Right now the logger is actually a uvio\n-        //      instance, which uses unkillable blocks internally for various\n-        //      reasons. This will cause serious trouble if the task is failing\n-        //      due to mismanagment of its own kill flag, so calling our own\n-        //      logger in its current state is a bit of a problem.\n-        match file.as_str() {\n-            Some(file) => {\n-                rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg, file, line);\n+            task = Local::unsafe_borrow();\n+            let n = (*task).name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+            // XXX: this should no get forcibly printed to the console, this should\n+            //      either be sent to the parent task (ideally), or get printed to\n+            //      the task's logger. Right now the logger is actually a uvio\n+            //      instance, which uses unkillable blocks internally for various\n+            //      reasons. This will cause serious trouble if the task is failing\n+            //      due to mismanagment of its own kill flag, so calling our own\n+            //      logger in its current state is a bit of a problem.\n+\n+            rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg, file, line);\n+\n+            if (*task).unwinder.unwinding {\n+                rtabort!(\"unwinding again\");\n             }\n-            None => rterrln!(\"task '{}' failed at '{}'\", n, msg),\n         }\n-        if (*task).unwinder.unwinding {\n-            rtabort!(\"unwinding again\");\n-        }\n-        (*task).unwinder.begin_unwind();\n+\n+        (*task).unwinder.begin_unwind(reason);\n     }\n }\n "}, {"sha": "5f78b9fc9591e95d62f1997a068c1f91a5db3af8", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -8,30 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rand;\n-use rand::Rng;\n-use os;\n-use libc;\n-use option::{Some, None};\n-use path::Path;\n+use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n+\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iter::{Iterator, range};\n-use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n-use vec::{OwnedVector, MutableVector, ImmutableVector};\n+use libc;\n+use option::{Some, None};\n+use os;\n use path::GenericPath;\n+use path::Path;\n+use rand::Rng;\n+use rand;\n+use result::{Result, Ok, Err};\n use rt::basic;\n-use rt::sched::Scheduler;\n+use rt::comm::oneshot;\n use rt::rtio::EventLoop;\n-use unstable::{run_in_bare_thread};\n-use rt::thread::Thread;\n+use rt::sched::Scheduler;\n+use rt::sleeper_list::SleeperList;\n use rt::task::Task;\n+use rt::task::UnwindResult;\n+use rt::thread::Thread;\n use rt::uv::uvio::UvEventLoop;\n use rt::work_queue::WorkQueue;\n-use rt::sleeper_list::SleeperList;\n-use rt::comm::oneshot;\n-use result::{Result, Ok, Err};\n+use unstable::{run_in_bare_thread};\n+use vec::{OwnedVector, MutableVector, ImmutableVector};\n \n pub fn new_test_uv_sched() -> Scheduler {\n \n@@ -85,9 +87,9 @@ pub fn run_in_uv_task_core(f: ~fn()) {\n     let mut sched = ~new_test_uv_sched();\n     let exit_handle = Cell::new(sched.make_handle());\n \n-    let on_exit: ~fn(bool) = |exit_status| {\n+    let on_exit: ~fn(UnwindResult) = |exit_status| {\n         exit_handle.take().send(Shutdown);\n-        rtassert!(exit_status);\n+        rtassert!(exit_status.is_success());\n     };\n     let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n     task.death.on_exit = Some(on_exit);\n@@ -96,15 +98,14 @@ pub fn run_in_uv_task_core(f: ~fn()) {\n }\n \n pub fn run_in_newsched_task_core(f: ~fn()) {\n-\n     use rt::sched::Shutdown;\n \n     let mut sched = ~new_test_sched();\n     let exit_handle = Cell::new(sched.make_handle());\n \n-    let on_exit: ~fn(bool) = |exit_status| {\n+    let on_exit: ~fn(UnwindResult) = |exit_status| {\n         exit_handle.take().send(Shutdown);\n-        rtassert!(exit_status);\n+        rtassert!(exit_status.is_success());\n     };\n     let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n     task.death.on_exit = Some(on_exit);\n@@ -248,14 +249,14 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         let handles = Cell::new(handles);\n-        let on_exit: ~fn(bool) = |exit_status| {\n+        let on_exit: ~fn(UnwindResult) = |exit_status| {\n             let mut handles = handles.take();\n             // Tell schedulers to exit\n             for handle in handles.mut_iter() {\n                 handle.send(Shutdown);\n             }\n \n-            rtassert!(exit_status);\n+            rtassert!(exit_status.is_success());\n         };\n         let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, None, f.take());\n         main_task.death.on_exit = Some(on_exit);\n@@ -323,15 +324,15 @@ pub fn spawntask_try(f: ~fn()) -> Result<(),()> {\n \n     let (port, chan) = oneshot();\n     let chan = Cell::new(chan);\n-    let on_exit: ~fn(bool) = |exit_status| chan.take().send(exit_status);\n+    let on_exit: ~fn(UnwindResult) = |exit_status| chan.take().send(exit_status);\n \n     let mut new_task = Task::build_root(None, f);\n     new_task.death.on_exit = Some(on_exit);\n \n     Scheduler::run_task(new_task);\n \n     let exit_status = port.recv();\n-    if exit_status { Ok(()) } else { Err(()) }\n+    if exit_status.is_success() { Ok(()) } else { Err(()) }\n \n }\n "}, {"sha": "5643f6445f16f6a198182ae170834f106fbded53", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -1899,6 +1899,7 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n     use rt::thread::Thread;\n     use rt::task::Task;\n     use rt::sched::{Shutdown, TaskFromFriend};\n+    use rt::task::UnwindResult;\n     do run_in_bare_thread {\n         let sleepers = SleeperList::new();\n         let work_queue1 = WorkQueue::new();\n@@ -1916,10 +1917,10 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n         let handle2 = Cell::new(sched2.make_handle());\n         let tasksFriendHandle = Cell::new(sched2.make_handle());\n \n-        let on_exit: ~fn(bool) = |exit_status| {\n+        let on_exit: ~fn(UnwindResult) = |exit_status| {\n             handle1.take().send(Shutdown);\n             handle2.take().send(Shutdown);\n-            rtassert!(exit_status);\n+            rtassert!(exit_status.is_success());\n         };\n \n         let test_function: ~fn() = || {\n@@ -1978,6 +1979,7 @@ fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n     use rt::task::Task;\n     use rt::comm::oneshot;\n     use rt::sched::Shutdown;\n+    use rt::task::UnwindResult;\n     do run_in_bare_thread {\n         let sleepers = SleeperList::new();\n         let work_queue1 = WorkQueue::new();\n@@ -2017,10 +2019,10 @@ fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n              */\n         };\n \n-        let on_exit: ~fn(bool) = |exit| {\n+        let on_exit: ~fn(UnwindResult) = |exit| {\n             handle1.take().send(Shutdown);\n             handle2.take().send(Shutdown);\n-            rtassert!(exit);\n+            rtassert!(exit.is_success());\n         };\n \n         let task1 = Cell::new(~Task::new_root(&mut sched1.stack_pool, None, body1));\n@@ -2088,6 +2090,7 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n     use rt::thread::Thread;\n     use rt::task::Task;\n     use rt::sched::{Shutdown};\n+    use rt::task::UnwindResult;\n     do run_in_bare_thread {\n         let sleepers = SleeperList::new();\n \n@@ -2108,14 +2111,14 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         let server_handle = Cell::new(server_sched.make_handle());\n         let client_handle = Cell::new(client_sched.make_handle());\n \n-        let server_on_exit: ~fn(bool) = |exit_status| {\n+        let server_on_exit: ~fn(UnwindResult) = |exit_status| {\n             server_handle.take().send(Shutdown);\n-            rtassert!(exit_status);\n+            rtassert!(exit_status.is_success());\n         };\n \n-        let client_on_exit: ~fn(bool) = |exit_status| {\n+        let client_on_exit: ~fn(UnwindResult) = |exit_status| {\n             client_handle.take().send(Shutdown);\n-            rtassert!(exit_status);\n+            rtassert!(exit_status.is_success());\n         };\n \n         let server_fn: ~fn() = || {"}, {"sha": "6e7d681d40a0564e673a5cae06ba2fc42cc399eb", "filename": "src/libstd/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -426,7 +426,7 @@ mod tests {\n         os::close(pipe_err.out);\n \n         do spawn {\n-            writeclose(pipe_in.out, ~\"test\");\n+            writeclose(pipe_in.out, \"test\");\n         }\n         let actual = readclose(pipe_out.input);\n         readclose(pipe_err.input);"}, {"sha": "069a390f0103e8e4f8fe774bdba54dc2d0bfffc3", "filename": "src/libstd/std.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -151,6 +151,7 @@ pub mod clone;\n pub mod hash;\n pub mod container;\n pub mod default;\n+pub mod any;\n \n /* Common data structures */\n \n@@ -213,15 +214,16 @@ mod std {\n     pub use clone;\n     pub use cmp;\n     pub use condition;\n-    pub use option;\n+    pub use fmt;\n     pub use kinds;\n     pub use local_data;\n     pub use logging;\n-    pub use sys;\n-    pub use unstable;\n-    pub use str;\n+    pub use logging;\n+    pub use option;\n     pub use os;\n-    pub use fmt;\n+    pub use str;\n+    pub use sys;\n     pub use to_bytes;\n-    pub use logging;\n+    pub use to_str;\n+    pub use unstable;\n }"}, {"sha": "b35b25aeb6f727e22bc6c31bb49489f729cdf132", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -12,41 +12,55 @@\n \n #[allow(missing_doc)];\n \n-use c_str::ToCStr;\n-use libc::size_t;\n-use libc;\n+use any::Any;\n+use kinds::Send;\n+use rt::task::{UnwindReasonStr, UnwindReasonAny};\n use rt::task;\n+use send_str::{SendStr, IntoSendStr};\n \n-/// Trait for initiating task failure.\n+/// Trait for initiating task failure with a sendable cause.\n pub trait FailWithCause {\n-    /// Fail the current task, taking ownership of `cause`\n+    /// Fail the current task with `cause`.\n     fn fail_with(cause: Self, file: &'static str, line: uint) -> !;\n }\n \n impl FailWithCause for ~str {\n     fn fail_with(cause: ~str, file: &'static str, line: uint) -> ! {\n-        do cause.with_c_str |msg_buf| {\n-            do file.with_c_str |file_buf| {\n-                task::begin_unwind(msg_buf, file_buf, line as libc::size_t)\n-            }\n-        }\n+        task::begin_unwind_reason(UnwindReasonStr(cause.into_send_str()), file, line)\n     }\n }\n \n impl FailWithCause for &'static str {\n     fn fail_with(cause: &'static str, file: &'static str, line: uint) -> ! {\n-        do cause.with_c_str |msg_buf| {\n-            do file.with_c_str |file_buf| {\n-                task::begin_unwind(msg_buf, file_buf, line as libc::size_t)\n-            }\n-        }\n+        task::begin_unwind_reason(UnwindReasonStr(cause.into_send_str()), file, line)\n+    }\n+}\n+\n+impl FailWithCause for SendStr {\n+    fn fail_with(cause: SendStr, file: &'static str, line: uint) -> ! {\n+        task::begin_unwind_reason(UnwindReasonStr(cause), file, line)\n+    }\n+}\n+\n+impl FailWithCause for ~Any {\n+    fn fail_with(cause: ~Any, file: &'static str, line: uint) -> ! {\n+        task::begin_unwind_reason(UnwindReasonAny(cause), file, line)\n+    }\n+}\n+\n+impl<T: Any + Send + 'static> FailWithCause for ~T {\n+    fn fail_with(cause: ~T, file: &'static str, line: uint) -> ! {\n+        task::begin_unwind_reason(UnwindReasonAny(cause as ~Any), file, line)\n     }\n }\n \n #[cfg(test)]\n mod tests {\n+    use super::*;\n+\n+    use any::Any;\n     use cast;\n-    use sys::*;\n+    use send_str::IntoSendStr;\n \n     #[test]\n     fn synthesize_closure() {\n@@ -74,9 +88,21 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn fail_static() { FailWithCause::fail_with(\"cause\", file!(), line!())  }\n+    fn fail_static() { FailWithCause::fail_with(\"cause\", file!(), line!()) }\n+\n+    #[test]\n+    #[should_fail]\n+    fn fail_owned() { FailWithCause::fail_with(~\"cause\", file!(), line!()) }\n+\n+    #[test]\n+    #[should_fail]\n+    fn fail_send() { FailWithCause::fail_with(\"cause\".into_send_str(), file!(), line!()) }\n+\n+    #[test]\n+    #[should_fail]\n+    fn fail_any() { FailWithCause::fail_with(~612_u16 as ~Any, file!(), line!()) }\n \n     #[test]\n     #[should_fail]\n-    fn fail_owned() { FailWithCause::fail_with(~\"cause\", file!(), line!())  }\n+    fn fail_any_wrap() { FailWithCause::fail_with(~413_u16, file!(), line!()) }\n }"}, {"sha": "3333b24a924d2536279aa2698e53d548463e90ff", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 125, "deletions": 40, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -56,38 +56,68 @@\n use prelude::*;\n \n use cell::Cell;\n-use comm::{stream, Chan, GenericChan, GenericPort, Port};\n-use result::Result;\n-use result;\n+use comm::{stream, Chan, GenericChan, GenericPort, Port, Peekable};\n+use result::{Result, Ok, Err};\n use rt::in_green_task_context;\n use rt::local::Local;\n+use rt::task::{UnwindReasonAny, UnwindReasonLinked, UnwindReasonStr};\n+use rt::task::{UnwindResult, Success, Failure};\n+use send_str::{SendStr, IntoSendStr};\n use unstable::finally::Finally;\n use util;\n-use send_str::{SendStr, IntoSendStr};\n \n+#[cfg(test)] use any::Any;\n #[cfg(test)] use cast;\n #[cfg(test)] use comm::SharedChan;\n #[cfg(test)] use comm;\n #[cfg(test)] use ptr;\n+#[cfg(test)] use result;\n #[cfg(test)] use task;\n \n pub mod spawn;\n \n-/**\n- * Indicates the manner in which a task exited.\n- *\n- * A task that completes without failing is considered to exit successfully.\n- * Supervised ancestors and linked siblings may yet fail after this task\n- * succeeds. Also note that in such a case, it may be nondeterministic whether\n- * linked failure or successful exit happen first.\n- *\n- * If you wish for this result's delivery to block until all linked and/or\n- * children tasks complete, recommend using a result future.\n- */\n-#[deriving(Eq)]\n-pub enum TaskResult {\n-    Success,\n-    Failure,\n+/// Indicates the manner in which a task exited.\n+///\n+/// A task that completes without failing is considered to exit successfully.\n+/// Supervised ancestors and linked siblings may yet fail after this task\n+/// succeeds. Also note that in such a case, it may be nondeterministic whether\n+/// linked failure or successful exit happen first.\n+///\n+/// If you wish for this result's delivery to block until all linked and/or\n+/// children tasks complete, recommend using a result future.\n+pub type TaskResult = Result<(), ~Any>;\n+\n+pub struct LinkedFailure;\n+\n+#[inline]\n+fn wrap_as_any(res: UnwindResult) -> TaskResult {\n+    match res {\n+        Success => Ok(()),\n+        Failure(UnwindReasonStr(s)) => Err(~s as ~Any),\n+        Failure(UnwindReasonAny(a)) => Err(a),\n+        Failure(UnwindReasonLinked) => Err(~LinkedFailure as ~Any)\n+    }\n+}\n+\n+pub struct TaskResultPort {\n+    priv port: Port<UnwindResult>\n+}\n+\n+impl GenericPort<TaskResult> for TaskResultPort {\n+    #[inline]\n+    fn recv(&self) -> TaskResult {\n+        wrap_as_any(self.port.recv())\n+    }\n+\n+    #[inline]\n+    fn try_recv(&self) -> Option<TaskResult> {\n+        self.port.try_recv().map(wrap_as_any)\n+    }\n+}\n+\n+impl Peekable<TaskResult> for TaskResultPort {\n+    #[inline]\n+    fn peek(&self) -> bool { self.port.peek() }\n }\n \n /// Scheduler modes\n@@ -148,7 +178,7 @@ pub struct TaskOpts {\n     priv supervised: bool,\n     priv watched: bool,\n     priv indestructible: bool,\n-    priv notify_chan: Option<Chan<TaskResult>>,\n+    priv notify_chan: Option<Chan<UnwindResult>>,\n     name: Option<SendStr>,\n     sched: SchedOpts,\n     stack_size: Option<uint>\n@@ -273,7 +303,7 @@ impl TaskBuilder {\n     ///\n     /// # Failure\n     /// Fails if a future_result was already set for this task.\n-    pub fn future_result(&mut self) -> Port<TaskResult> {\n+    pub fn future_result(&mut self) -> TaskResultPort {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -284,12 +314,12 @@ impl TaskBuilder {\n         }\n \n         // Construct the future and give it to the caller.\n-        let (notify_pipe_po, notify_pipe_ch) = stream::<TaskResult>();\n+        let (notify_pipe_po, notify_pipe_ch) = stream::<UnwindResult>();\n \n         // Reconfigure self to use a notify channel.\n         self.opts.notify_chan = Some(notify_pipe_ch);\n \n-        notify_pipe_po\n+        TaskResultPort { port: notify_pipe_po }\n     }\n \n     /// Name the task-to-be. Currently the name is used for identification\n@@ -394,7 +424,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    pub fn try<T:Send>(&mut self, f: ~fn() -> T) -> Result<T,()> {\n+    pub fn try<T:Send>(&mut self, f: ~fn() -> T) -> Result<T, ~Any> {\n         let (po, ch) = stream::<T>();\n \n         let result = self.future_result();\n@@ -404,8 +434,8 @@ impl TaskBuilder {\n         }\n \n         match result.recv() {\n-            Success => result::Ok(po.recv()),\n-            Failure => result::Err(())\n+            Ok(())     => Ok(po.recv()),\n+            Err(cause) => Err(cause)\n         }\n     }\n }\n@@ -512,7 +542,7 @@ pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n     task.spawn(f)\n }\n \n-pub fn try<T:Send>(f: ~fn() -> T) -> Result<T,()> {\n+pub fn try<T:Send>(f: ~fn() -> T) -> Result<T, ~Any> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -769,7 +799,7 @@ fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n fn test_spawn_unlinked_sup_fail_down() {\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             do spawn_supervised { block_forever(); }\n             fail!(); // Shouldn't leave a child hanging around.\n         };\n@@ -782,7 +812,7 @@ fn test_spawn_unlinked_sup_fail_down() {\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n             // We have to cheat with opts - the interface doesn't support them because\n             // they don't make sense (redundant with task().supervised()).\n@@ -803,7 +833,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // We have to cheat with opts - the interface doesn't support them because\n             // they don't make sense (redundant with task().supervised()).\n             let mut b0 = task();\n@@ -820,7 +850,7 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // Default options are to spawn linked & unsupervised.\n             do spawn { fail!(); }\n             block_forever(); // We should get punted awake\n@@ -833,7 +863,7 @@ fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // Default options are to spawn linked & unsupervised.\n             do spawn { block_forever(); }\n             fail!();\n@@ -846,7 +876,7 @@ fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // Make sure the above test is the same as this one.\n             let mut builder = task();\n             builder.linked();\n@@ -865,7 +895,7 @@ fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n fn test_spawn_failure_propagate_grandchild() {\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // Middle task exits; does grandparent's failure propagate across the gap?\n             do spawn_supervised {\n                 do spawn_supervised { block_forever(); }\n@@ -882,7 +912,7 @@ fn test_spawn_failure_propagate_grandchild() {\n fn test_spawn_failure_propagate_secondborn() {\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // First-born child exits; does parent's failure propagate to sibling?\n             do spawn_supervised {\n                 do spawn { block_forever(); } // linked\n@@ -899,7 +929,7 @@ fn test_spawn_failure_propagate_secondborn() {\n fn test_spawn_failure_propagate_nephew_or_niece() {\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // Our sibling exits; does our failure propagate to sibling's child?\n             do spawn { // linked\n                 do spawn_supervised { block_forever(); }\n@@ -916,7 +946,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n fn test_spawn_linked_sup_propagate_sibling() {\n     use rt::test::run_in_uv_task;\n     do run_in_uv_task {\n-        let result: Result<(),()> = do try {\n+        let result: Result<(), ~Any> = do try {\n             // Middle sibling exits - does eldest's failure propagate to youngest?\n             do spawn { // linked\n                 do spawn { block_forever(); } // linked\n@@ -1024,15 +1054,15 @@ fn test_future_result() {\n     let mut builder = task();\n     let result = builder.future_result();\n     do builder.spawn {}\n-    assert_eq!(result.recv(), Success);\n+    assert!(result.recv().is_ok());\n \n     let mut builder = task();\n     let result = builder.future_result();\n     builder.unlinked();\n     do builder.spawn {\n         fail!();\n     }\n-    assert_eq!(result.recv(), Failure);\n+    assert!(result.recv().is_err());\n }\n \n #[test] #[should_fail]\n@@ -1057,7 +1087,7 @@ fn test_try_fail() {\n     match do try {\n         fail!()\n     } {\n-        result::Err(()) => (),\n+        result::Err(_) => (),\n         result::Ok(()) => fail!()\n     }\n }\n@@ -1393,3 +1423,58 @@ fn test_indestructible() {\n         assert!(result.is_ok());\n     }\n }\n+\n+#[test]\n+fn test_try_fail_cause_static_str() {\n+    match do try {\n+        fail!(\"static string\");\n+    } {\n+        Err(ref e) if e.is::<SendStr>() => {}\n+        Err(_) | Ok(()) => fail!()\n+    }\n+}\n+\n+#[test]\n+fn test_try_fail_cause_owned_str() {\n+    match do try {\n+        fail!(~\"owned string\");\n+    } {\n+        Err(ref e) if e.is::<SendStr>() => {}\n+        Err(_) | Ok(()) => fail!()\n+    }\n+}\n+\n+#[test]\n+fn test_try_fail_cause_any() {\n+    match do try {\n+        fail!(~413u16 as ~Any);\n+    } {\n+        Err(ref e) if e.is::<u16>() => {}\n+        Err(_) | Ok(()) => fail!()\n+    }\n+}\n+\n+#[ignore(reason = \"linked failure\")]\n+#[test]\n+fn test_try_fail_cause_linked() {\n+    match do try {\n+        do spawn {\n+            fail!()\n+        }\n+    } {\n+        Err(ref e) if e.is::<LinkedFailure>() => {}\n+        Err(_) | Ok(()) => fail!()\n+    }\n+}\n+\n+#[test]\n+fn test_try_fail_cause_any_wrapped() {\n+    struct Juju;\n+\n+    match do try {\n+        fail!(~Juju)\n+    } {\n+        Err(ref e) if e.is::<Juju>() => {}\n+        Err(_) | Ok(()) => fail!()\n+    }\n+}"}, {"sha": "235e67048f678738cfd63c5a037ee070594b6c23", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -76,21 +76,24 @@ use prelude::*;\n use cast::transmute;\n use cast;\n use cell::Cell;\n-use container::MutableMap;\n use comm::{Chan, GenericChan, oneshot};\n+use container::MutableMap;\n use hashmap::{HashSet, HashSetMoveIterator};\n use local_data;\n-use task::{Failure, SingleThreaded};\n-use task::{Success, TaskOpts, TaskResult};\n-use task::unkillable;\n-use uint;\n-use util;\n-use unstable::sync::Exclusive;\n use rt::in_green_task_context;\n use rt::local::Local;\n-use rt::task::{Task, Sched};\n use rt::shouldnt_be_public::{Scheduler, KillHandle, WorkQueue, Thread, EventLoop};\n+use rt::task::{Task, Sched};\n+use rt::task::{UnwindReasonLinked, UnwindReasonStr};\n+use rt::task::{UnwindResult, Success, Failure};\n use rt::uv::uvio::UvEventLoop;\n+use send_str::IntoSendStr;\n+use task::SingleThreaded;\n+use task::TaskOpts;\n+use task::unkillable;\n+use uint;\n+use unstable::sync::Exclusive;\n+use util;\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n@@ -321,7 +324,7 @@ impl Drop for Taskgroup {\n         do RuntimeGlue::with_task_handle_and_failing |me, failing| {\n             if failing {\n                 for x in self.notifier.mut_iter() {\n-                    x.failed = true;\n+                    x.task_result = Some(Failure(UnwindReasonLinked));\n                 }\n                 // Take everybody down with us. After this point, every\n                 // other task in the group will see 'tg' as none, which\n@@ -353,7 +356,7 @@ pub fn Taskgroup(tasks: TaskGroupArc,\n        ancestors: AncestorList,\n        mut notifier: Option<AutoNotify>) -> Taskgroup {\n     for x in notifier.mut_iter() {\n-        x.failed = false;\n+        x.task_result = Some(Success);\n     }\n \n     Taskgroup {\n@@ -364,21 +367,28 @@ pub fn Taskgroup(tasks: TaskGroupArc,\n }\n \n struct AutoNotify {\n-    notify_chan: Chan<TaskResult>,\n-    failed: bool,\n+    notify_chan: Chan<UnwindResult>,\n+\n+    // XXX: By value self drop would allow this to be a plain UnwindResult\n+    task_result: Option<UnwindResult>,\n }\n \n-impl Drop for AutoNotify {\n-    fn drop(&mut self) {\n-        let result = if self.failed { Failure } else { Success };\n-        self.notify_chan.send(result);\n+impl AutoNotify {\n+    pub fn new(chan: Chan<UnwindResult>) -> AutoNotify {\n+        AutoNotify {\n+            notify_chan: chan,\n+\n+            // Un-set above when taskgroup successfully made.\n+            task_result: Some(Failure(UnwindReasonStr(\"AutoNotify::new()\".into_send_str())))\n+        }\n     }\n }\n \n-fn AutoNotify(chan: Chan<TaskResult>) -> AutoNotify {\n-    AutoNotify {\n-        notify_chan: chan,\n-        failed: true // Un-set above when taskgroup successfully made.\n+impl Drop for AutoNotify {\n+    fn drop(&mut self) {\n+        let result = self.task_result.take_unwrap();\n+\n+        self.notify_chan.send(result);\n     }\n }\n \n@@ -675,10 +685,8 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n     if opts.notify_chan.is_some() {\n         let notify_chan = opts.notify_chan.take_unwrap();\n         let notify_chan = Cell::new(notify_chan);\n-        let on_exit: ~fn(bool) = |success| {\n-            notify_chan.take().send(\n-                if success { Success } else { Failure }\n-            )\n+        let on_exit: ~fn(UnwindResult) = |task_result| {\n+            notify_chan.take().send(task_result)\n         };\n         task.death.on_exit = Some(on_exit);\n     }\n@@ -721,7 +729,7 @@ fn test_spawn_raw_notify_success() {\n     };\n     do spawn_raw(opts) {\n     }\n-    assert_eq!(notify_po.recv(), Success);\n+    assert!(notify_po.recv().is_success());\n }\n \n #[test]\n@@ -738,5 +746,5 @@ fn test_spawn_raw_notify_failure() {\n     do spawn_raw(opts) {\n         fail!();\n     }\n-    assert_eq!(notify_po.recv(), Failure);\n+    assert!(notify_po.recv().is_failure());\n }"}, {"sha": "28cebfb6146000c64628ae2bc8b4a9054dbf9aaa", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -14,7 +14,6 @@ use comm;\n use libc;\n use ptr;\n use option::*;\n-use either::{Either, Left, Right};\n use task;\n use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,Relaxed,SeqCst};\n use unstable::finally::Finally;\n@@ -31,6 +30,27 @@ pub struct UnsafeArc<T> {\n     data: *mut ArcData<T>,\n }\n \n+pub enum UnsafeArcUnwrap<T> {\n+    UnsafeArcSelf(UnsafeArc<T>),\n+    UnsafeArcT(T)\n+}\n+\n+impl<T> UnsafeArcUnwrap<T> {\n+    fn expect_t(self, msg: &'static str) -> T {\n+        match self {\n+            UnsafeArcSelf(_) => fail!(msg),\n+            UnsafeArcT(t) => t\n+        }\n+    }\n+\n+    fn is_self(&self) -> bool {\n+        match *self {\n+            UnsafeArcSelf(_) => true,\n+            UnsafeArcT(_) => false\n+        }\n+    }\n+}\n+\n struct ArcData<T> {\n     count: AtomicUint,\n     // An unwrapper uses this protocol to communicate with the \"other\" task that\n@@ -178,9 +198,9 @@ impl<T: Send> UnsafeArc<T> {\n         }\n     }\n \n-    /// As unwrap above, but without blocking. Returns 'Left(self)' if this is\n-    /// not the last reference; 'Right(unwrapped_data)' if so.\n-    pub fn try_unwrap(self) -> Either<UnsafeArc<T>, T> {\n+    /// As unwrap above, but without blocking. Returns 'UnsafeArcSelf(self)' if this is\n+    /// not the last reference; 'UnsafeArcT(unwrapped_data)' if so.\n+    pub fn try_unwrap(self) -> UnsafeArcUnwrap<T> {\n         unsafe {\n             let mut this = self; // FIXME(#4330) mutable self\n             // The ~ dtor needs to run if this code succeeds.\n@@ -198,10 +218,10 @@ impl<T: Send> UnsafeArc<T> {\n                 // Tell this handle's destructor not to run (we are now it).\n                 this.data = ptr::mut_null();\n                 // FIXME(#3224) as above\n-                Right(data.data.take_unwrap())\n+                UnsafeArcT(data.data.take_unwrap())\n             } else {\n                 cast::forget(data);\n-                Left(this)\n+                UnsafeArcSelf(this)\n             }\n         }\n     }\n@@ -574,17 +594,17 @@ mod tests {\n     #[test]\n     fn arclike_try_unwrap() {\n         let x = UnsafeArc::new(~~\"hello\");\n-        assert!(x.try_unwrap().expect_right(\"try_unwrap failed\") == ~~\"hello\");\n+        assert!(x.try_unwrap().expect_t(\"try_unwrap failed\") == ~~\"hello\");\n     }\n \n     #[test]\n     fn arclike_try_unwrap_fail() {\n         let x = UnsafeArc::new(~~\"hello\");\n         let x2 = x.clone();\n         let left_x = x.try_unwrap();\n-        assert!(left_x.is_left());\n+        assert!(left_x.is_self());\n         util::ignore(left_x);\n-        assert!(x2.try_unwrap().expect_right(\"try_unwrap none\") == ~~\"hello\");\n+        assert!(x2.try_unwrap().expect_t(\"try_unwrap none\") == ~~\"hello\");\n     }\n \n     #[test]\n@@ -601,7 +621,7 @@ mod tests {\n         p.recv();\n         task::deschedule(); // Try to make the unwrapper get blocked first.\n         let left_x = x.try_unwrap();\n-        assert!(left_x.is_left());\n+        assert!(left_x.is_self());\n         util::ignore(left_x);\n         p.recv();\n     }\n@@ -649,7 +669,7 @@ mod tests {\n             assert!(x2.unwrap() == ~~\"hello\");\n         }\n         assert!(x.unwrap() == ~~\"hello\");\n-        assert!(res.recv() == task::Success);\n+        assert!(res.recv().is_ok());\n     }\n \n     #[test]"}, {"sha": "54a05c7257e830a06ae0bf97279eaf43f9dd56cf", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -60,7 +60,7 @@ fn spawn_supervised_blocking(myname: &str, f: ~fn()) {\n     builder.spawn(f);\n     error!(\"{} group waiting\", myname);\n     let x = res.recv();\n-    assert_eq!(x, task::Success);\n+    assert!(x.is_ok());\n }\n \n fn main() {\n@@ -78,7 +78,7 @@ fn main() {\n     // Main group #0 waits for unsupervised group #1.\n     // Grandparent group #1 waits for middle group #2, then fails, killing #3.\n     // Middle group #2 creates grandchild_group #3, waits for it to be ready, exits.\n-    let x: result::Result<(),()> = do task::try { // unlinked\n+    let x: result::Result<(), ~Any> = do task::try { // unlinked\n         do spawn_supervised_blocking(\"grandparent\") {\n             do spawn_supervised_blocking(\"middle\") {\n                 grandchild_group(num_tasks);"}, {"sha": "5a3dda88f705add36bc843200bb02ef47057eb21", "filename": "src/test/run-fail/fail-macro-any-wrapped.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Frun-fail%2Ffail-macro-any-wrapped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Frun-fail%2Ffail-macro-any-wrapped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-any-wrapped.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:failed at '~Any'\n+\n+fn main() {\n+    fail!(~612_i64);\n+}"}, {"sha": "58f3522ce7a975f621583258dd6b2eacfdf26233", "filename": "src/test/run-fail/fail-macro-any.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:failed at '~Any'\n+\n+fn main() {\n+    fail!(~413 as ~Any);\n+}"}, {"sha": "2047fde150b9a71800a9cdbe91a1c9bd3c1194ea", "filename": "src/test/run-fail/fail-macro-send_str.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Frun-fail%2Ffail-macro-send_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Frun-fail%2Ffail-macro-send_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-send_str.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:failed at 'test-fail-send-str'\n+\n+fn main() {\n+    fail!(\"test-fail-send-str\".into_send_str());\n+}"}, {"sha": "8d4680436a42311f7272a302bfacfbb4fe05b82f", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=fa8e71a8257f4226ab532d4bf268d3ecbfa98eb4", "patch": "@@ -24,5 +24,7 @@ pub fn main() {\n     let x = do task::try {\n         let _b = Foo;\n     };\n-    assert_eq!(x, Err(()));\n+\n+    let s = x.unwrap_err().move::<SendStr>().unwrap();\n+    assert_eq!(s.as_slice(), \"This failure should happen.\");\n }"}]}