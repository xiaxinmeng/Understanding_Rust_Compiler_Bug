{"sha": "9be29712748cf8d723d190f9e99442cebbe1fd94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZTI5NzEyNzQ4Y2Y4ZDcyM2QxOTBmOWU5OTQ0MmNlYmJlMWZkOTQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-01-10T23:06:23Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-01-10T23:06:23Z"}, "message": "Refactor pairs/binops", "tree": {"sha": "94b9bf3382659e0d389d33410cc9abd45064cb0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94b9bf3382659e0d389d33410cc9abd45064cb0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be29712748cf8d723d190f9e99442cebbe1fd94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be29712748cf8d723d190f9e99442cebbe1fd94", "html_url": "https://github.com/rust-lang/rust/commit/9be29712748cf8d723d190f9e99442cebbe1fd94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be29712748cf8d723d190f9e99442cebbe1fd94/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e2fcc27e1b359efbdcc16b0aaabe6f7e09d8b4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e2fcc27e1b359efbdcc16b0aaabe6f7e09d8b4a", "html_url": "https://github.com/rust-lang/rust/commit/7e2fcc27e1b359efbdcc16b0aaabe6f7e09d8b4a"}], "stats": {"total": 296, "additions": 116, "deletions": 180}, "files": [{"sha": "3271cc3f2998775d44534155c42ad2bf5cdfffed", "filename": "src/expr.rs", "status": "modified", "additions": 98, "deletions": 159, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/9be29712748cf8d723d190f9e99442cebbe1fd94/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be29712748cf8d723d190f9e99442cebbe1fd94/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=9be29712748cf8d723d190f9e99442cebbe1fd94", "patch": "@@ -80,7 +80,15 @@ fn format_expr(expr: &ast::Expr,\n         }\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n         ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n-            rewrite_binary_op(context, op, lhs, rhs, width, offset)\n+            // FIXME: format comments between operands and operator\n+            rewrite_pair(&**lhs,\n+                         &**rhs,\n+                         \"\",\n+                         &format!(\" {} \", context.snippet(op.span)),\n+                         \"\",\n+                         context,\n+                         width,\n+                         offset)\n         }\n         ast::ExprKind::Unary(ref op, ref subexpr) => {\n             rewrite_unary_op(context, op, subexpr, width, offset)\n@@ -216,15 +224,14 @@ fn format_expr(expr: &ast::Expr,\n             rewrite_pair(&**expr, &**ty, \"\", \": \", \"\", context, width, offset)\n         }\n         ast::ExprKind::Index(ref expr, ref index) => {\n-            let use_spaces = context.config.spaces_within_square_brackets;\n-            let lbr = if use_spaces { \"[ \" } else { \"[\" };\n-            let rbr = if use_spaces { \" ]\" } else { \"]\" };\n-            rewrite_pair(&**expr, &**index, \"\", lbr, rbr, context, width, offset)\n+            rewrite_index(&**expr, &**index, context, width, offset)\n         }\n         ast::ExprKind::Repeat(ref expr, ref repeats) => {\n-            let use_spaces = context.config.spaces_within_square_brackets;\n-            let lbr = if use_spaces { \"[ \" } else { \"[\" };\n-            let rbr = if use_spaces { \" ]\" } else { \"]\" };\n+            let (lbr, rbr) = if context.config.spaces_within_square_brackets {\n+                (\"[ \", \" ]\")\n+            } else {\n+                (\"[\", \"]\")\n+            };\n             rewrite_pair(&**expr, &**repeats, lbr, \"; \", rbr, context, width, offset)\n         }\n         ast::ExprKind::Range(ref lhs, ref rhs, limits) => {\n@@ -286,29 +293,63 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n     where LHS: Rewrite,\n           RHS: Rewrite\n {\n-    let max_width = try_opt!(width.checked_sub(prefix.len() + infix.len() + suffix.len()));\n+    let lhs_budget = try_opt!(width.checked_sub(prefix.len() + infix.len()));\n+    let rhs_budget = try_opt!(width.checked_sub(suffix.len()));\n \n-    binary_search(1, max_width, |lhs_budget| {\n-        let lhs_offset = offset + prefix.len();\n-        let lhs_str = match lhs.rewrite(context, lhs_budget, lhs_offset) {\n-            Some(result) => result,\n-            None => return Err(Ordering::Greater),\n-        };\n+    // Get \"full width\" rhs and see if it fits on the current line. This\n+    // usually works fairly well since it tends to place operands of\n+    // operations with high precendence close together.\n+    // Note that this is non-conservative, but its just to see if it's even\n+    // worth trying to put everything on one line.\n+    let rhs_result = rhs.rewrite(context, rhs_budget, offset);\n \n-        let last_line_width = last_line_width(&lhs_str);\n-        let rhs_budget = match max_width.checked_sub(last_line_width) {\n-            Some(b) => b,\n-            None => return Err(Ordering::Less),\n-        };\n-        let rhs_indent = offset + last_line_width + prefix.len() + infix.len();\n+    if let Some(rhs_result) = rhs_result {\n+        // This is needed in case of line break not caused by a\n+        // shortage of space, but by end-of-line comments, for example.\n+        if !rhs_result.contains('\\n') {\n+            let lhs_result = lhs.rewrite(context, lhs_budget, offset);\n+            if let Some(lhs_result) = lhs_result {\n+                let mut result = format!(\"{}{}{}\", prefix, lhs_result, infix);\n \n-        let rhs_str = match rhs.rewrite(context, rhs_budget, rhs_indent) {\n-            Some(result) => result,\n-            None => return Err(Ordering::Less),\n-        };\n+                let remaining_width = width.checked_sub(last_line_width(&result)).unwrap_or(0);\n \n-        Ok(format!(\"{}{}{}{}{}\", prefix, lhs_str, infix, rhs_str, suffix))\n-    })\n+                if rhs_result.len() <= remaining_width {\n+                    result.push_str(&rhs_result);\n+                    result.push_str(suffix);\n+                    return Some(result);\n+                }\n+\n+                // Try rewriting the rhs into the remaining space.\n+                let rhs_budget = try_opt!(remaining_width.checked_sub(suffix.len()));\n+                if let Some(rhs_result) = rhs.rewrite(context, rhs_budget, offset + result.len()) {\n+                    if rhs_result.len() <= remaining_width {\n+                        result.push_str(&rhs_result);\n+                        result.push_str(suffix);\n+                        return Some(result);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // We have to use multiple lines.\n+\n+    // Re-evaluate the rhs because we have more space now:\n+    let infix = infix.trim_right();\n+    let lhs_budget =\n+        try_opt!(context.config.max_width.checked_sub(offset.width() + prefix.len() + infix.len()));\n+    let rhs_budget = try_opt!(rhs_budget.checked_sub(prefix.len()));\n+    let rhs_offset = offset + prefix.len();\n+\n+    let rhs_result = try_opt!(rhs.rewrite(context, rhs_budget, rhs_offset));\n+    let lhs_result = try_opt!(lhs.rewrite(context, lhs_budget, offset));\n+    Some(format!(\"{}{}{}\\n{}{}{}\",\n+                 prefix,\n+                 lhs_result,\n+                 infix,\n+                 rhs_offset.to_string(context.config),\n+                 rhs_result,\n+                 suffix))\n }\n \n pub fn rewrite_array<'a, I>(expr_iter: I,\n@@ -535,82 +576,6 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         let rewrite = try_opt!(block.rewrite(&context, budget, Indent::empty()));\n         Some(format!(\"{} {}\", prefix, rewrite))\n     }\n-\n-    // // This is where we figure out whether to use braces or not.\n-    // let mut had_braces = true;\n-    // let mut inner_block = body;\n-\n-    // let mut trailing_expr = stmt_expr(&inner_block.stmts[inner_block.stmts.len() - 1]);\n-\n-    // // If there is an inner block and we can ignore it, do so.\n-    // if body.stmts.len() == 1 && trailing_expr.is_some() {\n-    //     if let Some(ref inner) = stmt_block(&inner_block.stmts[0]) {\n-    //         inner_block = inner;\n-    //         trailing_expr = if inner_block.stmts.is_empty() {\n-    //             None\n-    //         } else {\n-    //             stmt_expr(&inner_block.stmts[inner_block.stmts.len() - 1])\n-    //         };\n-    //     } else if !force_block {\n-    //         had_braces = false;\n-    //     }\n-    // }\n-\n-    // let try_single_line = is_simple_block(inner_block, context.codemap) &&\n-    //                       inner_block.rules == ast::BlockCheckMode::Default;\n-\n-\n-    // if try_single_line && !force_block {\n-    //     let must_preserve_braces =\n-    //         trailing_expr.is_none() ||\n-    //         !classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(trailing_expr.unwrap()));\n-    //     if !(must_preserve_braces && had_braces) &&\n-    //        (must_preserve_braces || !prefix.contains('\\n')) {\n-    //         // If we got here, then we can try to format without braces.\n-\n-    //         let inner_expr = &inner_block.stmts[0];\n-    //         let mut rewrite = inner_expr.rewrite(context, budget, offset + extra_offset);\n-\n-    //         if must_preserve_braces {\n-    //             // If we are here, then failure to rewrite is unacceptable.\n-    //             if rewrite.is_none() {\n-    //                 return None;\n-    //             }\n-    //         } else {\n-    //             // Checks if rewrite succeeded and fits on a single line.\n-    //             rewrite = and_one_line(rewrite);\n-    //         }\n-\n-    //         if let Some(rewrite) = rewrite {\n-    //             return Some(format!(\"{} {}\", prefix, rewrite));\n-    //         }\n-    //     }\n-    // }\n-\n-    // // If we fell through the above block, then we need braces, but we might\n-    // // still prefer a one-liner (we might also have fallen through because of\n-    // // lack of space).\n-    // if try_single_line && !prefix.contains('\\n') {\n-    //     let inner_expr = &inner_block.stmts[0];\n-    //     // 4 = braces and spaces.\n-    //     let mut rewrite = inner_expr.rewrite(context,\n-    //                                          try_opt!(budget.checked_sub(4)),\n-    //                                          offset + extra_offset);\n-\n-    //     // Checks if rewrite succeeded and fits on a single line.\n-    //     rewrite = and_one_line(rewrite);\n-\n-    //     if let Some(rewrite) = rewrite {\n-    //         return Some(format!(\"{} {{ {} }}\", prefix, rewrite));\n-    //     }\n-    // }\n-\n-    // // We couldn't format the closure body as a single line expression; fall\n-    // // back to block formatting.\n-    // let mut context = context.clone();\n-    // context.block_indent.alignment = 0;\n-    // let body_rewrite = try_opt!(inner_block.rewrite(&context, budget, Indent::empty()));\n-    // Some(format!(\"{} {}\", prefix, body_rewrite))\n }\n \n fn and_one_line(x: Option<String>) -> Option<String> {\n@@ -1665,6 +1630,36 @@ fn rewrite_paren(context: &RewriteContext,\n     })\n }\n \n+fn rewrite_index(expr: &ast::Expr,\n+                 index: &ast::Expr,\n+                 context: &RewriteContext,\n+                 width: usize,\n+                 offset: Indent)\n+                 -> Option<String> {\n+    let expr_str = try_opt!(expr.rewrite(context, width, offset));\n+\n+    let (lbr, rbr) = if context.config.spaces_within_square_brackets {\n+        (\"[ \", \" ]\")\n+    } else {\n+        (\"[\", \"]\")\n+    };\n+\n+    let budget = width.checked_sub(expr_str.len() + lbr.len() + rbr.len()).unwrap_or(0);\n+    let index_str = index.rewrite(context, budget, offset);\n+    if let Some(index_str) = index_str {\n+        return Some(format!(\"{}{}{}{}\", expr_str, lbr, index_str, rbr));\n+    }\n+\n+    let indent = offset.block_indent(&context.config);\n+    let indent = indent.to_string(&context.config);\n+    // FIXME this is not right, since we don't take into account that width\n+    // might be reduced from max_width by something on the right.\n+    let budget =\n+        try_opt!(context.config.max_width.checked_sub(indent.len() + lbr.len() + rbr.len()));\n+    let index_str = try_opt!(index.rewrite(context, budget, offset));\n+    Some(format!(\"{}\\n{}{}{}{}\", expr_str, indent, lbr, index_str, rbr))\n+}\n+\n fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                           path: &ast::Path,\n                           fields: &'a [ast::Field],\n@@ -1886,62 +1881,6 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n     }\n }\n \n-fn rewrite_binary_op(context: &RewriteContext,\n-                     op: &ast::BinOp,\n-                     lhs: &ast::Expr,\n-                     rhs: &ast::Expr,\n-                     width: usize,\n-                     offset: Indent)\n-                     -> Option<String> {\n-    // FIXME: format comments between operands and operator\n-\n-    let operator_str = context.snippet(op.span);\n-\n-    // Get \"full width\" rhs and see if it fits on the current line. This\n-    // usually works fairly well since it tends to place operands of\n-    // operations with high precendence close together.\n-    let rhs_result = try_opt!(rhs.rewrite(context, width, offset));\n-\n-    // Second condition is needed in case of line break not caused by a\n-    // shortage of space, but by end-of-line comments, for example.\n-    // Note that this is non-conservative, but its just to see if it's even\n-    // worth trying to put everything on one line.\n-    if rhs_result.len() + 2 + operator_str.len() < width && !rhs_result.contains('\\n') {\n-        // 1 = space between lhs expr and operator\n-        if let Some(mut result) = lhs.rewrite(context, width - 1 - operator_str.len(), offset) {\n-            result.push(' ');\n-            result.push_str(&operator_str);\n-            result.push(' ');\n-\n-            let remaining_width = width.checked_sub(last_line_width(&result)).unwrap_or(0);\n-\n-            if rhs_result.len() <= remaining_width {\n-                result.push_str(&rhs_result);\n-                return Some(result);\n-            }\n-\n-            if let Some(rhs_result) = rhs.rewrite(context, remaining_width, offset + result.len()) {\n-                if rhs_result.len() <= remaining_width {\n-                    result.push_str(&rhs_result);\n-                    return Some(result);\n-                }\n-            }\n-        }\n-    }\n-\n-    // We have to use multiple lines.\n-\n-    // Re-evaluate the lhs because we have more space now:\n-    let budget = try_opt!(context.config\n-        .max_width\n-        .checked_sub(offset.width() + 1 + operator_str.len()));\n-    Some(format!(\"{} {}\\n{}{}\",\n-                 try_opt!(lhs.rewrite(context, budget, offset)),\n-                 operator_str,\n-                 offset.to_string(context.config),\n-                 rhs_result))\n-}\n-\n pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n                                         prefix: &str,\n                                         rewrite: &R,"}, {"sha": "ec9c6f10f5fb6a5ed6123a3c79afdd2162dc9af7", "filename": "tests/target/expr.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9be29712748cf8d723d190f9e99442cebbe1fd94/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be29712748cf8d723d190f9e99442cebbe1fd94/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=9be29712748cf8d723d190f9e99442cebbe1fd94", "patch": "@@ -76,8 +76,8 @@ fn foo() -> bool {\n }\n \n fn bar() {\n-    let range = (111111111 + 333333333333333333 + 1111 + 400000000000000000)..(2222 +\n-                                                                               2333333333333333);\n+    let range = (111111111 + 333333333333333333 + 1111 + 400000000000000000)..\n+                (2222 + 2333333333333333);\n \n     let another_range = 5..some_func(a, b /* comment */);\n \n@@ -226,19 +226,17 @@ fn casts() {\n }\n \n fn indices() {\n-    let x = (aaaaaaaaaaaaaaaaaaaaaaaaaaaa + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb + cccccccccccccccc)[x +\n-                                                                                                y +\n-                                                                                                z];\n-    let y = (aaaaaaaaaaaaaaaaaaaaaaaaaaaa + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb +\n-             cccccccccccccccc)[xxxxx + yyyyy + zzzzz];\n+    let x = (aaaaaaaaaaaaaaaaaaaaaaaaaaaa + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb + cccccccccccccccc)\n+                [x + y + z];\n+    let y = (aaaaaaaaaaaaaaaaaaaaaaaaaaaa + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb + cccccccccccccccc)\n+                [xxxxx + yyyyy + zzzzz];\n }\n \n fn repeats() {\n-    let x = [aaaaaaaaaaaaaaaaaaaaaaaaaaaa + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb + cccccccccccccccc; x +\n-                                                                                                y +\n-                                                                                                z];\n-    let y = [aaaaaaaaaaaaaaaaaaaaaaaaaaaa + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb +\n-             cccccccccccccccc; xxxxx + yyyyy + zzzzz];\n+    let x = [aaaaaaaaaaaaaaaaaaaaaaaaaaaa + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb + cccccccccccccccc;\n+             x + y + z];\n+    let y = [aaaaaaaaaaaaaaaaaaaaaaaaaaaa + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb + cccccccccccccccc;\n+             xxxxx + yyyyy + zzzzz];\n }\n \n fn blocks() {\n@@ -260,8 +258,8 @@ fn issue767() {\n \n fn ranges() {\n     let x = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n-    let y =\n-        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n+    let y = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...\n+            bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n     let z = ...x;\n \n     a...b"}, {"sha": "121c7990f86021e429633edf78dc92a393ceb439", "filename": "tests/target/type-ascription.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9be29712748cf8d723d190f9e99442cebbe1fd94/tests%2Ftarget%2Ftype-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be29712748cf8d723d190f9e99442cebbe1fd94/tests%2Ftarget%2Ftype-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftype-ascription.rs?ref=9be29712748cf8d723d190f9e99442cebbe1fd94", "patch": "@@ -1,13 +1,12 @@\n fn main() {\n-    let xxxxxxxxxxx =\n-        yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: SomeTrait<AA, BB, CC>;\n+    let xxxxxxxxxxx = yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy:\n+                      SomeTrait<AA, BB, CC>;\n \n-    let xxxxxxxxxxxxxxx =\n-        yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n+    let xxxxxxxxxxxxxxx = yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy:\n+                          AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n \n-    let z = funk(yyyyyyyyyyyyyyy,\n-                 zzzzzzzzzzzzzzzz,\n-                 wwwwww): AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n+    let z = funk(yyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzz, wwwwww):\n+            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n \n     x: u32 - 1u32 / 10f32: u32\n }"}]}