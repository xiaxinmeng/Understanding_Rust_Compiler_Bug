{"sha": "ab93561b5fa54954159480ddc10bbb69f015e539", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOTM1NjFiNWZhNTQ5NTQxNTk0ODBkZGMxMGJiYjY5ZjAxNWU1Mzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-13T02:28:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-13T02:28:13Z"}, "message": "Auto merge of #53051 - varkor:trait-method-pattern-arguments-error, r=petrochenkov\n\nEmit error for pattern arguments in trait methods\n\nThe error and check for this already existed, but the parser didn't try to parse trait method arguments as patterns, so the error was never emitted. This surfaces the error, so we get better errors than simple parse errors.\n\nThis improves the error message described in https://github.com/rust-lang/rust/issues/53046.\n\nr? @petrochenkov", "tree": {"sha": "05a25f34dab37f6f5e8096be2ea3fa7262463068", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05a25f34dab37f6f5e8096be2ea3fa7262463068"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab93561b5fa54954159480ddc10bbb69f015e539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab93561b5fa54954159480ddc10bbb69f015e539", "html_url": "https://github.com/rust-lang/rust/commit/ab93561b5fa54954159480ddc10bbb69f015e539", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab93561b5fa54954159480ddc10bbb69f015e539/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a0d2961ce88f7db90b13771d1e8fc3b50ded7b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0d2961ce88f7db90b13771d1e8fc3b50ded7b1", "html_url": "https://github.com/rust-lang/rust/commit/5a0d2961ce88f7db90b13771d1e8fc3b50ded7b1"}, {"sha": "5c814e2e4e0649972ec6a18c7dbf57259edf2210", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c814e2e4e0649972ec6a18c7dbf57259edf2210", "html_url": "https://github.com/rust-lang/rust/commit/5c814e2e4e0649972ec6a18c7dbf57259edf2210"}], "stats": {"total": 138, "additions": 122, "deletions": 16}, "files": [{"sha": "f1d0a4fee341e92502ddb9906fc58c3684d1c6d0", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=ab93561b5fa54954159480ddc10bbb69f015e539", "patch": "@@ -261,6 +261,27 @@ let result = loop { // ok!\n ```\n \"##,\n \n+E0642: r##\"\n+Trait methods currently cannot take patterns as arguments.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0642\n+trait Foo {\n+    fn foo((x, y): (i32, i32)); // error: patterns aren't allowed\n+                                //        in trait methods\n+}\n+```\n+\n+You can instead use a single name for the argument:\n+\n+```\n+trait Foo {\n+    fn foo(x_and_y: (i32, i32)); // ok!\n+}\n+```\n+\"##,\n+\n E0695: r##\"\n A `break` statement without a label appeared inside a labeled block.\n \n@@ -306,7 +327,6 @@ register_diagnostics! {\n     E0561, // patterns aren't allowed in function pointer types\n     E0567, // auto traits can not have generic parameters\n     E0568, // auto traits can not have super traits\n-    E0642, // patterns aren't allowed in methods without bodies\n     E0666, // nested `impl Trait` is illegal\n     E0667, // `impl Trait` in projections\n     E0696, // `continue` pointing to a labeled block"}, {"sha": "12ce478fe1d8ba02241f01d19cf7862c73cafb86", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ab93561b5fa54954159480ddc10bbb69f015e539", "patch": "@@ -27,6 +27,7 @@\n #![feature(slice_sort_by_cached_key)]\n #![feature(str_escape)]\n #![feature(unicode_internals)]\n+#![feature(catch_expr)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "746e03d771a880d3ac40851ec865066ee9a41e68", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ab93561b5fa54954159480ddc10bbb69f015e539", "patch": "@@ -44,7 +44,7 @@ use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, respan};\n use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, edition::Edition};\n-use errors::{self, Applicability, DiagnosticBuilder};\n+use errors::{self, Applicability, DiagnosticBuilder, DiagnosticId};\n use parse::{self, SeqSep, classify, token};\n use parse::lexer::TokenAndSpan;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -1371,7 +1371,7 @@ impl<'a> Parser<'a> {\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n \n-            let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+            let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n                 // This is somewhat dubious; We don't want to allow\n                 // argument names to be left off if there is a\n                 // definition...\n@@ -1753,21 +1753,59 @@ impl<'a> Parser<'a> {\n             (pat, self.parse_ty()?)\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n-            let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n-            let ty = self.parse_ty()?;\n-            let pat = P(Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n-                span: ty.span,\n-            });\n-            (pat, ty)\n+\n+            let parser_snapshot_before_pat = self.clone();\n+\n+            // We're going to try parsing the argument as a pattern (even though it's not\n+            // allowed). This way we can provide better errors to the user.\n+            let pat_arg: PResult<'a, _> = do catch {\n+                let pat = self.parse_pat()?;\n+                self.expect(&token::Colon)?;\n+                (pat, self.parse_ty()?)\n+            };\n+\n+            match pat_arg {\n+                Ok((pat, ty)) => {\n+                    let mut err = self.diagnostic().struct_span_err_with_code(\n+                        pat.span,\n+                        \"patterns aren't allowed in methods without bodies\",\n+                        DiagnosticId::Error(\"E0642\".into()),\n+                    );\n+                    err.span_suggestion_short_with_applicability(\n+                        pat.span,\n+                        \"give this argument a name or use an underscore to ignore it\",\n+                        \"_\".to_owned(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    err.emit();\n+                    // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n+                    let pat = P(Pat {\n+                        node: PatKind::Wild,\n+                        span: pat.span,\n+                        id: ast::DUMMY_NODE_ID\n+                    });\n+                    (pat, ty)\n+                }\n+                Err(mut err) => {\n+                    err.cancel();\n+                    // Recover from attempting to parse the argument as a pattern. This means\n+                    // the type is alone, with no name, e.g. `fn foo(u32)`.\n+                    mem::replace(self, parser_snapshot_before_pat);\n+                    debug!(\"parse_arg_general ident_to_pat\");\n+                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n+                    let ty = self.parse_ty()?;\n+                    let pat = P(Pat {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: PatKind::Ident(\n+                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n+                        span: ty.span,\n+                    });\n+                    (pat, ty)\n+                }\n+            }\n         };\n \n-        Ok(Arg {\n-            ty,\n-            pat,\n-            id: ast::DUMMY_NODE_ID,\n-        })\n+        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n     }\n \n     /// Parse a single function argument"}, {"sha": "58ccfc56ab79a8e293afcf2cf8ed5756c307a4b4", "filename": "src/test/ui/E0642.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Ftest%2Fui%2FE0642.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Ftest%2Fui%2FE0642.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0642.rs?ref=ab93561b5fa54954159480ddc10bbb69f015e539", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Clone, Copy)]\n+struct S;\n+\n+trait T {\n+    fn foo((x, y): (i32, i32)); //~ ERROR patterns aren't allowed in methods without bodies\n+\n+    fn bar((x, y): (i32, i32)) {} //~ ERROR patterns aren't allowed in methods without bodies\n+\n+    fn f(&ident: &S) {} // ok\n+    fn g(&&ident: &&S) {} // ok\n+    fn h(mut ident: S) {} // ok\n+}\n+\n+fn main() {}"}, {"sha": "34c163e2109703b838bf1400265f873dab3b6bde", "filename": "src/test/ui/E0642.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Ftest%2Fui%2FE0642.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab93561b5fa54954159480ddc10bbb69f015e539/src%2Ftest%2Fui%2FE0642.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0642.stderr?ref=ab93561b5fa54954159480ddc10bbb69f015e539", "patch": "@@ -0,0 +1,23 @@\n+error[E0642]: patterns aren't allowed in methods without bodies\n+  --> $DIR/E0642.rs:15:12\n+   |\n+LL |     fn foo((x, y): (i32, i32)); //~ ERROR patterns aren't allowed in methods without bodies\n+   |            ^^^^^^\n+help: give this argument a name or use an underscore to ignore it\n+   |\n+LL |     fn foo(_: (i32, i32)); //~ ERROR patterns aren't allowed in methods without bodies\n+   |            ^\n+\n+error[E0642]: patterns aren't allowed in methods without bodies\n+  --> $DIR/E0642.rs:17:12\n+   |\n+LL |     fn bar((x, y): (i32, i32)) {} //~ ERROR patterns aren't allowed in methods without bodies\n+   |            ^^^^^^\n+help: give this argument a name or use an underscore to ignore it\n+   |\n+LL |     fn bar(_: (i32, i32)) {} //~ ERROR patterns aren't allowed in methods without bodies\n+   |            ^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0642`."}]}