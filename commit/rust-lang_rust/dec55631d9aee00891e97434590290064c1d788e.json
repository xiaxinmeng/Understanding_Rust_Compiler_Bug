{"sha": "dec55631d9aee00891e97434590290064c1d788e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlYzU1NjMxZDlhZWUwMDg5MWU5NzQzNDU5MDI5MDA2NGMxZDc4OGU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-21T22:27:45Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-21T22:27:45Z"}, "message": "Use a boundary method instead of an endpoint method for split_grouped_constructors", "tree": {"sha": "4b6e94bc4f6daa50bf7b0b7b5faf9a732e9aeed1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b6e94bc4f6daa50bf7b0b7b5faf9a732e9aeed1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dec55631d9aee00891e97434590290064c1d788e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dec55631d9aee00891e97434590290064c1d788e", "html_url": "https://github.com/rust-lang/rust/commit/dec55631d9aee00891e97434590290064c1d788e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dec55631d9aee00891e97434590290064c1d788e/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a957e172af90befa1af4bd416ea872f6f50b086", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a957e172af90befa1af4bd416ea872f6f50b086", "html_url": "https://github.com/rust-lang/rust/commit/6a957e172af90befa1af4bd416ea872f6f50b086"}], "stats": {"total": 138, "additions": 54, "deletions": 84}, "files": [{"sha": "e47e2899507ee6e11e7e6be3fb94965b59c6773d", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 52, "deletions": 82, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/dec55631d9aee00891e97434590290064c1d788e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dec55631d9aee00891e97434590290064c1d788e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=dec55631d9aee00891e97434590290064c1d788e", "patch": "@@ -194,6 +194,7 @@ use std::cmp::{self, Ordering, min, max};\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n+use std::u128;\n \n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n                                 -> &'a Pattern<'tcx>\n@@ -799,6 +800,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e. `range.lo <= range.hi`.\n+#[derive(Clone)]\n struct IntRange<'tcx> {\n     pub range: RangeInclusive<u128>,\n     pub ty: Ty<'tcx>,\n@@ -1400,9 +1402,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n /// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n /// change.\n /// Our solution, therefore, is to split the range constructor into subranges at every single point\n-/// the group of intersecting patterns changes, which we can compute by converting each pattern to\n-/// a range and recording its endpoints, then creating subranges between each consecutive pair of\n-/// endpoints.\n+/// the group of intersecting patterns changes (using the method described below).\n /// And voil\u00e0! We're testing precisely those ranges that we need to, without any exhaustive matching\n /// on actual integers. The nice thing about this is that the number of subranges is linear in the\n /// number of rows in the matrix (i.e. the number of cases in the `match` statement), so we don't\n@@ -1414,14 +1414,14 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n ///    |-------| |-------|            |----| ||\n ///       |---------|\n ///\n-/// We truncate the ranges so that they lie inside each range constructor and then split them\n-/// up into equivalence classes so the ranges are no longer overlapping:\n+/// We split the ranges up into equivalence classes so the ranges are no longer overlapping:\n ///\n /// |--|--|||-||||--||---|||-------|  |-|||| ||\n ///\n-/// The logic for determining how to split the ranges is a little involved: we need to make sure\n-/// that we have a new range for each subrange for which a different set of rows co\u00efncides, but\n-/// essentially reduces to case analysis on the endpoints of the ranges.\n+/// The logic for determining how to split the ranges is fairly straightforward: we calculate\n+/// boundaries for each interval range, sort them, then create constructors for each new interval\n+/// between every pair of boundary points. (This essentially sums up to performing the intuitive\n+/// merging operation depicted above.)\n fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n@@ -1440,84 +1440,54 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n                 // `NotUseful`, which is the default case anyway, and can be ignored.\n                 let ctor_range = IntRange::from_ctor(tcx, &ctor).unwrap();\n \n-                // We're going to collect all the endpoints in the new pattern so we can create\n-                // subranges between them.\n-                // If there's a single point, we need to identify it as belonging\n-                // to a length-1 range, so it can be treated as an individual\n-                // constructor, rather than as an endpoint. To do this, we keep track of which\n-                // endpoint a point corresponds to. Whenever a point corresponds to both a start\n-                // and an end, then we create a unit range for it.\n-                #[derive(PartialEq, Clone, Copy, Debug)]\n-                enum Endpoint {\n-                    Start,\n-                    End,\n-                    Both,\n-                };\n-                let mut points = FxHashMap::default();\n-                let add_endpoint = |points: &mut FxHashMap<_, _>, x, endpoint| {\n-                    points.entry(x).and_modify(|ex_x| {\n-                        if *ex_x != endpoint {\n-                            *ex_x = Endpoint::Both\n-                        }\n-                    }).or_insert(endpoint);\n-                };\n-                let add_endpoints = |points: &mut FxHashMap<_, _>, lo, hi| {\n-                    // Insert the endpoints, taking care to keep track of to\n-                    // which endpoints a point corresponds.\n-                    add_endpoint(points, lo, Endpoint::Start);\n-                    add_endpoint(points, hi, Endpoint::End);\n-                };\n-                let (lo, hi) = (*ctor_range.range.start(), *ctor_range.range.end());\n-                add_endpoints(&mut points, lo, hi);\n-                // We're going to iterate through every row pattern, adding endpoints in.\n-                for row in m.iter() {\n-                    if let Some(r) = IntRange::from_pat(tcx, row[0]) {\n-                        // We're only interested in endpoints that lie (at least partially)\n-                        // within the subrange domain.\n-                        if let Some(r) = ctor_range.intersection(&r) {\n-                            let (r_lo, r_hi) = r.range.into_inner();\n-                            add_endpoints(&mut points, r_lo, r_hi);\n-                        }\n-                    }\n+                /// Represents a border between 2 integers. Because the intervals spanning borders\n+                /// must be able to cover every integer, we need 2^128 + 1 such borders.\n+                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+                enum Border {\n+                    JustBefore(u128),\n+                    AfterMax,\n                 }\n \n-                // The patterns were iterated in an arbitrary order (i.e. in the order the user\n-                // wrote them), so we need to make sure our endpoints are sorted.\n-                let mut points: Vec<(u128, Endpoint)> = points.into_iter().collect();\n-                points.sort_unstable_by_key(|(x, _)| *x);\n-                let mut points = points.into_iter();\n-                let mut a = points.next().unwrap();\n-\n-                // Iterate through pairs of points, adding the subranges to `split_ctors`.\n-                // We have to be careful about the orientation of the points as endpoints, to make\n-                // sure we're enumerating precisely the correct ranges. Too few and the matching is\n-                // actually incorrect. Too many and our diagnostics are poorer. This involves some\n-                // case analysis.\n-                // In essence, we need to ensure that every time the set of row-ranges that are\n-                // overlapping changes (as we go through the values covered by the ranges), we split\n-                // into a new subrange.\n-                while let Some(b) = points.next() {\n-                    // a < b (strictly)\n-                    if let Endpoint::Both = a.1 {\n-                        split_ctors.push(IntRange::range_to_ctor(tcx, ty, a.0..=a.0));\n-                    }\n-                    // Integer overflow cannot occur here, because only the first point may be\n-                    // u128::MIN and only the last may be u128::MAX.\n-                    let c = match a.1 {\n-                        Endpoint::Start => a.0,\n-                        Endpoint::End | Endpoint::Both => a.0 + 1,\n-                    };\n-                    let d = match b.1 {\n-                        Endpoint::Start | Endpoint::Both => b.0 - 1,\n-                        Endpoint::End => b.0,\n+                // A function for extracting the borders of an integer interval.\n+                fn range_borders(r: IntRange<'_>) -> impl Iterator<Item = Border> {\n+                    let (lo, hi) = r.range.into_inner();\n+                    let from = Border::JustBefore(lo);\n+                    let to = match hi.checked_add(1) {\n+                        Some(m) => Border::JustBefore(m),\n+                        None => Border::AfterMax,\n                     };\n-                    // In some cases, we won't need an intermediate range between two ranges\n-                    // lie immediately adjacent to one another.\n-                    if c <= d {\n-                        split_ctors.push(IntRange::range_to_ctor(tcx, ty, c..=d));\n-                    }\n+                    vec![from, to].into_iter()\n+                }\n \n-                    a = b;\n+                // `borders` is the set of borders between equivalence classes: each equivalence\n+                // class lies between 2 borders.\n+                let row_borders = m.iter()\n+                    .flat_map(|row| IntRange::from_pat(tcx, row[0]))\n+                    .flat_map(|range| ctor_range.intersection(&range))\n+                    .flat_map(|range| range_borders(range));\n+                let ctor_borders = range_borders(ctor_range.clone());\n+                let mut borders: Vec<_> = row_borders.chain(ctor_borders).collect();\n+                borders.sort_unstable();\n+\n+                // We're going to iterate through every pair of borders, making sure that each\n+                // represents an interval of nonnegative length, and convert each such interval\n+                // into a constructor.\n+                for IntRange { range, .. } in borders.windows(2).filter_map(|window| {\n+                    match (window[0], window[1]) {\n+                        (Border::JustBefore(n), Border::JustBefore(m)) => {\n+                            if n < m {\n+                                Some(IntRange { range: n..=(m - 1), ty })\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        (Border::JustBefore(n), Border::AfterMax) => {\n+                            Some(IntRange { range: n..=u128::MAX, ty })\n+                        }\n+                        (Border::AfterMax, _) => None,\n+                    }\n+                }) {\n+                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range));\n                 }\n             }\n             // Any other constructor can be used unchanged."}, {"sha": "a8e9e74905c7ba2d0abdaaa0696d9b44571c0326", "filename": "src/test/ui/exhaustive_integer_patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dec55631d9aee00891e97434590290064c1d788e/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dec55631d9aee00891e97434590290064c1d788e/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs?ref=dec55631d9aee00891e97434590290064c1d788e", "patch": "@@ -158,8 +158,8 @@ fn main() {\n         _ => {}\n     }\n \n-    const lim: u128 = u128::MAX - 1;\n+    const LIM: u128 = u128::MAX - 1;\n     match 0u128 { //~ ERROR non-exhaustive patterns\n-        0 ..= lim => {}\n+        0 ..= LIM => {}\n     }\n }"}]}