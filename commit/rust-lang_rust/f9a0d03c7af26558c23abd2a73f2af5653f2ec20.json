{"sha": "f9a0d03c7af26558c23abd2a73f2af5653f2ec20", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YTBkMDNjN2FmMjY1NThjMjNhYmQyYTczZjJhZjU2NTNmMmVjMjA=", "commit": {"author": {"name": "David Rajchenbach-Teller", "email": "dteller@mozilla.com", "date": "2011-11-05T09:29:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-05T20:04:34Z"}, "message": "Fixup: forgotten stdtest/rope.rs", "tree": {"sha": "7bdff8a9d81d992bef9d8f70462f652098b0a2ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bdff8a9d81d992bef9d8f70462f652098b0a2ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9a0d03c7af26558c23abd2a73f2af5653f2ec20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a0d03c7af26558c23abd2a73f2af5653f2ec20", "html_url": "https://github.com/rust-lang/rust/commit/f9a0d03c7af26558c23abd2a73f2af5653f2ec20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9a0d03c7af26558c23abd2a73f2af5653f2ec20/comments", "author": {"login": "Yoric", "id": 10190, "node_id": "MDQ6VXNlcjEwMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/10190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yoric", "html_url": "https://github.com/Yoric", "followers_url": "https://api.github.com/users/Yoric/followers", "following_url": "https://api.github.com/users/Yoric/following{/other_user}", "gists_url": "https://api.github.com/users/Yoric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yoric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yoric/subscriptions", "organizations_url": "https://api.github.com/users/Yoric/orgs", "repos_url": "https://api.github.com/users/Yoric/repos", "events_url": "https://api.github.com/users/Yoric/events{/privacy}", "received_events_url": "https://api.github.com/users/Yoric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5dcf66ad3760961244477c610e4478853e13abb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5dcf66ad3760961244477c610e4478853e13abb", "html_url": "https://github.com/rust-lang/rust/commit/a5dcf66ad3760961244477c610e4478853e13abb"}], "stats": {"total": 148, "additions": 148, "deletions": 0}, "files": [{"sha": "f8e897e6811413ee3361c15ca129b0db407fac92", "filename": "src/test/stdtest/rope.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/f9a0d03c7af26558c23abd2a73f2af5653f2ec20/src%2Ftest%2Fstdtest%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a0d03c7af26558c23abd2a73f2af5653f2ec20/src%2Ftest%2Fstdtest%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frope.rs?ref=f9a0d03c7af26558c23abd2a73f2af5653f2ec20", "patch": "@@ -0,0 +1,148 @@\n+import std::str;\n+import std::rope::*;\n+import std::option;\n+import std::uint;\n+\n+//Utility function, used for sanity check\n+fn rope_to_string(r: rope) -> str {\n+    alt(r) {\n+      node::empty. { ret \"\" }\n+      node::content(x) {\n+        let str = @mutable \"\";\n+        fn aux(str: @mutable str, node: @node::node) {\n+            alt(*node) {\n+              node::leaf(x) {\n+                *str += str::substr(*x.content, x.byte_offset, x.byte_len);\n+              }\n+              node::concat(x) {\n+                aux(str, x.left);\n+                aux(str, x.right);\n+              }\n+            }\n+        }\n+        aux(str, x);\n+        ret *str\n+      }\n+    }\n+}\n+\n+\n+#[test]\n+fn trivial() {\n+    assert char_len(empty()) == 0u;\n+    assert byte_len(empty()) == 0u;\n+}\n+\n+#[test]\n+fn of_string1() {\n+    let sample = @\"0123456789ABCDE\";\n+    let r      = of_str(sample);\n+\n+    assert char_len(r) == str::char_len(*sample);\n+    assert rope_to_string(r) == *sample;\n+}\n+\n+#[test]\n+fn of_string2() {\n+    let buf = @ mutable \"1234567890\";\n+    let i = 0;\n+    while i < 10 { *buf = *buf + *buf; i+=1;}\n+    let sample = @*buf;\n+    let r      = of_str(sample);\n+    assert char_len(r) == str::char_len(*sample);\n+    assert rope_to_string(r) == *sample;\n+\n+    let string_iter = 0u;\n+    let string_len  = str::byte_len(*sample);\n+    let rope_iter   = iterator::char::start(r);\n+    let equal       = true;\n+    let pos         = 0u;\n+    while equal {\n+        alt(node::char_iterator::next(rope_iter)) {\n+          option::none. {\n+            if string_iter < string_len {\n+                equal = false;\n+            } break; }\n+          option::some(c) {\n+            let {ch, next} = str::char_range_at(*sample, string_iter);\n+            string_iter = next;\n+            if ch != c { equal = false; break; }\n+          }\n+        }\n+        pos += 1u;\n+    }\n+\n+    assert equal;\n+}\n+\n+#[test]\n+fn iter1() {\n+    let buf = @ mutable \"1234567890\";\n+    let i = 0;\n+    while i < 10 { *buf = *buf + *buf; i+=1;}\n+    let sample = @*buf;\n+    let r      = of_str(sample);\n+\n+    let len = 0u;\n+    let it  = iterator::char::start(r);\n+    while true {\n+        alt(node::char_iterator::next(it)) {\n+          option::none. { break; }\n+          option::some(_) { len += 1u; }\n+        }\n+    }\n+\n+    assert len == str::char_len(*sample);\n+}\n+\n+#[test]\n+fn bal1() {\n+    let init = @ \"1234567890\";\n+    let buf  = @ mutable * init;\n+    let i = 0;\n+    while i < 16 { *buf = *buf + *buf; i+=1;}\n+    let sample = @*buf;\n+    let r1     = of_str(sample);\n+    let r2     = of_str(init);\n+    i = 0;\n+    while i < 16 { r2 = append_rope(r2, r2); i+= 1;}\n+\n+\n+    assert eq(r1, r2);\n+    let r3 = bal(r2);\n+    assert char_len(r1) == char_len(r3);\n+\n+    assert eq(r1, r3);\n+}\n+\n+#[test]\n+fn char_at1() {\n+    //Generate a large rope\n+    let r = of_str(@ \"123456789\");\n+    uint::range(0u, 10u){|_i|\n+        r = append_rope(r, r);\n+    }\n+\n+    //Copy it in the slowest possible way\n+    let r2 = empty();\n+    uint::range(0u, char_len(r)){|i|\n+        r2 = append_char(r2, char_at(r, i));\n+    }\n+    assert eq(r, r2);\n+\n+    let r3 = empty();\n+    uint::range(0u, char_len(r)){|i|\n+        r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n+    }\n+    assert eq(r, r3);\n+\n+    //Additional sanity checks\n+    let balr = bal(r);\n+    let bal2 = bal(r2);\n+    let bal3 = bal(r3);\n+    assert eq(r, balr);\n+    assert eq(r, bal2);\n+    assert eq(r, bal3);\n+    assert eq(r2, r3);\n+    assert eq(bal2, bal3);\n+}"}]}