{"sha": "4b806878549990d2ad2aa3c265751d3d89947cdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiODA2ODc4NTQ5OTkwZDJhZDJhYTNjMjY1NzUxZDNkODk5NDdjZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-30T01:02:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-30T01:02:18Z"}, "message": "rustdoc tweaking\n\n* Reuse memory\n* simplify `next_def_id`, avoid multiple hashing and unnecessary lookups\n* remove `all_fake_def_ids`, use the global map instead (probably not a good step toward parallelization, though...)\n* convert `add_deref_target` to iterative implementation\n* use `ArrayVec` where we know the max number of elements\n* minor touchups here and there\n* avoid building temporary vectors that get appended to other vectors\n\nAt most places I may or may not be doing the compiler's job is this PR.", "tree": {"sha": "556ad30a9c7c9720cc1bf8c8bd03464bc179aafd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/556ad30a9c7c9720cc1bf8c8bd03464bc179aafd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b806878549990d2ad2aa3c265751d3d89947cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b806878549990d2ad2aa3c265751d3d89947cdf", "html_url": "https://github.com/rust-lang/rust/commit/4b806878549990d2ad2aa3c265751d3d89947cdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b806878549990d2ad2aa3c265751d3d89947cdf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6bc46227ab57a844fc7a9ed3a6c9efb35c725a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6bc46227ab57a844fc7a9ed3a6c9efb35c725a9", "html_url": "https://github.com/rust-lang/rust/commit/c6bc46227ab57a844fc7a9ed3a6c9efb35c725a9"}], "stats": {"total": 1033, "additions": 521, "deletions": 512}, "files": [{"sha": "9149ffeded95267fee046536e31fa632892b5b74", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -4386,6 +4386,7 @@ dependencies = [\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arrayvec\",\n  \"expect-test\",\n  \"itertools 0.9.0\",\n  \"minifier\","}, {"sha": "b6965898b4e4449a3e4cd1bc9dbb2ed8dcc17574", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -8,6 +8,7 @@ edition = \"2018\"\n path = \"lib.rs\"\n \n [dependencies]\n+arrayvec = { version = \"0.5.1\", default-features = false }\n pulldown-cmark = { version = \"0.8\", default-features = false }\n minifier = \"0.0.33\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }"}, {"sha": "2588c00f2cffd3d81fd858990cf9001675dfd499", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -56,7 +56,7 @@ crate fn try_inline(\n     let kind = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n-            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n+            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n             clean::TraitItem(build_external_trait(cx, did))\n         }\n         Res::Def(DefKind::Fn, did) => {\n@@ -65,27 +65,27 @@ crate fn try_inline(\n         }\n         Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n-            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n+            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n             clean::StructItem(build_struct(cx, did))\n         }\n         Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n-            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n+            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n             clean::UnionItem(build_union(cx, did))\n         }\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n-            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n+            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n             clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n-            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n+            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n-            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n+            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -133,10 +133,7 @@ crate fn try_inline_glob(\n     res: Res,\n     visited: &mut FxHashSet<DefId>,\n ) -> Option<Vec<clean::Item>> {\n-    if res == Res::Err {\n-        return None;\n-    }\n-    let did = res.def_id();\n+    let did = res.opt_def_id()?;\n     if did.is_local() {\n         return None;\n     }\n@@ -280,16 +277,14 @@ crate fn build_impls(\n     parent_module: Option<DefId>,\n     did: DefId,\n     attrs: Option<Attrs<'_>>,\n-) -> Vec<clean::Item> {\n+    ret: &mut Vec<clean::Item>,\n+) {\n     let tcx = cx.tcx;\n-    let mut impls = Vec::new();\n \n     // for each implementation of an item represented by `did`, build the clean::Item for that impl\n     for &did in tcx.inherent_impls(did).iter() {\n-        build_impl(cx, parent_module, did, attrs, &mut impls);\n+        build_impl(cx, parent_module, did, attrs, ret);\n     }\n-\n-    impls\n }\n \n /// `parent_module` refers to the parent of the re-export, not the original item"}, {"sha": "18683f6809f4476cb244649fb438742a11a0a454", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -8,6 +8,7 @@ use std::rc::Rc;\n use std::sync::Arc;\n use std::{slice, vec};\n \n+use arrayvec::ArrayVec;\n use rustc_ast::attr;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast::{self as ast, AttrStyle};\n@@ -16,7 +17,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n@@ -28,7 +29,6 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol, SymbolStr};\n use rustc_span::{self, FileName, Loc};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n-use smallvec::{smallvec, SmallVec};\n \n use crate::clean::cfg::Cfg;\n use crate::clean::external_path;\n@@ -45,7 +45,7 @@ use self::ItemKind::*;\n use self::SelfTy::*;\n use self::Type::*;\n \n-thread_local!(crate static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Default::default());\n+thread_local!(crate static MAX_DEF_IDX: RefCell<FxHashMap<CrateNum, DefIndex>> = Default::default());\n \n #[derive(Clone, Debug)]\n crate struct Crate {\n@@ -293,8 +293,8 @@ impl Item {\n     ///\n     /// [`next_def_id()`]: DocContext::next_def_id()\n     crate fn is_fake(&self) -> bool {\n-        MAX_DEF_ID.with(|m| {\n-            m.borrow().get(&self.def_id.krate).map(|id| self.def_id >= *id).unwrap_or(false)\n+        MAX_DEF_IDX.with(|m| {\n+            m.borrow().get(&self.def_id.krate).map(|&idx| idx <= self.def_id.index).unwrap_or(false)\n         })\n     }\n }\n@@ -1539,12 +1539,12 @@ impl PrimitiveType {\n         }\n     }\n \n-    crate fn impls(&self, tcx: TyCtxt<'_>) -> &'static SmallVec<[DefId; 4]> {\n+    crate fn impls(&self, tcx: TyCtxt<'_>) -> &'static ArrayVec<[DefId; 4]> {\n         Self::all_impls(tcx).get(self).expect(\"missing impl for primitive type\")\n     }\n \n-    crate fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>> {\n-        static CELL: OnceCell<FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>>> = OnceCell::new();\n+    crate fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, ArrayVec<[DefId; 4]>> {\n+        static CELL: OnceCell<FxHashMap<PrimitiveType, ArrayVec<[DefId; 4]>>> = OnceCell::new();\n \n         CELL.get_or_init(move || {\n             use self::PrimitiveType::*;\n@@ -1568,7 +1568,7 @@ impl PrimitiveType {\n             }\n \n             let single = |a: Option<DefId>| a.into_iter().collect();\n-            let both = |a: Option<DefId>, b: Option<DefId>| -> SmallVec<_> {\n+            let both = |a: Option<DefId>, b: Option<DefId>| -> ArrayVec<_> {\n                 a.into_iter().chain(b).collect()\n             };\n \n@@ -1601,8 +1601,8 @@ impl PrimitiveType {\n                         .collect()\n                 },\n                 Array => single(lang_items.array_impl()),\n-                Tuple => smallvec![],\n-                Unit => smallvec![],\n+                Tuple => ArrayVec::new(),\n+                Unit => ArrayVec::new(),\n                 RawPointer => {\n                     lang_items\n                         .const_ptr_impl()\n@@ -1612,9 +1612,9 @@ impl PrimitiveType {\n                         .chain(lang_items.mut_slice_ptr_impl())\n                         .collect()\n                 },\n-                Reference => smallvec![],\n-                Fn => smallvec![],\n-                Never => smallvec![],\n+                Reference => ArrayVec::new(),\n+                Fn => ArrayVec::new(),\n+                Never => ArrayVec::new(),\n             }\n         })\n     }"}, {"sha": "ce8e0cf981c3823d78da3633eeb01a89835b0cc4", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -322,20 +322,14 @@ crate fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut\n             ItemKind::TypedefItem(ref t, true) => &t.type_,\n             _ => continue,\n         };\n-        let primitive = match *target {\n-            ResolvedPath { did, .. } if did.is_local() => continue,\n-            ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, None, did, None));\n-                continue;\n+\n+        if let Some(prim) = target.primitive_type() {\n+            for &did in prim.impls(tcx).iter().filter(|did| !did.is_local()) {\n+                inline::build_impl(cx, None, did, None, ret);\n             }\n-            _ => match target.primitive_type() {\n-                Some(prim) => prim,\n-                None => continue,\n-            },\n-        };\n-        for &did in primitive.impls(tcx) {\n+        } else if let ResolvedPath { did, .. } = *target {\n             if !did.is_local() {\n-                inline::build_impl(cx, None, did, None, ret);\n+                inline::build_impls(cx, None, did, None, ret);\n             }\n         }\n     }"}, {"sha": "95c6989dab4ee9c7aba45503939f761faf1ba598", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -474,7 +474,7 @@ impl Options {\n         };\n \n         let mut id_map = html::markdown::IdMap::new();\n-        id_map.populate(html::render::initial_ids());\n+        id_map.populate(&html::render::INITIAL_IDS);\n         let external_html = match ExternalHtml::load(\n             &matches.opt_strs(\"html-in-header\"),\n             &matches.opt_strs(\"html-before-content\"),"}, {"sha": "8eea102fa2fdbe11820eea4e77611f7dba1097f2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -24,12 +24,15 @@ use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n \n-use std::cell::{Cell, RefCell};\n use std::mem;\n use std::rc::Rc;\n+use std::{\n+    cell::{Cell, RefCell},\n+    collections::hash_map::Entry,\n+};\n \n use crate::clean;\n-use crate::clean::{AttributesExt, MAX_DEF_ID};\n+use crate::clean::{AttributesExt, MAX_DEF_IDX};\n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::config::{OutputFormat, RenderInfo};\n use crate::formats::cache::Cache;\n@@ -63,8 +66,7 @@ crate struct DocContext<'tcx> {\n     crate ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n     crate impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n-    crate fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n-    crate all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n+    crate fake_def_ids: RefCell<FxHashMap<CrateNum, DefIndex>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n     crate generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n@@ -138,37 +140,38 @@ impl<'tcx> DocContext<'tcx> {\n     /// [`Debug`]: std::fmt::Debug\n     /// [`clean::Item`]: crate::clean::types::Item\n     crate fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n-        let start_def_id = {\n-            let num_def_ids = if crate_num == LOCAL_CRATE {\n-                self.tcx.hir().definitions().def_path_table().num_def_ids()\n-            } else {\n-                self.enter_resolver(|r| r.cstore().num_def_ids(crate_num))\n-            };\n-\n-            DefId { krate: crate_num, index: DefIndex::from_usize(num_def_ids) }\n-        };\n-\n         let mut fake_ids = self.fake_def_ids.borrow_mut();\n \n-        let def_id = *fake_ids.entry(crate_num).or_insert(start_def_id);\n-        fake_ids.insert(\n-            crate_num,\n-            DefId { krate: crate_num, index: DefIndex::from(def_id.index.index() + 1) },\n-        );\n-\n-        MAX_DEF_ID.with(|m| {\n-            m.borrow_mut().entry(def_id.krate).or_insert(start_def_id);\n-        });\n-\n-        self.all_fake_def_ids.borrow_mut().insert(def_id);\n+        let def_index = match fake_ids.entry(crate_num) {\n+            Entry::Vacant(e) => {\n+                let num_def_idx = {\n+                    let num_def_idx = if crate_num == LOCAL_CRATE {\n+                        self.tcx.hir().definitions().def_path_table().num_def_ids()\n+                    } else {\n+                        self.enter_resolver(|r| r.cstore().num_def_ids(crate_num))\n+                    };\n+\n+                    DefIndex::from_usize(num_def_idx)\n+                };\n+\n+                MAX_DEF_IDX.with(|m| {\n+                    m.borrow_mut().insert(crate_num, num_def_idx);\n+                });\n+                e.insert(num_def_idx)\n+            }\n+            Entry::Occupied(e) => e.into_mut(),\n+        };\n+        *def_index = DefIndex::from(*def_index + 1);\n \n-        def_id\n+        DefId { krate: crate_num, index: *def_index }\n     }\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n     crate fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n-        if self.all_fake_def_ids.borrow().contains(&def_id) {\n+        if MAX_DEF_IDX.with(|m| {\n+            m.borrow().get(&def_id.krate).map(|&idx| idx <= def_id.index).unwrap_or(false)\n+        }) {\n             None\n         } else {\n             def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n@@ -517,7 +520,6 @@ crate fn run_global_ctxt(\n         ct_substs: Default::default(),\n         impl_trait_bounds: Default::default(),\n         fake_def_ids: Default::default(),\n-        all_fake_def_ids: Default::default(),\n         generated_synthetics: Default::default(),\n         auto_traits: tcx\n             .all_traits(LOCAL_CRATE)"}, {"sha": "f904de22f6ba45ee836aa68d52c0290ddf9252db", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -158,6 +158,6 @@ impl ItemType {\n \n impl fmt::Display for ItemType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.as_str())\n+        f.write_str(self.as_str())\n     }\n }"}, {"sha": "ce44722a532b0cd9c8c93ac138fa3592717e0d3c", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -16,23 +16,20 @@ impl<'a> fmt::Display for Escape<'a> {\n         let Escape(s) = *self;\n         let pile_o_bits = s;\n         let mut last = 0;\n-        for (i, ch) in s.bytes().enumerate() {\n-            match ch as char {\n-                '<' | '>' | '&' | '\\'' | '\"' => {\n-                    fmt.write_str(&pile_o_bits[last..i])?;\n-                    let s = match ch as char {\n-                        '>' => \"&gt;\",\n-                        '<' => \"&lt;\",\n-                        '&' => \"&amp;\",\n-                        '\\'' => \"&#39;\",\n-                        '\"' => \"&quot;\",\n-                        _ => unreachable!(),\n-                    };\n-                    fmt.write_str(s)?;\n-                    last = i + 1;\n-                }\n-                _ => {}\n-            }\n+        for (i, ch) in s.char_indices() {\n+            let s = match ch {\n+                '>' => \"&gt;\",\n+                '<' => \"&lt;\",\n+                '&' => \"&amp;\",\n+                '\\'' => \"&#39;\",\n+                '\"' => \"&quot;\",\n+                _ => continue,\n+            };\n+            fmt.write_str(&pile_o_bits[last..i])?;\n+            fmt.write_str(s)?;\n+            // NOTE: we only expect single byte characters here - which is fine as long as we\n+            // only match single byte characters\n+            last = i + 1;\n         }\n \n         if last < s.len() {"}, {"sha": "7e50d72e60f7daa5b1a9667e478b79628ef45d40", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -7,24 +7,26 @@\n \n use crate::html::escape::Escape;\n \n-use std::fmt::{Display, Write};\n+use std::fmt::Display;\n use std::iter::Peekable;\n \n use rustc_lexer::{LiteralKind, TokenKind};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::Symbol;\n use rustc_span::with_default_session_globals;\n \n+use super::format::Buffer;\n+\n /// Highlights `src`, returning the HTML output.\n crate fn render_with_highlighting(\n-    src: String,\n+    src: &str,\n+    out: &mut Buffer,\n     class: Option<&str>,\n     playground_button: Option<&str>,\n     tooltip: Option<(Option<Edition>, &str)>,\n     edition: Edition,\n-) -> String {\n+) {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n-    let mut out = String::with_capacity(src.len());\n     if let Some((edition_info, class)) = tooltip {\n         write!(\n             out,\n@@ -35,23 +37,19 @@ crate fn render_with_highlighting(\n             } else {\n                 String::new()\n             },\n-        )\n-        .unwrap();\n+        );\n     }\n \n-    write_header(&mut out, class);\n-    write_code(&mut out, &src, edition);\n-    write_footer(&mut out, playground_button);\n-\n-    out\n+    write_header(out, class);\n+    write_code(out, &src, edition);\n+    write_footer(out, playground_button);\n }\n \n-fn write_header(out: &mut String, class: Option<&str>) {\n-    write!(out, \"<div class=\\\"example-wrap\\\"><pre class=\\\"rust {}\\\">\\n\", class.unwrap_or_default())\n-        .unwrap()\n+fn write_header(out: &mut Buffer, class: Option<&str>) {\n+    write!(out, \"<div class=\\\"example-wrap\\\"><pre class=\\\"rust {}\\\">\\n\", class.unwrap_or_default());\n }\n \n-fn write_code(out: &mut String, src: &str, edition: Edition) {\n+fn write_code(out: &mut Buffer, src: &str, edition: Edition) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n     Classifier::new(&src, edition).highlight(&mut |highlight| {\n@@ -63,8 +61,8 @@ fn write_code(out: &mut String, src: &str, edition: Edition) {\n     });\n }\n \n-fn write_footer(out: &mut String, playground_button: Option<&str>) {\n-    write!(out, \"</pre>{}</div>\\n\", playground_button.unwrap_or_default()).unwrap()\n+fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n+    write!(out, \"</pre>{}</div>\\n\", playground_button.unwrap_or_default());\n }\n \n /// How a span of text is classified. Mostly corresponds to token kinds.\n@@ -331,13 +329,13 @@ impl<'a> Classifier<'a> {\n \n /// Called when we start processing a span of text that should be highlighted.\n /// The `Class` argument specifies how it should be highlighted.\n-fn enter_span(out: &mut String, klass: Class) {\n-    write!(out, \"<span class=\\\"{}\\\">\", klass.as_html()).unwrap()\n+fn enter_span(out: &mut Buffer, klass: Class) {\n+    write!(out, \"<span class=\\\"{}\\\">\", klass.as_html());\n }\n \n /// Called at the end of a span of highlighted text.\n-fn exit_span(out: &mut String) {\n-    write!(out, \"</span>\").unwrap()\n+fn exit_span(out: &mut Buffer) {\n+    out.write_str(\"</span>\");\n }\n \n /// Called for a span of text. If the text should be highlighted differently\n@@ -351,10 +349,10 @@ fn exit_span(out: &mut String) {\n /// ```\n /// The latter can be thought of as a shorthand for the former, which is more\n /// flexible.\n-fn string<T: Display>(out: &mut String, text: T, klass: Option<Class>) {\n+fn string<T: Display>(out: &mut Buffer, text: T, klass: Option<Class>) {\n     match klass {\n-        None => write!(out, \"{}\", text).unwrap(),\n-        Some(klass) => write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text).unwrap(),\n+        None => write!(out, \"{}\", text),\n+        Some(klass) => write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text),\n     }\n }\n "}, {"sha": "305cf61091dc6f7607c4a4bf3a43fe5c681ba511", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -1,4 +1,5 @@\n use super::write_code;\n+use crate::html::format::Buffer;\n use expect_test::expect_file;\n use rustc_span::edition::Edition;\n \n@@ -18,9 +19,9 @@ const STYLE: &str = r#\"\n fn test_html_highlighting() {\n     let src = include_str!(\"fixtures/sample.rs\");\n     let html = {\n-        let mut out = String::new();\n+        let mut out = Buffer::new();\n         write_code(&mut out, src, Edition::Edition2018);\n-        format!(\"{}<pre><code>{}</code></pre>\\n\", STYLE, out)\n+        format!(\"{}<pre><code>{}</code></pre>\\n\", STYLE, out.into_inner())\n     };\n     expect_file![\"fixtures/sample.html\"].assert_eq(&html);\n }\n@@ -30,7 +31,7 @@ fn test_dos_backline() {\n     let src = \"pub fn foo() {\\r\\n\\\n     println!(\\\"foo\\\");\\r\\n\\\n }\\r\\n\";\n-    let mut html = String::new();\n+    let mut html = Buffer::new();\n     write_code(&mut html, src, Edition::Edition2018);\n-    expect_file![\"fixtures/dos_line.html\"].assert_eq(&html);\n+    expect_file![\"fixtures/dos_line.html\"].assert_eq(&html.into_inner());\n }"}, {"sha": "e5a686bd07d074f76583121d088ad6fff405efcf", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -114,7 +114,6 @@ crate fn render<T: Print, S: Print>(\n     {after_content}\\\n     <div id=\\\"rustdoc-vars\\\" data-root-path=\\\"{root_path}\\\" data-current-crate=\\\"{krate}\\\"></div>\n     <script src=\\\"{static_root_path}main{suffix}.js\\\"></script>\\\n-    {static_extra_scripts}\\\n     {extra_scripts}\\\n     <script defer src=\\\"{root_path}search-index{suffix}.js\\\"></script>\\\n </body>\\\n@@ -135,22 +134,23 @@ crate fn render<T: Print, S: Print>(\n         root_path = page.root_path,\n         css_class = page.css_class,\n         logo = {\n-            let p = format!(\"{}{}\", page.root_path, layout.krate);\n-            let p = ensure_trailing_slash(&p);\n             if layout.logo.is_empty() {\n                 format!(\n-                    \"<a href='{path}index.html'>\\\n+                    \"<a href='{root}{path}index.html'>\\\n                      <div class='logo-container rust-logo'>\\\n                      <img src='{static_root_path}rust-logo{suffix}.png' alt='logo'></div></a>\",\n-                    path = p,\n+                    root = page.root_path,\n+                    path = ensure_trailing_slash(&layout.krate),\n                     static_root_path = static_root_path,\n                     suffix = page.resource_suffix\n                 )\n             } else {\n                 format!(\n-                    \"<a href='{}index.html'>\\\n-                     <div class='logo-container'><img src='{}' alt='logo'></div></a>\",\n-                    p, layout.logo\n+                    \"<a href='{root}{path}index.html'>\\\n+                     <div class='logo-container'><img src='{logo}' alt='logo'></div></a>\",\n+                    root = page.root_path,\n+                    path = ensure_trailing_slash(&layout.krate),\n+                    logo = layout.logo\n                 )\n             }\n         },\n@@ -194,7 +194,7 @@ crate fn render<T: Print, S: Print>(\n             ))\n             .collect::<String>(),\n         suffix = page.resource_suffix,\n-        static_extra_scripts = page\n+        extra_scripts = page\n             .static_extra_scripts\n             .iter()\n             .map(|e| {\n@@ -204,17 +204,13 @@ crate fn render<T: Print, S: Print>(\n                     extra_script = e\n                 )\n             })\n-            .collect::<String>(),\n-        extra_scripts = page\n-            .extra_scripts\n-            .iter()\n-            .map(|e| {\n+            .chain(page.extra_scripts.iter().map(|e| {\n                 format!(\n                     \"<script src=\\\"{root_path}{extra_script}.js\\\"></script>\",\n                     root_path = page.root_path,\n                     extra_script = e\n                 )\n-            })\n+            }))\n             .collect::<String>(),\n         filter_crates = if layout.generate_search_filter {\n             \"<select id=\\\"crate-search\\\">\\"}, {"sha": "bdb92844f07ad78d2ca61bfaef1cd0b094808b50", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -41,6 +41,8 @@ use pulldown_cmark::{\n     html, BrokenLink, CodeBlockKind, CowStr, Event, LinkType, Options, Parser, Tag,\n };\n \n+use super::format::Buffer;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -235,9 +237,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n         }\n         let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n         let text = lines.collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n-        // insert newline to clearly separate it from the\n-        // previous block so we can shorten the html output\n-        let mut s = String::from(\"\\n\");\n+\n         let playground_button = self.playground.as_ref().and_then(|playground| {\n             let krate = &playground.crate_name;\n             let url = &playground.url;\n@@ -298,17 +298,22 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             None\n         };\n \n-        s.push_str(&highlight::render_with_highlighting(\n-            text,\n+        // insert newline to clearly separate it from the\n+        // previous block so we can shorten the html output\n+        let mut s = Buffer::new();\n+        s.push_str(\"\\n\");\n+        highlight::render_with_highlighting(\n+            &text,\n+            &mut s,\n             Some(&format!(\n                 \"rust-example-rendered{}\",\n                 if let Some((_, class)) = tooltip { format!(\" {}\", class) } else { String::new() }\n             )),\n             playground_button.as_deref(),\n             tooltip,\n             edition,\n-        ));\n-        Some(Event::Html(s.into()))\n+        );\n+        Some(Event::Html(s.into_inner().into()))\n     }\n }\n \n@@ -1332,7 +1337,7 @@ impl IdMap {\n         IdMap { map: init_id_map() }\n     }\n \n-    crate fn populate<I: IntoIterator<Item = String>>(&mut self, ids: I) {\n+    crate fn populate<I: IntoIterator<Item = S>, S: AsRef<str> + ToString>(&mut self, ids: I) {\n         for id in ids {\n             let _ = self.derive(id);\n         }\n@@ -1342,11 +1347,11 @@ impl IdMap {\n         self.map = init_id_map();\n     }\n \n-    crate fn derive(&mut self, candidate: String) -> String {\n-        let id = match self.map.get_mut(&candidate) {\n-            None => candidate,\n+    crate fn derive<S: AsRef<str> + ToString>(&mut self, candidate: S) -> String {\n+        let id = match self.map.get_mut(candidate.as_ref()) {\n+            None => candidate.to_string(),\n             Some(a) => {\n-                let id = format!(\"{}-{}\", candidate, *a);\n+                let id = format!(\"{}-{}\", candidate.as_ref(), *a);\n                 *a += 1;\n                 id\n             }"}, {"sha": "daaa2c719b0e6c1708dd9ea30b811b8daaff1774", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 361, "deletions": 338, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -89,7 +89,7 @@ crate type NameDoc = (String, Option<String>);\n \n crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     crate::html::format::display_fn(move |f| {\n-        if !v.ends_with('/') && !v.is_empty() { write!(f, \"{}/\", v) } else { write!(f, \"{}\", v) }\n+        if !v.ends_with('/') && !v.is_empty() { write!(f, \"{}/\", v) } else { f.write_str(v) }\n     })\n }\n \n@@ -359,28 +359,23 @@ crate struct StylePath {\n \n thread_local!(crate static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n-crate fn initial_ids() -> Vec<String> {\n-    [\n-        \"main\",\n-        \"search\",\n-        \"help\",\n-        \"TOC\",\n-        \"render-detail\",\n-        \"associated-types\",\n-        \"associated-const\",\n-        \"required-methods\",\n-        \"provided-methods\",\n-        \"implementors\",\n-        \"synthetic-implementors\",\n-        \"implementors-list\",\n-        \"synthetic-implementors-list\",\n-        \"methods\",\n-        \"implementations\",\n-    ]\n-    .iter()\n-    .map(|id| (String::from(*id)))\n-    .collect()\n-}\n+crate const INITIAL_IDS: [&'static str; 15] = [\n+    \"main\",\n+    \"search\",\n+    \"help\",\n+    \"TOC\",\n+    \"render-detail\",\n+    \"associated-types\",\n+    \"associated-const\",\n+    \"required-methods\",\n+    \"provided-methods\",\n+    \"implementors\",\n+    \"synthetic-implementors\",\n+    \"implementors-list\",\n+    \"synthetic-implementors-list\",\n+    \"methods\",\n+    \"implementations\",\n+];\n \n /// Generates the documentation for `crate` into the directory `dst`\n impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n@@ -908,12 +903,13 @@ themePicker.onblur = handleThemeButtonsBlur;\n         let mut krates = Vec::new();\n \n         if path.exists() {\n+            let prefix = format!(r#\"{}[\"{}\"]\"#, key, krate);\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n                 if !line.starts_with(key) {\n                     continue;\n                 }\n-                if line.starts_with(&format!(r#\"{}[\"{}\"]\"#, key, krate)) {\n+                if line.starts_with(&prefix) {\n                     continue;\n                 }\n                 ret.push(line.to_string());\n@@ -934,12 +930,13 @@ themePicker.onblur = handleThemeButtonsBlur;\n         let mut krates = Vec::new();\n \n         if path.exists() {\n+            let prefix = format!(\"\\\"{}\\\"\", krate);\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n                 if !line.starts_with('\"') {\n                     continue;\n                 }\n-                if line.starts_with(&format!(\"\\\"{}\\\"\", krate)) {\n+                if line.starts_with(&prefix) {\n                     continue;\n                 }\n                 if line.ends_with(\",\\\\\") {\n@@ -1020,8 +1017,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                     break;\n                 } else {\n                     let e = cur_elem.clone();\n-                    h.children.entry(cur_elem.clone()).or_insert_with(|| Hierarchy::new(e));\n-                    h = h.children.get_mut(&cur_elem).expect(\"not found child\");\n+                    h = h.children.entry(cur_elem.clone()).or_insert_with(|| Hierarchy::new(e));\n                 }\n             }\n         }\n@@ -1214,11 +1210,7 @@ fn write_minify(\n \n fn write_srclink(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n     if let Some(l) = cx.src_href(item) {\n-        write!(\n-            buf,\n-            \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"{}\\\">[src]</a>\",\n-            l, \"goto source code\"\n-        )\n+        write!(buf, \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"goto source code\\\">[src]</a>\", l)\n     }\n }\n \n@@ -1325,25 +1317,23 @@ impl AllTypes {\n     }\n }\n \n-fn print_entries(f: &mut Buffer, e: &FxHashSet<ItemEntry>, title: &str, class: &str) {\n-    if !e.is_empty() {\n-        let mut e: Vec<&ItemEntry> = e.iter().collect();\n-        e.sort();\n-        write!(\n-            f,\n-            \"<h3 id=\\\"{}\\\">{}</h3><ul class=\\\"{} docblock\\\">{}</ul>\",\n-            title,\n-            Escape(title),\n-            class,\n-            e.iter().map(|s| format!(\"<li>{}</li>\", s.print())).collect::<String>()\n-        );\n-    }\n-}\n-\n impl AllTypes {\n     fn print(self, f: &mut Buffer) {\n-        write!(\n-            f,\n+        fn print_entries(f: &mut Buffer, e: &FxHashSet<ItemEntry>, title: &str, class: &str) {\n+            if !e.is_empty() {\n+                let mut e: Vec<&ItemEntry> = e.iter().collect();\n+                e.sort();\n+                write!(f, \"<h3 id=\\\"{}\\\">{}</h3><ul class=\\\"{} docblock\\\">\", title, title, class);\n+\n+                for s in e.iter() {\n+                    write!(f, \"<li>{}</li>\", s.print());\n+                }\n+\n+                f.write_str(\"</ul>\");\n+            }\n+        }\n+\n+        f.write_str(\n             \"<h1 class=\\\"fqn\\\">\\\n                  <span class=\\\"in-band\\\">List of all items</span>\\\n                  <span class=\\\"out-of-band\\\">\\\n@@ -1354,8 +1344,11 @@ impl AllTypes {\n                          </a>\\\n                      </span>\n                  </span>\n-             </h1>\"\n+                 <span class=\\\"in-band\\\">List of all items</span>\\\n+             </h1>\",\n         );\n+        // Note: print_entries does not escape the title, because we know the current set of titles\n+        // don't require escaping.\n         print_entries(f, &self.structs, \"Structs\", \"structs\");\n         print_entries(f, &self.enums, \"Enums\", \"enums\");\n         print_entries(f, &self.unions, \"Unions\", \"unions\");\n@@ -1581,7 +1574,7 @@ impl Context<'_> {\n \n         {\n             self.id_map.borrow_mut().reset();\n-            self.id_map.borrow_mut().populate(initial_ids());\n+            self.id_map.borrow_mut().populate(&INITIAL_IDS);\n         }\n \n         if !self.render_redirect_pages {\n@@ -1703,15 +1696,15 @@ fn wrap_into_docblock<F>(w: &mut Buffer, f: F)\n where\n     F: FnOnce(&mut Buffer),\n {\n-    write!(w, \"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\");\n+    w.write_str(\"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\");\n     f(w);\n-    write!(w, \"</div>\")\n+    w.write_str(\"</div>\")\n }\n \n fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n     debug_assert!(!item.is_stripped());\n     // Write the breadcrumb trail header for the top\n-    write!(buf, \"<h1 class=\\\"fqn\\\"><span class=\\\"in-band\\\">\");\n+    buf.write_str(\"<h1 class=\\\"fqn\\\"><span class=\\\"in-band\\\">\");\n     let name = match *item.kind {\n         clean::ModuleItem(ref m) => {\n             if m.is_crate {\n@@ -1759,23 +1752,22 @@ fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n     }\n     write!(buf, \"<a class=\\\"{}\\\" href=\\\"\\\">{}</a>\", item.type_(), item.name.as_ref().unwrap());\n \n-    write!(buf, \"</span>\"); // in-band\n-    write!(buf, \"<span class=\\\"out-of-band\\\">\");\n+    buf.write_str(\"</span>\"); // in-band\n+    buf.write_str(\"<span class=\\\"out-of-band\\\">\");\n     render_stability_since_raw(\n         buf,\n         item.stable_since(cx.tcx()).as_deref(),\n         item.const_stable_since(cx.tcx()).as_deref(),\n         None,\n         None,\n     );\n-    write!(\n-        buf,\n+    buf.write_str(\n         \"<span id=\\\"render-detail\\\">\\\n                 <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n                     title=\\\"collapse all docs\\\">\\\n                     [<span class=\\\"inner\\\">&#x2212;</span>]\\\n                 </a>\\\n-            </span>\"\n+            </span>\",\n     );\n \n     // Write `src` tag\n@@ -1788,7 +1780,7 @@ fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n         write_srclink(cx, item, buf);\n     }\n \n-    write!(buf, \"</span></h1>\"); // out-of-band\n+    buf.write_str(\"</span></h1>\"); // out-of-band\n \n     match *item.kind {\n         clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n@@ -1923,12 +1915,13 @@ fn document_full(\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n         render_markdown(w, cx, &*s, item.links(&cx.cache), prefix, is_hidden);\n     } else if !prefix.is_empty() {\n-        write!(\n-            w,\n-            \"<div class=\\\"docblock{}\\\">{}</div>\",\n-            if is_hidden { \" hidden\" } else { \"\" },\n-            prefix\n-        );\n+        if is_hidden {\n+            w.write_str(\"<div class=\\\"docblock hidden\\\">\");\n+        } else {\n+            w.write_str(\"<div class=\\\"docblock\\\">\");\n+        }\n+        w.write_str(prefix);\n+        w.write_str(\"</div>\");\n     }\n }\n \n@@ -1946,11 +1939,15 @@ fn document_item_info(\n ) {\n     let item_infos = short_item_info(item, cx, parent);\n     if !item_infos.is_empty() {\n-        write!(w, \"<div class=\\\"item-info{}\\\">\", if is_hidden { \" hidden\" } else { \"\" });\n+        if is_hidden {\n+            w.write_str(\"<div class=\\\"item-info hidden\\\">\");\n+        } else {\n+            w.write_str(\"<div class=\\\"item-info\\\">\");\n+        }\n         for info in item_infos {\n-            write!(w, \"{}\", info);\n+            w.write_str(&info);\n         }\n-        write!(w, \"</div>\");\n+        w.write_str(\"</div>\");\n     }\n }\n \n@@ -1973,36 +1970,32 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n         });\n \n         if item.is_struct() {\n-            write!(\n-                w,\n+            w.write_str(\n                 \"Non-exhaustive structs could have additional fields added in future. \\\n                  Therefore, non-exhaustive structs cannot be constructed in external crates \\\n                  using the traditional <code>Struct {{ .. }}</code> syntax; cannot be \\\n                  matched against without a wildcard <code>..</code>; and \\\n-                 struct update syntax will not work.\"\n+                 struct update syntax will not work.\",\n             );\n         } else if item.is_enum() {\n-            write!(\n-                w,\n+            w.write_str(\n                 \"Non-exhaustive enums could have additional variants added in future. \\\n                  Therefore, when matching against variants of non-exhaustive enums, an \\\n-                 extra wildcard arm must be added to account for any future variants.\"\n+                 extra wildcard arm must be added to account for any future variants.\",\n             );\n         } else if item.is_variant() {\n-            write!(\n-                w,\n+            w.write_str(\n                 \"Non-exhaustive enum variants could have additional fields added in future. \\\n                  Therefore, non-exhaustive enum variants cannot be constructed in external \\\n-                 crates and cannot be matched against.\"\n+                 crates and cannot be matched against.\",\n             );\n         } else {\n-            write!(\n-                w,\n-                \"This type will require a wildcard arm in any match statements or constructors.\"\n+            w.write_str(\n+                \"This type will require a wildcard arm in any match statements or constructors.\",\n             );\n         }\n \n-        write!(w, \"</div>\");\n+        w.write_str(\"</div>\");\n     }\n }\n \n@@ -2139,7 +2132,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n             curty = myty;\n         } else if myty != curty {\n             if curty.is_some() {\n-                write!(w, \"</table>\");\n+                w.write_str(\"</table>\");\n             }\n             curty = myty;\n             let (short, name) = item_ty_to_strs(&myty.unwrap());\n@@ -2171,7 +2164,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                         anchor(myitem.def_id, &*name.as_str(), cx.cache())\n                     ),\n                 }\n-                write!(w, \"</code></td></tr>\");\n+                w.write_str(\"</code></td></tr>\");\n             }\n \n             clean::ImportItem(ref import) => {\n@@ -2227,7 +2220,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n     }\n \n     if curty.is_some() {\n-        write!(w, \"</table>\");\n+        w.write_str(\"</table>\");\n     }\n }\n \n@@ -2389,7 +2382,7 @@ fn short_item_info(\n }\n \n fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n-    write!(w, \"<pre class=\\\"rust const\\\">\");\n+    w.write_str(\"<pre class=\\\"rust const\\\">\");\n     render_attributes(w, it, false);\n \n     write!(\n@@ -2403,7 +2396,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     if c.value.is_some() || c.is_literal {\n         write!(w, \" = {expr};\", expr = Escape(&c.expr));\n     } else {\n-        write!(w, \";\");\n+        w.write_str(\";\");\n     }\n \n     if let Some(value) = &c.value {\n@@ -2419,12 +2412,12 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n         }\n     }\n \n-    write!(w, \"</pre>\");\n+    w.write_str(\"</pre>\");\n     document(w, cx, it, None)\n }\n \n fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n-    write!(w, \"<pre class=\\\"rust static\\\">\");\n+    w.write_str(\"<pre class=\\\"rust static\\\">\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n@@ -2449,7 +2442,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         f.generics.print(cx.cache())\n     )\n     .len();\n-    write!(w, \"<pre class=\\\"rust fn\\\">\");\n+    w.write_str(\"<pre class=\\\"rust fn\\\">\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n@@ -2573,7 +2566,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n \n     // Output the trait definition\n     wrap_into_docblock(w, |w| {\n-        write!(w, \"<pre class=\\\"rust trait\\\">\");\n+        w.write_str(\"<pre class=\\\"rust trait\\\">\");\n         render_attributes(w, it, true);\n         write!(\n             w,\n@@ -2590,34 +2583,34 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             let where_ = WhereClause { gens: &t.generics, indent: 0, end_newline: true };\n             write!(w, \"{}\", where_.print(cx.cache()));\n         } else {\n-            write!(w, \" \");\n+            w.write_str(\" \");\n         }\n \n         if t.items.is_empty() {\n-            write!(w, \"{{ }}\");\n+            w.write_str(\"{ }\");\n         } else {\n             // FIXME: we should be using a derived_id for the Anchors here\n-            write!(w, \"{{\\n\");\n+            w.write_str(\"{\\n\");\n             for t in &types {\n                 render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                write!(w, \";\\n\");\n+                w.write_str(\";\\n\");\n             }\n             if !types.is_empty() && !consts.is_empty() {\n                 w.write_str(\"\\n\");\n             }\n             for t in &consts {\n                 render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                write!(w, \";\\n\");\n+                w.write_str(\";\\n\");\n             }\n             if !consts.is_empty() && !required.is_empty() {\n                 w.write_str(\"\\n\");\n             }\n             for (pos, m) in required.iter().enumerate() {\n                 render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                write!(w, \";\\n\");\n+                w.write_str(\";\\n\");\n \n                 if pos < required.len() - 1 {\n-                    write!(w, \"<div class=\\\"item-spacer\\\"></div>\");\n+                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n                 }\n             }\n             if !required.is_empty() && !provided.is_empty() {\n@@ -2629,19 +2622,19 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                     clean::MethodItem(ref inner, _)\n                         if !inner.generics.where_predicates.is_empty() =>\n                     {\n-                        write!(w, \",\\n    {{ ... }}\\n\");\n+                        w.write_str(\",\\n    { ... }\\n\");\n                     }\n                     _ => {\n-                        write!(w, \" {{ ... }}\\n\");\n+                        w.write_str(\" { ... }\\n\");\n                     }\n                 }\n                 if pos < provided.len() - 1 {\n-                    write!(w, \"<div class=\\\"item-spacer\\\"></div>\");\n+                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n                 }\n             }\n-            write!(w, \"}}\");\n+            w.write_str(\"}\");\n         }\n-        write!(w, \"</pre>\")\n+        w.write_str(\"</pre>\")\n     });\n \n     // Trait documentation\n@@ -2668,10 +2661,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         write!(w, \"<h3 id=\\\"{id}\\\" class=\\\"method\\\"><code>\", id = id,);\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n-        write!(w, \"</code>\");\n+        w.write_str(\"</code>\");\n         render_stability_since(w, m, t, cx.tcx());\n         write_srclink(cx, m, w);\n-        write!(w, \"</h3>\");\n+        w.write_str(\"</h3>\");\n         document(w, cx, m, Some(t));\n     }\n \n@@ -3072,10 +3065,10 @@ fn render_assoc_item(\n \n fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n     wrap_into_docblock(w, |w| {\n-        write!(w, \"<pre class=\\\"rust struct\\\">\");\n+        w.write_str(\"<pre class=\\\"rust struct\\\">\");\n         render_attributes(w, it, true);\n         render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n-        write!(w, \"</pre>\")\n+        w.write_str(\"</pre>\")\n     });\n \n     document(w, cx, it, None);\n@@ -3122,10 +3115,10 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n \n fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n     wrap_into_docblock(w, |w| {\n-        write!(w, \"<pre class=\\\"rust union\\\">\");\n+        w.write_str(\"<pre class=\\\"rust union\\\">\");\n         render_attributes(w, it, true);\n         render_union(w, it, Some(&s.generics), &s.fields, \"\", true, cx);\n-        write!(w, \"</pre>\")\n+        w.write_str(\"</pre>\")\n     });\n \n     document(w, cx, it, None);\n@@ -3168,7 +3161,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n \n fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     wrap_into_docblock(w, |w| {\n-        write!(w, \"<pre class=\\\"rust enum\\\">\");\n+        w.write_str(\"<pre class=\\\"rust enum\\\">\");\n         render_attributes(w, it, true);\n         write!(\n             w,\n@@ -3179,11 +3172,11 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             WhereClause { gens: &e.generics, indent: 0, end_newline: true }.print(cx.cache())\n         );\n         if e.variants.is_empty() && !e.variants_stripped {\n-            write!(w, \" {{}}\");\n+            w.write_str(\" {}\");\n         } else {\n-            write!(w, \" {{\\n\");\n+            w.write_str(\" {\\n\");\n             for v in &e.variants {\n-                write!(w, \"    \");\n+                w.write_str(\"    \");\n                 let name = v.name.as_ref().unwrap();\n                 match *v.kind {\n                     clean::VariantItem(ref var) => match var {\n@@ -3192,27 +3185,27 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                             write!(w, \"{}(\", name);\n                             for (i, ty) in tys.iter().enumerate() {\n                                 if i > 0 {\n-                                    write!(w, \",&nbsp;\")\n+                                    w.write_str(\",&nbsp;\")\n                                 }\n                                 write!(w, \"{}\", ty.print(cx.cache()));\n                             }\n-                            write!(w, \")\");\n+                            w.write_str(\")\");\n                         }\n                         clean::Variant::Struct(ref s) => {\n                             render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n                         }\n                     },\n                     _ => unreachable!(),\n                 }\n-                write!(w, \",\\n\");\n+                w.write_str(\",\\n\");\n             }\n \n             if e.variants_stripped {\n-                write!(w, \"    // some variants omitted\\n\");\n+                w.write_str(\"    // some variants omitted\\n\");\n             }\n-            write!(w, \"}}\");\n+            w.write_str(\"}\");\n         }\n-        write!(w, \"</pre>\")\n+        w.write_str(\"</pre>\")\n     });\n \n     document(w, cx, it, None);\n@@ -3236,16 +3229,16 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 name = variant.name.as_ref().unwrap()\n             );\n             if let clean::VariantItem(clean::Variant::Tuple(ref tys)) = *variant.kind {\n-                write!(w, \"(\");\n+                w.write_str(\"(\");\n                 for (i, ty) in tys.iter().enumerate() {\n                     if i > 0 {\n-                        write!(w, \",&nbsp;\");\n+                        w.write_str(\",&nbsp;\");\n                     }\n                     write!(w, \"{}\", ty.print(cx.cache()));\n                 }\n-                write!(w, \")\");\n+                w.write_str(\")\");\n             }\n-            write!(w, \"</code></div>\");\n+            w.write_str(\"</code></div>\");\n             document(w, cx, variant, Some(it));\n             document_non_exhaustive(w, variant);\n \n@@ -3283,7 +3276,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                         document(w, cx, field, Some(variant));\n                     }\n                 }\n-                write!(w, \"</div></div>\");\n+                w.write_str(\"</div></div>\");\n             }\n             render_stability_since(w, variant, it, cx.tcx());\n         }\n@@ -3363,7 +3356,7 @@ fn render_struct(\n                 )\n             }\n             let mut has_visible_fields = false;\n-            write!(w, \" {{\");\n+            w.write_str(\" {\");\n             for field in fields {\n                 if let clean::StructFieldItem(ref ty) = *field.kind {\n                     write!(\n@@ -3388,13 +3381,13 @@ fn render_struct(\n                 // `{ /* fields omitted */ }` to save space.\n                 write!(w, \" /* fields omitted */ \");\n             }\n-            write!(w, \"}}\");\n+            w.write_str(\"}\");\n         }\n         CtorKind::Fn => {\n-            write!(w, \"(\");\n+            w.write_str(\"(\");\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n-                    write!(w, \", \");\n+                    w.write_str(\", \");\n                 }\n                 match *field.kind {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n@@ -3409,15 +3402,15 @@ fn render_struct(\n                     _ => unreachable!(),\n                 }\n             }\n-            write!(w, \")\");\n+            w.write_str(\")\");\n             if let Some(g) = g {\n                 write!(\n                     w,\n                     \"{}\",\n                     WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n                 )\n             }\n-            write!(w, \";\");\n+            w.write_str(\";\");\n         }\n         CtorKind::Const => {\n             // Needed for PhantomData.\n@@ -3428,7 +3421,7 @@ fn render_struct(\n                     WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n                 )\n             }\n-            write!(w, \";\");\n+            w.write_str(\";\");\n         }\n     }\n }\n@@ -3471,7 +3464,7 @@ fn render_union(\n     if it.has_stripped_fields().unwrap() {\n         write!(w, \"    // some fields omitted\\n{}\", tab);\n     }\n-    write!(w, \"}}\");\n+    w.write_str(\"}\");\n }\n \n #[derive(Copy, Clone)]\n@@ -3505,16 +3498,15 @@ fn render_assoc_items(\n     if !non_trait.is_empty() {\n         let render_mode = match what {\n             AssocItemRender::All => {\n-                write!(\n-                    w,\n+                w.write_str(\n                     \"<h2 id=\\\"implementations\\\" class=\\\"small-section-header\\\">\\\n                          Implementations<a href=\\\"#implementations\\\" class=\\\"anchor\\\"></a>\\\n-                    </h2>\"\n+                    </h2>\",\n                 );\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n-                let id = cx.derive_id(small_url_encode(&format!(\n+                let id = cx.derive_id(small_url_encode(format!(\n                     \"deref-methods-{:#}\",\n                     type_.print(cx.cache())\n                 )));\n@@ -3589,29 +3581,27 @@ fn render_assoc_items(\n         }\n \n         if !synthetic.is_empty() {\n-            write!(\n-                w,\n+            w.write_str(\n                 \"<h2 id=\\\"synthetic-implementations\\\" class=\\\"small-section-header\\\">\\\n                      Auto Trait Implementations\\\n                      <a href=\\\"#synthetic-implementations\\\" class=\\\"anchor\\\"></a>\\\n                  </h2>\\\n-                 <div id=\\\"synthetic-implementations-list\\\">\"\n+                 <div id=\\\"synthetic-implementations-list\\\">\",\n             );\n             render_impls(cx, w, &synthetic, containing_item);\n-            write!(w, \"</div>\");\n+            w.write_str(\"</div>\");\n         }\n \n         if !blanket_impl.is_empty() {\n-            write!(\n-                w,\n+            w.write_str(\n                 \"<h2 id=\\\"blanket-implementations\\\" class=\\\"small-section-header\\\">\\\n                      Blanket Implementations\\\n                      <a href=\\\"#blanket-implementations\\\" class=\\\"anchor\\\"></a>\\\n                  </h2>\\\n-                 <div id=\\\"blanket-implementations-list\\\">\"\n+                 <div id=\\\"blanket-implementations-list\\\">\",\n             );\n             render_impls(cx, w, &blanket_impl, containing_item);\n-            write!(w, \"</div>\");\n+            w.write_str(\"</div>\");\n         }\n     }\n }\n@@ -3693,19 +3683,21 @@ fn spotlight_decl(decl: &clean::FnDecl, cache: &Cache) -> String {\n                 if impl_.trait_.def_id_full(cache).map_or(false, |d| cache.traits[&d].is_spotlight)\n                 {\n                     if out.is_empty() {\n-                        out.push_str(&format!(\n+                        write!(\n+                            &mut out,\n                             \"<h3 class=\\\"notable\\\">Notable traits for {}</h3>\\\n                              <code class=\\\"content\\\">\",\n                             impl_.for_.print(cache)\n-                        ));\n+                        );\n                         trait_.push_str(&impl_.for_.print(cache).to_string());\n                     }\n \n                     //use the \"where\" class here to make it small\n-                    out.push_str(&format!(\n+                    write!(\n+                        &mut out,\n                         \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n                         impl_.print(cache)\n-                    ));\n+                    );\n                     let t_did = impl_.trait_.def_id_full(cache).unwrap();\n                     for it in &impl_.items {\n                         if let clean::TypedefItem(ref tydef, _) = *it.kind {\n@@ -3765,7 +3757,7 @@ fn render_impl(\n                 if is_on_foreign_type {\n                     get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx.cache())\n                 } else {\n-                    format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t.print(cx.cache()))))\n+                    format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cx.cache()))))\n                 }\n             }\n             None => \"impl\".to_string(),\n@@ -3781,7 +3773,7 @@ fn render_impl(\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n                     if let clean::TypedefItem(ref tydef, _) = *it.kind {\n-                        write!(w, \"<span class=\\\"where fmt-newline\\\">  \");\n+                        w.write_str(\"<span class=\\\"where fmt-newline\\\">  \");\n                         assoc_type(\n                             w,\n                             it,\n@@ -3791,11 +3783,11 @@ fn render_impl(\n                             \"\",\n                             cx.cache(),\n                         );\n-                        write!(w, \";</span>\");\n+                        w.write_str(\";</span>\");\n                     }\n                 }\n             }\n-            write!(w, \"</code>\");\n+            w.write_str(\"</code>\");\n         } else {\n             write!(\n                 w,\n@@ -3814,7 +3806,7 @@ fn render_impl(\n             outer_const_version,\n         );\n         write_srclink(cx, &i.impl_item, w);\n-        write!(w, \"</h3>\");\n+        w.write_str(\"</h3>\");\n \n         if trait_.is_some() {\n             if let Some(portability) = portability(&i.impl_item, Some(parent)) {\n@@ -3877,9 +3869,9 @@ fn render_impl(\n                 if render_method_item {\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                     write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, extra_class);\n-                    write!(w, \"<code>\");\n+                    w.write_str(\"<code>\");\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl, cx);\n-                    write!(w, \"</code>\");\n+                    w.write_str(\"</code>\");\n                     render_stability_since_raw(\n                         w,\n                         item.stable_since(cx.tcx()).as_deref(),\n@@ -3888,7 +3880,7 @@ fn render_impl(\n                         outer_const_version,\n                     );\n                     write_srclink(cx, item, w);\n-                    write!(w, \"</h4>\");\n+                    w.write_str(\"</h4>\");\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n@@ -3903,13 +3895,13 @@ fn render_impl(\n                     \"\",\n                     cx.cache(),\n                 );\n-                write!(w, \"</code></h4>\");\n+                w.write_str(\"</code></h4>\");\n             }\n             clean::AssocConstItem(ref ty, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\"><code>\", id, item_type, extra_class);\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\", cx);\n-                write!(w, \"</code>\");\n+                w.write_str(\"</code>\");\n                 render_stability_since_raw(\n                     w,\n                     item.stable_since(cx.tcx()).as_deref(),\n@@ -3918,13 +3910,13 @@ fn render_impl(\n                     outer_const_version,\n                 );\n                 write_srclink(cx, item, w);\n-                write!(w, \"</h4>\");\n+                w.write_str(\"</h4>\");\n             }\n             clean::AssocTypeItem(ref bounds, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\"><code>\", id, item_type, extra_class);\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id), \"\", cx.cache());\n-                write!(w, \"</code></h4>\");\n+                w.write_str(\"</code></h4>\");\n             }\n             clean::StrippedItem(..) => return,\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name),\n@@ -3968,7 +3960,7 @@ fn render_impl(\n         }\n     }\n \n-    write!(w, \"<div class=\\\"impl-items\\\">\");\n+    w.write_str(\"<div class=\\\"impl-items\\\">\");\n     for trait_item in &i.inner_impl().items {\n         doc_impl_item(\n             w,\n@@ -4039,11 +4031,11 @@ fn render_impl(\n             );\n         }\n     }\n-    write!(w, \"</div>\");\n+    w.write_str(\"</div>\");\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n-    write!(w, \"<pre class=\\\"rust opaque\\\">\");\n+    w.write_str(\"<pre class=\\\"rust opaque\\\">\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n@@ -4065,7 +4057,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n }\n \n fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n-    write!(w, \"<pre class=\\\"rust trait-alias\\\">\");\n+    w.write_str(\"<pre class=\\\"rust trait-alias\\\">\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n@@ -4086,7 +4078,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n }\n \n fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n-    write!(w, \"<pre class=\\\"rust typedef\\\">\");\n+    w.write_str(\"<pre class=\\\"rust typedef\\\">\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n@@ -4108,7 +4100,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n }\n \n fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n-    writeln!(w, \"<pre class=\\\"rust foreigntype\\\">extern {{\");\n+    w.write_str(\"<pre class=\\\"rust foreigntype\\\">extern {\\n\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n@@ -4168,7 +4160,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n         }\n     }\n \n-    write!(buffer, \"<div class=\\\"sidebar-elems\\\">\");\n+    buffer.write_str(\"<div class=\\\"sidebar-elems\\\">\");\n     if it.is_crate() {\n         write!(\n             buffer,\n@@ -4196,10 +4188,10 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n     // as much HTML as possible in order to allow non-JS-enabled browsers\n     // to navigate the documentation (though slightly inefficiently).\n \n-    write!(buffer, \"<p class=\\\"location\\\">\");\n+    buffer.write_str(\"<p class=\\\"location\\\">\");\n     for (i, name) in cx.current.iter().take(parentlen).enumerate() {\n         if i > 0 {\n-            write!(buffer, \"::<wbr>\");\n+            buffer.write_str(\"::<wbr>\");\n         }\n         write!(\n             buffer,\n@@ -4208,7 +4200,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n             *name\n         );\n     }\n-    write!(buffer, \"</p>\");\n+    buffer.write_str(\"</p>\");\n \n     // Sidebar refers to the enclosing module, not this module.\n     let relpath = if it.is_mod() { \"../\" } else { \"\" };\n@@ -4227,7 +4219,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n         write!(buffer, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\", path = relpath);\n     }\n     // Closes sidebar-elems div.\n-    write!(buffer, \"</div>\");\n+    buffer.write_str(\"</div>\");\n }\n \n fn get_next_url(used_links: &mut FxHashSet<String>, url: String) -> String {\n@@ -4268,23 +4260,42 @@ fn get_methods(\n }\n \n // The point is to url encode any potential character from a type with genericity.\n-fn small_url_encode(s: &str) -> String {\n-    s.replace(\"<\", \"%3C\")\n-        .replace(\">\", \"%3E\")\n-        .replace(\" \", \"%20\")\n-        .replace(\"?\", \"%3F\")\n-        .replace(\"'\", \"%27\")\n-        .replace(\"&\", \"%26\")\n-        .replace(\",\", \"%2C\")\n-        .replace(\":\", \"%3A\")\n-        .replace(\";\", \"%3B\")\n-        .replace(\"[\", \"%5B\")\n-        .replace(\"]\", \"%5D\")\n-        .replace(\"\\\"\", \"%22\")\n+fn small_url_encode(s: String) -> String {\n+    let mut st = String::new();\n+    let mut last_match = 0;\n+    for (idx, c) in s.char_indices() {\n+        let escaped = match c {\n+            '<' => \"%3C\",\n+            '>' => \"%3E\",\n+            ' ' => \"%20\",\n+            '?' => \"%3F\",\n+            '\\'' => \"%27\",\n+            '&' => \"%26\",\n+            ',' => \"%2C\",\n+            ':' => \"%3A\",\n+            ';' => \"%3B\",\n+            '[' => \"%5B\",\n+            ']' => \"%5D\",\n+            '\"' => \"%22\",\n+            _ => continue,\n+        };\n+\n+        st += &s[last_match..idx];\n+        st += escaped;\n+        // NOTE: we only expect single byte characters here - which is fine as long as we\n+        // only match single byte characters\n+        last_match = idx + 1;\n+    }\n+\n+    if last_match != 0 {\n+        st += &s[last_match..];\n+        st\n+    } else {\n+        s\n+    }\n }\n \n-fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n-    let mut out = String::new();\n+fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     if let Some(v) = cx.cache.impls.get(&it.def_id) {\n         let mut used_links = FxHashSet::default();\n \n@@ -4300,11 +4311,15 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n             if !ret.is_empty() {\n                 // We want links' order to be reproducible so we don't use unstable sort.\n                 ret.sort();\n-                out.push_str(&format!(\n+\n+                out.push_str(\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#implementations\\\">Methods</a>\\\n-                     <div class=\\\"sidebar-links\\\">{}</div>\",\n-                    ret.join(\"\")\n-                ));\n+                     <div class=\\\"sidebar-links\\\">\",\n+                );\n+                for line in ret {\n+                    out.push_str(&line);\n+                }\n+                out.push_str(\"</div>\");\n             }\n         }\n \n@@ -4314,7 +4329,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_some())\n                 .find(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_trait_did)\n             {\n-                out.push_str(&sidebar_deref_methods(cx, impl_, v));\n+                sidebar_deref_methods(cx, out, impl_, v);\n             }\n             let format_impls = |impls: Vec<&Impl>| {\n                 let mut links = FxHashSet::default();\n@@ -4325,7 +4340,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n                         if let Some(ref i) = it.inner_impl().trait_ {\n                             let i_display = format!(\"{:#}\", i.print(cx.cache()));\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(&format!(\"{:#}\", i.print(cx.cache())));\n+                            let encoded = small_url_encode(format!(\"{:#}\", i.print(cx.cache())));\n                             let generated = format!(\n                                 \"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                 encoded,\n@@ -4339,7 +4354,15 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n                     })\n                     .collect::<Vec<String>>();\n                 ret.sort();\n-                ret.join(\"\")\n+                ret\n+            };\n+\n+            let write_sidebar_links = |out: &mut Buffer, links: Vec<String>| {\n+                out.push_str(\"<div class=\\\"sidebar-links\\\">\");\n+                for link in links {\n+                    out.push_str(&link);\n+                }\n+                out.push_str(\"</div>\");\n             };\n \n             let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n@@ -4357,32 +4380,29 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#trait-implementations\\\">\\\n                         Trait Implementations</a>\",\n                 );\n-                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", concrete_format));\n+                write_sidebar_links(out, concrete_format);\n             }\n \n             if !synthetic_format.is_empty() {\n                 out.push_str(\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#synthetic-implementations\\\">\\\n                         Auto Trait Implementations</a>\",\n                 );\n-                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", synthetic_format));\n+                write_sidebar_links(out, synthetic_format);\n             }\n \n             if !blanket_format.is_empty() {\n                 out.push_str(\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#blanket-implementations\\\">\\\n                         Blanket Implementations</a>\",\n                 );\n-                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", blanket_format));\n+                write_sidebar_links(out, blanket_format);\n             }\n         }\n     }\n-\n-    out\n }\n \n-fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> String {\n-    let mut out = String::new();\n+fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &Vec<Impl>) {\n     let c = cx.cache();\n \n     debug!(\"found Deref: {:?}\", impl_);\n@@ -4419,15 +4439,20 @@ fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> Strin\n                 let id = deref_id_map\n                     .get(&real_target.def_id_full(cx.cache()).unwrap())\n                     .expect(\"Deref section without derived id\");\n-                out.push_str(&format!(\n+                write!(\n+                    out,\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a>\",\n                     id,\n                     Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(c))),\n                     Escape(&format!(\"{:#}\", real_target.print(c))),\n-                ));\n+                );\n                 // We want links' order to be reproducible so we don't use unstable sort.\n                 ret.sort();\n-                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", ret.join(\"\")));\n+                out.push_str(\"<div class=\\\"sidebar-links\\\">\");\n+                for link in ret {\n+                    out.push_str(&link);\n+                }\n+                out.push_str(\"</div>\");\n             }\n         }\n \n@@ -4443,36 +4468,39 @@ fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> Strin\n                         // `impl Deref<Target = S> for S`\n                         if target_did == type_did {\n                             // Avoid infinite cycles\n-                            return out;\n+                            return;\n                         }\n                     }\n-                    out.push_str(&sidebar_deref_methods(cx, target_deref_impl, target_impls));\n+                    sidebar_deref_methods(cx, out, target_deref_impl, target_impls);\n                 }\n             }\n         }\n     }\n-\n-    out\n }\n \n fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n-    let mut sidebar = String::new();\n+    let mut sidebar = Buffer::new();\n     let fields = get_struct_fields_name(&s.fields);\n \n     if !fields.is_empty() {\n         if let CtorKind::Fictive = s.struct_type {\n-            sidebar.push_str(&format!(\n+            sidebar.push_str(\n                 \"<a class=\\\"sidebar-title\\\" href=\\\"#fields\\\">Fields</a>\\\n-                 <div class=\\\"sidebar-links\\\">{}</div>\",\n-                fields\n-            ));\n+                <div class=\\\"sidebar-links\\\">\",\n+            );\n+\n+            for field in fields {\n+                sidebar.push_str(&field);\n+            }\n+\n+            sidebar.push_str(\"</div>\");\n         }\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(cx, it));\n+    sidebar_assoc_items(cx, &mut sidebar, it);\n \n     if !sidebar.is_empty() {\n-        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n+        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar.into_inner());\n     }\n }\n \n@@ -4481,7 +4509,7 @@ fn get_id_for_impl_on_foreign_type(\n     trait_: &clean::Type,\n     cache: &Cache,\n ) -> String {\n-    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_.print(cache), for_.print(cache)))\n+    small_url_encode(format!(\"impl-{:#}-for-{:#}\", trait_.print(cache), for_.print(cache)))\n }\n \n fn extract_for_impl_name(item: &clean::Item, cache: &Cache) -> Option<(String, String)> {\n@@ -4501,82 +4529,74 @@ fn extract_for_impl_name(item: &clean::Item, cache: &Cache) -> Option<(String, S\n }\n \n fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n-    let mut sidebar = String::new();\n+    buf.write_str(\"<div class=\\\"block items\\\">\");\n+\n+    fn print_sidebar_section(\n+        out: &mut Buffer,\n+        items: &[clean::Item],\n+        before: &str,\n+        filter: impl Fn(&clean::Item) -> bool,\n+        write: impl Fn(&mut Buffer, &Symbol),\n+        after: &str,\n+    ) {\n+        let mut items = items\n+            .iter()\n+            .filter_map(|m| match m.name {\n+                Some(ref name) if filter(m) => Some(name),\n+                _ => None,\n+            })\n+            .collect::<Vec<_>>();\n \n-    let mut types = t\n-        .items\n-        .iter()\n-        .filter_map(|m| match m.name {\n-            Some(ref name) if m.is_associated_type() => {\n-                Some(format!(\"<a href=\\\"#associatedtype.{name}\\\">{name}</a>\", name = name))\n-            }\n-            _ => None,\n-        })\n-        .collect::<Vec<_>>();\n-    let mut consts = t\n-        .items\n-        .iter()\n-        .filter_map(|m| match m.name {\n-            Some(ref name) if m.is_associated_const() => {\n-                Some(format!(\"<a href=\\\"#associatedconstant.{name}\\\">{name}</a>\", name = name))\n-            }\n-            _ => None,\n-        })\n-        .collect::<Vec<_>>();\n-    let mut required = t\n-        .items\n-        .iter()\n-        .filter_map(|m| match m.name {\n-            Some(ref name) if m.is_ty_method() => {\n-                Some(format!(\"<a href=\\\"#tymethod.{name}\\\">{name}</a>\", name = name))\n+        if !items.is_empty() {\n+            items.sort();\n+            out.push_str(before);\n+            for item in items.into_iter() {\n+                write(out, item);\n             }\n-            _ => None,\n-        })\n-        .collect::<Vec<String>>();\n-    let mut provided = t\n-        .items\n-        .iter()\n-        .filter_map(|m| match m.name {\n-            Some(ref name) if m.is_method() => {\n-                Some(format!(\"<a href=\\\"#method.{0}\\\">{0}</a>\", name))\n-            }\n-            _ => None,\n-        })\n-        .collect::<Vec<String>>();\n-\n-    if !types.is_empty() {\n-        types.sort();\n-        sidebar.push_str(&format!(\n-            \"<a class=\\\"sidebar-title\\\" href=\\\"#associated-types\\\">\\\n-                Associated Types</a><div class=\\\"sidebar-links\\\">{}</div>\",\n-            types.join(\"\")\n-        ));\n-    }\n-    if !consts.is_empty() {\n-        consts.sort();\n-        sidebar.push_str(&format!(\n-            \"<a class=\\\"sidebar-title\\\" href=\\\"#associated-const\\\">\\\n-                Associated Constants</a><div class=\\\"sidebar-links\\\">{}</div>\",\n-            consts.join(\"\")\n-        ));\n-    }\n-    if !required.is_empty() {\n-        required.sort();\n-        sidebar.push_str(&format!(\n-            \"<a class=\\\"sidebar-title\\\" href=\\\"#required-methods\\\">\\\n-                Required Methods</a><div class=\\\"sidebar-links\\\">{}</div>\",\n-            required.join(\"\")\n-        ));\n-    }\n-    if !provided.is_empty() {\n-        provided.sort();\n-        sidebar.push_str(&format!(\n-            \"<a class=\\\"sidebar-title\\\" href=\\\"#provided-methods\\\">\\\n-                Provided Methods</a><div class=\\\"sidebar-links\\\">{}</div>\",\n-            provided.join(\"\")\n-        ));\n+            out.push_str(after);\n+        }\n     }\n \n+    print_sidebar_section(\n+        buf,\n+        &t.items,\n+        \"<a class=\\\"sidebar-title\\\" href=\\\"#associated-types\\\">\\\n+            Associated Types</a><div class=\\\"sidebar-links\\\">\",\n+        |m| m.is_associated_type(),\n+        |out, sym| write!(out, \"<a href=\\\"#associatedtype.{0}\\\">{0}</a>\", sym),\n+        \"</div>\",\n+    );\n+\n+    print_sidebar_section(\n+        buf,\n+        &t.items,\n+        \"<a class=\\\"sidebar-title\\\" href=\\\"#associated-const\\\">\\\n+            Associated Constants</a><div class=\\\"sidebar-links\\\">\",\n+        |m| m.is_associated_const(),\n+        |out, sym| write!(out, \"<a href=\\\"#associatedconstant.{0}\\\">{0}</a>\", sym),\n+        \"</div>\",\n+    );\n+\n+    print_sidebar_section(\n+        buf,\n+        &t.items,\n+        \"<a class=\\\"sidebar-title\\\" href=\\\"#required-methods\\\">\\\n+            Required Methods</a><div class=\\\"sidebar-links\\\">\",\n+        |m| m.is_ty_method(),\n+        |out, sym| write!(out, \"<a href=\\\"#tymethod.{0}\\\">{0}</a>\", sym),\n+        \"</div>\",\n+    );\n+\n+    print_sidebar_section(\n+        buf,\n+        &t.items,\n+        \"<a class=\\\"sidebar-title\\\" href=\\\"#provided-methods\\\">\\\n+            Provided Methods</a><div class=\\\"sidebar-links\\\">\",\n+        |m| m.is_method(),\n+        |out, sym| write!(out, \"<a href=\\\"#method.{0}\\\">{0}</a>\", sym),\n+        \"</div>\",\n+    );\n+\n     if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         let mut res = implementors\n             .iter()\n@@ -4591,83 +4611,87 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n \n         if !res.is_empty() {\n             res.sort();\n-            sidebar.push_str(&format!(\n+            buf.push_str(\n                 \"<a class=\\\"sidebar-title\\\" href=\\\"#foreign-impls\\\">\\\n                     Implementations on Foreign Types</a>\\\n-                 <div class=\\\"sidebar-links\\\">{}</div>\",\n-                res.into_iter()\n-                    .map(|(name, id)| format!(\"<a href=\\\"#{}\\\">{}</a>\", id, Escape(&name)))\n-                    .collect::<Vec<_>>()\n-                    .join(\"\")\n-            ));\n+                 <div class=\\\"sidebar-links\\\">\",\n+            );\n+            for (name, id) in res.into_iter() {\n+                write!(buf, \"<a href=\\\"#{}\\\">{}</a>\", id, Escape(&name));\n+            }\n+            buf.push_str(\"</div>\");\n         }\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(cx, it));\n+    sidebar_assoc_items(cx, buf, it);\n \n-    sidebar.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#implementors\\\">Implementors</a>\");\n+    buf.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#implementors\\\">Implementors</a>\");\n     if t.is_auto {\n-        sidebar.push_str(\n+        buf.push_str(\n             \"<a class=\\\"sidebar-title\\\" \\\n                 href=\\\"#synthetic-implementors\\\">Auto Implementors</a>\",\n         );\n     }\n \n-    write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar)\n+    buf.push_str(\"</div>\")\n }\n \n fn sidebar_primitive(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let sidebar = sidebar_assoc_items(cx, it);\n+    let mut sidebar = Buffer::new();\n+    sidebar_assoc_items(cx, &mut sidebar, it);\n \n     if !sidebar.is_empty() {\n-        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n+        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar.into_inner());\n     }\n }\n \n fn sidebar_typedef(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let sidebar = sidebar_assoc_items(cx, it);\n+    let mut sidebar = Buffer::new();\n+    sidebar_assoc_items(cx, &mut sidebar, it);\n \n     if !sidebar.is_empty() {\n-        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n+        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar.into_inner());\n     }\n }\n \n-fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n+fn get_struct_fields_name(fields: &[clean::Item]) -> Vec<String> {\n     let mut fields = fields\n         .iter()\n         .filter(|f| matches!(*f.kind, clean::StructFieldItem(..)))\n-        .filter_map(|f| match f.name {\n-            Some(ref name) => {\n-                Some(format!(\"<a href=\\\"#structfield.{name}\\\">{name}</a>\", name = name))\n-            }\n-            _ => None,\n+        .filter_map(|f| {\n+            f.name.map(|name| format!(\"<a href=\\\"#structfield.{name}\\\">{name}</a>\", name = name))\n         })\n         .collect::<Vec<_>>();\n     fields.sort();\n-    fields.join(\"\")\n+    fields\n }\n \n fn sidebar_union(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n-    let mut sidebar = String::new();\n+    let mut sidebar = Buffer::new();\n     let fields = get_struct_fields_name(&u.fields);\n \n     if !fields.is_empty() {\n-        sidebar.push_str(&format!(\n+        sidebar.push_str(\n             \"<a class=\\\"sidebar-title\\\" href=\\\"#fields\\\">Fields</a>\\\n-             <div class=\\\"sidebar-links\\\">{}</div>\",\n-            fields\n-        ));\n+            <div class=\\\"sidebar-links\\\">\",\n+        );\n+\n+        for field in fields {\n+            sidebar.push_str(&field);\n+        }\n+\n+        sidebar.push_str(\"</div>\");\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(cx, it));\n+    sidebar_assoc_items(cx, &mut sidebar, it);\n \n     if !sidebar.is_empty() {\n-        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n+        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar.into_inner());\n     }\n }\n \n fn sidebar_enum(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, e: &clean::Enum) {\n-    let mut sidebar = String::new();\n+    let mut sidebar = Buffer::new();\n \n     let mut variants = e\n         .variants\n@@ -4686,10 +4710,10 @@ fn sidebar_enum(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, e: &clean:\n         ));\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(cx, it));\n+    sidebar_assoc_items(cx, &mut sidebar, it);\n \n     if !sidebar.is_empty() {\n-        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n+        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar.into_inner());\n     }\n }\n \n@@ -4729,11 +4753,7 @@ fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n     if items.iter().any(|it| {\n         it.type_() == ItemType::ExternCrate || (it.type_() == ItemType::Import && !it.is_stripped())\n     }) {\n-        sidebar.push_str(&format!(\n-            \"<li><a href=\\\"#{id}\\\">{name}</a></li>\",\n-            id = \"reexports\",\n-            name = \"Re-exports\"\n-        ));\n+        sidebar.push_str(\"<li><a href=\\\"#reexports\\\">Re-exports</a></li>\");\n     }\n \n     // ordering taken from item_module, reorder, where it prioritized elements in a certain order\n@@ -4776,21 +4796,24 @@ fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n }\n \n fn sidebar_foreign_type(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let sidebar = sidebar_assoc_items(cx, it);\n+    let mut sidebar = Buffer::new();\n+    sidebar_assoc_items(cx, &mut sidebar, it);\n+\n     if !sidebar.is_empty() {\n-        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n+        write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar.into_inner());\n     }\n }\n \n fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Macro) {\n     wrap_into_docblock(w, |w| {\n-        w.write_str(&highlight::render_with_highlighting(\n-            t.source.clone(),\n+        highlight::render_with_highlighting(\n+            &t.source,\n+            w,\n             Some(\"macro\"),\n             None,\n             None,\n             it.source.span().edition(),\n-        ))\n+        );\n     });\n     document(w, cx, it, None)\n }\n@@ -4799,27 +4822,27 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n     let name = it.name.as_ref().expect(\"proc-macros always have names\");\n     match m.kind {\n         MacroKind::Bang => {\n-            write!(w, \"<pre class=\\\"rust macro\\\">\");\n+            w.push_str(\"<pre class=\\\"rust macro\\\">\");\n             write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n-            write!(w, \"</pre>\");\n+            w.push_str(\"</pre>\");\n         }\n         MacroKind::Attr => {\n-            write!(w, \"<pre class=\\\"rust attr\\\">\");\n+            w.push_str(\"<pre class=\\\"rust attr\\\">\");\n             write!(w, \"#[{}]\", name);\n-            write!(w, \"</pre>\");\n+            w.push_str(\"</pre>\");\n         }\n         MacroKind::Derive => {\n-            write!(w, \"<pre class=\\\"rust derive\\\">\");\n+            w.push_str(\"<pre class=\\\"rust derive\\\">\");\n             write!(w, \"#[derive({})]\", name);\n             if !m.helpers.is_empty() {\n-                writeln!(w, \"\\n{{\");\n-                writeln!(w, \"    // Attributes available to this derive:\");\n+                w.push_str(\"\\n{\\n\");\n+                w.push_str(\"    // Attributes available to this derive:\\n\");\n                 for attr in &m.helpers {\n                     writeln!(w, \"    #[{}]\", attr);\n                 }\n-                write!(w, \"}}\");\n+                w.push_str(\"}\\n\");\n             }\n-            write!(w, \"</pre>\");\n+            w.push_str(\"</pre>\");\n         }\n     }\n     document(w, cx, it, None)"}, {"sha": "bbb833e54aeb959e641b622d1eb2cd6635f2afa4", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -86,17 +86,15 @@ impl SourceCollector<'_, '_> {\n             return Ok(());\n         }\n \n-        let mut contents = match fs::read_to_string(&p) {\n+        let contents = match fs::read_to_string(&p) {\n             Ok(contents) => contents,\n             Err(e) => {\n                 return Err(Error::new(e, &p));\n             }\n         };\n \n         // Remove the utf-8 BOM if any\n-        if contents.starts_with('\\u{feff}') {\n-            contents.drain(..3);\n-        }\n+        let contents = if contents.starts_with('\\u{feff}') { &contents[3..] } else { &contents };\n \n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n@@ -171,18 +169,18 @@ where\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-fn print_src(buf: &mut Buffer, s: String, edition: Edition) {\n+fn print_src(buf: &mut Buffer, s: &str, edition: Edition) {\n     let lines = s.lines().count();\n     let mut cols = 0;\n     let mut tmp = lines;\n     while tmp > 0 {\n         cols += 1;\n         tmp /= 10;\n     }\n-    write!(buf, \"<pre class=\\\"line-numbers\\\">\");\n+    buf.write_str(\"<pre class=\\\"line-numbers\\\">\");\n     for i in 1..=lines {\n         write!(buf, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols);\n     }\n-    write!(buf, \"</pre>\");\n-    write!(buf, \"{}\", highlight::render_with_highlighting(s, None, None, None, edition));\n+    buf.write_str(\"</pre>\");\n+    highlight::render_with_highlighting(s, buf, None, None, None, edition);\n }"}, {"sha": "6f992b3a916eea243623501faa30879923e77af2", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b806878549990d2ad2aa3c265751d3d89947cdf/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=4b806878549990d2ad2aa3c265751d3d89947cdf", "patch": "@@ -56,12 +56,12 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n     // doesn't work with it anyway, so pull them from the HIR map instead\n+    let mut extra_attrs = Vec::new();\n     for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n-            let impl_did = cx.tcx.hir().local_def_id(impl_node);\n+            let impl_did = cx.tcx.hir().local_def_id(impl_node).to_def_id();\n             cx.tcx.sess.prof.generic_activity(\"build_local_trait_impl\").run(|| {\n-                let mut extra_attrs = Vec::new();\n-                let mut parent = cx.tcx.parent(impl_did.to_def_id());\n+                let mut parent = cx.tcx.parent(impl_did);\n                 while let Some(did) = parent {\n                     extra_attrs.extend(\n                         cx.tcx\n@@ -79,13 +79,8 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n                     );\n                     parent = cx.tcx.parent(did);\n                 }\n-                inline::build_impl(\n-                    cx,\n-                    None,\n-                    impl_did.to_def_id(),\n-                    Some(&extra_attrs),\n-                    &mut new_items,\n-                );\n+                inline::build_impl(cx, None, impl_did, Some(&extra_attrs), &mut new_items);\n+                extra_attrs.clear();\n             });\n         }\n     }\n@@ -137,25 +132,28 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         }\n     }\n \n-    new_items.retain(|it| {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n-            cleaner.keep_impl(for_)\n-                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t))\n-                || blanket_impl.is_some()\n-        } else {\n-            true\n-        }\n-    });\n-\n-    if let Some(ref mut it) = krate.module {\n+    let items = if let Some(ref mut it) = krate.module {\n         if let ModuleItem(Module { ref mut items, .. }) = *it.kind {\n-            items.extend(synth.impls);\n-            items.extend(new_items);\n+            items\n         } else {\n             panic!(\"collect-trait-impls can't run\");\n         }\n     } else {\n         panic!(\"collect-trait-impls can't run\");\n+    };\n+\n+    items.extend(synth.impls);\n+    for it in new_items.drain(..) {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n+            if !(cleaner.keep_impl(for_)\n+                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t))\n+                || blanket_impl.is_some())\n+            {\n+                continue;\n+            }\n+        }\n+\n+        items.push(it);\n     }\n \n     krate"}]}