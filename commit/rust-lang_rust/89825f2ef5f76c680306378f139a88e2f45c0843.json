{"sha": "89825f2ef5f76c680306378f139a88e2f45c0843", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ODI1ZjJlZjVmNzZjNjgwMzA2Mzc4ZjEzOWE4OGUyZjQ1YzA4NDM=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-22T16:57:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Use associated types instead of type parameters inside the BuilderMethods trait", "tree": {"sha": "8f58db54671e9fd039900c272fddfce8f6add195", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f58db54671e9fd039900c272fddfce8f6add195"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89825f2ef5f76c680306378f139a88e2f45c0843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89825f2ef5f76c680306378f139a88e2f45c0843", "html_url": "https://github.com/rust-lang/rust/commit/89825f2ef5f76c680306378f139a88e2f45c0843", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89825f2ef5f76c680306378f139a88e2f45c0843/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "html_url": "https://github.com/rust-lang/rust/commit/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468"}], "stats": {"total": 716, "additions": 355, "deletions": 361}, "files": [{"sha": "6c60f9d0ba070fc1a080078bc67f5d17ed3a4f86", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89825f2ef5f76c680306378f139a88e2f45c0843/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89825f2ef5f76c680306378f139a88e2f45c0843/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=89825f2ef5f76c680306378f139a88e2f45c0843", "patch": "@@ -76,7 +76,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::Idx;\n \n use traits::{IntPredicate, RealPredicate, BuilderMethods};\n-use llvm::BasicBlock;\n \n use std::any::Any;\n use std::cmp;\n@@ -390,9 +389,8 @@ pub fn call_assume(bx: &Builder<'_, 'll, '_>, val: &'ll Value) {\n     bx.call(assume_intrinsic, &[val], None);\n }\n \n-pub fn from_immediate<'a, 'll: 'a, 'tcx: 'll,\n-    Builder: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>>(\n-    bx: &Builder,\n+pub fn from_immediate<'a, 'll: 'a, 'tcx: 'll>(\n+    bx: &Builder<'_ ,'ll, '_, &'ll Value>,\n     val: &'ll Value\n ) -> &'ll Value {\n     if val_ty(val) == Type::i1(bx.cx()) {\n@@ -424,9 +422,8 @@ pub fn to_immediate_scalar(\n     val\n }\n \n-pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll,\n-    Builder: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>>(\n-    bx: &Builder,\n+pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll>(\n+    bx: &Builder<'_ ,'ll, '_, &'ll Value>,\n     dst: &'ll Value,\n     dst_align: Align,\n     src: &'ll Value,\n@@ -449,9 +446,8 @@ pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll,\n     bx.memcpy(dst_ptr, dst_align.abi(), src_ptr, src_align.abi(), size, volatile);\n }\n \n-pub fn memcpy_ty<'a, 'll: 'a, 'tcx: 'll,\n-    Builder: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>>(\n-    bx: &Builder,\n+pub fn memcpy_ty<'a, 'll: 'a, 'tcx: 'll>(\n+    bx: &Builder<'_ ,'ll, '_, &'ll Value>,\n     dst: &'ll Value,\n     dst_align: Align,\n     src: &'ll Value,"}, {"sha": "47c5315e0b59ffab1ba9ce5c93b555c14bcc2f48", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 172, "deletions": 170, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/89825f2ef5f76c680306378f139a88e2f45c0843/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89825f2ef5f76c680306378f139a88e2f45c0843/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=89825f2ef5f76c680306378f139a88e2f45c0843", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n-use llvm::{False, OperandBundleDef};\n-use llvm::{self, BasicBlock};\n+use llvm::{self, False, OperandBundleDef};\n use common::*;\n-use type_::Type;\n-use value::Value;\n+use type_;\n+use value;\n use libc::{c_uint, c_char};\n use rustc::ty::TyCtxt;\n use rustc::ty::layout::{Align, Size};\n@@ -28,7 +27,7 @@ use std::ptr;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n-pub struct Builder<'a, 'll: 'a, 'tcx: 'll, V: 'll = &'ll Value> {\n+pub struct Builder<'a, 'll: 'a, 'tcx: 'll, V: 'll = &'ll value::Value> {\n     pub llbuilder: &'ll mut llvm::Builder<'ll>,\n     pub cx: &'a CodegenCx<'ll, 'tcx, V>,\n }\n@@ -56,11 +55,14 @@ bitflags! {\n     }\n }\n \n-impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n-    for Builder<'a, 'll, 'tcx> {\n+impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n+    type Value = &'ll value::Value;\n+    type BasicBlock = &'ll llvm::BasicBlock;\n+    type Type = &'ll type_::Type;\n+\n     fn new_block<'b>(\n         cx: &'a CodegenCx<'ll, 'tcx>,\n-        llfn: &'ll Value,\n+        llfn: Self::Value,\n         name: &'b str\n     ) -> Self {\n         let bx = Builder::with_cx(cx);\n@@ -99,13 +101,13 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         self.cx.tcx\n     }\n \n-    fn llfn(&self) -> &'ll Value {\n+    fn llfn(&self) -> Self::Value {\n         unsafe {\n             llvm::LLVMGetBasicBlockParent(self.llbb())\n         }\n     }\n \n-    fn llbb(&self) -> &'ll BasicBlock {\n+    fn llbb(&self) -> Self::BasicBlock {\n         unsafe {\n             llvm::LLVMGetInsertBlock(self.llbuilder)\n         }\n@@ -124,20 +126,20 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn set_value_name(&self, value: &'ll Value, name: &str) {\n+    fn set_value_name(&self, value: Self::Value, name: &str) {\n         let cname = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n     }\n \n-    fn position_at_end(&self, llbb: &'ll BasicBlock) {\n+    fn position_at_end(&self, llbb: Self::BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n         }\n     }\n \n-    fn position_at_start(&self, llbb: &'ll BasicBlock) {\n+    fn position_at_start(&self, llbb: Self::BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n@@ -150,14 +152,14 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn ret(&self, v: &'ll Value) {\n+    fn ret(&self, v: Self::Value) {\n         self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n-    fn br(&self, dest: &'ll BasicBlock) {\n+    fn br(&self, dest: Self::BasicBlock) {\n         self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n@@ -166,9 +168,9 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n \n     fn cond_br(\n         &self,\n-        cond: &'ll Value,\n-        then_llbb: &'ll BasicBlock,\n-        else_llbb: &'ll BasicBlock,\n+        cond: Self::Value,\n+        then_llbb: Self::BasicBlock,\n+        else_llbb: Self::BasicBlock,\n     ) {\n         self.count_insn(\"condbr\");\n         unsafe {\n@@ -178,21 +180,21 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n \n     fn switch(\n         &self,\n-        v: &'ll Value,\n-        else_llbb: &'ll BasicBlock,\n+        v: Self::Value,\n+        else_llbb: Self::BasicBlock,\n         num_cases: usize,\n-    ) -> &'ll Value {\n+    ) -> Self::Value {\n         unsafe {\n             llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n         }\n     }\n \n     fn invoke(&self,\n-                  llfn: &'ll Value,\n-                  args: &[&'ll Value],\n-                  then: &'ll BasicBlock,\n-                  catch: &'ll BasicBlock,\n-                  bundle: Option<&traits::OperandBundleDef<'ll, &'ll Value>>) -> &'ll Value {\n+                  llfn: Self::Value,\n+                  args: &[Self::Value],\n+                  then: Self::BasicBlock,\n+                  catch: Self::BasicBlock,\n+                  bundle: Option<&traits::OperandBundleDef<'ll, Self::Value>>) -> Self::Value {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({:?})\",\n@@ -223,21 +225,21 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n     /* Arithmetic */\n-    fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn add(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fadd(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fadd_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n@@ -246,21 +248,21 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn sub(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fsub(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fsub_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n@@ -269,21 +271,21 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn mul(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fmul(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fmul_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n@@ -293,42 +295,42 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n \n-    fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn udiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn exactudiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn sdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn exactsdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fdiv_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n@@ -337,28 +339,28 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn urem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn srem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn frem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn frem_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n@@ -367,78 +369,78 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn shl(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn lshr(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn ashr(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn and(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn or(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn xor(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn neg(&self, v: &'ll Value) -> &'ll Value {\n+    fn neg(&self, v: Self::Value) -> Self::Value {\n         self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    fn fneg(&self, v: &'ll Value) -> &'ll Value {\n+    fn fneg(&self, v: Self::Value) -> Self::Value {\n         self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    fn not(&self, v: &'ll Value) -> &'ll Value {\n+    fn not(&self, v: Self::Value) -> Self::Value {\n         self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n     }\n \n-    fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn alloca(&self, ty: Self::Type, name: &str, align: Align) -> Self::Value {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&self, ty: Self::Type, name: &str, align: Align) -> Self::Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -454,10 +456,10 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n     fn array_alloca(&self,\n-                        ty: &'ll Type,\n-                        len: &'ll Value,\n+                        ty: Self::Type,\n+                        len: Self::Value,\n                         name: &str,\n-                        align: Align) -> &'ll Value {\n+                        align: Align) -> Self::Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -472,7 +474,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn load(&self, ptr: Self::Value, align: Align) -> Self::Value {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -481,7 +483,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value {\n+    fn volatile_load(&self, ptr: Self::Value) -> Self::Value {\n         self.count_insn(\"load.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -492,10 +494,10 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n \n     fn atomic_load(\n         &self,\n-        ptr: &'ll Value,\n+        ptr: Self::Value,\n         order: traits::AtomicOrdering,\n         size: Size,\n-    ) -> &'ll Value {\n+    ) -> Self::Value {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(\n@@ -511,7 +513,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n \n-    fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n+    fn range_metadata(&self, load: Self::Value, range: Range<u128>) {\n         if self.sess().target.target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks a i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n@@ -534,24 +536,24 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn nonnull_metadata(&self, load: &'ll Value) {\n+    fn nonnull_metadata(&self, load: Self::Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n-    fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn store(&self, val: Self::Value, ptr: Self::Value, align: Align) -> Self::Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n     fn store_with_flags(\n         &self,\n-        val: &'ll Value,\n-        ptr: &'ll Value,\n+        val: Self::Value,\n+        ptr: Self::Value,\n         align: Align,\n         flags: MemFlags,\n-    ) -> &'ll Value {\n+    ) -> Self::Value {\n         debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n@@ -579,7 +581,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-   fn atomic_store(&self, val: &'ll Value, ptr: &'ll Value,\n+   fn atomic_store(&self, val: Self::Value, ptr: Self::Value,\n                    order: traits::AtomicOrdering, size: Size) {\n         debug!(\"Store {:?} -> {:?}\", val, ptr);\n         self.count_insn(\"store.atomic\");\n@@ -596,15 +598,15 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n+    fn gep(&self, ptr: Self::Value, indices: &[Self::Value]) -> Self::Value {\n         self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n-    fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n+    fn inbounds_gep(&self, ptr: Self::Value, indices: &[Self::Value]) -> Self::Value {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n@@ -613,123 +615,123 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n     /* Casts */\n-    fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn trunc(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn sext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptoui(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptosi(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n-    fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn uitofp(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn sitofp(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptrunc(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fpext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn ptrtoint(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn inttoptr(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn bitcast(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n \n-    fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n+    fn intcast(&self, val: Self::Value, dest_ty: Self::Type, is_signed: bool) -> Self::Value {\n         self.count_insn(\"intcast\");\n         unsafe {\n             llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n-    fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn pointercast(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"pointercast\");\n         unsafe {\n             llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     /* Comparisons */\n-    fn icmp(&self, op: traits::IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn icmp(&self, op: traits::IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"icmp\");\n         let op = llvm::IntPredicate::from_generic(op);\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n-    fn fcmp(&self, op: traits::RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fcmp(&self, op: traits::RealPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     /* Miscellaneous instructions */\n-    fn empty_phi(&self, ty: &'ll Type) -> &'ll Value {\n+    fn empty_phi(&self, ty: Self::Type) -> Self::Value {\n         self.count_insn(\"emptyphi\");\n         unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n         }\n     }\n \n-    fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n+    fn phi(&self, ty: Self::Type, vals: &[Self::Value], bbs: &[Self::BasicBlock]) -> Self::Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -742,9 +744,9 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n     fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                       inputs: &[&'ll Value], output: &'ll Type,\n+                       inputs: &[Self::Value], output: Self::Type,\n                        volatile: bool, alignstack: bool,\n-                       dia: syntax::ast::AsmDialect) -> Option<&'ll Value> {\n+                       dia: syntax::ast::AsmDialect) -> Option<Self::Value> {\n         self.count_insn(\"inlineasm\");\n \n         let volatile = if volatile { llvm::True }\n@@ -758,7 +760,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = Type::func(&argtys[..], output);\n+        let fty = type_::Type::func(&argtys[..], output);\n         unsafe {\n             // Ask LLVM to verify that the constraints are well-formed.\n             let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n@@ -774,32 +776,32 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n-                  src: &'ll Value, src_align: u64,\n-                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+    fn memcpy(&self, dst: Self::Value, dst_align: u64,\n+                  src: Self::Value, src_align: u64,\n+                  size: Self::Value, is_volatile: bool) -> Self::Value {\n         unsafe {\n             llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align as c_uint,\n                                       src, src_align as c_uint, size, is_volatile)\n         }\n     }\n \n-    fn memmove(&self, dst: &'ll Value, dst_align: u64,\n-                  src: &'ll Value, src_align: u64,\n-                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+    fn memmove(&self, dst: Self::Value, dst_align: u64,\n+                  src: Self::Value, src_align: u64,\n+                  size: Self::Value, is_volatile: bool) -> Self::Value {\n         unsafe {\n             llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align as c_uint,\n                                       src, src_align as c_uint, size, is_volatile)\n         }\n     }\n \n-    fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn minnum(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"minnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs);\n             instr.expect(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\")\n         }\n     }\n-    fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn maxnum(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n         self.count_insn(\"maxnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs);\n@@ -808,60 +810,60 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n     fn select(\n-        &self, cond: &'ll Value,\n-        then_val: &'ll Value,\n-        else_val: &'ll Value,\n-    ) -> &'ll Value {\n+        &self, cond: Self::Value,\n+        then_val: Self::Value,\n+        else_val: Self::Value,\n+    ) -> Self::Value {\n         self.count_insn(\"select\");\n         unsafe {\n             llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n         }\n     }\n \n     #[allow(dead_code)]\n-    fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+    fn va_arg(&self, list: Self::Value, ty: Self::Type) -> Self::Value {\n         self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n-    fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n+    fn extract_element(&self, vec: Self::Value, idx: Self::Value) -> Self::Value {\n         self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n     }\n \n     fn insert_element(\n-        &self, vec: &'ll Value,\n-        elt: &'ll Value,\n-        idx: &'ll Value,\n-    ) -> &'ll Value {\n+        &self, vec: Self::Value,\n+        elt: Self::Value,\n+        idx: Self::Value,\n+    ) -> Self::Value {\n         self.count_insn(\"insertelement\");\n         unsafe {\n             llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n         }\n     }\n \n-    fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n+    fn shuffle_vector(&self, v1: Self::Value, v2: Self::Value, mask: Self::Value) -> Self::Value {\n         self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n-    fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n+    fn vector_splat(&self, num_elts: usize, elt: Self::Value) -> Self::Value {\n         unsafe {\n             let elt_ty = val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(Type::vector(elt_ty, num_elts as u64));\n+            let undef = llvm::LLVMGetUndef(type_::Type::vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n-            let vec_i32_ty = Type::vector(Type::i32(self.cx), num_elts as u64);\n+            let vec_i32_ty = type_::Type::vector(type_::Type::i32(self.cx), num_elts as u64);\n             self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n \n-    fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fadd_fast(&self, acc: Self::Value, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n@@ -872,7 +874,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n             instr\n         }\n     }\n-    fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmul_fast(&self, acc: Self::Value, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n@@ -883,69 +885,69 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n             instr\n         }\n     }\n-    fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_add(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.add\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n     }\n-    fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_mul(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.mul\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n     }\n-    fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_and(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.and\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n     }\n-    fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_or(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.or\");\n         unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n     }\n-    fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_xor(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.xor\");\n         unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n     }\n-    fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmin(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.fmin\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n-    fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmax(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.fmax\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n-    fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmin_fast(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmax_fast(&self, src: Self::Value) -> Self::Value {\n         self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+    fn vector_reduce_min(&self, src: Self::Value, is_signed: bool) -> Self::Value {\n         self.count_insn(\"vector.reduce.min\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n     }\n-    fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+    fn vector_reduce_max(&self, src: Self::Value, is_signed: bool) -> Self::Value {\n         self.count_insn(\"vector.reduce.max\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n     }\n \n-    fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n+    fn extract_value(&self, agg_val: Self::Value, idx: u64) -> Self::Value {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n-    fn insert_value(&self, agg_val: &'ll Value, elt: &'ll Value,\n-                       idx: u64) -> &'ll Value {\n+    fn insert_value(&self, agg_val: Self::Value, elt: Self::Value,\n+                       idx: u64) -> Self::Value {\n         self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n@@ -954,38 +956,38 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn landing_pad(&self, ty: &'ll Type, pers_fn: &'ll Value,\n-                       num_clauses: usize) -> &'ll Value {\n+    fn landing_pad(&self, ty: Self::Type, pers_fn: Self::Value,\n+                       num_clauses: usize) -> Self::Value {\n         self.count_insn(\"landingpad\");\n         unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n                                       num_clauses as c_uint, noname())\n         }\n     }\n \n-    fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value) {\n+    fn add_clause(&self, landing_pad: Self::Value, clause: Self::Value) {\n         unsafe {\n             llvm::LLVMAddClause(landing_pad, clause);\n         }\n     }\n \n-    fn set_cleanup(&self, landing_pad: &'ll Value) {\n+    fn set_cleanup(&self, landing_pad: Self::Value) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n-    fn resume(&self, exn: &'ll Value) -> &'ll Value {\n+    fn resume(&self, exn: Self::Value) -> Self::Value {\n         self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n     }\n \n     fn cleanup_pad(&self,\n-                       parent: Option<&'ll Value>,\n-                       args: &[&'ll Value]) -> &'ll Value {\n+                       parent: Option<Self::Value>,\n+                       args: &[Self::Value]) -> Self::Value {\n         self.count_insn(\"cleanuppad\");\n         let name = const_cstr!(\"cleanuppad\");\n         let ret = unsafe {\n@@ -999,9 +1001,9 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n     fn cleanup_ret(\n-        &self, cleanup: &'ll Value,\n-        unwind: Option<&'ll BasicBlock>,\n-    ) -> &'ll Value {\n+        &self, cleanup: Self::Value,\n+        unwind: Option<Self::BasicBlock>,\n+    ) -> Self::Value {\n         self.count_insn(\"cleanupret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n@@ -1010,8 +1012,8 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     }\n \n     fn catch_pad(&self,\n-                     parent: &'ll Value,\n-                     args: &[&'ll Value]) -> &'ll Value {\n+                     parent: Self::Value,\n+                     args: &[Self::Value]) -> Self::Value {\n         self.count_insn(\"catchpad\");\n         let name = const_cstr!(\"catchpad\");\n         let ret = unsafe {\n@@ -1022,7 +1024,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         ret.expect(\"LLVM does not have support for catchpad\")\n     }\n \n-    fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value {\n+    fn catch_ret(&self, pad: Self::Value, unwind: Self::BasicBlock) -> Self::Value {\n         self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, pad, unwind)\n@@ -1032,10 +1034,10 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n \n     fn catch_switch(\n         &self,\n-        parent: Option<&'ll Value>,\n-        unwind: Option<&'ll BasicBlock>,\n+        parent: Option<Self::Value>,\n+        unwind: Option<Self::BasicBlock>,\n         num_handlers: usize,\n-    ) -> &'ll Value {\n+    ) -> Self::Value {\n         self.count_insn(\"catchswitch\");\n         let name = const_cstr!(\"catchswitch\");\n         let ret = unsafe {\n@@ -1046,13 +1048,13 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         ret.expect(\"LLVM does not have support for catchswitch\")\n     }\n \n-    fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n+    fn add_handler(&self, catch_switch: Self::Value, handler: Self::BasicBlock) {\n         unsafe {\n             llvm::LLVMRustAddHandler(catch_switch, handler);\n         }\n     }\n \n-    fn set_personality_fn(&self, personality: &'ll Value) {\n+    fn set_personality_fn(&self, personality: Self::Value) {\n         unsafe {\n             llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n         }\n@@ -1061,13 +1063,13 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     // Atomic Operations\n     fn atomic_cmpxchg(\n         &self,\n-        dst: &'ll Value,\n-        cmp: &'ll Value,\n-        src: &'ll Value,\n+        dst: Self::Value,\n+        cmp: Self::Value,\n+        src: Self::Value,\n         order: traits::AtomicOrdering,\n         failure_order: traits::AtomicOrdering,\n         weak: bool,\n-    ) -> &'ll Value {\n+    ) -> Self::Value {\n         let weak = if weak { llvm::True } else { llvm::False };\n         unsafe {\n             llvm::LLVMRustBuildAtomicCmpXchg(\n@@ -1084,10 +1086,10 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     fn atomic_rmw(\n         &self,\n         op: traits::AtomicRmwBinOp,\n-        dst: &'ll Value,\n-        src: &'ll Value,\n+        dst: Self::Value,\n+        src: Self::Value,\n         order: traits::AtomicOrdering,\n-    ) -> &'ll Value {\n+    ) -> Self::Value {\n         unsafe {\n             llvm::LLVMBuildAtomicRMW(\n                 self.llbuilder,\n@@ -1109,20 +1111,20 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n+    fn add_case(&self, s: Self::Value, on_val: Self::Value, dest: Self::BasicBlock) {\n         unsafe {\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n-    fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n+    fn add_incoming_to_phi(&self, phi: Self::Value, val: Self::Value, bb: Self::BasicBlock) {\n         self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n \n-    fn set_invariant_load(&self, load: &'ll Value) {\n+    fn set_invariant_load(&self, load: Self::Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n@@ -1131,8 +1133,8 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n \n     /// Returns the ptr value that should be used for storing `val`.\n     fn check_store<'b>(&self,\n-                       val: &'ll Value,\n-                       ptr: &'ll Value) -> &'ll Value {\n+                       val: Self::Value,\n+                       ptr: Self::Value) -> Self::Value {\n         let dest_ptr_ty = val_ty(ptr);\n         let stored_ty = val_ty(val);\n         let stored_ptr_ty = stored_ty.ptr_to();\n@@ -1152,8 +1154,8 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     /// Returns the args that should be used for a call to `llfn`.\n     fn check_call<'b>(&self,\n                       typ: &str,\n-                      llfn: &'ll Value,\n-                      args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n+                      llfn: Self::Value,\n+                      args: &'b [Self::Value]) -> Cow<'b, [Self::Value]> {\n         let mut fn_ty = val_ty(llfn);\n         // Strip off pointers\n         while fn_ty.kind() == llvm::TypeKind::Pointer {\n@@ -1192,11 +1194,11 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         Cow::Owned(casted_args)\n     }\n \n-    fn lifetime_start(&self, ptr: &'ll Value, size: Size) {\n+    fn lifetime_start(&self, ptr: Self::Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n     }\n \n-    fn lifetime_end(&self, ptr: &'ll Value, size: Size) {\n+    fn lifetime_end(&self, ptr: Self::Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n     }\n \n@@ -1208,7 +1210,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     ///\n     /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n     /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n+    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: Self::Value, size: Size) {\n         if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;\n         }\n@@ -1220,12 +1222,12 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n \n         let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n \n-        let ptr = self.pointercast(ptr, Type::i8p(self.cx));\n+        let ptr = self.pointercast(ptr, type_::Type::i8p(self.cx));\n         self.call(lifetime_intrinsic, &[C_u64(self.cx, size), ptr], None);\n     }\n \n-    fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n-                bundle: Option<&traits::OperandBundleDef<'ll, &'ll Value>>) -> &'ll Value {\n+    fn call(&self, llfn: Self::Value, args: &[Self::Value],\n+                bundle: Option<&traits::OperandBundleDef<'ll, Self::Value>>) -> Self::Value {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {:?} with args ({:?})\",\n@@ -1247,14 +1249,14 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn zext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n         self.count_insn(\"zext\");\n         unsafe {\n             llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n+    fn struct_gep(&self, ptr: Self::Value, idx: u64) -> Self::Value {\n         self.count_insn(\"structgep\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {"}, {"sha": "b8505ba128136acb7a249c0e72f328b0df7e85ac", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89825f2ef5f76c680306378f139a88e2f45c0843/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89825f2ef5f76c680306378f139a88e2f45c0843/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=89825f2ef5f76c680306378f139a88e2f45c0843", "patch": "@@ -22,7 +22,6 @@ use type_::Type;\n use glue;\n \n use traits::BuilderMethods;\n-use llvm::BasicBlock;\n \n use std::fmt;\n \n@@ -280,9 +279,7 @@ impl OperandValue<&'ll Value> {\n     }\n }\n \n-impl<'a, 'll: 'a, 'tcx: 'll> OperandValue<&'ll Value> where\n-    Builder<'a, 'll, 'tcx>: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n-{\n+impl<'a, 'll: 'a, 'tcx: 'll> OperandValue<&'ll Value> {\n     pub fn nontemporal_store(\n         self,\n         bx: &Builder<'a, 'll, 'tcx>,\n@@ -291,9 +288,9 @@ impl<'a, 'll: 'a, 'tcx: 'll> OperandValue<&'ll Value> where\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n \n-    fn store_with_flags<Builder: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>>(\n+    fn store_with_flags(\n         self,\n-        bx: &Builder,\n+        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n         dest: PlaceRef<'tcx, &'ll Value>,\n         flags: MemFlags,\n     ) {"}, {"sha": "417c900b127aff31d347b1d044a7c6a81331a806", "filename": "src/librustc_codegen_llvm/traits.rs", "status": "modified", "additions": 174, "deletions": 175, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/89825f2ef5f76c680306378f139a88e2f45c0843/src%2Flibrustc_codegen_llvm%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89825f2ef5f76c680306378f139a88e2f45c0843/src%2Flibrustc_codegen_llvm%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftraits.rs?ref=89825f2ef5f76c680306378f139a88e2f45c0843", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use common::*;\n-use type_::Type;\n use libc::c_char;\n use rustc::ty::TyCtxt;\n use rustc::ty::layout::{Align, Size};\n@@ -103,265 +102,265 @@ pub enum SynchronizationScope {\n }\n \n \n-pub trait BuilderMethods<'a, 'll :'a, 'tcx: 'll,\n-    Value : ?Sized,\n-    BasicBlock: ?Sized\n-    > {\n+pub trait BuilderMethods<'a, 'll :'a, 'tcx: 'll> {\n+    type Value;\n+    type BasicBlock;\n+    type Type;\n \n     fn new_block<'b>(\n-        cx: &'a CodegenCx<'ll, 'tcx>,\n-        llfn: &'ll Value,\n+        cx: &'a CodegenCx<'ll, 'tcx, Self::Value>,\n+        llfn: Self::Value,\n         name: &'b str\n     ) -> Self;\n-    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self;\n+    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx, Self::Value>) -> Self;\n     fn build_sibling_block<'b>(&self, name: &'b str) -> Self;\n     fn sess(&self) -> &Session;\n-    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx>;\n+    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx, Self::Value>;\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-    fn llfn(&self) -> &'ll Value;\n-    fn llbb(&self) -> &'ll BasicBlock;\n+    fn llfn(&self) -> Self::Value;\n+    fn llbb(&self) -> Self::BasicBlock;\n     fn count_insn(&self, category: &str);\n \n-    fn set_value_name(&self, value: &'ll Value, name: &str);\n-    fn position_at_end(&self, llbb: &'ll BasicBlock);\n-    fn position_at_start(&self, llbb: &'ll BasicBlock);\n+    fn set_value_name(&self, value: Self::Value, name: &str);\n+    fn position_at_end(&self, llbb: Self::BasicBlock);\n+    fn position_at_start(&self, llbb: Self::BasicBlock);\n     fn ret_void(&self);\n-    fn ret(&self, v: &'ll Value);\n-    fn br(&self, dest: &'ll BasicBlock);\n+    fn ret(&self, v: Self::Value);\n+    fn br(&self, dest: Self::BasicBlock);\n     fn cond_br(\n         &self,\n-        cond: &'ll Value,\n-        then_llbb: &'ll BasicBlock,\n-        else_llbb: &'ll BasicBlock,\n+        cond: Self::Value,\n+        then_llbb: Self::BasicBlock,\n+        else_llbb: Self::BasicBlock,\n     );\n     fn switch(\n         &self,\n-        v: &'ll Value,\n-        else_llbb: &'ll BasicBlock,\n+        v: Self::Value,\n+        else_llbb: Self::BasicBlock,\n         num_cases: usize,\n-    ) -> &'ll Value;\n+    ) -> Self::Value;\n     fn invoke(\n         &self,\n-        llfn: &'ll Value,\n-        args: &[&'ll Value],\n-        then: &'ll BasicBlock,\n-        catch: &'ll BasicBlock,\n-        bundle: Option<&OperandBundleDef<'ll, &'ll Value>>\n-    ) -> &'ll Value;\n+        llfn: Self::Value,\n+        args: &[Self::Value],\n+        then: Self::BasicBlock,\n+        catch: Self::BasicBlock,\n+        bundle: Option<&OperandBundleDef<'ll, Self::Value>>\n+    ) -> Self::Value;\n     fn unreachable(&self);\n-    fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn neg(&self, v: &'ll Value) -> &'ll Value;\n-    fn fneg(&self, v: &'ll Value) -> &'ll Value;\n-    fn not(&self, v: &'ll Value) -> &'ll Value;\n+    fn add(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fadd(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fadd_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn sub(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fsub(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fsub_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn mul(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fmul(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fmul_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn udiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn exactudiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn sdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn exactsdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fdiv_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn urem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn srem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn frem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn frem_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn shl(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn lshr(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn ashr(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn and(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn or(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn xor(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn neg(&self, v: Self::Value) -> Self::Value;\n+    fn fneg(&self, v: Self::Value) -> Self::Value;\n+    fn not(&self, v: Self::Value) -> Self::Value;\n \n-    fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value;\n-    fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value;\n+    fn alloca(&self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n+    fn dynamic_alloca(&self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n     fn array_alloca(\n         &self,\n-        ty: &'ll Type,\n-        len: &'ll Value,\n+        ty: Self::Type,\n+        len: Self::Value,\n         name: &str,\n         align: Align\n-    ) -> &'ll Value;\n+    ) -> Self::Value;\n \n-    fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value;\n-    fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value;\n-    fn atomic_load(&self, ptr: &'ll Value, order: AtomicOrdering, size: Size) -> &'ll Value;\n+    fn load(&self, ptr: Self::Value, align: Align) -> Self::Value;\n+    fn volatile_load(&self, ptr: Self::Value) -> Self::Value;\n+    fn atomic_load(&self, ptr: Self::Value, order: AtomicOrdering, size: Size) -> Self::Value;\n \n-    fn range_metadata(&self, load: &'ll Value, range: Range<u128>);\n-    fn nonnull_metadata(&self, load: &'ll Value);\n+    fn range_metadata(&self, load: Self::Value, range: Range<u128>);\n+    fn nonnull_metadata(&self, load: Self::Value);\n \n-    fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value;\n+    fn store(&self, val: Self::Value, ptr: Self::Value, align: Align) -> Self::Value;\n     fn store_with_flags(\n         &self,\n-        val: &'ll Value,\n-        ptr: &'ll Value,\n+        val: Self::Value,\n+        ptr: Self::Value,\n         align: Align,\n         flags: MemFlags,\n-    ) -> &'ll Value;\n+    ) -> Self::Value;\n     fn atomic_store(\n         &self,\n-        val: &'ll Value,\n-        ptr: &'ll Value,\n+        val: Self::Value,\n+        ptr: Self::Value,\n         order: AtomicOrdering,\n         size: Size\n     );\n \n-    fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value;\n-    fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value;\n-    fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value;\n+    fn gep(&self, ptr: Self::Value, indices: &[Self::Value]) -> Self::Value;\n+    fn inbounds_gep(&self, ptr: Self::Value, indices: &[Self::Value]) -> Self::Value;\n+    fn struct_gep(&self, ptr: Self::Value, idx: u64) -> Self::Value;\n \n-    fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n-    fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value;\n-    fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn trunc(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn sext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn fptoui(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn fptosi(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn uitofp(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn sitofp(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn fptrunc(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn fpext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn ptrtoint(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn inttoptr(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn bitcast(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn intcast(&self, val: Self::Value, dest_ty: Self::Type, is_signed: bool) -> Self::Value;\n+    fn pointercast(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n \n-    fn icmp(&self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn fcmp(&self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn icmp(&self, op: IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn fcmp(&self, op: RealPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n \n-    fn empty_phi(&self, ty: &'ll Type) -> &'ll Value;\n-    fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value;\n+    fn empty_phi(&self, ty: Self::Type) -> Self::Value;\n+    fn phi(&self, ty: Self::Type, vals: &[Self::Value], bbs: &[Self::BasicBlock]) -> Self::Value;\n     fn inline_asm_call(\n         &self,\n         asm: *const c_char,\n         cons: *const c_char,\n-        inputs: &[&'ll Value],\n-        output: &'ll Type,\n+        inputs: &[Self::Value],\n+        output: Self::Type,\n         volatile: bool,\n         alignstack: bool,\n         dia: AsmDialect\n-    ) -> Option<&'ll Value>;\n+    ) -> Option<Self::Value>;\n \n \n-    fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n-                  src: &'ll Value, src_align: u64,\n-                  size: &'ll Value, is_volatile: bool) -> &'ll Value;\n-    fn memmove(&self, dst: &'ll Value, dst_align: u64,\n-                  src: &'ll Value, src_align: u64,\n-                  size: &'ll Value, is_volatile: bool) -> &'ll Value;\n+    fn memcpy(&self, dst: Self::Value, dst_align: u64,\n+                  src: Self::Value, src_align: u64,\n+                  size: Self::Value, is_volatile: bool) -> Self::Value;\n+    fn memmove(&self, dst: Self::Value, dst_align: u64,\n+                  src: Self::Value, src_align: u64,\n+                  size: Self::Value, is_volatile: bool) -> Self::Value;\n \n-    fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n-    fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn minnum(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n+    fn maxnum(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn select(\n-        &self, cond: &'ll Value,\n-        then_val: &'ll Value,\n-        else_val: &'ll Value,\n-    ) -> &'ll Value;\n+        &self, cond: Self::Value,\n+        then_val: Self::Value,\n+        else_val: Self::Value,\n+    ) -> Self::Value;\n \n-    fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value;\n-    fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value;\n+    fn va_arg(&self, list: Self::Value, ty: Self::Type) -> Self::Value;\n+    fn extract_element(&self, vec: Self::Value, idx: Self::Value) -> Self::Value;\n     fn insert_element(\n-        &self, vec: &'ll Value,\n-        elt: &'ll Value,\n-        idx: &'ll Value,\n-    ) -> &'ll Value;\n-    fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value;\n-    fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value;\n-    fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value;\n-    fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value;\n-    fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value;\n+        &self, vec: Self::Value,\n+        elt: Self::Value,\n+        idx: Self::Value,\n+    ) -> Self::Value;\n+    fn shuffle_vector(&self, v1: Self::Value, v2: Self::Value, mask: Self::Value) -> Self::Value;\n+    fn vector_splat(&self, num_elts: usize, elt: Self::Value) -> Self::Value;\n+    fn vector_reduce_fadd_fast(&self, acc: Self::Value, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_fmul_fast(&self, acc: Self::Value, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_add(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_mul(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_and(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_or(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_xor(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_fmin(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_fmax(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_fmin_fast(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_fmax_fast(&self, src: Self::Value) -> Self::Value;\n+    fn vector_reduce_min(&self, src: Self::Value, is_signed: bool) -> Self::Value;\n+    fn vector_reduce_max(&self, src: Self::Value, is_signed: bool) -> Self::Value;\n+    fn extract_value(&self, agg_val: Self::Value, idx: u64) -> Self::Value;\n     fn insert_value(\n         &self,\n-        agg_val: &'ll Value,\n-        elt: &'ll Value,\n+        agg_val: Self::Value,\n+        elt: Self::Value,\n         idx: u64\n-    ) -> &'ll Value;\n+    ) -> Self::Value;\n \n     fn landing_pad(\n         &self,\n-        ty: &'ll Type,\n-        pers_fn: &'ll Value,\n+        ty: Self::Type,\n+        pers_fn: Self::Value,\n         num_clauses: usize\n-    ) -> &'ll Value;\n-    fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value);\n-    fn set_cleanup(&self, landing_pad: &'ll Value);\n-    fn resume(&self, exn: &'ll Value) -> &'ll Value;\n+    ) -> Self::Value;\n+    fn add_clause(&self, landing_pad: Self::Value, clause: Self::Value);\n+    fn set_cleanup(&self, landing_pad: Self::Value);\n+    fn resume(&self, exn: Self::Value) -> Self::Value;\n     fn cleanup_pad(\n         &self,\n-        parent: Option<&'ll Value>,\n-        args: &[&'ll Value]\n-    ) -> &'ll Value;\n+        parent: Option<Self::Value>,\n+        args: &[Self::Value]\n+    ) -> Self::Value;\n     fn cleanup_ret(\n-        &self, cleanup: &'ll Value,\n-        unwind: Option<&'ll BasicBlock>,\n-    ) -> &'ll Value;\n+        &self, cleanup: Self::Value,\n+        unwind: Option<Self::BasicBlock>,\n+    ) -> Self::Value;\n     fn catch_pad(\n         &self,\n-        parent: &'ll Value,\n-        args: &[&'ll Value]\n-    ) -> &'ll Value;\n-    fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value;\n+        parent: Self::Value,\n+        args: &[Self::Value]\n+    ) -> Self::Value;\n+    fn catch_ret(&self, pad: Self::Value, unwind: Self::BasicBlock) -> Self::Value;\n     fn catch_switch(\n         &self,\n-        parent: Option<&'ll Value>,\n-        unwind: Option<&'ll BasicBlock>,\n+        parent: Option<Self::Value>,\n+        unwind: Option<Self::BasicBlock>,\n         num_handlers: usize,\n-    ) -> &'ll Value;\n-    fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock);\n-    fn set_personality_fn(&self, personality: &'ll Value);\n+    ) -> Self::Value;\n+    fn add_handler(&self, catch_switch: Self::Value, handler: Self::BasicBlock);\n+    fn set_personality_fn(&self, personality: Self::Value);\n \n     fn atomic_cmpxchg(\n         &self,\n-        dst: &'ll Value,\n-        cmp: &'ll Value,\n-        src: &'ll Value,\n+        dst: Self::Value,\n+        cmp: Self::Value,\n+        src: Self::Value,\n         order: AtomicOrdering,\n         failure_order: AtomicOrdering,\n         weak: bool,\n-    ) -> &'ll Value;\n+    ) -> Self::Value;\n     fn atomic_rmw(\n         &self,\n         op: AtomicRmwBinOp,\n-        dst: &'ll Value,\n-        src: &'ll Value,\n+        dst: Self::Value,\n+        src: Self::Value,\n         order: AtomicOrdering,\n-    ) -> &'ll Value;\n+    ) -> Self::Value;\n     fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope);\n-    fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock);\n-    fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock);\n-    fn set_invariant_load(&self, load: &'ll Value);\n+    fn add_case(&self, s: Self::Value, on_val: Self::Value, dest: Self::BasicBlock);\n+    fn add_incoming_to_phi(&self, phi: Self::Value, val: Self::Value, bb: Self::BasicBlock);\n+    fn set_invariant_load(&self, load: Self::Value);\n \n     fn check_store(\n         &self,\n-        val: &'ll Value,\n-        ptr: &'ll Value\n-    ) -> &'ll Value;\n+        val: Self::Value,\n+        ptr: Self::Value\n+    ) -> Self::Value;\n     fn check_call<'b>(\n         &self,\n         typ: &str,\n-        llfn: &'ll Value,\n-        args: &'b [&'ll Value]\n-    ) -> Cow<'b, [&'ll Value]>;\n-    fn lifetime_start(&self, ptr: &'ll Value, size: Size);\n-    fn lifetime_end(&self, ptr: &'ll Value, size: Size);\n+        llfn: Self::Value,\n+        args: &'b [Self::Value]\n+    ) -> Cow<'b, [Self::Value]> where [Self::Value] : ToOwned;\n+    fn lifetime_start(&self, ptr: Self::Value, size: Size);\n+    fn lifetime_end(&self, ptr: Self::Value, size: Size);\n \n-    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: &'ll Value, size: Size);\n+    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: Self::Value, size: Size);\n \n-    fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n-                bundle: Option<&OperandBundleDef<'ll, &'ll Value>>) -> &'ll Value;\n-    fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn call(&self, llfn: Self::Value, args: &[Self::Value],\n+                bundle: Option<&OperandBundleDef<'ll, Self::Value>>) -> Self::Value;\n+    fn zext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n }"}]}