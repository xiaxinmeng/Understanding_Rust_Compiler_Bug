{"sha": "e4c3b49fe790dd23f32acace8157d897d31c0cb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YzNiNDlmZTc5MGRkMjNmMzJhY2FjZTgxNTdkODk3ZDMxYzBjYjM=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-09T22:23:08Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-11T20:08:24Z"}, "message": "Emit an error during parsing", "tree": {"sha": "2a7cc6356768ea527ea54277eea867dea2cefdcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a7cc6356768ea527ea54277eea867dea2cefdcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4c3b49fe790dd23f32acace8157d897d31c0cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c3b49fe790dd23f32acace8157d897d31c0cb3", "html_url": "https://github.com/rust-lang/rust/commit/e4c3b49fe790dd23f32acace8157d897d31c0cb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4c3b49fe790dd23f32acace8157d897d31c0cb3/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a478cd41e3f203ec531bfce7efb8fc602aad5c7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a478cd41e3f203ec531bfce7efb8fc602aad5c7d", "html_url": "https://github.com/rust-lang/rust/commit/a478cd41e3f203ec531bfce7efb8fc602aad5c7d"}], "stats": {"total": 134, "additions": 74, "deletions": 60}, "files": [{"sha": "e15dab404f4784f531d4d05f394acf40b04ea04a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3b49fe790dd23f32acace8157d897d31c0cb3/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3b49fe790dd23f32acace8157d897d31c0cb3/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=e4c3b49fe790dd23f32acace8157d897d31c0cb3", "patch": "@@ -336,24 +336,19 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n                         self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness);\n                         self.check_trait_fn_not_const(sig.header.constness);\n-                        self.check_decl_no_pat(&sig.decl, |span, mut_ident| {\n-                            if mut_ident {\n-                                if block.is_none() {\n+                        if block.is_none() {\n+                            self.check_decl_no_pat(&sig.decl, |span, mut_ident| {\n+                                if mut_ident {\n                                     self.session.buffer_lint(\n                                         lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n                                         trait_item.id, span,\n                                         \"patterns aren't allowed in trait methods\");\n+                                } else {\n+                                    struct_span_err!(self.session, span, E0642,\n+                                        \"patterns aren't allowed in trait methods\").emit();\n                                 }\n-                            } else {\n-                                let mut err = struct_span_err!(self.session, span, E0642,\n-                                    \"patterns aren't allowed in trait methods\");\n-                                let suggestion = \"give this argument a name or use an \\\n-                                                  underscore to ignore it instead of using a \\\n-                                                  tuple pattern\";\n-                                err.span_suggestion(span, suggestion, \"_\".to_owned());\n-                                err.emit();\n-                            }\n-                        });\n+                            });\n+                        }\n                     }\n                 }\n             }"}, {"sha": "9a49d705c464b99ceda35bcb521cd162386f3583", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 62, "deletions": 42, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3b49fe790dd23f32acace8157d897d31c0cb3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3b49fe790dd23f32acace8157d897d31c0cb3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e4c3b49fe790dd23f32acace8157d897d31c0cb3", "patch": "@@ -1744,54 +1744,74 @@ impl<'a> Parser<'a> {\n     fn parse_arg_general(&mut self, require_name: bool) -> PResult<'a, Arg> {\n         maybe_whole!(self, NtArg, |x| x);\n \n-        // If we see `ident :`, then we know that the argument is not just of the\n-        // form `type`, which means we won't need to recover from parsing a\n-        // pattern and so we don't need to store a parser snapshot.\n-        let parser_snapshot_before_pat = if\n-            self.look_ahead(1, |t| t.is_ident()) &&\n-            self.look_ahead(2, |t| t == &token::Colon) {\n-                None\n-            } else {\n-                Some(self.clone())\n-            };\n-\n-        // We're going to try parsing the argument as a pattern (even if it's not\n-        // allowed, such as for trait methods without bodies). This way we can provide\n-        // better errors to the user.\n-        let pat_arg: PResult<'a, (P<Pat>, P<Ty>)> = do catch {\n+        let (pat, ty) = if require_name || self.is_named_argument() {\n+            debug!(\"parse_arg_general parse_pat (require_name:{})\",\n+                   require_name);\n             let pat = self.parse_pat()?;\n+\n             self.expect(&token::Colon)?;\n             (pat, self.parse_ty()?)\n-        };\n+        } else {\n+            debug!(\"parse_arg_general ident_to_pat\");\n+\n+            // If we see `ident :`, then we know that the argument is not just of the\n+            // form `type`, which means we won't need to recover from parsing a\n+            // pattern and so we don't need to store a parser snapshot.\n+            let parser_snapshot_before_pat = if\n+                self.look_ahead(1, |t| t.is_ident()) &&\n+                self.look_ahead(2, |t| t == &token::Colon) {\n+                    None\n+                } else {\n+                    Some(self.clone())\n+                };\n \n-        match pat_arg {\n-            Ok((pat, ty)) => {\n-                Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n-            }\n-            Err(mut err) => {\n-                match (require_name || self.is_named_argument(), parser_snapshot_before_pat) {\n-                    (true, _) | (_, None) => {\n-                        Err(err)\n-                    }\n-                    (false, Some(parser_snapshot_before_pat)) => {\n-                        err.cancel();\n-                        // Recover from attempting to parse the argument as a pattern. This means\n-                        // the type is alone, with no name, e.g. `fn foo(u32)`.\n-                        mem::replace(self, parser_snapshot_before_pat);\n-                        debug!(\"parse_arg_general ident_to_pat\");\n-                        let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n-                        let ty = self.parse_ty()?;\n-                        let pat = P(Pat {\n-                            id: ast::DUMMY_NODE_ID,\n-                            node: PatKind::Ident(\n-                                BindingMode::ByValue(Mutability::Immutable), ident, None),\n-                            span: ty.span,\n-                        });\n-                        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n-                    }\n+            // We're going to try parsing the argument as a pattern (even though it's not\n+            // allowed). This way we can provide better errors to the user.\n+            let pat_arg: PResult<'a, _> = do catch {\n+                let pat = self.parse_pat()?;\n+                self.expect(&token::Colon)?;\n+                (pat, self.parse_ty()?)\n+            };\n+\n+            match pat_arg {\n+                Ok((pat, ty)) => {\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(pat.span, \"patterns aren't allowed in trait methods\");\n+                    err.span_suggestion_short_with_applicability(\n+                        pat.span,\n+                        \"give this argument a name or use an underscore to ignore it\",\n+                        \"_\".to_owned(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    err.emit();\n+                    // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n+                    let pat = P(Pat {\n+                        node: PatKind::Wild,\n+                        span: pat.span,\n+                        id: ast::DUMMY_NODE_ID\n+                    });\n+                    (pat, ty)\n+                }\n+                Err(mut err) => {\n+                    err.cancel();\n+                    // Recover from attempting to parse the argument as a pattern. This means\n+                    // the type is alone, with no name, e.g. `fn foo(u32)`.\n+                    mem::replace(self, parser_snapshot_before_pat.unwrap());\n+                    debug!(\"parse_arg_general ident_to_pat\");\n+                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n+                    let ty = self.parse_ty()?;\n+                    let pat = P(Pat {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: PatKind::Ident(\n+                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n+                        span: ty.span,\n+                    });\n+                    (pat, ty)\n                 }\n             }\n-        }\n+        };\n+\n+        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n     }\n \n     /// Parse a single function argument"}, {"sha": "b8e0496945a15892781c0ebcb49b62b3f8a9550b", "filename": "src/test/ui/E0642.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3b49fe790dd23f32acace8157d897d31c0cb3/src%2Ftest%2Fui%2FE0642.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3b49fe790dd23f32acace8157d897d31c0cb3/src%2Ftest%2Fui%2FE0642.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0642.stderr?ref=e4c3b49fe790dd23f32acace8157d897d31c0cb3", "patch": "@@ -1,23 +1,22 @@\n-error[E0642]: patterns aren't allowed in trait methods\n+error: patterns aren't allowed in trait methods\n   --> $DIR/E0642.rs:12:12\n    |\n LL |     fn foo((x, y): (i32, i32)); //~ ERROR patterns aren't allowed in trait methods\n    |            ^^^^^^\n-help: give this argument a name or use an underscore to ignore it instead of using a tuple pattern\n+help: give this argument a name or use an underscore to ignore it\n    |\n LL |     fn foo(_: (i32, i32)); //~ ERROR patterns aren't allowed in trait methods\n    |            ^\n \n-error[E0642]: patterns aren't allowed in trait methods\n+error: patterns aren't allowed in trait methods\n   --> $DIR/E0642.rs:16:12\n    |\n LL |     fn bar((x, y): (i32, i32)) {} //~ ERROR patterns aren't allowed in trait methods\n    |            ^^^^^^\n-help: give this argument a name or use an underscore to ignore it instead of using a tuple pattern\n+help: give this argument a name or use an underscore to ignore it\n    |\n LL |     fn bar(_: (i32, i32)) {} //~ ERROR patterns aren't allowed in trait methods\n    |            ^\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0642`."}]}