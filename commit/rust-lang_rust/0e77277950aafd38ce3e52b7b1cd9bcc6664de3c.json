{"sha": "0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNzcyNzc5NTBhYWZkMzhjZTNlNTJiN2IxY2Q5YmNjNjY2NGRlM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-19T17:52:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-19T17:52:54Z"}, "message": "Auto merge of #39939 - petrochenkov:regres, r=eddyb\n\nFix two ICEs in path resolution\n\nFixes https://github.com/rust-lang/rust/issues/39535\nFixes https://github.com/rust-lang/rust/issues/39559\nFixes https://github.com/rust-lang/rust/issues/39924\n\nr? @eddyb", "tree": {"sha": "6049b4bf74d73527fd758028a375e1bd00b74351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6049b4bf74d73527fd758028a375e1bd00b74351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "html_url": "https://github.com/rust-lang/rust/commit/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0128be9ad70970829420ed498d2f2943a72e1b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/0128be9ad70970829420ed498d2f2943a72e1b62", "html_url": "https://github.com/rust-lang/rust/commit/0128be9ad70970829420ed498d2f2943a72e1b62"}, {"sha": "8c7d0077ab51a076d79ff8e91d7845e745f90b21", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7d0077ab51a076d79ff8e91d7845e745f90b21", "html_url": "https://github.com/rust-lang/rust/commit/8c7d0077ab51a076d79ff8e91d7845e745f90b21"}], "stats": {"total": 184, "additions": 119, "deletions": 65}, "files": [{"sha": "53b7be74f85037dcaea5d9e7c362f0413d41447b", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "patch": "@@ -59,32 +59,45 @@ pub enum Def {\n     Err,\n }\n \n-/// The result of resolving a path.\n-/// Before type checking completes, `depth` represents the number of\n-/// trailing segments which are yet unresolved. Afterwards, if there\n-/// were no errors, all paths should be fully resolved, with `depth`\n-/// set to `0` and `base_def` representing the final resolution.\n-///\n+/// The result of resolving a path before lowering to HIR.\n+/// `base_def` is definition of resolved part of the\n+/// path, `unresolved_segments` is the number of unresolved\n+/// segments.\n ///     module::Type::AssocX::AssocY::MethodOrAssocType\n ///     ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-///     base_def      depth = 3\n+///     base_def      unresolved_segments = 3\n ///\n ///     <T as Trait>::AssocX::AssocY::MethodOrAssocType\n ///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n-///           base_def        depth = 2\n+///           base_def        unresolved_segments = 2\n #[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n-    pub base_def: Def,\n-    pub depth: usize\n+    base_def: Def,\n+    unresolved_segments: usize,\n }\n \n impl PathResolution {\n-    pub fn new(def: Def) -> PathResolution {\n-        PathResolution { base_def: def, depth: 0 }\n+    pub fn new(def: Def) -> Self {\n+        PathResolution { base_def: def, unresolved_segments: 0 }\n+    }\n+\n+    pub fn with_unresolved_segments(def: Def, mut unresolved_segments: usize) -> Self {\n+        if def == Def::Err { unresolved_segments = 0 }\n+        PathResolution { base_def: def, unresolved_segments: unresolved_segments }\n+    }\n+\n+    #[inline]\n+    pub fn base_def(&self) -> Def {\n+        self.base_def\n+    }\n+\n+    #[inline]\n+    pub fn unresolved_segments(&self) -> usize {\n+        self.unresolved_segments\n     }\n \n     pub fn kind_name(&self) -> &'static str {\n-        if self.depth != 0 {\n+        if self.unresolved_segments != 0 {\n             \"associated item\"\n         } else {\n             self.base_def.kind_name()"}, {"sha": "c87ce6505fcd505e81bff483904cec8e691ff254", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "patch": "@@ -217,10 +217,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn expect_full_def(&mut self, id: NodeId) -> Def {\n         self.resolver.get_resolution(id).map_or(Def::Err, |pr| {\n-            if pr.depth != 0 {\n+            if pr.unresolved_segments() != 0 {\n                 bug!(\"path not fully resolved: {:?}\", pr);\n             }\n-            pr.base_def\n+            pr.base_def()\n         })\n     }\n \n@@ -421,9 +421,9 @@ impl<'a> LoweringContext<'a> {\n         let resolution = self.resolver.get_resolution(id)\n                                       .unwrap_or(PathResolution::new(Def::Err));\n \n-        let proj_start = p.segments.len() - resolution.depth;\n+        let proj_start = p.segments.len() - resolution.unresolved_segments();\n         let path = P(hir::Path {\n-            def: resolution.base_def,\n+            def: resolution.base_def(),\n             segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n                 let param_mode = match (qself_position, param_mode) {\n                     (Some(j), ParamMode::Optional) if i < j => {\n@@ -443,7 +443,7 @@ impl<'a> LoweringContext<'a> {\n                         index: this.def_key(def_id).parent.expect(\"missing parent\")\n                     }\n                 };\n-                let type_def_id = match resolution.base_def {\n+                let type_def_id = match resolution.base_def() {\n                     Def::AssociatedTy(def_id) if i + 2 == proj_start => {\n                         Some(parent_def_id(self, def_id))\n                     }\n@@ -474,7 +474,7 @@ impl<'a> LoweringContext<'a> {\n \n         // Simple case, either no projections, or only fully-qualified.\n         // E.g. `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if resolution.depth == 0 {\n+        if resolution.unresolved_segments() == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n \n@@ -749,7 +749,7 @@ impl<'a> LoweringContext<'a> {\n                                        bound_pred.bound_lifetimes.is_empty() => {\n                                 if let Some(Def::TyParam(def_id)) =\n                                         self.resolver.get_resolution(bound_pred.bounded_ty.id)\n-                                                     .map(|d| d.base_def) {\n+                                                     .map(|d| d.base_def()) {\n                                     if let Some(node_id) =\n                                             self.resolver.definitions().as_local_node_id(def_id) {\n                                         for ty_param in &g.ty_params {\n@@ -1295,7 +1295,7 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                     self.with_parent_def(p.id, |this| {\n-                        match this.resolver.get_resolution(p.id).map(|d| d.base_def) {\n+                        match this.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n                             // `None` can occur in body-less function signatures\n                             def @ None | def @ Some(Def::Local(_)) => {\n                                 let def_id = def.map(|d| d.def_id()).unwrap_or_else(|| {"}, {"sha": "c9e870188aaeccb36199b4d13a3d4178ff4961da", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "patch": "@@ -1195,7 +1195,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n         match self.resolve_path(&path, Some(namespace), Some(span)) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n-            PathResult::NonModule(path_res) if path_res.depth == 0 => *def = path_res.base_def,\n+            PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n+                *def = path_res.base_def(),\n             PathResult::NonModule(..) => match self.resolve_path(&path, None, Some(span)) {\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -1718,7 +1719,7 @@ impl<'a> Resolver<'a> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let def = self.smart_resolve_path(trait_ref.ref_id, None,\n-                                              &trait_ref.path, PathSource::Trait).base_def;\n+                                              &trait_ref.path, PathSource::Trait).base_def();\n             if def != Def::Err {\n                 new_val = Some((def.def_id(), trait_ref.clone()));\n                 new_id = Some(def.def_id());\n@@ -1849,8 +1850,8 @@ impl<'a> Resolver<'a> {\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.def_map.get(&pat.id) {\n-                    Some(&PathResolution { base_def: Def::Local(..), .. }) => true,\n+                if sub_pat.is_some() || match self.def_map.get(&pat.id).map(|res| res.base_def()) {\n+                    Some(Def::Local(..)) => true,\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n@@ -2248,14 +2249,14 @@ impl<'a> Resolver<'a> {\n         let resolution = match self.resolve_qpath_anywhere(id, qself, path, ns, span,\n                                                            source.defer_to_typeck(),\n                                                            source.global_by_default()) {\n-            Some(resolution) if resolution.depth == 0 => {\n-                if is_expected(resolution.base_def) || resolution.base_def == Def::Err {\n+            Some(resolution) if resolution.unresolved_segments() == 0 => {\n+                if is_expected(resolution.base_def()) || resolution.base_def() == Def::Err {\n                     resolution\n                 } else {\n                     // Add a temporary hack to smooth the transition to new struct ctor\n                     // visibility rules. See #38932 for more details.\n                     let mut res = None;\n-                    if let Def::Struct(def_id) = resolution.base_def {\n+                    if let Def::Struct(def_id) = resolution.base_def() {\n                         if let Some((ctor_def, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_def) && self.is_accessible(ctor_vis) {\n@@ -2268,7 +2269,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n \n-                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_def)))\n+                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_def())))\n                 }\n             }\n             Some(resolution) if source.defer_to_typeck() => {\n@@ -2321,7 +2322,8 @@ impl<'a> Resolver<'a> {\n                 match self.resolve_qpath(id, qself, path, ns, span, global_by_default) {\n                     // If defer_to_typeck, then resolution > no resolution,\n                     // otherwise full resolution > partial resolution > no resolution.\n-                    Some(res) if res.depth == 0 || defer_to_typeck => return Some(res),\n+                    Some(res) if res.unresolved_segments() == 0 || defer_to_typeck =>\n+                        return Some(res),\n                     res => if fin_res.is_none() { fin_res = res },\n                 };\n             }\n@@ -2346,19 +2348,17 @@ impl<'a> Resolver<'a> {\n         if let Some(qself) = qself {\n             if qself.position == 0 {\n                 // FIXME: Create some fake resolution that can't possibly be a type.\n-                return Some(PathResolution {\n-                    base_def: Def::Mod(DefId::local(CRATE_DEF_INDEX)),\n-                    depth: path.len(),\n-                });\n+                return Some(PathResolution::with_unresolved_segments(\n+                    Def::Mod(DefId::local(CRATE_DEF_INDEX)), path.len()\n+                ));\n             }\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n-            let mut res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                           span, PathSource::TraitItem(ns));\n-            if res.base_def != Def::Err {\n-                res.depth += path.len() - qself.position - 1;\n-            }\n-            return Some(res);\n+            let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n+                                                       span, PathSource::TraitItem(ns));\n+            return Some(PathResolution::with_unresolved_segments(\n+                res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n+            ));\n         }\n \n         let result = match self.resolve_path(&path, Some(ns), Some(span)) {\n@@ -2393,10 +2393,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => {}\n                 }\n-                PathResolution {\n-                    base_def: Def::PrimTy(prim),\n-                    depth: path.len() - 1,\n-                }\n+                PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n             PathResult::Failed(msg, false) => {\n@@ -2407,16 +2404,16 @@ impl<'a> Resolver<'a> {\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n-        if path.len() > 1 && !global_by_default && result.base_def != Def::Err &&\n+        if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n            path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n-                    PathResult::NonModule(path_res) => path_res.base_def,\n+                    PathResult::NonModule(path_res) => path_res.base_def(),\n                     PathResult::Module(module) => module.def().unwrap(),\n                     _ => return Some(result),\n                 }\n             };\n-            if result.base_def == unqualified_result {\n+            if result.base_def() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n                 self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n             }\n@@ -2470,10 +2467,9 @@ impl<'a> Resolver<'a> {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n-                        return PathResult::NonModule(PathResolution {\n-                            base_def: def,\n-                            depth: path.len() - 1,\n-                        });\n+                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                            def, path.len() - 1\n+                        ));\n                     }\n                     _ => Err(if record_used.is_some() { Determined } else { Undetermined }),\n                 }\n@@ -2488,10 +2484,9 @@ impl<'a> Resolver<'a> {\n                     } else if def == Def::Err {\n                         return PathResult::NonModule(err_path_resolution());\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        return PathResult::NonModule(PathResolution {\n-                            base_def: def,\n-                            depth: path.len() - i - 1,\n-                        });\n+                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                            def, path.len() - i - 1\n+                        ));\n                     } else {\n                         return PathResult::Failed(format!(\"Not a module `{}`\", ident), is_last);\n                     }\n@@ -2500,10 +2495,9 @@ impl<'a> Resolver<'a> {\n                 Err(Determined) => {\n                     if let Some(module) = module {\n                         if opt_ns.is_some() && !module.is_normal() {\n-                            return PathResult::NonModule(PathResolution {\n-                                base_def: module.def().unwrap(),\n-                                depth: path.len() - i,\n-                            });\n+                            return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                                module.def().unwrap(), path.len() - i\n+                            ));\n                         }\n                     }\n                     let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n@@ -2672,8 +2666,9 @@ impl<'a> Resolver<'a> {\n             if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n                 // Look for a field with the same name in the current self_type.\n                 if let Some(resolution) = self.def_map.get(&node_id) {\n-                    match resolution.base_def {\n-                        Def::Struct(did) | Def::Union(did) if resolution.depth == 0 => {\n+                    match resolution.base_def() {\n+                        Def::Struct(did) | Def::Union(did)\n+                                if resolution.unresolved_segments() == 0 => {\n                             if let Some(field_names) = self.field_names.get(&did) {\n                                 if field_names.iter().any(|&field_name| name == field_name) {\n                                     return Some(AssocSuggestion::Field);\n@@ -3057,7 +3052,6 @@ impl<'a> Resolver<'a> {\n \n     fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n-        assert!(resolution.depth == 0 || resolution.base_def != Def::Err);\n         if let Some(prev_res) = self.def_map.insert(node_id, resolution) {\n             panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n@@ -3071,7 +3065,8 @@ impl<'a> Resolver<'a> {\n                 ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n             ast::Visibility::Restricted { ref path, id } => {\n-                let def = self.smart_resolve_path(id, None, path, PathSource::Visibility).base_def;\n+                let def = self.smart_resolve_path(id, None, path,\n+                                                  PathSource::Visibility).base_def();\n                 if def == Def::Err {\n                     ty::Visibility::Public\n                 } else {"}, {"sha": "8d563d20549c3b8e78108d75231941ce3b54e358", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "patch": "@@ -262,7 +262,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n \n             let ext = match self.resolve_path(&path, Some(MacroNS), None) {\n-                PathResult::NonModule(path_res) => match path_res.base_def {\n+                PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => Ok(self.get_macro(def)),\n                 },"}, {"sha": "ab1897101eb6ffe683c7b1d69f4be3a956d8b147", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "patch": "@@ -918,7 +918,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait - we have a concrete self type and a\n                 // trait reference.\n-                let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+                // FIXME: Self type is not always computed when we are here because type parameter\n+                // bounds may affect Self type and have to be converted before it.\n+                let trait_ref = if impl_def_id.is_local() {\n+                    tcx.impl_trait_refs.borrow().get(&impl_def_id).cloned().and_then(|x| x)\n+                } else {\n+                    tcx.impl_trait_ref(impl_def_id)\n+                };\n+                let trait_ref = if let Some(trait_ref) = trait_ref {\n+                    trait_ref\n+                } else {\n+                    tcx.sess.span_err(span, \"`Self` type is used before it's determined\");\n+                    return (tcx.types.err, Def::Err);\n+                };\n                 let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n                     trait_ref.subst(tcx, free_substs)\n                 } else {"}, {"sha": "a56a5e8548944d01f8f7850cf4d9ccd00f53e079", "filename": "src/test/compile-fail/issue-39559.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Dim {\n+    fn dim() -> usize;\n+}\n+\n+enum Dim3 {}\n+\n+impl Dim for Dim3 {\n+    fn dim() -> usize {\n+        3\n+    }\n+}\n+\n+pub struct Vector<T, D: Dim> {\n+    entries: [T; D::dim()]\n+    //~^ ERROR cannot use an outer type parameter in this context\n+    //~| ERROR constant evaluation error\n+}\n+\n+fn main() {\n+    let array: [usize; Dim3::dim()] = [0; Dim3::dim()];\n+}"}, {"sha": "04f98c7ab329faa751bddadfe4598d3ac6974b39", "filename": "src/test/compile-fail/resolve-self-in-impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77277950aafd38ce3e52b7b1cd9bcc6664de3c/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs?ref=0e77277950aafd38ce3e52b7b1cd9bcc6664de3c", "patch": "@@ -18,9 +18,12 @@ impl<T: Tr<Self>> Tr<T> for S {} //~ ERROR `Self` type is used before it's deter\n impl<T = Self> Tr<T> for S {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S where Self: Copy {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S where S<Self>: Copy {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for S where Self::Assoc: Copy {} //~ ERROR `Self` type is used before it's determined\n+                                         //~^ ERROR `Self` type is used before it's determined\n impl Tr for Self {} //~ ERROR `Self` type is used before it's determined\n impl Tr for S<Self> {} //~ ERROR `Self` type is used before it's determined\n impl Self {} //~ ERROR `Self` type is used before it's determined\n impl S<Self> {} //~ ERROR `Self` type is used before it's determined\n+impl Tr<Self::Assoc> for S {} //~ ERROR `Self` type is used before it's determined\n \n fn main() {}"}]}