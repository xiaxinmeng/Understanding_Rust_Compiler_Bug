{"sha": "01ce87ad148d0f7af616158d3345bde246663d08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxY2U4N2FkMTQ4ZDBmN2FmNjE2MTU4ZDMzNDViZGUyNDY2NjNkMDg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-01T23:09:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-01T23:09:25Z"}, "message": "Rollup merge of #60348 - agnxy:refactor-parser, r=petrochenkov\n\nmove some functions from parser.rs to diagostics.rs\n\nStarting with a few functions mentioned in https://github.com/rust-lang/rust/issues/60015#issuecomment-484259773. We might refactor parser.rs further in subsequent changes.\nr? @petrochenkov", "tree": {"sha": "f55964f776076437caccb7677b2fb992b35d2abf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f55964f776076437caccb7677b2fb992b35d2abf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01ce87ad148d0f7af616158d3345bde246663d08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcyiclCRBK7hj4Ov3rIwAAdHIIAG/IFhV+1JDzXKI0jCx4RX1F\nLJKpwsOQdgv+83p+uGxWG/80Qnk3KyJFtP24xeXKB6hsjxdf8lhV0ngGW+82Loxv\n/g9VfcbCgS9UpYYmYB3vpQm0msxL2M0Oyh7L2hS5y51YpiAIMYOzjCz4IhEkrcdV\ndj7lTxk6wQZUcfiR1hkd0FWJ8IE9S+KmOA/2dyqaQD/kTJW5QlywpfhUvyU5zuAE\nD49GD5z9coN38kxrS9gK/iD6Rf+wdGXYNqpIJ6ZRKsMAGEQN9xX/xG9OzbMUeZKb\nxMZZnUVeTOB7G2CEhWhBQe3HUSUpcY5u0x/TjiytcenAN7jOY9wkVfk8fXPuiyM=\n=NPQC\n-----END PGP SIGNATURE-----\n", "payload": "tree f55964f776076437caccb7677b2fb992b35d2abf\nparent eabdce578bfe2e503bedbe42247539e4196a06d7\nparent d3fff6cda7e56488566b6b82c494e6075d2d9988\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556752165 +0200\ncommitter GitHub <noreply@github.com> 1556752165 +0200\n\nRollup merge of #60348 - agnxy:refactor-parser, r=petrochenkov\n\nmove some functions from parser.rs to diagostics.rs\n\nStarting with a few functions mentioned in https://github.com/rust-lang/rust/issues/60015#issuecomment-484259773. We might refactor parser.rs further in subsequent changes.\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01ce87ad148d0f7af616158d3345bde246663d08", "html_url": "https://github.com/rust-lang/rust/commit/01ce87ad148d0f7af616158d3345bde246663d08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01ce87ad148d0f7af616158d3345bde246663d08/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eabdce578bfe2e503bedbe42247539e4196a06d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/eabdce578bfe2e503bedbe42247539e4196a06d7", "html_url": "https://github.com/rust-lang/rust/commit/eabdce578bfe2e503bedbe42247539e4196a06d7"}, {"sha": "d3fff6cda7e56488566b6b82c494e6075d2d9988", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3fff6cda7e56488566b6b82c494e6075d2d9988", "html_url": "https://github.com/rust-lang/rust/commit/d3fff6cda7e56488566b6b82c494e6075d2d9988"}], "stats": {"total": 393, "additions": 231, "deletions": 162}, "files": [{"sha": "32e1ee94f0dfb702f8ce3667b888e73a95c322d7", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/01ce87ad148d0f7af616158d3345bde246663d08/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ce87ad148d0f7af616158d3345bde246663d08/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=01ce87ad148d0f7af616158d3345bde246663d08", "patch": "@@ -0,0 +1,226 @@\n+use crate::ast;\n+use crate::ast::{Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind};\n+use crate::parse::parser::PathStyle;\n+use crate::parse::token;\n+use crate::parse::PResult;\n+use crate::parse::Parser;\n+use crate::print::pprust;\n+use crate::ptr::P;\n+use crate::ThinVec;\n+use errors::Applicability;\n+use syntax_pos::Span;\n+\n+pub trait RecoverQPath: Sized + 'static {\n+    const PATH_STYLE: PathStyle = PathStyle::Expr;\n+    fn to_ty(&self) -> Option<P<Ty>>;\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self;\n+}\n+\n+impl RecoverQPath for Ty {\n+    const PATH_STYLE: PathStyle = PathStyle::Type;\n+    fn to_ty(&self) -> Option<P<Ty>> {\n+        Some(P(self.clone()))\n+    }\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self {\n+            span: path.span,\n+            node: TyKind::Path(qself, path),\n+            id: ast::DUMMY_NODE_ID,\n+        }\n+    }\n+}\n+\n+impl RecoverQPath for Pat {\n+    fn to_ty(&self) -> Option<P<Ty>> {\n+        self.to_ty()\n+    }\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self {\n+            span: path.span,\n+            node: PatKind::Path(qself, path),\n+            id: ast::DUMMY_NODE_ID,\n+        }\n+    }\n+}\n+\n+impl RecoverQPath for Expr {\n+    fn to_ty(&self) -> Option<P<Ty>> {\n+        self.to_ty()\n+    }\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self {\n+            span: path.span,\n+            node: ExprKind::Path(qself, path),\n+            attrs: ThinVec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+        }\n+    }\n+}\n+\n+impl<'a> Parser<'a> {\n+    crate fn maybe_report_ambiguous_plus(\n+        &mut self,\n+        allow_plus: bool,\n+        impl_dyn_multi: bool,\n+        ty: &Ty,\n+    ) {\n+        if !allow_plus && impl_dyn_multi {\n+            let sum_with_parens = format!(\"({})\", pprust::ty_to_string(&ty));\n+            self.struct_span_err(ty.span, \"ambiguous `+` in a type\")\n+                .span_suggestion(\n+                    ty.span,\n+                    \"use parentheses to disambiguate\",\n+                    sum_with_parens,\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n+    }\n+\n+    crate fn maybe_recover_from_bad_type_plus(\n+        &mut self,\n+        allow_plus: bool,\n+        ty: &Ty,\n+    ) -> PResult<'a, ()> {\n+        // Do not add `+` to expected tokens.\n+        if !allow_plus || !self.token.is_like_plus() {\n+            return Ok(());\n+        }\n+\n+        self.bump(); // `+`\n+        let bounds = self.parse_generic_bounds(None)?;\n+        let sum_span = ty.span.to(self.prev_span);\n+\n+        let mut err = struct_span_err!(\n+            self.sess.span_diagnostic,\n+            sum_span,\n+            E0178,\n+            \"expected a path on the left-hand side of `+`, not `{}`\",\n+            pprust::ty_to_string(ty)\n+        );\n+\n+        match ty.node {\n+            TyKind::Rptr(ref lifetime, ref mut_ty) => {\n+                let sum_with_parens = pprust::to_string(|s| {\n+                    use crate::print::pprust::PrintState;\n+\n+                    s.s.word(\"&\")?;\n+                    s.print_opt_lifetime(lifetime)?;\n+                    s.print_mutability(mut_ty.mutbl)?;\n+                    s.popen()?;\n+                    s.print_type(&mut_ty.ty)?;\n+                    s.print_type_bounds(\" +\", &bounds)?;\n+                    s.pclose()\n+                });\n+                err.span_suggestion(\n+                    sum_span,\n+                    \"try adding parentheses\",\n+                    sum_with_parens,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            TyKind::Ptr(..) | TyKind::BareFn(..) => {\n+                err.span_label(sum_span, \"perhaps you forgot parentheses?\");\n+            }\n+            _ => {\n+                err.span_label(sum_span, \"expected a path\");\n+            }\n+        }\n+        err.emit();\n+        Ok(())\n+    }\n+\n+    /// Try to recover from associated item paths like `[T]::AssocItem`/`(T, U)::AssocItem`.\n+    /// Attempt to convert the base expression/pattern/type into a type, parse the `::AssocItem`\n+    /// tail, and combine them into a `<Ty>::AssocItem` expression/pattern/type.\n+    crate fn maybe_recover_from_bad_qpath<T: RecoverQPath>(\n+        &mut self,\n+        base: P<T>,\n+        allow_recovery: bool,\n+    ) -> PResult<'a, P<T>> {\n+        // Do not add `::` to expected tokens.\n+        if allow_recovery && self.token == token::ModSep {\n+            if let Some(ty) = base.to_ty() {\n+                return self.maybe_recover_from_bad_qpath_stage_2(ty.span, ty);\n+            }\n+        }\n+        Ok(base)\n+    }\n+\n+    /// Given an already parsed `Ty` parse the `::AssocItem` tail and\n+    /// combine them into a `<Ty>::AssocItem` expression/pattern/type.\n+    crate fn maybe_recover_from_bad_qpath_stage_2<T: RecoverQPath>(\n+        &mut self,\n+        ty_span: Span,\n+        ty: P<Ty>,\n+    ) -> PResult<'a, P<T>> {\n+        self.expect(&token::ModSep)?;\n+\n+        let mut path = ast::Path {\n+            segments: Vec::new(),\n+            span: syntax_pos::DUMMY_SP,\n+        };\n+        self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n+        path.span = ty_span.to(self.prev_span);\n+\n+        let ty_str = self\n+            .sess\n+            .source_map()\n+            .span_to_snippet(ty_span)\n+            .unwrap_or_else(|_| pprust::ty_to_string(&ty));\n+        self.diagnostic()\n+            .struct_span_err(path.span, \"missing angle brackets in associated item path\")\n+            .span_suggestion(\n+                // this is a best-effort recovery\n+                path.span,\n+                \"try\",\n+                format!(\"<{}>::{}\", ty_str, path),\n+                Applicability::MaybeIncorrect,\n+            )\n+            .emit();\n+\n+        let path_span = ty_span.shrink_to_hi(); // use an empty path since `position` == 0\n+        Ok(P(T::recovered(\n+            Some(QSelf {\n+                ty,\n+                path_span,\n+                position: 0,\n+            }),\n+            path,\n+        )))\n+    }\n+\n+    crate fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n+        if self.eat(&token::Semi) {\n+            let mut err = self.struct_span_err(self.prev_span, \"expected item, found `;`\");\n+            err.span_suggestion_short(\n+                self.prev_span,\n+                \"remove this semicolon\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+            if !items.is_empty() {\n+                let previous_item = &items[items.len() - 1];\n+                let previous_item_kind_name = match previous_item.node {\n+                    // say \"braced struct\" because tuple-structs and\n+                    // braceless-empty-struct declarations do take a semicolon\n+                    ItemKind::Struct(..) => Some(\"braced struct\"),\n+                    ItemKind::Enum(..) => Some(\"enum\"),\n+                    ItemKind::Trait(..) => Some(\"trait\"),\n+                    ItemKind::Union(..) => Some(\"union\"),\n+                    _ => None,\n+                };\n+                if let Some(name) = previous_item_kind_name {\n+                    err.help(&format!(\n+                        \"{} declarations are not followed by a semicolon\",\n+                        name\n+                    ));\n+                }\n+            }\n+            err.emit();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "85a74df23573835841136af4b92ad1feb8fbc56e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01ce87ad148d0f7af616158d3345bde246663d08/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ce87ad148d0f7af616158d3345bde246663d08/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=01ce87ad148d0f7af616158d3345bde246663d08", "patch": "@@ -30,6 +30,7 @@ pub mod parser;\n pub mod lexer;\n pub mod token;\n pub mod attr;\n+pub mod diagnostics;\n \n pub mod classify;\n "}, {"sha": "6c64055ded1b1986ca82e9c1c31b27b2ee82358b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 162, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/01ce87ad148d0f7af616158d3345bde246663d08/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ce87ad148d0f7af616158d3345bde246663d08/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=01ce87ad148d0f7af616158d3345bde246663d08", "patch": "@@ -189,41 +189,6 @@ enum PrevTokenKind {\n     Other,\n }\n \n-trait RecoverQPath: Sized + 'static {\n-    const PATH_STYLE: PathStyle = PathStyle::Expr;\n-    fn to_ty(&self) -> Option<P<Ty>>;\n-    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self;\n-}\n-\n-impl RecoverQPath for Ty {\n-    const PATH_STYLE: PathStyle = PathStyle::Type;\n-    fn to_ty(&self) -> Option<P<Ty>> {\n-        Some(P(self.clone()))\n-    }\n-    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: TyKind::Path(qself, path), id: ast::DUMMY_NODE_ID }\n-    }\n-}\n-\n-impl RecoverQPath for Pat {\n-    fn to_ty(&self) -> Option<P<Ty>> {\n-        self.to_ty()\n-    }\n-    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: PatKind::Path(qself, path), id: ast::DUMMY_NODE_ID }\n-    }\n-}\n-\n-impl RecoverQPath for Expr {\n-    fn to_ty(&self) -> Option<P<Ty>> {\n-        self.to_ty()\n-    }\n-    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: ExprKind::Path(qself, path),\n-               attrs: ThinVec::new(), id: ast::DUMMY_NODE_ID }\n-    }\n-}\n-\n /* ident is handled by common.rs */\n \n #[derive(Clone)]\n@@ -1479,7 +1444,7 @@ impl<'a> Parser<'a> {\n     fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n-    fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+    crate fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n     fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n@@ -1882,99 +1847,6 @@ impl<'a> Parser<'a> {\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n \n-    fn maybe_report_ambiguous_plus(&mut self, allow_plus: bool, impl_dyn_multi: bool, ty: &Ty) {\n-        if !allow_plus && impl_dyn_multi {\n-            let sum_with_parens = format!(\"({})\", pprust::ty_to_string(&ty));\n-            self.struct_span_err(ty.span, \"ambiguous `+` in a type\")\n-                .span_suggestion(\n-                    ty.span,\n-                    \"use parentheses to disambiguate\",\n-                    sum_with_parens,\n-                    Applicability::MachineApplicable\n-                ).emit();\n-        }\n-    }\n-\n-    fn maybe_recover_from_bad_type_plus(&mut self, allow_plus: bool, ty: &Ty) -> PResult<'a, ()> {\n-        // Do not add `+` to expected tokens.\n-        if !allow_plus || !self.token.is_like_plus() {\n-            return Ok(())\n-        }\n-\n-        self.bump(); // `+`\n-        let bounds = self.parse_generic_bounds(None)?;\n-        let sum_span = ty.span.to(self.prev_span);\n-\n-        let mut err = struct_span_err!(self.sess.span_diagnostic, sum_span, E0178,\n-            \"expected a path on the left-hand side of `+`, not `{}`\", pprust::ty_to_string(ty));\n-\n-        match ty.node {\n-            TyKind::Rptr(ref lifetime, ref mut_ty) => {\n-                let sum_with_parens = pprust::to_string(|s| {\n-                    use crate::print::pprust::PrintState;\n-\n-                    s.s.word(\"&\")?;\n-                    s.print_opt_lifetime(lifetime)?;\n-                    s.print_mutability(mut_ty.mutbl)?;\n-                    s.popen()?;\n-                    s.print_type(&mut_ty.ty)?;\n-                    s.print_type_bounds(\" +\", &bounds)?;\n-                    s.pclose()\n-                });\n-                err.span_suggestion(\n-                    sum_span,\n-                    \"try adding parentheses\",\n-                    sum_with_parens,\n-                    Applicability::MachineApplicable\n-                );\n-            }\n-            TyKind::Ptr(..) | TyKind::BareFn(..) => {\n-                err.span_label(sum_span, \"perhaps you forgot parentheses?\");\n-            }\n-            _ => {\n-                err.span_label(sum_span, \"expected a path\");\n-            },\n-        }\n-        err.emit();\n-        Ok(())\n-    }\n-\n-    /// Try to recover from associated item paths like `[T]::AssocItem`/`(T, U)::AssocItem`.\n-    /// Attempt to convert the base expression/pattern/type into a type, parse the `::AssocItem`\n-    /// tail, and combine them into a `<Ty>::AssocItem` expression/pattern/type.\n-    fn maybe_recover_from_bad_qpath<T: RecoverQPath>(&mut self, base: P<T>, allow_recovery: bool)\n-                                                     -> PResult<'a, P<T>> {\n-        // Do not add `::` to expected tokens.\n-        if allow_recovery && self.token == token::ModSep {\n-            if let Some(ty) = base.to_ty() {\n-                return self.maybe_recover_from_bad_qpath_stage_2(ty.span, ty);\n-            }\n-        }\n-        Ok(base)\n-    }\n-\n-    /// Given an already parsed `Ty` parse the `::AssocItem` tail and\n-    /// combine them into a `<Ty>::AssocItem` expression/pattern/type.\n-    fn maybe_recover_from_bad_qpath_stage_2<T: RecoverQPath>(&mut self, ty_span: Span, ty: P<Ty>)\n-                                                             -> PResult<'a, P<T>> {\n-        self.expect(&token::ModSep)?;\n-\n-        let mut path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n-        self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n-        path.span = ty_span.to(self.prev_span);\n-\n-        let ty_str = self.sess.source_map().span_to_snippet(ty_span)\n-            .unwrap_or_else(|_| pprust::ty_to_string(&ty));\n-        self.diagnostic()\n-            .struct_span_err(path.span, \"missing angle brackets in associated item path\")\n-            .span_suggestion( // this is a best-effort recovery\n-                path.span, \"try\", format!(\"<{}>::{}\", ty_str, path), Applicability::MaybeIncorrect\n-            ).emit();\n-\n-        let path_span = ty_span.shrink_to_hi(); // use an empty path since `position` == 0\n-        Ok(P(T::recovered(Some(QSelf { ty, path_span, position: 0 }), path)))\n-    }\n-\n     fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n         let opt_lifetime = if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n         let mutbl = self.parse_mutability();\n@@ -2410,7 +2282,7 @@ impl<'a> Parser<'a> {\n         self.parse_path(style)\n     }\n \n-    fn parse_path_segments(&mut self,\n+    crate fn parse_path_segments(&mut self,\n                            segments: &mut Vec<PathSegment>,\n                            style: PathStyle)\n                            -> PResult<'a, ()> {\n@@ -5815,7 +5687,8 @@ impl<'a> Parser<'a> {\n         return Ok(bounds);\n     }\n \n-    fn parse_generic_bounds(&mut self, colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+    crate fn parse_generic_bounds(&mut self,\n+                                  colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n         self.parse_generic_bounds_common(true, colon_span)\n     }\n \n@@ -7352,37 +7225,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n-        if self.eat(&token::Semi) {\n-            let mut err = self.struct_span_err(self.prev_span, \"expected item, found `;`\");\n-            err.span_suggestion_short(\n-                self.prev_span,\n-                \"remove this semicolon\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n-            if !items.is_empty() {\n-                let previous_item = &items[items.len()-1];\n-                let previous_item_kind_name = match previous_item.node {\n-                    // say \"braced struct\" because tuple-structs and\n-                    // braceless-empty-struct declarations do take a semicolon\n-                    ItemKind::Struct(..) => Some(\"braced struct\"),\n-                    ItemKind::Enum(..) => Some(\"enum\"),\n-                    ItemKind::Trait(..) => Some(\"trait\"),\n-                    ItemKind::Union(..) => Some(\"union\"),\n-                    _ => None,\n-                };\n-                if let Some(name) = previous_item_kind_name {\n-                    err.help(&format!(\"{} declarations are not followed by a semicolon\", name));\n-                }\n-            }\n-            err.emit();\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     /// Given a termination token, parses all of the items in a module.\n     fn parse_mod_items(&mut self, term: &token::Token, inner_lo: Span) -> PResult<'a, Mod> {\n         let mut items = vec![];"}]}