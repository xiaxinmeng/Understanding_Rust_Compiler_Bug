{"sha": "987ab1feda701581dc0254453fbf80eaf39d169b", "node_id": "C_kwDOAAsO6NoAKDk4N2FiMWZlZGE3MDE1ODFkYzAyNTQ0NTNmYmY4MGVhZjM5ZDE2OWI", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-10-14T16:19:20Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-10-14T16:19:20Z"}, "message": "implement feedback from review", "tree": {"sha": "5f9655088ddcb2c4c8734fdcaaa30381cb2dd961", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f9655088ddcb2c4c8734fdcaaa30381cb2dd961"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/987ab1feda701581dc0254453fbf80eaf39d169b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/987ab1feda701581dc0254453fbf80eaf39d169b", "html_url": "https://github.com/rust-lang/rust/commit/987ab1feda701581dc0254453fbf80eaf39d169b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/987ab1feda701581dc0254453fbf80eaf39d169b/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ffe91526510a4640d0d0d718a41f607f49dab3", "url": "https://api.github.com/repos/rust-lang/rust/commits/68ffe91526510a4640d0d0d718a41f607f49dab3", "html_url": "https://github.com/rust-lang/rust/commit/68ffe91526510a4640d0d0d718a41f607f49dab3"}], "stats": {"total": 74, "additions": 54, "deletions": 20}, "files": [{"sha": "1db945a6fcf7f0f2d9a8c1ee9efb362c11beb64e", "filename": "crates/ide_assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/987ab1feda701581dc0254453fbf80eaf39d169b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987ab1feda701581dc0254453fbf80eaf39d169b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=987ab1feda701581dc0254453fbf80eaf39d169b", "patch": "@@ -2,7 +2,7 @@ use hir::{self, HasCrate, HasSource, HirDisplay};\n use syntax::ast::{self, make, AstNode, HasGenericParams, HasName, HasVisibility};\n \n use crate::{\n-    utils::{find_struct_impl, render_snippet, Cursor},\n+    utils::{convert_param_list_to_arg_list, find_struct_impl, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n };\n use syntax::ast::edit::AstNodeEdit;\n@@ -43,8 +43,6 @@ use syntax::ast::edit::AstNodeEdit;\n // }\n // ```\n pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let cap = ctx.config.snippet_cap?;\n-\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let strukt_name = strukt.name()?;\n \n@@ -57,8 +55,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext)\n         None => {\n             let field = ctx.find_node_at_offset::<ast::TupleField>()?;\n             let field_list = ctx.find_node_at_offset::<ast::TupleFieldList>()?;\n-            let field_list_index =\n-                field_list.syntax().children().into_iter().position(|s| &s == field.syntax())?;\n+            let field_list_index = field_list.fields().position(|it| it == field)?;\n             let field_ty = field.ty()?;\n             (format!(\"{}\", field_list_index), field_ty)\n         }\n@@ -73,16 +70,14 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext)\n                 methods.push(f)\n             }\n         }\n-        Some(())\n+        Option::<()>::None\n     });\n \n     let target = field_ty.syntax().text_range();\n     for method in methods {\n-        let impl_def = find_struct_impl(\n-            ctx,\n-            &ast::Adt::Struct(strukt.clone()),\n-            &method.name(ctx.db()).to_string(),\n-        )?;\n+        let adt = ast::Adt::Struct(strukt.clone());\n+        let name = method.name(ctx.db()).to_string();\n+        let impl_def = find_struct_impl(ctx, &adt, &name).flatten();\n         acc.add_group(\n             &GroupLabel(\"Generate delegate methods\u2026\".to_owned()),\n             AssistId(\"generate_delegate_methods\", AssistKind::Generate),\n@@ -99,15 +94,22 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext)\n                 let name = make::name(&method.name(ctx.db()).to_string());\n                 let params =\n                     method_source.param_list().unwrap_or_else(|| make::param_list(None, []));\n+                let type_params = method_source.generic_param_list();\n+                let arg_list = match method_source.param_list() {\n+                    Some(list) => convert_param_list_to_arg_list(list),\n+                    None => make::arg_list([]),\n+                };\n                 let tail_expr = make::expr_method_call(\n                     make::ext::field_from_idents([\"self\", &field_name]).unwrap(), // This unwrap is ok because we have at least 1 arg in the list\n                     make::name_ref(&method_name.to_string()),\n-                    make::arg_list([]),\n+                    arg_list,\n                 );\n-                let type_params = method_source.generic_param_list();\n                 let body = make::block_expr([], Some(tail_expr));\n                 let ret_type = method.ret_type(ctx.db());\n                 let ret_type = if ret_type.is_unknown() {\n+                    // FIXME: we currently can't resolve certain generics, and\n+                    // are returning placeholders instead. We should fix our\n+                    // type resolution here, so we return fewer placeholders.\n                     Some(make::ret_type(make::ty_placeholder()))\n                 } else {\n                     let ret_type = &ret_type.display(ctx.db()).to_string();\n@@ -133,8 +135,15 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext)\n                         assoc_items.add_item(f.clone().into());\n \n                         // Update the impl block.\n-                        let snippet = render_snippet(cap, impl_def.syntax(), cursor);\n-                        builder.replace_snippet(cap, old_range, snippet);\n+                        match ctx.config.snippet_cap {\n+                            Some(cap) => {\n+                                let snippet = render_snippet(cap, impl_def.syntax(), cursor);\n+                                builder.replace_snippet(cap, old_range, snippet);\n+                            }\n+                            None => {\n+                                builder.replace(old_range, impl_def.syntax().to_string());\n+                            }\n+                        }\n                     }\n                     None => {\n                         // Attach the function to the impl block\n@@ -147,10 +156,19 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext)\n                         assoc_items.add_item(f.clone().into());\n \n                         // Insert the impl block.\n-                        let offset = strukt.syntax().text_range().end();\n-                        let snippet = render_snippet(cap, impl_def.syntax(), cursor);\n-                        let snippet = format!(\"\\n\\n{}\", snippet);\n-                        builder.insert_snippet(cap, offset, snippet);\n+                        match ctx.config.snippet_cap {\n+                            Some(cap) => {\n+                                let offset = strukt.syntax().text_range().end();\n+                                let snippet = render_snippet(cap, impl_def.syntax(), cursor);\n+                                let snippet = format!(\"\\n\\n{}\", snippet);\n+                                builder.insert_snippet(cap, offset, snippet);\n+                            }\n+                            None => {\n+                                let offset = strukt.syntax().text_range().end();\n+                                let snippet = format!(\"\\n\\n{}\", impl_def.syntax().to_string());\n+                                builder.insert(offset, snippet);\n+                            }\n+                        }\n                     }\n                 }\n             },\n@@ -297,7 +315,7 @@ struct Person<T> {\n \n impl<T> Person<T> {\n     $0pub(crate) async fn age<J, 'a>(&'a mut self, ty: T, arg: J) -> _ {\n-        self.age.age()\n+        self.age.age(ty, arg)\n     }\n }\"#,\n         );"}, {"sha": "c1092b97c2218fb76aa7b7b4158fc7db1596b890", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/987ab1feda701581dc0254453fbf80eaf39d169b/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987ab1feda701581dc0254453fbf80eaf39d169b/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=987ab1feda701581dc0254453fbf80eaf39d169b", "patch": "@@ -525,3 +525,19 @@ pub(crate) fn trimmed_text_range(source_file: &SourceFile, initial_range: TextRa\n     }\n     trimmed_range\n }\n+\n+/// Convert a list of function params to a list of arguments that can be passed\n+/// into a function call.\n+pub(crate) fn convert_param_list_to_arg_list(list: ast::ParamList) -> ast::ArgList {\n+    let mut args = vec![];\n+    for param in list.params() {\n+        if let Some(ast::Pat::IdentPat(pat)) = param.pat() {\n+            if let Some(name) = pat.name() {\n+                let name = name.to_string();\n+                let expr = make::expr_path(make::ext::ident_path(&name));\n+                args.push(expr);\n+            }\n+        }\n+    }\n+    make::arg_list(args)\n+}"}]}