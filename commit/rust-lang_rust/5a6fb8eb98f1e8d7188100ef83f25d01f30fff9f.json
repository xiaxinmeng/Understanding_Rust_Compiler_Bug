{"sha": "5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNmZiOGViOThmMWU4ZDcxODgxMDBlZjgzZjI1ZDAxZjMwZmZmOWY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-26T22:02:23Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-26T23:42:32Z"}, "message": "Merge remote-tracking branch 'rust-lang/master'\n\nConflicts:\n\tsrc/librustc/lint/builtin.rs\n\tsrc/librustc/lint/context.rs", "tree": {"sha": "b258f900721206035f33e5fcc229474d19448569", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b258f900721206035f33e5fcc229474d19448569"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "html_url": "https://github.com/rust-lang/rust/commit/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "html_url": "https://github.com/rust-lang/rust/commit/d179ba3b8eb65c951b68f6c52da3aba82806a3a1"}, {"sha": "16286f5cf921a9de463d8a744c33f49837698c3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/16286f5cf921a9de463d8a744c33f49837698c3d", "html_url": "https://github.com/rust-lang/rust/commit/16286f5cf921a9de463d8a744c33f49837698c3d"}], "stats": {"total": 1682, "additions": 841, "deletions": 841}, "files": [{"sha": "a52100c4cdd4e3141f229061e6747b35298f8fe2", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -2418,10 +2418,6 @@ The currently implemented features of the reference compiler are:\n                        for now until the specification of identifiers is fully\n                        fleshed out.\n \n-* `once_fns` - Onceness guarantees a closure is only executed once. Defining a\n-               closure as `once` is unlikely to be supported going forward. So\n-               they are hidden behind this feature until they are to be removed.\n-\n * `plugin` - Usage of [compiler plugins][plugin] for custom lints or syntax extensions.\n              These depend on compiler internals and are subject to change.\n "}, {"sha": "5189b825f1615230e384ea1fb4c3ad4914d68e52", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -1417,4 +1417,20 @@ mod tests {\n             let _ = String::from_utf8_lossy(s.as_slice());\n         });\n     }\n+\n+    #[bench]\n+    fn bench_exact_size_shrink_to_fit(b: &mut Bencher) {\n+        let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                 Lorem ipsum dolor sit amet, consectetur. \";\n+        // ensure our operation produces an exact-size string before we benchmark it\n+        let mut r = String::with_capacity(s.len());\n+        r.push_str(s);\n+        assert_eq!(r.len(), r.capacity());\n+        b.iter(|| {\n+            let mut r = String::with_capacity(s.len());\n+            r.push_str(s);\n+            r.shrink_to_fit();\n+            r\n+        });\n+    }\n }"}, {"sha": "c44dfff9117d9f807e08489fb44595af4e3c1476", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -357,7 +357,7 @@ impl<T> Vec<T> {\n                 }\n                 self.cap = 0;\n             }\n-        } else {\n+        } else if self.cap != self.len {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at\n                 // least this large."}, {"sha": "8e6715fa38b15838c5502d73a7de2aaa225c00fb", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -255,6 +255,7 @@ pub trait Show {\n            reason = \"I/O and core have yet to be reconciled\")]\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is defined in your \\\n                             crate, add `#[derive(Debug)]` or manually implement it\"]\n+#[lang = \"debug_trait\"]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;"}, {"sha": "f13814527cdfd3a6ddb58b691839c85753a34814", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -1624,6 +1624,69 @@ impl LintPass for MissingCopyImplementations {\n     }\n }\n \n+declare_lint! {\n+    MISSING_DEBUG_IMPLEMENTATIONS,\n+    Allow,\n+    \"detects missing implementations of fmt::Debug\"\n+}\n+\n+pub struct MissingDebugImplementations {\n+    impling_types: Option<NodeSet>,\n+}\n+\n+impl MissingDebugImplementations {\n+    pub fn new() -> MissingDebugImplementations {\n+        MissingDebugImplementations {\n+            impling_types: None,\n+        }\n+    }\n+}\n+\n+impl LintPass for MissingDebugImplementations {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MISSING_DEBUG_IMPLEMENTATIONS)\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        if !cx.exported_items.contains(&item.id) {\n+            return;\n+        }\n+\n+        match item.node {\n+            ast::ItemStruct(..) | ast::ItemEnum(..) => {},\n+            _ => return,\n+        }\n+\n+        let debug = match cx.tcx.lang_items.debug_trait() {\n+            Some(debug) => debug,\n+            None => return,\n+        };\n+\n+        if self.impling_types.is_none() {\n+            let impls = cx.tcx.trait_impls.borrow();\n+            let impls = match impls.get(&debug) {\n+                Some(impls) => {\n+                    impls.borrow().iter()\n+                        .filter(|d| d.krate == ast::LOCAL_CRATE)\n+                        .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n+                        .map(|d| d.node)\n+                        .collect()\n+                }\n+                None => NodeSet(),\n+            };\n+            self.impling_types = Some(impls);\n+            debug!(\"{:?}\", self.impling_types);\n+        }\n+\n+        if !self.impling_types.as_ref().unwrap().contains(&item.id) {\n+            cx.span_lint(MISSING_DEBUG_IMPLEMENTATIONS,\n+                         item.span,\n+                         \"type does not implement `fmt::Debug`; consider adding #[derive(Debug)] \\\n+                          or a manual implementation\")\n+        }\n+    }\n+}\n+\n declare_lint! {\n     DEPRECATED,\n     Warn,\n@@ -1826,7 +1889,7 @@ impl LintPass for UnconditionalRecursion {\n                     ty::MethodTraitObject(_) => return false,\n \n                     // This `did` refers directly to the method definition.\n-                    ty::MethodStatic(did) | ty::MethodStaticUnboxedClosure(did) => did,\n+                    ty::MethodStatic(did) | ty::MethodStaticClosure(did) => did,\n \n                     // MethodTypeParam are methods from traits:\n "}, {"sha": "3a103e421016f398cbbe4f20e766b5476e9b27d5", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -219,6 +219,7 @@ impl LintStore {\n                               TypeLimits,\n                               RawPointerDerive,\n                               MissingDoc,\n+                              MissingDebugImplementations,\n         );\n \n         add_lint_group!(sess, \"bad_style\","}, {"sha": "0ca3e2595ab87f202b3da5699fdf6ab0999c57d2", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -139,7 +139,7 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_adjustments = 0x51,\n     tag_table_moves_map = 0x52,\n     tag_table_capture_map = 0x53,\n-    tag_table_unboxed_closures = 0x54,\n+    tag_table_closures = 0x54,\n     tag_table_upvar_borrow_map = 0x55,\n     tag_table_capture_modes = 0x56,\n     tag_table_object_cast_map = 0x57,\n@@ -225,10 +225,10 @@ pub struct LinkMeta {\n     pub crate_hash: Svh,\n }\n \n-pub const tag_unboxed_closures: uint = 0x95;\n-pub const tag_unboxed_closure: uint = 0x96;\n-pub const tag_unboxed_closure_type: uint = 0x97;\n-pub const tag_unboxed_closure_kind: uint = 0x98;\n+pub const tag_closures: uint = 0x95;\n+pub const tag_closure: uint = 0x96;\n+pub const tag_closure_type: uint = 0x97;\n+pub const tag_closure_kind: uint = 0x98;\n \n pub const tag_struct_fields: uint = 0x99;\n pub const tag_struct_field: uint = 0x9a;"}, {"sha": "2de453812492a5aef3a0099f8204a2c7b73aa71e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -618,13 +618,12 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n     rbml_w.end_tag();\n }\n \n-fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n-                               kind: ty::UnboxedClosureKind) {\n-    rbml_w.start_tag(tag_unboxed_closure_kind);\n+fn encode_closure_kind(rbml_w: &mut Encoder, kind: ty::ClosureKind) {\n+    rbml_w.start_tag(tag_closure_kind);\n     let ch = match kind {\n-        ty::FnUnboxedClosureKind => 'f',\n-        ty::FnMutUnboxedClosureKind => 'm',\n-        ty::FnOnceUnboxedClosureKind => 'o',\n+        ty::FnClosureKind => 'f',\n+        ty::FnMutClosureKind => 'm',\n+        ty::FnOnceClosureKind => 'o',\n     };\n     rbml_w.wr_str(&ch.to_string()[]);\n     rbml_w.end_tag();\n@@ -1838,24 +1837,19 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_unboxed_closures<'a>(\n-                           ecx: &'a EncodeContext,\n-                           rbml_w: &'a mut Encoder) {\n-    rbml_w.start_tag(tag_unboxed_closures);\n-    for (unboxed_closure_id, unboxed_closure) in ecx.tcx\n-                                                    .unboxed_closures\n-                                                    .borrow()\n-                                                    .iter() {\n-        if unboxed_closure_id.krate != ast::LOCAL_CRATE {\n+fn encode_closures<'a>(ecx: &'a EncodeContext, rbml_w: &'a mut Encoder) {\n+    rbml_w.start_tag(tag_closures);\n+    for (closure_id, closure) in ecx.tcx.closures.borrow().iter() {\n+        if closure_id.krate != ast::LOCAL_CRATE {\n             continue\n         }\n \n-        rbml_w.start_tag(tag_unboxed_closure);\n-        encode_def_id(rbml_w, *unboxed_closure_id);\n-        rbml_w.start_tag(tag_unboxed_closure_type);\n-        write_closure_type(ecx, rbml_w, &unboxed_closure.closure_type);\n+        rbml_w.start_tag(tag_closure);\n+        encode_def_id(rbml_w, *closure_id);\n+        rbml_w.start_tag(tag_closure_type);\n+        write_closure_type(ecx, rbml_w, &closure.closure_type);\n         rbml_w.end_tag();\n-        encode_unboxed_closure_kind(rbml_w, unboxed_closure.kind);\n+        encode_closure_kind(rbml_w, closure.kind);\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n@@ -2069,7 +2063,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         native_lib_bytes: u64,\n         plugin_registrar_fn_bytes: u64,\n         macro_defs_bytes: u64,\n-        unboxed_closure_bytes: u64,\n+        closure_bytes: u64,\n         impl_bytes: u64,\n         misc_bytes: u64,\n         item_bytes: u64,\n@@ -2084,7 +2078,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         native_lib_bytes: 0,\n         plugin_registrar_fn_bytes: 0,\n         macro_defs_bytes: 0,\n-        unboxed_closure_bytes: 0,\n+        closure_bytes: 0,\n         impl_bytes: 0,\n         misc_bytes: 0,\n         item_bytes: 0,\n@@ -2154,10 +2148,10 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n     encode_macro_defs(&mut rbml_w, krate);\n     stats.macro_defs_bytes = rbml_w.writer.tell().unwrap() - i;\n \n-    // Encode the types of all unboxed closures in this crate.\n+    // Encode the types of all closures in this crate.\n     i = rbml_w.writer.tell().unwrap();\n-    encode_unboxed_closures(&ecx, &mut rbml_w);\n-    stats.unboxed_closure_bytes = rbml_w.writer.tell().unwrap() - i;\n+    encode_closures(&ecx, &mut rbml_w);\n+    stats.closure_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n     i = rbml_w.writer.tell().unwrap();\n@@ -2199,7 +2193,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         println!(\"          native bytes: {}\", stats.native_lib_bytes);\n         println!(\"plugin registrar bytes: {}\", stats.plugin_registrar_fn_bytes);\n         println!(\"       macro def bytes: {}\", stats.macro_defs_bytes);\n-        println!(\" unboxed closure bytes: {}\", stats.unboxed_closure_bytes);\n+        println!(\"         closure bytes: {}\", stats.closure_bytes);\n         println!(\"            impl bytes: {}\", stats.impl_bytes);\n         println!(\"            misc bytes: {}\", stats.misc_bytes);\n         println!(\"            item bytes: {}\", stats.item_bytes);"}, {"sha": "cb6b7e56b5770f3ee8761ea8998c1a1d4c76654f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -57,8 +57,8 @@ pub enum DefIdSource {\n     // Identifies a region parameter (`fn foo<'X>() { ... }`).\n     RegionParameter,\n \n-    // Identifies an unboxed closure\n-    UnboxedClosureSource\n+    // Identifies a closure\n+    ClosureSource\n }\n \n // type conv_did = impl FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n@@ -537,11 +537,11 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def_(st, UnboxedClosureSource, conv);\n+          let did = parse_def_(st, ClosureSource, conv);\n           let region = parse_region_(st, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_unboxed_closure(st.tcx, did,\n+          return ty::mk_closure(st.tcx, did,\n                   st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n       }\n       'P' => {"}, {"sha": "54b930fbda9ca6ee4b029e8426a265b111d1aa8d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -139,7 +139,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_unboxed_closure(def, region, substs) => {\n+        ty::ty_closure(def, region, substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n             enc_region(w, cx, *region);\n             enc_substs(w, cx, substs);"}, {"sha": "fcc2be985a5561771d7ad024a4469580db10bec4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -21,7 +21,7 @@ use metadata::encoder as e;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n-use metadata::tydecode::{RegionParameter, UnboxedClosureSource};\n+use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::mem_categorization::Typer;\n use middle::subst;\n@@ -448,10 +448,8 @@ impl tr for def::Def {\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, index, def_id, n) => def::DefTyParam(s, index, def_id.tr(dcx), n),\n           def::DefUse(did) => def::DefUse(did.tr(dcx)),\n-          def::DefUpvar(nid1, nid2, nid3) => {\n-            def::DefUpvar(dcx.tr_id(nid1),\n-                           dcx.tr_id(nid2),\n-                           dcx.tr_id(nid3))\n+          def::DefUpvar(nid1, nid2) => {\n+            def::DefUpvar(dcx.tr_id(nid1), dcx.tr_id(nid2))\n           }\n           def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n           def::DefRegion(nid) => def::DefRegion(dcx.tr_id(nid)),\n@@ -618,8 +616,8 @@ impl<'tcx> tr for MethodOrigin<'tcx> {\n     fn tr(&self, dcx: &DecodeContext) -> MethodOrigin<'tcx> {\n         match *self {\n             ty::MethodStatic(did) => ty::MethodStatic(did.tr(dcx)),\n-            ty::MethodStaticUnboxedClosure(did) => {\n-                ty::MethodStaticUnboxedClosure(did.tr(dcx))\n+            ty::MethodStaticClosure(did) => {\n+                ty::MethodStaticClosure(did.tr(dcx))\n             }\n             ty::MethodTypeParam(ref mp) => {\n                 ty::MethodTypeParam(\n@@ -643,24 +641,23 @@ impl<'tcx> tr for MethodOrigin<'tcx> {\n     }\n }\n \n-pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n-                                   kind: ty::UnboxedClosureKind) {\n+pub fn encode_closure_kind(ebml_w: &mut Encoder, kind: ty::ClosureKind) {\n     use serialize::Encoder;\n \n-    ebml_w.emit_enum(\"UnboxedClosureKind\", |ebml_w| {\n+    ebml_w.emit_enum(\"ClosureKind\", |ebml_w| {\n         match kind {\n-            ty::FnUnboxedClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnUnboxedClosureKind\", 0, 3, |_| {\n+            ty::FnClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnClosureKind\", 0, 3, |_| {\n                     Ok(())\n                 })\n             }\n-            ty::FnMutUnboxedClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnMutUnboxedClosureKind\", 1, 3, |_| {\n+            ty::FnMutClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnMutClosureKind\", 1, 3, |_| {\n                     Ok(())\n                 })\n             }\n-            ty::FnOnceUnboxedClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnOnceUnboxedClosureKind\",\n+            ty::FnOnceClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnOnceClosureKind\",\n                                          2,\n                                          3,\n                                          |_| {\n@@ -736,7 +733,7 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             this.read_enum_variant(&[\"vtable_static\",\n                                      \"vtable_param\",\n                                      \"vtable_error\",\n-                                     \"vtable_unboxed_closure\"],\n+                                     \"vtable_closure\"],\n                                    |this, i| {\n                 Ok(match i {\n                   0 => {\n@@ -763,7 +760,7 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                     )\n                   }\n                   2 => {\n-                    ty::vtable_unboxed_closure(\n+                    ty::vtable_closure(\n                         this.read_enum_variant_arg(0u, |this| {\n                             Ok(this.read_def_id_nodcx(cdata))\n                         }).unwrap()\n@@ -865,8 +862,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     })\n                 }\n \n-                ty::MethodStaticUnboxedClosure(def_id) => {\n-                    this.emit_enum_variant(\"MethodStaticUnboxedClosure\", 1, 1, |this| {\n+                ty::MethodStaticClosure(def_id) => {\n+                    this.emit_enum_variant(\"MethodStaticClosure\", 1, 1, |this| {\n                         Ok(this.emit_def_id(def_id))\n                     })\n                 }\n@@ -1322,15 +1319,12 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for unboxed_closure in tcx.unboxed_closures\n-                              .borrow()\n-                              .get(&ast_util::local_def(id))\n-                              .iter() {\n-        rbml_w.tag(c::tag_table_unboxed_closures, |rbml_w| {\n+    for closure in tcx.closures.borrow().get(&ast_util::local_def(id)).iter() {\n+        rbml_w.tag(c::tag_table_closures, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_closure_type(ecx, &unboxed_closure.closure_type);\n-                encode_unboxed_closure_kind(rbml_w, unboxed_closure.kind)\n+                rbml_w.emit_closure_type(ecx, &closure.closure_type);\n+                encode_closure_kind(rbml_w, closure.kind)\n             })\n         })\n     }\n@@ -1369,8 +1363,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                            -> subst::Substs<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx>;\n-    fn read_unboxed_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                    -> ty::UnboxedClosure<'tcx>;\n+    fn read_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                            -> ty::Closure<'tcx>;\n     fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1436,7 +1430,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                   -> ty::MethodOrigin<'tcx>\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n-            let variants = &[\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n+            let variants = &[\"MethodStatic\", \"MethodStaticClosure\",\n                              \"MethodTypeParam\", \"MethodTraitObject\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n@@ -1447,7 +1441,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n                     1 => {\n                         let def_id = this.read_def_id(dcx);\n-                        ty::MethodStaticUnboxedClosure(def_id)\n+                        ty::MethodStaticClosure(def_id)\n                     }\n \n                     2 => {\n@@ -1797,8 +1791,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                    -> ty::UnboxedClosure<'tcx> {\n+    fn read_closure<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                            -> ty::Closure<'tcx> {\n         let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data(\n                 doc.data,\n@@ -1808,21 +1802,21 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                 |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap();\n         let variants = &[\n-            \"FnUnboxedClosureKind\",\n-            \"FnMutUnboxedClosureKind\",\n-            \"FnOnceUnboxedClosureKind\"\n+            \"FnClosureKind\",\n+            \"FnMutClosureKind\",\n+            \"FnOnceClosureKind\"\n         ];\n-        let kind = self.read_enum(\"UnboxedClosureKind\", |this| {\n+        let kind = self.read_enum(\"ClosureKind\", |this| {\n             this.read_enum_variant(variants, |_, i| {\n                 Ok(match i {\n-                    0 => ty::FnUnboxedClosureKind,\n-                    1 => ty::FnMutUnboxedClosureKind,\n-                    2 => ty::FnOnceUnboxedClosureKind,\n-                    _ => panic!(\"bad enum variant for ty::UnboxedClosureKind\"),\n+                    0 => ty::FnClosureKind,\n+                    1 => ty::FnMutClosureKind,\n+                    2 => ty::FnOnceClosureKind,\n+                    _ => panic!(\"bad enum variant for ty::ClosureKind\"),\n                 })\n             })\n         }).unwrap();\n-        ty::UnboxedClosure {\n+        ty::Closure {\n             closure_type: closure_type,\n             kind: kind,\n         }\n@@ -1864,7 +1858,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                       -> ast::DefId {\n         let r = match source {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n-            TypeParameter | UnboxedClosureSource => dcx.tr_intern_def_id(did)\n+            TypeParameter | ClosureSource => dcx.tr_intern_def_id(did)\n         };\n         debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n@@ -1959,14 +1953,11 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n-                    c::tag_table_unboxed_closures => {\n-                        let unboxed_closure =\n-                            val_dsr.read_unboxed_closure(dcx);\n-                        dcx.tcx\n-                           .unboxed_closures\n-                           .borrow_mut()\n-                           .insert(ast_util::local_def(id),\n-                                   unboxed_closure);\n+                    c::tag_table_closures => {\n+                        let closure =\n+                            val_dsr.read_closure(dcx);\n+                        dcx.tcx.closures.borrow_mut().insert(ast_util::local_def(id),\n+                                                             closure);\n                     }\n                     _ => {\n                         dcx.tcx.sess.bug("}, {"sha": "3db931002d23c05055c3f3332b15e7e9f6dbc404", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                             None => self.check_def_id(def_id)\n                         }\n                     }\n-                    ty::MethodStaticUnboxedClosure(_) => {}\n+                    ty::MethodStaticClosure(_) => {}\n                     ty::MethodTypeParam(ty::MethodParam {\n                         ref trait_ref,\n                         method_num: index,"}, {"sha": "2043dde72f47b26488697253566438d41b4b3a4c", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -43,9 +43,7 @@ pub enum Def {\n     DefTyParam(ParamSpace, u32, ast::DefId, ast::Name),\n     DefUse(ast::DefId),\n     DefUpvar(ast::NodeId,  // id of closed over local\n-             ast::NodeId,  // expr node that creates the closure\n-             ast::NodeId), // block node for the closest enclosing proc\n-                           // or unboxed closure, DUMMY_NODE_ID otherwise\n+             ast::NodeId), // expr node that creates the closure\n \n     /// Note that if it's a tuple struct's definition, the node id of the ast::DefId\n     /// may either refer to the item definition's id or the StructDef.ctor_id.\n@@ -145,7 +143,7 @@ impl Def {\n             }\n             DefLocal(id) |\n             DefSelfTy(id) |\n-            DefUpvar(id, _, _) |\n+            DefUpvar(id, _) |\n             DefRegion(id) |\n             DefTyParamBinder(id) |\n             DefLabel(id) => {"}, {"sha": "70a7b4f13cc83e59be767ccee69a76c9b312475e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -26,7 +26,7 @@ use middle::mem_categorization::Typer;\n use middle::ty::{self};\n use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n-use middle::ty::{MethodStatic, MethodStaticUnboxedClosure};\n+use middle::ty::{MethodStatic, MethodStaticClosure};\n use util::ppaux::Repr;\n \n use std::marker;\n@@ -257,13 +257,13 @@ impl OverloadedCallType {\n         OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n     }\n \n-    fn from_unboxed_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n-                            -> OverloadedCallType {\n+    fn from_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n+                    -> OverloadedCallType {\n         let trait_did =\n-            tcx.unboxed_closures\n+            tcx.closures\n                .borrow()\n                .get(&closure_did)\n-               .expect(\"OverloadedCallType::from_unboxed_closure: didn't \\\n+               .expect(\"OverloadedCallType::from_closure: didn't \\\n                         find closure id\")\n                .kind\n                .trait_did(tcx);\n@@ -276,8 +276,8 @@ impl OverloadedCallType {\n             MethodStatic(def_id) => {\n                 OverloadedCallType::from_method_id(tcx, def_id)\n             }\n-            MethodStaticUnboxedClosure(def_id) => {\n-                OverloadedCallType::from_unboxed_closure(tcx, def_id)\n+            MethodStaticClosure(def_id) => {\n+                OverloadedCallType::from_closure(tcx, def_id)\n             }\n             MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n             MethodTraitObject(MethodObject { ref trait_ref, .. }) => {"}, {"sha": "b33e5a802f1582f6a639431938abaf3c026d8709", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -28,7 +28,7 @@ pub enum SimplifiedType {\n     TupleSimplifiedType(uint),\n     TraitSimplifiedType(ast::DefId),\n     StructSimplifiedType(ast::DefId),\n-    UnboxedClosureSimplifiedType(ast::DefId),\n+    ClosureSimplifiedType(ast::DefId),\n     FunctionSimplifiedType(uint),\n     ParameterSimplifiedType,\n }\n@@ -74,8 +74,8 @@ pub fn simplify_type(tcx: &ty::ctxt,\n             let def_id = tcx.lang_items.owned_box().unwrap();\n             Some(StructSimplifiedType(def_id))\n         }\n-        ty::ty_unboxed_closure(def_id, _, _) => {\n-            Some(UnboxedClosureSimplifiedType(def_id))\n+        ty::ty_closure(def_id, _, _) => {\n+            Some(ClosureSimplifiedType(def_id))\n         }\n         ty::ty_tup(ref tys) => {\n             Some(TupleSimplifiedType(tys.len()))"}, {"sha": "04b3b55df8d2039acde5c21d97dffbb710257966", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -52,7 +52,7 @@ use middle::ty_fold::{TypeFoldable};\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n-use syntax::ast::{Onceness, Unsafety};\n+use syntax::ast::Unsafety;\n use syntax::ast;\n use syntax::abi;\n use syntax::codemap::Span;\n@@ -254,8 +254,6 @@ pub trait Combine<'tcx> : Sized {\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness>;\n-\n     fn projection_tys(&self,\n                       a: &ty::ProjectionTy<'tcx>,\n                       b: &ty::ProjectionTy<'tcx>)\n@@ -514,15 +512,15 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n       }\n \n-      (&ty::ty_unboxed_closure(a_id, a_region, a_substs),\n-       &ty::ty_unboxed_closure(b_id, b_region, b_substs))\n+      (&ty::ty_closure(a_id, a_region, a_substs),\n+       &ty::ty_closure(b_id, b_region, b_substs))\n       if a_id == b_id => {\n-          // All ty_unboxed_closure types with the same id represent\n+          // All ty_closure types with the same id represent\n           // the (anonymous) type of the same closure expression. So\n           // all of their regions should be equated.\n           let region = try!(this.equate().regions(*a_region, *b_region));\n           let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-          Ok(ty::mk_unboxed_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n+          Ok(ty::mk_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {"}, {"sha": "f0bde22286488c3fb6272dac63018e0b4fb7c1e1", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -21,7 +21,7 @@ use middle::infer::{TypeTrace, Subtype};\n use middle::infer::type_variable::{EqTo};\n use util::ppaux::{Repr};\n \n-use syntax::ast::{Onceness, Unsafety};\n+use syntax::ast::Unsafety;\n \n pub struct Equate<'f, 'tcx: 'f> {\n     fields: CombineFields<'f, 'tcx>\n@@ -78,14 +78,6 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n-        if a != b {\n-            Err(ty::terr_onceness_mismatch(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n-        }\n-    }\n-\n     fn builtin_bounds(&self,\n                       a: BuiltinBounds,\n                       b: BuiltinBounds)"}, {"sha": "8e9911aaefa0a5d3fc673893912c2973a08317e1", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ty_bare_fn(..) |\n             ty::ty_trait(..) |\n             ty::ty_struct(..) |\n-            ty::ty_unboxed_closure(..) |\n+            ty::ty_closure(..) |\n             ty::ty_tup(..) |\n             ty::ty_projection(..) |\n             ty::ty_param(..) => {"}, {"sha": "ff0c2d92f45eeae58ec193540288669275f7055b", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -19,8 +19,7 @@ use super::{TypeTrace, Subtype};\n \n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n-use syntax::ast::{Many, Once, MutImmutable, MutMutable};\n-use syntax::ast::{Onceness, Unsafety};\n+use syntax::ast::{MutImmutable, MutMutable, Unsafety};\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n@@ -87,13 +86,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n-        match (a, b) {\n-            (Many, _) | (_, Many) => Ok(Many),\n-            (Once, Once) => Ok(Once)\n-        }\n-    }\n-\n     fn builtin_bounds(&self,\n                       a: ty::BuiltinBounds,\n                       b: ty::BuiltinBounds)"}, {"sha": "204560e87ee3b2718943c488adc71b5d6221d3ac", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -19,9 +19,7 @@ use super::{TypeTrace, Subtype};\n \n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n-use syntax::ast::{Many, Once};\n-use syntax::ast::{Onceness, Unsafety};\n-use syntax::ast::{MutMutable, MutImmutable};\n+use syntax::ast::{MutMutable, MutImmutable, Unsafety};\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n@@ -83,13 +81,6 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n-        match (a, b) {\n-            (Once, _) | (_, Once) => Ok(Once),\n-            (Many, Many) => Ok(Many)\n-        }\n-    }\n-\n     fn builtin_bounds(&self,\n                       a: ty::BuiltinBounds,\n                       b: ty::BuiltinBounds)"}, {"sha": "1e0d14544ff888c882b06034ca11692241423735", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -23,7 +23,7 @@ use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use util::ppaux::{Repr};\n \n-use syntax::ast::{Onceness, MutImmutable, MutMutable, Unsafety};\n+use syntax::ast::{MutImmutable, MutMutable, Unsafety};\n \n \n /// \"Greatest lower bound\" (common subtype)\n@@ -99,12 +99,6 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         })\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n-        self.lub().oncenesses(a, b).compare(b, || {\n-            ty::terr_onceness_mismatch(expected_found(self, a, b))\n-        })\n-    }\n-\n     fn builtin_bounds(&self, a: BuiltinBounds, b: BuiltinBounds)\n                       -> cres<'tcx, BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds."}, {"sha": "c1ce5945946c294a594e367ed92da4f70726bb4b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -113,11 +113,11 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn fn_trait_kind(&self, id: ast::DefId) -> Option<ty::UnboxedClosureKind> {\n+    pub fn fn_trait_kind(&self, id: ast::DefId) -> Option<ty::ClosureKind> {\n         let def_id_kinds = [\n-            (self.fn_trait(), ty::FnUnboxedClosureKind),\n-            (self.fn_mut_trait(), ty::FnMutUnboxedClosureKind),\n-            (self.fn_once_trait(), ty::FnOnceUnboxedClosureKind),\n+            (self.fn_trait(), ty::FnClosureKind),\n+            (self.fn_mut_trait(), ty::FnMutClosureKind),\n+            (self.fn_once_trait(), ty::FnOnceClosureKind),\n             ];\n \n         for &(opt_def_id, kind) in def_id_kinds.iter() {\n@@ -328,4 +328,6 @@ lets_do_this! {\n     IteratorItem,                    \"iterator\",                iterator;\n \n     StackExhaustedLangItem,          \"stack_exhausted\",         stack_exhausted;\n+\n+    DebugTraitLangItem,              \"debug_trait\",             debug_trait;\n }"}, {"sha": "0131b9f1491e7afbb5b467aa30ad05819b0a6ee1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -114,7 +114,7 @@ use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::region::CodeExtent;\n use middle::ty;\n-use middle::ty::UnboxedClosureTyper;\n+use middle::ty::ClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n \n@@ -1519,8 +1519,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n-            ty::ty_unboxed_closure(closure_def_id, _, substs) =>\n-                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.output(),\n+            ty::ty_closure(closure_def_id, _, substs) =>\n+                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ =>\n                 ty::ty_fn_ret(fn_ty),\n         }"}, {"sha": "9954aa3922635667f1db689409a14aa67bd3729d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -104,10 +104,7 @@ pub enum categorization<'tcx> {\n #[derive(Clone, Copy, PartialEq, Show)]\n pub struct Upvar {\n     pub id: ty::UpvarId,\n-    // Unboxed closure kinds are used even for old-style closures for simplicity\n-    pub kind: ty::UnboxedClosureKind,\n-    // Is this from an unboxed closure?  Used only for diagnostics.\n-    pub is_unboxed: bool\n+    pub kind: ty::ClosureKind\n }\n \n // different kinds of pointers:\n@@ -269,7 +266,7 @@ pub type McResult<T> = Result<T, ()>;\n /// In the borrow checker, in contrast, type checking is complete and we\n /// know that no errors have occurred, so we simply consult the tcx and we\n /// can be sure that only `Ok` results will occur.\n-pub trait Typer<'tcx> : ty::UnboxedClosureTyper<'tcx> {\n+pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n@@ -593,13 +590,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               }))\n           }\n \n-          def::DefUpvar(var_id, fn_node_id, _) => {\n+          def::DefUpvar(var_id, fn_node_id) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n-                  ty::ty_unboxed_closure(closure_id, _, _) => {\n-                      let kind = self.typer.unboxed_closure_kind(closure_id);\n+                  ty::ty_closure(closure_id, _, _) => {\n+                      let kind = self.typer.closure_kind(closure_id);\n                       let mode = self.typer.capture_mode(fn_node_id);\n-                      self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, true)\n+                      self.cat_upvar(id, span, var_id, fn_node_id, kind, mode)\n                   }\n                   _ => {\n                       self.tcx().sess.span_bug(\n@@ -631,9 +628,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  span: Span,\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId,\n-                 kind: ty::UnboxedClosureKind,\n-                 mode: ast::CaptureClause,\n-                 is_unboxed: bool)\n+                 kind: ty::ClosureKind,\n+                 mode: ast::CaptureClause)\n                  -> McResult<cmt<'tcx>> {\n         // An upvar can have up to 3 components.  The base is a\n         // `cat_upvar`.  Next, we add a deref through the implicit\n@@ -654,8 +650,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // Fn             | copied -> &'env      | upvar -> &'env -> &'up bk\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n-        // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n-        // old proc/once  | copied               | N/A\n         let var_ty = try!(self.node_ty(var_id));\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n@@ -666,12 +660,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         // Construct information about env pointer dereference, if any\n         let mutbl = match kind {\n-            ty::FnOnceUnboxedClosureKind => None, // None, env is by-value\n-            ty::FnMutUnboxedClosureKind => match mode { // Depends on capture type\n+            ty::FnOnceClosureKind => None, // None, env is by-value\n+            ty::FnMutClosureKind => match mode { // Depends on capture type\n                 ast::CaptureByValue => Some(var_mutbl), // Mutable if the original var is\n                 ast::CaptureByRef => Some(McDeclared) // Mutable regardless\n             },\n-            ty::FnUnboxedClosureKind => Some(McImmutable) // Never mutable\n+            ty::FnClosureKind => Some(McImmutable) // Never mutable\n         };\n         let env_info = mutbl.map(|env_mutbl| {\n             // Look up the node ID of the closure body so we can construct\n@@ -711,8 +705,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     span: span,\n                     cat: cat_upvar(Upvar {\n                         id: upvar_id,\n-                        kind: kind,\n-                        is_unboxed: is_unboxed\n+                        kind: kind\n                     }),\n                     mutbl: var_mutbl,\n                     ty: var_ty,\n@@ -751,8 +744,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     span: span,\n                     cat: cat_upvar(Upvar {\n                         id: upvar_id,\n-                        kind: kind,\n-                        is_unboxed: is_unboxed\n+                        kind: kind\n                     }),\n                     mutbl: McImmutable,\n                     ty: self.tcx().types.err,\n@@ -1566,7 +1558,7 @@ fn element_kind(t: Ty) -> ElementKind {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::UnboxedClosureKind {\n+impl<'tcx> Repr<'tcx> for ty::ClosureKind {\n     fn repr(&self, _: &ty::ctxt) -> String {\n         format!(\"Upvar({:?})\", self)\n     }\n@@ -1581,9 +1573,9 @@ impl<'tcx> Repr<'tcx> for Upvar {\n impl<'tcx> UserString<'tcx> for Upvar {\n     fn user_string(&self, _: &ty::ctxt) -> String {\n         let kind = match self.kind {\n-            ty::FnUnboxedClosureKind => \"Fn\",\n-            ty::FnMutUnboxedClosureKind => \"FnMut\",\n-            ty::FnOnceUnboxedClosureKind => \"FnOnce\",\n+            ty::FnClosureKind => \"Fn\",\n+            ty::FnMutClosureKind => \"FnMut\",\n+            ty::FnOnceClosureKind => \"FnOnce\",\n         };\n         format!(\"captured outer variable in an `{}` closure\", kind)\n     }"}, {"sha": "7b5af0ab1aa2ff2cc848ac7da12d25645b2cd961", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -311,7 +311,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                         ty::MethodStatic(def_id) => {\n                             def_id\n                         }\n-                        ty::MethodStaticUnboxedClosure(def_id) => {\n+                        ty::MethodStaticClosure(def_id) => {\n                             def_id\n                         }\n                         ty::MethodTypeParam(ty::MethodParam {"}, {"sha": "e3363aa8fb70a6f8c47c5a4593546db2975ce653", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -138,7 +138,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n             tt.principal_def_id().krate == ast::LOCAL_CRATE\n         }\n \n-        ty::ty_unboxed_closure(..) |\n+        ty::ty_closure(..) |\n         ty::ty_infer(..) |\n         ty::ty_open(..) |\n         ty::ty_err => {"}, {"sha": "d08857c96133eaac013260662fa1a4a74dbb9350", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -110,7 +110,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// `projection_ty` again.\n     pub fn normalize_projection_type<'a>(&mut self,\n                                          infcx: &InferCtxt<'a,'tcx>,\n-                                         typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                         typer: &ty::ClosureTyper<'tcx>,\n                                          projection_ty: ty::ProjectionTy<'tcx>,\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n@@ -186,7 +186,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn select_all_or_error<'a>(&mut self,\n                                    infcx: &InferCtxt<'a,'tcx>,\n-                                   typer: &ty::UnboxedClosureTyper<'tcx>)\n+                                   typer: &ty::ClosureTyper<'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         try!(self.select_where_possible(infcx, typer));\n@@ -211,7 +211,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// results in `O(n^2)` performance (#18208).\n     pub fn select_new_obligations<'a>(&mut self,\n                                       infcx: &InferCtxt<'a,'tcx>,\n-                                      typer: &ty::UnboxedClosureTyper<'tcx>)\n+                                      typer: &ty::ClosureTyper<'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, typer);\n@@ -220,7 +220,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn select_where_possible<'a>(&mut self,\n                                      infcx: &InferCtxt<'a,'tcx>,\n-                                     typer: &ty::UnboxedClosureTyper<'tcx>)\n+                                     typer: &ty::ClosureTyper<'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, typer);"}, {"sha": "8d3888fcfdbb50012c2b528bd4daac70a139e4d5", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -232,11 +232,10 @@ pub enum Vtable<'tcx, N> {\n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n \n-    /// Vtable automatically generated for an unboxed closure. The def\n-    /// ID is the ID of the closure expression. This is a `VtableImpl`\n-    /// in spirit, but the impl is generated by the compiler and does\n-    /// not appear in the source.\n-    VtableUnboxedClosure(ast::DefId, subst::Substs<'tcx>),\n+    /// Vtable automatically generated for a closure. The def ID is the ID\n+    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n+    /// impl is generated by the compiler and does not appear in the source.\n+    VtableClosure(ast::DefId, subst::Substs<'tcx>),\n \n     /// Same as above, but for a fn pointer type with the given signature.\n     VtableFnPointer(ty::Ty<'tcx>),\n@@ -296,7 +295,7 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                       typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                       typer: &ty::ClosureTyper<'tcx>,\n                                        ty: Ty<'tcx>,\n                                        bound: ty::BuiltinBound,\n                                        span: Span)\n@@ -361,7 +360,7 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n }\n \n pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                                 typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                                 typer: &ty::ClosureTyper<'tcx>,\n                                                  ty: Ty<'tcx>,\n                                                  bound: ty::BuiltinBound,\n                                                  span: Span)\n@@ -446,7 +445,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n             VtableFnPointer(..) => (&[]).iter(),\n-            VtableUnboxedClosure(..) => (&[]).iter(),\n+            VtableClosure(..) => (&[]).iter(),\n             VtableParam(ref n) => n.iter(),\n             VtableObject(_) => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n@@ -457,7 +456,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n-            VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n+            VtableClosure(d, ref s) => VtableClosure(d, s.clone()),\n             VtableParam(ref n) => VtableParam(n.iter().map(op).collect()),\n             VtableObject(ref p) => VtableObject(p.clone()),\n             VtableBuiltin(ref b) => VtableBuiltin(b.map_nested(op)),\n@@ -470,7 +469,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         match self {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n-            VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n+            VtableClosure(d, s) => VtableClosure(d, s),\n             VtableParam(n) => VtableParam(n.into_iter().map(op).collect()),\n             VtableObject(p) => VtableObject(p),\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),"}, {"sha": "ffb38091a873549524cd7b751ad4fdd90cb0003d", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -579,7 +579,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // in `assemble_candidates_from_param_env`.\n         }\n         super::VtableBuiltin(..) |\n-        super::VtableUnboxedClosure(..) |\n+        super::VtableClosure(..) |\n         super::VtableFnPointer(..) => {\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug("}, {"sha": "b2e8bbe059fe64dfb340f362a0b29c8675dcb6e3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -25,7 +25,7 @@ use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n-use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure,\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n             VtableFnPointer, VtableObject};\n use super::{VtableImplData, VtableObjectData, VtableBuiltinData};\n use super::object_safety;\n@@ -47,7 +47,7 @@ use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    closure_typer: &'cx (ty::UnboxedClosureTyper<'tcx>+'cx),\n+    closure_typer: &'cx (ty::ClosureTyper<'tcx>+'cx),\n \n     /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n@@ -143,7 +143,7 @@ enum SelectionCandidate<'tcx> {\n \n     /// Implementation of a `Fn`-family trait by one of the\n     /// anonymous types generated for a `||` expression.\n-    UnboxedClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n+    ClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -181,7 +181,7 @@ enum EvaluationResult<'tcx> {\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-               closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n+               closure_typer: &'cx ty::ClosureTyper<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n@@ -192,7 +192,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-                      closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n+                      closure_typer: &'cx ty::ClosureTyper<'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n@@ -751,7 +751,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // For the time being, we ignore user-defined impls for builtin-bounds, other than\n                 // `Copy`.\n                 // (And unboxed candidates only apply to the Fn/FnMut/etc traits.)\n-                try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n+                try!(self.assemble_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n                 try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n                 self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n@@ -943,15 +943,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     /// Check for the artificial impl that the compiler will create for an obligation like `X :\n-    /// FnMut<..>` where `X` is an unboxed closure type.\n+    /// FnMut<..>` where `X` is a closure type.\n     ///\n-    /// Note: the type parameters on an unboxed closure candidate are modeled as *output* type\n+    /// Note: the type parameters on a closure candidate are modeled as *output* type\n     /// parameters and hence do not affect whether this trait is a match or not. They will be\n     /// unified during the confirmation step.\n-    fn assemble_unboxed_closure_candidates(&mut self,\n-                                           obligation: &TraitObligation<'tcx>,\n-                                           candidates: &mut SelectionCandidateSet<'tcx>)\n-                                           -> Result<(),SelectionError<'tcx>>\n+    fn assemble_closure_candidates(&mut self,\n+                                   obligation: &TraitObligation<'tcx>,\n+                                   candidates: &mut SelectionCandidateSet<'tcx>)\n+                                   -> Result<(),SelectionError<'tcx>>\n     {\n         let kind = match self.fn_family_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n@@ -960,7 +960,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::ty_unboxed_closure(id, _, ref substs) => (id, substs.clone()),\n+            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n                 candidates.ambiguous = true;\n                 return Ok(());\n@@ -973,12 +973,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                kind,\n                obligation.repr(self.tcx()));\n \n-        let closure_kind = self.closure_typer.unboxed_closure_kind(closure_def_id);\n+        let closure_kind = self.closure_typer.closure_kind(closure_def_id);\n \n         debug!(\"closure_kind = {:?}\", closure_kind);\n \n         if closure_kind == kind {\n-            candidates.vec.push(UnboxedClosureCandidate(closure_def_id, substs.clone()));\n+            candidates.vec.push(ClosureCandidate(closure_def_id, substs.clone()));\n         }\n \n         Ok(())\n@@ -1453,7 +1453,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(If(tys.clone()))\n             }\n \n-            ty::ty_unboxed_closure(def_id, _, substs) => {\n+            ty::ty_closure(def_id, _, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1471,7 +1471,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return Ok(ParameterBuiltin);\n                 }\n \n-                match self.closure_typer.unboxed_closure_upvars(def_id, substs) {\n+                match self.closure_typer.closure_upvars(def_id, substs) {\n                     Some(upvars) => {\n                         Ok(If(upvars.iter().map(|c| c.ty).collect()))\n                     }\n@@ -1616,9 +1616,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableImpl(vtable_impl))\n             }\n \n-            UnboxedClosureCandidate(closure_def_id, substs) => {\n-                try!(self.confirm_unboxed_closure_candidate(obligation, closure_def_id, &substs));\n-                Ok(VtableUnboxedClosure(closure_def_id, substs))\n+            ClosureCandidate(closure_def_id, substs) => {\n+                try!(self.confirm_closure_candidate(obligation, closure_def_id, &substs));\n+                Ok(VtableClosure(closure_def_id, substs))\n             }\n \n             ObjectCandidate => {\n@@ -1894,20 +1894,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(self_ty)\n     }\n \n-    fn confirm_unboxed_closure_candidate(&mut self,\n-                                         obligation: &TraitObligation<'tcx>,\n-                                         closure_def_id: ast::DefId,\n-                                         substs: &Substs<'tcx>)\n-                                         -> Result<(),SelectionError<'tcx>>\n+    fn confirm_closure_candidate(&mut self,\n+                                 obligation: &TraitObligation<'tcx>,\n+                                 closure_def_id: ast::DefId,\n+                                 substs: &Substs<'tcx>)\n+                                 -> Result<(),SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_unboxed_closure_candidate({},{},{})\",\n+        debug!(\"confirm_closure_candidate({},{},{})\",\n                obligation.repr(self.tcx()),\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = self.closure_typer.unboxed_closure_type(closure_def_id, substs);\n+        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n \n-        debug!(\"confirm_unboxed_closure_candidate: closure_def_id={} closure_type={}\",\n+        debug!(\"confirm_closure_candidate: closure_def_id={} closure_type={}\",\n                closure_def_id.repr(self.tcx()),\n                closure_type.repr(self.tcx()));\n \n@@ -1923,7 +1923,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             substs: self.tcx().mk_substs(trait_substs),\n         }));\n \n-        debug!(\"confirm_unboxed_closure_candidate(closure_def_id={}, trait_ref={})\",\n+        debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={})\",\n                closure_def_id.repr(self.tcx()),\n                trait_ref.repr(self.tcx()));\n \n@@ -1932,7 +1932,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                      trait_ref)\n     }\n \n-    /// In the case of unboxed closure types and fn pointers,\n+    /// In the case of closure types and fn pointers,\n     /// we currently treat the input type parameters on the trait as\n     /// outputs. This means that when we have a match we have only\n     /// considered the self type, so we have to go back and make sure\n@@ -1942,7 +1942,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// errors as if there is no applicable impl, but rather report\n     /// errors are about mismatched argument types.\n     ///\n-    /// Here is an example. Imagine we have an unboxed closure expression\n+    /// Here is an example. Imagine we have an closure expression\n     /// and we desugared it so that the type of the expression is\n     /// `Closure`, and `Closure` expects an int as argument. Then it\n     /// is \"as if\" the compiler generated this impl:\n@@ -2259,15 +2259,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn fn_family_trait_kind(&self,\n                             trait_def_id: ast::DefId)\n-                            -> Option<ty::UnboxedClosureKind>\n+                            -> Option<ty::ClosureKind>\n     {\n         let tcx = self.tcx();\n         if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            Some(ty::FnUnboxedClosureKind)\n+            Some(ty::FnClosureKind)\n         } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            Some(ty::FnMutUnboxedClosureKind)\n+            Some(ty::FnMutClosureKind)\n         } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            Some(ty::FnOnceUnboxedClosureKind)\n+            Some(ty::FnOnceClosureKind)\n         } else {\n             None\n         }\n@@ -2318,8 +2318,8 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ObjectCandidate => {\n                 format!(\"ObjectCandidate\")\n             }\n-            UnboxedClosureCandidate(c, ref s) => {\n-                format!(\"UnboxedClosureCandidate({:?},{})\", c, s.repr(tcx))\n+            ClosureCandidate(c, ref s) => {\n+                format!(\"ClosureCandidate({:?},{})\", c, s.repr(tcx))\n             }\n         }\n     }"}, {"sha": "beb28260834acf4e8e46bae3828a1645ba5665b3", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -367,8 +367,8 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n             super::VtableImpl(ref v) =>\n                 v.repr(tcx),\n \n-            super::VtableUnboxedClosure(ref d, ref s) =>\n-                format!(\"VtableUnboxedClosure({},{})\",\n+            super::VtableClosure(ref d, ref s) =>\n+                format!(\"VtableClosure({},{})\",\n                         d.repr(tcx),\n                         s.repr(tcx)),\n "}, {"sha": "0ee26ce1cd3cb0329eaefee074c8f101e6a99bcd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 88, "deletions": 104, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -16,7 +16,7 @@ pub use self::BuiltinBound::*;\n pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n-pub use self::UnboxedClosureKind::*;\n+pub use self::ClosureKind::*;\n pub use self::ast_ty_to_ty_cache_entry::*;\n pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n@@ -81,8 +81,7 @@ use std::collections::{HashMap, HashSet};\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n-use syntax::ast::{Onceness, StmtExpr, StmtSemi, StructField, UnnamedField};\n-use syntax::ast::{Visibility};\n+use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, lit_is_str, local_def, PostExpansionMethod};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n@@ -433,8 +432,8 @@ pub enum MethodOrigin<'tcx> {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n \n-    // fully statically resolved unboxed closure invocation\n-    MethodStaticUnboxedClosure(ast::DefId),\n+    // fully statically resolved closure invocation\n+    MethodStaticClosure(ast::DefId),\n \n     // method invoked on a type parameter with a bounded trait\n     MethodTypeParam(MethodParam<'tcx>),\n@@ -566,10 +565,10 @@ pub enum vtable_origin<'tcx> {\n     vtable_param(param_index, uint),\n \n     /*\n-      Vtable automatically generated for an unboxed closure. The def ID is the\n+      Vtable automatically generated for a closure. The def ID is the\n       ID of the closure expression.\n      */\n-    vtable_unboxed_closure(ast::DefId),\n+    vtable_closure(ast::DefId),\n \n     /*\n       Asked to determine the vtable for ty_err. This is the value used\n@@ -786,9 +785,9 @@ pub struct ctxt<'tcx> {\n \n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n-    /// Records the type of each unboxed closure. The def ID is the ID of the\n-    /// expression defining the unboxed closure.\n-    pub unboxed_closures: RefCell<DefIdMap<UnboxedClosure<'tcx>>>,\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closures: RefCell<DefIdMap<Closure<'tcx>>>,\n \n     pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n@@ -913,7 +912,7 @@ impl<'tcx> ctxt<'tcx> {\n         sty_debug_print!(\n             self,\n             ty_enum, ty_uniq, ty_vec, ty_ptr, ty_rptr, ty_bare_fn, ty_trait,\n-            ty_struct, ty_unboxed_closure, ty_tup, ty_param, ty_open, ty_infer, ty_projection);\n+            ty_struct, ty_closure, ty_tup, ty_param, ty_open, ty_infer, ty_projection);\n \n         println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n@@ -1376,7 +1375,7 @@ pub enum sty<'tcx> {\n     ty_trait(Box<TyTrait<'tcx>>),\n     ty_struct(DefId, &'tcx Substs<'tcx>),\n \n-    ty_unboxed_closure(DefId, &'tcx Region, &'tcx Substs<'tcx>),\n+    ty_closure(DefId, &'tcx Region, &'tcx Substs<'tcx>),\n \n     ty_tup(Vec<Ty<'tcx>>),\n \n@@ -1535,7 +1534,6 @@ pub struct expected_found<T> {\n pub enum type_err<'tcx> {\n     terr_mismatch,\n     terr_unsafety_mismatch(expected_found<ast::Unsafety>),\n-    terr_onceness_mismatch(expected_found<Onceness>),\n     terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n     terr_box_mutability,\n@@ -2264,30 +2262,30 @@ pub struct ItemSubsts<'tcx> {\n     pub substs: Substs<'tcx>,\n }\n \n-/// Records information about each unboxed closure.\n+/// Records information about each closure.\n #[derive(Clone)]\n-pub struct UnboxedClosure<'tcx> {\n-    /// The type of the unboxed closure.\n+pub struct Closure<'tcx> {\n+    /// The type of the closure.\n     pub closure_type: ClosureTy<'tcx>,\n-    /// The kind of unboxed closure this is.\n-    pub kind: UnboxedClosureKind,\n+    /// The kind of closure this is.\n+    pub kind: ClosureKind,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Show)]\n-pub enum UnboxedClosureKind {\n-    FnUnboxedClosureKind,\n-    FnMutUnboxedClosureKind,\n-    FnOnceUnboxedClosureKind,\n+pub enum ClosureKind {\n+    FnClosureKind,\n+    FnMutClosureKind,\n+    FnOnceClosureKind,\n }\n \n-impl UnboxedClosureKind {\n+impl ClosureKind {\n     pub fn trait_did(&self, cx: &ctxt) -> ast::DefId {\n         let result = match *self {\n-            FnUnboxedClosureKind => cx.lang_items.require(FnTraitLangItem),\n-            FnMutUnboxedClosureKind => {\n+            FnClosureKind => cx.lang_items.require(FnTraitLangItem),\n+            FnMutClosureKind => {\n                 cx.lang_items.require(FnMutTraitLangItem)\n             }\n-            FnOnceUnboxedClosureKind => {\n+            FnOnceClosureKind => {\n                 cx.lang_items.require(FnOnceTraitLangItem)\n             }\n         };\n@@ -2298,23 +2296,21 @@ impl UnboxedClosureKind {\n     }\n }\n \n-pub trait UnboxedClosureTyper<'tcx> {\n+pub trait ClosureTyper<'tcx> {\n     fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind;\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind;\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>;\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>;\n \n     // Returns `None` if the upvar types cannot yet be definitively determined.\n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<UnboxedClosureUpvar<'tcx>>>;\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ClosureUpvar<'tcx>>>;\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -2407,7 +2403,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         extern_const_variants: RefCell::new(DefIdMap()),\n         method_map: RefCell::new(FnvHashMap()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n-        unboxed_closures: RefCell::new(DefIdMap()),\n+        closures: RefCell::new(DefIdMap()),\n         node_lint_levels: RefCell::new(FnvHashMap()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n@@ -2454,19 +2450,16 @@ impl<'tcx> ctxt<'tcx> {\n         region\n     }\n \n-    pub fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.unboxed_closures.borrow()[def_id].kind\n+    pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        self.closures.borrow()[def_id].kind\n     }\n \n-    pub fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    pub fn closure_type(&self,\n+                        def_id: ast::DefId,\n+                        substs: &subst::Substs<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n     {\n-        self.unboxed_closures.borrow()[def_id].closure_type.subst(self, substs)\n+        self.closures.borrow()[def_id].closure_type.subst(self, substs)\n     }\n }\n \n@@ -2574,7 +2567,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty_unboxed_closure(_, region, substs) => {\n+            &ty_closure(_, region, substs) => {\n                 self.add_region(*region);\n                 self.add_substs(substs);\n             }\n@@ -2843,10 +2836,10 @@ pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_unboxed_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n-                                region: &'tcx Region, substs: &'tcx Substs<'tcx>)\n-                                -> Ty<'tcx> {\n-    mk_t(cx, ty_unboxed_closure(closure_id, region, substs))\n+pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n+                        region: &'tcx Region, substs: &'tcx Substs<'tcx>)\n+                        -> Ty<'tcx> {\n+    mk_t(cx, ty_closure(closure_id, region, substs))\n }\n \n pub fn mk_var<'tcx>(cx: &ctxt<'tcx>, v: TyVid) -> Ty<'tcx> {\n@@ -3057,7 +3050,7 @@ pub fn type_is_vec(ty: Ty) -> bool {\n pub fn type_is_structural(ty: Ty) -> bool {\n     match ty.sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) |\n-      ty_vec(_, Some(_)) | ty_unboxed_closure(..) => true,\n+      ty_vec(_, Some(_)) | ty_closure(..) => true,\n       _ => type_is_slice(ty) | type_is_trait(ty)\n     }\n }\n@@ -3422,11 +3415,10 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_unboxed_closure(did, r, substs) => {\n-                // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n-                // unboxed closure.\n+            ty_closure(did, r, substs) => {\n+                // FIXME(#14449): `borrowed_contents` below assumes `&mut` closure.\n                 let param_env = ty::empty_parameter_environment(cx);\n-                let upvars = unboxed_closure_upvars(&param_env, did, substs).unwrap();\n+                let upvars = closure_upvars(&param_env, did, substs).unwrap();\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache))\n                     | borrowed_contents(*r, MutMutable)\n@@ -3690,9 +3682,9 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n \n             ty_err |\n             ty_infer(_) |\n-            ty_unboxed_closure(..) => {\n+            ty_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n-                // inference by-products or unboxed closure types\n+                // inference by-products or closure types\n                 cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n                                     ty).as_slice())\n             }\n@@ -3784,9 +3776,9 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n-            ty_unboxed_closure(..) => {\n-                // this check is run on type definitions, so we don't expect to see\n-                // unboxed closure types\n+            ty_closure(..) => {\n+                // this check is run on type definitions, so we don't expect\n+                // to see closure types\n                 cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n                                     ty).as_slice())\n             }\n@@ -4698,7 +4690,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_struct(id, _) => {\n             format!(\"struct `{}`\", item_path_str(cx, id))\n         }\n-        ty_unboxed_closure(..) => \"closure\".to_string(),\n+        ty_closure(..) => \"closure\".to_string(),\n         ty_tup(_) => \"tuple\".to_string(),\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n@@ -4742,11 +4734,6 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                     values.expected,\n                     values.found)\n         }\n-        terr_onceness_mismatch(values) => {\n-            format!(\"expected {} fn, found {} fn\",\n-                    values.expected,\n-                    values.found)\n-        }\n         terr_mutability => \"values differ in mutability\".to_string(),\n         terr_box_mutability => {\n             \"boxed values differ in mutability\".to_string()\n@@ -5118,7 +5105,7 @@ pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n             Some(tt.principal_def_id()),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n-        ty_unboxed_closure(id, _, _) =>\n+        ty_closure(id, _, _) =>\n             Some(id),\n         _ =>\n             None\n@@ -5626,17 +5613,17 @@ pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n }\n \n #[derive(Copy, Clone)]\n-pub struct UnboxedClosureUpvar<'tcx> {\n+pub struct ClosureUpvar<'tcx> {\n     pub def: def::Def,\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n }\n \n-// Returns a list of `UnboxedClosureUpvar`s for each upvar.\n-pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n-                                    closure_id: ast::DefId,\n-                                    substs: &Substs<'tcx>)\n-                                    -> Option<Vec<UnboxedClosureUpvar<'tcx>>>\n+// Returns a list of `ClosureUpvar`s for each upvar.\n+pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n+                            closure_id: ast::DefId,\n+                            substs: &Substs<'tcx>)\n+                            -> Option<Vec<ClosureUpvar<'tcx>>>\n {\n     // Presently an unboxed closure type cannot \"escape\" out of a\n     // function, so we will only encounter ones that originated in the\n@@ -5660,9 +5647,9 @@ pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n \n                         match capture_mode {\n                             ast::CaptureByValue => {\n-                                Some(UnboxedClosureUpvar { def: freevar.def,\n-                                                           span: freevar.span,\n-                                                           ty: freevar_ty })\n+                                Some(ClosureUpvar { def: freevar.def,\n+                                                    span: freevar.span,\n+                                                    ty: freevar_ty })\n                             }\n \n                             ast::CaptureByRef => {\n@@ -5688,7 +5675,7 @@ pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n                                         freevar_ty\n                                     }\n                                 };\n-                                Some(UnboxedClosureUpvar {\n+                                Some(ClosureUpvar {\n                                     def: freevar.def,\n                                     span: freevar.span,\n                                     ty: freevar_ref_ty,\n@@ -6240,7 +6227,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 ty_open(_) => byte!(22),\n                 ty_infer(_) => unreachable!(),\n                 ty_err => byte!(23),\n-                ty_unboxed_closure(d, r, _) => {\n+                ty_closure(d, r, _) => {\n                     byte!(24);\n                     did(state, d);\n                     region(state, *r);\n@@ -6476,32 +6463,29 @@ impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n     }\n }\n \n-impl<'a,'tcx> UnboxedClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n+impl<'a,'tcx> ClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n     fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n         self\n     }\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.tcx.unboxed_closure_kind(def_id)\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        self.tcx.closure_kind(def_id)\n     }\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n     {\n-        self.tcx.unboxed_closure_type(def_id, substs)\n+        self.tcx.closure_type(def_id, substs)\n     }\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<UnboxedClosureUpvar<'tcx>>>\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ClosureUpvar<'tcx>>>\n     {\n-        unboxed_closure_upvars(self, def_id, substs)\n+        closure_upvars(self, def_id, substs)\n     }\n }\n \n@@ -6533,7 +6517,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_struct(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n-            ty_unboxed_closure(_, region, substs) => {\n+            ty_closure(_, region, substs) => {\n                 accumulator.push(*region);\n                 accum_substs(accumulator, substs);\n             }\n@@ -6826,8 +6810,8 @@ impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n                 format!(\"vtable_param({:?}, {})\", x, y)\n             }\n \n-            vtable_unboxed_closure(def_id) => {\n-                format!(\"vtable_unboxed_closure({:?})\", def_id)\n+            vtable_closure(def_id) => {\n+                format!(\"vtable_closure({:?})\", def_id)\n             }\n \n             vtable_error => {\n@@ -7064,7 +7048,7 @@ impl<'tcx> HasProjectionTypes for ClosureTy<'tcx> {\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for UnboxedClosureUpvar<'tcx> {\n+impl<'tcx> HasProjectionTypes for ClosureUpvar<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.ty.has_projection_types()\n     }\n@@ -7285,9 +7269,9 @@ impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for UnboxedClosureUpvar<'tcx> {\n+impl<'tcx> Repr<'tcx> for ClosureUpvar<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"UnboxedClosureUpvar({},{})\",\n+        format!(\"ClosureUpvar({},{})\",\n                 self.def.repr(tcx),\n                 self.ty.repr(tcx))\n     }"}, {"sha": "86552705963c9865d03890e79d4a7eff6cebd0c5", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -304,8 +304,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n             ty::MethodStatic(def_id) => {\n                 ty::MethodStatic(def_id)\n             }\n-            ty::MethodStaticUnboxedClosure(def_id) => {\n-                ty::MethodStaticUnboxedClosure(def_id)\n+            ty::MethodStaticClosure(def_id) => {\n+                ty::MethodStaticClosure(def_id)\n             }\n             ty::MethodTypeParam(ref param) => {\n                 ty::MethodTypeParam(ty::MethodParam {\n@@ -337,8 +337,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::vtable_origin<'tcx> {\n             ty::vtable_param(n, b) => {\n                 ty::vtable_param(n, b)\n             }\n-            ty::vtable_unboxed_closure(def_id) => {\n-                ty::vtable_unboxed_closure(def_id)\n+            ty::vtable_closure(def_id) => {\n+                ty::vtable_closure(def_id)\n             }\n             ty::vtable_error => {\n                 ty::vtable_error\n@@ -499,8 +499,8 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n-            traits::VtableUnboxedClosure(d, ref s) => {\n-                traits::VtableUnboxedClosure(d, s.fold_with(folder))\n+            traits::VtableClosure(d, ref s) => {\n+                traits::VtableClosure(d, s.fold_with(folder))\n             }\n             traits::VtableFnPointer(ref d) => {\n                 traits::VtableFnPointer(d.fold_with(folder))\n@@ -545,9 +545,9 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::UnboxedClosureUpvar<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnboxedClosureUpvar<'tcx> {\n-        ty::UnboxedClosureUpvar {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureUpvar<'tcx> {\n+        ty::ClosureUpvar {\n             def: self.def,\n             span: self.span,\n             ty: self.ty.fold_with(folder),\n@@ -624,10 +624,10 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let substs = substs.fold_with(this);\n             ty::ty_struct(did, this.tcx().mk_substs(substs))\n         }\n-        ty::ty_unboxed_closure(did, ref region, ref substs) => {\n+        ty::ty_closure(did, ref region, ref substs) => {\n             let r = region.fold_with(this);\n             let s = substs.fold_with(this);\n-            ty::ty_unboxed_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n+            ty::ty_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n         }\n         ty::ty_projection(ref data) => {\n             ty::ty_projection(data.fold_with(this))"}, {"sha": "a9121951460f54c30ad48196e201b24d347e30e7", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -37,12 +37,15 @@ impl<'tcx> TypeWalker<'tcx> {\n             ty::ty_projection(ref data) => {\n                 self.push_reversed(data.trait_ref.substs.types.as_slice());\n             }\n-            ty::ty_trait(box ty::TyTrait { ref principal, .. }) => {\n+            ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n                 self.push_reversed(principal.substs().types.as_slice());\n+                self.push_reversed(bounds.projection_bounds.iter().map(|pred| {\n+                    pred.0.ty\n+                }).collect::<Vec<_>>().as_slice());\n             }\n             ty::ty_enum(_, ref substs) |\n             ty::ty_struct(_, ref substs) |\n-            ty::ty_unboxed_closure(_, _, ref substs) => {\n+            ty::ty_closure(_, _, ref substs) => {\n                 self.push_reversed(substs.types.as_slice());\n             }\n             ty::ty_tup(ref ts) => {"}, {"sha": "f93f5903e014da7cd71b3e6b917839f043caebc3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -20,7 +20,7 @@ use middle::ty::{mt, Ty, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn};\n use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n-use middle::ty::{ty_unboxed_closure};\n+use middle::ty::{ty_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::ty_fold::TypeFoldable;\n@@ -414,9 +414,8 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                     data.item_name.user_string(cx))\n         }\n         ty_str => \"str\".to_string(),\n-        ty_unboxed_closure(ref did, _, substs) => {\n-            let unboxed_closures = cx.unboxed_closures.borrow();\n-            unboxed_closures.get(did).map(|cl| {\n+        ty_closure(ref did, _, substs) => {\n+            cx.closures.borrow().get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| {\n                 if did.krate == ast::LOCAL_CRATE {\n@@ -1021,8 +1020,8 @@ impl<'tcx> Repr<'tcx> for ty::MethodOrigin<'tcx> {\n             &ty::MethodStatic(def_id) => {\n                 format!(\"MethodStatic({})\", def_id.repr(tcx))\n             }\n-            &ty::MethodStaticUnboxedClosure(def_id) => {\n-                format!(\"MethodStaticUnboxedClosure({})\", def_id.repr(tcx))\n+            &ty::MethodStaticClosure(def_id) => {\n+                format!(\"MethodStaticClosure({})\", def_id.repr(tcx))\n             }\n             &ty::MethodTypeParam(ref p) => {\n                 p.repr(tcx)"}, {"sha": "b66419420e9a127b8f782e99145a9a2fcc426d9f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -806,7 +806,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n                     _ => unreachable!()\n                 };\n-                if kind == ty::FnUnboxedClosureKind {\n+                if kind == ty::FnClosureKind {\n                     self.bccx.span_err(\n                         assignment_span,\n                         &format!(\"cannot assign to {}\","}, {"sha": "449f2a4d00643d48837678524bab262f16a958a2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -845,7 +845,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n                             _ => unreachable!()\n                         };\n-                        if kind == ty::FnUnboxedClosureKind {\n+                        if kind == ty::FnClosureKind {\n                             self.tcx.sess.span_help(\n                                 self.tcx.map.span(upvar_id.closure_expr_id),\n                                 \"consider changing this closure to take \\"}, {"sha": "dbac2358047dfb561cad273bbc7db595961d73eb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -43,7 +43,7 @@ use rustc::middle::privacy::{ExportedItems, PublicItems, LastPrivateMap};\n use rustc::middle::privacy::{ExternalExports};\n use rustc::middle::ty::{MethodTypeParam, MethodStatic};\n use rustc::middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n-use rustc::middle::ty::{MethodStaticUnboxedClosure, MethodObject};\n+use rustc::middle::ty::{MethodStaticClosure, MethodObject};\n use rustc::middle::ty::{MethodTraitObject};\n use rustc::middle::ty::{self, Ty};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n@@ -819,7 +819,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             MethodStatic(method_id) => {\n                 self.check_static_method(span, method_id, ident)\n             }\n-            MethodStaticUnboxedClosure(_) => {}\n+            MethodStaticClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n             MethodTypeParam(MethodParam { ref trait_ref, .. }) |"}, {"sha": "1d9c701a16c417aa36d195f230984b3307d7be6e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -249,7 +249,7 @@ enum RibKind {\n \n     // We passed through a closure scope at the given node ID.\n     // Translate upvars as appropriate.\n-    ClosureRibKind(NodeId /* func id */, NodeId /* body id if proc or unboxed */),\n+    ClosureRibKind(NodeId /* func id */),\n \n     // We passed through an impl or trait and are now in one of its\n     // methods. Allow references to ty params that impl or trait\n@@ -2611,18 +2611,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n                 let mut def = d;\n-                let mut last_proc_body_id = ast::DUMMY_NODE_ID;\n                 for rib in ribs.iter() {\n                     match rib.kind {\n                         NormalRibKind => {\n                             // Nothing to do. Continue.\n                         }\n-                        ClosureRibKind(function_id, maybe_proc_body) => {\n+                        ClosureRibKind(function_id) => {\n                             let prev_def = def;\n-                            if maybe_proc_body != ast::DUMMY_NODE_ID {\n-                                last_proc_body_id = maybe_proc_body;\n-                            }\n-                            def = DefUpvar(node_id, function_id, last_proc_body_id);\n+                            def = DefUpvar(node_id, function_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n                             let seen = match seen.entry(function_id) {\n@@ -4529,7 +4525,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ExprClosure(capture_clause, _, ref fn_decl, ref block) => {\n                 self.capture_mode_map.insert(expr.id, capture_clause);\n-                self.resolve_function(ClosureRibKind(expr.id, ast::DUMMY_NODE_ID),\n+                self.resolve_function(ClosureRibKind(expr.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }"}, {"sha": "71ca6a4db03d34694bb32b373a8165b431464652", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -920,7 +920,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let method_callee = &(*method_map)[ty::MethodCall::expr(ex.id)];\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |\n-            ty::MethodStaticUnboxedClosure(def_id) => {\n+            ty::MethodStaticClosure(def_id) => {\n                 // method invoked on an object with a concrete type (not a static method)\n                 let decl_id =\n                     match ty::trait_item_of_item(&self.analysis.ty_cx,"}, {"sha": "77ae119a02486ca0571124653f328848a0d77aae", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -1228,19 +1228,19 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n     let (vid, field) = match discr.node {\n         ast::ExprPath(_) | ast::ExprQPath(_) => match bcx.def(discr.id) {\n-            def::DefLocal(vid) | def::DefUpvar(vid, _, _) => (vid, None),\n+            def::DefLocal(vid) | def::DefUpvar(vid, _) => (vid, None),\n             _ => return false\n         },\n         ast::ExprField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id) {\n-                Some(&def::DefLocal(vid)) | Some(&def::DefUpvar(vid, _, _)) => vid,\n+                Some(&def::DefLocal(vid)) | Some(&def::DefUpvar(vid, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::NamedField(field.node.name)))\n         },\n         ast::ExprTupField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id) {\n-                Some(&def::DefLocal(vid)) | Some(&def::DefUpvar(vid, _, _)) => vid,\n+                Some(&def::DefLocal(vid)) | Some(&def::DefUpvar(vid, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::PositionalField(field.node)))"}, {"sha": "519a7e19125101653a93f282e9d5bc81e9ba630b", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -51,7 +51,7 @@ use std::rc::Rc;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, Ty, ClosureTyper};\n use middle::ty::Disr;\n use syntax::ast;\n use syntax::attr;\n@@ -169,9 +169,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[], packed, t), dtor)\n         }\n-        ty::ty_unboxed_closure(def_id, _, substs) => {\n-            let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n-            let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n+        ty::ty_closure(def_id, _, substs) => {\n+            let typer = NormalizingClosureTyper::new(cx.tcx());\n+            let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, &upvar_types[], false, t), false)\n         }"}, {"sha": "230a4c5d4272ecb043d4cc941320d94e54b5f1fb", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -43,7 +43,7 @@ use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::subst;\n use middle::weak_lang_items;\n use middle::subst::{Subst, Substs};\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, Ty, ClosureTyper};\n use session::config::{self, NoDebugInfo};\n use session::Session;\n use trans::_match;\n@@ -255,27 +255,25 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     f\n }\n \n-pub fn self_type_for_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               closure_id: ast::DefId,\n-                                               fn_ty: Ty<'tcx>)\n-                                               -> Ty<'tcx>\n+pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       closure_id: ast::DefId,\n+                                       fn_ty: Ty<'tcx>)\n+                                       -> Ty<'tcx>\n {\n-    let unboxed_closure_kind = ccx.tcx().unboxed_closure_kind(closure_id);\n-    match unboxed_closure_kind {\n-        ty::FnUnboxedClosureKind => {\n+    let closure_kind = ccx.tcx().closure_kind(closure_id);\n+    match closure_kind {\n+        ty::FnClosureKind => {\n             ty::mk_imm_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n-        ty::FnMutUnboxedClosureKind => {\n+        ty::FnMutClosureKind => {\n             ty::mk_mut_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n-        ty::FnOnceUnboxedClosureKind => fn_ty\n+        ty::FnOnceClosureKind => fn_ty\n     }\n }\n \n-pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n-                                -> ty::UnboxedClosureKind {\n-    let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-    (*unboxed_closures)[closure_id].kind\n+pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n+    ccx.tcx().closures.borrow()[closure_id].kind\n }\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -295,10 +293,10 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref f) => {\n             (&f.sig, f.abi, None)\n         }\n-        ty::ty_unboxed_closure(closure_did, _, substs) => {\n-            let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            function_type = typer.unboxed_closure_type(closure_did, substs);\n-            let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n+        ty::ty_closure(closure_did, _, substs) => {\n+            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n+            function_type = typer.closure_type(closure_did, substs);\n+            let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n             debug!(\"decl_rust_fn: function_type={} self_type={}\",\n                    function_type.repr(ccx.tcx()),\n@@ -715,10 +713,10 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::ty_unboxed_closure(def_id, _, substs) => {\n+      ty::ty_closure(def_id, _, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let typer = common::NormalizingUnboxedClosureTyper::new(cx.tcx());\n-          let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n+          let typer = common::NormalizingClosureTyper::new(cx.tcx());\n+          let upvars = typer.closure_upvars(def_id, substs).unwrap();\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);\n@@ -1626,14 +1624,13 @@ fn copy_args_to_allocas<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n-                                        mut bcx: Block<'blk, 'tcx>,\n-                                        arg_scope: cleanup::CustomScopeIndex,\n-                                        args: &[ast::Arg],\n-                                        arg_datums: Vec<RvalueDatum<'tcx>>,\n-                                        monomorphized_arg_types: &[Ty<'tcx>])\n-                                        -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"copy_unboxed_closure_args_to_allocas\");\n+fn copy_closure_args_to_allocas<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                            arg_scope: cleanup::CustomScopeIndex,\n+                                            args: &[ast::Arg],\n+                                            arg_datums: Vec<RvalueDatum<'tcx>>,\n+                                            monomorphized_arg_types: &[Ty<'tcx>])\n+                                            -> Block<'blk, 'tcx> {\n+    let _icx = push_ctxt(\"copy_closure_args_to_allocas\");\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n     assert_eq!(arg_datums.len(), 1);\n@@ -1766,12 +1763,6 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq)]\n-pub enum IsUnboxedClosureFlag {\n-    NotUnboxedClosure,\n-    IsUnboxedClosure,\n-}\n-\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n@@ -1822,7 +1813,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        closure::UnboxedClosure(..) => {\n+        closure::Closure(..) => {\n             vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n         }\n     };\n@@ -1850,8 +1841,8 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  &decl.inputs[],\n                                  arg_datums)\n         }\n-        closure::UnboxedClosure(..) => {\n-            copy_unboxed_closure_args_to_allocas(\n+        closure::Closure(..) => {\n+            copy_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n                 &decl.inputs[],\n@@ -2430,9 +2421,9 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     let function_type;\n     let (fn_sig, abi, has_env) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, false),\n-        ty::ty_unboxed_closure(closure_did, _, substs) => {\n-            let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            function_type = typer.unboxed_closure_type(closure_did, substs);\n+        ty::ty_closure(closure_did, _, substs) => {\n+            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n+            function_type = typer.closure_type(closure_did, substs);\n             (&function_type.sig, RustCall, true)\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n@@ -2449,7 +2440,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n-        ty::ty_unboxed_closure(_, _, _) => {\n+        ty::ty_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n             match fn_sig.inputs[0].sty {"}, {"sha": "73d174c2c34192ddbdf08b95f4c5a1df0454f368", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -457,10 +457,8 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         }\n     };\n \n-    // If this is an unboxed closure, redirect to it.\n-    match closure::get_or_create_declaration_if_unboxed_closure(ccx,\n-                                                                def_id,\n-                                                                &substs) {\n+    // If this is a closure, redirect to it.\n+    match closure::get_or_create_declaration_if_closure(ccx, def_id, &substs) {\n         None => {}\n         Some(llfn) => return llfn,\n     }"}, {"sha": "c1914ce94aa629a03569b491663922c9e8b8f422", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -23,32 +23,31 @@ use trans::debuginfo;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n-use middle::ty::{self, UnboxedClosureTyper};\n+use middle::ty::{self, ClosureTyper};\n use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n \n use syntax::ast;\n use syntax::ast_util;\n \n \n-fn load_unboxed_closure_environment<'blk, 'tcx>(\n-                                    bcx: Block<'blk, 'tcx>,\n-                                    arg_scope_id: ScopeId,\n-                                    freevar_mode: ast::CaptureClause,\n-                                    freevars: &[ty::Freevar])\n-                                    -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::load_unboxed_closure_environment\");\n+fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        arg_scope_id: ScopeId,\n+                                        freevar_mode: ast::CaptureClause,\n+                                        freevars: &[ty::Freevar])\n+                                        -> Block<'blk, 'tcx> {\n+    let _icx = push_ctxt(\"closure::load_closure_environment\");\n \n     // Special case for small by-value selfs.\n     let closure_id = ast_util::local_def(bcx.fcx.id);\n-    let self_type = self_type_for_unboxed_closure(bcx.ccx(), closure_id,\n+    let self_type = self_type_for_closure(bcx.ccx(), closure_id,\n                                                   node_id_type(bcx, closure_id.node));\n-    let kind = kind_for_unboxed_closure(bcx.ccx(), closure_id);\n-    let llenv = if kind == ty::FnOnceUnboxedClosureKind &&\n+    let kind = kind_for_closure(bcx.ccx(), closure_id);\n+    let llenv = if kind == ty::FnOnceClosureKind &&\n             !arg_is_indirect(bcx.ccx(), self_type) {\n         let datum = rvalue_scratch_datum(bcx,\n                                          self_type,\n-                                         \"unboxed_closure_env\");\n+                                         \"closure_env\");\n         store_ty(bcx, bcx.fcx.llenv.unwrap(), datum.val, self_type);\n         datum.val\n     } else {\n@@ -77,7 +76,7 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n         let def_id = freevar.def.def_id();\n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n \n-        if kind == ty::FnOnceUnboxedClosureKind && freevar_mode == ast::CaptureByValue {\n+        if kind == ty::FnOnceClosureKind && freevar_mode == ast::CaptureByValue {\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n                                       node_id_type(bcx, def_id.node))\n@@ -100,8 +99,8 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n #[derive(PartialEq)]\n pub enum ClosureKind<'tcx> {\n     NotClosure,\n-    // See load_unboxed_closure_environment.\n-    UnboxedClosure(ast::CaptureClause)\n+    // See load_closure_environment.\n+    Closure(ast::CaptureClause)\n }\n \n pub struct ClosureEnv<'a, 'tcx> {\n@@ -127,21 +126,21 @@ impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n \n         match self.kind {\n             NotClosure => bcx,\n-            UnboxedClosure(freevar_mode) => {\n-                load_unboxed_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n+            Closure(freevar_mode) => {\n+                load_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n             }\n         }\n     }\n }\n \n-/// Returns the LLVM function declaration for an unboxed closure, creating it\n-/// if necessary. If the ID does not correspond to a closure ID, returns None.\n-pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                              closure_id: ast::DefId,\n-                                                              substs: &Substs<'tcx>)\n-                                                              -> Option<Datum<'tcx, Rvalue>> {\n-    if !ccx.tcx().unboxed_closures.borrow().contains_key(&closure_id) {\n-        // Not an unboxed closure.\n+/// Returns the LLVM function declaration for a closure, creating it if\n+/// necessary. If the ID does not correspond to a closure ID, returns None.\n+pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                      closure_id: ast::DefId,\n+                                                      substs: &Substs<'tcx>)\n+                                                      -> Option<Datum<'tcx, Rvalue>> {\n+    if !ccx.tcx().closures.borrow().contains_key(&closure_id) {\n+        // Not a closure.\n         return None\n     }\n \n@@ -152,66 +151,64 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n     // duplicate declarations\n     let function_type = erase_regions(ccx.tcx(), &function_type);\n     let params = match function_type.sty {\n-        ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n+        ty::ty_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n     };\n     let mono_id = MonoId {\n         def: closure_id,\n         params: params\n     };\n \n-    match ccx.unboxed_closure_vals().borrow().get(&mono_id) {\n+    match ccx.closure_vals().borrow().get(&mono_id) {\n         Some(&llfn) => {\n-            debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n-                    closure\");\n+            debug!(\"get_or_create_declaration_if_closure(): found closure\");\n             return Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n         }\n         None => {}\n     }\n \n     let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n-        mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n+        mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n     let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    debug!(\"get_or_create_declaration_if_unboxed_closure(): inserting new \\\n+    debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n             closure {:?} (type {})\",\n            mono_id,\n            ccx.tn().type_to_string(val_ty(llfn)));\n-    ccx.unboxed_closure_vals().borrow_mut().insert(mono_id, llfn);\n+    ccx.closure_vals().borrow_mut().insert(mono_id, llfn);\n \n     Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n }\n \n-pub fn trans_unboxed_closure<'blk, 'tcx>(\n-                             mut bcx: Block<'blk, 'tcx>,\n-                             decl: &ast::FnDecl,\n-                             body: &ast::Block,\n-                             id: ast::NodeId,\n-                             dest: expr::Dest)\n-                             -> Block<'blk, 'tcx>\n+pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                      decl: &ast::FnDecl,\n+                                      body: &ast::Block,\n+                                      id: ast::NodeId,\n+                                      dest: expr::Dest)\n+                                      -> Block<'blk, 'tcx>\n {\n-    let _icx = push_ctxt(\"closure::trans_unboxed_closure\");\n+    let _icx = push_ctxt(\"closure::trans_closure\");\n \n-    debug!(\"trans_unboxed_closure()\");\n+    debug!(\"trans_closure()\");\n \n     let closure_id = ast_util::local_def(id);\n-    let llfn = get_or_create_declaration_if_unboxed_closure(\n+    let llfn = get_or_create_declaration_if_closure(\n         bcx.ccx(),\n         closure_id,\n         bcx.fcx.param_substs).unwrap();\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n     // takes the same set of type arguments as the enclosing fn, and\n-    // this function (`trans_unboxed_closure`) is invoked at the point\n+    // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n-    let typer = NormalizingUnboxedClosureTyper::new(bcx.tcx());\n-    let function_type = typer.unboxed_closure_type(closure_id, bcx.fcx.param_substs);\n+    let typer = NormalizingClosureTyper::new(bcx.tcx());\n+    let function_type = typer.closure_type(closure_id, bcx.fcx.param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n@@ -229,15 +226,15 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   sig.output,\n                   function_type.abi,\n                   ClosureEnv::new(&freevars[],\n-                                  UnboxedClosure(freevar_mode)));\n+                                  Closure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n-    // to have a zero-size unboxed closure (in which case dest will be\n-    // `Ignore`) and we must still generate the closure body.\n+    // to have a zero-size closure (in which case dest will be `Ignore`) and\n+    // we must still generate the closure body.\n     let dest_addr = match dest {\n         expr::SaveIn(p) => p,\n         expr::Ignore => {\n-            debug!(\"trans_unboxed_closure() ignoring result\");\n+            debug!(\"trans_closure() ignoring result\");\n             return bcx\n         }\n     };"}, {"sha": "a5c4df7dbb94290eadd1f462a0476816265f41d6", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -248,7 +248,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     }\n     match ty.sty {\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) | ty::ty_vec(_, Some(_)) |\n-        ty::ty_unboxed_closure(..) => {\n+        ty::ty_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n         }\n@@ -693,35 +693,32 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n }\n \n-impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n+impl<'blk, 'tcx> ty::ClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n     fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n         &self.fcx.param_env\n     }\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_kind(def_id)\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        let typer = NormalizingClosureTyper::new(self.tcx());\n+        typer.closure_kind(def_id)\n     }\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n     {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_type(def_id, substs)\n+        let typer = NormalizingClosureTyper::new(self.tcx());\n+        typer.closure_type(def_id, substs)\n     }\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_upvars(def_id, substs)\n+        let typer = NormalizingClosureTyper::new(self.tcx());\n+        typer.closure_upvars(def_id, substs)\n     }\n }\n \n@@ -1011,7 +1008,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n@@ -1056,49 +1053,46 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n-pub struct NormalizingUnboxedClosureTyper<'a,'tcx:'a> {\n+pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n     param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n \n-impl<'a,'tcx> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n+impl<'a,'tcx> NormalizingClosureTyper<'a,'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingClosureTyper<'a,'tcx> {\n         // Parameter environment is used to give details about type parameters,\n         // but since we are in trans, everything is fully monomorphized.\n-        NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n+        NormalizingClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n     }\n }\n \n-impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'a,'tcx> {\n+impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n     fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n         &self.param_env\n     }\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.param_env.tcx.unboxed_closure_kind(def_id)\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        self.param_env.tcx.closure_kind(def_id)\n     }\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n+        let closure_ty = self.param_env.tcx.closure_type(def_id, substs);\n         monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n     }\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n+        let result = ty::closure_upvars(&self.param_env, def_id, substs);\n         monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n     }\n }\n@@ -1116,7 +1110,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n-    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n+    let typer = NormalizingClosureTyper::new(infcx.tcx);\n     match fulfill_cx.select_all_or_error(infcx, &typer) {\n         Ok(()) => { }\n         Err(errors) => {"}, {"sha": "09e0c016133cd0da577eb520ace687b15742fe13", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -138,7 +138,7 @@ pub struct LocalCrateContext<'tcx> {\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    unboxed_closure_vals: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n+    closure_vals: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n@@ -414,7 +414,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                unboxed_closure_vals: RefCell::new(FnvHashMap()),\n+                closure_vals: RefCell::new(FnvHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(FnvHashMap()),\n@@ -684,8 +684,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.opaque_vec_type\n     }\n \n-    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>,ValueRef>> {\n-        &self.local.unboxed_closure_vals\n+    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>> {\n+        &self.local.closure_vals\n     }\n \n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {"}, {"sha": "4c1cf62ce8a996c08f51ce6c681a2dd5fa16a5a3", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -197,11 +197,11 @@ use metadata::csearch;\n use middle::subst::{self, Substs};\n use trans::{self, adt, machine, type_of};\n use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n-                    C_bytes, C_i32, C_i64, NormalizingUnboxedClosureTyper};\n+                    C_bytes, C_i32, C_i64, NormalizingClosureTyper};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, Ty, ClosureTyper};\n use middle::pat_util;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n@@ -472,9 +472,9 @@ impl<'tcx> TypeMap<'tcx> {\n                     }\n                 }\n             },\n-            ty::ty_unboxed_closure(def_id, _, substs) => {\n-                let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n-                let closure_ty = typer.unboxed_closure_type(def_id, substs);\n+            ty::ty_closure(def_id, _, substs) => {\n+                let typer = NormalizingClosureTyper::new(cx.tcx());\n+                let closure_ty = typer.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n@@ -3035,9 +3035,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref barefnty) => {\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n-        ty::ty_unboxed_closure(def_id, _, substs) => {\n-            let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n-            let sig = typer.unboxed_closure_type(def_id, substs).sig;\n+        ty::ty_closure(def_id, _, substs) => {\n+            let typer = NormalizingClosureTyper::new(cx.tcx());\n+            let sig = typer.closure_type(def_id, substs).sig;\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n         ty::ty_struct(def_id, substs) => {\n@@ -3888,7 +3888,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         },\n-        ty::ty_unboxed_closure(..) => {\n+        ty::ty_closure(..) => {\n             output.push_str(\"closure\");\n         }\n         ty::ty_err |"}, {"sha": "1504c2a7c2d9ff6537e44194481f91a06b18779c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -1098,11 +1098,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n         ast::ExprClosure(_, _, ref decl, ref body) => {\n-            // Check the side-table to see whether this is an unboxed\n-            // closure or an older, legacy style closure. Store this\n-            // into a variable to ensure the the RefCell-lock is\n-            // released before we recurse.\n-            closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n+            closure::trans_closure_expr(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n@@ -1263,7 +1259,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     match def {\n-        def::DefUpvar(nid, _, _) => {\n+        def::DefUpvar(nid, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.borrow().get(&nid) {"}, {"sha": "c1d98987991e374800344d5c8b1641fb2d8ee12d", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -438,7 +438,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                 }\n             }\n         }\n-        ty::ty_unboxed_closure(..) => {\n+        ty::ty_closure(..) => {\n             iter_structural_ty(bcx,\n                                v0,\n                                t,"}, {"sha": "580a2d5ae3dc7c37631a2ab2912386b28dc90d7d", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -120,7 +120,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match origin {\n         ty::MethodStatic(did) |\n-        ty::MethodStaticUnboxedClosure(did) => {\n+        ty::MethodStaticClosure(did) => {\n             Callee {\n                 bcx: bcx,\n                 data: Fn(callee::trans_fn_ref(bcx.ccx(),\n@@ -365,7 +365,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n-        traits::VtableUnboxedClosure(closure_def_id, substs) => {\n+        traits::VtableClosure(closure_def_id, substs) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n             let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n@@ -727,7 +727,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     nested: _ }) => {\n                 emit_vtable_methods(bcx, id, substs).into_iter()\n             }\n-            traits::VtableUnboxedClosure(closure_def_id, substs) => {\n+            traits::VtableClosure(closure_def_id, substs) => {\n                 let llfn = trans_fn_ref_with_substs(\n                     bcx.ccx(),\n                     closure_def_id,"}, {"sha": "72e41408d8a46fbfb62cea781b14f514d80026ef", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -322,7 +322,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     // FIXME(#20304) -- cache\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } ="}, {"sha": "61dbb5514353af8f4e8310e64395a6f363536115", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -211,7 +211,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::nil(cx)\n         }\n \n-        ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n+        ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_closure(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, &*repr, false)\n         }\n@@ -330,15 +330,15 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let name = llvm_type_name(cx, an_enum, did, tps);\n           adt::incomplete_type_of(cx, &*repr, &name[])\n       }\n-      ty::ty_unboxed_closure(did, _, ref substs) => {\n+      ty::ty_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n           let repr = adt::represent_type(cx, t);\n           // Unboxed closures can have substitutions in all spaces\n           // inherited from their environment, so we use entire\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n-          let name = llvm_type_name(cx, an_unboxed_closure, did, substs.types.as_slice());\n+          let name = llvm_type_name(cx, a_closure, did, substs.types.as_slice());\n           adt::incomplete_type_of(cx, &*repr, &name[])\n       }\n \n@@ -432,7 +432,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n \n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n-        ty::ty_enum(..) | ty::ty_struct(..) | ty::ty_unboxed_closure(..)\n+        ty::ty_enum(..) | ty::ty_struct(..) | ty::ty_closure(..)\n                 if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &*repr, &mut llty);\n@@ -454,7 +454,7 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n pub enum named_ty {\n     a_struct,\n     an_enum,\n-    an_unboxed_closure,\n+    a_closure,\n }\n \n pub fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -465,7 +465,7 @@ pub fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let name = match what {\n         a_struct => \"struct\",\n         an_enum => \"enum\",\n-        an_unboxed_closure => return \"closure\".to_string(),\n+        a_closure => return \"closure\".to_string(),\n     };\n \n     let base = ty::item_path_str(cx.tcx(), did);"}, {"sha": "0e0a929464018a2a9bfc09eade851876feb8c805", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -18,7 +18,7 @@ use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                                typer: &(ty::UnboxedClosureTyper<'tcx>+'a),\n+                                                typer: &(ty::ClosureTyper<'tcx>+'a),\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n                                                 body_id: ast::NodeId,"}, {"sha": "2d7a76344721c7da8bdefa4ebd7690ab730e9657", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -25,7 +25,7 @@ use util::ppaux::Repr;\n pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n                                    _capture: ast::CaptureClause,\n-                                   opt_kind: Option<ast::UnboxedClosureKind>,\n+                                   opt_kind: Option<ast::ClosureKind>,\n                                    decl: &ast::FnDecl,\n                                    body: &ast::Block,\n                                    expected: Expectation<'tcx>) {\n@@ -34,54 +34,54 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            expected.repr(fcx.tcx()));\n \n     let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n-        deduce_unboxed_closure_expectations_from_expected_type(fcx, ty)\n+        deduce_closure_expectations_from_expected_type(fcx, ty)\n     });\n \n     match opt_kind {\n         None => {\n             // If users didn't specify what sort of closure they want,\n             // examine the expected type. For now, if we see explicit\n             // evidence than an unboxed closure is desired, we'll use\n-            // that, otherwise we'll fall back to boxed closures.\n+            // that, otherwise we'll error, requesting an annotation.\n             match expected_sig_and_kind {\n                 None => { // don't have information about the kind, request explicit annotation\n                     // NB We still need to typeck the body, so assume `FnMut` kind just for that\n-                    let kind = ty::FnMutUnboxedClosureKind;\n+                    let kind = ty::FnMutClosureKind;\n \n-                    check_unboxed_closure(fcx, expr, kind, decl, body, None);\n+                    check_closure(fcx, expr, kind, decl, body, None);\n \n                     span_err!(fcx.ccx.tcx.sess, expr.span, E0187,\n                         \"can't infer the \\\"kind\\\" of the closure; explicitly annotate it; e.g. \\\n                         `|&:| {{}}`\");\n                 },\n                 Some((sig, kind)) => {\n-                    check_unboxed_closure(fcx, expr, kind, decl, body, Some(sig));\n+                    check_closure(fcx, expr, kind, decl, body, Some(sig));\n                 }\n             }\n         }\n \n         Some(kind) => {\n             let kind = match kind {\n-                ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n-                ast::FnMutUnboxedClosureKind => ty::FnMutUnboxedClosureKind,\n-                ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n+                ast::FnClosureKind => ty::FnClosureKind,\n+                ast::FnMutClosureKind => ty::FnMutClosureKind,\n+                ast::FnOnceClosureKind => ty::FnOnceClosureKind,\n             };\n \n             let expected_sig = expected_sig_and_kind.map(|t| t.0);\n-            check_unboxed_closure(fcx, expr, kind, decl, body, expected_sig);\n+            check_closure(fcx, expr, kind, decl, body, expected_sig);\n         }\n     }\n }\n \n-fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                  expr: &ast::Expr,\n-                                  kind: ty::UnboxedClosureKind,\n-                                  decl: &ast::FnDecl,\n-                                  body: &ast::Block,\n-                                  expected_sig: Option<ty::FnSig<'tcx>>) {\n+fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                          expr: &ast::Expr,\n+                          kind: ty::ClosureKind,\n+                          decl: &ast::FnDecl,\n+                          body: &ast::Block,\n+                          expected_sig: Option<ty::FnSig<'tcx>>) {\n     let expr_def_id = ast_util::local_def(expr.id);\n \n-    debug!(\"check_unboxed_closure kind={:?} expected_sig={}\",\n+    debug!(\"check_closure kind={:?} expected_sig={}\",\n            kind,\n            expected_sig.repr(fcx.tcx()));\n \n@@ -100,11 +100,11 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         Ok(regions) => regions[0],\n     };\n \n-    let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n-                                              expr_def_id,\n-                                              fcx.ccx.tcx.mk_region(region),\n-                                              fcx.ccx.tcx.mk_substs(\n-                                                  fcx.inh.param_env.free_substs.clone()));\n+    let closure_type = ty::mk_closure(fcx.ccx.tcx,\n+                                      expr_def_id,\n+                                      fcx.ccx.tcx.mk_region(region),\n+                                      fcx.ccx.tcx.mk_substs(\n+                                        fcx.inh.param_env.free_substs.clone()));\n \n     fcx.write_ty(expr.id, closure_type);\n \n@@ -121,54 +121,51 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n              fcx.inh);\n \n     // Tuple up the arguments and insert the resulting function type into\n-    // the `unboxed_closures` table.\n+    // the `closures` table.\n     fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n-    debug!(\"unboxed_closure for {} --> sig={} kind={:?}\",\n+    debug!(\"closure for {} --> sig={} kind={:?}\",\n            expr_def_id.repr(fcx.tcx()),\n            fn_ty.sig.repr(fcx.tcx()),\n            kind);\n \n-    let unboxed_closure = ty::UnboxedClosure {\n+    let closure = ty::Closure {\n         closure_type: fn_ty,\n         kind: kind,\n     };\n \n-    fcx.inh\n-        .unboxed_closures\n-        .borrow_mut()\n-        .insert(expr_def_id, unboxed_closure);\n+    fcx.inh.closures.borrow_mut().insert(expr_def_id, closure);\n }\n \n-fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(\n+fn deduce_closure_expectations_from_expected_type<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_ty: Ty<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>,ty::UnboxedClosureKind)>\n+    -> Option<(ty::FnSig<'tcx>,ty::ClosureKind)>\n {\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n             let trait_ref =\n                 object_type.principal_trait_ref_with_self_ty(fcx.tcx(),\n                                                              fcx.tcx().types.err);\n-            deduce_unboxed_closure_expectations_from_trait_ref(fcx, &trait_ref)\n+            deduce_closure_expectations_from_trait_ref(fcx, &trait_ref)\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n-            deduce_unboxed_closure_expectations_from_obligations(fcx, vid)\n+            deduce_closure_expectations_from_obligations(fcx, vid)\n         }\n         _ => {\n             None\n         }\n     }\n }\n \n-fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n+fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     trait_ref: &ty::PolyTraitRef<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n+    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_unboxed_closure_expectations_from_object_type({})\",\n+    debug!(\"deduce_closure_expectations_from_object_type({})\",\n            trait_ref.repr(tcx));\n \n     let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n@@ -202,10 +199,10 @@ fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     return Some((fn_sig, kind));\n }\n \n-fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n+fn deduce_closure_expectations_from_obligations<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_vid: ty::TyVid)\n-    -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n+    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n {\n     // Here `expected_ty` is known to be a type inference variable.\n     for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n@@ -218,7 +215,7 @@ fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n                     _ => { continue; }\n                 }\n \n-                match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n+                match deduce_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n                     Some(e) => { return Some(e); }\n                     None => { }\n                 }"}, {"sha": "61332ada506de97cf718146c42a61765462de478", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -62,7 +62,7 @@ enum CandidateKind<'tcx> {\n     ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n-    UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n+    ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n     WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n     ProjectionCandidate(ast::DefId, MethodIndex),\n }\n@@ -249,7 +249,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n             ty::ty_enum(did, _) |\n             ty::ty_struct(did, _) |\n-            ty::ty_unboxed_closure(did, _, _) => {\n+            ty::ty_closure(did, _, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n             ty::ty_param(p) => {\n@@ -494,9 +494,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                            method.clone(),\n                                                            matching_index);\n \n-        self.assemble_unboxed_closure_candidates(trait_def_id,\n-                                                 method.clone(),\n-                                                 matching_index);\n+        self.assemble_closure_candidates(trait_def_id,\n+                                         method.clone(),\n+                                         matching_index);\n \n         self.assemble_projection_candidates(trait_def_id,\n                                             method.clone(),\n@@ -571,19 +571,19 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         simplified_steps.contains(&impl_simplified_type)\n     }\n \n-    fn assemble_unboxed_closure_candidates(&mut self,\n-                                           trait_def_id: ast::DefId,\n-                                           method_ty: Rc<ty::Method<'tcx>>,\n-                                           method_index: uint)\n+    fn assemble_closure_candidates(&mut self,\n+                                   trait_def_id: ast::DefId,\n+                                   method_ty: Rc<ty::Method<'tcx>>,\n+                                   method_index: uint)\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n         let tcx = self.tcx();\n         let kind = if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            ty::FnUnboxedClosureKind\n+            ty::FnClosureKind\n         } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            ty::FnMutUnboxedClosureKind\n+            ty::FnMutClosureKind\n         } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            ty::FnOnceUnboxedClosureKind\n+            ty::FnOnceClosureKind\n         } else {\n             return;\n         };\n@@ -593,17 +593,17 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n             let (closure_def_id, _, _) = match step.self_ty.sty {\n-                ty::ty_unboxed_closure(a, b, ref c) => (a, b, c),\n+                ty::ty_closure(a, b, ref c) => (a, b, c),\n                 _ => continue,\n             };\n \n-            let unboxed_closures = self.fcx.inh.unboxed_closures.borrow();\n-            let closure_data = match unboxed_closures.get(&closure_def_id) {\n+            let closures = self.fcx.inh.closures.borrow();\n+            let closure_data = match closures.get(&closure_def_id) {\n                 Some(data) => data,\n                 None => {\n                     self.tcx().sess.span_bug(\n                         self.span,\n-                        &format!(\"No entry for unboxed closure: {}\",\n+                        &format!(\"No entry for closure: {}\",\n                                 closure_def_id.repr(self.tcx()))[]);\n                 }\n             };\n@@ -626,7 +626,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: method_ty.clone(),\n-                kind: UnboxedClosureCandidate(trait_def_id, method_index)\n+                kind: ClosureCandidate(trait_def_id, method_index)\n             });\n         }\n     }\n@@ -950,7 +950,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                 ProjectionCandidate(..) |\n                 ObjectCandidate(..) |\n-                UnboxedClosureCandidate(..) |\n+                ClosureCandidate(..) |\n                 WhereClauseCandidate(..) => {\n                     // These have no additional conditions to check.\n                     true\n@@ -1173,7 +1173,7 @@ impl<'tcx> Candidate<'tcx> {\n                 ExtensionImplCandidate(def_id, _, _, index) => {\n                     ExtensionImplPick(def_id, index)\n                 }\n-                UnboxedClosureCandidate(trait_def_id, index) => {\n+                ClosureCandidate(trait_def_id, index) => {\n                     TraitPick(trait_def_id, index)\n                 }\n                 WhereClauseCandidate(ref trait_ref, index) => {\n@@ -1198,7 +1198,7 @@ impl<'tcx> Candidate<'tcx> {\n             InherentImplCandidate(def_id, _) => ImplSource(def_id),\n             ObjectCandidate(def_id, _, _) => TraitSource(def_id),\n             ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n-            UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n+            ClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n             WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n             ProjectionCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n         }\n@@ -1210,7 +1210,7 @@ impl<'tcx> Candidate<'tcx> {\n             ObjectCandidate(..) => {\n                 None\n             }\n-            UnboxedClosureCandidate(trait_def_id, method_num) => {\n+            ClosureCandidate(trait_def_id, method_num) => {\n                 Some((trait_def_id, method_num))\n             }\n             ExtensionImplCandidate(_, ref trait_ref, _, method_num) => {\n@@ -1244,8 +1244,8 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n             ExtensionImplCandidate(ref a, ref b, ref c, ref d) =>\n                 format!(\"ExtensionImplCandidate({},{},{},{})\", a.repr(tcx), b.repr(tcx),\n                         c.repr(tcx), d),\n-            UnboxedClosureCandidate(ref a, ref b) =>\n-                format!(\"UnboxedClosureCandidate({},{})\", a.repr(tcx), b),\n+            ClosureCandidate(ref a, ref b) =>\n+                format!(\"ClosureCandidate({},{})\", a.repr(tcx), b),\n             WhereClauseCandidate(ref a, ref b) =>\n                 format!(\"WhereClauseCandidate({},{})\", a.repr(tcx), b),\n             ProjectionCandidate(ref a, ref b) =>"}, {"sha": "5b172598ebb57298f4d66a49862c797110dae006", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -160,7 +160,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n     method_map: MethodMap<'tcx>,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n-    unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>>,\n+    closures: RefCell<DefIdMap<ty::Closure<'tcx>>>,\n     object_cast_map: ObjectCastMap<'tcx>,\n \n     // A mapping from each fn's id to its signature, with all bound\n@@ -338,32 +338,29 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty::UnboxedClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n     fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n         &self.inh.param_env\n     }\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.inh.unboxed_closures.borrow()[def_id].kind\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        self.inh.closures.borrow()[def_id].kind\n     }\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n     {\n-        self.inh.unboxed_closures.borrow()[def_id].closure_type.subst(self.tcx(), substs)\n+        self.inh.closures.borrow()[def_id].closure_type.subst(self.tcx(), substs)\n     }\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n-        ty::unboxed_closure_upvars(self, def_id, substs)\n+        ty::closure_upvars(self, def_id, substs)\n     }\n }\n \n@@ -381,14 +378,14 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             method_map: RefCell::new(FnvHashMap()),\n             object_cast_map: RefCell::new(NodeMap()),\n             upvar_borrow_map: RefCell::new(FnvHashMap()),\n-            unboxed_closures: RefCell::new(DefIdMap()),\n+            closures: RefCell::new(DefIdMap()),\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n \n     fn normalize_associated_types_in<T>(&self,\n-                                        typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                        typer: &ty::ClosureTyper<'tcx>,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n                                         value: &T)\n@@ -1635,14 +1632,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let raw_ty = self.expr_ty(expr);\n         let raw_ty = self.infcx().shallow_resolve(raw_ty);\n+        let resolve_ty = |&: ty: Ty<'tcx>| self.infcx().resolve_type_vars_if_possible(&ty);\n         ty::adjust_ty(self.tcx(),\n                       expr.span,\n                       expr.id,\n                       raw_ty,\n                       adjustment,\n                       |method_call| self.inh.method_map.borrow()\n                                                        .get(&method_call)\n-                                                       .map(|method| method.ty))\n+                                                       .map(|method| resolve_ty(method.ty)))\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n@@ -4624,7 +4622,7 @@ pub fn type_scheme_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      defn: def::Def)\n                                      -> TypeScheme<'tcx> {\n     match defn {\n-      def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n+      def::DefLocal(nid) | def::DefUpvar(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }"}, {"sha": "f2a3d6609252ffd3726191067f20da806cf02448", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -177,16 +177,9 @@ pub struct Rcx<'a, 'tcx: 'a> {\n fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n-        def::DefLocal(node_id) => {\n+        def::DefLocal(node_id) | def::DefUpvar(node_id, _) => {\n             tcx.region_maps.var_region(node_id)\n         }\n-        def::DefUpvar(node_id, _, body_id) => {\n-            if body_id == ast::DUMMY_NODE_ID {\n-                tcx.region_maps.var_region(node_id)\n-            } else {\n-                ReScope(CodeExtent::from_node_id(body_id))\n-            }\n-        }\n         _ => {\n             tcx.sess.bug(&format!(\"unexpected def in region_of_def: {:?}\",\n                                  def)[])\n@@ -748,7 +741,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     let function_type = rcx.resolve_node_type(expr.id);\n \n     match function_type.sty {\n-        ty::ty_unboxed_closure(_, region, _) => {\n+        ty::ty_closure(_, region, _) => {\n             if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n                 ty::with_freevars(tcx, expr.id, |freevars| {\n                     if !freevars.is_empty() {\n@@ -768,7 +761,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     rcx.set_repeating_scope(repeating_scope);\n \n     match function_type.sty {\n-        ty::ty_unboxed_closure(_, region, _) => {\n+        ty::ty_closure(_, region, _) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 let bounds = ty::region_existential_bound(*region);\n                 ensure_free_variable_types_outlive_closure_bound(rcx, &bounds, expr, freevars);"}, {"sha": "58e8a9c6912b12fcc597342752bc8ac84dced8f3", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -68,8 +68,8 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::ty_unboxed_closure(_, region, _) => {\n-                // An \"unboxed closure type\" is basically\n+            ty::ty_closure(_, region, _) => {\n+                // An \"closure type\" is basically\n                 // modeled here as equivalent to a struct like\n                 //\n                 //     struct TheClosure<'b> {\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 // where the `'b` is the lifetime bound of the\n                 // contents (i.e., all contents must outlive 'b).\n                 //\n-                // Even though unboxed closures are glorified structs\n+                // Even though closures are glorified structs\n                 // of upvars, we do not need to consider them as they\n                 // can't generate any new constraints.  The\n                 // substitutions on the closure are equal to the free"}, {"sha": "7fc0a83e34ac591765e935a6928b33fe4014de88", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -121,13 +121,8 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      capture_clause: ast::CaptureClause,\n                      _body: &ast::Block)\n     {\n-        let is_old_skool_closure = match self.fcx.expr_ty(expr).sty {\n-            _ => false,\n-        };\n-\n         match capture_clause {\n-            ast::CaptureByValue if !is_old_skool_closure => {\n-            }\n+            ast::CaptureByValue => {}\n             _ => {\n                 ty::with_freevars(self.tcx(), expr.id, |freevars| {\n                     for freevar in freevars.iter() {"}, {"sha": "2fd33983fd38a2ba58d40dc4229949b02399c5b0", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -39,7 +39,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     let mut wbcx = WritebackCx::new(fcx);\n     wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n-    wbcx.visit_unboxed_closures();\n+    wbcx.visit_closures();\n     wbcx.visit_object_cast_map();\n }\n \n@@ -60,7 +60,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n         }\n     }\n     wbcx.visit_upvar_borrow_map();\n-    wbcx.visit_unboxed_closures();\n+    wbcx.visit_closures();\n     wbcx.visit_object_cast_map();\n }\n \n@@ -195,27 +195,19 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn visit_unboxed_closures(&self) {\n+    fn visit_closures(&self) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n-        for (def_id, unboxed_closure) in self.fcx\n-                                             .inh\n-                                             .unboxed_closures\n-                                             .borrow()\n-                                             .iter() {\n-            let closure_ty = self.resolve(&unboxed_closure.closure_type,\n-                                          ResolvingUnboxedClosure(*def_id));\n-            let unboxed_closure = ty::UnboxedClosure {\n+        for (def_id, closure) in self.fcx.inh.closures.borrow().iter() {\n+            let closure_ty = self.resolve(&closure.closure_type,\n+                                          ResolvingClosure(*def_id));\n+            let closure = ty::Closure {\n                 closure_type: closure_ty,\n-                kind: unboxed_closure.kind,\n+                kind: closure.kind,\n             };\n-            self.fcx\n-                .tcx()\n-                .unboxed_closures\n-                .borrow_mut()\n-                .insert(*def_id, unboxed_closure);\n+            self.fcx.tcx().closures.borrow_mut().insert(*def_id, closure);\n         }\n     }\n \n@@ -331,7 +323,7 @@ enum ResolveReason {\n     ResolvingLocal(Span),\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n-    ResolvingUnboxedClosure(ast::DefId),\n+    ResolvingClosure(ast::DefId),\n }\n \n impl ResolveReason {\n@@ -343,7 +335,7 @@ impl ResolveReason {\n             ResolvingUpvar(upvar_id) => {\n                 ty::expr_span(tcx, upvar_id.closure_expr_id)\n             }\n-            ResolvingUnboxedClosure(did) => {\n+            ResolvingClosure(did) => {\n                 if did.krate == ast::LOCAL_CRATE {\n                     ty::expr_span(tcx, did.node)\n                 } else {\n@@ -414,11 +406,10 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                         infer::fixup_err_to_string(e));\n                 }\n \n-                ResolvingUnboxedClosure(_) => {\n+                ResolvingClosure(_) => {\n                     let span = self.reason.span(self.tcx);\n                     span_err!(self.tcx.sess, span, E0196,\n-                                           \"cannot determine a type for this \\\n-                                            unboxed closure\")\n+                              \"cannot determine a type for this closure\")\n                 }\n             }\n         }"}, {"sha": "9760d5f05df71d6878b182d382dc6fd7dc611dda", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -26,7 +26,7 @@ use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n-use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n+use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::{ty_projection};\n use middle::ty;\n use CrateCtxt;\n@@ -80,7 +80,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             None\n         }\n \n-        ty_infer(..) | ty_unboxed_closure(..) => {\n+        ty_infer(..) | ty_closure(..) => {\n             // `ty` comes from a user declaration so we should only expect types\n             // that the user can type\n             inference_context.tcx.sess.span_bug(\n@@ -410,7 +410,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n-                ty::ty_unboxed_closure(type_def_id, _, _) => {\n+                ty::ty_closure(type_def_id, _, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n                        .insert(type_def_id, method_def_id.def_id());"}, {"sha": "680ff2fcda64cd6e6c35eb871e01aa0a7254a8dc", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -113,7 +113,7 @@ register_diagnostics! {\n            // involving type parameters\n     E0194,\n     E0195, // lifetime parameters or bounds on method do not match the trait declaration\n-    E0196, // cannot determine a type for this unboxed closure\n+    E0196, // cannot determine a type for this closure\n     E0197, // inherent impls cannot be declared as unsafe\n     E0198, // negative implementations are not unsafe\n     E0199, // implementing trait is not unsafe"}, {"sha": "ed8a50110e5ac9323850efccdadf16972c1b056e", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -740,8 +740,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 /* leaf type -- noop */\n             }\n \n-            ty::ty_unboxed_closure(..) => {\n-                self.tcx().sess.bug(\"Unexpected unboxed closure type in variance computation\");\n+            ty::ty_closure(..) => {\n+                self.tcx().sess.bug(\"Unexpected closure type in variance computation\");\n             }\n \n             ty::ty_rptr(region, ref mt) => {"}, {"sha": "c12726c8868cad9c4cdd7a984b161547756d2857", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -1604,7 +1604,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n \n             ty::ty_param(ref p) => Generic(token::get_name(p.name).to_string()),\n \n-            ty::ty_unboxed_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n+            ty::ty_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => panic!(\"ty_infer\"),\n             ty::ty_open(..) => panic!(\"ty_open\"),"}, {"sha": "4f6cd8ad356d70750266ec2e892c9439b051ba9e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -35,7 +35,6 @@ pub use self::MacStmtStyle::*;\n pub use self::MetaItem_::*;\n pub use self::Method_::*;\n pub use self::Mutability::*;\n-pub use self::Onceness::*;\n pub use self::Pat_::*;\n pub use self::PathListItem_::*;\n pub use self::PatWildKind::*;\n@@ -49,7 +48,7 @@ pub use self::TraitItem::*;\n pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UintTy::*;\n-pub use self::UnboxedClosureKind::*;\n+pub use self::ClosureKind::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::VariantKind::*;\n@@ -734,7 +733,7 @@ pub enum Expr_ {\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n-    ExprClosure(CaptureClause, Option<UnboxedClosureKind>, P<FnDecl>, P<Block>),\n+    ExprClosure(CaptureClause, Option<ClosureKind>, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(P<Expr>, P<Expr>),\n@@ -1222,31 +1221,6 @@ pub enum PrimTy {\n     TyChar\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, Show)]\n-pub enum Onceness {\n-    Once,\n-    Many\n-}\n-\n-impl fmt::Display for Onceness {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(match *self {\n-            Once => \"once\",\n-            Many => \"many\",\n-        }, f)\n-    }\n-}\n-\n-/// Represents the type of a closure\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n-pub struct ClosureTy {\n-    pub lifetimes: Vec<LifetimeDef>,\n-    pub unsafety: Unsafety,\n-    pub onceness: Onceness,\n-    pub decl: P<FnDecl>,\n-    pub bounds: TyParamBounds,\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n@@ -1710,10 +1684,10 @@ impl ForeignItem_ {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n-pub enum UnboxedClosureKind {\n-    FnUnboxedClosureKind,\n-    FnMutUnboxedClosureKind,\n-    FnOnceUnboxedClosureKind,\n+pub enum ClosureKind {\n+    FnClosureKind,\n+    FnMutClosureKind,\n+    FnOnceClosureKind,\n }\n \n /// The data we save and restore about an inlined item or method.  This is not"}, {"sha": "dd89153d497100ab190c34d349a6bc6182dddf5a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -467,6 +467,8 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n                                     ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"derive\"),\n                             Decorator(box ext::deriving::expand_meta_derive));\n+    syntax_expanders.insert(intern(\"deriving\"),\n+                            Decorator(box ext::deriving::expand_deprecated_deriving));\n \n     if ecfg.enable_quotes {\n         // Quasi-quoting expanders"}, {"sha": "9c85d3d28a7a0039d5b34ade26d4d773a2f11f67", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -51,7 +51,8 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n         path: Path::new(vec!(\"std\", \"marker\", name)),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: vec!()\n+        methods: Vec::new(),\n+        associated_types: Vec::new(),\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "e1dcc887778231d1b8f557b59caa4d424faafc9e", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -44,7 +44,8 @@ pub fn expand_deriving_clone<F>(cx: &mut ExtCtxt,\n                     cs_clone(\"Clone\", c, s, sub)\n                 }),\n             }\n-        )\n+        ),\n+        associated_types: Vec::new(),\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "00971b96e9288759ec9dcdaea150112d278fc772", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -88,7 +88,8 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n         methods: vec!(\n             md!(\"eq\", cs_eq),\n             md!(\"ne\", cs_ne)\n-        )\n+        ),\n+        associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "1f92f8d7b372a3ac92738b41fcfda4de05ac94e8", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -78,7 +78,8 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n             md!(\"le\", true, true),\n             md!(\"gt\", false, false),\n             md!(\"ge\", false, true)\n-        ]\n+        ],\n+        associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "0429db3643bb1a335279fb04c181668906bd04e2", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -61,7 +61,8 @@ pub fn expand_deriving_totaleq<F>(cx: &mut ExtCtxt,\n                     cs_total_eq_assert(a, b, c)\n                 })\n             }\n-        )\n+        ),\n+        associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "e90c1aa6fcee8254a18eea0a04520f8db653380b", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -45,7 +45,8 @@ pub fn expand_deriving_totalord<F>(cx: &mut ExtCtxt,\n                     cs_cmp(a, b, c)\n                 }),\n             }\n-        )\n+        ),\n+        associated_types: Vec::new(),\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "9552dff941d273d1a55ac99e8c96091d186dd7b1", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -79,7 +79,9 @@ fn expand_deriving_decodable_imp<F>(cx: &mut ExtCtxt,\n                 combine_substructure: combine_substructure(box |a, b, c| {\n                     decodable_substructure(a, b, c, krate)\n                 }),\n-            })\n+            }\n+        ),\n+        associated_types: Vec::new(),\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "27f3c46c48fceaf3edb4f6ccac496773ac2fc00f", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -43,7 +43,9 @@ pub fn expand_deriving_default<F>(cx: &mut ExtCtxt,\n                 combine_substructure: combine_substructure(box |a, b, c| {\n                     default_substructure(a, b, c)\n                 })\n-            })\n+            }\n+        ),\n+        associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "d0b2c2faf3719e2a3a70f921abd0fb0ee0970425", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -155,7 +155,9 @@ fn expand_deriving_encodable_imp<F>(cx: &mut ExtCtxt,\n                 combine_substructure: combine_substructure(box |a, b, c| {\n                     encodable_substructure(a, b, c)\n                 }),\n-            })\n+            }\n+        ),\n+        associated_types: Vec::new(),\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "56ff455a02bb87c0aca8bfab12b852da2c4c6c60", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -228,6 +228,8 @@ pub struct TraitDef<'a> {\n     pub generics: LifetimeBounds<'a>,\n \n     pub methods: Vec<MethodDef<'a>>,\n+\n+    pub associated_types: Vec<(ast::Ident, Ty<'a>)>,\n }\n \n \n@@ -387,6 +389,22 @@ impl<'a> TraitDef<'a> {\n                            methods: Vec<P<ast::Method>>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n+        // Transform associated types from `deriving::ty::Ty` into `ast::Typedef`\n+        let associated_types = self.associated_types.iter().map(|&(ident, ref type_def)| {\n+            P(ast::Typedef {\n+                id: ast::DUMMY_NODE_ID,\n+                span: self.span,\n+                ident: ident,\n+                vis: ast::Inherited,\n+                attrs: Vec::new(),\n+                typ: type_def.to_ty(cx,\n+                    self.span,\n+                    type_ident,\n+                    generics\n+                ),\n+            })\n+        });\n+\n         let Generics { mut lifetimes, ty_params, mut where_clause } =\n             self.generics.to_generics(cx, self.span, type_ident, generics);\n         let mut ty_params = ty_params.into_vec();\n@@ -494,7 +512,11 @@ impl<'a> TraitDef<'a> {\n                           methods.into_iter()\n                                  .map(|method| {\n                                      ast::MethodImplItem(method)\n-                                 }).collect()))\n+                                 }).chain(\n+                                     associated_types.map(|type_| {\n+                                         ast::TypeImplItem(type_)\n+                                     })\n+                                 ).collect()))\n     }\n \n     fn expand_struct_def(&self,"}, {"sha": "e7f546b2691f2c7bb9d94c597f0649d43df536c6", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -54,7 +54,8 @@ pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n                     hash_substructure(a, b, c)\n                 })\n             }\n-        )\n+        ),\n+        associated_types: Vec::new(),\n     };\n \n     hash_trait_def.expand(cx, mitem, item, push);"}, {"sha": "ddec517a78e6cba354790598777884f7f949967b", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -40,6 +40,14 @@ pub mod totalord;\n \n pub mod generic;\n \n+pub fn expand_deprecated_deriving(cx: &mut ExtCtxt,\n+                                  span: Span,\n+                                  _: &MetaItem,\n+                                  _: &Item,\n+                                  _: Box<FnMut(P<Item>)>) {\n+    cx.span_err(span, \"`deriving` has been renamed to `derive`\");\n+}\n+\n pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                           _span: Span,\n                           mitem: &MetaItem,"}, {"sha": "c694b054ba3c25cf273d88f19db0e0b5c6d73de1", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -65,7 +65,9 @@ pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n                 combine_substructure: combine_substructure(box |c, s, sub| {\n                     cs_from(\"u64\", c, s, sub)\n                 }),\n-            })\n+            }\n+        ),\n+        associated_types: Vec::new(),\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "9fd5091e194dcee568d8ee9a585f5e19138baaca", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -49,7 +49,8 @@ pub fn expand_deriving_rand<F>(cx: &mut ExtCtxt,\n                     rand_substructure(a, b, c)\n                 })\n             }\n-        )\n+        ),\n+        associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "ec5941f58f3f02c1aaf49b01a8d3ceafd0970689", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -35,10 +35,10 @@ pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new(vec!(\"std\", \"fmt\", \"Debug\")),\n+        path: Path::new(vec![\"std\", \"fmt\", \"Debug\"]),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: vec!(\n+        methods: vec![\n             MethodDef {\n                 name: \"fmt\",\n                 generics: LifetimeBounds::empty(),\n@@ -50,7 +50,8 @@ pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n                     show_substructure(a, b, c)\n                 })\n             }\n-        )\n+        ],\n+        associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "eab24574bb1952e9575e5fd763a32ccb36457423", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -28,8 +28,8 @@ use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprQPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n-use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n-use ast::{FnOnceUnboxedClosureKind};\n+use ast::{FnClosureKind, FnMutClosureKind};\n+use ast::{FnOnceClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n@@ -57,7 +57,7 @@ use ast::{TyFixedLengthVec, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n-use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n+use ast::{TypeImplItem, TypeTraitItem, Typedef, ClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n@@ -1133,27 +1133,26 @@ impl<'a> Parser<'a> {\n         TyInfer\n     }\n \n-    /// Parses an optional unboxed closure kind (`&:`, `&mut:`, or `:`).\n-    pub fn parse_optional_unboxed_closure_kind(&mut self)\n-                                               -> Option<UnboxedClosureKind> {\n+    /// Parses an optional closure kind (`&:`, `&mut:`, or `:`).\n+    pub fn parse_optional_closure_kind(&mut self) -> Option<ClosureKind> {\n         if self.check(&token::BinOp(token::And)) &&\n                 self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n                 self.look_ahead(2, |t| *t == token::Colon) {\n             self.bump();\n             self.bump();\n             self.bump();\n-            return Some(FnMutUnboxedClosureKind)\n+            return Some(FnMutClosureKind)\n         }\n \n         if self.token == token::BinOp(token::And) &&\n                     self.look_ahead(1, |t| *t == token::Colon) {\n             self.bump();\n             self.bump();\n-            return Some(FnUnboxedClosureKind)\n+            return Some(FnClosureKind)\n         }\n \n         if self.eat(&token::Colon) {\n-            return Some(FnOnceUnboxedClosureKind)\n+            return Some(FnOnceClosureKind)\n         }\n \n         return None\n@@ -3023,8 +3022,7 @@ impl<'a> Parser<'a> {\n                              -> P<Expr>\n     {\n         let lo = self.span.lo;\n-        let (decl, optional_unboxed_closure_kind) =\n-            self.parse_fn_block_decl();\n+        let (decl, optional_closure_kind) = self.parse_fn_block_decl();\n         let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n             id: ast::DUMMY_NODE_ID,\n@@ -3037,7 +3035,7 @@ impl<'a> Parser<'a> {\n         self.mk_expr(\n             lo,\n             fakeblock.span.hi,\n-            ExprClosure(capture_clause, optional_unboxed_closure_kind, decl, fakeblock))\n+            ExprClosure(capture_clause, optional_closure_kind, decl, fakeblock))\n     }\n \n     pub fn parse_else_expr(&mut self) -> P<Expr> {\n@@ -4506,22 +4504,21 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&mut self)\n-                           -> (P<FnDecl>, Option<UnboxedClosureKind>) {\n-        let (optional_unboxed_closure_kind, inputs_captures) = {\n+    fn parse_fn_block_decl(&mut self) -> (P<FnDecl>, Option<ClosureKind>) {\n+        let (optional_closure_kind, inputs_captures) = {\n             if self.eat(&token::OrOr) {\n                 (None, Vec::new())\n             } else {\n                 self.expect(&token::BinOp(token::Or));\n-                let optional_unboxed_closure_kind =\n-                    self.parse_optional_unboxed_closure_kind();\n+                let optional_closure_kind =\n+                    self.parse_optional_closure_kind();\n                 let args = self.parse_seq_to_before_end(\n                     &token::BinOp(token::Or),\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_fn_block_arg()\n                 );\n                 self.bump();\n-                (optional_unboxed_closure_kind, args)\n+                (optional_closure_kind, args)\n             }\n         };\n         let output = self.parse_ret_ty();\n@@ -4530,7 +4527,7 @@ impl<'a> Parser<'a> {\n             inputs: inputs_captures,\n             output: output,\n             variadic: false\n-        }), optional_unboxed_closure_kind)\n+        }), optional_closure_kind)\n     }\n \n     /// Parses the `(arg, arg) -> return_type` header on a procedure."}, {"sha": "d06ac50920e04b12f032a2432de235400ed3243d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 92, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -11,11 +11,11 @@\n pub use self::AnnNode::*;\n \n use abi;\n-use ast::{self, FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n-use ast::{FnOnceUnboxedClosureKind};\n+use ast::{self, FnClosureKind, FnMutClosureKind};\n+use ast::{FnOnceClosureKind};\n use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n-use ast::{UnboxedClosureKind};\n+use ast::{ClosureKind};\n use ast_util;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n@@ -703,14 +703,11 @@ impl<'a> State<'a> {\n                         predicates: Vec::new(),\n                     },\n                 };\n-                try!(self.print_ty_fn(Some(f.abi),\n-                                      None,\n+                try!(self.print_ty_fn(f.abi,\n                                       f.unsafety,\n-                                      ast::Many,\n                                       &*f.decl,\n                                       None,\n-                                      &OwnedSlice::empty(),\n-                                      Some(&generics),\n+                                      &generics,\n                                       None));\n             }\n             ast::TyPath(ref path, _) => {\n@@ -1215,14 +1212,11 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(m.span.lo));\n         try!(self.print_outer_attributes(&m.attrs[]));\n-        try!(self.print_ty_fn(None,\n-                              None,\n+        try!(self.print_ty_fn(m.abi,\n                               m.unsafety,\n-                              ast::Many,\n                               &*m.decl,\n                               Some(m.ident),\n-                              &OwnedSlice::empty(),\n-                              Some(&m.generics),\n+                              &m.generics,\n                               Some(&m.explicit_self.node)));\n         word(&mut self.s, \";\")\n     }\n@@ -2300,7 +2294,7 @@ impl<'a> State<'a> {\n                     opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> IoResult<()> {\n         try!(self.head(\"\"));\n-        try!(self.print_fn_header_info(opt_explicit_self, unsafety, abi, vis));\n+        try!(self.print_fn_header_info(unsafety, abi, vis));\n         try!(self.nbsp());\n         try!(self.print_ident(name));\n         try!(self.print_generics(generics));\n@@ -2357,14 +2351,14 @@ impl<'a> State<'a> {\n     pub fn print_fn_block_args(\n             &mut self,\n             decl: &ast::FnDecl,\n-            unboxed_closure_kind: Option<UnboxedClosureKind>)\n+            closure_kind: Option<ClosureKind>)\n             -> IoResult<()> {\n         try!(word(&mut self.s, \"|\"));\n-        match unboxed_closure_kind {\n+        match closure_kind {\n             None => {}\n-            Some(FnUnboxedClosureKind) => try!(self.word_space(\"&:\")),\n-            Some(FnMutUnboxedClosureKind) => try!(self.word_space(\"&mut:\")),\n-            Some(FnOnceUnboxedClosureKind) => try!(self.word_space(\":\")),\n+            Some(FnClosureKind) => try!(self.word_space(\"&:\")),\n+            Some(FnMutClosureKind) => try!(self.word_space(\"&mut:\")),\n+            Some(FnOnceClosureKind) => try!(self.word_space(\":\")),\n         }\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n@@ -2396,31 +2390,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_proc_args(&mut self, decl: &ast::FnDecl) -> IoResult<()> {\n-        try!(word(&mut self.s, \"proc\"));\n-        try!(word(&mut self.s, \"(\"));\n-        try!(self.print_fn_args(decl, None));\n-        try!(word(&mut self.s, \")\"));\n-\n-        if let ast::DefaultReturn(..) = decl.output {\n-            return Ok(());\n-        }\n-\n-        try!(self.space_if_not_bol());\n-        try!(self.word_space(\"->\"));\n-        match decl.output {\n-            ast::Return(ref ty) => {\n-                try!(self.print_type(&**ty));\n-                self.maybe_print_comment(ty.span.lo)\n-            }\n-            ast::DefaultReturn(..) => unreachable!(),\n-            ast::NoReturn(span) => {\n-                try!(self.word_nbsp(\"!\"));\n-                self.maybe_print_comment(span.lo)\n-            }\n-        }\n-    }\n-\n     pub fn print_bounds(&mut self,\n                         prefix: &str,\n                         bounds: &[ast::TyParamBound])\n@@ -2696,31 +2665,15 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_fn(&mut self,\n-                       opt_abi: Option<abi::Abi>,\n-                       opt_sigil: Option<char>,\n+                       abi: abi::Abi,\n                        unsafety: ast::Unsafety,\n-                       onceness: ast::Onceness,\n                        decl: &ast::FnDecl,\n                        id: Option<ast::Ident>,\n-                       bounds: &OwnedSlice<ast::TyParamBound>,\n-                       generics: Option<&ast::Generics>,\n+                       generics: &ast::Generics,\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n-\n-        // Duplicates the logic in `print_fn_header_info()`.  This is because that\n-        // function prints the sigil in the wrong place.  That should be fixed.\n-        if opt_sigil == Some('~') && onceness == ast::Once {\n-            try!(word(&mut self.s, \"proc\"));\n-        } else if opt_sigil == Some('&') {\n-            try!(self.print_unsafety(unsafety));\n-            try!(self.print_extern_opt_abi(opt_abi));\n-        } else {\n-            assert!(opt_sigil.is_none());\n-            try!(self.print_unsafety(unsafety));\n-            try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n-            try!(word(&mut self.s, \"fn\"));\n-        }\n+        try!(self.print_fn_header_info(Some(unsafety), abi, ast::Inherited));\n \n         match id {\n             Some(id) => {\n@@ -2730,35 +2683,10 @@ impl<'a> State<'a> {\n             _ => ()\n         }\n \n-        match generics { Some(g) => try!(self.print_generics(g)), _ => () }\n+        try!(self.print_generics(generics));\n         try!(zerobreak(&mut self.s));\n-\n-        if opt_sigil == Some('&') {\n-            try!(word(&mut self.s, \"|\"));\n-        } else {\n-            try!(self.popen());\n-        }\n-\n-        try!(self.print_fn_args(decl, opt_explicit_self));\n-\n-        if opt_sigil == Some('&') {\n-            try!(word(&mut self.s, \"|\"));\n-        } else {\n-            if decl.variadic {\n-                try!(word(&mut self.s, \", ...\"));\n-            }\n-            try!(self.pclose());\n-        }\n-\n-        try!(self.print_bounds(\":\", &bounds[]));\n-\n-        try!(self.print_fn_output(decl));\n-\n-        match generics {\n-            Some(generics) => try!(self.print_where_clause(generics)),\n-            None => {}\n-        }\n-\n+        try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n+        try!(self.print_where_clause(generics));\n         self.end()\n     }\n \n@@ -3015,7 +2943,6 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                _opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 opt_unsafety: Option<ast::Unsafety>,\n                                 abi: abi::Abi,\n                                 vis: ast::Visibility) -> IoResult<()> {"}, {"sha": "060e178eef2b467dd02a4738ab9a5acd367fec61", "filename": "src/test/compile-fail/deriving-is-deprecated.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Fcompile-fail%2Fderiving-is-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Fcompile-fail%2Fderiving-is-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-is-deprecated.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#[deriving(Clone)] //~ ERROR `deriving` has been renamed to `derive`\n+struct Foo;\n+\n+fn main() {}"}, {"sha": "4adae2f3680645070df06b0a8fe9e4936300a17f", "filename": "src/test/compile-fail/missing_debug_impls.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --crate-type lib\n+#![deny(missing_debug_implementations)]\n+#![allow(unused, unstable, missing_copy_implementations)]\n+\n+use std::fmt;\n+\n+pub enum A {} //~ ERROR type does not implement `fmt::Debug`\n+\n+#[derive(Debug)]\n+pub enum B {}\n+\n+pub enum C {}\n+\n+impl fmt::Debug for C {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+pub struct Foo; //~ ERROR type does not implement `fmt::Debug`\n+\n+#[derive(Debug)]\n+pub struct Bar;\n+\n+pub struct Baz;\n+\n+impl fmt::Debug for Baz {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+struct PrivateStruct;\n+\n+enum PrivateEnum {}\n+\n+#[derive(Debug)]\n+struct GenericType<T>(T);"}, {"sha": "c75abd88963433dbb92f6901e3d8a738f43cad96", "filename": "src/test/run-pass/issue-21306.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Frun-pass%2Fissue-21306.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Frun-pass%2Fissue-21306.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21306.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::Arc;\n+\n+fn main() {\n+    let x = 5us;\n+    let command = Arc::new(Box::new(|&:| { x*2 }));\n+    assert_eq!(command(), 10);\n+}"}, {"sha": "2fc1d9fd6433c4c15dcdb7be41b8a1b5f33d7ee0", "filename": "src/test/run-pass/issue-21363.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Frun-pass%2Fissue-21363.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Frun-pass%2Fissue-21363.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21363.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![no_implicit_prelude]\n+\n+trait Iterator {\n+    type Item;\n+}\n+\n+impl<'a, T> Iterator for &'a mut (Iterator<Item=T> + 'a) {\n+    type Item = T;\n+}\n+\n+fn main() {}"}, {"sha": "a04301931da6a941e03048046e977c3a0500565d", "filename": "src/test/run-pass/unboxed-closures-unique-type-id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs?ref=5a6fb8eb98f1e8d7188100ef83f25d01f30fff9f", "patch": "@@ -12,7 +12,7 @@\n //\n //    error: internal compiler error: get_unique_type_id_of_type() -\n //    unexpected type: closure,\n-//    ty_unboxed_closure(syntax::ast::DefId{krate: 0u32, node: 66u32},\n+//    ty_closure(syntax::ast::DefId{krate: 0u32, node: 66u32},\n //    ReScope(63u32))\n //\n // This is a regression test for issue #17021."}]}