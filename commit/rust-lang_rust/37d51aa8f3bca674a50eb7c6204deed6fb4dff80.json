{"sha": "37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZDUxYWE4ZjNiY2E2NzRhNTBlYjdjNjIwNGRlZWQ2ZmI0ZGZmODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-25T23:27:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-25T23:27:20Z"}, "message": "Auto merge of #57898 - Centril:rollup, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #56233 (Miri and miri-related code contains repetitions of `(n << amt) >> amt`)\n - #57645 (distinguish \"no data\" from \"heterogeneous\" in ABI)\n - #57734 (Fix evaluating trivial drop glue in constants)\n - #57886 (Add suggestion for moving type declaration before associated type bindings in generic arguments.)\n - #57890 (Fix wording in diagnostics page)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "497061fd0419b43366c4a601081cd782d358b15d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/497061fd0419b43366c4a601081cd782d358b15d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "html_url": "https://github.com/rust-lang/rust/commit/37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf669d1e3295bc688f71b8c91f48a6beaf895f67", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf669d1e3295bc688f71b8c91f48a6beaf895f67", "html_url": "https://github.com/rust-lang/rust/commit/bf669d1e3295bc688f71b8c91f48a6beaf895f67"}, {"sha": "0ae3d87d814d28457c143813beb526733e400570", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ae3d87d814d28457c143813beb526733e400570", "html_url": "https://github.com/rust-lang/rust/commit/0ae3d87d814d28457c143813beb526733e400570"}], "stats": {"total": 952, "additions": 870, "deletions": 82}, "files": [{"sha": "c9089428b23245c24ac45af7bdc3f46325c51560", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -2937,16 +2937,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given the DefId of an item, returns its MIR, borrowed immutably.\n-    /// Returns None if there is no MIR for the DefId\n-    pub fn maybe_optimized_mir(self, did: DefId) -> Option<&'gcx Mir<'gcx>> {\n-        if self.is_mir_available(did) {\n-            Some(self.optimized_mir(did))\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Get the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'gcx> {\n         if let Some(id) = self.hir().as_local_node_id(did) {"}, {"sha": "55f9d8a1109ce75f50332b1ee1e0978685aee486", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -22,7 +22,7 @@ use rustc_incremental;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n use rustc_mir as mir;\n-use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion};\n+use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion, layout_test};\n use rustc_plugin as plugin;\n use rustc_plugin::registry::Registry;\n use rustc_privacy;\n@@ -1287,6 +1287,9 @@ where\n                     mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n                 }\n             });\n+\n+            time(sess, \"layout testing\", || layout_test::test_layout(tcx));\n+\n             // Avoid overwhelming user with errors if type checking failed.\n             // I'm not sure how helpful this is, to be honest, but it avoids\n             // a"}, {"sha": "9d3275ffde2c0a3f6000bcf760bdce386f5bbaae", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -21,6 +21,8 @@ use syntax::source_map;\n \n use rustc::hir;\n \n+use rustc::mir::interpret::{sign_extend, truncate};\n+\n declare_lint! {\n     UNUSED_COMPARISONS,\n     Warn,\n@@ -368,14 +370,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             let (t, actually) = match ty {\n                 ty::Int(t) => {\n                     let ity = attr::IntType::SignedInt(t);\n-                    let bits = layout::Integer::from_attr(&cx.tcx, ity).size().bits();\n-                    let actually = (val << (128 - bits)) as i128 >> (128 - bits);\n+                    let size = layout::Integer::from_attr(&cx.tcx, ity).size();\n+                    let actually = sign_extend(val, size) as i128;\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }\n                 ty::Uint(t) => {\n                     let ity = attr::IntType::UnsignedInt(t);\n-                    let bits = layout::Integer::from_attr(&cx.tcx, ity).size().bits();\n-                    let actually = (val << (128 - bits)) >> (128 - bits);\n+                    let size = layout::Integer::from_attr(&cx.tcx, ity).size();\n+                    let actually = truncate(val, size);\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }\n                 _ => bug!(),"}, {"sha": "9ed480a9af5bb8b6b8f06ccf3b72f5dac4f48228", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -340,19 +340,22 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n-        // Execution might have wandered off into other crates, so we cannot to a stability-\n-        // sensitive check here.  But we can at least rule out functions that are not const\n-        // at all.\n-        if !ecx.tcx.is_const_fn_raw(instance.def_id()) {\n-            // Some functions we support even if they are non-const -- but avoid testing\n-            // that for const fn!  We certainly do *not* want to actually call the fn\n-            // though, so be sure we return here.\n-            return if ecx.hook_fn(instance, args, dest)? {\n-                ecx.goto_block(ret)?; // fully evaluated and done\n-                Ok(None)\n-            } else {\n-                err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n-            };\n+        // Only check non-glue functions\n+        if let ty::InstanceDef::Item(def_id) = instance.def {\n+            // Execution might have wandered off into other crates, so we cannot to a stability-\n+            // sensitive check here.  But we can at least rule out functions that are not const\n+            // at all.\n+            if !ecx.tcx.is_const_fn_raw(def_id) {\n+                // Some functions we support even if they are non-const -- but avoid testing\n+                // that for const fn!  We certainly do *not* want to actually call the fn\n+                // though, so be sure we return here.\n+                return if ecx.hook_fn(instance, args, dest)? {\n+                    ecx.goto_block(ret)?; // fully evaluated and done\n+                    Ok(None)\n+                } else {\n+                    err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n+                };\n+            }\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def) {"}, {"sha": "34443bb353e0e4f1dfb54b2d8df884747713d789", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -273,11 +273,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         }\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n-            ty::InstanceDef::Item(def_id) => {\n-                self.tcx.maybe_optimized_mir(def_id).ok_or_else(||\n-                    EvalErrorKind::NoMirFor(self.tcx.item_path_str(def_id)).into()\n-                )\n-            }\n+            ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n+                Ok(self.tcx.optimized_mir(did))\n+            } else {\n+                err!(NoMirFor(self.tcx.item_path_str(def_id)))\n+            },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n     }"}, {"sha": "d21707c578b2ac536e1813357216e990faeb9ebb", "filename": "src/librustc_passes/layout_test.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,132 @@\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::ItemKind;\n+use rustc::ty::layout::HasDataLayout;\n+use rustc::ty::layout::HasTyCtxt;\n+use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::TargetDataLayout;\n+use rustc::ty::layout::TyLayout;\n+use rustc::ty::ParamEnv;\n+use rustc::ty::Ty;\n+use rustc::ty::TyCtxt;\n+use syntax::ast::Attribute;\n+\n+pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    if tcx.features().rustc_attrs {\n+        // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n+        tcx.hir()\n+            .krate()\n+            .visit_all_item_likes(&mut VarianceTest { tcx });\n+    }\n+}\n+\n+struct VarianceTest<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let item_def_id = self.tcx.hir().local_def_id(item.id);\n+\n+        if let ItemKind::Ty(..) = item.node {\n+            for attr in self.tcx.get_attrs(item_def_id).iter() {\n+                if attr.check_name(\"rustc_layout\") {\n+                    self.dump_layout_of(item_def_id, item, attr);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {}\n+}\n+\n+impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n+    fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item, attr: &Attribute) {\n+        let tcx = self.tcx;\n+        let param_env = self.tcx.param_env(item_def_id);\n+        let ty = self.tcx.type_of(item_def_id);\n+        match self.tcx.layout_of(param_env.and(ty)) {\n+            Ok(ty_layout) => {\n+                // Check out the `#[rustc_layout(..)]` attribute to tell what to dump.\n+                // The `..` are the names of fields to dump.\n+                let meta_items = attr.meta_item_list().unwrap_or_default();\n+                for meta_item in meta_items {\n+                    let name = meta_item.word().map(|mi| mi.name().as_str());\n+                    let name = name.as_ref().map(|s| &s[..]).unwrap_or(\"\");\n+\n+                    match name {\n+                        \"abi\" => {\n+                            self.tcx\n+                                .sess\n+                                .span_err(item.span, &format!(\"abi: {:?}\", ty_layout.abi));\n+                        }\n+\n+                        \"align\" => {\n+                            self.tcx\n+                                .sess\n+                                .span_err(item.span, &format!(\"align: {:?}\", ty_layout.align));\n+                        }\n+\n+                        \"size\" => {\n+                            self.tcx\n+                                .sess\n+                                .span_err(item.span, &format!(\"size: {:?}\", ty_layout.size));\n+                        }\n+\n+                        \"homogeneous_aggregate\" => {\n+                            self.tcx.sess.span_err(\n+                                item.span,\n+                                &format!(\n+                                    \"homogeneous_aggregate: {:?}\",\n+                                    ty_layout\n+                                        .homogeneous_aggregate(&UnwrapLayoutCx { tcx, param_env }),\n+                                ),\n+                            );\n+                        }\n+\n+                        _ => {\n+                            self.tcx.sess.span_err(\n+                                meta_item.span,\n+                                &format!(\"unrecognized field name `{}`\", name),\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Err(layout_error) => {\n+                self.tcx\n+                    .sess\n+                    .span_err(item.span, &format!(\"layout error: {:?}\", layout_error));\n+            }\n+        }\n+    }\n+}\n+\n+struct UnwrapLayoutCx<'me, 'tcx> {\n+    tcx: TyCtxt<'me, 'tcx, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+}\n+\n+impl<'me, 'tcx> LayoutOf for UnwrapLayoutCx<'me, 'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyLayout = TyLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.tcx.layout_of(self.param_env.and(ty)).unwrap()\n+    }\n+}\n+\n+impl<'me, 'tcx> HasTyCtxt<'tcx> for UnwrapLayoutCx<'me, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'me, 'tcx> HasDataLayout for UnwrapLayoutCx<'me, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self.tcx.data_layout()\n+    }\n+}"}, {"sha": "a181bc7e9b480dc8bbf56bc664dd8cb333b11fab", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -32,6 +32,7 @@ mod diagnostics;\n pub mod ast_validation;\n pub mod rvalue_promotion;\n pub mod hir_stats;\n+pub mod layout_test;\n pub mod loops;\n \n __build_diagnostic_array! { librustc_passes, DIAGNOSTICS }"}, {"sha": "9f9bba14b963e8428ffc225606fdf2fc40a470eb", "filename": "src/librustc_target/abi/call/aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Faarch64.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -6,7 +6,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "228dd36216158976b1926b894f7aca7d1ca95da9", "filename": "src/librustc_target/abi/call/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Farm.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -7,7 +7,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members."}, {"sha": "85444500c5e11752e13d4653fb0b7ed8fa0d74a7", "filename": "src/librustc_target/abi/call/asmjs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fasmjs.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -11,7 +11,7 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>)\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n     if ret.layout.is_aggregate() {\n-        if let Some(unit) = ret.layout.homogeneous_aggregate(cx) {\n+        if let Some(unit) = ret.layout.homogeneous_aggregate(cx).unit() {\n             let size = ret.layout.size;\n             if unit.size == size {\n                 ret.cast_to(Uniform {"}, {"sha": "0d50439c67ec08495698a6b6b5807c8d7f8c6fa3", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 66, "deletions": 13, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -228,6 +228,33 @@ impl CastTarget {\n     }\n }\n \n+/// Return value from the `homogeneous_aggregate` test function.\n+#[derive(Copy, Clone, Debug)]\n+pub enum HomogeneousAggregate {\n+    /// Yes, all the \"leaf fields\" of this struct are passed in the\n+    /// same way (specified in the `Reg` value).\n+    Homogeneous(Reg),\n+\n+    /// There are distinct leaf fields passed in different ways,\n+    /// or this is uninhabited.\n+    Heterogeneous,\n+\n+    /// There are no leaf fields at all.\n+    NoData,\n+}\n+\n+impl HomogeneousAggregate {\n+    /// If this is a homogeneous aggregate, returns the homogeneous\n+    /// unit, else `None`.\n+    pub fn unit(self) -> Option<Reg> {\n+        if let HomogeneousAggregate::Homogeneous(r) = self {\n+            Some(r)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, Ty> TyLayout<'a, Ty> {\n     fn is_aggregate(&self) -> bool {\n         match self.abi {\n@@ -239,11 +266,21 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n         }\n     }\n \n-    fn homogeneous_aggregate<C>(&self, cx: &C) -> Option<Reg>\n+    /// True if this layout is an aggregate containing fields of only\n+    /// a single type (e.g., `(u32, u32)`). Such aggregates are often\n+    /// special-cased in ABIs.\n+    ///\n+    /// Note: We generally ignore fields of zero-sized type when computing\n+    /// this value (cc #56877).\n+    ///\n+    /// This is public so that it can be used in unit tests, but\n+    /// should generally only be relevant to the ABI details of\n+    /// specific targets.\n+    pub fn homogeneous_aggregate<C>(&self, cx: &C) -> HomogeneousAggregate\n         where Ty: TyLayoutMethods<'a, C> + Copy, C: LayoutOf<Ty = Ty, TyLayout = Self>\n     {\n         match self.abi {\n-            Abi::Uninhabited => None,\n+            Abi::Uninhabited => HomogeneousAggregate::Heterogeneous,\n \n             // The primitive for this algorithm.\n             Abi::Scalar(ref scalar) => {\n@@ -252,14 +289,15 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n                     abi::Pointer => RegKind::Integer,\n                     abi::Float(_) => RegKind::Float,\n                 };\n-                Some(Reg {\n+                HomogeneousAggregate::Homogeneous(Reg {\n                     kind,\n                     size: self.size\n                 })\n             }\n \n             Abi::Vector { .. } => {\n-                Some(Reg {\n+                assert!(!self.is_zst());\n+                HomogeneousAggregate::Homogeneous(Reg {\n                     kind: RegKind::Vector,\n                     size: self.size\n                 })\n@@ -275,7 +313,7 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n                         if count > 0 {\n                             return self.field(cx, 0).homogeneous_aggregate(cx);\n                         } else {\n-                            return None;\n+                            return HomogeneousAggregate::NoData;\n                         }\n                     }\n                     FieldPlacement::Union(_) => true,\n@@ -284,21 +322,27 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n \n                 for i in 0..self.fields.count() {\n                     if !is_union && total != self.fields.offset(i) {\n-                        return None;\n+                        return HomogeneousAggregate::Heterogeneous;\n                     }\n \n                     let field = self.field(cx, i);\n+\n                     match (result, field.homogeneous_aggregate(cx)) {\n-                        // The field itself must be a homogeneous aggregate.\n-                        (_, None) => return None,\n+                        (_, HomogeneousAggregate::NoData) => {\n+                            // Ignore fields that have no data\n+                        }\n+                        (_, HomogeneousAggregate::Heterogeneous) => {\n+                            // The field itself must be a homogeneous aggregate.\n+                            return HomogeneousAggregate::Heterogeneous;\n+                        }\n                         // If this is the first field, record the unit.\n-                        (None, Some(unit)) => {\n+                        (None, HomogeneousAggregate::Homogeneous(unit)) => {\n                             result = Some(unit);\n                         }\n                         // For all following fields, the unit must be the same.\n-                        (Some(prev_unit), Some(unit)) => {\n+                        (Some(prev_unit), HomogeneousAggregate::Homogeneous(unit)) => {\n                             if prev_unit != unit {\n-                                return None;\n+                                return HomogeneousAggregate::Heterogeneous;\n                             }\n                         }\n                     }\n@@ -314,9 +358,18 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n \n                 // There needs to be no padding.\n                 if total != self.size {\n-                    None\n+                    HomogeneousAggregate::Heterogeneous\n                 } else {\n-                    result\n+                    match result {\n+                        Some(reg) => {\n+                            assert_ne!(total, Size::ZERO);\n+                            HomogeneousAggregate::Homogeneous(reg)\n+                        }\n+                        None => {\n+                            assert_eq!(total, Size::ZERO);\n+                            HomogeneousAggregate::NoData\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "305a2d4225056352f776f2df481e76efe8fe8dfc", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -18,7 +18,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: A\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n         if (abi == ELFv1 && arg.layout.size > unit.size)"}, {"sha": "150b48a8d02550d06aa0f7ea5377dd9ee8fa4a4d", "filename": "src/librustc_target/abi/call/sparc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc64.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -8,7 +8,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n-    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).unit().and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n         if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;"}, {"sha": "648a4b5bb9d79cb1ceb96000145f9d3ab3363c0d", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -99,7 +99,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Fla\n             };\n \n             // At this point we know this must be a primitive of sorts.\n-            let unit = arg.layout.homogeneous_aggregate(cx).unwrap();\n+            let unit = arg.layout.homogeneous_aggregate(cx).unit().unwrap();\n             assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;"}, {"sha": "1f260d317e4c65a22cb0f33228f9d73f9d1a2bcb", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -763,7 +763,7 @@ function's return type and the value being returned.\n \"##,\n \n E0070: r##\"\n-The left-hand side of an assignment operator must be a place expression. An\n+The left-hand side of an assignment operator must be a place expression. A\n place expression represents a memory location and can be a variable (with\n optional namespacing), a dereference, an indexing expression or a field\n reference."}, {"sha": "85e80f7bdaf19f0c882c79183a1190d601e4257e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -938,6 +938,13 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n                                       is just used for rustc unit tests \\\n                                       and will never be stable\",\n                                      cfg_fn!(rustc_attrs))),\n+    (\"rustc_layout\", Normal, template!(List: \"field1, field2, ...\"),\n+     Gated(Stability::Unstable,\n+           \"rustc_attrs\",\n+           \"the `#[rustc_layout]` attribute \\\n+            is just used for rustc unit tests \\\n+            and will never be stable\",\n+           cfg_fn!(rustc_attrs))),\n     (\"rustc_regions\", Normal, template!(Word), Gated(Stability::Unstable,\n                                     \"rustc_attrs\",\n                                     \"the `#[rustc_regions]` attribute \\"}, {"sha": "57dcc42d9e6f8f9efd069796fabedf153b3edfad", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 107, "deletions": 27, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -5543,22 +5543,31 @@ impl<'a> Parser<'a> {\n     fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n         let mut args = Vec::new();\n         let mut bindings = Vec::new();\n+\n         let mut seen_type = false;\n         let mut seen_binding = false;\n+\n+        let mut last_comma_span = None;\n         let mut first_type_or_binding_span: Option<Span> = None;\n+        let mut first_binding_span: Option<Span> = None;\n+\n         let mut bad_lifetime_pos = vec![];\n-        let mut last_comma_span = None;\n-        let mut suggestions = vec![];\n+        let mut bad_type_pos = vec![];\n+\n+        let mut lifetime_suggestions = vec![];\n+        let mut type_suggestions = vec![];\n         loop {\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 // Parse lifetime argument.\n                 args.push(GenericArg::Lifetime(self.expect_lifetime()));\n+\n                 if seen_type || seen_binding {\n                     let remove_sp = last_comma_span.unwrap_or(self.prev_span).to(self.prev_span);\n                     bad_lifetime_pos.push(self.prev_span);\n+\n                     if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.prev_span) {\n-                        suggestions.push((remove_sp, String::new()));\n-                        suggestions.push((\n+                        lifetime_suggestions.push((remove_sp, String::new()));\n+                        lifetime_suggestions.push((\n                             first_type_or_binding_span.unwrap().shrink_to_lo(),\n                             format!(\"{}, \", snippet)));\n                     }\n@@ -5576,24 +5585,29 @@ impl<'a> Parser<'a> {\n                     ty,\n                     span,\n                 });\n+\n                 seen_binding = true;\n                 if first_type_or_binding_span.is_none() {\n                     first_type_or_binding_span = Some(span);\n                 }\n+                if first_binding_span.is_none() {\n+                    first_binding_span = Some(span);\n+                }\n             } else if self.check_type() {\n                 // Parse type argument.\n                 let ty_param = self.parse_ty()?;\n                 if seen_binding {\n-                    self.struct_span_err(\n-                        ty_param.span,\n-                        \"type parameters must be declared prior to associated type bindings\"\n-                    )\n-                        .span_label(\n-                            ty_param.span,\n-                            \"must be declared prior to associated type bindings\",\n-                        )\n-                        .emit();\n+                    let remove_sp = last_comma_span.unwrap_or(self.prev_span).to(self.prev_span);\n+                    bad_type_pos.push(self.prev_span);\n+\n+                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.prev_span) {\n+                        type_suggestions.push((remove_sp, String::new()));\n+                        type_suggestions.push((\n+                            first_binding_span.unwrap().shrink_to_lo(),\n+                            format!(\"{}, \", snippet)));\n+                    }\n                 }\n+\n                 if first_type_or_binding_span.is_none() {\n                     first_type_or_binding_span = Some(ty_param.span);\n                 }\n@@ -5609,27 +5623,93 @@ impl<'a> Parser<'a> {\n                 last_comma_span = Some(self.prev_span);\n             }\n         }\n-        if !bad_lifetime_pos.is_empty() {\n-            let mut err = self.struct_span_err(\n+\n+        self.maybe_report_incorrect_generic_argument_order(\n+            bad_lifetime_pos, bad_type_pos, lifetime_suggestions, type_suggestions\n+        );\n+\n+        Ok((args, bindings))\n+    }\n+\n+    /// Maybe report an error about incorrect generic argument order - \"lifetime parameters\n+    /// must be declared before type parameters\", \"type parameters must be declared before\n+    /// associated type bindings\" or both.\n+    fn maybe_report_incorrect_generic_argument_order(\n+        &self,\n+        bad_lifetime_pos: Vec<Span>,\n+        bad_type_pos: Vec<Span>,\n+        lifetime_suggestions: Vec<(Span, String)>,\n+        type_suggestions: Vec<(Span, String)>,\n+    ) {\n+        let mut err = if !bad_lifetime_pos.is_empty() && !bad_type_pos.is_empty() {\n+            let mut positions = bad_lifetime_pos.clone();\n+            positions.extend_from_slice(&bad_type_pos);\n+\n+            self.struct_span_err(\n+                positions,\n+                \"generic arguments must declare lifetimes, types and associated type bindings in \\\n+                 that order\",\n+            )\n+        } else if !bad_lifetime_pos.is_empty() {\n+            self.struct_span_err(\n                 bad_lifetime_pos.clone(),\n                 \"lifetime parameters must be declared prior to type parameters\"\n-            );\n+            )\n+        } else if !bad_type_pos.is_empty() {\n+            self.struct_span_err(\n+                bad_type_pos.clone(),\n+                \"type parameters must be declared prior to associated type bindings\"\n+            )\n+        } else {\n+            return;\n+        };\n+\n+        if !bad_lifetime_pos.is_empty() {\n             for sp in &bad_lifetime_pos {\n                 err.span_label(*sp, \"must be declared prior to type parameters\");\n             }\n-            if !suggestions.is_empty() {\n-                err.multipart_suggestion_with_applicability(\n-                    &format!(\n-                        \"move the lifetime parameter{} prior to the first type parameter\",\n-                        if bad_lifetime_pos.len() > 1 { \"s\" } else { \"\" },\n-                    ),\n-                    suggestions,\n-                    Applicability::MachineApplicable,\n-                );\n+        }\n+\n+        if !bad_type_pos.is_empty() {\n+            for sp in &bad_type_pos {\n+                err.span_label(*sp, \"must be declared prior to associated type bindings\");\n             }\n-            err.emit();\n         }\n-        Ok((args, bindings))\n+\n+        if !lifetime_suggestions.is_empty() && !type_suggestions.is_empty() {\n+            let mut suggestions = lifetime_suggestions;\n+            suggestions.extend_from_slice(&type_suggestions);\n+\n+            let plural = bad_lifetime_pos.len() + bad_type_pos.len() > 1;\n+            err.multipart_suggestion_with_applicability(\n+                &format!(\n+                    \"move the parameter{}\",\n+                    if plural { \"s\" } else { \"\" },\n+                ),\n+                suggestions,\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !lifetime_suggestions.is_empty() {\n+            err.multipart_suggestion_with_applicability(\n+                &format!(\n+                    \"move the lifetime parameter{} prior to the first type parameter\",\n+                    if bad_lifetime_pos.len() > 1 { \"s\" } else { \"\" },\n+                ),\n+                lifetime_suggestions,\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !type_suggestions.is_empty() {\n+            err.multipart_suggestion_with_applicability(\n+                &format!(\n+                    \"move the type parameter{} prior to the first associated type binding\",\n+                    if bad_type_pos.len() > 1 { \"s\" } else { \"\" },\n+                ),\n+                type_suggestions,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        err.emit();\n     }\n \n     /// Parses an optional `where` clause and places it in `generics`."}, {"sha": "86a197ffb993ece641d6e19edd1f54e652eb32db", "filename": "src/test/ui/consts/drop_none.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fconsts%2Fdrop_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fconsts%2Fdrop_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdrop_none.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,13 @@\n+// compile-pass\n+#![allow(dead_code)]\n+struct A;\n+impl Drop for A {\n+    fn drop(&mut self) {}\n+}\n+\n+const FOO: Option<A> = None;\n+\n+const BAR: () = (FOO, ()).1;\n+\n+\n+fn main() {}"}, {"sha": "622709e7de58472f962767fd2923055425c9e8fb", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,36 @@\n+#![feature(rustc_attrs)]\n+\n+// Show that `homogeneous_aggregate` code ignores zero-length C\n+// arrays.  This matches the recent C standard, though not the\n+// behavior of all older compilers, which somtimes consider `T[0]` to\n+// be a \"flexible array member\" (see discussion on #56877 for\n+// details).\n+\n+#[repr(C)]\n+pub struct Foo {\n+    x: u32\n+}\n+\n+#[repr(C)]\n+pub struct Middle {\n+    pub a: f32,\n+    pub foo: [Foo; 0],\n+    pub b: f32,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type TestMiddle = Middle;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+#[repr(C)]\n+pub struct Final {\n+    pub a: f32,\n+    pub b: f32,\n+    pub foo: [Foo; 0],\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type TestFinal = Final;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+fn main() { }"}, {"sha": "0d442606351875787fdaed1f50d6b0239272f3c5", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-c-struct.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-c-struct.stderr?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,14 @@\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:22:1\n+   |\n+LL | pub type TestMiddle = Middle;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-c-struct.rs:33:1\n+   |\n+LL | pub type TestFinal = Final;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4b429412aebfc2a9e63c25f38e05a6f12efd156d", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,73 @@\n+#![feature(rustc_attrs)]\n+\n+// Regression test for #56877. We want to ensure that the presence of\n+// `PhantomData` does not prevent `Bar` from being considered a\n+// homogeneous aggregate.\n+\n+#[repr(C)]\n+pub struct BaseCase {\n+    pub a: f32,\n+    pub b: f32,\n+}\n+\n+#[repr(C)]\n+pub struct WithPhantomData {\n+    pub a: f32,\n+    pub b: f32,\n+    pub _unit: std::marker::PhantomData<()>,\n+}\n+\n+pub struct EmptyRustStruct {\n+}\n+\n+#[repr(C)]\n+pub struct WithEmptyRustStruct {\n+    pub a: f32,\n+    pub b: f32,\n+    pub _unit: EmptyRustStruct,\n+}\n+\n+pub struct TransitivelyEmptyRustStruct {\n+    field: EmptyRustStruct,\n+    array: [u32; 0],\n+}\n+\n+#[repr(C)]\n+pub struct WithTransitivelyEmptyRustStruct {\n+    pub a: f32,\n+    pub b: f32,\n+    pub _unit: TransitivelyEmptyRustStruct,\n+}\n+\n+pub enum EmptyRustEnum {\n+    Dummy,\n+}\n+\n+#[repr(C)]\n+pub struct WithEmptyRustEnum {\n+    pub a: f32,\n+    pub b: f32,\n+    pub _unit: EmptyRustEnum,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test1 = BaseCase;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test2 = WithPhantomData;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test3 = WithEmptyRustStruct;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test4 = WithTransitivelyEmptyRustStruct;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+pub type Test5 = WithEmptyRustEnum;\n+//~^ ERROR homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+\n+fn main() { }"}, {"sha": "be04ba3e7f6cb7a3685cee5c956ea35969a6db84", "filename": "src/test/ui/layout/homogeneous-aggr-zero-sized-repr-rust.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhomogeneous-aggr-zero-sized-repr-rust.stderr?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,32 @@\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:54:1\n+   |\n+LL | pub type Test1 = BaseCase;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:58:1\n+   |\n+LL | pub type Test2 = WithPhantomData;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:62:1\n+   |\n+LL | pub type Test3 = WithEmptyRustStruct;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:66:1\n+   |\n+LL | pub type Test4 = WithTransitivelyEmptyRustStruct;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/homogeneous-aggr-zero-sized-repr-rust.rs:70:1\n+   |\n+LL | pub type Test5 = WithEmptyRustEnum;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "68b218249eb9a84a799dce33cb97ad3d91336bc7", "filename": "src/test/ui/layout/zero-sized-array-union.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,95 @@\n+#![feature(rustc_attrs)]\n+\n+// Various tests around the behavior of zero-sized arrays and\n+// unions. This matches the behavior of modern C compilers, though\n+// older compilers (and sometimes clang) treat `T[0]` as a \"flexible\n+// array member\". See more\n+// details in #56877.\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Empty { }\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Empty2 {\n+    e: Empty\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Empty3 {\n+    z: [f32; 0],\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Empty4 {\n+    e: Empty3\n+}\n+\n+#[repr(C)]\n+union U1 {\n+    s: Empty\n+}\n+\n+#[repr(C)]\n+union U2 {\n+    s: Empty2\n+}\n+\n+#[repr(C)]\n+union U3 {\n+    s: Empty3\n+}\n+\n+#[repr(C)]\n+union U4 {\n+    s: Empty4\n+}\n+\n+#[repr(C)]\n+struct Baz1 {\n+    x: f32,\n+    y: f32,\n+    u: U1,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+type TestBaz1 = Baz1;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+#[repr(C)]\n+struct Baz2 {\n+    x: f32,\n+    y: f32,\n+    u: U2,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+type TestBaz2 = Baz2;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+#[repr(C)]\n+struct Baz3 {\n+    x: f32,\n+    y: f32,\n+    u: U3,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+type TestBaz3 = Baz3;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+#[repr(C)]\n+struct Baz4 {\n+    x: f32,\n+    y: f32,\n+    u: U4,\n+}\n+\n+#[rustc_layout(homogeneous_aggregate)]\n+type TestBaz4 = Baz4;\n+//~^ ERROR homogeneous_aggregate: Homogeneous\n+\n+fn main() { }"}, {"sha": "1bb31aaf7b7b90cbd2790933971e20111895f64b", "filename": "src/test/ui/layout/zero-sized-array-union.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-union.stderr?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,26 @@\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/zero-sized-array-union.rs:59:1\n+   |\n+LL | type TestBaz1 = Baz1;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/zero-sized-array-union.rs:70:1\n+   |\n+LL | type TestBaz2 = Baz2;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/zero-sized-array-union.rs:81:1\n+   |\n+LL | type TestBaz3 = Baz3;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: homogeneous_aggregate: Homogeneous(Reg { kind: Float, size: Size { raw: 4 } })\n+  --> $DIR/zero-sized-array-union.rs:92:1\n+   |\n+LL | type TestBaz4 = Baz4;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "660e517c85a13d32aaf54fecb7a60b1e768a4764", "filename": "src/test/ui/parser/issue-32214.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -3,6 +3,10 @@ error: type parameters must be declared prior to associated type bindings\n    |\n LL | pub fn test<W, I: Trait<Item=(), W> >() {}\n    |                                  ^ must be declared prior to associated type bindings\n+help: move the type parameter prior to the first associated type binding\n+   |\n+LL | pub fn test<W, I: Trait<W, Item=()> >() {}\n+   |                         ^^       --\n \n error: aborting due to previous error\n "}, {"sha": "df6383b4fc2226b9bb384236fe61b89b5f5211ca", "filename": "src/test/ui/static/static-drop-scope.nll.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.nll.stderr?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -54,7 +54,19 @@ error[E0493]: destructors cannot be evaluated at compile-time\n LL |     (x, ()).1\n    |     ^^^^^^^ constant functions cannot evaluate destructors\n \n-error: aborting due to 8 previous errors\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/static-drop-scope.rs:31:34\n+   |\n+LL | const EARLY_DROP_C_OPTION: i32 = (Some(WithDtor), 0).1;\n+   |                                  ^^^^^^^^^^^^^^^^^^^ constants cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/static-drop-scope.rs:36:43\n+   |\n+LL | const EARLY_DROP_C_OPTION_CONSTANT: i32 = (HELPER, 0).1;\n+   |                                           ^^^^^^^^^^^ constants cannot evaluate destructors\n+\n+error: aborting due to 10 previous errors\n \n Some errors occurred: E0493, E0716.\n For more information about an error, try `rustc --explain E0493`."}, {"sha": "e5a9f2a40564419ec5da38a46e1b696bed7e8731", "filename": "src/test/ui/static/static-drop-scope.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -28,4 +28,12 @@ const fn const_drop2<T>(x: T) {\n     //~^ ERROR destructors cannot be evaluated at compile-time\n }\n \n+const EARLY_DROP_C_OPTION: i32 = (Some(WithDtor), 0).1;\n+//~^ ERROR destructors cannot be evaluated at compile-time\n+\n+const HELPER: Option<WithDtor> = Some(WithDtor);\n+\n+const EARLY_DROP_C_OPTION_CONSTANT: i32 = (HELPER, 0).1;\n+//~^ ERROR destructors cannot be evaluated at compile-time\n+\n fn main () {}"}, {"sha": "3e3032eb4fb60b4b6082b112538b60a73ccfc82c", "filename": "src/test/ui/static/static-drop-scope.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -54,7 +54,19 @@ error[E0493]: destructors cannot be evaluated at compile-time\n LL |     (x, ()).1\n    |     ^^^^^^^ constant functions cannot evaluate destructors\n \n-error: aborting due to 8 previous errors\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/static-drop-scope.rs:31:34\n+   |\n+LL | const EARLY_DROP_C_OPTION: i32 = (Some(WithDtor), 0).1;\n+   |                                  ^^^^^^^^^^^^^^^^^^^ constants cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/static-drop-scope.rs:36:43\n+   |\n+LL | const EARLY_DROP_C_OPTION_CONSTANT: i32 = (HELPER, 0).1;\n+   |                                           ^^^^^^^^^^^ constants cannot evaluate destructors\n+\n+error: aborting due to 10 previous errors\n \n Some errors occurred: E0493, E0597.\n For more information about an error, try `rustc --explain E0493`."}, {"sha": "fd10ba4350c4a4bb654c0bb1ef4752313df96b58", "filename": "src/test/ui/suggestions/suggest-move-types.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,85 @@\n+// ignore-tidy-linelength\n+\n+#![allow(warnings)]\n+\n+// This test verifies that the suggestion to move types before associated type bindings\n+// is correct.\n+\n+trait One<T> {\n+  type A;\n+}\n+\n+trait OneWithLifetime<'a, T> {\n+  type A;\n+}\n+\n+trait Three<T, U, V> {\n+  type A;\n+  type B;\n+  type C;\n+}\n+\n+trait ThreeWithLifetime<'a, 'b, 'c, T, U, V> {\n+  type A;\n+  type B;\n+  type C;\n+}\n+\n+struct A<T, M: One<A=(), T>> { //~ ERROR type parameters must be declared\n+    m: M,\n+    t: T,\n+}\n+\n+\n+struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n+//~^ ERROR generic arguments must declare lifetimes, types and associated type bindings in that order\n+    m: M,\n+    t: &'a T,\n+}\n+\n+struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> { //~ ERROR type parameters must be declared\n+    m: M,\n+    t: T,\n+    u: U,\n+    v: V,\n+}\n+\n+struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n+//~^ ERROR generic arguments must declare lifetimes, types and associated type bindings in that order\n+    m: M,\n+    t: &'a T,\n+    u: &'b U,\n+    v: &'c V,\n+}\n+\n+struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> { //~ ERROR type parameters must be declared\n+    m: M,\n+    t: T,\n+    u: U,\n+    v: V,\n+}\n+\n+struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n+//~^ ERROR generic arguments must declare lifetimes, types and associated type bindings in that order\n+    m: M,\n+    t: &'a T,\n+    u: &'b U,\n+    v: &'c V,\n+}\n+\n+struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> { //~ ERROR type parameters must be declared\n+    m: M,\n+    t: T,\n+    u: U,\n+    v: V,\n+}\n+\n+struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n+//~^ ERROR generic arguments must declare lifetimes, types and associated type bindings in that order\n+    m: M,\n+    t: &'a T,\n+    u: &'b U,\n+    v: &'c V,\n+}\n+\n+fn main() {}"}, {"sha": "3643d9a912455ea6a4ffeb1e9883fcb41e492839", "filename": "src/test/ui/suggestions/suggest-move-types.stderr", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d51aa8f3bca674a50eb7c6204deed6fb4dff80/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr?ref=37d51aa8f3bca674a50eb7c6204deed6fb4dff80", "patch": "@@ -0,0 +1,107 @@\n+error: type parameters must be declared prior to associated type bindings\n+  --> $DIR/suggest-move-types.rs:28:26\n+   |\n+LL | struct A<T, M: One<A=(), T>> { //~ ERROR type parameters must be declared\n+   |                          ^ must be declared prior to associated type bindings\n+help: move the type parameter prior to the first associated type binding\n+   |\n+LL | struct A<T, M: One<T, A=()>> { //~ ERROR type parameters must be declared\n+   |                    ^^    --\n+\n+error: generic arguments must declare lifetimes, types and associated type bindings in that order\n+  --> $DIR/suggest-move-types.rs:34:46\n+   |\n+LL | struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n+   |                                           ^  ^^ must be declared prior to type parameters\n+   |                                           |\n+   |                                           must be declared prior to associated type bindings\n+help: move the parameters\n+   |\n+LL | struct Al<'a, T, M: OneWithLifetime<'a, T, A=()>> {\n+   |                                     ^^^ ^^    --\n+\n+error: type parameters must be declared prior to associated type bindings\n+  --> $DIR/suggest-move-types.rs:40:46\n+   |\n+LL | struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> { //~ ERROR type parameters must be declared\n+   |                                              ^  ^  ^ must be declared prior to associated type bindings\n+   |                                              |  |\n+   |                                              |  must be declared prior to associated type bindings\n+   |                                              must be declared prior to associated type bindings\n+help: move the type parameters prior to the first associated type binding\n+   |\n+LL | struct B<T, U, V, M: Three<T, U, V, A=(), B=(), C=()>> { //~ ERROR type parameters must be declared\n+   |                            ^^ ^^ ^^                --\n+\n+error: generic arguments must declare lifetimes, types and associated type bindings in that order\n+  --> $DIR/suggest-move-types.rs:47:80\n+   |\n+LL | struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n+   |                                                                       ^  ^  ^  ^^  ^^  ^^ must be declared prior to type parameters\n+   |                                                                       |  |  |  |   |\n+   |                                                                       |  |  |  |   must be declared prior to type parameters\n+   |                                                                       |  |  |  must be declared prior to type parameters\n+   |                                                                       |  |  must be declared prior to associated type bindings\n+   |                                                                       |  must be declared prior to associated type bindings\n+   |                                                                       must be declared prior to associated type bindings\n+help: move the parameters\n+   |\n+LL | struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<'a, 'b, 'c, T, U, V, A=(), B=(), C=()>> {\n+   |                                                     ^^^ ^^^ ^^^ ^^ ^^ ^^                --\n+\n+error: type parameters must be declared prior to associated type bindings\n+  --> $DIR/suggest-move-types.rs:55:49\n+   |\n+LL | struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> { //~ ERROR type parameters must be declared\n+   |                                                 ^  ^ must be declared prior to associated type bindings\n+   |                                                 |\n+   |                                                 must be declared prior to associated type bindings\n+help: move the type parameters prior to the first associated type binding\n+   |\n+LL | struct C<T, U, V, M: Three<T, U, V, A=(), B=(), C=()>> { //~ ERROR type parameters must be declared\n+   |                               ^^ ^^                --\n+\n+error: generic arguments must declare lifetimes, types and associated type bindings in that order\n+  --> $DIR/suggest-move-types.rs:62:56\n+   |\n+LL | struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n+   |                                                        ^^                    ^  ^^  ^  ^^ must be declared prior to type parameters\n+   |                                                        |                     |  |   |\n+   |                                                        |                     |  |   must be declared prior to associated type bindings\n+   |                                                        |                     |  must be declared prior to type parameters\n+   |                                                        |                     must be declared prior to associated type bindings\n+   |                                                        must be declared prior to type parameters\n+help: move the parameters\n+   |\n+LL | struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<'a, 'b, 'c, T, U, V, A=(), B=(), C=()>> {\n+   |                                                     ^^^ ^^^ ^^^ -- ^^ ^^                --\n+\n+error: type parameters must be declared prior to associated type bindings\n+  --> $DIR/suggest-move-types.rs:70:43\n+   |\n+LL | struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> { //~ ERROR type parameters must be declared\n+   |                                           ^        ^ must be declared prior to associated type bindings\n+   |                                           |\n+   |                                           must be declared prior to associated type bindings\n+help: move the type parameters prior to the first associated type binding\n+   |\n+LL | struct D<T, U, V, M: Three<T, U, V, A=(), B=(), C=()>> { //~ ERROR type parameters must be declared\n+   |                               ^^ ^^          --    --\n+\n+error: generic arguments must declare lifetimes, types and associated type bindings in that order\n+  --> $DIR/suggest-move-types.rs:77:56\n+   |\n+LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n+   |                                                        ^^              ^  ^^        ^  ^^ must be declared prior to type parameters\n+   |                                                        |               |  |         |\n+   |                                                        |               |  |         must be declared prior to associated type bindings\n+   |                                                        |               |  must be declared prior to type parameters\n+   |                                                        |               must be declared prior to associated type bindings\n+   |                                                        must be declared prior to type parameters\n+help: move the parameters\n+   |\n+LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<'a, 'b, 'c, T, U, V, A=(), B=(), C=()>> {\n+   |                                                     ^^^ ^^^ ^^^ -- ^^ ^^          --    --\n+\n+error: aborting due to 8 previous errors\n+"}]}