{"sha": "cc1d696cb9df64b1da9aeebcc47717d84ec649f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMWQ2OTZjYjlkZjY0YjFkYTlhZWViY2M0NzcxN2Q4NGVjNjQ5Zjg=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2015-12-14T13:30:09Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2015-12-14T13:30:09Z"}, "message": "fix fallout from CC improvements", "tree": {"sha": "101258685b49d68fac6e109d279577d7b2e8bea3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/101258685b49d68fac6e109d279577d7b2e8bea3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc1d696cb9df64b1da9aeebcc47717d84ec649f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc1d696cb9df64b1da9aeebcc47717d84ec649f8", "html_url": "https://github.com/rust-lang/rust/commit/cc1d696cb9df64b1da9aeebcc47717d84ec649f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc1d696cb9df64b1da9aeebcc47717d84ec649f8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "902c7d832b6f355414632ca55dc7c7017fde5250", "url": "https://api.github.com/repos/rust-lang/rust/commits/902c7d832b6f355414632ca55dc7c7017fde5250", "html_url": "https://github.com/rust-lang/rust/commit/902c7d832b6f355414632ca55dc7c7017fde5250"}], "stats": {"total": 39, "additions": 16, "deletions": 23}, "files": [{"sha": "8295e18617259e3b85e3d79777931fa6ce0b4a12", "filename": "src/loops.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cc1d696cb9df64b1da9aeebcc47717d84ec649f8/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc1d696cb9df64b1da9aeebcc47717d84ec649f8/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=cc1d696cb9df64b1da9aeebcc47717d84ec649f8", "patch": "@@ -147,14 +147,8 @@ impl LateLintPass for LoopsPass {\n \n             // extract the expression from the first statement (if any) in a block\n             let inner_stmt_expr = extract_expr_from_first_stmt(block);\n-            // extract the first expression (if any) from the block\n-            let inner_expr = extract_first_expr(block);\n-            let (extracted, collect_expr) = match inner_stmt_expr {\n-                Some(_) => (inner_stmt_expr, true),     // check if an expression exists in the first statement\n-                None => (inner_expr, false),    // if not, let's go for the first expression in the block\n-            };\n-\n-            if let Some(inner) = extracted {\n+            // or extract the first expression (if any) from the block\n+            if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(block)) {\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // collect the remaining statements below the match\n                     let mut other_stuff = block.stmts\n@@ -163,10 +157,11 @@ impl LateLintPass for LoopsPass {\n                                   .map(|stmt| {\n                                       format!(\"{}\", snippet(cx, stmt.span, \"..\"))\n                                   }).collect::<Vec<String>>();\n-                    if collect_expr {           // if we have a statement which has a match,\n-                        match block.expr {      // then collect the expression (without semicolon) below it\n-                            Some(ref expr) => other_stuff.push(format!(\"{}\", snippet(cx, expr.span, \"..\"))),\n-                            None => (),\n+                    if inner_stmt_expr.is_some() {\n+                        // if we have a statement which has a match,\n+                        if let Some(ref expr) = block.expr {\n+                            // then collect the expression (without semicolon) below it\n+                            other_stuff.push(format!(\"{}\", snippet(cx, expr.span, \"..\")));\n                         }\n                     }\n \n@@ -180,12 +175,12 @@ impl LateLintPass for LoopsPass {\n                             is_break_expr(&arms[1].body)\n                         {\n                             if in_external_macro(cx, expr.span) { return; }\n-                            let loop_body = match inner_stmt_expr {\n+                            let loop_body = if inner_stmt_expr.is_some() {\n                                 // FIXME: should probably be an ellipsis\n                                 // tabbing and newline is probably a bad idea, especially for large blocks\n-                                Some(_) => Cow::Owned(format!(\"{{\\n    {}\\n}}\", other_stuff.join(\"\\n    \"))),\n-                                None => expr_block(cx, &arms[0].body,\n-                                                   Some(other_stuff.join(\"\\n    \")), \"..\"),\n+                                Cow::Owned(format!(\"{{\\n    {}\\n}}\", other_stuff.join(\"\\n    \")))\n+                            } else {\n+                                expr_block(cx, &arms[0].body, Some(other_stuff.join(\"\\n    \")), \"..\")\n                             };\n                             span_help_and_lint(cx, WHILE_LET_LOOP, expr.span,\n                                                \"this loop could be written as a `while let` loop\","}, {"sha": "460893d93ab1f18c5348ebf16a4e4cc02500b363", "filename": "src/matches.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc1d696cb9df64b1da9aeebcc47717d84ec649f8/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc1d696cb9df64b1da9aeebcc47717d84ec649f8/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=cc1d696cb9df64b1da9aeebcc47717d84ec649f8", "patch": "@@ -102,13 +102,11 @@ impl LateLintPass for MatchPass {\n                 if arms.len() == 2 && arms[0].pats.len() == 1 { // no guards\n                     let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n                         if let ExprLit(ref lit) = arm_bool.node {\n-                            if let LitBool(val) = lit.node {\n-                                if val {\n-                                    Some((&*arms[0].body, &*arms[1].body))\n-                                } else {\n-                                    Some((&*arms[1].body, &*arms[0].body))\n-                                }\n-                            } else { None }\n+                            match lit.node {\n+                                LitBool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                                LitBool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                                _ => None,\n+                            }\n                         } else { None }\n                     } else { None };\n                     if let Some((ref true_expr, ref false_expr)) = exprs {"}]}