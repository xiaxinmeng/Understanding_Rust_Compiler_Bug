{"sha": "10d628dbd06ec71956c7849c24822dde8710c2bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZDYyOGRiZDA2ZWM3MTk1NmM3ODQ5YzI0ODIyZGRlODcxMGMyYmQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-19T20:28:43Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-19T20:28:43Z"}, "message": "Add a type slot to the AST", "tree": {"sha": "5635a8259d226cdd3a3d6dfd1e429aa8ddc73c28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5635a8259d226cdd3a3d6dfd1e429aa8ddc73c28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10d628dbd06ec71956c7849c24822dde8710c2bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10d628dbd06ec71956c7849c24822dde8710c2bd", "html_url": "https://github.com/rust-lang/rust/commit/10d628dbd06ec71956c7849c24822dde8710c2bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10d628dbd06ec71956c7849c24822dde8710c2bd/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e497fe981b03d44591d87c234c63b69e62ecf747", "url": "https://api.github.com/repos/rust-lang/rust/commits/e497fe981b03d44591d87c234c63b69e62ecf747", "html_url": "https://github.com/rust-lang/rust/commit/e497fe981b03d44591d87c234c63b69e62ecf747"}], "stats": {"total": 191, "additions": 98, "deletions": 93}, "files": [{"sha": "acf64c1b18302d965f50ed9a381fcfcfffb310c2", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/10d628dbd06ec71956c7849c24822dde8710c2bd/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d628dbd06ec71956c7849c24822dde8710c2bd/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=10d628dbd06ec71956c7849c24822dde8710c2bd", "patch": "@@ -259,14 +259,15 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n \n     // FIXME: can only remove this sort of thing when both typestate and\n     // alt-exhaustive-match checking are co-operating.\n-    let ast.expr_ ex = ast.expr_lit(@spanned(lo, lo, ast.lit_nil));\n+    auto lit = @spanned(lo, lo, ast.lit_nil);\n+    let ast.expr_ ex = ast.expr_lit(lit, none[@ast.ty]);\n \n     alt (p.peek()) {\n \n         case (token.IDENT(?i)) {\n             auto n = parse_name(p, i);\n             hi = n.span;\n-            ex = ast.expr_name(n, none[ast.def]);\n+            ex = ast.expr_name(n, none[ast.def], none[@ast.ty]);\n         }\n \n         case (token.LPAREN) {\n@@ -285,7 +286,7 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n                                                       some(token.COMMA),\n                                                       pf, p);\n             hi = es.span;\n-            ex = ast.expr_tup(es.node);\n+            ex = ast.expr_tup(es.node, none[@ast.ty]);\n         }\n \n         case (token.VEC) {\n@@ -296,7 +297,7 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n                                            some(token.COMMA),\n                                            pf, p);\n             hi = es.span;\n-            ex = ast.expr_vec(es.node);\n+            ex = ast.expr_vec(es.node, none[@ast.ty]);\n         }\n \n         case (token.REC) {\n@@ -315,14 +316,14 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n                                                      some(token.COMMA),\n                                                      pf, p);\n             hi = es.span;\n-            ex = ast.expr_rec(es.node);\n+            ex = ast.expr_rec(es.node, none[@ast.ty]);\n         }\n \n         case (_) {\n             alt (parse_lit(p)) {\n                 case (some[ast.lit](?lit)) {\n                     hi = lit.span;\n-                    ex = ast.expr_lit(@lit);\n+                    ex = ast.expr_lit(@lit, none[@ast.ty]);\n                 }\n                 case (none[ast.lit]) {\n                     p.err(\"expecting expression\");\n@@ -347,13 +348,15 @@ io fn parse_path_expr(parser p) -> @ast.expr {\n                     case (token.IDENT(?i)) {\n                         hi = p.get_span();\n                         p.bump();\n-                        e = @spanned(lo, hi, ast.expr_field(e, i));\n+                        auto e_ = ast.expr_field(e, i, none[@ast.ty]);\n+                        e = @spanned(lo, hi, e_);\n                     }\n \n                     case (token.LPAREN) {\n                         auto ix = parse_bottom_expr(p);\n                         hi = ix.span;\n-                        e = @spanned(lo, hi, ast.expr_index(e, ix));\n+                        auto e_ = ast.expr_index(e, ix, none[@ast.ty]);\n+                        e = @spanned(lo, hi, e_);\n                     }\n                 }\n             }\n@@ -372,22 +375,23 @@ io fn parse_prefix_expr(parser p) -> @ast.expr {\n \n     // FIXME: can only remove this sort of thing when both typestate and\n     // alt-exhaustive-match checking are co-operating.\n-    let ast.expr_ ex = ast.expr_lit(@spanned(lo, lo, ast.lit_nil));\n+    auto lit = @spanned(lo, lo, ast.lit_nil);\n+    let ast.expr_ ex = ast.expr_lit(lit, none[@ast.ty]);\n \n     alt (p.peek()) {\n \n         case (token.NOT) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span;\n-            ex = ast.expr_unary(ast.not, e);\n+            ex = ast.expr_unary(ast.not, e, none[@ast.ty]);\n         }\n \n         case (token.TILDE) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span;\n-            ex = ast.expr_unary(ast.bitnot, e);\n+            ex = ast.expr_unary(ast.bitnot, e, none[@ast.ty]);\n         }\n \n         case (token.BINOP(?b)) {\n@@ -396,14 +400,14 @@ io fn parse_prefix_expr(parser p) -> @ast.expr {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span;\n-                    ex = ast.expr_unary(ast.neg, e);\n+                    ex = ast.expr_unary(ast.neg, e, none[@ast.ty]);\n                 }\n \n                 case (token.STAR) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span;\n-                    ex = ast.expr_unary(ast.deref, e);\n+                    ex = ast.expr_unary(ast.deref, e, none[@ast.ty]);\n                 }\n \n                 case (_) {\n@@ -416,7 +420,7 @@ io fn parse_prefix_expr(parser p) -> @ast.expr {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span;\n-            ex = ast.expr_unary(ast.box, e);\n+            ex = ast.expr_unary(ast.box, e, none[@ast.ty]);\n         }\n \n         case (_) {\n@@ -443,7 +447,8 @@ io fn parse_binops(parser p,\n                         p.bump();\n                         auto rhs = sub(p);\n                         hi = rhs.span;\n-                        auto exp = ast.expr_binary(pair._1, e, rhs);\n+                        auto exp = ast.expr_binary(pair._1, e, rhs,\n+                                                   none[@ast.ty]);\n                         e = @spanned(lo, hi, exp);\n                         more = true;\n                     }\n@@ -469,7 +474,7 @@ io fn parse_binary_exprs(parser p,\n                 p.bump();\n                 auto rhs = sub(p);\n                 hi = rhs.span;\n-                auto exp = ast.expr_binary(pair._1, e, rhs);\n+                auto exp = ast.expr_binary(pair._1, e, rhs, none[@ast.ty]);\n                 e = @spanned(lo, hi, exp);\n                 more = true;\n             }\n@@ -578,15 +583,15 @@ io fn parse_if_expr(parser p) -> @ast.expr {\n             hi = eblk.span;\n         }\n     }\n-    ret @spanned(lo, hi, ast.expr_if(cond, thn, els));\n+    ret @spanned(lo, hi, ast.expr_if(cond, thn, els, none[@ast.ty]));\n }\n \n io fn parse_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LBRACE) {\n             auto blk = parse_block(p);\n             ret @spanned(blk.span, blk.span,\n-                         ast.expr_block(blk));\n+                         ast.expr_block(blk, none[@ast.ty]));\n         }\n         case (token.IF) {\n             ret parse_if_expr(p);"}, {"sha": "81bbffeb3ee05db78eea1a6d99f412c48881a93e", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/10d628dbd06ec71956c7849c24822dde8710c2bd/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d628dbd06ec71956c7849c24822dde8710c2bd/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=10d628dbd06ec71956c7849c24822dde8710c2bd", "patch": "@@ -106,7 +106,7 @@ type ast_fold[ENV] =\n          &ast.local local) -> @decl)              fold_decl_local,\n \n      (fn(&ENV e, &span sp,\n-         @item item, option[@ty] ty) -> @decl)    fold_decl_item,\n+         @item item) -> @decl)                    fold_decl_item,\n \n \n      // Stmt folds.\n@@ -278,49 +278,49 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n     }\n \n     alt (e.node) {\n-        case (ast.expr_vec(?es)) {\n+        case (ast.expr_vec(?es, ?t)) {\n             auto ees = fold_exprs(env_, fld, es);\n-            ret fld.fold_expr_vec(env_, e.span, ees);\n+            ret fld.fold_expr_vec(env_, e.span, ees, t);\n         }\n \n-        case (ast.expr_tup(?es)) {\n+        case (ast.expr_tup(?es, ?t)) {\n             let vec[tup(bool,@expr)] entries = vec();\n             for (tup(bool,@expr) entry in es) {\n                 entries += fold_tup_entry[ENV](env, fld, entry);\n             }\n-            ret fld.fold_expr_tup(env_, e.span, entries);\n+            ret fld.fold_expr_tup(env_, e.span, entries, t);\n         }\n \n-        case (ast.expr_rec(?es)) {\n+        case (ast.expr_rec(?es, ?t)) {\n             let vec[tup(ident,@expr)] entries = vec();\n             for (tup(ident,@expr) entry in es) {\n                 entries += fold_rec_entry(env, fld, entry);\n             }\n-            ret fld.fold_expr_rec(env_, e.span, entries);\n+            ret fld.fold_expr_rec(env_, e.span, entries, t);\n         }\n \n-        case (ast.expr_call(?f, ?args)) {\n+        case (ast.expr_call(?f, ?args, ?t)) {\n             auto ff = fold_expr(env_, fld, f);\n             auto aargs = fold_exprs(env_, fld, args);\n-            ret fld.fold_expr_call(env_, e.span, ff, aargs);\n+            ret fld.fold_expr_call(env_, e.span, ff, aargs, t);\n         }\n \n-        case (ast.expr_binary(?op, ?a, ?b)) {\n+        case (ast.expr_binary(?op, ?a, ?b, ?t)) {\n             auto aa = fold_expr(env_, fld, a);\n             auto bb = fold_expr(env_, fld, b);\n-            ret fld.fold_expr_binary(env_, e.span, op, aa, bb);\n+            ret fld.fold_expr_binary(env_, e.span, op, aa, bb, t);\n         }\n \n-        case (ast.expr_unary(?op, ?a)) {\n+        case (ast.expr_unary(?op, ?a, ?t)) {\n             auto aa = fold_expr(env_, fld, a);\n-            ret fld.fold_expr_unary(env_, e.span, op, a);\n+            ret fld.fold_expr_unary(env_, e.span, op, a, t);\n         }\n \n-        case (ast.expr_lit(?lit)) {\n-            ret fld.fold_expr_lit(env_, e.span, lit);\n+        case (ast.expr_lit(?lit, ?t)) {\n+            ret fld.fold_expr_lit(env_, e.span, lit, t);\n         }\n \n-        case (ast.expr_if(?cnd, ?thn, ?els)) {\n+        case (ast.expr_if(?cnd, ?thn, ?els, ?t)) {\n             auto ccnd = fold_expr(env_, fld, cnd);\n             auto tthn = fold_block(env_, fld, thn);\n             auto eels = none[block];\n@@ -329,34 +329,34 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n                     eels = some(fold_block(env_, fld, b));\n                 }\n             }\n-            ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels);\n+            ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels, t);\n         }\n \n-        case (ast.expr_block(?b)) {\n+        case (ast.expr_block(?b, ?t)) {\n             auto bb = fold_block(env_, fld, b);\n-            ret fld.fold_expr_block(env_, e.span, bb);\n+            ret fld.fold_expr_block(env_, e.span, bb, t);\n         }\n \n-        case (ast.expr_assign(?lhs, ?rhs)) {\n+        case (ast.expr_assign(?lhs, ?rhs, ?t)) {\n             auto llhs = fold_expr(env_, fld, lhs);\n             auto rrhs = fold_expr(env_, fld, rhs);\n-            ret fld.fold_expr_assign(env_, e.span, llhs, rrhs);\n+            ret fld.fold_expr_assign(env_, e.span, llhs, rrhs, t);\n         }\n \n-        case (ast.expr_field(?e, ?i)) {\n+        case (ast.expr_field(?e, ?i, ?t)) {\n             auto ee = fold_expr(env_, fld, e);\n-            ret fld.fold_expr_field(env_, e.span, ee, i);\n+            ret fld.fold_expr_field(env_, e.span, ee, i, t);\n         }\n \n-        case (ast.expr_index(?e, ?ix)) {\n+        case (ast.expr_index(?e, ?ix, ?t)) {\n             auto ee = fold_expr(env_, fld, e);\n             auto iix = fold_expr(env_, fld, ix);\n-            ret fld.fold_expr_index(env_, e.span, ee, iix);\n+            ret fld.fold_expr_index(env_, e.span, ee, iix, t);\n         }\n \n-        case (ast.expr_name(?n, ?r)) {\n+        case (ast.expr_name(?n, ?r, ?t)) {\n             auto n_ = fold_name(env_, fld, n);\n-            ret fld.fold_expr_name(env_, e.span, n, r);\n+            ret fld.fold_expr_name(env_, e.span, n, r, t);\n         }\n     }\n \n@@ -547,74 +547,74 @@ fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n // Expr identities.\n \n fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es,\n-                               option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_vec(es, ty));\n+                               option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_vec(es, t));\n }\n \n fn identity_fold_expr_tup[ENV](&ENV env, &span sp, vec[tup(bool, @expr)] es,\n-                               option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_tup(es, ty));\n+                               option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_tup(es, t));\n }\n \n fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n-                               vec[tup(ident,@expr)] fields, option[@ty] ty)\n+                               vec[tup(ident,@expr)] fields, option[@ty] t)\n     -> @expr {\n-    ret @respan(sp, ast.expr_rec(fields, ty));\n+    ret @respan(sp, ast.expr_rec(fields, t));\n }\n \n fn identity_fold_expr_call[ENV](&ENV env, &span sp, @expr f,\n-                                vec[@expr] args, option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_call(f, args, ty));\n+                                vec[@expr] args, option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_call(f, args, t));\n }\n \n fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast.binop b,\n                                   @expr lhs, @expr rhs,\n-                                  option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_binary(b, lhs, rhs, ty));\n+                                  option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_binary(b, lhs, rhs, t));\n }\n \n fn identity_fold_expr_unary[ENV](&ENV env, &span sp,\n-                                 ast.unop u, @expr e, option[@ty] ty)\n+                                 ast.unop u, @expr e, option[@ty] t)\n         -> @expr {\n-    ret @respan(sp, ast.expr_unary(u, e, ty));\n+    ret @respan(sp, ast.expr_unary(u, e, t));\n }\n \n fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit,\n-                               option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_lit(lit, ty));\n+                               option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_lit(lit, t));\n }\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               @expr cond, &block thn,\n-                              &option[block] els, option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_if(cond, thn, els, ty));\n+                              &option[block] els, option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_if(cond, thn, els, t));\n }\n \n fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk,\n-                                 option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_block(blk, ty));\n+                                 option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_block(blk, t));\n }\n \n fn identity_fold_expr_assign[ENV](&ENV env, &span sp,\n-                                  @expr lhs, @expr rhs, option[@ty] ty)\n+                                  @expr lhs, @expr rhs, option[@ty] t)\n         -> @expr {\n-    ret @respan(sp, ast.expr_assign(lhs, rhs, ty));\n+    ret @respan(sp, ast.expr_assign(lhs, rhs, t));\n }\n \n fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n-                                 @expr e, ident i, option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_field(e, i, ty));\n+                                 @expr e, ident i, option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_field(e, i, t));\n }\n \n fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n-                                 @expr e, @expr ix, option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_index(e, ix, ty));\n+                                 @expr e, @expr ix, option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_index(e, ix, t));\n }\n \n fn identity_fold_expr_name[ENV](&ENV env, &span sp,\n                                 &name n, &option[def] d,\n-                                option[@ty] ty) -> @expr {\n-    ret @respan(sp, ast.expr_name(n, d, ty));\n+                                option[@ty] t) -> @expr {\n+    ret @respan(sp, ast.expr_name(n, d, t));\n }\n \n \n@@ -745,19 +745,19 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_ty_tup     = bind identity_fold_ty_tup[ENV](_,_,_),\n          fold_ty_path    = bind identity_fold_ty_path[ENV](_,_,_,_),\n \n-         fold_expr_vec    = bind identity_fold_expr_vec[ENV](_,_,_),\n-         fold_expr_tup    = bind identity_fold_expr_tup[ENV](_,_,_),\n-         fold_expr_rec    = bind identity_fold_expr_rec[ENV](_,_,_),\n-         fold_expr_call   = bind identity_fold_expr_call[ENV](_,_,_,_),\n-         fold_expr_binary = bind identity_fold_expr_binary[ENV](_,_,_,_,_),\n-         fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_),\n-         fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_),\n-         fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_),\n-         fold_expr_block  = bind identity_fold_expr_block[ENV](_,_,_),\n-         fold_expr_assign = bind identity_fold_expr_assign[ENV](_,_,_,_),\n-         fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_),\n-         fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_),\n-         fold_expr_name   = bind identity_fold_expr_name[ENV](_,_,_,_),\n+         fold_expr_vec    = bind identity_fold_expr_vec[ENV](_,_,_,_),\n+         fold_expr_tup    = bind identity_fold_expr_tup[ENV](_,_,_,_),\n+         fold_expr_rec    = bind identity_fold_expr_rec[ENV](_,_,_,_),\n+         fold_expr_call   = bind identity_fold_expr_call[ENV](_,_,_,_,_),\n+         fold_expr_binary = bind identity_fold_expr_binary[ENV](_,_,_,_,_,_),\n+         fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_,_),\n+         fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_,_),\n+         fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_,_),\n+         fold_expr_block  = bind identity_fold_expr_block[ENV](_,_,_,_),\n+         fold_expr_assign = bind identity_fold_expr_assign[ENV](_,_,_,_,_),\n+         fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_,_),\n+         fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_,_),\n+         fold_expr_name   = bind identity_fold_expr_name[ENV](_,_,_,_,_),\n \n          fold_decl_local  = bind identity_fold_decl_local[ENV](_,_,_),\n          fold_decl_item   = bind identity_fold_decl_item[ENV](_,_,_),"}, {"sha": "08b2e588596ca2e0aa79258fa6b867b8e6fb0a77", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10d628dbd06ec71956c7849c24822dde8710c2bd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d628dbd06ec71956c7849c24822dde8710c2bd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=10d628dbd06ec71956c7849c24822dde8710c2bd", "patch": "@@ -101,7 +101,7 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n }\n \n fn fold_expr_name(&env e, &span sp, &ast.name n,\n-                  &option[def] d) -> @ast.expr {\n+                  &option[def] d, option[@ast.ty] t) -> @ast.expr {\n \n     auto d_ = lookup_name(e, n.node.ident);\n \n@@ -114,7 +114,7 @@ fn fold_expr_name(&env e, &span sp, &ast.name n,\n         }\n     }\n \n-    ret @fold.respan[ast.expr_](sp, ast.expr_name(n, d_));\n+    ret @fold.respan[ast.expr_](sp, ast.expr_name(n, d_, t));\n }\n \n fn update_env_for_crate(&env e, @ast.crate c) -> env {\n@@ -131,7 +131,7 @@ fn update_env_for_block(&env e, &ast.block b) -> env {\n \n fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n-    fld = @rec( fold_expr_name = bind fold_expr_name(_,_,_,_),\n+    fld = @rec( fold_expr_name = bind fold_expr_name(_,_,_,_,_),\n                 update_env_for_crate = bind update_env_for_crate(_,_),\n                 update_env_for_item = bind update_env_for_item(_,_),\n                 update_env_for_block = bind update_env_for_block(_,_)"}, {"sha": "dd7ac62e96872b25e50c8b472f357459ef5b5062", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10d628dbd06ec71956c7849c24822dde8710c2bd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d628dbd06ec71956c7849c24822dde8710c2bd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=10d628dbd06ec71956c7849c24822dde8710c2bd", "patch": "@@ -546,23 +546,23 @@ fn trans_if(@block_ctxt cx, &ast.expr cond,\n \n fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n     alt (e.node) {\n-        case (ast.expr_lit(?lit)) {\n+        case (ast.expr_lit(?lit, _)) {\n             ret trans_lit(cx, *lit);\n         }\n \n-        case (ast.expr_unary(?op, ?x)) {\n+        case (ast.expr_unary(?op, ?x, _)) {\n             ret trans_unary(cx, op, *x);\n         }\n \n-        case (ast.expr_binary(?op, ?x, ?y)) {\n+        case (ast.expr_binary(?op, ?x, ?y, _)) {\n             ret trans_binary(cx, op, *x, *y);\n         }\n \n-        case (ast.expr_if(?cond, ?thn, ?els)) {\n+        case (ast.expr_if(?cond, ?thn, ?els, _)) {\n             ret trans_if(cx, *cond, thn, els);\n         }\n \n-        case (ast.expr_block(?blk)) {\n+        case (ast.expr_block(?blk, _)) {\n             auto sub_cx = new_empty_block_ctxt(cx.fcx);\n             auto next_cx = new_extension_block_ctxt(cx);\n             auto sub = trans_block(sub_cx, blk);\n@@ -579,7 +579,7 @@ fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n \n fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n     alt (e.node) {\n-        case (ast.expr_lit(?lit)) {\n+        case (ast.expr_lit(?lit, _)) {\n             alt (lit.node) {\n                 case (ast.lit_str(_)) {\n                     auto sub = trans_expr(cx, e);"}]}