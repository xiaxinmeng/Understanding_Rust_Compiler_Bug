{"sha": "8752aeed3a7c8c14dbea790733ed9937ac005efb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NTJhZWVkM2E3YzhjMTRkYmVhNzkwNzMzZWQ5OTM3YWMwMDVlZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-18T00:44:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-18T00:44:58Z"}, "message": "Auto merge of #45899 - eddyb:meta-race, r=alexcrichton\n\nrustc_trans: atomically write .rmeta outputs to avoid races.\n\nFixes #45841 in a similar vein to how LLVM writes archives: write a temporary file and then rename it.\n\nr? @alexcrichton", "tree": {"sha": "c92c537c81a756ae63f486d12b9c92c9f70c6505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c92c537c81a756ae63f486d12b9c92c9f70c6505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8752aeed3a7c8c14dbea790733ed9937ac005efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8752aeed3a7c8c14dbea790733ed9937ac005efb", "html_url": "https://github.com/rust-lang/rust/commit/8752aeed3a7c8c14dbea790733ed9937ac005efb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8752aeed3a7c8c14dbea790733ed9937ac005efb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18d8acf41d21c19eedcb732d161ae943c438fd57", "url": "https://api.github.com/repos/rust-lang/rust/commits/18d8acf41d21c19eedcb732d161ae943c438fd57", "html_url": "https://github.com/rust-lang/rust/commit/18d8acf41d21c19eedcb732d161ae943c438fd57"}, {"sha": "f5952804251be7ddafa9e9a511842bfda55a9d1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5952804251be7ddafa9e9a511842bfda55a9d1e", "html_url": "https://github.com/rust-lang/rust/commit/f5952804251be7ddafa9e9a511842bfda55a9d1e"}], "stats": {"total": 53, "additions": 35, "deletions": 18}, "files": [{"sha": "a67cc3399164a6b5f8a44b8150c679c18bc700eb", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8752aeed3a7c8c14dbea790733ed9937ac005efb/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752aeed3a7c8c14dbea790733ed9937ac005efb/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=8752aeed3a7c8c14dbea790733ed9937ac005efb", "patch": "@@ -262,19 +262,31 @@ fn link_binary_output(sess: &Session,\n         check_file_is_writeable(obj, sess);\n     }\n \n-    let tmpdir = match TempDir::new(\"rustc\") {\n-        Ok(tmpdir) => tmpdir,\n-        Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n-    };\n-\n     let mut out_filenames = vec![];\n \n     if outputs.outputs.contains_key(&OutputType::Metadata) {\n         let out_filename = filename_for_metadata(sess, crate_name, outputs);\n-        emit_metadata(sess, trans, &out_filename);\n+        // To avoid races with another rustc process scanning the output directory,\n+        // we need to write the file somewhere else and atomically move it to its\n+        // final destination, with a `fs::rename` call. In order for the rename to\n+        // always succeed, the temporary file needs to be on the same filesystem,\n+        // which is why we create it inside the output directory specifically.\n+        let metadata_tmpdir = match TempDir::new_in(out_filename.parent().unwrap(), \"rmeta\") {\n+            Ok(tmpdir) => tmpdir,\n+            Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n+        };\n+        let metadata = emit_metadata(sess, trans, &metadata_tmpdir);\n+        if let Err(e) = fs::rename(metadata, &out_filename) {\n+            sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+        }\n         out_filenames.push(out_filename);\n     }\n \n+    let tmpdir = match TempDir::new(\"rustc\") {\n+        Ok(tmpdir) => tmpdir,\n+        Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n+    };\n+\n     if outputs.outputs.should_trans() {\n         let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n         match crate_type {\n@@ -283,10 +295,10 @@ fn link_binary_output(sess: &Session,\n                           trans,\n                           RlibFlavor::Normal,\n                           &out_filename,\n-                          tmpdir.path()).build();\n+                          &tmpdir).build();\n             }\n             config::CrateTypeStaticlib => {\n-                link_staticlib(sess, trans, &out_filename, tmpdir.path());\n+                link_staticlib(sess, trans, &out_filename, &tmpdir);\n             }\n             _ => {\n                 link_natively(sess, crate_type, &out_filename, trans, tmpdir.path());\n@@ -321,14 +333,23 @@ fn archive_config<'a>(sess: &'a Session,\n     }\n }\n \n-fn emit_metadata<'a>(sess: &'a Session, trans: &CrateTranslation, out_filename: &Path) {\n-    let result = fs::File::create(out_filename).and_then(|mut f| {\n+/// We use a temp directory here to avoid races between concurrent rustc processes,\n+/// such as builds in the same directory using the same filename for metadata while\n+/// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n+/// directory being searched for `extern crate` (observing an incomplete file).\n+/// The returned path is the temporary file containing the complete metadata.\n+fn emit_metadata<'a>(sess: &'a Session, trans: &CrateTranslation, tmpdir: &TempDir)\n+                     -> PathBuf {\n+    let out_filename = tmpdir.path().join(METADATA_FILENAME);\n+    let result = fs::File::create(&out_filename).and_then(|mut f| {\n         f.write_all(&trans.metadata.raw_data)\n     });\n \n     if let Err(e) = result {\n         sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n     }\n+\n+    out_filename\n }\n \n enum RlibFlavor {\n@@ -346,7 +367,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                  trans: &CrateTranslation,\n                  flavor: RlibFlavor,\n                  out_filename: &Path,\n-                 tmpdir: &Path) -> ArchiveBuilder<'a> {\n+                 tmpdir: &TempDir) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib to {:?}\", out_filename);\n     let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n \n@@ -408,12 +429,8 @@ fn link_rlib<'a>(sess: &'a Session,\n     match flavor {\n         RlibFlavor::Normal => {\n             // Instead of putting the metadata in an object file section, rlibs\n-            // contain the metadata in a separate file. We use a temp directory\n-            // here so concurrent builds in the same directory don't try to use\n-            // the same filename for metadata (stomping over one another)\n-            let metadata = tmpdir.join(METADATA_FILENAME);\n-            emit_metadata(sess, trans, &metadata);\n-            ab.add_file(&metadata);\n+            // contain the metadata in a separate file.\n+            ab.add_file(&emit_metadata(sess, trans, tmpdir));\n \n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.\n@@ -457,7 +474,7 @@ fn link_rlib<'a>(sess: &'a Session,\n fn link_staticlib(sess: &Session,\n                   trans: &CrateTranslation,\n                   out_filename: &Path,\n-                  tempdir: &Path) {\n+                  tempdir: &TempDir) {\n     let mut ab = link_rlib(sess,\n                            trans,\n                            RlibFlavor::StaticlibBase,"}]}