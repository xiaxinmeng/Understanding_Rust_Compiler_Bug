{"sha": "fcb1523241cd682abc9a0622efe9877fbac53231", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYjE1MjMyNDFjZDY4MmFiYzlhMDYyMmVmZTk4NzdmYmFjNTMyMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-18T08:36:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-18T08:36:39Z"}, "message": "auto merge of #18885 : thestinger/rust/writer, r=aturon\n\nThe trait has an obvious, sensible implementation directly on vectors so\r\nthe MemWriter wrapper is unnecessary. This will halt the trend towards\r\nproviding all of the vector methods on MemWriter along with eliminating\r\nthe noise caused by conversions between the two types. It also provides\r\nthe useful default Writer methods on Vec<u8>.\r\n\r\nAfter the type is removed and code has been migrated, it would make\r\nsense to add a new implementation of MemWriter with seeking support. The\r\nsimple use cases can be covered with vectors alone, and ones with the\r\nneed for seeks can use a new MemWriter implementation.", "tree": {"sha": "4b7d4cbdd13006e15f2780a0dabb8f338ee7567f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b7d4cbdd13006e15f2780a0dabb8f338ee7567f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcb1523241cd682abc9a0622efe9877fbac53231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcb1523241cd682abc9a0622efe9877fbac53231", "html_url": "https://github.com/rust-lang/rust/commit/fcb1523241cd682abc9a0622efe9877fbac53231", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcb1523241cd682abc9a0622efe9877fbac53231/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f637f1c5a27b2d8023342163c6ac5c394d91c1fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f637f1c5a27b2d8023342163c6ac5c394d91c1fe", "html_url": "https://github.com/rust-lang/rust/commit/f637f1c5a27b2d8023342163c6ac5c394d91c1fe"}, {"sha": "85c2c2e38ce7c606fac1e9c8fa9d2ab71b35c8c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/85c2c2e38ce7c606fac1e9c8fa9d2ab71b35c8c8", "html_url": "https://github.com/rust-lang/rust/commit/85c2c2e38ce7c606fac1e9c8fa9d2ab71b35c8c8"}], "stats": {"total": 249, "additions": 120, "deletions": 129}, "files": [{"sha": "cd9ef215720f8011526ea791662beb5b41ee747c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -90,7 +90,7 @@ impl<'a> dot::GraphWalk<'a, Nd, Ed> for Edges {\n     fn target(&self, e: &Ed) -> Nd { let &(_,t) = e; t }\n }\n \n-# pub fn main() { use std::io::MemWriter; render_to(&mut MemWriter::new()) }\n+# pub fn main() { render_to(&mut Vec::new()) }\n ```\n \n ```no_run\n@@ -182,7 +182,7 @@ impl<'a> dot::GraphWalk<'a, Nd, Ed<'a>> for Graph {\n     fn target(&self, e: &Ed) -> Nd { let & &(_,t) = e; t }\n }\n \n-# pub fn main() { use std::io::MemWriter; render_to(&mut MemWriter::new()) }\n+# pub fn main() { render_to(&mut Vec::new()) }\n ```\n \n ```no_run\n@@ -246,7 +246,7 @@ impl<'a> dot::GraphWalk<'a, Nd<'a>, Ed<'a>> for Graph {\n     fn target(&self, e: &Ed<'a>) -> Nd<'a> { let &(_,t) = e; t }\n }\n \n-# pub fn main() { use std::io::MemWriter; render_to(&mut MemWriter::new()) }\n+# pub fn main() { render_to(&mut Vec::new()) }\n ```\n \n ```no_run\n@@ -274,7 +274,7 @@ pub fn main() {\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(globs)]\n+#![feature(globs, slicing_syntax)]\n \n pub use self::LabelText::*;\n \n@@ -553,7 +553,7 @@ mod tests {\n     use self::NodeLabels::*;\n     use super::{Id, LabelText, LabelStr, EscStr, Labeller};\n     use super::{Nodes, Edges, GraphWalk, render};\n-    use std::io::{MemWriter, BufReader, IoResult};\n+    use std::io::{BufReader, IoResult};\n     use std::str;\n \n     /// each node is an index in a vector in the graph.\n@@ -702,9 +702,9 @@ mod tests {\n     }\n \n     fn test_input(g: LabelledGraph) -> IoResult<String> {\n-        let mut writer = MemWriter::new();\n+        let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n-        let mut r = BufReader::new(writer.get_ref());\n+        let mut r = BufReader::new(writer[]);\n         r.read_to_string()\n     }\n \n@@ -809,15 +809,15 @@ r#\"digraph hasse_diagram {\n             \"branch2\",\n             \"afterward\"));\n \n-        let mut writer = MemWriter::new();\n+        let mut writer = Vec::new();\n \n         let g = LabelledGraphWithEscStrs::new(\n             \"syntax_tree\", labels,\n             vec!(edge(0, 1, \"then\"), edge(0, 2, \"else\"),\n                  edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n-        let mut r = BufReader::new(writer.get_ref());\n+        let mut r = BufReader::new(writer[]);\n         let r = r.read_to_string();\n \n         assert_eq!(r.unwrap().as_slice(),"}, {"sha": "c773467552a751386951ac25864fc617d5ef5002", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -122,7 +122,6 @@ use util::nodemap::NodeMap;\n use std::fmt;\n use std::io;\n use std::rc::Rc;\n-use std::str;\n use std::uint;\n use syntax::ast;\n use syntax::ast::*;\n@@ -742,7 +741,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     #[allow(unused_must_use)]\n     fn ln_str(&self, ln: LiveNode) -> String {\n-        let mut wr = io::MemWriter::new();\n+        let mut wr = Vec::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n             write!(wr, \"[ln({}) of kind {} reads\", ln.get(), self.ir.lnk(ln));\n@@ -751,7 +750,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.write_vars(wr, ln, |idx| self.users[idx].writer);\n             write!(wr, \"  precedes {}]\", self.successors[ln.get()].to_string());\n         }\n-        str::from_utf8(wr.unwrap().as_slice()).unwrap().to_string()\n+        String::from_utf8(wr).unwrap()\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {"}, {"sha": "d445da9d1340d96be2a344a23dd3aa5e83379e83", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -28,13 +28,13 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n                                       src.to_string(),\n                                       \"<stdin>\".to_string());\n \n-    let mut out = io::MemWriter::new();\n+    let mut out = Vec::new();\n     doit(&sess,\n          lexer::StringReader::new(&sess.span_diagnostic, fm),\n          class,\n          id,\n          &mut out).unwrap();\n-    String::from_utf8_lossy(out.unwrap().as_slice()).into_string()\n+    String::from_utf8_lossy(out[]).into_string()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "0ecb86d8bdd616fa394c636fe50922aa8fb31099", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -38,7 +38,7 @@ use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::{Occupied, Vacant};\n use std::fmt;\n use std::io::fs::PathExtensions;\n-use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n+use std::io::{fs, File, BufferedWriter, BufferedReader};\n use std::io;\n use std::str;\n use std::string::String;\n@@ -420,7 +420,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n     }\n \n     // Collect the index into a string\n-    let mut w = MemWriter::new();\n+    let mut w = Vec::new();\n     try!(write!(&mut w, r#\"searchIndex['{}'] = {{\"items\":[\"#, krate.name));\n \n     let mut lastpath = \"\".to_string();\n@@ -463,7 +463,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n \n     try!(write!(&mut w, \"]}};\"));\n \n-    Ok(String::from_utf8(w.unwrap()).unwrap())\n+    Ok(String::from_utf8(w).unwrap())\n }\n \n fn write_shared(cx: &Context,"}, {"sha": "e33895bb640bd076d6287e8fb1fb2f4fe5d169e2", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -28,7 +28,7 @@ extern crate \"test\" as testing;\n #[phase(plugin, link)] extern crate log;\n \n use std::io;\n-use std::io::{File, MemWriter};\n+use std::io::File;\n use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n use serialize::{json, Decodable, Encodable};\n@@ -467,12 +467,12 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n     let crate_json_str = {\n-        let mut w = MemWriter::new();\n+        let mut w = Vec::new();\n         {\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        String::from_utf8(w.unwrap()).unwrap()\n+        String::from_utf8(w).unwrap()\n     };\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,"}, {"sha": "2968c53de9aba4b291125811334efb9f4936dbad", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -206,7 +206,6 @@ use self::InternalStackElement::*;\n use std;\n use std::collections::{HashMap, TreeMap};\n use std::{char, f64, fmt, io, num, str};\n-use std::io::MemWriter;\n use std::mem::{swap, transmute};\n use std::num::{Float, FPNaN, FPInfinite, Int};\n use std::str::{FromStr, ScalarValue};\n@@ -412,14 +411,14 @@ impl<'a> Encoder<'a> {\n     /// Encode the specified struct into a json [u8]\n     pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(object: &T) -> Vec<u8>  {\n         //Serialize the object in a string using a writer\n-        let mut m = MemWriter::new();\n+        let mut m = Vec::new();\n         // FIXME(14302) remove the transmute and unsafe block.\n         unsafe {\n             let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n-            // MemWriter never Errs\n+            // Vec<u8> never Errs\n             let _ = object.encode(transmute(&mut encoder));\n         }\n-        m.unwrap()\n+        m\n     }\n }\n \n@@ -578,13 +577,13 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         if idx != 0 { try!(write!(self.writer, \",\")) }\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n-        let mut buf = MemWriter::new();\n+        let mut buf = Vec::new();\n         // FIXME(14302) remove the transmute and unsafe block.\n         unsafe {\n             let mut check_encoder = Encoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf.get_ref()).unwrap();\n+        let out = str::from_utf8(buf[]).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -839,13 +838,13 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         try!(spaces(self.writer, self.curr_indent));\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n-        let mut buf = MemWriter::new();\n+        let mut buf = Vec::new();\n         // FIXME(14302) remove the transmute and unsafe block.\n         unsafe {\n             let mut check_encoder = PrettyEncoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf.get_ref()).unwrap();\n+        let out = str::from_utf8(buf[]).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -892,9 +891,9 @@ impl Json {\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> string::String {\n-        let mut s = MemWriter::new();\n+        let mut s = Vec::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        string::String::from_utf8(s.unwrap()).unwrap()\n+        string::String::from_utf8(s).unwrap()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -2659,12 +2658,11 @@ mod tests {\n     }\n \n     fn with_str_writer(f: |&mut io::Writer|) -> string::String {\n-        use std::io::MemWriter;\n         use std::str;\n \n-        let mut m = MemWriter::new();\n+        let mut m = Vec::new();\n         f(&mut m as &mut io::Writer);\n-        str::from_utf8(m.unwrap().as_slice()).unwrap().to_string()\n+        string::String::from_utf8(m).unwrap()\n     }\n \n     #[test]\n@@ -3286,17 +3284,15 @@ mod tests {\n     fn test_encode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n         use std::io::Writer;\n-        use std::io::MemWriter;\n         use std::collections::HashMap;\n         let mut hm: HashMap<uint, bool> = HashMap::new();\n         hm.insert(1, true);\n-        let mut mem_buf = MemWriter::new();\n+        let mut mem_buf = Vec::new();\n         {\n             let mut encoder = Encoder::new(&mut mem_buf as &mut io::Writer);\n             hm.encode(&mut encoder).unwrap();\n         }\n-        let bytes = mem_buf.unwrap();\n-        let json_str = from_utf8(bytes.as_slice()).unwrap();\n+        let json_str = from_utf8(mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3307,17 +3303,15 @@ mod tests {\n     fn test_prettyencode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n         use std::io::Writer;\n-        use std::io::MemWriter;\n         use std::collections::HashMap;\n         let mut hm: HashMap<uint, bool> = HashMap::new();\n         hm.insert(1, true);\n-        let mut mem_buf = MemWriter::new();\n+        let mut mem_buf = Vec::new();\n         {\n             let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n             hm.encode(&mut encoder).unwrap()\n         }\n-        let bytes = mem_buf.unwrap();\n-        let json_str = from_utf8(bytes.as_slice()).unwrap();\n+        let json_str = from_utf8(mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3327,7 +3321,6 @@ mod tests {\n     #[test]\n     fn test_prettyencoder_indent_level_param() {\n         use std::str::from_utf8;\n-        use std::io::MemWriter;\n         use std::collections::TreeMap;\n \n         let mut tree = TreeMap::new();\n@@ -3354,15 +3347,14 @@ mod tests {\n \n         // Test up to 4 spaces of indents (more?)\n         for i in range(0, 4u) {\n-            let mut writer = MemWriter::new();\n+            let mut writer = Vec::new();\n             {\n                 let ref mut encoder = PrettyEncoder::new(&mut writer);\n                 encoder.set_indent(i);\n                 json.encode(encoder).unwrap();\n             }\n \n-            let bytes = writer.unwrap();\n-            let printed = from_utf8(bytes.as_slice()).unwrap();\n+            let printed = from_utf8(writer[]).unwrap();\n \n             // Check for indents at each line\n             let lines: Vec<&str> = printed.lines().collect();"}, {"sha": "e140ddba723d22f341bd8a027800fe1788a6f4b9", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -256,7 +256,7 @@ actually invoking the `write` function defined in this module. Example usage is:\n # #![allow(unused_must_use)]\n use std::io;\n \n-let mut w = io::MemWriter::new();\n+let mut w = Vec::new();\n write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n ```\n \n@@ -415,6 +415,7 @@ use io::Writer;\n use io;\n use result::{Ok, Err};\n use string;\n+use vec::Vec;\n \n pub use core::fmt::{Formatter, Result, FormatWriter, rt};\n pub use core::fmt::{Show, Bool, Char, Signed, Unsigned, Octal, Binary};\n@@ -443,10 +444,10 @@ pub use core::fmt::{argument, argumentstr, argumentuint};\n /// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n-pub fn format(args: &Arguments) -> string::String{\n-    let mut output = io::MemWriter::new();\n-    let _ = write!(&mut output, \"{}\", args);\n-    string::String::from_utf8(output.unwrap()).unwrap()\n+pub fn format(args: &Arguments) -> string::String {\n+    let mut output = Vec::new();\n+    let _ = write!(&mut output as &mut Writer, \"{}\", args);\n+    string::String::from_utf8(output).unwrap()\n }\n \n impl<'a> Writer for Formatter<'a> {"}, {"sha": "25e85f33aa56512ab90bcb70cf52066e7f15439b", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -374,7 +374,7 @@ mod test {\n     use prelude::*;\n     use super::*;\n     use super::super::{IoResult, EndOfFile};\n-    use super::super::mem::{MemReader, MemWriter, BufReader};\n+    use super::super::mem::{MemReader, BufReader};\n     use self::test::Bencher;\n     use str::StrPrelude;\n \n@@ -447,57 +447,57 @@ mod test {\n \n     #[test]\n     fn test_buffered_writer() {\n-        let inner = MemWriter::new();\n+        let inner = Vec::new();\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n         writer.write(&[0, 1]).unwrap();\n         let b: &[_] = &[];\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n \n         writer.write(&[2]).unwrap();\n         let b: &[_] = &[0, 1];\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n \n         writer.write(&[3]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n \n         writer.flush().unwrap();\n         let a: &[_] = &[0, 1, 2, 3];\n-        assert_eq!(a, writer.get_ref().get_ref());\n+        assert_eq!(a, writer.get_ref()[]);\n \n         writer.write(&[4]).unwrap();\n         writer.write(&[5]).unwrap();\n-        assert_eq!(a, writer.get_ref().get_ref());\n+        assert_eq!(a, writer.get_ref()[]);\n \n         writer.write(&[6]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5];\n         assert_eq!(a,\n-                   writer.get_ref().get_ref());\n+                   writer.get_ref()[]);\n \n         writer.write(&[7, 8]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n         assert_eq!(a,\n-                   writer.get_ref().get_ref());\n+                   writer.get_ref()[]);\n \n         writer.write(&[9, 10, 11]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n         assert_eq!(a,\n-                   writer.get_ref().get_ref());\n+                   writer.get_ref()[]);\n \n         writer.flush().unwrap();\n         assert_eq!(a,\n-                   writer.get_ref().get_ref());\n+                   writer.get_ref()[]);\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n-        let mut w = BufferedWriter::with_capacity(3, MemWriter::new());\n+        let mut w = BufferedWriter::with_capacity(3, Vec::new());\n         w.write(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n-        assert_eq!(a, w.get_ref().get_ref());\n+        assert_eq!(a, w.get_ref()[]);\n         let w = w.unwrap();\n         let a: &[_] = &[0, 1];\n-        assert_eq!(a, w.get_ref());\n+        assert_eq!(a, w[]);\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -536,24 +536,24 @@ mod test {\n \n     #[test]\n     fn test_line_buffer() {\n-        let mut writer = LineBufferedWriter::new(MemWriter::new());\n+        let mut writer = LineBufferedWriter::new(Vec::new());\n         writer.write(&[0]).unwrap();\n         let b: &[_] = &[];\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n         writer.write(&[1]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1];\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n         writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n         writer.write(&[3, b'\\n']).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n-        assert_eq!(writer.get_ref().get_ref(), b);\n+        assert_eq!(writer.get_ref()[], b);\n     }\n \n     #[test]"}, {"sha": "4b2ffb4d559c443da994b00354900029e79f97bf", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -171,7 +171,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n mod test {\n     use prelude::*;\n     use io;\n-    use io::{MemReader, MemWriter, BytesReader};\n+    use io::{MemReader, BytesReader};\n \n     struct InitialZeroByteReader {\n         count: int,\n@@ -397,12 +397,12 @@ mod test {\n     fn test_read_write_le_mem() {\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n \n-        let mut writer = MemWriter::new();\n+        let mut writer = Vec::new();\n         for i in uints.iter() {\n             writer.write_le_u64(*i).unwrap();\n         }\n \n-        let mut reader = MemReader::new(writer.unwrap());\n+        let mut reader = MemReader::new(writer);\n         for i in uints.iter() {\n             assert!(reader.read_le_u64().unwrap() == *i);\n         }\n@@ -413,12 +413,12 @@ mod test {\n     fn test_read_write_be() {\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n \n-        let mut writer = MemWriter::new();\n+        let mut writer = Vec::new();\n         for i in uints.iter() {\n             writer.write_be_u64(*i).unwrap();\n         }\n \n-        let mut reader = MemReader::new(writer.unwrap());\n+        let mut reader = MemReader::new(writer);\n         for i in uints.iter() {\n             assert!(reader.read_be_u64().unwrap() == *i);\n         }\n@@ -428,12 +428,12 @@ mod test {\n     fn test_read_be_int_n() {\n         let ints = [::i32::MIN, -123456, -42, -5, 0, 1, ::i32::MAX];\n \n-        let mut writer = MemWriter::new();\n+        let mut writer = Vec::new();\n         for i in ints.iter() {\n             writer.write_be_i32(*i).unwrap();\n         }\n \n-        let mut reader = MemReader::new(writer.unwrap());\n+        let mut reader = MemReader::new(writer);\n         for i in ints.iter() {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n@@ -446,10 +446,10 @@ mod test {\n         //big-endian floating-point 8.1250\n         let buf = vec![0x41, 0x02, 0x00, 0x00];\n \n-        let mut writer = MemWriter::new();\n+        let mut writer = Vec::new();\n         writer.write(buf.as_slice()).unwrap();\n \n-        let mut reader = MemReader::new(writer.unwrap());\n+        let mut reader = MemReader::new(writer);\n         let f = reader.read_be_f32().unwrap();\n         assert!(f == 8.1250);\n     }\n@@ -458,11 +458,11 @@ mod test {\n     fn test_read_write_f32() {\n         let f:f32 = 8.1250;\n \n-        let mut writer = MemWriter::new();\n+        let mut writer = Vec::new();\n         writer.write_be_f32(f).unwrap();\n         writer.write_le_f32(f).unwrap();\n \n-        let mut reader = MemReader::new(writer.unwrap());\n+        let mut reader = MemReader::new(writer);\n         assert!(reader.read_be_f32().unwrap() == 8.1250);\n         assert!(reader.read_le_f32().unwrap() == 8.1250);\n     }"}, {"sha": "21de6c2013d2c8e667cfc61eeffcc84c3f628f5e", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -12,6 +12,8 @@\n \n //! Readers and Writers for in-memory buffers\n \n+#![allow(deprecated)]\n+\n use cmp::min;\n use option::None;\n use result::{Err, Ok};\n@@ -41,6 +43,14 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n     }\n }\n \n+impl Writer for Vec<u8> {\n+    #[inline]\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.push_all(buf);\n+        Ok(())\n+    }\n+}\n+\n /// Writes to an owned, growable byte vector\n ///\n /// # Example\n@@ -54,6 +64,7 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n ///\n /// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n /// ```\n+#[deprecated = \"use the Vec<u8> Writer implementation directly\"]\n #[deriving(Clone)]\n pub struct MemWriter {\n     buf: Vec<u8>,"}, {"sha": "82bfa3c4e80ffed571f2ed4408df31cf1c6a42cd", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -1297,9 +1297,9 @@ impl<'a> Writer for &'a mut Writer+'a {\n /// # fn process_input<R: Reader>(r: R) {}\n /// # fn foo () {\n /// use std::io::util::TeeReader;\n-/// use std::io::{stdin, MemWriter, ByRefWriter};\n+/// use std::io::{stdin, ByRefWriter};\n ///\n-/// let mut output = MemWriter::new();\n+/// let mut output = Vec::new();\n ///\n /// {\n ///     // Don't give ownership of 'output' to the 'tee'. Instead we keep a\n@@ -1308,7 +1308,7 @@ impl<'a> Writer for &'a mut Writer+'a {\n ///     process_input(tee);\n /// }\n ///\n-/// println!(\"input processed: {}\", output.unwrap());\n+/// println!(\"input processed: {}\", output);\n /// # }\n /// ```\n pub struct RefWriter<'a, W:'a> {"}, {"sha": "305bcf9ecbc9cf9194d95f8b917b53ebf60801cd", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -84,15 +84,15 @@ mod test {\n \n     #[test]\n     fn test_option_writer() {\n-        let mut writer: io::IoResult<MemWriter> = Ok(MemWriter::new());\n+        let mut writer: io::IoResult<Vec<u8>> = Ok(Vec::new());\n         writer.write(&[0, 1, 2]).unwrap();\n         writer.flush().unwrap();\n-        assert_eq!(writer.unwrap().unwrap(), vec!(0, 1, 2));\n+        assert_eq!(writer.unwrap(), vec!(0, 1, 2));\n     }\n \n     #[test]\n     fn test_option_writer_error() {\n-        let mut writer: io::IoResult<MemWriter> =\n+        let mut writer: io::IoResult<Vec<u8>> =\n             Err(io::standard_error(io::EndOfFile));\n \n         match writer.write(&[0, 0, 0]) {"}, {"sha": "4d491beb87ba3727b2c9379c3bf1c8ef24fbf0ab", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -265,7 +265,7 @@ impl<T: Iterator<u8>> Reader for IterReader<T> {\n \n #[cfg(test)]\n mod test {\n-    use io::{MemReader, MemWriter, BufReader, ByRefReader};\n+    use io::{MemReader, BufReader, ByRefReader};\n     use io;\n     use boxed::Box;\n     use super::*;\n@@ -371,18 +371,18 @@ mod test {\n     #[test]\n     fn test_tee_reader() {\n         let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n-                                   MemWriter::new());\n+                                   Vec::new());\n         assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n         let (_, w) = r.unwrap();\n-        assert_eq!(vec!(0, 1, 2), w.unwrap());\n+        assert_eq!(vec!(0, 1, 2), w);\n     }\n \n     #[test]\n     fn test_copy() {\n         let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n-        let mut w = MemWriter::new();\n+        let mut w = Vec::new();\n         copy(&mut r, &mut w).unwrap();\n-        assert_eq!(vec!(0, 1, 2, 3, 4), w.unwrap());\n+        assert_eq!(vec!(0, 1, 2, 3, 4), w);\n     }\n \n     #[test]"}, {"sha": "26e9e70dff3e8faa6b670906f857eb7ad659516b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -253,9 +253,8 @@ macro_rules! format(\n ///\n /// ```\n /// # #![allow(unused_must_use)]\n-/// use std::io::MemWriter;\n ///\n-/// let mut w = MemWriter::new();\n+/// let mut w = Vec::new();\n /// write!(&mut w, \"test\");\n /// write!(&mut w, \"formatted {}\", \"arguments\");\n /// ```"}, {"sha": "1938ac09c73555582fa8cedb9d093c8c8c50aa67", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -1009,12 +1009,10 @@ mod imp {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use io::MemWriter;\n-\n     macro_rules! t( ($a:expr, $b:expr) => ({\n-        let mut m = MemWriter::new();\n+        let mut m = Vec::new();\n         super::demangle(&mut m, $a).unwrap();\n-        assert_eq!(String::from_utf8(m.unwrap()).unwrap(), $b.to_string());\n+        assert_eq!(String::from_utf8(m).unwrap(), $b.to_string());\n     }) )\n \n     #[test]"}, {"sha": "0543b80f208b1073c7bb8d9f9ad92f77cb8ff654", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -33,7 +33,7 @@ use print::pp;\n use ptr::P;\n \n use std::ascii;\n-use std::io::{IoResult, MemWriter};\n+use std::io::IoResult;\n use std::io;\n use std::mem;\n \n@@ -169,17 +169,17 @@ impl<'a> State<'a> {\n \n pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n     use std::raw::TraitObject;\n-    let mut s = rust_printer(box MemWriter::new());\n+    let mut s = rust_printer(box Vec::new());\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n     let wr = unsafe {\n         // FIXME(pcwalton): A nasty function to extract the string from an `io::Writer`\n-        // that we \"know\" to be a `MemWriter` that works around the lack of checked\n+        // that we \"know\" to be a `Vec<u8>` that works around the lack of checked\n         // downcasts.\n         let obj: &TraitObject = mem::transmute(&s.s.out);\n-        mem::transmute::<*mut (), &MemWriter>(obj.data)\n+        mem::transmute::<*mut (), &Vec<u8>>(obj.data)\n     };\n-    String::from_utf8(wr.get_ref().to_vec()).unwrap()\n+    String::from_utf8(wr.clone()).unwrap()\n }\n \n pub fn binop_to_string(op: BinOpToken) -> &'static str {"}, {"sha": "d5d0e7aeb17367d2983609baf98d95955a01922e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -33,7 +33,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(asm, macro_rules, phase, globs)]\n+#![feature(asm, macro_rules, phase, globs, slicing_syntax)]\n \n extern crate getopts;\n extern crate regex;\n@@ -848,8 +848,6 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::IoR\n \n #[test]\n fn should_sort_failures_before_printing_them() {\n-    use std::io::MemWriter;\n-\n     let test_a = TestDesc {\n         name: StaticTestName(\"a\"),\n         ignore: false,\n@@ -864,7 +862,7 @@ fn should_sort_failures_before_printing_them() {\n \n     let mut st = ConsoleTestState {\n         log_out: None,\n-        out: Raw(MemWriter::new()),\n+        out: Raw(Vec::new()),\n         use_color: false,\n         total: 0u,\n         passed: 0u,\n@@ -878,7 +876,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures().unwrap();\n     let s = match st.out {\n-        Raw(ref m) => String::from_utf8_lossy(m.get_ref()),\n+        Raw(ref m) => String::from_utf8_lossy(m[]),\n         Pretty(_) => unreachable!()\n     };\n "}, {"sha": "ab6756ffce3cfecf217a3cf437f98a80866fb1bb", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -1027,10 +1027,9 @@ mod tests {\n     #[test]\n     fn test_boxplot_nonpositive() {\n         fn t(s: &Summary<f64>, expected: String) {\n-            use std::io::MemWriter;\n-            let mut m = MemWriter::new();\n+            let mut m = Vec::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();\n-            let out = String::from_utf8(m.unwrap()).unwrap();\n+            let out = String::from_utf8(m).unwrap();\n             assert_eq!(out, expected);\n         }\n "}, {"sha": "ed4fdc525729e820c3b7443f8ce675469646dcea", "filename": "src/test/compile-fail/variance-trait-matching-2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -10,22 +10,21 @@\n \n extern crate serialize;\n \n-use std::io::MemWriter;\n use std::io;\n use serialize::{Encodable, Encoder};\n \n pub fn buffer_encode<'a,\n                      T:Encodable<serialize::json::Encoder<'a>,io::IoError>>(\n                      to_encode_object: &T)\n                      -> Vec<u8> {\n-    let mut m = MemWriter::new();\n+    let mut m = Vec::new();\n     {\n         let mut encoder =\n             serialize::json::Encoder::new(&mut m as &mut io::Writer);\n         //~^ ERROR `m` does not live long enough\n         to_encode_object.encode(&mut encoder);\n     }\n-    m.unwrap()\n+    m\n }\n \n fn main() {}"}, {"sha": "3fc2ed5468a6e35b0e3c45c76b6dd1b193ab30ff", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -31,12 +31,11 @@ fn test_rbml<'a, 'b, A:\n     Encodable<EBWriter::Encoder<'a>> +\n     Decodable<EBReader::Decoder<'b>>\n >(a1: &A) {\n-    let mut wr = std::io::MemWriter::new();\n+    let mut wr = Vec::new();\n     let mut rbml_w = EBwriter::Encoder::new(&mut wr);\n     a1.encode(&mut rbml_w);\n-    let bytes = wr.get_ref();\n \n-    let d: serialize::rbml::Doc<'a> = EBDoc::new(bytes);\n+    let d: serialize::rbml::Doc<'a> = EBDoc::new(wr[]);\n     let mut decoder: EBReader::Decoder<'a> = EBreader::Decoder::new(d);\n     let a2: A = Decodable::decode(&mut decoder);\n     assert!(*a1 == a2);"}, {"sha": "75b8e39133105997fa6fefe330051ae7efb15bc3", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -10,7 +10,7 @@\n \n // no-pretty-expanded\n \n-#![allow(unused_must_use, dead_code)]\n+#![allow(unused_must_use, dead_code, deprecated)]\n #![feature(macro_rules)]\n \n use std::io::MemWriter;"}, {"sha": "a846f852694d336cdbe997dbcea08920c66c37e6", "filename": "src/test/run-pass/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -14,7 +14,6 @@\n extern crate serialize;\n \n use std::cell::{Cell, RefCell};\n-use std::io::MemWriter;\n use serialize::{Encodable, Decodable};\n use serialize::json;\n "}, {"sha": "021b609efe251ec9b519f1101a4ff591b074a700", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -19,7 +19,6 @@ extern crate rand;\n extern crate rbml;\n extern crate serialize;\n \n-use std::io::MemWriter;\n use rand::{random, Rand};\n use rbml;\n use rbml::Doc;\n@@ -59,10 +58,10 @@ struct G<T> {\n fn roundtrip<'a, T: Rand + Eq + Encodable<Encoder<'a>> +\n                     Decodable<Decoder<'a>>>() {\n     let obj: T = random();\n-    let mut w = MemWriter::new();\n+    let mut w = Vec::new();\n     let mut e = Encoder::new(&mut w);\n     obj.encode(&mut e);\n-    let doc = rbml::Doc::new(@w.get_ref());\n+    let doc = rbml::Doc::new(@w[]);\n     let mut dec = Decoder::new(doc);\n     let obj2 = Decodable::decode(&mut dec);\n     assert!(obj == obj2);"}, {"sha": "59f7eda41610c501c64a2deb5412787d9ccc46f8", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb1523241cd682abc9a0622efe9877fbac53231/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=fcb1523241cd682abc9a0622efe9877fbac53231", "patch": "@@ -16,9 +16,7 @@\n #![allow(unused_must_use)]\n \n use std::fmt;\n-use std::io::MemWriter;\n use std::io;\n-use std::str;\n \n struct A;\n struct B;\n@@ -161,7 +159,7 @@ pub fn main() {\n // Basic test to make sure that we can invoke the `write!` macro with an\n // io::Writer instance.\n fn test_write() {\n-    let mut buf = MemWriter::new();\n+    let mut buf = Vec::new();\n     write!(&mut buf as &mut io::Writer, \"{}\", 3i);\n     {\n         let w = &mut buf as &mut io::Writer;\n@@ -171,7 +169,7 @@ fn test_write() {\n         writeln!(w, \"{foo}\", foo=\"bar\");\n     }\n \n-    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_string();\n+    let s = String::from_utf8(buf).unwrap();\n     t!(s, \"34helloline\\nbar\\n\");\n }\n \n@@ -188,14 +186,14 @@ fn test_print() {\n // Just make sure that the macros are defined, there's not really a lot that we\n // can do with them just yet (to test the output)\n fn test_format_args() {\n-    let mut buf = MemWriter::new();\n+    let mut buf = Vec::new();\n     {\n         let w = &mut buf as &mut io::Writer;\n         format_args!(|args| { write!(w, \"{}\", args); }, \"{}\", 1i);\n         format_args!(|args| { write!(w, \"{}\", args); }, \"test\");\n         format_args!(|args| { write!(w, \"{}\", args); }, \"{test}\", test=3i);\n     }\n-    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_string();\n+    let s = String::from_utf8(buf).unwrap();\n     t!(s, \"1test3\");\n \n     let s = format_args!(fmt::format, \"hello {}\", \"world\");"}]}