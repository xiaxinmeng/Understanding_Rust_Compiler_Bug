{"sha": "924f24a6c46ae4e586abd6b79a026119855595da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNGYyNGE2YzQ2YWU0ZTU4NmFiZDZiNzlhMDI2MTE5ODU1NTk1ZGE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-24T17:26:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-24T17:26:43Z"}, "message": "Rollup merge of #49274 - oli-obk:slow_miri, r=michaelwoerister,eddyb\n\nRemove slow HashSet during miri stack frame creation\n\nfixes #49237\n\nprobably has a major impact on #48846\n\nr? @michaelwoerister\n\ncc @eddyb I know you kept telling me to use vectors instead of hash containers... Now I know why.", "tree": {"sha": "0904ce42e2e1fdfc8c3382fcfd3cad084cd6b786", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0904ce42e2e1fdfc8c3382fcfd3cad084cd6b786"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/924f24a6c46ae4e586abd6b79a026119855595da", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJatopTCRBK7hj4Ov3rIwAAdHIIAAVCRPjpSVvv6RA20Tr7quUx\nMkF7oUXK7fNGoaCuouaI+8TZbjJbEumrJMn0SFAQn25YukxC5mAKFj1qrh6oIoMw\ns4QEx6NNmf1QCNpDzCfi6IB8iZ/1e4p67nyH4vAx0hQCdFF/QR3dvwgfXcZnHYSy\nUO+E+y7qf9cWS32qLzukZ2h7TWshfDHjzreEGLlk+jNzPBugPJCPIe5FL17OMoyw\n/wCg95SEnYoKBE7Fhjs913ygaxlVF2zzRz2zu/QOV2pY0QS/Zl7e5z2vXLfW7Vn8\nL+V5Cgxn0Uc2h23bfqwoIJT/Uz/JQpeP6+ThKKQEic8TUDosqXffw41oXH/bHAY=\n=bUf4\n-----END PGP SIGNATURE-----\n", "payload": "tree 0904ce42e2e1fdfc8c3382fcfd3cad084cd6b786\nparent 2b2f91638f140aa5d5a889aff185aee964f0fe40\nparent f9019aee5bc2f84b69771dc4e2e0cfad5e053566\nauthor kennytm <kennytm@gmail.com> 1521912403 +0800\ncommitter GitHub <noreply@github.com> 1521912403 +0800\n\nRollup merge of #49274 - oli-obk:slow_miri, r=michaelwoerister,eddyb\n\nRemove slow HashSet during miri stack frame creation\n\nfixes #49237\n\nprobably has a major impact on #48846\n\nr? @michaelwoerister\n\ncc @eddyb I know you kept telling me to use vectors instead of hash containers... Now I know why.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/924f24a6c46ae4e586abd6b79a026119855595da", "html_url": "https://github.com/rust-lang/rust/commit/924f24a6c46ae4e586abd6b79a026119855595da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/924f24a6c46ae4e586abd6b79a026119855595da/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b2f91638f140aa5d5a889aff185aee964f0fe40", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b2f91638f140aa5d5a889aff185aee964f0fe40", "html_url": "https://github.com/rust-lang/rust/commit/2b2f91638f140aa5d5a889aff185aee964f0fe40"}, {"sha": "f9019aee5bc2f84b69771dc4e2e0cfad5e053566", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9019aee5bc2f84b69771dc4e2e0cfad5e053566", "html_url": "https://github.com/rust-lang/rust/commit/f9019aee5bc2f84b69771dc4e2e0cfad5e053566"}], "stats": {"total": 102, "additions": 44, "deletions": 58}, "files": [{"sha": "b8bfcd756cd231d711c9c5880e6af8a2947e9c0c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/924f24a6c46ae4e586abd6b79a026119855595da/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924f24a6c46ae4e586abd6b79a026119855595da/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=924f24a6c46ae4e586abd6b79a026119855595da", "patch": "@@ -1,22 +1,23 @@\n-use std::collections::HashSet;\n use std::fmt::Write;\n \n use rustc::hir::def_id::DefId;\n+use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::middle::const_val::{ConstVal, ErrKind};\n use rustc::mir;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::TyCtxtAt;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::middle::const_val::FrameInfo;\n use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n     GlobalId, Value, Pointer, PrimVal, PrimValKind,\n     EvalError, EvalResult, EvalErrorKind, MemoryPointer,\n };\n+use std::mem;\n \n use super::{Place, PlaceExtra, Memory,\n             HasMemory, MemoryKind,\n@@ -71,12 +72,12 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub return_place: Place,\n \n     /// The list of locals for this stack frame, stored in order as\n-    /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n+    /// `[return_ptr, arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `PrimVal` or refer to some part of an `Allocation`.\n     ///\n     /// Before being initialized, arguments are `Value::ByVal(PrimVal::Undef)` and other locals are `None`.\n-    pub locals: Vec<Option<Value>>,\n+    pub locals: IndexVec<mir::Local, Option<Value>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -383,39 +384,29 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n-        /// Return the set of locals that have a storage annotation anywhere\n-        fn collect_storage_annotations<'mir, 'tcx>(mir: &'mir mir::Mir<'tcx>) -> HashSet<mir::Local> {\n-            use rustc::mir::StatementKind::*;\n-\n-            let mut set = HashSet::new();\n-            for block in mir.basic_blocks() {\n-                for stmt in block.statements.iter() {\n-                    match stmt.kind {\n-                        StorageLive(local) |\n-                        StorageDead(local) => {\n-                            set.insert(local);\n+        let locals = if mir.local_decls.len() > 1 {\n+            let mut locals = IndexVec::from_elem(Some(Value::ByVal(PrimVal::Undef)), &mir.local_decls);\n+            match self.tcx.describe_def(instance.def_id()) {\n+                // statics and constants don't have `Storage*` statements, no need to look for them\n+                Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n+                _ => {\n+                    trace!(\"push_stack_frame: {:?}: num_bbs: {}\", span, mir.basic_blocks().len());\n+                    for block in mir.basic_blocks() {\n+                        for stmt in block.statements.iter() {\n+                            use rustc::mir::StatementKind::{StorageDead, StorageLive};\n+                            match stmt.kind {\n+                                StorageLive(local) |\n+                                StorageDead(local) => locals[local] = None,\n+                                _ => {}\n+                            }\n                         }\n-                        _ => {}\n                     }\n-                }\n-            }\n-            set\n-        }\n-\n-        // Subtract 1 because `local_decls` includes the ReturnMemoryPointer, but we don't store a local\n-        // `Value` for that.\n-        let num_locals = mir.local_decls.len() - 1;\n-\n-        let locals = {\n-            let annotated_locals = collect_storage_annotations(mir);\n-            let mut locals = vec![None; num_locals];\n-            for i in 0..num_locals {\n-                let local = mir::Local::new(i + 1);\n-                if !annotated_locals.contains(&local) {\n-                    locals[i] = Some(Value::ByVal(PrimVal::Undef));\n-                }\n+                },\n             }\n             locals\n+        } else {\n+            // don't allocate at all for trivial constants\n+            IndexVec::new()\n         };\n \n         self.stack.push(Frame {\n@@ -973,8 +964,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n         let new_place = match place {\n             Place::Local { frame, local } => {\n-                // -1 since we don't store the return value\n-                match self.stack[frame].locals[local.index() - 1] {\n+                match self.stack[frame].locals[local] {\n                     None => return err!(DeadLocal),\n                     Some(Value::ByRef(ptr, align)) => {\n                         Place::Ptr {\n@@ -988,7 +978,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let layout = self.layout_of(ty)?;\n                         let ptr = self.alloc_ptr(ty)?;\n-                        self.stack[frame].locals[local.index() - 1] =\n+                        self.stack[frame].locals[local] =\n                             Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n                         let place = Place::from_ptr(ptr, layout.align);\n                         self.write_value(ValTy { value: val, ty }, place)?;\n@@ -1702,13 +1692,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n     pub fn get_local(&self, local: mir::Local) -> EvalResult<'tcx, Value> {\n-        // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        self.locals[local.index() - 1].ok_or(EvalErrorKind::DeadLocal.into())\n+        self.locals[local].ok_or(EvalErrorKind::DeadLocal.into())\n     }\n \n     fn set_local(&mut self, local: mir::Local, value: Value) -> EvalResult<'tcx> {\n-        // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        match self.locals[local.index() - 1] {\n+        match self.locals[local] {\n             None => err!(DeadLocal),\n             Some(ref mut local) => {\n                 *local = value;\n@@ -1717,20 +1705,17 @@ impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n         }\n     }\n \n-    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn storage_live(&mut self, local: mir::Local) -> Option<Value> {\n         trace!(\"{:?} is now live\", local);\n \n-        let old = self.locals[local.index() - 1];\n-        self.locals[local.index() - 1] = Some(Value::ByVal(PrimVal::Undef)); // StorageLive *always* kills the value that's currently stored\n-        return Ok(old);\n+        // StorageLive *always* kills the value that's currently stored\n+        mem::replace(&mut self.locals[local], Some(Value::ByVal(PrimVal::Undef)))\n     }\n \n     /// Returns the old value of the local\n-    pub fn storage_dead(&mut self, local: mir::Local) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn storage_dead(&mut self, local: mir::Local) -> Option<Value> {\n         trace!(\"{:?} is now dead\", local);\n \n-        let old = self.locals[local.index() - 1];\n-        self.locals[local.index() - 1] = None;\n-        return Ok(old);\n+        self.locals[local].take()\n     }\n }"}, {"sha": "4026f52e9620dd3a6cc2691c19a51fe083a6fb68", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/924f24a6c46ae4e586abd6b79a026119855595da/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924f24a6c46ae4e586abd6b79a026119855595da/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=924f24a6c46ae4e586abd6b79a026119855595da", "patch": "@@ -1,12 +1,13 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n-use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n+use std::collections::{btree_map, BTreeMap, VecDeque};\n use std::{ptr, io};\n \n use rustc::ty::Instance;\n use rustc::ty::maps::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout};\n use syntax::ast::Mutability;\n \n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, Value, Pointer,\n                             EvalResult, PrimVal, EvalErrorKind};\n \n@@ -33,15 +34,15 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub data: M::MemoryData,\n \n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    alloc_kind: HashMap<AllocId, MemoryKind<M::MemoryKinds>>,\n+    alloc_kind: FxHashMap<AllocId, MemoryKind<M::MemoryKinds>>,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<AllocId, Allocation>,\n+    alloc_map: FxHashMap<AllocId, Allocation>,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     ///\n     /// Stores statics while they are being processed, before they are interned and thus frozen\n-    uninitialized_statics: HashMap<AllocId, Allocation>,\n+    uninitialized_statics: FxHashMap<AllocId, Allocation>,\n \n     /// The current stack frame.  Used to check accesses against locks.\n     pub cur_frame: usize,\n@@ -53,9 +54,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n-            alloc_kind: HashMap::new(),\n-            alloc_map: HashMap::new(),\n-            uninitialized_statics: HashMap::new(),\n+            alloc_kind: FxHashMap::default(),\n+            alloc_map: FxHashMap::default(),\n+            uninitialized_statics: FxHashMap::default(),\n             tcx,\n             cur_frame: usize::max_value(),\n         }\n@@ -338,7 +339,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         allocs.sort();\n         allocs.dedup();\n         let mut allocs_to_print = VecDeque::from(allocs);\n-        let mut allocs_seen = HashSet::new();\n+        let mut allocs_seen = FxHashSet::default();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n             let mut msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));"}, {"sha": "a22572ec687c3cf05a90177aa0b41d96cb585143", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/924f24a6c46ae4e586abd6b79a026119855595da/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924f24a6c46ae4e586abd6b79a026119855595da/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=924f24a6c46ae4e586abd6b79a026119855595da", "patch": "@@ -69,13 +69,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             // Mark locals as alive\n             StorageLive(local) => {\n-                let old_val = self.frame_mut().storage_live(local)?;\n+                let old_val = self.frame_mut().storage_live(local);\n                 self.deallocate_local(old_val)?;\n             }\n \n             // Mark locals as dead\n             StorageDead(local) => {\n-                let old_val = self.frame_mut().storage_dead(local)?;\n+                let old_val = self.frame_mut().storage_dead(local);\n                 self.deallocate_local(old_val)?;\n             }\n "}]}