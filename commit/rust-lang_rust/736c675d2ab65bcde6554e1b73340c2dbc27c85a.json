{"sha": "736c675d2ab65bcde6554e1b73340c2dbc27c85a", "node_id": "C_kwDOAAsO6NoAKDczNmM2NzVkMmFiNjViY2RlNjU1NGUxYjczMzQwYzJkYmMyN2M4NWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-21T04:42:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-21T04:42:43Z"}, "message": "Auto merge of #103454 - camsteffen:remove-conservatively-uninhabited, r=oli-obk\n\nFactor out `conservative_is_privately_uninhabited`\n\nAfter #102660 there is no more need for `conservative_is_privately_uninhabited`.\n\nr? `@oli-obk`", "tree": {"sha": "8c93d81e4b31ef0013c2e9042e38c12878ff7cb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c93d81e4b31ef0013c2e9042e38c12878ff7cb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/736c675d2ab65bcde6554e1b73340c2dbc27c85a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/736c675d2ab65bcde6554e1b73340c2dbc27c85a", "html_url": "https://github.com/rust-lang/rust/commit/736c675d2ab65bcde6554e1b73340c2dbc27c85a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/736c675d2ab65bcde6554e1b73340c2dbc27c85a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccde51a912e89478a649dc9e64b5584a5971f75f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccde51a912e89478a649dc9e64b5584a5971f75f", "html_url": "https://github.com/rust-lang/rust/commit/ccde51a912e89478a649dc9e64b5584a5971f75f"}, {"sha": "cc8dddbac9e04f125c7e81dbe9fb6a01990e8b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc8dddbac9e04f125c7e81dbe9fb6a01990e8b25", "html_url": "https://github.com/rust-lang/rust/commit/cc8dddbac9e04f125c7e81dbe9fb6a01990e8b25"}], "stats": {"total": 262, "additions": 99, "deletions": 163}, "files": [{"sha": "9b6c7d27c791b23923b3fd3c47a0cb779f2062bf", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -1564,10 +1564,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             None => {\n-                if !self\n-                    .tcx()\n-                    .conservative_is_privately_uninhabited(self.param_env.and(sig.output()))\n-                {\n+                if !sig.output().is_privately_uninhabited(self.tcx(), self.param_env) {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n             }"}, {"sha": "a78b294181c72c3afb279008d73a2e0db89303d5", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n         let ty = self.tcx.erase_regions(ty);\n         let m = self.tcx.parent_module(expr.hir_id).to_def_id();\n         let param_env = self.tcx.param_env(m.expect_local());\n-        if self.tcx.is_ty_uninhabited_from(m, ty, param_env) {\n+        if !ty.is_inhabited_from(self.tcx, m, param_env) {\n             // This function will not return. We model this fact as an infinite loop.\n             self.drop_ranges.add_control_edge(self.expr_index + 1, self.expr_index + 1);\n         }"}, {"sha": "bd3589c6c43a95889baf983240f4a3154931f0dc", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -542,10 +542,10 @@ fn check_must_not_suspend_ty<'tcx>(\n     data: SuspendCheckData<'_, 'tcx>,\n ) -> bool {\n     if ty.is_unit()\n-    // FIXME: should this check `is_ty_uninhabited_from`. This query is not available in this stage\n+    // FIXME: should this check `Ty::is_inhabited_from`. This query is not available in this stage\n     // of typeck (before ReVar and RePlaceholder are removed), but may remove noise, like in\n     // `must_use`\n-    // || fcx.tcx.is_ty_uninhabited_from(fcx.tcx.parent_module(hir_id).to_def_id(), ty, fcx.param_env)\n+    // || !ty.is_inhabited_from(fcx.tcx, fcx.tcx.parent_module(hir_id).to_def_id(), fcx.param_env)\n     {\n         return false;\n     }"}, {"sha": "100a8788763c2909b6ee10b6b1b131d2f945b750", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -201,9 +201,9 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             plural_len: usize,\n         ) -> bool {\n             if ty.is_unit()\n-                || cx.tcx.is_ty_uninhabited_from(\n+                || !ty.is_inhabited_from(\n+                    cx.tcx,\n                     cx.tcx.parent_module(expr.hir_id).to_def_id(),\n-                    ty,\n                     cx.param_env,\n                 )\n             {"}, {"sha": "21097b1fec6dea198c9aaa12709116d4c10733ad", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -2078,17 +2078,6 @@ rustc_queries! {\n         desc { \"normalizing opaque types in `{:?}`\", key }\n     }\n \n-    /// Checks whether a type is definitely uninhabited. This is\n-    /// conservative: for some types that are uninhabited we return `false`,\n-    /// but we only return `true` for types that are definitely uninhabited.\n-    /// `ty.conservative_is_privately_uninhabited` implies that any value of type `ty`\n-    /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n-    /// size, to account for partial initialisation. See #49298 for details.)\n-    query conservative_is_privately_uninhabited(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-        desc { \"conservatively checking if `{}` is privately uninhabited\", key.value }\n-        remap_env_constness\n-    }\n-\n     query limits(key: ()) -> Limits {\n         desc { \"looking up limits\" }\n     }"}, {"sha": "33f72729798dca93e38753e6332892c5cf835cf9", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -41,6 +41,13 @@ impl<'tcx> InhabitedPredicate<'tcx> {\n         self.apply_inner(tcx, param_env, &|_| Err(())).ok()\n     }\n \n+    /// Same as `apply`, but `NotInModule(_)` predicates yield `false`. That is,\n+    /// privately uninhabited types are considered always uninhabited.\n+    pub fn apply_ignore_module(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> bool {\n+        let Ok(result) = self.apply_inner::<!>(tcx, param_env, &|_| Ok(true));\n+        result\n+    }\n+\n     fn apply_inner<E>(\n         self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "ace81bc4f8352e155330d5178968f369eed30054", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -29,7 +29,7 @@\n //! }\n //! ```\n //! In this code, the type `Foo` will only be visibly uninhabited inside the\n-//! modules `b`, `c` and `d`. Calling `uninhabited_predicate` on `Foo` will\n+//! modules `b`, `c` and `d`. Calling `inhabited_predicate` on `Foo` will\n //! return `NotInModule(b) AND NotInModule(c)`.\n //!\n //! We need this information for pattern-matching on `Foo` or types that contain\n@@ -57,57 +57,6 @@ pub(crate) fn provide(providers: &mut ty::query::Providers) {\n         ty::query::Providers { inhabited_predicate_adt, inhabited_predicate_type, ..*providers };\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Checks whether a type is visibly uninhabited from a particular module.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// #![feature(never_type)]\n-    /// # fn main() {}\n-    /// enum Void {}\n-    /// mod a {\n-    ///     pub mod b {\n-    ///         pub struct SecretlyUninhabited {\n-    ///             _priv: !,\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// mod c {\n-    ///     use super::Void;\n-    ///     pub struct AlsoSecretlyUninhabited {\n-    ///         _priv: Void,\n-    ///     }\n-    ///     mod d {\n-    ///     }\n-    /// }\n-    ///\n-    /// struct Foo {\n-    ///     x: a::b::SecretlyUninhabited,\n-    ///     y: c::AlsoSecretlyUninhabited,\n-    /// }\n-    /// ```\n-    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n-    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n-    /// contain `Foo`.\n-    ///\n-    /// # Example\n-    /// ```ignore (illustrative)\n-    /// let foo_result: Result<T, Foo> = ... ;\n-    /// let Ok(t) = foo_result;\n-    /// ```\n-    /// This code should only compile in modules where the uninhabitedness of Foo is\n-    /// visible.\n-    pub fn is_ty_uninhabited_from(\n-        self,\n-        module: DefId,\n-        ty: Ty<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        !ty.inhabited_predicate(self).apply(self, param_env, module)\n-    }\n-}\n-\n /// Returns an `InhabitedPredicate` that is generic over type parameters and\n /// requires calling [`InhabitedPredicate::subst`]\n fn inhabited_predicate_adt(tcx: TyCtxt<'_>, def_id: DefId) -> InhabitedPredicate<'_> {\n@@ -171,6 +120,64 @@ impl<'tcx> Ty<'tcx> {\n             _ => InhabitedPredicate::True,\n         }\n     }\n+\n+    /// Checks whether a type is visibly uninhabited from a particular module.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(never_type)]\n+    /// # fn main() {}\n+    /// enum Void {}\n+    /// mod a {\n+    ///     pub mod b {\n+    ///         pub struct SecretlyUninhabited {\n+    ///             _priv: !,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// mod c {\n+    ///     use super::Void;\n+    ///     pub struct AlsoSecretlyUninhabited {\n+    ///         _priv: Void,\n+    ///     }\n+    ///     mod d {\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Foo {\n+    ///     x: a::b::SecretlyUninhabited,\n+    ///     y: c::AlsoSecretlyUninhabited,\n+    /// }\n+    /// ```\n+    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n+    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n+    /// contain `Foo`.\n+    ///\n+    /// # Example\n+    /// ```ignore (illustrative)\n+    /// let foo_result: Result<T, Foo> = ... ;\n+    /// let Ok(t) = foo_result;\n+    /// ```\n+    /// This code should only compile in modules where the uninhabitedness of Foo is\n+    /// visible.\n+    pub fn is_inhabited_from(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        module: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n+        self.inhabited_predicate(tcx).apply(tcx, param_env, module)\n+    }\n+\n+    /// Returns true if the type is uninhabited without regard to visibility\n+    pub fn is_privately_uninhabited(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n+        !self.inhabited_predicate(tcx).apply_ignore_module(tcx, param_env)\n+    }\n }\n \n /// N.B. this query should only be called through `Ty::inhabited_predicate`"}, {"sha": "efb6eba7e576f79d02f0dde68380c1f659161090", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -271,15 +271,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // MIR checks and ultimately whether code is accepted or not. We can only\n                         // omit the return edge if a return type is visibly uninhabited to a module\n                         // that makes the call.\n-                        target: if this.tcx.is_ty_uninhabited_from(\n-                            this.parent_module,\n-                            expr.ty,\n-                            this.param_env,\n-                        ) {\n-                            None\n-                        } else {\n-                            Some(success)\n-                        },\n+                        target: expr\n+                            .ty\n+                            .is_inhabited_from(this.tcx, this.parent_module, this.param_env)\n+                            .then_some(success),\n                         from_hir_call,\n                         fn_span,\n                     },"}, {"sha": "caf27eb39d7d4b1d3303fdca934c3c891cf894b1", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -264,10 +264,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let irrefutable = adt_def.variants().iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n                         self.tcx.features().exhaustive_patterns\n-                            && v.inhabited_predicate(self.tcx, adt_def)\n+                            && !v\n+                                .inhabited_predicate(self.tcx, adt_def)\n                                 .subst(self.tcx, substs)\n-                                .apply_any_module(self.tcx, self.param_env)\n-                                != Some(true)\n+                                .apply_ignore_module(self.tcx, self.param_env)\n                     }\n                 }) && (adt_def.did().is_local()\n                     || !adt_def.is_variant_list_non_exhaustive());"}, {"sha": "0df228a0d599aec5337b7081bb4bdc606388b5e6", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -818,7 +818,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n         }\n     }\n     if let ty::Ref(_, sub_ty, _) = scrut_ty.kind() {\n-        if cx.tcx.is_ty_uninhabited_from(cx.module, *sub_ty, cx.param_env) {\n+        if !sub_ty.is_inhabited_from(cx.tcx, cx.module, cx.param_env) {\n             err.note(\"references are always considered inhabited\");\n         }\n     }"}, {"sha": "3e370a053766574d110cefebb855cfed25ff81fc", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -324,7 +324,7 @@ pub(crate) struct MatchCheckCtxt<'p, 'tcx> {\n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub(super) fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n         if self.tcx.features().exhaustive_patterns {\n-            self.tcx.is_ty_uninhabited_from(self.module, ty, self.param_env)\n+            !ty.is_inhabited_from(self.tcx, self.module, self.param_env)\n         } else {\n             false\n         }"}, {"sha": "fcd63b6cfa17843bdb91f87b838d5c5c1eefadf4", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -1015,7 +1015,7 @@ fn insert_panic_block<'tcx>(\n \n fn can_return<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n     // Returning from a function with an uninhabited return type is undefined behavior.\n-    if tcx.conservative_is_privately_uninhabited(param_env.and(body.return_ty())) {\n+    if body.return_ty().is_privately_uninhabited(tcx, param_env) {\n         return false;\n     }\n "}, {"sha": "58e1fe937a68fba34ececfe019c4c76434257ed1", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -1284,20 +1284,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_is_ty_uninhabited(&mut self, expr: &Expr<'_>, succ: LiveNode) -> LiveNode {\n         let ty = self.typeck_results.expr_ty(expr);\n         let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n-        if self.ir.tcx.is_ty_uninhabited_from(m, ty, self.param_env) {\n-            match self.ir.lnks[succ] {\n-                LiveNodeKind::ExprNode(succ_span, succ_id) => {\n-                    self.warn_about_unreachable(expr.span, ty, succ_span, succ_id, \"expression\");\n-                }\n-                LiveNodeKind::VarDefNode(succ_span, succ_id) => {\n-                    self.warn_about_unreachable(expr.span, ty, succ_span, succ_id, \"definition\");\n-                }\n-                _ => {}\n-            };\n-            self.exit_ln\n-        } else {\n-            succ\n+        if ty.is_inhabited_from(self.ir.tcx, m, self.param_env) {\n+            return succ;\n         }\n+        match self.ir.lnks[succ] {\n+            LiveNodeKind::ExprNode(succ_span, succ_id) => {\n+                self.warn_about_unreachable(expr.span, ty, succ_span, succ_id, \"expression\");\n+            }\n+            LiveNodeKind::VarDefNode(succ_span, succ_id) => {\n+                self.warn_about_unreachable(expr.span, ty, succ_span, succ_id, \"definition\");\n+            }\n+            _ => {}\n+        };\n+        self.exit_ln\n     }\n \n     fn warn_about_unreachable("}, {"sha": "92e8542795faea78ae7790c5cca6ed3fa89decb1", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -442,8 +442,7 @@ fn layout_of_uncached<'tcx>(\n             let element = cx.layout_of(element)?;\n             let size = element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow(ty))?;\n \n-            let abi = if count != 0 && tcx.conservative_is_privately_uninhabited(param_env.and(ty))\n-            {\n+            let abi = if count != 0 && ty.is_privately_uninhabited(tcx, param_env) {\n                 Abi::Uninhabited\n             } else {\n                 Abi::Aggregate { sized: true }"}, {"sha": "ee5e7bc235974a3097e13a1267c4ad846c1e013d", "filename": "compiler/rustc_ty_utils/src/layout_sanity_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -12,7 +12,7 @@ pub(super) fn sanity_check_layout<'tcx>(\n     layout: &TyAndLayout<'tcx>,\n ) {\n     // Type-level uninhabitedness should always imply ABI uninhabitedness.\n-    if cx.tcx.conservative_is_privately_uninhabited(cx.param_env.and(layout.ty)) {\n+    if layout.ty.is_privately_uninhabited(cx.tcx, cx.param_env) {\n         assert!(layout.abi.is_uninhabited());\n     }\n "}, {"sha": "c60ade360dfb194cd5b2777b9b6f02c66191fe91", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -416,62 +416,6 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     node.fn_sig().map_or(hir::IsAsync::NotAsync, |sig| sig.header.asyncness)\n }\n \n-/// Don't call this directly: use ``tcx.conservative_is_privately_uninhabited`` instead.\n-pub fn conservative_is_privately_uninhabited_raw<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env_and: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> bool {\n-    let (param_env, ty) = param_env_and.into_parts();\n-    match ty.kind() {\n-        ty::Never => {\n-            debug!(\"ty::Never =>\");\n-            true\n-        }\n-        ty::Adt(def, _) if def.is_union() => {\n-            debug!(\"ty::Adt(def, _) if def.is_union() =>\");\n-            // For now, `union`s are never considered uninhabited.\n-            false\n-        }\n-        ty::Adt(def, substs) => {\n-            debug!(\"ty::Adt(def, _) if def.is_not_union() =>\");\n-            // Any ADT is uninhabited if either:\n-            // (a) It has no variants (i.e. an empty `enum`);\n-            // (b) Each of its variants (a single one in the case of a `struct`) has at least\n-            //     one uninhabited field.\n-            def.variants().iter().all(|var| {\n-                var.fields.iter().any(|field| {\n-                    let ty = tcx.bound_type_of(field.did).subst(tcx, substs);\n-                    tcx.conservative_is_privately_uninhabited(param_env.and(ty))\n-                })\n-            })\n-        }\n-        ty::Tuple(fields) => {\n-            debug!(\"ty::Tuple(..) =>\");\n-            fields.iter().any(|ty| tcx.conservative_is_privately_uninhabited(param_env.and(ty)))\n-        }\n-        ty::Array(ty, len) => {\n-            debug!(\"ty::Array(ty, len) =>\");\n-            match len.try_eval_usize(tcx, param_env) {\n-                Some(0) | None => false,\n-                // If the array is definitely non-empty, it's uninhabited if\n-                // the type of its elements is uninhabited.\n-                Some(1..) => tcx.conservative_is_privately_uninhabited(param_env.and(*ty)),\n-            }\n-        }\n-        ty::Ref(..) => {\n-            debug!(\"ty::Ref(..) =>\");\n-            // References to uninitialised memory is valid for any type, including\n-            // uninhabited types, in unsafe code, so we treat all references as\n-            // inhabited.\n-            false\n-        }\n-        _ => {\n-            debug!(\"_ =>\");\n-            false\n-        }\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n         asyncness,\n@@ -481,7 +425,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,\n-        conservative_is_privately_uninhabited: conservative_is_privately_uninhabited_raw,\n         ..*providers\n     };\n }"}, {"sha": "b385406b0202ffd97359814ccea4f1f75cd089cc", "filename": "src/test/ui/const-generics/inhabited-assoc-ty-ice-1.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/src%2Ftest%2Fui%2Fconst-generics%2Finhabited-assoc-ty-ice-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/src%2Ftest%2Fui%2Fconst-generics%2Finhabited-assoc-ty-ice-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finhabited-assoc-ty-ice-1.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -2,7 +2,7 @@\n #![feature(generic_const_exprs)]\n #![allow(incomplete_features)]\n \n-// This tests that the `conservative_is_privately_uninhabited` fn doesn't cause\n+// This tests that the inhabited check doesn't cause\n // ICEs by trying to evaluate `T::ASSOC` with an incorrect `ParamEnv`.\n \n trait Foo {", "previous_filename": "src/test/ui/const-generics/conservative_is_privately_uninhabited_uses_correct_param_env-1.rs"}, {"sha": "216d29c7cd4d0ad687b20663599677db6271ab25", "filename": "src/test/ui/const-generics/inhabited-assoc-ty-ice-2.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/src%2Ftest%2Fui%2Fconst-generics%2Finhabited-assoc-ty-ice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/src%2Ftest%2Fui%2Fconst-generics%2Finhabited-assoc-ty-ice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finhabited-assoc-ty-ice-2.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -2,7 +2,7 @@\n #![feature(generic_const_exprs)]\n #![allow(incomplete_features)]\n \n-// This tests that the `conservative_is_privately_uninhabited` fn doesn't cause\n+// This tests that the inhabited check doesn't cause\n // ICEs by trying to evaluate `T::ASSOC` with an incorrect `ParamEnv`.\n \n trait Foo {", "previous_filename": "src/test/ui/const-generics/conservative_is_privately_uninhabited_uses_correct_param_env-2.rs"}, {"sha": "5622808d4c7d66b99114ab4e9f1bb3f85fb2557f", "filename": "src/test/ui/pattern/usefulness/uninhabited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -2,7 +2,7 @@\n // aux-build:empty.rs\n //\n // This tests plays with matching and uninhabited types. This also serves as a test for the\n-// `tcx.is_ty_uninhabited_from()` function.\n+// `Ty::is_inhabited_from` function.\n #![feature(never_type)]\n #![feature(never_type_fallback)]\n #![feature(exhaustive_patterns)]"}]}