{"sha": "5d9680fc7e97b57527c4a94d2bba32aeff4a195e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOTY4MGZjN2U5N2I1NzUyN2M0YTk0ZDJiYmEzMmFlZmY0YTE5NWU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-09T23:42:55Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-09T23:42:55Z"}, "message": "Move object-system-related trans stuff to its own file.", "tree": {"sha": "82982affd0f3ef19e8d81d7f2f89cf6d55e62fbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82982affd0f3ef19e8d81d7f2f89cf6d55e62fbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9680fc7e97b57527c4a94d2bba32aeff4a195e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9680fc7e97b57527c4a94d2bba32aeff4a195e", "html_url": "https://github.com/rust-lang/rust/commit/5d9680fc7e97b57527c4a94d2bba32aeff4a195e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9680fc7e97b57527c4a94d2bba32aeff4a195e/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61425c8d1356451845171230def89b6b83bef9a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/61425c8d1356451845171230def89b6b83bef9a9", "html_url": "https://github.com/rust-lang/rust/commit/61425c8d1356451845171230def89b6b83bef9a9"}], "stats": {"total": 2013, "additions": 1005, "deletions": 1008}, "files": [{"sha": "01a1101b3691c3be873455076850e9e4b81b929f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 1008, "changes": 1011, "blob_url": "https://github.com/rust-lang/rust/blob/5d9680fc7e97b57527c4a94d2bba32aeff4a195e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9680fc7e97b57527c4a94d2bba32aeff4a195e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5d9680fc7e97b57527c4a94d2bba32aeff4a195e", "patch": "@@ -75,6 +75,9 @@ import trans_comm::trans_spawn;\n import trans_comm::trans_send;\n import trans_comm::trans_recv;\n \n+import trans_objects::trans_anon_obj;\n+import trans_objects::trans_obj;\n+\n // This function now fails if called on a type with dynamic size (as its\n // return value was always meaningless in that case anyhow). Beware!\n //\n@@ -5591,242 +5594,6 @@ fn trans_be(cx: &@block_ctxt, e: &@ast::expr) -> result {\n     ret trans_ret(cx, some(e));\n }\n \n-/*\n-\n-  Suppose we create an anonymous object my_b from a regular object a:\n-\n-        obj a() {\n-            fn foo() -> int {\n-                ret 2;\n-            }\n-            fn bar() -> int {\n-                ret self.foo();\n-            }\n-        }\n-\n-       auto my_a = a();\n-       auto my_b = obj { fn baz() -> int { ret self.foo() } with my_a };\n-\n-  Here we're extending the my_a object with an additional method baz, creating\n-  an object my_b. Since it's an object, my_b is a pair of a vtable pointer and\n-  a body pointer:\n-\n-  my_b: [vtbl* | body*]\n-\n-  my_b's vtable has entries for foo, bar, and baz, whereas my_a's vtable has\n-  only foo and bar. my_b's 3-entry vtable consists of two forwarding functions\n-  and one real method.\n-\n-  my_b's body just contains the pair a: [ a_vtable | a_body ], wrapped up with\n-  any additional fields that my_b added. None were added, so my_b is just the\n-  wrapped inner object.\n-\n-*/\n-\n-// trans_anon_obj: create and return a pointer to an object.  This code\n-// differs from trans_obj in that, rather than creating an object constructor\n-// function and putting it in the generated code as an object item, we are\n-// instead \"inlining\" the construction of the object and returning the object\n-// itself.\n-fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n-                  id: ast::node_id) -> result {\n-\n-\n-    let ccx = bcx_ccx(bcx);\n-\n-    // Fields.\n-    // FIXME (part of issue #538): Where do we fill in the field *values* from\n-    // the outer object?\n-    let additional_fields: [ast::anon_obj_field] = ~[];\n-    let additional_field_vals: [result] = ~[];\n-    let additional_field_tys: [ty::t] = ~[];\n-    alt anon_obj.fields {\n-      none. { }\n-      some(fields) {\n-        additional_fields = fields;\n-        for f: ast::anon_obj_field  in fields {\n-            additional_field_tys += ~[node_id_type(ccx, f.id)];\n-            additional_field_vals += ~[trans_expr(bcx, f.expr)];\n-        }\n-      }\n-    }\n-\n-    // Get the type of the eventual entire anonymous object, possibly with\n-    // extensions.  NB: This type includes both inner and outer methods.\n-    let outer_obj_ty = ty::node_id_to_type(ccx.tcx, id);\n-\n-    // Create a vtable for the anonymous object.\n-\n-    // create_vtbl() wants an ast::_obj and all we have is an ast::anon_obj,\n-    // so we need to roll our own.  NB: wrapper_obj includes only outer\n-    // methods, not inner ones.\n-    let wrapper_obj: ast::_obj =\n-        {fields:\n-             std::ivec::map(ast::obj_field_from_anon_obj_field,\n-                            additional_fields),\n-         methods: anon_obj.methods};\n-\n-    let inner_obj_ty: ty::t;\n-    let vtbl;\n-    alt anon_obj.inner_obj {\n-      none. {\n-        // We need a dummy inner_obj_ty for setting up the object body\n-        // later.\n-        inner_obj_ty = ty::mk_type(ccx.tcx);\n-\n-        // If there's no inner_obj -- that is, if we're just adding new\n-        // fields rather than extending an existing object -- then we just\n-        // pass the outer object to create_vtbl().  Our vtable won't need\n-        // to have any forwarding slots.\n-        vtbl =\n-            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[], none,\n-                        additional_field_tys);\n-      }\n-      some(e) {\n-        // TODO: What makes more sense to get the type of an expr --\n-        // calling ty::expr_ty(ccx.tcx, e) on it or calling\n-        // ty::node_id_to_type(ccx.tcx, id) on its id?\n-        inner_obj_ty = ty::expr_ty(ccx.tcx, e);\n-        //inner_obj_ty = ty::node_id_to_type(ccx.tcx, e.id);\n-\n-        // If there's a inner_obj, we pass its type along to create_vtbl().\n-        // Part of what create_vtbl() will do is take the set difference\n-        // of methods defined on the original and methods being added.\n-        // For every method defined on the original that does *not* have\n-        // one with a matching name and type being added, we'll need to\n-        // create a forwarding slot.  And, of course, we need to create a\n-        // normal vtable entry for every method being added.\n-        vtbl =\n-            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[],\n-                        some(inner_obj_ty), additional_field_tys);\n-      }\n-    }\n-\n-    // Allocate the object that we're going to return.\n-    let pair = alloca(bcx, ccx.rust_object_type);\n-\n-    // Take care of cleanups.\n-    let t = node_id_type(ccx, id);\n-    add_clean_temp(bcx, pair, t);\n-\n-    // Grab onto the first and second elements of the pair.\n-    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n-    // of 'pair'.\n-    let pair_vtbl =\n-        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box =\n-        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_box)]);\n-\n-    vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n-    bcx.build.Store(vtbl, pair_vtbl);\n-\n-    // Next we have to take care of the other half of the pair we're\n-    // returning: a boxed (reference-counted) tuple containing a tydesc,\n-    // typarams, fields, and a pointer to our inner_obj.\n-    let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n-\n-    if std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n-           anon_obj.inner_obj == none {\n-        // If the object we're translating has no fields and no inner_obj,\n-        // there's not much to do.\n-        bcx.build.Store(C_null(llbox_ty), pair_box);\n-    } else {\n-\n-        // Synthesize a tuple type for fields: [field, ...]\n-        let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, additional_field_tys);\n-\n-        // Type for tydescs.\n-        let tydesc_ty: ty::t = ty::mk_type(ccx.tcx);\n-\n-        // Placeholder for non-existent typarams, since anon objs don't have\n-        // them.\n-        let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, ~[]);\n-\n-        // Tuple type for body:\n-        // [tydesc, [typaram, ...], [field, ...], inner_obj]\n-        let body_ty: ty::t =\n-            ty::mk_imm_tup(ccx.tcx,\n-                           ~[tydesc_ty, typarams_ty, fields_ty,\n-                             inner_obj_ty]);\n-\n-        // Hand this type we've synthesized off to trans_malloc_boxed, which\n-        // allocates a box, including space for a refcount.\n-        let box = trans_malloc_boxed(bcx, body_ty);\n-        bcx = box.bcx;\n-        let body = box.body;\n-\n-        // Put together a tydesc for the body, so that the object can later be\n-        // freed by calling through its tydesc.\n-\n-        // Every object (not just those with type parameters) needs to have a\n-        // tydesc to describe its body, since all objects have unknown type to\n-        // the user of the object.  So the tydesc is needed to keep track of\n-        // the types of the object's fields, so that the fields can be freed\n-        // later.\n-        let body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_tydesc]);\n-        bcx = body_tydesc.bcx;\n-        let ti = none[@tydesc_info];\n-        let body_td = get_tydesc(bcx, body_ty, true, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-        bcx = body_td.bcx;\n-        bcx.build.Store(body_td.val, body_tydesc.val);\n-\n-        // Copy the object's fields into the space we allocated for the object\n-        // body.  (This is something like saving the lexical environment of a\n-        // function in its closure: the fields were passed to the object\n-        // constructor and are now available to the object's methods.\n-        let body_fields =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_fields]);\n-        bcx = body_fields.bcx;\n-        let i: int = 0;\n-        for f: ast::anon_obj_field  in additional_fields {\n-            // FIXME (part of issue #538): make this work eventually, when we\n-            // have additional field exprs in the AST.\n-            load_if_immediate(bcx, additional_field_vals.(i).val,\n-                              additional_field_tys.(i));\n-\n-            let field =\n-                GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n-            bcx = field.bcx;\n-            bcx =\n-                copy_val(bcx, INIT, field.val, additional_field_vals.(i).val,\n-                         additional_field_tys.(i)).bcx;\n-            i += 1;\n-        }\n-\n-        // If there's a inner_obj, copy a pointer to it into the object's\n-        // body.\n-        alt anon_obj.inner_obj {\n-          none. { }\n-          some(e) {\n-            // If inner_obj (the object being extended) exists, translate it.\n-            // Translating inner_obj returns a ValueRef (pointer to a 2-word\n-            // value) wrapped in a result.\n-            let inner_obj_val: result = trans_expr(bcx, e);\n-\n-            let body_inner_obj =\n-                GEP_tup_like(bcx, body_ty, body,\n-                             ~[0, abi::obj_body_elt_inner_obj]);\n-            bcx = body_inner_obj.bcx;\n-            bcx =\n-                copy_val(bcx, INIT, body_inner_obj.val, inner_obj_val.val,\n-                         inner_obj_ty).bcx;\n-          }\n-        }\n-\n-        // Store box ptr in outer pair.\n-        let p = bcx.build.PointerCast(box.box, llbox_ty);\n-        bcx.build.Store(p, pair_box);\n-    }\n-\n-    // return the object we built.\n-    ret rslt(bcx, pair);\n-}\n-\n fn init_local(bcx: @block_ctxt, local: &@ast::local) -> result {\n     let ty = node_id_type(bcx_ccx(bcx), local.node.id);\n     let llptr = bcx.fcx.lllocals.get(local.node.id);\n@@ -6464,778 +6231,6 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n     log_fn_time(cx.ccx, str::connect_ivec(cx.path, \"::\"), start, end);\n }\n \n-// Update a self-stack structure ([[wrapper_self_pair], self_pair*]) to\n-// [[backwarding_vtbl*, inner_obj_body*], outer_obj*].\n-//\n-// We do this when we're receiving the outer object in a forwarding function\n-// via the llenv argument, and we want the forwarding function to call a\n-// method on a \"self\" that's inner-obj-shaped, but we also want to hold onto\n-// the outer obj for potential use later by backwarding functions.\n-fn populate_self_stack(bcx: @block_ctxt,\n-                       self_stack: ValueRef, outer_obj: ValueRef,\n-                       backwarding_vtbl: ValueRef, inner_obj_body: ValueRef)\n-    -> ValueRef {\n-\n-    // Drop the outer obj into the second slot.\n-    let self_pair_ptr = bcx.build.GEP(self_stack,\n-                            ~[C_int(0),\n-                              C_int(1)]);\n-    bcx.build.Store(outer_obj, self_pair_ptr);\n-\n-    // Drop in the backwarding vtbl.\n-    let wrapper_pair = bcx.build.GEP(self_stack,\n-                                     ~[C_int(0),\n-                                       C_int(0)]);\n-    let wrapper_vtbl_ptr = bcx.build.GEP(wrapper_pair,\n-                                         ~[C_int(0),\n-                                           C_int(0)]);\n-    let backwarding_vtbl_cast =\n-        bcx.build.PointerCast(backwarding_vtbl, T_ptr(T_empty_struct()));\n-    bcx.build.Store(backwarding_vtbl_cast, wrapper_vtbl_ptr);\n-\n-    // Drop in the inner obj body.\n-    let wrapper_body_ptr = bcx.build.GEP(wrapper_pair,\n-                                         ~[C_int(0),\n-                                           C_int(1)]);\n-    bcx.build.Store(inner_obj_body, wrapper_body_ptr);\n-\n-    ret self_stack;\n-}\n-\n-// process_bkwding_mthd: Create the backwarding function that appears in a\n-// backwarding vtable slot.\n-//\n-// Backwarding functions are used in situations where method calls dispatch\n-// back through an outer object.  For example, suppose an inner object has\n-// methods foo and bar, and bar contains the call self.foo().  We extend that\n-// object with a foo method that overrides the inner foo.  Now, a call to\n-// outer.bar() should send us to to inner.bar() via a normal forwarding\n-// function, and then to self.foo().  But inner.bar() was already compiled\n-// under the assumption that self.foo() is inner.foo(), when we really want to\n-// reach outer.foo().  So, we give 'self' a vtable of backwarding functions,\n-// one for each method on inner, each of which takes all the same arguments as\n-// the corresponding method on inner does, calls that method on outer, and\n-// returns the value returned from that call.\n-fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &[ast::ty_param], outer_obj_ty: ty::t,\n-                       additional_field_tys: &[ty::t]) -> ValueRef {\n-\n-    // Create a local context that's aware of the name of the method we're\n-    // creating.\n-    let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n-\n-    // Make up a name for the backwarding function.\n-    let fn_name: str = \"backwarding_fn\";\n-    let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n-                                                      fn_name);\n-\n-    // Get the backwarding function's type and declare it.\n-    let llbackwarding_fn_ty: TypeRef =\n-        type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n-                        std::ivec::len[ast::ty_param](ty_params));\n-    let llbackwarding_fn: ValueRef =\n-        decl_internal_fastcall_fn(cx.ccx.llmod, s, llbackwarding_fn_ty);\n-\n-    // Create a new function context and block context for the backwarding\n-    // function, holding onto a pointer to the first block.\n-    let fcx = new_fn_ctxt(cx, sp, llbackwarding_fn);\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-\n-    // The self-object will arrive in the backwarding function via the llenv\n-    // argument, but we need to jump past the first item in the self-stack to\n-    // get to the one we really want.\n-\n-    // Cast to self-stack's type.\n-    let llenv = bcx.build.PointerCast(\n-        fcx.llenv,\n-        T_ptr(T_struct(~[cx.ccx.rust_object_type,\n-                         T_ptr(cx.ccx.rust_object_type)])));\n-\n-    let llself_obj_ptr = bcx.build.GEP(llenv,\n-                                       ~[C_int(0),\n-                                         C_int(1)]);\n-    llself_obj_ptr = bcx.build.Load(llself_obj_ptr);\n-\n-    // Cast it back to pointer-to-object-type, so LLVM won't complain.\n-    llself_obj_ptr = bcx.build.PointerCast(llself_obj_ptr,\n-                                           T_ptr(cx.ccx.rust_object_type));\n-\n-    // The 'llretptr' that will arrive in the backwarding function we're\n-    // creating also needs to be the correct type.  Cast it to the method's\n-    // return type, if necessary.\n-    let llretptr = fcx.llretptr;\n-    if ty::type_contains_params(cx.ccx.tcx, m.output) {\n-        let llretty = type_of_inner(cx.ccx, sp, m.output);\n-        llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n-    }\n-\n-    // Get the index of the method we want.\n-    let ix: uint = 0u;\n-    alt ty::struct(bcx_tcx(bcx), outer_obj_ty) {\n-      ty::ty_obj(methods) {\n-        ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n-      }\n-      _ {\n-        // Shouldn't happen.\n-        cx.ccx.sess.bug(\"process_bkwding_mthd(): non-object type passed \\\n-                        as outer_obj_ty\");\n-      }\n-    }\n-\n-    // Pick out the method being backwarded to from the outer object's vtable.\n-    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-\n-    let llouter_obj_vtbl =\n-        bcx.build.GEP(llself_obj_ptr,\n-                      ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n-    llouter_obj_vtbl = bcx.build.Load(llouter_obj_vtbl);\n-    llouter_obj_vtbl = bcx.build.PointerCast(llouter_obj_vtbl, vtbl_type);\n-\n-    let llouter_mthd =\n-        bcx.build.GEP(llouter_obj_vtbl, ~[C_int(0), C_int(ix as int)]);\n-\n-    // Set up the outer method to be called.\n-    let outer_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n-    let llouter_mthd_ty =\n-        type_of_fn_full(bcx_ccx(bcx), sp,\n-                        ty::ty_fn_proto(bcx_tcx(bcx), outer_mthd_ty), true,\n-                        m.inputs, m.output,\n-                        std::ivec::len[ast::ty_param](ty_params));\n-    llouter_mthd =\n-        bcx.build.PointerCast(llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n-    llouter_mthd = bcx.build.Load(llouter_mthd);\n-\n-    // Set up the three implicit arguments to the outer method we'll need\n-    // to call.\n-    let self_arg = llself_obj_ptr;\n-    let llouter_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_arg];\n-\n-    // Copy the explicit arguments that are being passed into the forwarding\n-    // function (they're in fcx.llargs) to llouter_mthd_args.\n-\n-    let a: uint = 3u; // retptr, task ptr, env come first\n-    let passed_arg: ValueRef = llvm::LLVMGetParam(llbackwarding_fn, a);\n-    for arg: ty::arg  in m.inputs {\n-        if arg.mode == ty::mo_val {\n-            passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n-        }\n-        llouter_mthd_args += ~[passed_arg];\n-        a += 1u;\n-    }\n-\n-    // And, finally, call the outer method.\n-    bcx.build.FastCall(llouter_mthd, llouter_mthd_args);\n-\n-    bcx.build.RetVoid();\n-    finish_fn(fcx, lltop);\n-\n-    ret llbackwarding_fn;\n-\n-}\n-\n-// process_fwding_mthd: Create the forwarding function that appears in a\n-// vtable slot for method calls that need to forward to another object.  A\n-// helper function for create_vtbl.\n-//\n-// Forwarding functions are used for method calls that fall through to an\n-// inner object.  For example, suppose an inner object has method foo and we\n-// extend it with a method bar.  The only version of 'foo' we have is on the\n-// inner object, but we would like to be able to call outer.foo().  So we use\n-// a forwarding function to make the foo method available on the outer object.\n-// It takes all the same arguments as the foo method on the inner object does,\n-// calls inner.foo() with those arguments, and then returns the value returned\n-// from that call.  (The inner object won't exist until run-time, but we know\n-// its type statically.)\n-fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &[ast::ty_param], inner_obj_ty: ty::t,\n-                       backwarding_vtbl: ValueRef,\n-                       additional_field_tys: &[ty::t]) -> ValueRef {\n-\n-    // Create a local context that's aware of the name of the method we're\n-    // creating.\n-    let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n-\n-    // Make up a name for the forwarding function.\n-    let fn_name: str = \"forwarding_fn\";\n-    let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n-                                                      fn_name);\n-\n-    // Get the forwarding function's type and declare it.\n-    let llforwarding_fn_ty: TypeRef =\n-        type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n-                        std::ivec::len[ast::ty_param](ty_params));\n-    let llforwarding_fn: ValueRef =\n-        decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n-\n-    // Create a new function context and block context for the forwarding\n-    // function, holding onto a pointer to the first block.\n-    let fcx = new_fn_ctxt(cx, sp, llforwarding_fn);\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-\n-    // The outer object will arrive in the forwarding function via the llenv\n-    // argument.\n-    let llself_obj_ptr = fcx.llenv;\n-\n-    // The 'llretptr' that will arrive in the forwarding function we're\n-    // creating also needs to be the correct type.  Cast it to the method's\n-    // return type, if necessary.\n-    let llretptr = fcx.llretptr;\n-    if ty::type_contains_params(cx.ccx.tcx, m.output) {\n-        let llretty = type_of_inner(cx.ccx, sp, m.output);\n-        llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n-    }\n-\n-    // Now, we have to get the the inner_obj's vtbl out of the self_obj.  This\n-    // is a multi-step process:\n-\n-    // First, grab the box out of the self_obj.  It contains a refcount and a\n-    // body.\n-    let llself_obj_box =\n-        bcx.build.GEP(llself_obj_ptr, ~[C_int(0), C_int(abi::obj_field_box)]);\n-    llself_obj_box = bcx.build.Load(llself_obj_box);\n-\n-    let ccx = bcx_ccx(bcx);\n-    let llbox_ty = T_opaque_obj_ptr(*ccx);\n-    llself_obj_box = bcx.build.PointerCast(llself_obj_box, llbox_ty);\n-\n-    // Now, reach into the box and grab the body.\n-    let llself_obj_body =\n-        bcx.build.GEP(llself_obj_box,\n-                      ~[C_int(0), C_int(abi::box_rc_field_body)]);\n-\n-    // Now, we need to figure out exactly what type the body is supposed to be\n-    // cast to.\n-\n-    // NB: This next part is almost flat-out copypasta from trans_anon_obj.\n-    // It would be great to factor this out.\n-\n-    // Synthesize a tuple type for fields: [field, ...]\n-    let fields_ty: ty::t = ty::mk_imm_tup(cx.ccx.tcx, additional_field_tys);\n-\n-    // Type for tydescs.\n-    let tydesc_ty: ty::t = ty::mk_type(cx.ccx.tcx);\n-\n-    // Placeholder for non-existent typarams, since anon objs don't have them.\n-    let typarams_ty: ty::t = ty::mk_imm_tup(cx.ccx.tcx, ~[]);\n-\n-    // Tuple type for body:\n-    // [tydesc, [typaram, ...], [field, ...], inner_obj]\n-\n-    let body_ty: ty::t =\n-        ty::mk_imm_tup(cx.ccx.tcx,\n-                       ~[tydesc_ty, typarams_ty, fields_ty, inner_obj_ty]);\n-\n-    // And cast to that type.\n-    llself_obj_body =\n-        bcx.build.PointerCast(llself_obj_body,\n-                              T_ptr(type_of(cx.ccx, sp, body_ty)));\n-\n-    // Now, reach into the body and grab the inner_obj.\n-    let llinner_obj =\n-        GEP_tup_like(bcx, body_ty, llself_obj_body,\n-                     ~[0, abi::obj_body_elt_inner_obj]);\n-    bcx = llinner_obj.bcx;\n-\n-    // And, now, somewhere in inner_obj is a vtable with an entry for the\n-    // method we want.  First, pick out the vtable, and then pluck that\n-    // method's entry out of the vtable so that the forwarding function can\n-    // call it.\n-    let llinner_obj_vtbl =\n-        bcx.build.GEP(llinner_obj.val,\n-                      ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n-    llinner_obj_vtbl = bcx.build.Load(llinner_obj_vtbl);\n-\n-    let llinner_obj_body =\n-        bcx.build.GEP(llinner_obj.val,\n-                      ~[C_int(0), C_int(abi::obj_field_box)]);\n-    llinner_obj_body = bcx.build.Load(llinner_obj_body);\n-\n-    // Get the index of the method we want.\n-    let ix: uint = 0u;\n-    alt ty::struct(bcx_tcx(bcx), inner_obj_ty) {\n-      ty::ty_obj(methods) {\n-        ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n-      }\n-      _ {\n-        // Shouldn't happen.\n-        cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \\\n-                        as target_obj_ty\");\n-      }\n-    }\n-\n-    // Pick out the original method from the vtable.\n-    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-    llinner_obj_vtbl = bcx.build.PointerCast(llinner_obj_vtbl, vtbl_type);\n-\n-    let llorig_mthd =\n-        bcx.build.GEP(llinner_obj_vtbl, ~[C_int(0), C_int(ix as int)]);\n-\n-    // Set up the original method to be called.\n-    let orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n-    let llorig_mthd_ty =\n-        type_of_fn_full(bcx_ccx(bcx), sp,\n-                        ty::ty_fn_proto(bcx_tcx(bcx), orig_mthd_ty), true,\n-                        m.inputs, m.output,\n-                        std::ivec::len[ast::ty_param](ty_params));\n-    llorig_mthd =\n-        bcx.build.PointerCast(llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n-    llorig_mthd = bcx.build.Load(llorig_mthd);\n-\n-    // Set up the self-stack.\n-    let self_stack = alloca(bcx, T_struct(~[cx.ccx.rust_object_type,\n-                                            T_ptr(cx.ccx.rust_object_type)]));\n-    self_stack = populate_self_stack(bcx,\n-                                     self_stack,\n-                                     llself_obj_ptr,\n-                                     backwarding_vtbl,\n-                                     llinner_obj_body);\n-\n-    // Cast self_stack back to pointer-to-object-type to make LLVM happy.\n-    self_stack = bcx.build.PointerCast(self_stack,\n-                                       T_ptr(cx.ccx.rust_object_type));\n-\n-    // Set up the three implicit arguments to the original method we'll need\n-    // to call.\n-    let llorig_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_stack];\n-\n-    // Copy the explicit arguments that are being passed into the forwarding\n-    // function (they're in fcx.llargs) to llorig_mthd_args.\n-\n-    let a: uint = 3u; // retptr, task ptr, env come first\n-    let passed_arg: ValueRef = llvm::LLVMGetParam(llforwarding_fn, a);\n-    for arg: ty::arg  in m.inputs {\n-        if arg.mode == ty::mo_val {\n-            passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n-        }\n-        llorig_mthd_args += ~[passed_arg];\n-        a += 1u;\n-    }\n-\n-    // And, finally, call the original (inner) method.\n-    bcx.build.FastCall(llorig_mthd, llorig_mthd_args);\n-\n-    bcx.build.RetVoid();\n-    finish_fn(fcx, lltop);\n-\n-    ret llforwarding_fn;\n-}\n-\n-// process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n-// function for create_vtbl.\n-fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n-                       ty_params: &[ast::ty_param]) -> ValueRef {\n-\n-    let llfnty = T_nil();\n-    alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n-      ty::ty_fn(proto, inputs, output, _, _) {\n-        llfnty =\n-            type_of_fn_full(cx.ccx, m.span, proto, true, inputs, output,\n-                            std::ivec::len[ast::ty_param](ty_params));\n-      }\n-    }\n-    let mcx: @local_ctxt =\n-        @{path: cx.path + ~[\"method\", m.node.ident] with *cx};\n-    let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n-    let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n-\n-    // Every method on an object gets its node_id inserted into the\n-    // crate-wide item_ids map, together with the ValueRef that points to\n-    // where that method's definition will be in the executable.\n-    cx.ccx.item_ids.insert(m.node.id, llfn);\n-    cx.ccx.item_symbols.insert(m.node.id, s);\n-    trans_fn(mcx, m.span, m.node.meth, llfn, some(self_ty), ty_params,\n-             m.node.id);\n-\n-    ret llfn;\n-}\n-\n-// Used only inside create_vtbl and create_backwarding_vtbl to distinguish\n-// different kinds of slots we'll have to create.\n-tag vtbl_mthd {\n-    // Normal methods are complete AST nodes, but for forwarding methods,\n-    // the only information we'll have about them is their type.\n-    normal_mthd(@ast::method);\n-    fwding_mthd(@ty::method);\n-}\n-\n-// Alphabetize ast::methods by ident.  A helper for create_vtbl.\n-fn ast_mthd_lteq(a: &@ast::method, b: &@ast::method) -> bool {\n-    ret str::lteq(a.node.ident, b.node.ident);\n-}\n-\n-// Alphabetize vtbl_mthds by ident.  A helper for create_vtbl.\n-fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n-    alt a {\n-      normal_mthd(ma) {\n-        alt b {\n-          normal_mthd(mb) { ret str::lteq(ma.node.ident, mb.node.ident); }\n-          fwding_mthd(mb) { ret str::lteq(ma.node.ident, mb.ident); }\n-        }\n-      }\n-      fwding_mthd(ma) {\n-        alt b {\n-          normal_mthd(mb) { ret str::lteq(ma.ident, mb.node.ident); }\n-          fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n-        }\n-      }\n-    }\n-}\n-\n-// Used by create_vtbl to filter a list of methods to remove the ones that we\n-// don't need forwarding slots for.\n-fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n-                addtl_meths: [@ast::method]) ->\n-    option::t[vtbl_mthd] {\n-\n-    // Since m is a fwding_mthd, and we're checking to see if it's in\n-    // addtl_meths (which only contains normal_mthds), we can't just check if\n-    // it's a member of addtl_meths.  Instead, we have to go through\n-    // addtl_meths and see if there's some method in it that has the same name\n-    // as m.\n-    alt m {\n-      fwding_mthd(fm) {\n-        for am: @ast::method in addtl_meths {\n-            if str::eq(am.node.ident, fm.ident) { ret none; }\n-        }\n-        ret some(fwding_mthd(fm));\n-      }\n-      normal_mthd(_) {\n-        cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any \\\n-                        normal_mthds in meths here\");\n-      }\n-    }\n-}\n-\n-// Create a vtable for an object being translated.  Returns a pointer into\n-// read-only memory.\n-fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n-               ob: &ast::_obj, ty_params: &[ast::ty_param],\n-               inner_obj_ty: option::t[ty::t],\n-               additional_field_tys: &[ty::t]) -> ValueRef {\n-\n-    let llmethods: [ValueRef] = ~[];\n-\n-    alt inner_obj_ty {\n-      none. {\n-        // Sort and process all the methods.\n-        let meths =\n-            std::sort::ivector::merge_sort[@ast::method]\n-            (bind ast_mthd_lteq(_, _), ob.methods);\n-\n-        for m: @ast::method in meths {\n-            llmethods += ~[process_normal_mthd(cx, m, outer_obj_ty,\n-                                               ty_params)];\n-        }\n-      }\n-      some(inner_obj_ty) {\n-        // If this vtable is being created for an extended object, then the\n-        // vtable needs to contain 'forwarding slots' for methods that were on\n-        // the original object and are not being overridden by the extended\n-        // one.  So, to find the set of methods that we need forwarding slots\n-        // for, we need to take the set difference of inner_obj_methods\n-        // (methods on the original object) and ob.methods (methods being\n-        // added, whether entirely new or overriding).\n-\n-        // inner_obj_ty is the type of the inner object being forwarded to,\n-        // and \"ob\" is the wrapper object.  We need to take apart\n-        // inner_obj_ty, which is the type of the object being forwarded to\n-        // (it had better have an object type with methods!) and put those\n-        // original methods onto the list of methods we need forwarding\n-        // methods for.\n-\n-        let meths: [vtbl_mthd] = ~[];\n-\n-        // Gather up methods on the original object in 'meths'.\n-        alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n-          ty::ty_obj(inner_obj_methods) {\n-            for m: ty::method  in inner_obj_methods {\n-                meths += ~[fwding_mthd(@m)];\n-            }\n-          }\n-          _ {\n-            cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \\\n-                            non-object\");\n-          }\n-        }\n-\n-        // Now, filter out any methods that we don't need forwarding slots\n-        // for, because they're being overridden.\n-        let f = bind filtering_fn(cx, _, ob.methods);\n-        meths = std::ivec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n-\n-        // And now add the additional ones, both overriding ones and entirely\n-        // new ones.  These will just be normal methods.\n-        for m: @ast::method in ob.methods { meths += ~[normal_mthd(m)]; }\n-\n-        // Sort all the methods and process them.\n-        meths =\n-            std::sort::ivector::merge_sort[vtbl_mthd]\n-            (bind vtbl_mthd_lteq(_, _), meths);\n-\n-        let backwarding_vtbl: ValueRef =\n-            create_backwarding_vtbl(cx, sp, inner_obj_ty, outer_obj_ty);\n-\n-        for m: vtbl_mthd in meths {\n-            alt m {\n-              normal_mthd(nm) {\n-                llmethods +=\n-                    ~[process_normal_mthd(cx, nm, outer_obj_ty, ty_params)];\n-              }\n-              fwding_mthd(fm) {\n-                llmethods +=\n-                    ~[process_fwding_mthd(cx, sp, fm, ty_params, inner_obj_ty,\n-                                          backwarding_vtbl,\n-                                          additional_field_tys)];\n-              }\n-            }\n-        }\n-      }\n-    }\n-\n-    let vtbl = C_struct(llmethods);\n-    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + ~[\"vtbl\"]);\n-    let gvar =\n-        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n-    llvm::LLVMSetInitializer(gvar, vtbl);\n-    llvm::LLVMSetGlobalConstant(gvar, True);\n-    llvm::LLVMSetLinkage(gvar,\n-                         lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    ret gvar;\n-}\n-\n-fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n-                           outer_obj_ty: ty::t) -> ValueRef {\n-\n-    // This vtbl needs to have slots for all of the methods on an inner\n-    // object, and it needs to forward them to the corresponding slots on the\n-    // outer object.  All we know about either one are their types.\n-\n-    let llmethods: [ValueRef] = ~[];\n-    let meths: [ty::method]= ~[];\n-\n-    // Gather up methods on the inner object.\n-    alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n-        ty::ty_obj(inner_obj_methods) {\n-            for m: ty::method in inner_obj_methods {\n-                meths += ~[m];\n-            }\n-        }\n-        _ {\n-            // Shouldn't happen.\n-            cx.ccx.sess.bug(\"create_backwarding_vtbl(): trying to extend a \\\n-                            non-object\");\n-        }\n-    }\n-\n-    // Methods should have already been sorted, so no need to do so again.\n-    for m: ty::method in meths {\n-        // We pass outer_obj_ty to process_fwding_mthd() because it's\n-        // the one being forwarded to.\n-        llmethods += ~[process_bkwding_mthd(\n-            cx, sp, @m, ~[], outer_obj_ty, ~[])];\n-    }\n-\n-    let vtbl = C_struct(llmethods);\n-    let vtbl_name =\n-        mangle_internal_name_by_path(cx.ccx,\n-                                     cx.path + ~[\"backwarding_vtbl\"]);\n-    let gvar =\n-        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n-    llvm::LLVMSetInitializer(gvar, vtbl);\n-    llvm::LLVMSetGlobalConstant(gvar, True);\n-    llvm::LLVMSetLinkage(gvar,\n-                         lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-\n-    ret gvar;\n-\n-}\n-\n-// trans_obj: creates an LLVM function that is the object constructor for the\n-// object being translated.\n-fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n-             ctor_id: ast::node_id, ty_params: &[ast::ty_param]) {\n-    // To make a function, we have to create a function context and, inside\n-    // that, a number of block contexts for which code is generated.\n-\n-    let ccx = cx.ccx;\n-    let llctor_decl;\n-    alt ccx.item_ids.find(ctor_id) {\n-      some(x) { llctor_decl = x; }\n-      _ { cx.ccx.sess.span_fatal(sp, \"unbound llctor_decl in trans_obj\"); }\n-    }\n-    // Much like trans_fn, we must create an LLVM function, but since we're\n-    // starting with an ast::_obj rather than an ast::_fn, we have some setup\n-    // work to do.\n-\n-    // The fields of our object will become the arguments to the function\n-    // we're creating.\n-\n-    let fn_args: [ast::arg] = ~[];\n-    for f: ast::obj_field  in ob.fields {\n-        fn_args +=\n-            ~[{mode: ast::alias(false), ty: f.ty, ident: f.ident, id: f.id}];\n-    }\n-    let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n-\n-    // Both regular arguments and type parameters are handled here.\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n-                              ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n-                              ty_params);\n-    let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n-    copy_args_to_allocas(fcx, fn_args, arg_tys);\n-\n-    //  Create the first block context in the function and keep a handle on it\n-    //  to pass to finish_fn later.\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-\n-    // Pick up the type of this object by looking at our own output type, that\n-    // is, the output type of the object constructor we're building.\n-    let self_ty = ty::ret_ty_of_fn(ccx.tcx, ctor_id);\n-\n-    // Set up the two-word pair that we're going to return from the object\n-    // constructor we're building.  The two elements of this pair will be a\n-    // vtable pointer and a body pointer.  (llretptr already points to the\n-    // place where this two-word pair should go; it was pre-allocated by the\n-    // caller of the function.)\n-    let pair = bcx.fcx.llretptr;\n-\n-    // Grab onto the first and second elements of the pair.\n-    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n-    // of 'pair'.\n-    let pair_vtbl =\n-        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box =\n-        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_box)]);\n-\n-    // Make a vtable for this object: a static array of pointers to functions.\n-    // It will be located in the read-only memory of the executable we're\n-    // creating and will contain ValueRefs for all of this object's methods.\n-    // create_vtbl returns a pointer to the vtable, which we store.\n-    let vtbl = create_vtbl(cx, sp, self_ty, ob, ty_params, none, ~[]);\n-    vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n-\n-    bcx.build.Store(vtbl, pair_vtbl);\n-\n-    // Next we have to take care of the other half of the pair we're\n-    // returning: a boxed (reference-counted) tuple containing a tydesc,\n-    // typarams, and fields.\n-\n-    // FIXME: What about inner_obj?  Do we have to think about it here?\n-    // (Pertains to issues #538/#539/#540/#543.)\n-\n-    let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n-\n-    if std::ivec::len[ast::ty_param](ty_params) == 0u &&\n-           std::ivec::len[ty::arg](arg_tys) == 0u {\n-        // If the object we're translating has no fields or type parameters,\n-        // there's not much to do.\n-\n-        // Store null into pair, if no args or typarams.\n-        bcx.build.Store(C_null(llbox_ty), pair_box);\n-    } else {\n-        // Otherwise, we have to synthesize a big structural type for the\n-        // object body.\n-        let obj_fields: [ty::t] = ~[];\n-        for a: ty::arg  in arg_tys { obj_fields += ~[a.ty]; }\n-\n-        // Tuple type for fields: [field, ...]\n-        let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, obj_fields);\n-\n-        let tydesc_ty = ty::mk_type(ccx.tcx);\n-        let tps: [ty::t] = ~[];\n-        for tp: ast::ty_param  in ty_params { tps += ~[tydesc_ty]; }\n-\n-        // Tuple type for typarams: [typaram, ...]\n-        let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, tps);\n-\n-        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n-        let body_ty: ty::t =\n-            ty::mk_imm_tup(ccx.tcx, ~[tydesc_ty, typarams_ty, fields_ty]);\n-\n-        // Hand this type we've synthesized off to trans_malloc_boxed, which\n-        // allocates a box, including space for a refcount.\n-        let box = trans_malloc_boxed(bcx, body_ty);\n-        bcx = box.bcx;\n-        let body = box.body;\n-\n-        // Put together a tydesc for the body, so that the object can later be\n-        // freed by calling through its tydesc.\n-\n-        // Every object (not just those with type parameters) needs to have a\n-        // tydesc to describe its body, since all objects have unknown type to\n-        // the user of the object.  So the tydesc is needed to keep track of\n-        // the types of the object's fields, so that the fields can be freed\n-        // later.\n-\n-        let body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_tydesc]);\n-        bcx = body_tydesc.bcx;\n-        let ti = none[@tydesc_info];\n-        let body_td = get_tydesc(bcx, body_ty, true, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-        bcx = body_td.bcx;\n-        bcx.build.Store(body_td.val, body_tydesc.val);\n-\n-        // Copy the object's type parameters and fields into the space we\n-        // allocated for the object body.  (This is something like saving the\n-        // lexical environment of a function in its closure: the \"captured\n-        // typarams\" are any type parameters that are passed to the object\n-        // constructor and are then available to the object's methods.\n-        // Likewise for the object's fields.)\n-\n-        // Copy typarams into captured typarams.\n-        let body_typarams =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_typarams]);\n-        bcx = body_typarams.bcx;\n-        let i: int = 0;\n-        for tp: ast::ty_param  in ty_params {\n-            let typaram = bcx.fcx.lltydescs.(i);\n-            let capture =\n-                GEP_tup_like(bcx, typarams_ty, body_typarams.val, ~[0, i]);\n-            bcx = capture.bcx;\n-            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n-            i += 1;\n-        }\n-\n-        // Copy args into body fields.\n-        let body_fields =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_fields]);\n-        bcx = body_fields.bcx;\n-        i = 0;\n-        for f: ast::obj_field  in ob.fields {\n-            alt bcx.fcx.llargs.find(f.id) {\n-              some(arg1) {\n-                let arg = load_if_immediate(bcx, arg1, arg_tys.(i).ty);\n-                let field =\n-                    GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n-                bcx = field.bcx;\n-                bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n-                i += 1;\n-              }\n-              none. {\n-                bcx_ccx(bcx).sess.span_fatal(f.ty.span,\n-                                             \"internal error in trans_obj\");\n-              }\n-            }\n-        }\n-\n-        // Store box ptr in outer pair.\n-        let p = bcx.build.PointerCast(box.box, llbox_ty);\n-        bcx.build.Store(p, pair_box);\n-    }\n-    bcx.build.RetVoid();\n-\n-    // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(fcx, lltop);\n-}\n-\n fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n                   ctor_id: ast::node_id, ty_params: &[ast::ty_param]) {\n     // Create a function for the constructor"}, {"sha": "454a4f3b39a49de34505e2fe838aeba96c065ebe", "filename": "src/comp/middle/trans_objects.rs", "status": "added", "additions": 1001, "deletions": 0, "changes": 1001, "blob_url": "https://github.com/rust-lang/rust/blob/5d9680fc7e97b57527c4a94d2bba32aeff4a195e/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9680fc7e97b57527c4a94d2bba32aeff4a195e/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=5d9680fc7e97b57527c4a94d2bba32aeff4a195e", "patch": "@@ -0,0 +1,1001 @@\n+// Translation of object-related things to LLVM IR.\n+\n+import std::str;\n+import std::option;\n+import option::none;\n+import option::some;\n+\n+import lib::llvm::llvm;\n+import lib::llvm::Bool;\n+import lib::llvm::True;\n+import lib::llvm::llvm::TypeRef;\n+import lib::llvm::llvm::ValueRef;\n+\n+import back::abi;\n+import back::link::mangle_internal_name_by_path;\n+import back::link::mangle_internal_name_by_path_and_seq;\n+import syntax::ast;\n+import syntax::codemap::span;\n+\n+import trans_common::*;\n+import trans::*;\n+\n+export trans_anon_obj;\n+export trans_obj;\n+\n+// trans_obj: creates an LLVM function that is the object constructor for the\n+// object being translated.\n+fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n+             ctor_id: ast::node_id, ty_params: &[ast::ty_param]) {\n+    // To make a function, we have to create a function context and, inside\n+    // that, a number of block contexts for which code is generated.\n+\n+    let ccx = cx.ccx;\n+    let llctor_decl;\n+    alt ccx.item_ids.find(ctor_id) {\n+      some(x) { llctor_decl = x; }\n+      _ { cx.ccx.sess.span_fatal(sp, \"unbound llctor_decl in trans_obj\"); }\n+    }\n+    // Much like trans_fn, we must create an LLVM function, but since we're\n+    // starting with an ast::_obj rather than an ast::_fn, we have some setup\n+    // work to do.\n+\n+    // The fields of our object will become the arguments to the function\n+    // we're creating.\n+\n+    let fn_args: [ast::arg] = ~[];\n+    for f: ast::obj_field  in ob.fields {\n+        fn_args +=\n+            ~[{mode: ast::alias(false), ty: f.ty, ident: f.ident, id: f.id}];\n+    }\n+    let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n+\n+    // Both regular arguments and type parameters are handled here.\n+    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n+                              ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n+                              ty_params);\n+    let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n+    copy_args_to_allocas(fcx, fn_args, arg_tys);\n+\n+    //  Create the first block context in the function and keep a handle on it\n+    //  to pass to finish_fn later.\n+    let bcx = new_top_block_ctxt(fcx);\n+    let lltop = bcx.llbb;\n+\n+    // Pick up the type of this object by looking at our own output type, that\n+    // is, the output type of the object constructor we're building.\n+    let self_ty = ty::ret_ty_of_fn(ccx.tcx, ctor_id);\n+\n+    // Set up the two-word pair that we're going to return from the object\n+    // constructor we're building.  The two elements of this pair will be a\n+    // vtable pointer and a body pointer.  (llretptr already points to the\n+    // place where this two-word pair should go; it was pre-allocated by the\n+    // caller of the function.)\n+    let pair = bcx.fcx.llretptr;\n+\n+    // Grab onto the first and second elements of the pair.\n+    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n+    // of 'pair'.\n+    let pair_vtbl =\n+        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_box =\n+        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_box)]);\n+\n+    // Make a vtable for this object: a static array of pointers to functions.\n+    // It will be located in the read-only memory of the executable we're\n+    // creating and will contain ValueRefs for all of this object's methods.\n+    // create_vtbl returns a pointer to the vtable, which we store.\n+    let vtbl = create_vtbl(cx, sp, self_ty, ob, ty_params, none, ~[]);\n+    vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n+\n+    bcx.build.Store(vtbl, pair_vtbl);\n+\n+    // Next we have to take care of the other half of the pair we're\n+    // returning: a boxed (reference-counted) tuple containing a tydesc,\n+    // typarams, and fields.\n+\n+    // FIXME: What about inner_obj?  Do we have to think about it here?\n+    // (Pertains to issues #538/#539/#540/#543.)\n+\n+    let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n+\n+    if std::ivec::len[ast::ty_param](ty_params) == 0u &&\n+           std::ivec::len[ty::arg](arg_tys) == 0u {\n+        // If the object we're translating has no fields or type parameters,\n+        // there's not much to do.\n+\n+        // Store null into pair, if no args or typarams.\n+        bcx.build.Store(C_null(llbox_ty), pair_box);\n+    } else {\n+        // Otherwise, we have to synthesize a big structural type for the\n+        // object body.\n+        let obj_fields: [ty::t] = ~[];\n+        for a: ty::arg  in arg_tys { obj_fields += ~[a.ty]; }\n+\n+        // Tuple type for fields: [field, ...]\n+        let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, obj_fields);\n+\n+        let tydesc_ty = ty::mk_type(ccx.tcx);\n+        let tps: [ty::t] = ~[];\n+        for tp: ast::ty_param  in ty_params { tps += ~[tydesc_ty]; }\n+\n+        // Tuple type for typarams: [typaram, ...]\n+        let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, tps);\n+\n+        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n+        let body_ty: ty::t =\n+            ty::mk_imm_tup(ccx.tcx, ~[tydesc_ty, typarams_ty, fields_ty]);\n+\n+        // Hand this type we've synthesized off to trans_malloc_boxed, which\n+        // allocates a box, including space for a refcount.\n+        let box = trans_malloc_boxed(bcx, body_ty);\n+        bcx = box.bcx;\n+        let body = box.body;\n+\n+        // Put together a tydesc for the body, so that the object can later be\n+        // freed by calling through its tydesc.\n+\n+        // Every object (not just those with type parameters) needs to have a\n+        // tydesc to describe its body, since all objects have unknown type to\n+        // the user of the object.  So the tydesc is needed to keep track of\n+        // the types of the object's fields, so that the fields can be freed\n+        // later.\n+\n+        let body_tydesc =\n+            GEP_tup_like(bcx, body_ty, body,\n+                         ~[0, abi::obj_body_elt_tydesc]);\n+        bcx = body_tydesc.bcx;\n+        let ti = none[@tydesc_info];\n+        let body_td = get_tydesc(bcx, body_ty, true, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+        bcx = body_td.bcx;\n+        bcx.build.Store(body_td.val, body_tydesc.val);\n+\n+        // Copy the object's type parameters and fields into the space we\n+        // allocated for the object body.  (This is something like saving the\n+        // lexical environment of a function in its closure: the \"captured\n+        // typarams\" are any type parameters that are passed to the object\n+        // constructor and are then available to the object's methods.\n+        // Likewise for the object's fields.)\n+\n+        // Copy typarams into captured typarams.\n+        let body_typarams =\n+            GEP_tup_like(bcx, body_ty, body,\n+                         ~[0, abi::obj_body_elt_typarams]);\n+        bcx = body_typarams.bcx;\n+        let i: int = 0;\n+        for tp: ast::ty_param  in ty_params {\n+            let typaram = bcx.fcx.lltydescs.(i);\n+            let capture =\n+                GEP_tup_like(bcx, typarams_ty, body_typarams.val, ~[0, i]);\n+            bcx = capture.bcx;\n+            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n+            i += 1;\n+        }\n+\n+        // Copy args into body fields.\n+        let body_fields =\n+            GEP_tup_like(bcx, body_ty, body,\n+                         ~[0, abi::obj_body_elt_fields]);\n+        bcx = body_fields.bcx;\n+        i = 0;\n+        for f: ast::obj_field  in ob.fields {\n+            alt bcx.fcx.llargs.find(f.id) {\n+              some(arg1) {\n+                let arg = load_if_immediate(bcx, arg1, arg_tys.(i).ty);\n+                let field =\n+                    GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n+                bcx = field.bcx;\n+                bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n+                i += 1;\n+              }\n+              none. {\n+                bcx_ccx(bcx).sess.span_fatal(f.ty.span,\n+                                             \"internal error in trans_obj\");\n+              }\n+            }\n+        }\n+\n+        // Store box ptr in outer pair.\n+        let p = bcx.build.PointerCast(box.box, llbox_ty);\n+        bcx.build.Store(p, pair_box);\n+    }\n+    bcx.build.RetVoid();\n+\n+    // Insert the mandatory first few basic blocks before lltop.\n+    finish_fn(fcx, lltop);\n+}\n+\n+// trans_anon_obj: create and return a pointer to an object.  This code\n+// differs from trans_obj in that, rather than creating an object constructor\n+// function and putting it in the generated code as an object item, we are\n+// instead \"inlining\" the construction of the object and returning the object\n+// itself.\n+fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n+                  id: ast::node_id) -> result {\n+\n+\n+    let ccx = bcx_ccx(bcx);\n+\n+    // Fields.\n+    // FIXME (part of issue #538): Where do we fill in the field *values* from\n+    // the outer object?\n+    let additional_fields: [ast::anon_obj_field] = ~[];\n+    let additional_field_vals: [result] = ~[];\n+    let additional_field_tys: [ty::t] = ~[];\n+    alt anon_obj.fields {\n+      none. { }\n+      some(fields) {\n+        additional_fields = fields;\n+        for f: ast::anon_obj_field  in fields {\n+            additional_field_tys += ~[node_id_type(ccx, f.id)];\n+            additional_field_vals += ~[trans_expr(bcx, f.expr)];\n+        }\n+      }\n+    }\n+\n+    // Get the type of the eventual entire anonymous object, possibly with\n+    // extensions.  NB: This type includes both inner and outer methods.\n+    let outer_obj_ty = ty::node_id_to_type(ccx.tcx, id);\n+\n+    // Create a vtable for the anonymous object.\n+\n+    // create_vtbl() wants an ast::_obj and all we have is an ast::anon_obj,\n+    // so we need to roll our own.  NB: wrapper_obj includes only outer\n+    // methods, not inner ones.\n+    let wrapper_obj: ast::_obj =\n+        {fields:\n+             std::ivec::map(ast::obj_field_from_anon_obj_field,\n+                            additional_fields),\n+         methods: anon_obj.methods};\n+\n+    let inner_obj_ty: ty::t;\n+    let vtbl;\n+    alt anon_obj.inner_obj {\n+      none. {\n+        // We need a dummy inner_obj_ty for setting up the object body\n+        // later.\n+        inner_obj_ty = ty::mk_type(ccx.tcx);\n+\n+        // If there's no inner_obj -- that is, if we're just adding new\n+        // fields rather than extending an existing object -- then we just\n+        // pass the outer object to create_vtbl().  Our vtable won't need\n+        // to have any forwarding slots.\n+        vtbl =\n+            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[], none,\n+                        additional_field_tys);\n+      }\n+      some(e) {\n+        // TODO: What makes more sense to get the type of an expr --\n+        // calling ty::expr_ty(ccx.tcx, e) on it or calling\n+        // ty::node_id_to_type(ccx.tcx, id) on its id?\n+        inner_obj_ty = ty::expr_ty(ccx.tcx, e);\n+        //inner_obj_ty = ty::node_id_to_type(ccx.tcx, e.id);\n+\n+        // If there's a inner_obj, we pass its type along to create_vtbl().\n+        // Part of what create_vtbl() will do is take the set difference\n+        // of methods defined on the original and methods being added.\n+        // For every method defined on the original that does *not* have\n+        // one with a matching name and type being added, we'll need to\n+        // create a forwarding slot.  And, of course, we need to create a\n+        // normal vtable entry for every method being added.\n+        vtbl =\n+            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[],\n+                        some(inner_obj_ty), additional_field_tys);\n+      }\n+    }\n+\n+    // Allocate the object that we're going to return.\n+    let pair = alloca(bcx, ccx.rust_object_type);\n+\n+    // Take care of cleanups.\n+    let t = node_id_type(ccx, id);\n+    add_clean_temp(bcx, pair, t);\n+\n+    // Grab onto the first and second elements of the pair.\n+    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n+    // of 'pair'.\n+    let pair_vtbl =\n+        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_box =\n+        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_box)]);\n+\n+    vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n+    bcx.build.Store(vtbl, pair_vtbl);\n+\n+    // Next we have to take care of the other half of the pair we're\n+    // returning: a boxed (reference-counted) tuple containing a tydesc,\n+    // typarams, fields, and a pointer to our inner_obj.\n+    let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n+\n+    if std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n+           anon_obj.inner_obj == none {\n+        // If the object we're translating has no fields and no inner_obj,\n+        // there's not much to do.\n+        bcx.build.Store(C_null(llbox_ty), pair_box);\n+    } else {\n+\n+        // Synthesize a tuple type for fields: [field, ...]\n+        let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, additional_field_tys);\n+\n+        // Type for tydescs.\n+        let tydesc_ty: ty::t = ty::mk_type(ccx.tcx);\n+\n+        // Placeholder for non-existent typarams, since anon objs don't have\n+        // them.\n+        let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, ~[]);\n+\n+        // Tuple type for body:\n+        // [tydesc, [typaram, ...], [field, ...], inner_obj]\n+        let body_ty: ty::t =\n+            ty::mk_imm_tup(ccx.tcx,\n+                           ~[tydesc_ty, typarams_ty, fields_ty,\n+                             inner_obj_ty]);\n+\n+        // Hand this type we've synthesized off to trans_malloc_boxed, which\n+        // allocates a box, including space for a refcount.\n+        let box = trans_malloc_boxed(bcx, body_ty);\n+        bcx = box.bcx;\n+        let body = box.body;\n+\n+        // Put together a tydesc for the body, so that the object can later be\n+        // freed by calling through its tydesc.\n+\n+        // Every object (not just those with type parameters) needs to have a\n+        // tydesc to describe its body, since all objects have unknown type to\n+        // the user of the object.  So the tydesc is needed to keep track of\n+        // the types of the object's fields, so that the fields can be freed\n+        // later.\n+        let body_tydesc =\n+            GEP_tup_like(bcx, body_ty, body,\n+                         ~[0, abi::obj_body_elt_tydesc]);\n+        bcx = body_tydesc.bcx;\n+        let ti = none[@tydesc_info];\n+        let body_td = get_tydesc(bcx, body_ty, true, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+        bcx = body_td.bcx;\n+        bcx.build.Store(body_td.val, body_tydesc.val);\n+\n+        // Copy the object's fields into the space we allocated for the object\n+        // body.  (This is something like saving the lexical environment of a\n+        // function in its closure: the fields were passed to the object\n+        // constructor and are now available to the object's methods.\n+        let body_fields =\n+            GEP_tup_like(bcx, body_ty, body,\n+                         ~[0, abi::obj_body_elt_fields]);\n+        bcx = body_fields.bcx;\n+        let i: int = 0;\n+        for f: ast::anon_obj_field  in additional_fields {\n+            // FIXME (part of issue #538): make this work eventually, when we\n+            // have additional field exprs in the AST.\n+            load_if_immediate(bcx, additional_field_vals.(i).val,\n+                              additional_field_tys.(i));\n+\n+            let field =\n+                GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n+            bcx = field.bcx;\n+            bcx =\n+                copy_val(bcx, INIT, field.val, additional_field_vals.(i).val,\n+                         additional_field_tys.(i)).bcx;\n+            i += 1;\n+        }\n+\n+        // If there's a inner_obj, copy a pointer to it into the object's\n+        // body.\n+        alt anon_obj.inner_obj {\n+          none. { }\n+          some(e) {\n+            // If inner_obj (the object being extended) exists, translate it.\n+            // Translating inner_obj returns a ValueRef (pointer to a 2-word\n+            // value) wrapped in a result.\n+            let inner_obj_val: result = trans_expr(bcx, e);\n+\n+            let body_inner_obj =\n+                GEP_tup_like(bcx, body_ty, body,\n+                             ~[0, abi::obj_body_elt_inner_obj]);\n+            bcx = body_inner_obj.bcx;\n+            bcx =\n+                copy_val(bcx, INIT, body_inner_obj.val, inner_obj_val.val,\n+                         inner_obj_ty).bcx;\n+          }\n+        }\n+\n+        // Store box ptr in outer pair.\n+        let p = bcx.build.PointerCast(box.box, llbox_ty);\n+        bcx.build.Store(p, pair_box);\n+    }\n+\n+    // return the object we built.\n+    ret rslt(bcx, pair);\n+}\n+\n+// Used only inside create_vtbl and create_backwarding_vtbl to distinguish\n+// different kinds of slots we'll have to create.\n+tag vtbl_mthd {\n+    // Normal methods are complete AST nodes, but for forwarding methods,\n+    // the only information we'll have about them is their type.\n+    normal_mthd(@ast::method);\n+    fwding_mthd(@ty::method);\n+}\n+\n+// Alphabetize ast::methods by ident.  A helper for create_vtbl.\n+fn ast_mthd_lteq(a: &@ast::method, b: &@ast::method) -> bool {\n+    ret str::lteq(a.node.ident, b.node.ident);\n+}\n+\n+// Alphabetize vtbl_mthds by ident.  A helper for create_vtbl.\n+fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n+    alt a {\n+      normal_mthd(ma) {\n+        alt b {\n+          normal_mthd(mb) { ret str::lteq(ma.node.ident, mb.node.ident); }\n+          fwding_mthd(mb) { ret str::lteq(ma.node.ident, mb.ident); }\n+        }\n+      }\n+      fwding_mthd(ma) {\n+        alt b {\n+          normal_mthd(mb) { ret str::lteq(ma.ident, mb.node.ident); }\n+          fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n+        }\n+      }\n+    }\n+}\n+\n+// Used by create_vtbl to filter a list of methods to remove the ones that we\n+// don't need forwarding slots for.\n+fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n+                addtl_meths: [@ast::method]) ->\n+    option::t[vtbl_mthd] {\n+\n+    // Since m is a fwding_mthd, and we're checking to see if it's in\n+    // addtl_meths (which only contains normal_mthds), we can't just check if\n+    // it's a member of addtl_meths.  Instead, we have to go through\n+    // addtl_meths and see if there's some method in it that has the same name\n+    // as m.\n+    alt m {\n+      fwding_mthd(fm) {\n+        for am: @ast::method in addtl_meths {\n+            if str::eq(am.node.ident, fm.ident) { ret none; }\n+        }\n+        ret some(fwding_mthd(fm));\n+      }\n+      normal_mthd(_) {\n+        cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any \\\n+                        normal_mthds in meths here\");\n+      }\n+    }\n+}\n+\n+// Create a vtable for an object being translated.  Returns a pointer into\n+// read-only memory.\n+fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n+               ob: &ast::_obj, ty_params: &[ast::ty_param],\n+               inner_obj_ty: option::t[ty::t],\n+               additional_field_tys: &[ty::t]) -> ValueRef {\n+\n+    let llmethods: [ValueRef] = ~[];\n+\n+    alt inner_obj_ty {\n+      none. {\n+        // Sort and process all the methods.\n+        let meths =\n+            std::sort::ivector::merge_sort[@ast::method]\n+            (bind ast_mthd_lteq(_, _), ob.methods);\n+\n+        for m: @ast::method in meths {\n+            llmethods += ~[process_normal_mthd(cx, m, outer_obj_ty,\n+                                               ty_params)];\n+        }\n+      }\n+      some(inner_obj_ty) {\n+        // If this vtable is being created for an extended object, then the\n+        // vtable needs to contain 'forwarding slots' for methods that were on\n+        // the original object and are not being overridden by the extended\n+        // one.  So, to find the set of methods that we need forwarding slots\n+        // for, we need to take the set difference of inner_obj_methods\n+        // (methods on the original object) and ob.methods (methods being\n+        // added, whether entirely new or overriding).\n+\n+        // inner_obj_ty is the type of the inner object being forwarded to,\n+        // and \"ob\" is the wrapper object.  We need to take apart\n+        // inner_obj_ty, which is the type of the object being forwarded to\n+        // (it had better have an object type with methods!) and put those\n+        // original methods onto the list of methods we need forwarding\n+        // methods for.\n+\n+        let meths: [vtbl_mthd] = ~[];\n+\n+        // Gather up methods on the original object in 'meths'.\n+        alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n+          ty::ty_obj(inner_obj_methods) {\n+            for m: ty::method  in inner_obj_methods {\n+                meths += ~[fwding_mthd(@m)];\n+            }\n+          }\n+          _ {\n+            cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \\\n+                            non-object\");\n+          }\n+        }\n+\n+        // Now, filter out any methods that we don't need forwarding slots\n+        // for, because they're being overridden.\n+        let f = bind filtering_fn(cx, _, ob.methods);\n+        meths = std::ivec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n+\n+        // And now add the additional ones, both overriding ones and entirely\n+        // new ones.  These will just be normal methods.\n+        for m: @ast::method in ob.methods { meths += ~[normal_mthd(m)]; }\n+\n+        // Sort all the methods and process them.\n+        meths =\n+            std::sort::ivector::merge_sort[vtbl_mthd]\n+            (bind vtbl_mthd_lteq(_, _), meths);\n+\n+        let backwarding_vtbl: ValueRef =\n+            create_backwarding_vtbl(cx, sp, inner_obj_ty, outer_obj_ty);\n+\n+        for m: vtbl_mthd in meths {\n+            alt m {\n+              normal_mthd(nm) {\n+                llmethods +=\n+                    ~[process_normal_mthd(cx, nm, outer_obj_ty, ty_params)];\n+              }\n+              fwding_mthd(fm) {\n+                llmethods +=\n+                    ~[process_fwding_mthd(cx, sp, fm, ty_params, inner_obj_ty,\n+                                          backwarding_vtbl,\n+                                          additional_field_tys)];\n+              }\n+            }\n+        }\n+      }\n+    }\n+\n+    let vtbl = C_struct(llmethods);\n+    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + ~[\"vtbl\"]);\n+    let gvar =\n+        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n+    llvm::LLVMSetInitializer(gvar, vtbl);\n+    llvm::LLVMSetGlobalConstant(gvar, True);\n+    llvm::LLVMSetLinkage(gvar,\n+                         lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n+    ret gvar;\n+}\n+\n+fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n+                           outer_obj_ty: ty::t) -> ValueRef {\n+\n+    // This vtbl needs to have slots for all of the methods on an inner\n+    // object, and it needs to forward them to the corresponding slots on the\n+    // outer object.  All we know about either one are their types.\n+\n+    let llmethods: [ValueRef] = ~[];\n+    let meths: [ty::method]= ~[];\n+\n+    // Gather up methods on the inner object.\n+    alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n+        ty::ty_obj(inner_obj_methods) {\n+            for m: ty::method in inner_obj_methods {\n+                meths += ~[m];\n+            }\n+        }\n+        _ {\n+            // Shouldn't happen.\n+            cx.ccx.sess.bug(\"create_backwarding_vtbl(): trying to extend a \\\n+                            non-object\");\n+        }\n+    }\n+\n+    // Methods should have already been sorted, so no need to do so again.\n+    for m: ty::method in meths {\n+        // We pass outer_obj_ty to process_fwding_mthd() because it's\n+        // the one being forwarded to.\n+        llmethods += ~[process_bkwding_mthd(\n+            cx, sp, @m, ~[], outer_obj_ty, ~[])];\n+    }\n+\n+    let vtbl = C_struct(llmethods);\n+    let vtbl_name =\n+        mangle_internal_name_by_path(cx.ccx,\n+                                     cx.path + ~[\"backwarding_vtbl\"]);\n+    let gvar =\n+        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n+    llvm::LLVMSetInitializer(gvar, vtbl);\n+    llvm::LLVMSetGlobalConstant(gvar, True);\n+    llvm::LLVMSetLinkage(gvar,\n+                         lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n+\n+    ret gvar;\n+\n+}\n+\n+\n+// process_bkwding_mthd: Create the backwarding function that appears in a\n+// backwarding vtable slot.\n+//\n+// Backwarding functions are used in situations where method calls dispatch\n+// back through an outer object.  For example, suppose an inner object has\n+// methods foo and bar, and bar contains the call self.foo().  We extend that\n+// object with a foo method that overrides the inner foo.  Now, a call to\n+// outer.bar() should send us to to inner.bar() via a normal forwarding\n+// function, and then to self.foo().  But inner.bar() was already compiled\n+// under the assumption that self.foo() is inner.foo(), when we really want to\n+// reach outer.foo().  So, we give 'self' a vtable of backwarding functions,\n+// one for each method on inner, each of which takes all the same arguments as\n+// the corresponding method on inner does, calls that method on outer, and\n+// returns the value returned from that call.\n+fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n+                       ty_params: &[ast::ty_param], outer_obj_ty: ty::t,\n+                       additional_field_tys: &[ty::t]) -> ValueRef {\n+\n+    // Create a local context that's aware of the name of the method we're\n+    // creating.\n+    let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n+\n+    // Make up a name for the backwarding function.\n+    let fn_name: str = \"backwarding_fn\";\n+    let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n+                                                      fn_name);\n+\n+    // Get the backwarding function's type and declare it.\n+    let llbackwarding_fn_ty: TypeRef =\n+        type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n+                        std::ivec::len[ast::ty_param](ty_params));\n+    let llbackwarding_fn: ValueRef =\n+        decl_internal_fastcall_fn(cx.ccx.llmod, s, llbackwarding_fn_ty);\n+\n+    // Create a new function context and block context for the backwarding\n+    // function, holding onto a pointer to the first block.\n+    let fcx = new_fn_ctxt(cx, sp, llbackwarding_fn);\n+    let bcx = new_top_block_ctxt(fcx);\n+    let lltop = bcx.llbb;\n+\n+    // The self-object will arrive in the backwarding function via the llenv\n+    // argument, but we need to jump past the first item in the self-stack to\n+    // get to the one we really want.\n+\n+    // Cast to self-stack's type.\n+    let llenv = bcx.build.PointerCast(\n+        fcx.llenv,\n+        T_ptr(T_struct(~[cx.ccx.rust_object_type,\n+                         T_ptr(cx.ccx.rust_object_type)])));\n+\n+    let llself_obj_ptr = bcx.build.GEP(llenv,\n+                                       ~[C_int(0),\n+                                         C_int(1)]);\n+    llself_obj_ptr = bcx.build.Load(llself_obj_ptr);\n+\n+    // Cast it back to pointer-to-object-type, so LLVM won't complain.\n+    llself_obj_ptr = bcx.build.PointerCast(llself_obj_ptr,\n+                                           T_ptr(cx.ccx.rust_object_type));\n+\n+    // The 'llretptr' that will arrive in the backwarding function we're\n+    // creating also needs to be the correct type.  Cast it to the method's\n+    // return type, if necessary.\n+    let llretptr = fcx.llretptr;\n+    if ty::type_contains_params(cx.ccx.tcx, m.output) {\n+        let llretty = type_of_inner(cx.ccx, sp, m.output);\n+        llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n+    }\n+\n+    // Get the index of the method we want.\n+    let ix: uint = 0u;\n+    alt ty::struct(bcx_tcx(bcx), outer_obj_ty) {\n+      ty::ty_obj(methods) {\n+        ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n+      }\n+      _ {\n+        // Shouldn't happen.\n+        cx.ccx.sess.bug(\"process_bkwding_mthd(): non-object type passed \\\n+                        as outer_obj_ty\");\n+      }\n+    }\n+\n+    // Pick out the method being backwarded to from the outer object's vtable.\n+    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n+\n+    let llouter_obj_vtbl =\n+        bcx.build.GEP(llself_obj_ptr,\n+                      ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n+    llouter_obj_vtbl = bcx.build.Load(llouter_obj_vtbl);\n+    llouter_obj_vtbl = bcx.build.PointerCast(llouter_obj_vtbl, vtbl_type);\n+\n+    let llouter_mthd =\n+        bcx.build.GEP(llouter_obj_vtbl, ~[C_int(0), C_int(ix as int)]);\n+\n+    // Set up the outer method to be called.\n+    let outer_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n+    let llouter_mthd_ty =\n+        type_of_fn_full(bcx_ccx(bcx), sp,\n+                        ty::ty_fn_proto(bcx_tcx(bcx), outer_mthd_ty), true,\n+                        m.inputs, m.output,\n+                        std::ivec::len[ast::ty_param](ty_params));\n+    llouter_mthd =\n+        bcx.build.PointerCast(llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n+    llouter_mthd = bcx.build.Load(llouter_mthd);\n+\n+    // Set up the three implicit arguments to the outer method we'll need\n+    // to call.\n+    let self_arg = llself_obj_ptr;\n+    let llouter_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_arg];\n+\n+    // Copy the explicit arguments that are being passed into the forwarding\n+    // function (they're in fcx.llargs) to llouter_mthd_args.\n+\n+    let a: uint = 3u; // retptr, task ptr, env come first\n+    let passed_arg: ValueRef = llvm::LLVMGetParam(llbackwarding_fn, a);\n+    for arg: ty::arg  in m.inputs {\n+        if arg.mode == ty::mo_val {\n+            passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n+        }\n+        llouter_mthd_args += ~[passed_arg];\n+        a += 1u;\n+    }\n+\n+    // And, finally, call the outer method.\n+    bcx.build.FastCall(llouter_mthd, llouter_mthd_args);\n+\n+    bcx.build.RetVoid();\n+    finish_fn(fcx, lltop);\n+\n+    ret llbackwarding_fn;\n+\n+}\n+\n+// process_fwding_mthd: Create the forwarding function that appears in a\n+// vtable slot for method calls that need to forward to another object.  A\n+// helper function for create_vtbl.\n+//\n+// Forwarding functions are used for method calls that fall through to an\n+// inner object.  For example, suppose an inner object has method foo and we\n+// extend it with a method bar.  The only version of 'foo' we have is on the\n+// inner object, but we would like to be able to call outer.foo().  So we use\n+// a forwarding function to make the foo method available on the outer object.\n+// It takes all the same arguments as the foo method on the inner object does,\n+// calls inner.foo() with those arguments, and then returns the value returned\n+// from that call.  (The inner object won't exist until run-time, but we know\n+// its type statically.)\n+fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n+                       ty_params: &[ast::ty_param], inner_obj_ty: ty::t,\n+                       backwarding_vtbl: ValueRef,\n+                       additional_field_tys: &[ty::t]) -> ValueRef {\n+\n+    // Create a local context that's aware of the name of the method we're\n+    // creating.\n+    let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n+\n+    // Make up a name for the forwarding function.\n+    let fn_name: str = \"forwarding_fn\";\n+    let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n+                                                      fn_name);\n+\n+    // Get the forwarding function's type and declare it.\n+    let llforwarding_fn_ty: TypeRef =\n+        type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n+                        std::ivec::len[ast::ty_param](ty_params));\n+    let llforwarding_fn: ValueRef =\n+        decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n+\n+    // Create a new function context and block context for the forwarding\n+    // function, holding onto a pointer to the first block.\n+    let fcx = new_fn_ctxt(cx, sp, llforwarding_fn);\n+    let bcx = new_top_block_ctxt(fcx);\n+    let lltop = bcx.llbb;\n+\n+    // The outer object will arrive in the forwarding function via the llenv\n+    // argument.\n+    let llself_obj_ptr = fcx.llenv;\n+\n+    // The 'llretptr' that will arrive in the forwarding function we're\n+    // creating also needs to be the correct type.  Cast it to the method's\n+    // return type, if necessary.\n+    let llretptr = fcx.llretptr;\n+    if ty::type_contains_params(cx.ccx.tcx, m.output) {\n+        let llretty = type_of_inner(cx.ccx, sp, m.output);\n+        llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n+    }\n+\n+    // Now, we have to get the the inner_obj's vtbl out of the self_obj.  This\n+    // is a multi-step process:\n+\n+    // First, grab the box out of the self_obj.  It contains a refcount and a\n+    // body.\n+    let llself_obj_box =\n+        bcx.build.GEP(llself_obj_ptr, ~[C_int(0), C_int(abi::obj_field_box)]);\n+    llself_obj_box = bcx.build.Load(llself_obj_box);\n+\n+    let ccx = bcx_ccx(bcx);\n+    let llbox_ty = T_opaque_obj_ptr(*ccx);\n+    llself_obj_box = bcx.build.PointerCast(llself_obj_box, llbox_ty);\n+\n+    // Now, reach into the box and grab the body.\n+    let llself_obj_body =\n+        bcx.build.GEP(llself_obj_box,\n+                      ~[C_int(0), C_int(abi::box_rc_field_body)]);\n+\n+    // Now, we need to figure out exactly what type the body is supposed to be\n+    // cast to.\n+\n+    // NB: This next part is almost flat-out copypasta from trans_anon_obj.\n+    // It would be great to factor this out.\n+\n+    // Synthesize a tuple type for fields: [field, ...]\n+    let fields_ty: ty::t = ty::mk_imm_tup(cx.ccx.tcx, additional_field_tys);\n+\n+    // Type for tydescs.\n+    let tydesc_ty: ty::t = ty::mk_type(cx.ccx.tcx);\n+\n+    // Placeholder for non-existent typarams, since anon objs don't have them.\n+    let typarams_ty: ty::t = ty::mk_imm_tup(cx.ccx.tcx, ~[]);\n+\n+    // Tuple type for body:\n+    // [tydesc, [typaram, ...], [field, ...], inner_obj]\n+\n+    let body_ty: ty::t =\n+        ty::mk_imm_tup(cx.ccx.tcx,\n+                       ~[tydesc_ty, typarams_ty, fields_ty, inner_obj_ty]);\n+\n+    // And cast to that type.\n+    llself_obj_body =\n+        bcx.build.PointerCast(llself_obj_body,\n+                              T_ptr(type_of(cx.ccx, sp, body_ty)));\n+\n+    // Now, reach into the body and grab the inner_obj.\n+    let llinner_obj =\n+        GEP_tup_like(bcx, body_ty, llself_obj_body,\n+                     ~[0, abi::obj_body_elt_inner_obj]);\n+    bcx = llinner_obj.bcx;\n+\n+    // And, now, somewhere in inner_obj is a vtable with an entry for the\n+    // method we want.  First, pick out the vtable, and then pluck that\n+    // method's entry out of the vtable so that the forwarding function can\n+    // call it.\n+    let llinner_obj_vtbl =\n+        bcx.build.GEP(llinner_obj.val,\n+                      ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n+    llinner_obj_vtbl = bcx.build.Load(llinner_obj_vtbl);\n+\n+    let llinner_obj_body =\n+        bcx.build.GEP(llinner_obj.val,\n+                      ~[C_int(0), C_int(abi::obj_field_box)]);\n+    llinner_obj_body = bcx.build.Load(llinner_obj_body);\n+\n+    // Get the index of the method we want.\n+    let ix: uint = 0u;\n+    alt ty::struct(bcx_tcx(bcx), inner_obj_ty) {\n+      ty::ty_obj(methods) {\n+        ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n+      }\n+      _ {\n+        // Shouldn't happen.\n+        cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \\\n+                        as target_obj_ty\");\n+      }\n+    }\n+\n+    // Pick out the original method from the vtable.\n+    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n+    llinner_obj_vtbl = bcx.build.PointerCast(llinner_obj_vtbl, vtbl_type);\n+\n+    let llorig_mthd =\n+        bcx.build.GEP(llinner_obj_vtbl, ~[C_int(0), C_int(ix as int)]);\n+\n+    // Set up the original method to be called.\n+    let orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n+    let llorig_mthd_ty =\n+        type_of_fn_full(bcx_ccx(bcx), sp,\n+                        ty::ty_fn_proto(bcx_tcx(bcx), orig_mthd_ty), true,\n+                        m.inputs, m.output,\n+                        std::ivec::len[ast::ty_param](ty_params));\n+    llorig_mthd =\n+        bcx.build.PointerCast(llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n+    llorig_mthd = bcx.build.Load(llorig_mthd);\n+\n+    // Set up the self-stack.\n+    let self_stack = alloca(bcx, T_struct(~[cx.ccx.rust_object_type,\n+                                            T_ptr(cx.ccx.rust_object_type)]));\n+    self_stack = populate_self_stack(bcx,\n+                                     self_stack,\n+                                     llself_obj_ptr,\n+                                     backwarding_vtbl,\n+                                     llinner_obj_body);\n+\n+    // Cast self_stack back to pointer-to-object-type to make LLVM happy.\n+    self_stack = bcx.build.PointerCast(self_stack,\n+                                       T_ptr(cx.ccx.rust_object_type));\n+\n+    // Set up the three implicit arguments to the original method we'll need\n+    // to call.\n+    let llorig_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_stack];\n+\n+    // Copy the explicit arguments that are being passed into the forwarding\n+    // function (they're in fcx.llargs) to llorig_mthd_args.\n+\n+    let a: uint = 3u; // retptr, task ptr, env come first\n+    let passed_arg: ValueRef = llvm::LLVMGetParam(llforwarding_fn, a);\n+    for arg: ty::arg  in m.inputs {\n+        if arg.mode == ty::mo_val {\n+            passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n+        }\n+        llorig_mthd_args += ~[passed_arg];\n+        a += 1u;\n+    }\n+\n+    // And, finally, call the original (inner) method.\n+    bcx.build.FastCall(llorig_mthd, llorig_mthd_args);\n+\n+    bcx.build.RetVoid();\n+    finish_fn(fcx, lltop);\n+\n+    ret llforwarding_fn;\n+}\n+\n+// process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n+// function for create_vtbl.\n+fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n+                       ty_params: &[ast::ty_param]) -> ValueRef {\n+\n+    let llfnty = T_nil();\n+    alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n+      ty::ty_fn(proto, inputs, output, _, _) {\n+        llfnty =\n+            type_of_fn_full(cx.ccx, m.span, proto, true, inputs, output,\n+                            std::ivec::len[ast::ty_param](ty_params));\n+      }\n+    }\n+    let mcx: @local_ctxt =\n+        @{path: cx.path + ~[\"method\", m.node.ident] with *cx};\n+    let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n+    let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n+\n+    // Every method on an object gets its node_id inserted into the\n+    // crate-wide item_ids map, together with the ValueRef that points to\n+    // where that method's definition will be in the executable.\n+    cx.ccx.item_ids.insert(m.node.id, llfn);\n+    cx.ccx.item_symbols.insert(m.node.id, s);\n+    trans_fn(mcx, m.span, m.node.meth, llfn, some(self_ty), ty_params,\n+             m.node.id);\n+\n+    ret llfn;\n+}\n+\n+// Update a self-stack structure ([[wrapper_self_pair], self_pair*]) to\n+// [[backwarding_vtbl*, inner_obj_body*], outer_obj*].\n+//\n+// We do this when we're receiving the outer object in a forwarding function\n+// via the llenv argument, and we want the forwarding function to call a\n+// method on a \"self\" that's inner-obj-shaped, but we also want to hold onto\n+// the outer obj for potential use later by backwarding functions.\n+fn populate_self_stack(bcx: @block_ctxt,\n+                       self_stack: ValueRef, outer_obj: ValueRef,\n+                       backwarding_vtbl: ValueRef, inner_obj_body: ValueRef)\n+    -> ValueRef {\n+\n+    // Drop the outer obj into the second slot.\n+    let self_pair_ptr = bcx.build.GEP(self_stack,\n+                            ~[C_int(0),\n+                              C_int(1)]);\n+    bcx.build.Store(outer_obj, self_pair_ptr);\n+\n+    // Drop in the backwarding vtbl.\n+    let wrapper_pair = bcx.build.GEP(self_stack,\n+                                     ~[C_int(0),\n+                                       C_int(0)]);\n+    let wrapper_vtbl_ptr = bcx.build.GEP(wrapper_pair,\n+                                         ~[C_int(0),\n+                                           C_int(0)]);\n+    let backwarding_vtbl_cast =\n+        bcx.build.PointerCast(backwarding_vtbl, T_ptr(T_empty_struct()));\n+    bcx.build.Store(backwarding_vtbl_cast, wrapper_vtbl_ptr);\n+\n+    // Drop in the inner obj body.\n+    let wrapper_body_ptr = bcx.build.GEP(wrapper_pair,\n+                                         ~[C_int(0),\n+                                           C_int(1)]);\n+    bcx.build.Store(inner_obj_body, wrapper_body_ptr);\n+\n+    ret self_stack;\n+}"}, {"sha": "8e174f3f736a678120769733ffb3881fc9ae34bb", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d9680fc7e97b57527c4a94d2bba32aeff4a195e/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5d9680fc7e97b57527c4a94d2bba32aeff4a195e/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=5d9680fc7e97b57527c4a94d2bba32aeff4a195e", "patch": "@@ -20,6 +20,7 @@ mod middle {\n     mod trans_alt;\n     mod trans_comm;\n     mod trans_dps;\n+    mod trans_objects;\n     mod trans_vec;\n     mod ty;\n     mod ast_map;"}]}