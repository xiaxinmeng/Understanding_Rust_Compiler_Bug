{"sha": "000d12f4aff47528a44a7cd8d8a26b644ac91cb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMGQxMmY0YWZmNDc1MjhhNDRhN2NkOGQ4YTI2YjY0NGFjOTFjYjA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-16T20:54:30Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-16T20:54:30Z"}, "message": "Use \"trait\" rather than \"iface\" where possible in docs", "tree": {"sha": "80d408136b4b811a102c97ac38bfb15611b8fc21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80d408136b4b811a102c97ac38bfb15611b8fc21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/000d12f4aff47528a44a7cd8d8a26b644ac91cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/000d12f4aff47528a44a7cd8d8a26b644ac91cb0", "html_url": "https://github.com/rust-lang/rust/commit/000d12f4aff47528a44a7cd8d8a26b644ac91cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/000d12f4aff47528a44a7cd8d8a26b644ac91cb0/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23704740c2e5ddf4e7c184a25d3eed216dd47b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/23704740c2e5ddf4e7c184a25d3eed216dd47b82", "html_url": "https://github.com/rust-lang/rust/commit/23704740c2e5ddf4e7c184a25d3eed216dd47b82"}], "stats": {"total": 57, "additions": 28, "deletions": 29}, "files": [{"sha": "d1def7cbf9399fc226b8cc659e759f78f474bf4b", "filename": "doc/rust.md", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/000d12f4aff47528a44a7cd8d8a26b644ac91cb0/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/000d12f4aff47528a44a7cd8d8a26b644ac91cb0/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=000d12f4aff47528a44a7cd8d8a26b644ac91cb0", "patch": "@@ -574,7 +574,7 @@ of [attributes](#attributes) attached to it.\n \n ~~~~~~~~ {.ebnf .gram}\n item : mod_item | fn_item | type_item | enum_item\n-     | res_item | iface_item | impl_item | foreign_mod_item ;\n+     | res_item | trait_item | impl_item | foreign_mod_item ;\n ~~~~~~~~\n \n An _item_ is a component of a crate; some module items can be defined in crate\n@@ -1259,7 +1259,7 @@ those methods for a specific type.\n # type surface = int;\n # type bounding_box = int;\n \n-iface shape {\n+trait shape {\n     fn draw(surface);\n     fn bounding_box() -> bounding_box;\n }\n@@ -1275,7 +1275,7 @@ These appear after the name, using the same syntax used in [generic\n functions](#generic-functions).\n \n ~~~~\n-iface seq<T> {\n+trait seq<T> {\n    fn len() -> uint;\n    fn elt_at(n: uint) -> T;\n    fn iter(fn(T));\n@@ -1290,7 +1290,7 @@ that have the parameter's type. For example:\n \n ~~~~\n # type surface = int;\n-# iface shape { fn draw(surface); }\n+# trait shape { fn draw(surface); }\n \n fn draw_twice<T: shape>(surface: surface, sh: T) {\n     sh.draw(surface);\n@@ -1301,33 +1301,33 @@ fn draw_twice<T: shape>(surface: surface, sh: T) {\n Trait items also define a type with the same name as the\n trait. Values of this type are created by\n [casting](#type-cast-expressions) values (of a type for which an\n-implementation of the given interface is in scope) to the interface\n+implementation of the given trait is in scope) to the trait\n type.\n \n ~~~~\n-# iface shape { }\n+# trait shape { }\n # impl of shape for int { }\n # let mycircle = 0;\n \n let myshape: shape = mycircle as shape;\n ~~~~\n \n-The resulting value is a reference counted box containing the value\n+The resulting value is a reference-counted box containing the value\n that was cast along with information that identify the methods of the\n-implementation that was used. Values with an interface type can always\n-have methods of their interface called on them, and can be used to\n-instantiate type parameters that are bounded on their interface.\n+implementation that was used. Values with a trait type can always\n+have methods from their trait called on them, and can be used to\n+instantiate type parameters that are bounded by their trait.\n \n ### Implementations\n \n-An _implementation item_ provides an implementation of an\n-[interface](#traits) for a type.\n+An _implementation item_ provides an implementation of a\n+[trait](#traits) for a type.\n \n ~~~~\n # type point = {x: float, y: float};\n # type surface = int;\n # type bounding_box = {x: float, y: float, width: float, height: float};\n-# iface shape { fn draw(surface); fn bounding_box() -> bounding_box; }\n+# trait shape { fn draw(surface); fn bounding_box() -> bounding_box; }\n # fn do_draw_circle(s: surface, c: circle) { }\n \n type circle = {radius: float, center: point};\n@@ -1342,16 +1342,16 @@ impl circle_shape of shape for circle {\n }\n ~~~~\n \n-This defines an implementation named `circle_shape` of interface\n+This defines an implementation named `circle_shape` of trait\n `shape` for type `circle`. The name of the implementation is the name\n by which it is imported and exported, but has no further significance.\n-It may be omitted to default to the name of the interface that was\n+It may be omitted to default to the name of the trait that was\n implemented. Implementation names do not conflict the way other names\n do: multiple implementations with the same name may exist in a scope at\n the same time.\n \n-It is possible to define an implementation without referencing an\n-interface. The methods in such an implementation can only be used\n+It is possible to define an implementation without referring to a trait.\n+The methods in such an implementation can only be used\n statically (as direct calls on the values of the type that the\n implementation targets). In such an implementation, the `of` clause is\n not given, and the name is mandatory.\n@@ -1365,17 +1365,17 @@ impl uint_loops for uint {\n }\n ~~~~\n \n-_When_ an interface is specified, all methods declared as part of the\n-interface must be present, with matching types and type parameter\n+_When_ a trait is specified, all methods declared as part of the\n+trait must be present, with matching types and type parameter\n counts, in the implementation.\n \n An implementation can take type parameters, which can be different\n-from the type parameters taken by the interface it implements. They\n+from the type parameters taken by the trait it implements. They\n are written after the name of the implementation, or if that is not\n specified, after the `impl` keyword.\n \n ~~~~\n-# iface seq<T> { }\n+# trait seq<T> { }\n \n impl <T> of seq<T> for ~[T] {\n     /* ... */\n@@ -1540,7 +1540,7 @@ statement block. The declared name may denote a new slot or a new item.\n \n An _item declaration statement_ has a syntactic form identical to an\n [item](#items) declaration within a module. Declaring an item -- a function,\n-enumeration, type, resource, interface, implementation or module -- locally\n+enumeration, type, resource, trait, implementation or module -- locally\n within a statement block is simply a way of restricting its scope to a narrow\n region containing all of its uses; it is otherwise identical in meaning to\n declaring the item outside the statement block.\n@@ -2763,8 +2763,7 @@ Every trait item (see [traits](#traits)) defines a type with the same name\n as the trait. For a trait `T`, cast expressions introduce values of type `T`:\n \n ~~~~~~~~\n-// doc extractor doesn't recognize trait -- fix it\n-iface printable {\n+trait printable {\n   fn to_str() -> ~str;\n }\n \n@@ -2811,7 +2810,7 @@ impl item. It refers to the type of the implicit `self` argument. For\n example, in:\n \n ~~~~~~\n-iface printable {\n+trait printable {\n   fn to_str() -> ~str;\n }\n \n@@ -2848,7 +2847,7 @@ Sendable\n Copyable\n   : This kind includes all types that can be copied. All types with\n     sendable kind are copyable, as are shared boxes, shared closures,\n-    interface types, and structural types built out of these.\n+    trait types, and structural types built out of these.\n Noncopyable\n   : [Resource](#resources) types, and every type that includes a\n     resource without storing it in a shared box, may not be copied.\n@@ -2933,10 +2932,10 @@ shared or unique boxes, and/or references. Sharing memory between tasks can\n only be accomplished using *unsafe* constructs, such as raw pointer\n operations or calling C code.\n \n-When a task sends a value satisfying the `send` interface over a channel, it\n+When a task sends a value that has the `send` trait over a channel, it\n loses ownership of the value sent and can no longer refer to it. This is\n statically guaranteed by the combined use of \"move semantics\" and the\n-compiler-checked _meaning_ of the `send` interface: it is only instantiated\n+compiler-checked _meaning_ of the `send` trait: it is only instantiated\n for (transitively) unique kinds of data constructor and pointers, never shared\n pointers.\n \n@@ -3117,7 +3116,7 @@ channels -- may lead to the same port.]\n Each port and channel can carry only one type of message. The message type is\n encoded as a parameter of the channel or port type. The message type of a\n channel is equal to the message type of the port it is bound to. The types of\n-messages must satisfy the `send` built-in interface.\n+messages must satisfy the `send` built-in trait.\n \n Messages are generally sent asynchronously, with optional\n rate-limiting on the transmit side.  Each port contains a message"}]}