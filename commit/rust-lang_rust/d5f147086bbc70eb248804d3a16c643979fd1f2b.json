{"sha": "d5f147086bbc70eb248804d3a16c643979fd1f2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZjE0NzA4NmJiYzcwZWIyNDg4MDRkM2ExNmM2NDM5NzlmZDFmMmI=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-31T15:34:37Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-07T23:31:58Z"}, "message": "De-indent all fmt::Display impls for later replacement to functions", "tree": {"sha": "7fffdadb4491aae25d8360534d472c5b5cadb661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fffdadb4491aae25d8360534d472c5b5cadb661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5f147086bbc70eb248804d3a16c643979fd1f2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5f147086bbc70eb248804d3a16c643979fd1f2b", "html_url": "https://github.com/rust-lang/rust/commit/d5f147086bbc70eb248804d3a16c643979fd1f2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5f147086bbc70eb248804d3a16c643979fd1f2b/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eefaee1af4cc3df09d2588638c2bb250fe6a30e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/eefaee1af4cc3df09d2588638c2bb250fe6a30e6", "html_url": "https://github.com/rust-lang/rust/commit/eefaee1af4cc3df09d2588638c2bb250fe6a30e6"}], "stats": {"total": 510, "additions": 255, "deletions": 255}, "files": [{"sha": "f3c40c8568bb655e9070d2b69f80b04ffe4cc695", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5f147086bbc70eb248804d3a16c643979fd1f2b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f147086bbc70eb248804d3a16c643979fd1f2b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d5f147086bbc70eb248804d3a16c643979fd1f2b", "patch": "@@ -290,11 +290,11 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime, ref bounds } => {\n                     clause.push_str(&format!(\"{}: {}\",\n-                                             lifetime,\n-                                             bounds.iter()\n-                                                   .map(|b| b.to_string())\n-                                                   .collect::<Vec<_>>()\n-                                                   .join(\" + \")));\n+                                                lifetime,\n+                                                bounds.iter()\n+                                                    .map(|b| b.to_string())\n+                                                    .collect::<Vec<_>>()\n+                                                    .join(\" + \")));\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n                     if f.alternate() {"}, {"sha": "1d1e54fc9eaba860fa814073352b5933818bdf7c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 233, "deletions": 233, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/d5f147086bbc70eb248804d3a16c643979fd1f2b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f147086bbc70eb248804d3a16c643979fd1f2b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d5f147086bbc70eb248804d3a16c643979fd1f2b", "patch": "@@ -1772,33 +1772,33 @@ fn print_entries(f: &mut fmt::Formatter<'_>, e: &FxHashSet<ItemEntry>, title: &s\n }\n \n impl fmt::Display for AllTypes {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f,\n+fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    write!(f,\n \"<h1 class='fqn'>\\\n-     <span class='out-of-band'>\\\n-         <span id='render-detail'>\\\n-             <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" title=\\\"collapse all docs\\\">\\\n-                 [<span class='inner'>&#x2212;</span>]\\\n-             </a>\\\n-         </span>\n-     </span>\n-     <span class='in-band'>List of all items</span>\\\n+    <span class='out-of-band'>\\\n+        <span id='render-detail'>\\\n+            <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" title=\\\"collapse all docs\\\">\\\n+                [<span class='inner'>&#x2212;</span>]\\\n+            </a>\\\n+        </span>\n+    </span>\n+    <span class='in-band'>List of all items</span>\\\n </h1>\")?;\n-        print_entries(f, &self.structs, \"Structs\", \"structs\")?;\n-        print_entries(f, &self.enums, \"Enums\", \"enums\")?;\n-        print_entries(f, &self.unions, \"Unions\", \"unions\")?;\n-        print_entries(f, &self.primitives, \"Primitives\", \"primitives\")?;\n-        print_entries(f, &self.traits, \"Traits\", \"traits\")?;\n-        print_entries(f, &self.macros, \"Macros\", \"macros\")?;\n-        print_entries(f, &self.attributes, \"Attribute Macros\", \"attributes\")?;\n-        print_entries(f, &self.derives, \"Derive Macros\", \"derives\")?;\n-        print_entries(f, &self.functions, \"Functions\", \"functions\")?;\n-        print_entries(f, &self.typedefs, \"Typedefs\", \"typedefs\")?;\n-        print_entries(f, &self.trait_aliases, \"Trait Aliases\", \"trait-aliases\")?;\n-        print_entries(f, &self.opaque_tys, \"Opaque Types\", \"opaque-types\")?;\n-        print_entries(f, &self.statics, \"Statics\", \"statics\")?;\n-        print_entries(f, &self.constants, \"Constants\", \"constants\")\n-    }\n+    print_entries(f, &self.structs, \"Structs\", \"structs\")?;\n+    print_entries(f, &self.enums, \"Enums\", \"enums\")?;\n+    print_entries(f, &self.unions, \"Unions\", \"unions\")?;\n+    print_entries(f, &self.primitives, \"Primitives\", \"primitives\")?;\n+    print_entries(f, &self.traits, \"Traits\", \"traits\")?;\n+    print_entries(f, &self.macros, \"Macros\", \"macros\")?;\n+    print_entries(f, &self.attributes, \"Attribute Macros\", \"attributes\")?;\n+    print_entries(f, &self.derives, \"Derive Macros\", \"derives\")?;\n+    print_entries(f, &self.functions, \"Functions\", \"functions\")?;\n+    print_entries(f, &self.typedefs, \"Typedefs\", \"typedefs\")?;\n+    print_entries(f, &self.trait_aliases, \"Trait Aliases\", \"trait-aliases\")?;\n+    print_entries(f, &self.opaque_tys, \"Opaque Types\", \"opaque-types\")?;\n+    print_entries(f, &self.statics, \"Statics\", \"statics\")?;\n+    print_entries(f, &self.constants, \"Constants\", \"constants\")\n+}\n }\n \n #[derive(Debug)]\n@@ -1829,27 +1829,27 @@ impl<'a> Settings<'a> {\n }\n \n impl<'a> fmt::Display for Settings<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f,\n+fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    write!(f,\n \"<h1 class='fqn'>\\\n-     <span class='in-band'>Rustdoc settings</span>\\\n+    <span class='in-band'>Rustdoc settings</span>\\\n </h1>\\\n <div class='settings'>{}</div>\\\n <script src='{}settings{}.js'></script>\",\n-               self.settings.iter()\n-                            .map(|(id, text, enabled)| {\n-                                format!(\"<div class='setting-line'>\\\n-                                             <label class='toggle'>\\\n-                                                <input type='checkbox' id='{}' {}>\\\n-                                                <span class='slider'></span>\\\n-                                             </label>\\\n-                                             <div>{}</div>\\\n-                                         </div>\", id, if *enabled { \" checked\" } else { \"\" }, text)\n-                            })\n-                            .collect::<String>(),\n-               self.root_path,\n-               self.suffix)\n-    }\n+            self.settings.iter()\n+                        .map(|(id, text, enabled)| {\n+                            format!(\"<div class='setting-line'>\\\n+                                            <label class='toggle'>\\\n+                                            <input type='checkbox' id='{}' {}>\\\n+                                            <span class='slider'></span>\\\n+                                            </label>\\\n+                                            <div>{}</div>\\\n+                                        </div>\", id, if *enabled { \" checked\" } else { \"\" }, text)\n+                        })\n+                        .collect::<String>(),\n+            self.root_path,\n+            self.suffix)\n+}\n }\n \n impl Context {\n@@ -2205,108 +2205,108 @@ where F: Fn(&mut fmt::Formatter<'_>) -> fmt::Result {\n }\n \n impl<'a> fmt::Display for Item<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        debug_assert!(!self.item.is_stripped());\n-        // Write the breadcrumb trail header for the top\n-        write!(fmt, \"<h1 class='fqn'><span class='out-of-band'>\")?;\n-        if let Some(version) = self.item.stable_since() {\n-            write!(fmt, \"<span class='since' title='Stable since Rust version {0}'>{0}</span>\",\n-                   version)?;\n-        }\n-        write!(fmt,\n-               \"<span id='render-detail'>\\\n-                   <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n-                      title=\\\"collapse all docs\\\">\\\n-                       [<span class='inner'>&#x2212;</span>]\\\n-                   </a>\\\n-               </span>\")?;\n-\n-        // Write `src` tag\n-        //\n-        // When this item is part of a `pub use` in a downstream crate, the\n-        // [src] link in the downstream documentation will actually come back to\n-        // this page, and this link will be auto-clicked. The `id` attribute is\n-        // used to find the link to auto-click.\n-        if self.cx.shared.include_sources && !self.item.is_primitive() {\n-            if let Some(l) = self.src_href() {\n-                write!(fmt, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n-                       l, \"goto source code\")?;\n-            }\n-        }\n-\n-        write!(fmt, \"</span>\")?; // out-of-band\n-        write!(fmt, \"<span class='in-band'>\")?;\n-        match self.item.inner {\n-            clean::ModuleItem(ref m) => if m.is_crate {\n-                    write!(fmt, \"Crate \")?;\n-                } else {\n-                    write!(fmt, \"Module \")?;\n-                },\n-            clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => write!(fmt, \"Function \")?,\n-            clean::TraitItem(..) => write!(fmt, \"Trait \")?,\n-            clean::StructItem(..) => write!(fmt, \"Struct \")?,\n-            clean::UnionItem(..) => write!(fmt, \"Union \")?,\n-            clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n-            clean::TypedefItem(..) => write!(fmt, \"Type Definition \")?,\n-            clean::MacroItem(..) => write!(fmt, \"Macro \")?,\n-            clean::ProcMacroItem(ref mac) => match mac.kind {\n-                MacroKind::Bang => write!(fmt, \"Macro \")?,\n-                MacroKind::Attr => write!(fmt, \"Attribute Macro \")?,\n-                MacroKind::Derive => write!(fmt, \"Derive Macro \")?,\n-            }\n-            clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n-            clean::StaticItem(..) | clean::ForeignStaticItem(..) => write!(fmt, \"Static \")?,\n-            clean::ConstantItem(..) => write!(fmt, \"Constant \")?,\n-            clean::ForeignTypeItem => write!(fmt, \"Foreign Type \")?,\n-            clean::KeywordItem(..) => write!(fmt, \"Keyword \")?,\n-            clean::OpaqueTyItem(..) => write!(fmt, \"Opaque Type \")?,\n-            clean::TraitAliasItem(..) => write!(fmt, \"Trait Alias \")?,\n-            _ => {\n-                // We don't generate pages for any other type.\n-                unreachable!();\n-            }\n-        }\n-        if !self.item.is_primitive() && !self.item.is_keyword() {\n-            let cur = &self.cx.current;\n-            let amt = if self.item.is_mod() { cur.len() - 1 } else { cur.len() };\n-            for (i, component) in cur.iter().enumerate().take(amt) {\n-                write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n-                       \"../\".repeat(cur.len() - i - 1),\n-                       component)?;\n-            }\n-        }\n-        write!(fmt, \"<a class=\\\"{}\\\" href=''>{}</a>\",\n-               self.item.type_(), self.item.name.as_ref().unwrap())?;\n-\n-        write!(fmt, \"</span></h1>\")?; // in-band\n-\n-        match self.item.inner {\n-            clean::ModuleItem(ref m) =>\n-                item_module(fmt, self.cx, self.item, &m.items),\n-            clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n-                item_function(fmt, self.cx, self.item, f),\n-            clean::TraitItem(ref t) => item_trait(fmt, self.cx, self.item, t),\n-            clean::StructItem(ref s) => item_struct(fmt, self.cx, self.item, s),\n-            clean::UnionItem(ref s) => item_union(fmt, self.cx, self.item, s),\n-            clean::EnumItem(ref e) => item_enum(fmt, self.cx, self.item, e),\n-            clean::TypedefItem(ref t, _) => item_typedef(fmt, self.cx, self.item, t),\n-            clean::MacroItem(ref m) => item_macro(fmt, self.cx, self.item, m),\n-            clean::ProcMacroItem(ref m) => item_proc_macro(fmt, self.cx, self.item, m),\n-            clean::PrimitiveItem(ref p) => item_primitive(fmt, self.cx, self.item, p),\n-            clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n-                item_static(fmt, self.cx, self.item, i),\n-            clean::ConstantItem(ref c) => item_constant(fmt, self.cx, self.item, c),\n-            clean::ForeignTypeItem => item_foreign_type(fmt, self.cx, self.item),\n-            clean::KeywordItem(ref k) => item_keyword(fmt, self.cx, self.item, k),\n-            clean::OpaqueTyItem(ref e, _) => item_opaque_ty(fmt, self.cx, self.item, e),\n-            clean::TraitAliasItem(ref ta) => item_trait_alias(fmt, self.cx, self.item, ta),\n-            _ => {\n-                // We don't generate pages for any other type.\n-                unreachable!();\n-            }\n+fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    debug_assert!(!self.item.is_stripped());\n+    // Write the breadcrumb trail header for the top\n+    write!(fmt, \"<h1 class='fqn'><span class='out-of-band'>\")?;\n+    if let Some(version) = self.item.stable_since() {\n+        write!(fmt, \"<span class='since' title='Stable since Rust version {0}'>{0}</span>\",\n+                version)?;\n+    }\n+    write!(fmt,\n+            \"<span id='render-detail'>\\\n+                <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n+                    title=\\\"collapse all docs\\\">\\\n+                    [<span class='inner'>&#x2212;</span>]\\\n+                </a>\\\n+            </span>\")?;\n+\n+    // Write `src` tag\n+    //\n+    // When this item is part of a `pub use` in a downstream crate, the\n+    // [src] link in the downstream documentation will actually come back to\n+    // this page, and this link will be auto-clicked. The `id` attribute is\n+    // used to find the link to auto-click.\n+    if self.cx.shared.include_sources && !self.item.is_primitive() {\n+        if let Some(l) = self.src_href() {\n+            write!(fmt, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                    l, \"goto source code\")?;\n+        }\n+    }\n+\n+    write!(fmt, \"</span>\")?; // out-of-band\n+    write!(fmt, \"<span class='in-band'>\")?;\n+    match self.item.inner {\n+        clean::ModuleItem(ref m) => if m.is_crate {\n+                write!(fmt, \"Crate \")?;\n+            } else {\n+                write!(fmt, \"Module \")?;\n+            },\n+        clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => write!(fmt, \"Function \")?,\n+        clean::TraitItem(..) => write!(fmt, \"Trait \")?,\n+        clean::StructItem(..) => write!(fmt, \"Struct \")?,\n+        clean::UnionItem(..) => write!(fmt, \"Union \")?,\n+        clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n+        clean::TypedefItem(..) => write!(fmt, \"Type Definition \")?,\n+        clean::MacroItem(..) => write!(fmt, \"Macro \")?,\n+        clean::ProcMacroItem(ref mac) => match mac.kind {\n+            MacroKind::Bang => write!(fmt, \"Macro \")?,\n+            MacroKind::Attr => write!(fmt, \"Attribute Macro \")?,\n+            MacroKind::Derive => write!(fmt, \"Derive Macro \")?,\n+        }\n+        clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n+        clean::StaticItem(..) | clean::ForeignStaticItem(..) => write!(fmt, \"Static \")?,\n+        clean::ConstantItem(..) => write!(fmt, \"Constant \")?,\n+        clean::ForeignTypeItem => write!(fmt, \"Foreign Type \")?,\n+        clean::KeywordItem(..) => write!(fmt, \"Keyword \")?,\n+        clean::OpaqueTyItem(..) => write!(fmt, \"Opaque Type \")?,\n+        clean::TraitAliasItem(..) => write!(fmt, \"Trait Alias \")?,\n+        _ => {\n+            // We don't generate pages for any other type.\n+            unreachable!();\n+        }\n+    }\n+    if !self.item.is_primitive() && !self.item.is_keyword() {\n+        let cur = &self.cx.current;\n+        let amt = if self.item.is_mod() { cur.len() - 1 } else { cur.len() };\n+        for (i, component) in cur.iter().enumerate().take(amt) {\n+            write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n+                    \"../\".repeat(cur.len() - i - 1),\n+                    component)?;\n+        }\n+    }\n+    write!(fmt, \"<a class=\\\"{}\\\" href=''>{}</a>\",\n+            self.item.type_(), self.item.name.as_ref().unwrap())?;\n+\n+    write!(fmt, \"</span></h1>\")?; // in-band\n+\n+    match self.item.inner {\n+        clean::ModuleItem(ref m) =>\n+            item_module(fmt, self.cx, self.item, &m.items),\n+        clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n+            item_function(fmt, self.cx, self.item, f),\n+        clean::TraitItem(ref t) => item_trait(fmt, self.cx, self.item, t),\n+        clean::StructItem(ref s) => item_struct(fmt, self.cx, self.item, s),\n+        clean::UnionItem(ref s) => item_union(fmt, self.cx, self.item, s),\n+        clean::EnumItem(ref e) => item_enum(fmt, self.cx, self.item, e),\n+        clean::TypedefItem(ref t, _) => item_typedef(fmt, self.cx, self.item, t),\n+        clean::MacroItem(ref m) => item_macro(fmt, self.cx, self.item, m),\n+        clean::ProcMacroItem(ref m) => item_proc_macro(fmt, self.cx, self.item, m),\n+        clean::PrimitiveItem(ref p) => item_primitive(fmt, self.cx, self.item, p),\n+        clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n+            item_static(fmt, self.cx, self.item, i),\n+        clean::ConstantItem(ref c) => item_constant(fmt, self.cx, self.item, c),\n+        clean::ForeignTypeItem => item_foreign_type(fmt, self.cx, self.item),\n+        clean::KeywordItem(ref k) => item_keyword(fmt, self.cx, self.item, k),\n+        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(fmt, self.cx, self.item, e),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(fmt, self.cx, self.item, ta),\n+        _ => {\n+            // We don't generate pages for any other type.\n+            unreachable!();\n         }\n     }\n }\n+}\n \n fn item_path(ty: ItemType, name: &str) -> String {\n     match ty {\n@@ -3834,9 +3834,9 @@ fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n         struct RendererStruct<'a, 'b, 'c>(&'a Context, Vec<&'b &'b Impl>, &'c clean::Item);\n \n         impl<'a, 'b, 'c> fmt::Display for RendererStruct<'a, 'b, 'c> {\n-            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                render_impls(self.0, fmt, &self.1, self.2)\n-            }\n+        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            render_impls(self.0, fmt, &self.1, self.2)\n+        }\n         }\n \n         let impls = RendererStruct(cx, concrete, containing_item).to_string();\n@@ -4264,97 +4264,97 @@ fn item_foreign_type(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item)\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-    fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n-        let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n-\n-        if it.is_struct() || it.is_trait() || it.is_primitive() || it.is_union()\n-            || it.is_enum() || it.is_mod() || it.is_typedef() {\n-            write!(buffer, \"<p class='location'>{}{}</p>\",\n-                match it.inner {\n-                    clean::StructItem(..) => \"Struct \",\n-                    clean::TraitItem(..) => \"Trait \",\n-                    clean::PrimitiveItem(..) => \"Primitive Type \",\n-                    clean::UnionItem(..) => \"Union \",\n-                    clean::EnumItem(..) => \"Enum \",\n-                    clean::TypedefItem(..) => \"Type Definition \",\n-                    clean::ForeignTypeItem => \"Foreign Type \",\n-                    clean::ModuleItem(..) => if it.is_crate() {\n-                        \"Crate \"\n-                    } else {\n-                        \"Module \"\n-                    },\n-                    _ => \"\",\n+fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n+    let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n+\n+    if it.is_struct() || it.is_trait() || it.is_primitive() || it.is_union()\n+        || it.is_enum() || it.is_mod() || it.is_typedef() {\n+        write!(buffer, \"<p class='location'>{}{}</p>\",\n+            match it.inner {\n+                clean::StructItem(..) => \"Struct \",\n+                clean::TraitItem(..) => \"Trait \",\n+                clean::PrimitiveItem(..) => \"Primitive Type \",\n+                clean::UnionItem(..) => \"Union \",\n+                clean::EnumItem(..) => \"Enum \",\n+                clean::TypedefItem(..) => \"Type Definition \",\n+                clean::ForeignTypeItem => \"Foreign Type \",\n+                clean::ModuleItem(..) => if it.is_crate() {\n+                    \"Crate \"\n+                } else {\n+                    \"Module \"\n                 },\n-                it.name.as_ref().unwrap());\n-        }\n-\n-        if it.is_crate() {\n-            if let Some(ref version) = cache().crate_version {\n-                write!(buffer,\n-                       \"<div class='block version'>\\\n-                        <p>Version {}</p>\\\n-                        </div>\",\n-                       version);\n-            }\n-        }\n-\n-        write!(buffer, \"<div class=\\\"sidebar-elems\\\">\");\n-        if it.is_crate() {\n-            write!(buffer, \"<a id='all-types' href='all.html'><p>See all {}'s items</p></a>\",\n-                   it.name.as_ref().expect(\"crates always have a name\"));\n-        }\n-        match it.inner {\n-            clean::StructItem(ref s) => sidebar_struct(buffer, it, s),\n-            clean::TraitItem(ref t) => sidebar_trait(buffer, it, t),\n-            clean::PrimitiveItem(ref p) => sidebar_primitive(buffer, it, p),\n-            clean::UnionItem(ref u) => sidebar_union(buffer, it, u),\n-            clean::EnumItem(ref e) => sidebar_enum(buffer, it, e),\n-            clean::TypedefItem(ref t, _) => sidebar_typedef(buffer, it, t),\n-            clean::ModuleItem(ref m) => sidebar_module(buffer, it, &m.items),\n-            clean::ForeignTypeItem => sidebar_foreign_type(buffer, it),\n-            _ => (),\n-        }\n-\n-        // The sidebar is designed to display sibling functions, modules and\n-        // other miscellaneous information. since there are lots of sibling\n-        // items (and that causes quadratic growth in large modules),\n-        // we refactor common parts into a shared JavaScript file per module.\n-        // still, we don't move everything into JS because we want to preserve\n-        // as much HTML as possible in order to allow non-JS-enabled browsers\n-        // to navigate the documentation (though slightly inefficiently).\n-\n-        write!(buffer, \"<p class='location'>\");\n-        for (i, name) in cx.current.iter().take(parentlen).enumerate() {\n-            if i > 0 {\n-                write!(buffer, \"::<wbr>\");\n-            }\n-            write!(buffer, \"<a href='{}index.html'>{}</a>\",\n-                   &cx.root_path()[..(cx.current.len() - i - 1) * 3],\n-                   *name);\n-        }\n-        write!(buffer, \"</p>\");\n-\n-        // Sidebar refers to the enclosing module, not this module.\n-        let relpath = if it.is_mod() { \"../\" } else { \"\" };\n-        write!(buffer,\n-               \"<script>window.sidebarCurrent = {{\\\n-                   name: '{name}', \\\n-                   ty: '{ty}', \\\n-                   relpath: '{path}'\\\n-                }};</script>\",\n-               name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-               ty = it.type_().css_class(),\n-               path = relpath);\n-        if parentlen == 0 {\n-            // There is no sidebar-items.js beyond the crate root path\n-            // FIXME maybe dynamic crate loading can be merged here\n-        } else {\n-            write!(buffer, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\",\n-                   path = relpath);\n-        }\n-        // Closes sidebar-elems div.\n-        write!(buffer, \"</div>\");\n+                _ => \"\",\n+            },\n+            it.name.as_ref().unwrap());\n+    }\n+\n+    if it.is_crate() {\n+        if let Some(ref version) = cache().crate_version {\n+            write!(buffer,\n+                    \"<div class='block version'>\\\n+                    <p>Version {}</p>\\\n+                    </div>\",\n+                    version);\n+        }\n+    }\n+\n+    write!(buffer, \"<div class=\\\"sidebar-elems\\\">\");\n+    if it.is_crate() {\n+        write!(buffer, \"<a id='all-types' href='all.html'><p>See all {}'s items</p></a>\",\n+                it.name.as_ref().expect(\"crates always have a name\"));\n+    }\n+    match it.inner {\n+        clean::StructItem(ref s) => sidebar_struct(buffer, it, s),\n+        clean::TraitItem(ref t) => sidebar_trait(buffer, it, t),\n+        clean::PrimitiveItem(ref p) => sidebar_primitive(buffer, it, p),\n+        clean::UnionItem(ref u) => sidebar_union(buffer, it, u),\n+        clean::EnumItem(ref e) => sidebar_enum(buffer, it, e),\n+        clean::TypedefItem(ref t, _) => sidebar_typedef(buffer, it, t),\n+        clean::ModuleItem(ref m) => sidebar_module(buffer, it, &m.items),\n+        clean::ForeignTypeItem => sidebar_foreign_type(buffer, it),\n+        _ => (),\n+    }\n+\n+    // The sidebar is designed to display sibling functions, modules and\n+    // other miscellaneous information. since there are lots of sibling\n+    // items (and that causes quadratic growth in large modules),\n+    // we refactor common parts into a shared JavaScript file per module.\n+    // still, we don't move everything into JS because we want to preserve\n+    // as much HTML as possible in order to allow non-JS-enabled browsers\n+    // to navigate the documentation (though slightly inefficiently).\n+\n+    write!(buffer, \"<p class='location'>\");\n+    for (i, name) in cx.current.iter().take(parentlen).enumerate() {\n+        if i > 0 {\n+            write!(buffer, \"::<wbr>\");\n+        }\n+        write!(buffer, \"<a href='{}index.html'>{}</a>\",\n+                &cx.root_path()[..(cx.current.len() - i - 1) * 3],\n+                *name);\n+    }\n+    write!(buffer, \"</p>\");\n+\n+    // Sidebar refers to the enclosing module, not this module.\n+    let relpath = if it.is_mod() { \"../\" } else { \"\" };\n+    write!(buffer,\n+            \"<script>window.sidebarCurrent = {{\\\n+                name: '{name}', \\\n+                ty: '{ty}', \\\n+                relpath: '{path}'\\\n+            }};</script>\",\n+            name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n+            ty = it.type_().css_class(),\n+            path = relpath);\n+    if parentlen == 0 {\n+        // There is no sidebar-items.js beyond the crate root path\n+        // FIXME maybe dynamic crate loading can be merged here\n+    } else {\n+        write!(buffer, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\",\n+                path = relpath);\n     }\n+    // Closes sidebar-elems div.\n+    write!(buffer, \"</div>\");\n+}\n \n fn get_next_url(used_links: &mut FxHashSet<String>, url: String) -> String {\n     if used_links.insert(url.clone()) {"}, {"sha": "6dccfdadf0fb843509ba4795faedc18c1465fe51", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d5f147086bbc70eb248804d3a16c643979fd1f2b/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f147086bbc70eb248804d3a16c643979fd1f2b/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=d5f147086bbc70eb248804d3a16c643979fd1f2b", "patch": "@@ -160,22 +160,22 @@ where\n struct Source<'a>(&'a str);\n \n impl<'a> fmt::Display for Source<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let Source(s) = *self;\n-        let lines = s.lines().count();\n-        let mut cols = 0;\n-        let mut tmp = lines;\n-        while tmp > 0 {\n-            cols += 1;\n-            tmp /= 10;\n-        }\n-        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n-        for i in 1..=lines {\n-            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n-        }\n-        write!(fmt, \"</pre>\")?;\n-        write!(fmt, \"{}\",\n-               highlight::render_with_highlighting(s, None, None, None))?;\n-        Ok(())\n+fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    let Source(s) = *self;\n+    let lines = s.lines().count();\n+    let mut cols = 0;\n+    let mut tmp = lines;\n+    while tmp > 0 {\n+        cols += 1;\n+        tmp /= 10;\n     }\n+    write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n+    for i in 1..=lines {\n+        write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n+    }\n+    write!(fmt, \"</pre>\")?;\n+    write!(fmt, \"{}\",\n+            highlight::render_with_highlighting(s, None, None, None))?;\n+    Ok(())\n+}\n }"}]}