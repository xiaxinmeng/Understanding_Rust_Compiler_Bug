{"sha": "ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60", "node_id": "C_kwDOAAsO6NoAKGFkOTlkMmUxNWRkOWYzNmExYjg0MzU5ZjhiOWJiOWZmYmFhNWFjNjA", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-09-01T12:17:15Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:11Z"}, "message": "Move handling of references and simplify flooding", "tree": {"sha": "4083d3b89a3fd0c92fcf6bb1fbb6b79b7ce65d8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4083d3b89a3fd0c92fcf6bb1fbb6b79b7ce65d8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60", "html_url": "https://github.com/rust-lang/rust/commit/ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f98dc78380a60ffea0e5849393a718a10f495b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f98dc78380a60ffea0e5849393a718a10f495b4", "html_url": "https://github.com/rust-lang/rust/commit/3f98dc78380a60ffea0e5849393a718a10f495b4"}], "stats": {"total": 149, "additions": 92, "deletions": 57}, "files": [{"sha": "4d4a1ea553e4039389a0ae529d5a2b19a9c626b6", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 71, "deletions": 44, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60", "patch": "@@ -115,52 +115,40 @@ pub trait ValueAnalysis<'tcx> {\n         rvalue: &Rvalue<'tcx>,\n         state: &mut State<Self::Value>,\n     ) {\n-        match rvalue {\n-            Rvalue::Ref(_, BorrowKind::Shared, place) => {\n-                let target_deref = self\n-                    .map()\n-                    .find(target.as_ref())\n-                    .and_then(|target| self.map().apply_elem(target, ProjElem::Deref));\n-                let place = self.map().find(place.as_ref());\n-                match (target_deref, place) {\n-                    (Some(target_deref), Some(place)) => {\n-                        state.assign_idx(target_deref, ValueOrPlace::Place(place), self.map())\n-                    }\n-                    _ => (),\n-                }\n-            }\n-            Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n-                state.flood(place.as_ref(), self.map(), Self::Value::top());\n-            }\n-            _ => {\n-                let result = self.handle_rvalue(rvalue, state);\n-                state.assign(target.as_ref(), result, self.map());\n-            }\n-        }\n+        let result = self.handle_rvalue(rvalue, state);\n+        state.assign(target.as_ref(), result, self.map());\n     }\n \n     fn handle_rvalue(\n         &self,\n         rvalue: &Rvalue<'tcx>,\n         state: &mut State<Self::Value>,\n-    ) -> ValueOrPlace<Self::Value> {\n+    ) -> ValueOrPlaceOrRef<Self::Value> {\n         self.super_rvalue(rvalue, state)\n     }\n \n     fn super_rvalue(\n         &self,\n         rvalue: &Rvalue<'tcx>,\n         state: &mut State<Self::Value>,\n-    ) -> ValueOrPlace<Self::Value> {\n+    ) -> ValueOrPlaceOrRef<Self::Value> {\n         match rvalue {\n-            Rvalue::Use(operand) => self.handle_operand(operand, state),\n-            Rvalue::CopyForDeref(place) => self.handle_operand(&Operand::Copy(*place), state),\n-            Rvalue::Ref(..) | Rvalue::AddressOf(..) => {\n-                bug!(\"this rvalue must be handled by handle_assign() or super_assign()\")\n+            Rvalue::Use(operand) => self.handle_operand(operand, state).into(),\n+            Rvalue::Ref(_, BorrowKind::Shared, place) => self\n+                .map()\n+                .find(place.as_ref())\n+                .map(ValueOrPlaceOrRef::Ref)\n+                .unwrap_or(ValueOrPlaceOrRef::Unknown),\n+            Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+                state.flood(place.as_ref(), self.map());\n+                ValueOrPlaceOrRef::Unknown\n+            }\n+            Rvalue::CopyForDeref(place) => {\n+                self.handle_operand(&Operand::Copy(*place), state).into()\n             }\n             _ => {\n                 // FIXME: Check that other Rvalues really have no side-effect.\n-                ValueOrPlace::Unknown\n+                ValueOrPlaceOrRef::Unknown\n             }\n         }\n     }\n@@ -228,7 +216,7 @@ pub trait ValueAnalysis<'tcx> {\n         state: &mut State<Self::Value>,\n     ) {\n         return_places.for_each(|place| {\n-            state.flood(place.as_ref(), self.map(), Self::Value::top());\n+            state.flood(place.as_ref(), self.map());\n         })\n     }\n \n@@ -270,7 +258,7 @@ impl<'tcx, T: ValueAnalysis<'tcx>> AnalysisDomain<'tcx> for ValueAnalysisWrapper\n \n     fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n         for arg in body.args_iter() {\n-            state.flood(PlaceRef { local: arg, projection: &[] }, self.0.map(), T::Value::top());\n+            state.flood(PlaceRef { local: arg, projection: &[] }, self.0.map());\n         }\n     }\n }\n@@ -328,24 +316,36 @@ rustc_index::newtype_index!(\n pub struct State<V>(IndexVec<ValueIndex, V>);\n \n impl<V: Clone + HasTop> State<V> {\n-    pub fn flood_all(&mut self, value: V) {\n+    pub fn flood_all(&mut self) {\n+        self.flood_all_with(V::top())\n+    }\n+\n+    pub fn flood_all_with(&mut self, value: V) {\n         self.0.raw.fill(value);\n     }\n \n-    pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n+    pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         if let Some(root) = map.find(place) {\n-            self.flood_idx(root, map, value);\n+            self.flood_idx_with(root, map, value);\n         }\n     }\n \n-    pub fn flood_idx(&mut self, place: PlaceIndex, map: &Map, value: V) {\n+    pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map) {\n+        self.flood_with(place, map, V::top())\n+    }\n+\n+    pub fn flood_idx_with(&mut self, place: PlaceIndex, map: &Map, value: V) {\n         map.preorder_invoke(place, &mut |place| {\n             if let Some(vi) = map.places[place].value_index {\n                 self.0[vi] = value.clone();\n             }\n         });\n     }\n \n+    pub fn flood_idx(&mut self, place: PlaceIndex, map: &Map) {\n+        self.flood_idx_with(place, map, V::top())\n+    }\n+\n     pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n         if let Some(target_value) = map.places[target].value_index {\n             if let Some(source_value) = map.places[source].value_index {\n@@ -360,30 +360,40 @@ impl<V: Clone + HasTop> State<V> {\n             if let Some(source_child) = map.projections.get(&(source, projection)) {\n                 self.assign_place_idx(target_child, *source_child, map);\n             } else {\n-                self.flood_idx(target_child, map, V::top());\n+                self.flood_idx(target_child, map);\n             }\n         }\n     }\n \n-    pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+    pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlaceOrRef<V>, map: &Map) {\n         if let Some(target) = map.find(target) {\n             self.assign_idx(target, result, map);\n+        } else {\n+            // We don't track this place nor any projections, assignment can be ignored.\n         }\n     }\n \n-    pub fn assign_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n+    pub fn assign_idx(&mut self, target: PlaceIndex, result: ValueOrPlaceOrRef<V>, map: &Map) {\n         match result {\n-            ValueOrPlace::Value(value) => {\n+            ValueOrPlaceOrRef::Value(value) => {\n                 // First flood the target place in case we also track any projections (although\n-                // this scenario is currently not well-supported with the ValueOrPlace interface).\n-                self.flood_idx(target, map, V::top());\n+                // this scenario is currently not well-supported by the API).\n+                self.flood_idx(target, map);\n                 if let Some(value_index) = map.places[target].value_index {\n                     self.0[value_index] = value;\n                 }\n             }\n-            ValueOrPlace::Place(source) => self.assign_place_idx(target, source, map),\n-            ValueOrPlace::Unknown => {\n-                self.flood_idx(target, map, V::top());\n+            ValueOrPlaceOrRef::Place(source) => self.assign_place_idx(target, source, map),\n+            ValueOrPlaceOrRef::Ref(source) => {\n+                if let Some(value_index) = map.places[target].value_index {\n+                    self.0[value_index] = V::top();\n+                }\n+                if let Some(target_deref) = map.apply_elem(target, ProjElem::Deref) {\n+                    self.assign_place_idx(target_deref, source, map);\n+                }\n+            }\n+            ValueOrPlaceOrRef::Unknown => {\n+                self.flood_idx(target, map);\n             }\n         }\n     }\n@@ -578,6 +588,23 @@ pub enum ValueOrPlace<V> {\n     Unknown,\n }\n \n+pub enum ValueOrPlaceOrRef<V> {\n+    Value(V),\n+    Place(PlaceIndex),\n+    Ref(PlaceIndex),\n+    Unknown,\n+}\n+\n+impl<V> From<ValueOrPlace<V>> for ValueOrPlaceOrRef<V> {\n+    fn from(x: ValueOrPlace<V>) -> Self {\n+        match x {\n+            ValueOrPlace::Value(value) => ValueOrPlaceOrRef::Value(value),\n+            ValueOrPlace::Place(place) => ValueOrPlaceOrRef::Place(place),\n+            ValueOrPlace::Unknown => ValueOrPlaceOrRef::Unknown,\n+        }\n+    }\n+}\n+\n pub trait HasBottom {\n     fn bottom() -> Self;\n }"}, {"sha": "b05b0fdfd43ec7a30a0eb7940766455f77e3a847", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=ad99d2e15dd9f36a1b84359f8b9bb9ffbaa5ac60", "patch": "@@ -3,7 +3,9 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n-use rustc_mir_dataflow::value_analysis::{Map, ProjElem, State, ValueAnalysis, ValueOrPlace};\n+use rustc_mir_dataflow::value_analysis::{\n+    Map, ProjElem, State, ValueAnalysis, ValueOrPlace, ValueOrPlaceOrRef,\n+};\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n use rustc_span::DUMMY_SP;\n \n@@ -59,6 +61,12 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n         match rvalue {\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n                 let target = self.map().find(target.as_ref());\n+                if let Some(target) = target {\n+                    // We should not track any projections other than\n+                    // what is overwritten below, but just in case...\n+                    state.flood_idx(target, self.map());\n+                }\n+\n                 let value_target = target.and_then(|target| {\n                     self.map().apply_elem(target, ProjElem::Field(0_u32.into()))\n                 });\n@@ -70,12 +78,12 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                     let (val, overflow) = self.binary_op(state, *op, left, right);\n \n                     if let Some(value_target) = value_target {\n-                        state.assign_idx(value_target, ValueOrPlace::Value(val), self.map());\n+                        state.assign_idx(value_target, ValueOrPlaceOrRef::Value(val), self.map());\n                     }\n                     if let Some(overflow_target) = overflow_target {\n                         state.assign_idx(\n                             overflow_target,\n-                            ValueOrPlace::Value(overflow),\n+                            ValueOrPlaceOrRef::Value(overflow),\n                             self.map(),\n                         );\n                     }\n@@ -89,32 +97,32 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n         &self,\n         rvalue: &Rvalue<'tcx>,\n         state: &mut State<Self::Value>,\n-    ) -> ValueOrPlace<Self::Value> {\n+    ) -> ValueOrPlaceOrRef<Self::Value> {\n         match rvalue {\n             Rvalue::Cast(CastKind::Misc, operand, ty) => {\n                 let operand = self.eval_operand(operand, state);\n                 match operand {\n                     FlatSet::Elem(operand) => self\n                         .ecx\n                         .misc_cast(&operand, *ty)\n-                        .map(|result| ValueOrPlace::Value(self.wrap_immediate(result, *ty)))\n-                        .unwrap_or(ValueOrPlace::Unknown),\n-                    _ => ValueOrPlace::Unknown,\n+                        .map(|result| ValueOrPlaceOrRef::Value(self.wrap_immediate(result, *ty)))\n+                        .unwrap_or(ValueOrPlaceOrRef::Unknown),\n+                    _ => ValueOrPlaceOrRef::Unknown,\n                 }\n             }\n             Rvalue::BinaryOp(op, box (left, right)) => {\n                 let (val, _overflow) = self.binary_op(state, *op, left, right);\n                 // FIXME: Just ignore overflow here?\n-                ValueOrPlace::Value(val)\n+                ValueOrPlaceOrRef::Value(val)\n             }\n             Rvalue::UnaryOp(op, operand) => match self.eval_operand(operand, state) {\n                 FlatSet::Elem(value) => self\n                     .ecx\n                     .unary_op(*op, &value)\n-                    .map(|val| ValueOrPlace::Value(self.wrap_immty(val)))\n-                    .unwrap_or(ValueOrPlace::Value(FlatSet::Top)),\n-                FlatSet::Bottom => ValueOrPlace::Value(FlatSet::Bottom),\n-                FlatSet::Top => ValueOrPlace::Value(FlatSet::Top),\n+                    .map(|val| ValueOrPlaceOrRef::Value(self.wrap_immty(val)))\n+                    .unwrap_or(ValueOrPlaceOrRef::Value(FlatSet::Top)),\n+                FlatSet::Bottom => ValueOrPlaceOrRef::Value(FlatSet::Bottom),\n+                FlatSet::Top => ValueOrPlaceOrRef::Value(FlatSet::Top),\n             },\n             _ => self.super_rvalue(rvalue, state),\n         }\n@@ -175,7 +183,7 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                 handled = true;\n             } else {\n                 // Branch is not taken, we can flood everything.\n-                state.flood_all(FlatSet::Bottom);\n+                state.flood_all();\n             }\n         })\n     }"}]}