{"sha": "d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZWM4YjVmYjg1Y2I2ZmQ0Y2FlZDY0MjIzYzVjYjNmZDkyMGRhYWI=", "commit": {"author": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-06-14T19:17:56Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-06-14T19:17:56Z"}, "message": "redesigned the pinning to pin deal with things on dequeue, not on enqueue", "tree": {"sha": "47dc844dc524065a5c5c7948c149488ce0390e7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47dc844dc524065a5c5c7948c149488ce0390e7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "html_url": "https://github.com/rust-lang/rust/commit/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/comments", "author": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4224fc7aad3cfbd7093e55812e5a566d7aad3325", "url": "https://api.github.com/repos/rust-lang/rust/commits/4224fc7aad3cfbd7093e55812e5a566d7aad3325", "html_url": "https://github.com/rust-lang/rust/commit/4224fc7aad3cfbd7093e55812e5a566d7aad3325"}], "stats": {"total": 606, "additions": 393, "deletions": 213}, "files": [{"sha": "b01bd8f993c01bde1764018c11c3535b9310258c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "patch": "@@ -49,18 +49,7 @@ pub fn do_abort() -> ! {\n macro_rules! abort(\n     ($( $msg:expr),+) => ( {\n         rtdebug!($($msg),+);\n-\n-//        do_abort();\n-\n-        // NB: This is in a fn to avoid putting the `unsafe` block in\n-        // a macro, which causes spurious 'unnecessary unsafe block'\n-        // warnings.\n-//        fn do_abort() -> ! {\n-//            unsafe { ::libc::abort(); }\n-//        }\n-\n         ::macros::do_abort();\n-\n     } )\n )\n "}, {"sha": "6e0fbda5ec9a73cec4cf28914808c9e5c759999e", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "patch": "@@ -30,7 +30,7 @@ impl Local for Scheduler {\n     fn borrow<T>(f: &fn(&mut Scheduler) -> T) -> T {\n         let mut res: Option<T> = None;\n         let res_ptr: *mut Option<T> = &mut res;\n-        unsafe { \n+        unsafe {\n             do local_ptr::borrow |sched| {\n                 let result = f(sched);\n                 *res_ptr = Some(result);\n@@ -39,7 +39,7 @@ impl Local for Scheduler {\n         match res {\n             Some(r) => { r }\n             None => abort!(\"function failed!\")\n-        }               \n+        }\n     }\n     unsafe fn unsafe_borrow() -> *mut Scheduler { local_ptr::unsafe_borrow() }\n     unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> { abort!(\"unimpl\") }\n@@ -139,5 +139,5 @@ mod test {\n         assert!(res)\n         let _scheduler: ~Scheduler = Local::take();\n     }\n-            \n+\n }"}, {"sha": "3b8a31d1840b33a687157cfafebe1bd8be763451", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 360, "deletions": 181, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "patch": "@@ -90,27 +90,10 @@ pub struct Coroutine {\n     priv saved_context: Context,\n     /// The heap, GC, unwinding, local storage, logging\n     task: ~Task,\n-    /// The scheduler that this task calls home\n-    home_sched: SchedHome\n }\n \n-// To send a Coroutine to another task we have to use contained home\n-// information (the SchedHandle). So we need a form that doesn't\n-// include one.\n-\n-// XXX perf: Evaluate this structure - there should be a clever way to\n-// make it such that we don't need to deal with building/destructing\n-// on Coroutines that aren't homed.\n-\n-pub struct HomelessCoroutine {\n-    priv current_stack_segment: StackSegment,\n-    priv saved_context: Context,\n-    task: ~Task\n-}\n-   \n // A scheduler home is either a handle to the home scheduler, or an\n // explicit \"AnySched\".\n-        \n pub enum SchedHome {\n     AnySched,\n     Sched(SchedHandle)\n@@ -119,7 +102,7 @@ pub enum SchedHome {\n pub enum SchedMessage {\n     Wake,\n     Shutdown,\n-    BiasedTask(~HomelessCoroutine)\n+    PinnedTask(~Coroutine)\n }\n \n enum CleanupJob {\n@@ -193,6 +176,7 @@ pub impl Scheduler {\n             (*event_loop).run();\n         }\n \n+        rtdebug!(\"run taking sched\");\n         let sched = Local::take::<Scheduler>();\n         // XXX: Reenable this once we're using a per-task queue. With a shared\n         // queue this is not true\n@@ -214,6 +198,7 @@ pub impl Scheduler {\n         if sched.interpret_message_queue() {\n             // We performed a scheduling action. There may be other work\n             // to do yet, so let's try again later.\n+            rtdebug!(\"run_sched_once, interpret_message_queue taking sched\");\n             let mut sched = Local::take::<Scheduler>();\n             sched.metrics.messages_received += 1;\n             sched.event_loop.callback(Scheduler::run_sched_once);\n@@ -222,6 +207,7 @@ pub impl Scheduler {\n         }\n \n         // Now, look in the work queue for tasks to run\n+        rtdebug!(\"run_sched_once taking\");\n         let sched = Local::take::<Scheduler>();\n         if sched.resume_task_from_queue() {\n             // We performed a scheduling action. There may be other work\n@@ -271,7 +257,7 @@ pub impl Scheduler {\n \n         // We don't want to queue tasks that belong on other threads,\n         // so we send them home at enqueue time.\n-        \n+\n         // The borrow checker doesn't like our disassembly of the\n         // Coroutine struct and partial use and mutation of the\n         // fields. So completely disassemble here and stop using?\n@@ -283,95 +269,31 @@ pub impl Scheduler {\n \n         let this = self;\n \n-        match task {\n-            ~Coroutine { current_stack_segment: css,\n-                         saved_context: sc,\n-                         task: t,\n-                         home_sched: home_sched } => {\n-                \n-                let mut home_sched = home_sched;\n-\n-                match home_sched {\n-                    Sched(ref mut home_handle) \n-                      if home_handle.sched_id != this.sched_id() => {\n-\n-                          // In this branch we know the task is not\n-                          // home, so we send it home.\n-\n-                        rtdebug!(\"home_handle_id: %u, loc: %u\", \n-                                 home_handle.sched_id,\n-                                 this.sched_id());\n-                            let homeless = ~HomelessCoroutine {\n-                                current_stack_segment: css,\n-                                saved_context: sc,\n-                                task: t\n-                            };\n-                            home_handle.send(BiasedTask(homeless));\n-                            rtdebug!(\"sent task home\");\n-                        return ();\n-                    }\n-                    Sched( ref mut home_handle) => {\n-\n-                        // Here we know the task is home, so we need\n-                        // to \"keep\" it home. Since we don't have a\n-                        // scheduler-local queue for this purpose, we\n-                        // just use our message queue.\n-\n-                        rtdebug!(\"homed task at home, sending to self\");\n-                        let homeless = ~HomelessCoroutine {\n-                            current_stack_segment: css,\n-                            saved_context: sc,\n-                            task: t\n-                        };\n-                        home_handle.send(BiasedTask(homeless));\n-                        rtdebug!(\"sent home to self\");\n-                        return ();\n-                         \n-                    }                    \n-                    _ => {\n-                        \n-                        // We just destroyed our Coroutine ... but now\n-                        // we want it back. Build a new one?  \n-                        // XXX: perf: see above comment about not\n-                        // destroying\n-\n-                        let task = ~Coroutine {\n-                            current_stack_segment: css,\n-                            saved_context: sc,\n-                            task: t,\n-                            home_sched: AnySched };\n-\n-                        \n-                        // We push the task onto our local queue.\n-                        this.work_queue.push(task);\n-                        this.event_loop.callback(Scheduler::run_sched_once);\n-\n-                        // We've made work available. Notify a\n-                        // sleeping scheduler.\n-                        \n-                        // XXX: perf. Check for a sleeper without\n-                        // synchronizing memory.  It's not critical\n-                        // that we always find it.\n-                        \n-                        // XXX: perf. If there's a sleeper then we\n-                        // might as well just send it the task\n-                        // directly instead of pushing it to the\n-                        // queue. That is essentially the intent here\n-                        // and it is less work.\n-                        match this.sleeper_list.pop() {\n-                            Some(handle) => {\n-                                let mut handle = handle;\n-                                handle.send(Wake)\n-                            }\n-                            None => { (/* pass */) }\n-                        };\n-                    }\n-                }\n+        // We push the task onto our local queue clone.\n+        this.work_queue.push(task);\n+        this.event_loop.callback(Scheduler::run_sched_once);\n+\n+        // We've made work available. Notify a\n+        // sleeping scheduler.\n+\n+        // XXX: perf. Check for a sleeper without\n+        // synchronizing memory.  It's not critical\n+        // that we always find it.\n+\n+        // XXX: perf. If there's a sleeper then we\n+        // might as well just send it the task\n+        // directly instead of pushing it to the\n+        // queue. That is essentially the intent here\n+        // and it is less work.\n+        match this.sleeper_list.pop() {\n+            Some(handle) => {\n+                let mut handle = handle;\n+                handle.send(Wake)\n             }\n-        }\n+            None => { (/* pass */) }\n+        };\n     }\n \n-\n     // * Scheduler-context operations\n \n     fn interpret_message_queue(~self) -> bool {\n@@ -381,23 +303,11 @@ pub impl Scheduler {\n \n         let mut this = self;\n         match this.message_queue.pop() {\n-            Some(BiasedTask(~HomelessCoroutine { \n-                current_stack_segment: css,\n-                saved_context: sc,\n-                task: t})) => {\n+            Some(PinnedTask(task)) => {\n                 rtdebug!(\"recv BiasedTask message in sched: %u\",\n                          this.sched_id());\n-            \n-                // Since this was the \"send home\" message for a task,\n-                // we know that this is the home. So we rebuild the\n-                // sched_handle.\n-                \n-                let task = ~Coroutine {\n-                    current_stack_segment: css,\n-                    saved_context: sc,\n-                    task: t,\n-                    home_sched: Sched(this.make_handle())\n-                };\n+                let mut task = task;\n+                task.task.home = Some(Sched(this.make_handle()));\n                 this.resume_task_immediately(task);\n                 return true;\n             }\n@@ -438,32 +348,93 @@ pub impl Scheduler {\n         }\n     }\n \n+    /// Given an input Coroutine sends it back to its home scheduler.\n+    fn send_task_home(task: ~Coroutine) {\n+        let mut task = task;\n+        let mut home = task.task.home.swap_unwrap();\n+        match home {\n+            Sched(ref mut home_handle) => {\n+                home_handle.send(PinnedTask(task));\n+            }\n+            AnySched => {\n+                abort!(\"error: cannot send anysched task home\");\n+            }\n+        }\n+    }\n+\n+    // Resume a task from the queue - but also take into account that\n+    // it might not belong here.\n     fn resume_task_from_queue(~self) -> bool {\n         assert!(!self.in_task_context());\n \n         rtdebug!(\"looking in work queue for task to schedule\");\n         let mut this = self;\n \n-        if this.run_anything {\n-            match this.work_queue.pop() {\n-                Some(task) => {\n-                    rtdebug!(\"resuming task from work queue\");\n-                    this.resume_task_immediately(task);\n-                    return true;\n-                }\n-                None => {\n-                    rtdebug!(\"no tasks in queue\");\n-                    Local::put(this);\n-                    return false;\n+        // The borrow checker imposes the possibly absurd requirement\n+        // that we split this into two match expressions. This is due\n+        // to the inspection of the internal bits of task, as that\n+        // can't be in scope when we act on task.\n+        match this.work_queue.pop() {\n+            Some(task) => {\n+                let action_id = {\n+                    let home = &task.task.home;\n+                    match home {\n+                        &Some(Sched(ref home_handle))\n+                        if home_handle.sched_id != this.sched_id() => {\n+                            0\n+                        }\n+                        &Some(AnySched) if this.run_anything => {\n+                            1\n+                        }\n+                        &Some(AnySched) => {\n+                            2\n+                        }\n+                        &Some(Sched(_)) => {\n+                            3\n+                        }\n+                        &None => {\n+                            4\n+                        }\n+                    }\n+                };\n+\n+                match action_id {\n+                    0 => {\n+                        rtdebug!(\"sending task home\");\n+                        Scheduler::send_task_home(task);\n+                        Local::put(this);\n+                        return false;\n+                    }\n+                    1 => {\n+                        rtdebug!(\"resuming now\");\n+                        this.resume_task_immediately(task);\n+                        return true;\n+                    }\n+                    2 => {\n+                        rtdebug!(\"re-queueing\")\n+                        this.enqueue_task(task);\n+                        Local::put(this);\n+                        return false;\n+                    }\n+                    3 => {\n+                        rtdebug!(\"resuming now\");\n+                        this.resume_task_immediately(task);\n+                        return true;\n+                    }\n+                    4 => {\n+                        abort!(\"task home was None!\");\n+                    }\n+                    _ => {\n+                        abort!(\"literally, you should not be here\");\n+                    }\n                 }\n             }\n-        } else {\n-            // In this branch we have a scheduler that is not allowed\n-            // to run unpinned tasks. As such it will only get tasks\n-            // to run from the message queue.\n-            rtdebug!(\"skipping resume_task_from_queue\");\n-            Local::put(this);\n-            return false;\n+\n+            None => {\n+               rtdebug!(\"no tasks in queue\");\n+               Local::put(this);\n+               return false;\n+           }\n         }\n     }\n \n@@ -484,21 +455,32 @@ pub impl Scheduler {\n         abort!(\"control reached end of task\");\n     }\n \n-    fn schedule_new_task(~self, task: ~Coroutine) {\n+    pub fn schedule_task(~self, task: ~Coroutine) {\n         assert!(self.in_task_context());\n \n-        do self.switch_running_tasks_and_then(task) |sched, last_task| {\n-            let last_task = Cell(last_task);\n-            sched.enqueue_task(last_task.take());\n-        }\n-    }\n+        // is the task home?\n+        let is_home = task.is_home_no_tls(&self);\n \n-    fn schedule_task(~self, task: ~Coroutine) {\n-        assert!(self.in_task_context());\n+        // does the task have a home?\n+        let homed = task.homed();\n+\n+        let mut this = self;\n \n-        do self.switch_running_tasks_and_then(task) |sched, last_task| {\n-            let last_task = Cell(last_task);\n-            sched.enqueue_task(last_task.take());\n+        if is_home || (!homed && this.run_anything) {\n+            // here we know we are home, execute now OR we know we\n+            // aren't homed, and that this sched doesn't care\n+            do this.switch_running_tasks_and_then(task) |sched, last_task| {\n+                let last_task = Cell(last_task);\n+                sched.enqueue_task(last_task.take());\n+            }\n+        } else if !homed && !this.run_anything {\n+            // the task isn't homed, but it can't be run here\n+            this.enqueue_task(task);\n+            Local::put(this);\n+        } else {\n+            // task isn't home, so don't run it here, send it home\n+            Scheduler::send_task_home(task);\n+            Local::put(this);\n         }\n     }\n \n@@ -681,19 +663,66 @@ impl SchedHandle {\n \n pub impl Coroutine {\n \n-\n-    /// This function checks that a coroutine is running \"home\". \n-    fn am_home(&self) -> bool {\n+    /// This function checks that a coroutine is running \"home\".\n+    fn is_home(&self) -> bool {\n+        rtdebug!(\"checking if coroutine is home\");\n         do Local::borrow::<Scheduler,bool> |sched| {\n-            match self.home_sched {\n-                AnySched => { true }\n-                Sched(SchedHandle { sched_id: ref id, _ }) => {\n+            match self.task.home {\n+                Some(AnySched) => { false }\n+                Some(Sched(SchedHandle { sched_id: ref id, _ })) => {\n                     *id == sched.sched_id()\n                 }\n+                None => { abort!(\"error: homeless task!\"); }\n+            }\n+        }\n+    }\n+\n+    /// Without access to self, but with access to the \"expected home\n+    /// id\", see if we are home.\n+    fn is_home_using_id(id: uint) -> bool {\n+        rtdebug!(\"checking if coroutine is home using id\");\n+        do Local::borrow::<Scheduler,bool> |sched| {\n+            if sched.sched_id() == id {\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Check if this coroutine has a home\n+    fn homed(&self) -> bool {\n+        rtdebug!(\"checking if this coroutine has a home\");\n+        match self.task.home {\n+            Some(AnySched) => { false }\n+            Some(Sched(_)) => { true }\n+            None => { abort!(\"error: homeless task!\");\n+                    }\n+        }\n+    }\n+\n+    /// A version of is_home that does not need to use TLS, it instead\n+    /// takes local scheduler as a parameter.\n+    fn is_home_no_tls(&self, sched: &~Scheduler) -> bool {\n+        rtdebug!(\"checking if coroutine is home without tls\");\n+        match self.task.home {\n+            Some(AnySched) => { true }\n+            Some(Sched(SchedHandle { sched_id: ref id, _})) => {\n+                *id == sched.sched_id()\n             }\n+            None => { abort!(\"error: homeless task!\"); }\n+        }\n+    }\n+\n+    /// Check TLS for the scheduler to see if we are on a special\n+    /// scheduler.\n+    pub fn on_special() -> bool {\n+        rtdebug!(\"checking if coroutine is executing on special sched\");\n+        do Local::borrow::<Scheduler,bool>() |sched| {\n+            !sched.run_anything\n         }\n-    }                                      \n-    \n+    }\n+\n     // Created new variants of \"new\" that takes a home scheduler\n     // parameter. The original with_task now calls with_task_homed\n     // using the AnySched paramter.\n@@ -710,19 +739,20 @@ pub impl Coroutine {\n                        task: ~Task,\n                        start: ~fn(),\n                        home: SchedHome) -> Coroutine {\n-        \n+\n         static MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n-        \n+\n         let start = Coroutine::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n         let initial_context = Context::new(start, &mut stack);\n-        return Coroutine {\n+        let mut crt = Coroutine {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n             task: task,\n-            home_sched: home\n         };\n+        crt.task.home = Some(home);\n+        return crt;\n     }\n \n     fn with_task(stack_pool: &mut StackPool,\n@@ -841,7 +871,7 @@ mod test {\n \n             let sched_handle = sched.make_handle();\n             let sched_id = sched.sched_id();\n-            \n+\n             let task = ~do Coroutine::new_homed(&mut sched.stack_pool,\n                                                 Sched(sched_handle)) {\n                 unsafe { *task_ran_ptr = true };\n@@ -855,6 +885,146 @@ mod test {\n         }\n     }\n \n+    // A test for each state of schedule_task\n+\n+    #[test]\n+    fn test_schedule_home_states() {\n+\n+        use rt::uv::uvio::UvEventLoop;\n+        use rt::sched::Shutdown;\n+        use rt::sleeper_list::SleeperList;\n+        use rt::work_queue::WorkQueue;\n+\n+        do run_in_bare_thread {\n+//            let nthreads = 2;\n+\n+            let sleepers = SleeperList::new();\n+            let work_queue = WorkQueue::new();\n+\n+            // our normal scheduler\n+            let mut normal_sched = ~Scheduler::new(\n+                ~UvEventLoop::new(),\n+                work_queue.clone(),\n+                sleepers.clone());\n+\n+            let normal_handle = Cell(normal_sched.make_handle());\n+\n+            // our special scheduler\n+            let mut special_sched = ~Scheduler::new_special(\n+                ~UvEventLoop::new(),\n+                work_queue.clone(),\n+                sleepers.clone(),\n+                true);\n+\n+            let special_handle = Cell(special_sched.make_handle());\n+            let special_handle2 = Cell(special_sched.make_handle());\n+            let special_id = special_sched.sched_id();\n+            let t1_handle = special_sched.make_handle();\n+            let t4_handle = special_sched.make_handle();\n+\n+            let t1f = ~do Coroutine::new_homed(&mut special_sched.stack_pool,\n+                                            Sched(t1_handle)) {\n+                let is_home = Coroutine::is_home_using_id(special_id);\n+                rtdebug!(\"t1 should be home: %b\", is_home);\n+                assert!(is_home);\n+            };\n+            let t1f = Cell(t1f);\n+\n+            let t2f = ~do Coroutine::new(&mut normal_sched.stack_pool) {\n+                let on_special = Coroutine::on_special();\n+                rtdebug!(\"t2 should not be on special: %b\", on_special);\n+                assert!(!on_special);\n+            };\n+            let t2f = Cell(t2f);\n+\n+            let t3f = ~do Coroutine::new(&mut normal_sched.stack_pool) {\n+                // not on special\n+                let on_special = Coroutine::on_special();\n+                rtdebug!(\"t3 should not be on special: %b\", on_special);\n+                assert!(!on_special);\n+            };\n+            let t3f = Cell(t3f);\n+\n+            let t4f = ~do Coroutine::new_homed(&mut special_sched.stack_pool,\n+                                            Sched(t4_handle)) {\n+                // is home\n+                let home = Coroutine::is_home_using_id(special_id);\n+                rtdebug!(\"t4 should be home: %b\", home);\n+                assert!(home);\n+            };\n+            let t4f = Cell(t4f);\n+\n+            // we have four tests, make them as closures\n+            let t1: ~fn() = || {\n+                // task is home on special\n+                let task = t1f.take();\n+                let sched = Local::take::<Scheduler>();\n+                sched.schedule_task(task);\n+            };\n+            let t2: ~fn() = || {\n+                // not homed, task doesn't care\n+                let task = t2f.take();\n+                let sched = Local::take::<Scheduler>();\n+                sched.schedule_task(task);\n+            };\n+            let t3: ~fn() = || {\n+                // task not homed, must leave\n+                let task = t3f.take();\n+                let sched = Local::take::<Scheduler>();\n+                sched.schedule_task(task);\n+            };\n+            let t4: ~fn() = || {\n+                // task not home, send home\n+                let task = t4f.take();\n+                let sched = Local::take::<Scheduler>();\n+                sched.schedule_task(task);\n+            };\n+\n+            let t1 = Cell(t1);\n+            let t2 = Cell(t2);\n+            let t3 = Cell(t3);\n+            let t4 = Cell(t4);\n+\n+            // build a main task that runs our four tests\n+            let main_task = ~do Coroutine::new(&mut normal_sched.stack_pool) {\n+                // the two tasks that require a normal start location\n+                t2.take()();\n+                t4.take()();\n+                normal_handle.take().send(Shutdown);\n+                special_handle.take().send(Shutdown);\n+            };\n+\n+            // task to run the two \"special start\" tests\n+            let special_task = ~do Coroutine::new_homed(\n+                &mut special_sched.stack_pool,\n+                Sched(special_handle2.take())) {\n+                t1.take()();\n+                t3.take()();\n+            };\n+\n+            // enqueue the main tasks\n+            normal_sched.enqueue_task(special_task);\n+            normal_sched.enqueue_task(main_task);\n+\n+            let nsched_cell = Cell(normal_sched);\n+            let normal_thread = do Thread::start {\n+                let sched = nsched_cell.take();\n+                sched.run();\n+            };\n+\n+            let ssched_cell = Cell(special_sched);\n+            let special_thread = do Thread::start {\n+                let sched = ssched_cell.take();\n+                sched.run();\n+            };\n+\n+            // wait for the end\n+            let _thread1 = normal_thread;\n+            let _thread2 = special_thread;\n+\n+        }\n+    }\n+\n     // The following test is a bit of a mess, but it trys to do\n     // something tricky so I'm not sure how to get around this in the\n     // short term.\n@@ -865,9 +1035,9 @@ mod test {\n     // observe that the task is not home, and send it home.\n \n     // This test is light in that it does very little.\n-                \n+\n     #[test]\n-    fn test_transfer_task_home() {        \n+    fn test_transfer_task_home() {\n \n         use rt::uv::uvio::UvEventLoop;\n         use rt::sched::Shutdown;\n@@ -879,18 +1049,18 @@ mod test {\n         use vec::OwnedVector;\n \n         do run_in_bare_thread {\n-            \n+\n             static N: uint = 8;\n-            \n+\n             let sleepers = SleeperList::new();\n             let work_queue = WorkQueue::new();\n-            \n+\n             let mut handles = ~[];\n             let mut scheds = ~[];\n-            \n+\n             for uint::range(0, N) |_| {\n                 let loop_ = ~UvEventLoop::new();\n-                let mut sched = ~Scheduler::new(loop_, \n+                let mut sched = ~Scheduler::new(loop_,\n                                                 work_queue.clone(),\n                                                 sleepers.clone());\n                 let handle = sched.make_handle();\n@@ -901,7 +1071,7 @@ mod test {\n \n             let handles = Cell(handles);\n \n-            let home_handle = scheds[6].make_handle();               \n+            let home_handle = scheds[6].make_handle();\n             let home_id = home_handle.sched_id;\n             let home = Sched(home_handle);\n \n@@ -913,18 +1083,18 @@ mod test {\n                          sched.sched_id(),\n                          home_id);\n                 assert!(sched.sched_id() == home_id);\n-                Local::put::<Scheduler>(sched);                 \n+                Local::put::<Scheduler>(sched);\n \n                 let mut handles = handles.take();\n                 for handles.each_mut |handle| {\n                     handle.send(Shutdown);\n                 }\n             };\n-                \n+\n             scheds[0].enqueue_task(main_task);\n-            \n+\n             let mut threads = ~[];\n-            \n+\n             while !scheds.is_empty() {\n                 let sched = scheds.pop();\n                 let sched_cell = Cell(sched);\n@@ -934,13 +1104,23 @@ mod test {\n                 };\n                 threads.push(thread);\n             }\n-                \n+\n             let _threads = threads;\n         }\n     }\n-    \n+\n+    // Do it a lot\n+\n+    #[test]\n+    fn test_stress_schedule_task_states() {\n+        let n = stress_factor() * 120;\n+        for int::range(0,n as int) |_| {\n+            test_schedule_home_states();\n+        }\n+    }\n+\n     // The goal is that this is the high-stress test for making sure\n-    // homing is working. It allocates 120*RUST_RT_STRESS tasks that\n+    // homing is working. It allocates RUST_RT_STRESS tasks that\n     // do nothing but assert that they are home at execution\n     // time. These tasks are queued to random schedulers, so sometimes\n     // they are home and sometimes not. It also runs RUST_RT_STRESS\n@@ -953,7 +1133,6 @@ mod test {\n             run_in_mt_newsched_task_random_homed();\n         }\n     }\n-            \n \n     #[test]\n     fn test_simple_scheduling() {\n@@ -1210,8 +1389,8 @@ mod test {\n     fn start_closure_dtor() {\n         use ops::Drop;\n \n-        // Regression test that the `start` task entrypoint can contain dtors\n-        // that use task resources\n+        // Regression test that the `start` task entrypoint can\n+        // contain dtors that use task resources\n         do run_in_newsched_task {\n             struct S { field: () }\n \n@@ -1226,7 +1405,7 @@ mod test {\n             do spawntask {\n                 let _ss = &s;\n             }\n-        }        \n+        }\n     }\n \n }"}, {"sha": "06318ac6623b034ff05a6ad48833b8500cfe4f26", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "patch": "@@ -19,14 +19,16 @@ use cast::transmute;\n use rt::local::Local;\n use super::local_heap::LocalHeap;\n use rt::logging::StdErrLogger;\n+use rt::sched::{SchedHome, AnySched};\n \n pub struct Task {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n     logger: StdErrLogger,\n     unwinder: Option<Unwinder>,\n-    destroyed: bool\n+    destroyed: bool,\n+    home: Option<SchedHome>\n }\n \n pub struct GarbageCollector;\n@@ -44,7 +46,8 @@ impl Task {\n             storage: LocalStorage(ptr::null(), None),\n             logger: StdErrLogger,\n             unwinder: Some(Unwinder { unwinding: false }),\n-            destroyed: false\n+            destroyed: false,\n+            home: Some(AnySched)\n         }\n     }\n \n@@ -55,10 +58,15 @@ impl Task {\n             storage: LocalStorage(ptr::null(), None),\n             logger: StdErrLogger,\n             unwinder: None,\n-            destroyed: false\n+            destroyed: false,\n+            home: Some(AnySched)\n         }\n     }\n \n+    pub fn give_home(&mut self, new_home: SchedHome) {\n+        self.home = Some(new_home);\n+    }\n+\n     pub fn run(&mut self, f: &fn()) {\n         // This is just an assertion that `run` was called unsafely\n         // and this instance of Task is still accessible."}, {"sha": "bb284c0254179d8816cb229442078d5bb0d6aaff", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "patch": "@@ -162,18 +162,19 @@ pub fn run_in_mt_newsched_task_random_homed() {\n         for uint::range(0, nthreads) |i| {\n             let special = (i % 2) == 0;\n             let loop_ = ~UvEventLoop::new();\n-            let mut sched = ~Scheduler::new_special(loop_, work_queue.clone(), sleepers.clone(), special);\n+            let mut sched = ~Scheduler::new_special(\n+                loop_, work_queue.clone(), sleepers.clone(), special);\n             let handle = sched.make_handle();\n             handles.push(handle);\n             scheds.push(sched);\n-        }           \n+        }\n \n         // Schedule a pile o tasks\n-        let n = 5*stress_factor();        \n+        let n = 5*stress_factor();\n         for uint::range(0,n) |_i| {\n                 rtdebug!(\"creating task: %u\", _i);\n                 let hf: ~fn() = || { assert!(true) };\n-                spawntask_homed(&mut scheds, hf);            \n+                spawntask_homed(&mut scheds, hf);\n             }\n \n         // Now we want another pile o tasks that do not ever run on a\n@@ -182,24 +183,24 @@ pub fn run_in_mt_newsched_task_random_homed() {\n \n         let n = 5*stress_factor();\n \n-        let f: ~fn() = || {        \n+        let f: ~fn() = || {\n             for uint::range(0,n) |_| {\n-                let f: ~fn()  = || {                                 \n+                let f: ~fn()  = || {\n                     // Borrow the scheduler we run on and check if it is\n-                    // privliged.\n+                    // privileged.\n                     do Local::borrow::<Scheduler,()> |sched| {\n                         assert!(sched.run_anything);\n                     };\n                 };\n                 spawntask_random(f);\n             };\n         };\n-        \n+\n         let f_cell = Cell(f);\n         let handles = Cell(handles);\n \n         rtdebug!(\"creating main task\");\n-        \n+\n         let main_task = ~do Coroutine::new(&mut scheds[0].stack_pool) {\n             f_cell.take()();\n             let mut handles = handles.take();\n@@ -210,7 +211,7 @@ pub fn run_in_mt_newsched_task_random_homed() {\n         };\n \n         rtdebug!(\"queuing main task\")\n-        \n+\n         scheds[0].enqueue_task(main_task);\n \n         let mut threads = ~[];\n@@ -243,11 +244,13 @@ pub fn run_in_mt_newsched_task_random_homed() {\n pub fn spawntask(f: ~fn()) {\n     use super::sched::*;\n \n+    rtdebug!(\"spawntask taking the scheduler from TLS\")\n     let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n                                      ~Task::without_unwinding(),\n                                      f);\n-    sched.schedule_new_task(task);\n+    rtdebug!(\"spawntask scheduling the new task\");\n+    sched.schedule_task(task);\n }\n \n /// Create a new task and run it right now. Aborts on failure\n@@ -305,7 +308,7 @@ pub fn spawntask_homed(scheds: &mut ~[~Scheduler], f: ~fn()) {\n     use super::sched::*;\n     use rand::{rng, RngUtil};\n     let mut rng = rng();\n-    \n+\n     let task = {\n         let sched = &mut scheds[rng.gen_int_range(0,scheds.len() as int)];\n         let handle = sched.make_handle();\n@@ -321,14 +324,15 @@ pub fn spawntask_homed(scheds: &mut ~[~Scheduler], f: ~fn()) {\n                 assert!(home_id == sched.sched_id());\n             };\n             f()\n-        };            \n-    \n+        };\n+\n         ~Coroutine::with_task_homed(&mut sched.stack_pool,\n                                     ~Task::without_unwinding(),\n                                     af,\n                                     Sched(handle))\n     };\n     let dest_sched = &mut scheds[rng.gen_int_range(0,scheds.len() as int)];\n+    // enqueue it for future execution\n     dest_sched.enqueue_task(task);\n }\n "}, {"sha": "5e507238f671fc52468f6cdb3a1b3d06e63ee1bb", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=d1ec8b5fb85cb6fd4caed64223c5cb3fd920daab", "patch": "@@ -578,7 +578,7 @@ fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n \n     let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::new(&mut sched.stack_pool, f);\n-    sched.schedule_new_task(task);\n+    sched.schedule_task(task);\n }\n \n fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {"}]}