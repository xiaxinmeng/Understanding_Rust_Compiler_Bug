{"sha": "2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZDMwM2ViMDdlNTFjZTBjNGY5ZGQ2YTI1M2FiNGU5MzhhYjY1ZjA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-09T10:31:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-09T10:51:07Z"}, "message": "make floating point casts nicer with generics", "tree": {"sha": "4e200694b483ae1866e849c0169734e1697d0286", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e200694b483ae1866e849c0169734e1697d0286"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0", "html_url": "https://github.com/rust-lang/rust/commit/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de7bcca6e4a5e2f999b6c4d1f06dac6074ad3e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/de7bcca6e4a5e2f999b6c4d1f06dac6074ad3e50", "html_url": "https://github.com/rust-lang/rust/commit/de7bcca6e4a5e2f999b6c4d1f06dac6074ad3e50"}], "stats": {"total": 88, "additions": 50, "deletions": 38}, "files": [{"sha": "5cc46b21fca1f1bf27de4e57f469d89b0ee6709b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0", "patch": "@@ -2035,6 +2035,14 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn is_fn_ptr(&self) -> bool {\n+        match self.sty {\n+            FnPtr(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_impl_trait(&self) -> bool {\n         match self.sty {\n             Opaque(..) => true,"}, {"sha": "7a0c98bc44c3751b1ef0bd2cee5a2efc71a3dac7", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0", "patch": "@@ -5,11 +5,11 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n+use rustc_apfloat::{Float, FloatConvert};\n use rustc::mir::interpret::{\n     Scalar, InterpResult, Pointer, PointerArithmetic, InterpError,\n };\n use rustc::mir::CastKind;\n-use rustc_apfloat::Float;\n \n use super::{InterpretCx, Machine, PlaceTy, OpTy, Immediate};\n \n@@ -126,7 +126,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         Ok(())\n     }\n \n-    pub(super) fn cast_scalar(\n+    fn cast_scalar(\n         &self,\n         val: Scalar<M::PointerTag>,\n         src_layout: TyLayout<'tcx>,\n@@ -135,23 +135,33 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n-        match val.to_bits_or_ptr(src_layout.size, self) {\n-            Err(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n-            Ok(data) => {\n-                match src_layout.ty.sty {\n-                    Float(fty) => self.cast_from_float(data, fty, dest_layout.ty),\n-                    _ => self.cast_from_int(data, src_layout, dest_layout),\n+        match src_layout.ty.sty {\n+            // Floating point\n+            Float(FloatTy::F32) => self.cast_from_float(val.to_f32()?, dest_layout.ty),\n+            Float(FloatTy::F64) => self.cast_from_float(val.to_f64()?, dest_layout.ty),\n+            // Integer(-like), including fn ptr casts\n+            _ => {\n+                assert!(\n+                    src_layout.ty.is_bool() || src_layout.ty.is_char() ||\n+                    src_layout.ty.is_integral()   || src_layout.ty.is_region_ptr() ||\n+                    src_layout.ty.is_unsafe_ptr() || src_layout.ty.is_fn_ptr(),\n+                    \"Unexpected cast from type {:?}\", src_layout.ty\n+                );\n+                match val.to_bits_or_ptr(src_layout.size, self) {\n+                    Err(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n+                    Ok(data) => self.cast_from_int(data, src_layout, dest_layout),\n                 }\n             }\n         }\n     }\n \n     fn cast_from_int(\n         &self,\n-        v: u128,\n+        v: u128, // raw bits\n         src_layout: TyLayout<'tcx>,\n         dest_layout: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        // Let's make sure v is sign-extended *if* it has a signed type.\n         let signed = src_layout.abi.is_signed();\n         let v = if signed {\n             self.sign_extend(v, src_layout)\n@@ -190,46 +200,36 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         }\n     }\n \n-    fn cast_from_float(\n+    fn cast_from_float<F>(\n         &self,\n-        bits: u128,\n-        fty: FloatTy,\n+        f: F,\n         dest_ty: Ty<'tcx>\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>>\n+    where F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>\n+    {\n         use rustc::ty::TyKind::*;\n-        use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {\n             // float -> uint\n             Uint(t) => {\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n-                let v = match fty {\n-                    FloatTy::F32 => Single::from_bits(bits).to_u128(width).value,\n-                    FloatTy::F64 => Double::from_bits(bits).to_u128(width).value,\n-                };\n+                let v = f.to_u128(width).value;\n                 // This should already fit the bit width\n                 Ok(Scalar::from_uint(v, Size::from_bits(width as u64)))\n             },\n             // float -> int\n             Int(t) => {\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n-                let v = match fty {\n-                    FloatTy::F32 => Single::from_bits(bits).to_i128(width).value,\n-                    FloatTy::F64 => Double::from_bits(bits).to_i128(width).value,\n-                };\n+                let v = f.to_i128(width).value;\n                 Ok(Scalar::from_int(v, Size::from_bits(width as u64)))\n             },\n-            // f64 -> f32\n-            Float(FloatTy::F32) if fty == FloatTy::F64 =>\n-                Ok(Scalar::from_f32(Double::from_bits(bits).convert(&mut false).value)),\n-            // f32 -> f64\n-            Float(FloatTy::F64) if fty == FloatTy::F32 =>\n-                Ok(Scalar::from_f64(Single::from_bits(bits).convert(&mut false).value)),\n-            // identity cast\n-            Float(FloatTy::F64) if fty == FloatTy::F64 =>\n-                Ok(Scalar::from_uint(bits, Size::from_bits(64))),\n-            Float(FloatTy::F32) if fty == FloatTy::F32 =>\n-                Ok(Scalar::from_uint(bits, Size::from_bits(32))),\n-            _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n+            // float -> f32\n+            Float(FloatTy::F32) =>\n+                Ok(Scalar::from_f32(f.convert(&mut false).value)),\n+            // float -> f64\n+            Float(FloatTy::F64) =>\n+                Ok(Scalar::from_f64(f.convert(&mut false).value)),\n+            // That's it.\n+            _ => bug!(\"invalid float to {:?} cast\", dest_ty),\n         }\n     }\n "}, {"sha": "db7da9359de7b7762bfc153120bdce4bd56dc699", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=2ad303eb07e51ce0c4f9dd6a253ab4e938ab65f0", "patch": "@@ -292,10 +292,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             }\n             _ => {\n                 // Must be integer(-like) types.  Don't forget about == on fn pointers.\n-                assert!(left.layout.ty.is_integral() || left.layout.ty.is_unsafe_ptr() ||\n-                    left.layout.ty.is_fn());\n-                assert!(right.layout.ty.is_integral() || right.layout.ty.is_unsafe_ptr() ||\n-                    right.layout.ty.is_fn());\n+                assert!(\n+                    left.layout.ty.is_integral()   ||\n+                    left.layout.ty.is_unsafe_ptr() || left.layout.ty.is_fn_ptr(),\n+                    \"Unexpected LHS type {:?} for BinOp {:?}\", left.layout.ty, bin_op);\n+                assert!(\n+                    right.layout.ty.is_integral()   ||\n+                    right.layout.ty.is_unsafe_ptr() || right.layout.ty.is_fn_ptr(),\n+                    \"Unexpected RHS type {:?} for BinOp {:?}\", right.layout.ty, bin_op);\n \n                 // Handle operations that support pointer values\n                 if left.to_scalar_ptr()?.is_ptr() ||"}]}