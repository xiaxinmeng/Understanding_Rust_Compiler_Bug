{"sha": "c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YTYxMDViY2NkNTU5OWRhZjBlY2VmNDBjNGI1ZmZhMTc1ZmMxYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-16T22:32:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-16T22:32:40Z"}, "message": "Auto merge of #79104 - m-ou-se:rollup-v74492y, r=m-ou-se\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #74989 (Implement `Index` and `IndexMut` for arrays)\n - #76339 (Test structural matching for all range types)\n - #77691 (Rename/Deprecate LayoutErr in favor of LayoutError)\n - #78364 (Update RELEASES.md for 1.48.0)\n - #78678 (Add tests and improve rendering of cfgs on traits)\n - #78714 (Simplify output capturing)\n - #78769 (Remove unneeded lifetimes in array/mod.rs)\n - #78903 (BTreeMap: test chaotic ordering & other bits & bobs)\n - #79032 (improve type const mismatch errors)\n - #79061 (Make all rustdoc functions and structs crate-private)\n - #79087 (Update E0744 about control flow in `const` contexts to accurately describe when the error is triggered and why)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4f3c7a87cf0dadf0ddc4485c9d823ac351058844", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f3c7a87cf0dadf0ddc4485c9d823ac351058844"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "html_url": "https://github.com/rust-lang/rust/commit/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5230fbf76bafd86ee4376a0e26e551df8d17fec", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5230fbf76bafd86ee4376a0e26e551df8d17fec", "html_url": "https://github.com/rust-lang/rust/commit/f5230fbf76bafd86ee4376a0e26e551df8d17fec"}, {"sha": "e6b6c8e4fc63b2229e4db079510c1dac26917437", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6b6c8e4fc63b2229e4db079510c1dac26917437", "html_url": "https://github.com/rust-lang/rust/commit/e6b6c8e4fc63b2229e4db079510c1dac26917437"}], "stats": {"total": 3472, "additions": 1863, "deletions": 1609}, "files": [{"sha": "9fd796fd775bf995f9d8a624704a36f1bbbabe7d", "filename": "RELEASES.md", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,3 +1,143 @@\n+Version 1.48.0 (2020-11-19)\n+==========================\n+\n+Language\n+--------\n+\n+- [The `unsafe` keyword is now syntactically permitted on modules.][75857] This\n+  is still rejected *semantically*, but can now be parsed by procedural macros.\n+\n+Compiler\n+--------\n+- [Stabilised the `-C link-self-contained=<yes|no>` compiler flag.][76158] This tells\n+  `rustc` whether to link its own C runtime and libraries or to rely on a external \n+  linker to find them. (Supported only on `windows-gnu`, `linux-musl`, and `wasi` platforms.)\n+- [You can now use `-C target-feature=+crt-static` on `linux-gnu` targets.][77386]\n+  Note: If you're using cargo you must explicitly pass the `--target` flag.\n+- [Added tier 2\\* support for `aarch64-unknown-linux-musl`.][76420]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [`io::Write` is now implemented for `&ChildStdin` `&Sink`, `&Stdout`,\n+  and `&Stderr`.][76275]\n+- [All arrays of any length now implement `TryFrom<Vec<T>>`.][76310]\n+- [The `matches!` macro now supports having a trailing comma.][74880]\n+- [`Vec<A>` now implements `PartialEq<[B]>` where `A: PartialEq<B>`.][74194]\n+- [The `RefCell::{replace, replace_with, clone}` methods now all use `#[track_caller]`.][77055]\n+\n+Stabilized APIs\n+---------------\n+- [`slice::as_ptr_range`]\n+- [`slice::as_mut_ptr_range`]\n+- [`VecDeque::make_contiguous`]\n+- [`future::pending`]\n+- [`future::ready`]\n+\n+The following previously stable methods are now `const fn`'s:\n+\n+- [`Option::is_some`]\n+- [`Option::is_none`]\n+- [`Option::as_ref`]\n+- [`Result::is_ok`]\n+- [`Result::is_err`]\n+- [`Result::as_ref`]\n+- [`Ordering::reverse`]\n+- [`Ordering::then`]\n+\n+Cargo\n+-----\n+\n+Rustdoc\n+-------\n+- [You can now link to items in `rustdoc` using the intra-doc link\n+  syntax.][74430] E.g. ``/// Uses [`std::future`]`` will automatically generate\n+  a link to `std::future`'s documentation. See [\"Linking to items by\n+  name\"][intradoc-links] for more information.\n+- [You can now specify `#[doc(alias = \"<alias>\")]` on items to add search aliases\n+  when searching through `rustdoc`'s UI.][75740]\n+\n+Compatibility Notes\n+-------------------\n+- [Promotion of references to `'static` lifetime inside `const fn` now follows the\n+  same rules as inside a `fn` body.][75502] In particular, `&foo()` will not be\n+  promoted to `'static` lifetime any more inside `const fn`s.\n+- [Associated type bindings on trait objects are now verified to meet the bounds\n+  declared on the trait when checking that they implement the trait.][27675]\n+- [When trait bounds on associated types or opaque types are ambiguous, the\n+  compiler no longer makes an arbitrary choice on which bound to use.][54121]\n+- [Fixed recursive nonterminals not being expanded in macros during\n+  pretty-print/reparse check.][77153] This may cause errors if your macro wasn't\n+  correctly handling recursive nonterminal tokens.\n+- [`&mut` references to non zero-sized types are no longer promoted.][75585]\n+- [`rustc` will now warn if you use attributes like `#[link_name]` or `#[cold]`\n+  in places where they have no effect.][73461]\n+- [Updated `_mm256_extract_epi8` and `_mm256_extract_epi16` signatures in\n+  `arch::{x86, x86_64}` to return `i32` to match the vendor signatures.][73166]\n+- [`mem::uninitialized` will now panic if any inner types inside a struct or enum\n+  disallow zero-initialization.][71274]\n+- [`#[target_feature]` will now error if used in a place where it has no effect.][78143]\n+- [Foreign exceptions are now caught by `catch_unwind` and will cause an abort.][70212]\n+  Note: This behaviour is not guaranteed and is still considered undefined behaviour,\n+  see the [`catch_unwind`] documentation for further information.\n+  \n+\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc and\n+related tools.\n+\n+- [Building `rustc` from source now uses `ninja` by default over `make`.][74922]\n+  You can continue building with `make` by setting `ninja=false` in\n+  your `config.toml`.\n+- [cg_llvm: `fewer_names` in `uncached_llvm_type`][76030]\n+- [Made `ensure_sufficient_stack()` non-generic][76680]\n+\n+[78143]: https://github.com/rust-lang/rust/issues/78143\n+[76680]: https://github.com/rust-lang/rust/pull/76680/\n+[76030]: https://github.com/rust-lang/rust/pull/76030/\n+[70212]: https://github.com/rust-lang/rust/pull/70212/\n+[27675]: https://github.com/rust-lang/rust/issues/27675/\n+[54121]: https://github.com/rust-lang/rust/issues/54121/  \n+[71274]: https://github.com/rust-lang/rust/pull/71274/\n+[77386]: https://github.com/rust-lang/rust/pull/77386/\n+[77153]: https://github.com/rust-lang/rust/pull/77153/\n+[77055]: https://github.com/rust-lang/rust/pull/77055/\n+[76275]: https://github.com/rust-lang/rust/pull/76275/\n+[76310]: https://github.com/rust-lang/rust/pull/76310/\n+[76420]: https://github.com/rust-lang/rust/pull/76420/\n+[76158]: https://github.com/rust-lang/rust/pull/76158/\n+[75857]: https://github.com/rust-lang/rust/pull/75857/\n+[75585]: https://github.com/rust-lang/rust/pull/75585/\n+[75740]: https://github.com/rust-lang/rust/pull/75740/\n+[75502]: https://github.com/rust-lang/rust/pull/75502/\n+[74880]: https://github.com/rust-lang/rust/pull/74880/\n+[74922]: https://github.com/rust-lang/rust/pull/74922/\n+[74430]: https://github.com/rust-lang/rust/pull/74430/\n+[74194]: https://github.com/rust-lang/rust/pull/74194/\n+[73461]: https://github.com/rust-lang/rust/pull/73461/\n+[73166]: https://github.com/rust-lang/rust/pull/73166/\n+[intradoc-links]: https://doc.rust-lang.org/rustdoc/linking-to-items-by-name.html\n+[`catch_unwind`]: https://doc.rust-lang.org/std/panic/fn.catch_unwind.html\n+[`Option::is_some`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some\n+[`Option::is_none`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none\n+[`Option::as_ref`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref\n+[`Result::is_ok`]: https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok\n+[`Result::is_err`]: https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err\n+[`Result::as_ref`]: https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref\n+[`Ordering::reverse`]: https://doc.rust-lang.org/std/cmp/enum.Ordering.html#method.reverse\n+[`Ordering::then`]: https://doc.rust-lang.org/std/cmp/enum.Ordering.html#method.then\n+[`slice::as_ptr_range`]: https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range\n+[`slice::as_mut_ptr_range`]: https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr_range\n+[`VecDeque::make_contiguous`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.make_contiguous\n+[`future::pending`]: https://doc.rust-lang.org/std/future/fn.pending.html\n+[`future::ready`]: https://doc.rust-lang.org/std/future/fn.ready.html\n+\n+\n Version 1.47.0 (2020-10-08)\n ==========================\n \n@@ -90,6 +230,7 @@ Compatibility Notes\n \n Internal Only\n --------\n+\n - [Improved default settings for bootstrapping in `x.py`.][73964] You can read details about this change in the [\"Changes to `x.py` defaults\"](https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html) post on the Inside Rust blog.\n \n [1.47.0-cfg]: https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard"}, {"sha": "45804ab266e286d03e32a7d3be60cce926674dae", "filename": "compiler/rustc_error_codes/src/error_codes/E0744.md", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0744.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0744.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0744.md?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,4 +1,4 @@\n-A control-flow expression was used inside a const context.\n+An unsupported expression was used inside a const context.\n \n Erroneous code example:\n \n@@ -12,12 +12,15 @@ const _: i32 = {\n };\n ```\n \n-At the moment, `if` and `match`, as well as the looping constructs `for`,\n-`while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n+At the moment, `for` loops, `.await`, and the `Try` operator (`?`) are forbidden\n+inside a `const`, `static`, or `const fn`.\n \n-This will be allowed at some point in the future, but the implementation is not\n-yet complete. See the tracking issue for [conditionals] or [loops] in a const\n-context for the current status.\n+This may be allowed at some point in the future, but the implementation is not\n+yet complete. See the tracking issues for [`async`] and [`?`] in `const fn`, and\n+(to support `for` loops in `const fn`) the tracking issues for [`impl const\n+Trait for Ty`] and [`&mut T`] in `const fn`.\n \n-[conditionals]: https://github.com/rust-lang/rust/issues/49146\n-[loops]: https://github.com/rust-lang/rust/issues/52000\n+[`async`]: https://github.com/rust-lang/rust/issues/69431\n+[`?`]: https://github.com/rust-lang/rust/issues/74935\n+[`impl const Trait for Ty`]: https://github.com/rust-lang/rust/issues/67792\n+[`&mut T`]: https://github.com/rust-lang/rust/issues/57349"}, {"sha": "4497c8c0eaaa8cef1f90fb33802ac7a00a1e47b2", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -282,6 +282,14 @@ impl GenericArg<'_> {\n             GenericArg::Const(_) => \"constant\",\n         }\n     }\n+\n+    pub fn short_descr(&self) -> &'static str {\n+        match self {\n+            GenericArg::Lifetime(_) => \"lifetime\",\n+            GenericArg::Type(_) => \"type\",\n+            GenericArg::Const(_) => \"const\",\n+        }\n+    }\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "0935eb2bd7199cad3d5810684c37767d23993aea", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,6 +1,6 @@\n #![feature(bool_to_option)]\n #![feature(box_syntax)]\n-#![feature(set_stdio)]\n+#![feature(internal_output_capture)]\n #![feature(nll)]\n #![feature(generator_trait)]\n #![feature(generators)]"}, {"sha": "20a7b47313ecf5d08e4bf16eb9b01acd260370c1", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -25,7 +25,7 @@ use rustc_span::symbol::{sym, Symbol};\n use smallvec::SmallVec;\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n-use std::io::{self, Write};\n+use std::io;\n use std::lazy::SyncOnceCell;\n use std::mem;\n use std::ops::DerefMut;\n@@ -106,21 +106,6 @@ fn get_stack_size() -> Option<usize> {\n     env::var_os(\"RUST_MIN_STACK\").is_none().then_some(STACK_SIZE)\n }\n \n-struct Sink(Arc<Mutex<Vec<u8>>>);\n-impl Write for Sink {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Write::write(&mut *self.0.lock().unwrap(), data)\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-impl io::LocalOutput for Sink {\n-    fn clone_box(&self) -> Box<dyn io::LocalOutput> {\n-        Box::new(Self(self.0.clone()))\n-    }\n-}\n-\n /// Like a `thread::Builder::spawn` followed by a `join()`, but avoids the need\n /// for `'static` bounds.\n #[cfg(not(parallel_compiler))]\n@@ -163,9 +148,7 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n \n     let main_handler = move || {\n         rustc_span::with_session_globals(edition, || {\n-            if let Some(stderr) = stderr {\n-                io::set_panic(Some(box Sink(stderr.clone())));\n-            }\n+            io::set_output_capture(stderr.clone());\n             f()\n         })\n     };\n@@ -203,9 +186,7 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n             // on the new threads.\n             let main_handler = move |thread: rayon::ThreadBuilder| {\n                 rustc_span::SESSION_GLOBALS.set(session_globals, || {\n-                    if let Some(stderr) = stderr {\n-                        io::set_panic(Some(box Sink(stderr.clone())));\n-                    }\n+                    io::set_output_capture(stderr.clone());\n                     thread.run()\n                 })\n             };"}, {"sha": "0db5fda272a262db2436215889e865b64d4c2232", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 79, "deletions": 103, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -23,6 +23,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         sess: &Session,\n         arg: &GenericArg<'_>,\n         kind: &'static str,\n+        possible_ordering_error: bool,\n         help: Option<&str>,\n     ) {\n         let mut err = struct_span_err!(\n@@ -49,8 +50,23 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             GenericArg::Const(_) => ParamKindOrd::Const { unordered },\n         };\n \n+        if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Path { .. }, .. }))\n+            && matches!(kind_ord, ParamKindOrd::Const { .. })\n+        {\n+            let suggestions = vec![\n+                (arg.span().shrink_to_lo(), String::from(\"{ \")),\n+                (arg.span().shrink_to_hi(), String::from(\" }\")),\n+            ];\n+            err.multipart_suggestion(\n+                \"if this generic argument was intended as a const parameter, \\\n+                try surrounding it with braces:\",\n+                suggestions,\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n         // This note is only true when generic parameters are strictly ordered by their kind.\n-        if kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n+        if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n             let (first, last) =\n                 if kind_ord < arg_ord { (kind, arg.descr()) } else { (arg.descr(), kind) };\n             err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n@@ -148,8 +164,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // Check whether this segment takes generic arguments and the user has provided any.\n             let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n \n-            let mut args =\n-                generic_args.iter().flat_map(|generic_args| generic_args.args.iter()).peekable();\n+            let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n+            let mut args = args_iter.clone().peekable();\n \n             // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n             // If we later encounter a lifetime, we know that the arguments were provided in the\n@@ -216,8 +232,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                                     GenericParamDefKind::Const => {\n                                                         ParamKindOrd::Const {\n                                                             unordered: tcx\n-                                                                .sess\n-                                                                .features_untracked()\n+                                                                .features()\n                                                                 .const_generics,\n                                                         }\n                                                     }\n@@ -237,6 +252,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                         tcx.sess,\n                                         arg,\n                                         kind.descr(),\n+                                        !args_iter.clone().is_sorted_by_key(|arg| match arg {\n+                                            GenericArg::Lifetime(_) => ParamKindOrd::Lifetime,\n+                                            GenericArg::Type(_) => ParamKindOrd::Type,\n+                                            GenericArg::Const(_) => ParamKindOrd::Const {\n+                                                unordered: tcx.features().const_generics,\n+                                            },\n+                                        }),\n                                         Some(&format!(\n                                             \"reorder the arguments: {}: `<{}>`\",\n                                             param_types_present\n@@ -288,7 +310,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             assert_eq!(kind, \"lifetime\");\n                             let provided =\n                                 force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n-                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind, None);\n+                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind, false, None);\n                         }\n \n                         break;\n@@ -346,6 +368,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n         let param_counts = def.own_counts();\n+        let named_type_param_count = param_counts.types - has_self as usize;\n         let arg_counts = args.own_counts();\n         let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n \n@@ -384,11 +407,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n             // For other kinds (i.e., types), `permitted` may be greater than `required`.\n             if required <= provided && provided <= permitted {\n-                return Ok(());\n+                return true;\n             }\n \n             if silent {\n-                return Err((0i32, None));\n+                return false;\n             }\n \n             // Unfortunately lifetime and type parameter mismatches are typically styled\n@@ -404,25 +427,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 (required, \"\")\n             };\n \n-            let (spans, label) = if required == permitted && provided > permitted {\n+            let (spans, labels) = if provided > permitted {\n                 // In the case when the user has provided too many arguments,\n                 // we want to point to the unexpected arguments.\n-                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n+                let (spans, labels): (Vec<Span>, Vec<String>) = args.args\n+                    [offset + permitted..offset + provided]\n                     .iter()\n-                    .map(|arg| arg.span())\n-                    .collect();\n+                    .map(|arg| (arg.span(), format!(\"unexpected {} argument\", arg.short_descr())))\n+                    .unzip();\n                 unexpected_spans.extend(spans.clone());\n-                (spans, format!(\"unexpected {} argument\", kind))\n+                (spans, labels)\n             } else {\n                 (\n                     vec![span],\n-                    format!(\n+                    vec![format!(\n                         \"expected {}{} {} argument{}\",\n                         quantifier,\n                         bound,\n                         kind,\n                         pluralize!(bound),\n-                    ),\n+                    )],\n                 )\n             };\n \n@@ -434,105 +458,57 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ),\n                 DiagnosticId::Error(\"E0107\".into()),\n             );\n-            for span in spans {\n+            for (span, label) in spans.into_iter().zip(labels) {\n                 err.span_label(span, label.as_str());\n             }\n-\n-            assert_ne!(bound, provided);\n-            Err((bound as i32 - provided as i32, Some(err)))\n+            err.emit();\n+            false\n         };\n \n         let mut unexpected_spans = vec![];\n \n-        let mut lifetime_count_correct = Ok(());\n-        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n-            lifetime_count_correct = check_kind_count(\n-                \"lifetime\",\n-                param_counts.lifetimes,\n-                param_counts.lifetimes,\n-                arg_counts.lifetimes,\n-                0,\n-                &mut unexpected_spans,\n-                explicit_late_bound == ExplicitLateBound::Yes,\n-            );\n-        }\n-\n-        // FIXME(const_generics:defaults)\n-        let mut const_count_correct = Ok(());\n-        if !infer_args || arg_counts.consts > param_counts.consts {\n-            const_count_correct = check_kind_count(\n-                \"const\",\n-                param_counts.consts,\n-                param_counts.consts,\n-                arg_counts.consts,\n-                arg_counts.lifetimes + arg_counts.types,\n-                &mut unexpected_spans,\n-                false,\n-            );\n-        }\n-\n-        // Note that type errors are currently be emitted *after* const errors.\n-        let mut type_count_correct = Ok(());\n-        if !infer_args || arg_counts.types > param_counts.types - defaults.types - has_self as usize\n-        {\n-            type_count_correct = check_kind_count(\n-                \"type\",\n-                param_counts.types - defaults.types - has_self as usize,\n-                param_counts.types - has_self as usize,\n-                arg_counts.types,\n-                arg_counts.lifetimes,\n-                &mut unexpected_spans,\n-                false,\n-            );\n-        }\n-\n-        // Emit a help message if it's possible that a type could be surrounded in braces\n-        if let Err((c_mismatch, Some(ref mut _const_err))) = const_count_correct {\n-            if let Err((_, Some(ref mut type_err))) = type_count_correct {\n-                let possible_matches = args.args[arg_counts.lifetimes..]\n-                    .iter()\n-                    .filter(|arg| {\n-                        matches!(\n-                            arg,\n-                            GenericArg::Type(hir::Ty { kind: hir::TyKind::Path { .. }, .. })\n-                        )\n-                    })\n-                    .take(c_mismatch.max(0) as usize);\n-                for arg in possible_matches {\n-                    let suggestions = vec![\n-                        (arg.span().shrink_to_lo(), String::from(\"{ \")),\n-                        (arg.span().shrink_to_hi(), String::from(\" }\")),\n-                    ];\n-                    type_err.multipart_suggestion(\n-                        \"If this generic argument was intended as a const parameter, \\\n-                        try surrounding it with braces:\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n-        }\n+        let lifetime_count_correct = check_kind_count(\n+            \"lifetime\",\n+            if infer_lifetimes { 0 } else { param_counts.lifetimes },\n+            param_counts.lifetimes,\n+            arg_counts.lifetimes,\n+            0,\n+            &mut unexpected_spans,\n+            explicit_late_bound == ExplicitLateBound::Yes,\n+        );\n \n-        let emit_correct =\n-            |correct: Result<(), (_, Option<rustc_errors::DiagnosticBuilder<'_>>)>| match correct {\n-                Ok(()) => Ok(()),\n-                Err((_, None)) => Err(()),\n-                Err((_, Some(mut err))) => {\n-                    err.emit();\n-                    Err(())\n-                }\n-            };\n+        let kind_str = if param_counts.consts + arg_counts.consts == 0 {\n+            \"type\"\n+        } else if named_type_param_count + arg_counts.types == 0 {\n+            \"const\"\n+        } else {\n+            \"generic\"\n+        };\n \n-        let arg_count_correct = emit_correct(lifetime_count_correct)\n-            .and(emit_correct(const_count_correct))\n-            .and(emit_correct(type_count_correct));\n+        let arg_count_correct = check_kind_count(\n+            kind_str,\n+            if infer_args {\n+                0\n+            } else {\n+                param_counts.consts + named_type_param_count - defaults.types\n+            },\n+            param_counts.consts + named_type_param_count,\n+            arg_counts.consts + arg_counts.types,\n+            arg_counts.lifetimes,\n+            &mut unexpected_spans,\n+            false,\n+        );\n \n         GenericArgCountResult {\n             explicit_late_bound,\n-            correct: arg_count_correct.map_err(|()| GenericArgCountMismatch {\n-                reported: Some(ErrorReported),\n-                invalid_args: unexpected_spans,\n-            }),\n+            correct: if lifetime_count_correct && arg_count_correct {\n+                Ok(())\n+            } else {\n+                Err(GenericArgCountMismatch {\n+                    reported: Some(ErrorReported),\n+                    invalid_args: unexpected_spans,\n+                })\n+            },\n         }\n     }\n "}, {"sha": "929c88455f04134de9346b2cdc6f6ff37b88e739", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -61,6 +61,7 @@ This API is completely unstable and subject to change.\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n+#![feature(is_sorted)]\n #![feature(nll)]\n #![feature(or_patterns)]\n #![feature(try_blocks)]"}, {"sha": "6e45d38dd9f912f9ee40e9407879b2a1059bc2e7", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 121, "deletions": 25, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -14,6 +14,9 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n+mod ord_chaos;\n+use ord_chaos::{Cyclic3, Governed, Governor};\n+\n // Capacity of a tree with a single level,\n // i.e., a tree who's root is a leaf node at height 0.\n const NODE_CAPACITY: usize = node::CAPACITY;\n@@ -28,7 +31,7 @@ const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_2: usize = 89;\n \n-// Gather all references from a mutable iterator and make sure Miri notices if\n+// Gathers all references from a mutable iterator and makes sure Miri notices if\n // using them is dangerous.\n fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>) {\n     // Gather all those references.\n@@ -43,28 +46,43 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n }\n \n impl<K, V> BTreeMap<K, V> {\n-    /// Panics if the map (or the code navigating it) is corrupted.\n-    fn check(&self)\n-    where\n-        K: Copy + Debug + Ord,\n-    {\n+    // Panics if the map (or the code navigating it) is corrupted.\n+    fn check_invariants(&self) {\n         if let Some(root) = &self.root {\n             let root_node = root.node_as_ref();\n \n+            // Check the back pointers top-down, before we attempt to rely on\n+            // more serious navigation code.\n             assert!(root_node.ascend().is_err());\n             root_node.assert_back_pointers();\n \n+            // Check consistenty of `length` and some of the navigation.\n             assert_eq!(self.length, root_node.calc_length());\n+            assert_eq!(self.length, self.keys().count());\n \n+            // Lastly, check the invariant causing the least harm.\n             root_node.assert_min_len(if root_node.height() > 0 { 1 } else { 0 });\n         } else {\n+            // Check consistenty of `length` and some of the navigation.\n             assert_eq!(self.length, 0);\n+            assert_eq!(self.length, self.keys().count());\n         }\n+    }\n \n-        self.assert_ascending();\n+    // Panics if the map is corrupted or if the keys are not in strictly\n+    // ascending order, in the current opinion of the `Ord` implementation.\n+    // If the `Ord` implementation does not honor transitivity, this method\n+    // does not guarantee that all the keys are unique, just that adjacent\n+    // keys are unique.\n+    fn check(&self)\n+    where\n+        K: Debug + Ord,\n+    {\n+        self.check_invariants();\n+        self.assert_strictly_ascending();\n     }\n \n-    /// Returns the height of the root, if any.\n+    // Returns the height of the root, if any.\n     fn height(&self) -> Option<usize> {\n         self.root.as_ref().map(node::Root::height)\n     }\n@@ -80,22 +98,18 @@ impl<K, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Asserts that the keys are in strictly ascending order.\n-    fn assert_ascending(&self)\n+    // Panics if the keys are not in strictly ascending order.\n+    fn assert_strictly_ascending(&self)\n     where\n-        K: Copy + Debug + Ord,\n+        K: Debug + Ord,\n     {\n-        let mut num_seen = 0;\n         let mut keys = self.keys();\n         if let Some(mut previous) = keys.next() {\n-            num_seen = 1;\n             for next in keys {\n                 assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n                 previous = next;\n-                num_seen += 1;\n             }\n         }\n-        assert_eq!(num_seen, self.len());\n     }\n }\n \n@@ -111,7 +125,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n     }\n }\n \n-// Test our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n+// Tests our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n // implementation of insertion, but it's best to be aware of when it does.\n #[test]\n fn test_levels() {\n@@ -149,6 +163,25 @@ fn test_levels() {\n     assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2, \"{}\", map.dump_keys());\n }\n \n+// Ensures the testing infrastructure usually notices order violations.\n+#[test]\n+#[should_panic]\n+fn test_check_ord_chaos() {\n+    let gov = Governor::new();\n+    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    gov.flip();\n+    map.check();\n+}\n+\n+// Ensures the testing infrastructure doesn't always mind order violations.\n+#[test]\n+fn test_check_invariants_ord_chaos() {\n+    let gov = Governor::new();\n+    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    gov.flip();\n+    map.check_invariants();\n+}\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n@@ -334,7 +367,7 @@ fn test_iter_rev() {\n     test(size, map.into_iter().rev());\n }\n \n-/// Specifically tests iter_mut's ability to mutate the value of pairs in-line\n+// Specifically tests iter_mut's ability to mutate the value of pairs in-line.\n fn do_test_iter_mut_mutation<T>(size: usize)\n where\n     T: Copy + Debug + Ord + TryFrom<usize>,\n@@ -439,6 +472,8 @@ fn test_iter_entering_root_twice() {\n     *back.1 = 42;\n     assert_eq!(front, (&0, &mut 24));\n     assert_eq!(back, (&1, &mut 42));\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next_back(), None);\n     map.check();\n }\n \n@@ -591,11 +626,12 @@ fn test_range_small() {\n \n #[test]\n fn test_range_height_1() {\n-    // Tests tree with a root and 2 leaves. Depending on details we don't want or need\n-    // to rely upon, the single key at the root will be 6 or 7.\n+    // Tests tree with a root and 2 leaves. The single key in the root node is\n+    // close to the middle among the keys.\n \n-    let map: BTreeMap<_, _> = (1..=MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n-    for &root in &[6, 7] {\n+    let map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n+    let middle = MIN_INSERTS_HEIGHT_1 as i32 / 2;\n+    for root in middle - 2..=middle + 2 {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n         assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n         assert_eq!(range_keys(&map, (Included(root), Excluded(root + 1))), vec![root]);\n@@ -727,6 +763,19 @@ fn test_range_backwards_4() {\n     map.range((Excluded(3), Excluded(2)));\n }\n \n+#[test]\n+#[should_panic]\n+fn test_range_backwards_5() {\n+    let mut map = BTreeMap::new();\n+    map.insert(Cyclic3::B, ());\n+    // Lacking static_assert, call `range` conditionally, to emphasise that\n+    // we cause a different panic than `test_range_backwards_1` does.\n+    // A more refined `should_panic` would be welcome.\n+    if Cyclic3::C < Cyclic3::A {\n+        map.range(Cyclic3::C..=Cyclic3::A);\n+    }\n+}\n+\n #[test]\n fn test_range_1000() {\n     // Miri is too slow\n@@ -831,18 +880,28 @@ mod test_drain_filter {\n     }\n \n     #[test]\n-    fn consuming_nothing() {\n+    fn consumed_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n \n     #[test]\n-    fn consuming_all() {\n+    fn consumed_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.clone().collect();\n         assert!(map.drain_filter(|_, _| true).eq(pairs));\n+        assert!(map.is_empty());\n+        map.check();\n+    }\n+\n+    #[test]\n+    fn dropped_removing_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n         map.check();\n     }\n \n@@ -1723,6 +1782,27 @@ fn test_append_drop_leak() {\n     assert_eq!(DROPS.load(Ordering::SeqCst), 4); // Rust issue #47949 ate one little piggy\n }\n \n+#[test]\n+fn test_append_ord_chaos() {\n+    let mut map1 = BTreeMap::new();\n+    map1.insert(Cyclic3::A, ());\n+    map1.insert(Cyclic3::B, ());\n+    let mut map2 = BTreeMap::new();\n+    map2.insert(Cyclic3::A, ());\n+    map2.insert(Cyclic3::B, ());\n+    map2.insert(Cyclic3::C, ()); // lands first, before A\n+    map2.insert(Cyclic3::B, ()); // lands first, before C\n+    map1.check();\n+    map2.check(); // keys are not unique but still strictly ascending\n+    assert_eq!(map1.len(), 2);\n+    assert_eq!(map2.len(), 4);\n+    map1.append(&mut map2);\n+    assert_eq!(map1.len(), 5);\n+    assert_eq!(map2.len(), 0);\n+    map1.check();\n+    map2.check();\n+}\n+\n fn rand_data(len: usize) -> Vec<(u32, u32)> {\n     assert!(len * 2 <= 70029); // from that point on numbers repeat\n     let mut rng = DeterministicRng::new();\n@@ -1885,11 +1965,27 @@ fn test_insert_remove_intertwined() {\n     let loops = if cfg!(miri) { 100 } else { 1_000_000 };\n     let mut map = BTreeMap::new();\n     let mut i = 1;\n+    let offset = 165; // somewhat arbitrarily chosen to cover some code paths\n     for _ in 0..loops {\n-        i = (i + 421) & 0xFF;\n+        i = (i + offset) & 0xFF;\n         map.insert(i, i);\n         map.remove(&(0xFF - i));\n     }\n-\n     map.check();\n }\n+\n+#[test]\n+fn test_insert_remove_intertwined_ord_chaos() {\n+    let loops = if cfg!(miri) { 100 } else { 1_000_000 };\n+    let gov = Governor::new();\n+    let mut map = BTreeMap::new();\n+    let mut i = 1;\n+    let offset = 165; // more arbitrarily copied from above\n+    for _ in 0..loops {\n+        i = (i + offset) & 0xFF;\n+        map.insert(Governed(i, &gov), ());\n+        map.remove(&Governed(0xFF - i, &gov));\n+        gov.flip();\n+    }\n+    map.check_invariants();\n+}"}, {"sha": "91d1d6ea9ef38f48fe9ef73171c4ebc6014a3514", "filename": "library/alloc/src/collections/btree/map/tests/ord_chaos.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -0,0 +1,76 @@\n+use std::cell::Cell;\n+use std::cmp::Ordering::{self, *};\n+use std::ptr;\n+\n+#[derive(Debug)]\n+pub enum Cyclic3 {\n+    A,\n+    B,\n+    C,\n+}\n+use Cyclic3::*;\n+\n+impl PartialOrd for Cyclic3 {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Cyclic3 {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        match (self, other) {\n+            (A, A) | (B, B) | (C, C) => Equal,\n+            (A, B) | (B, C) | (C, A) => Less,\n+            (A, C) | (B, A) | (C, B) => Greater,\n+        }\n+    }\n+}\n+\n+impl PartialEq for Cyclic3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.cmp(&other) == Equal\n+    }\n+}\n+\n+impl Eq for Cyclic3 {}\n+\n+#[derive(Debug)]\n+pub struct Governor {\n+    flipped: Cell<bool>,\n+}\n+\n+impl Governor {\n+    pub fn new() -> Self {\n+        Governor { flipped: Cell::new(false) }\n+    }\n+\n+    pub fn flip(&self) {\n+        self.flipped.set(!self.flipped.get());\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Governed<'a, T>(pub T, pub &'a Governor);\n+\n+impl<T: Ord> PartialOrd for Governed<'_, T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl<T: Ord> Ord for Governed<'_, T> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        assert!(ptr::eq(self.1, other.1));\n+        let ord = self.0.cmp(&other.0);\n+        if self.1.flipped.get() { ord.reverse() } else { ord }\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for Governed<'_, T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        assert!(ptr::eq(self.1, other.1));\n+        self.0.eq(&other.0)\n+    }\n+}\n+\n+impl<T: Eq> Eq for Governed<'_, T> {}"}, {"sha": "b04b29320ac988756eb6bc337ac35da52bdca65f", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -5,7 +5,7 @@ use crate::string::String;\n use core::cmp::Ordering::*;\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Asserts that the back pointer in each reachable node points to its parent.\n+    // Asserts that the back pointer in each reachable node points to its parent.\n     pub fn assert_back_pointers(self) {\n         if let ForceResult::Internal(node) = self.force() {\n             for idx in 0..=node.len() {\n@@ -17,6 +17,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n         }\n     }\n \n+    // Renders a multi-line display of the keys in order and in tree hierarchy,\n+    // picturing the tree growing sideways from its root on the left to its\n+    // leaves on the right.\n     pub fn dump_keys(self) -> String\n     where\n         K: Debug,"}, {"sha": "8213e904fba2f4428a015cc7ba04efba1ec8fc32", "filename": "library/alloc/src/collections/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -41,7 +41,7 @@ pub use linked_list::LinkedList;\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;\n \n-use crate::alloc::{Layout, LayoutErr};\n+use crate::alloc::{Layout, LayoutError};\n use core::fmt::Display;\n \n /// The error type for `try_reserve` methods.\n@@ -71,9 +71,9 @@ pub enum TryReserveError {\n }\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n-impl From<LayoutErr> for TryReserveError {\n+impl From<LayoutError> for TryReserveError {\n     #[inline]\n-    fn from(_: LayoutErr) -> Self {\n+    fn from(_: LayoutError) -> Self {\n         TryReserveError::CapacityOverflow\n     }\n }"}, {"sha": "522c5bcf5af109004ccc61acf4ab4398915529ac", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,7 +1,7 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n-use core::alloc::LayoutErr;\n+use core::alloc::LayoutError;\n use core::cmp;\n use core::intrinsics;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n@@ -472,7 +472,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n // significant, because the number of different `A` types seen in practice is\n // much smaller than the number of `T` types.)\n fn finish_grow<A>(\n-    new_layout: Result<Layout, LayoutErr>,\n+    new_layout: Result<Layout, LayoutError>,\n     current_memory: Option<(NonNull<u8>, Layout)>,\n     alloc: &mut A,\n ) -> Result<NonNull<[u8]>, TryReserveError>"}, {"sha": "2258d9614d53b767bef6d17652481e59d87bb360", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -39,7 +39,7 @@ pub struct Layout {\n \n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `LayoutErr` if any of the following conditions\n+    /// or returns `LayoutError` if any of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must not be zero,\n@@ -52,9 +52,9 @@ impl Layout {\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n+    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutError> {\n         if !align.is_power_of_two() {\n-            return Err(LayoutErr { private: () });\n+            return Err(LayoutError { private: () });\n         }\n \n         // (power-of-two implies align != 0.)\n@@ -72,7 +72,7 @@ impl Layout {\n         // Above implies that checking for summation overflow is both\n         // necessary and sufficient.\n         if size > usize::MAX - (align - 1) {\n-            return Err(LayoutErr { private: () });\n+            return Err(LayoutError { private: () });\n         }\n \n         // SAFETY: the conditions for `from_size_align_unchecked` have been\n@@ -200,7 +200,7 @@ impl Layout {\n     /// `align` violates the conditions listed in [`Layout::from_size_align`].\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n-    pub fn align_to(&self, align: usize) -> Result<Self, LayoutErr> {\n+    pub fn align_to(&self, align: usize) -> Result<Self, LayoutError> {\n         Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n     }\n \n@@ -274,16 +274,16 @@ impl Layout {\n     /// layout of the array and `offs` is the distance between the start\n     /// of each element in the array.\n     ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n+    /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n-    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n+    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {\n         // This cannot overflow. Quoting from the invariant of Layout:\n         // > `size`, when rounded up to the nearest multiple of `align`,\n         // > must not overflow (i.e., the rounded value must be less than\n         // > `usize::MAX`)\n         let padded_size = self.size() + self.padding_needed_for(self.align());\n-        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n+        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutError { private: () })?;\n \n         // SAFETY: self.align is already known to be valid and alloc_size has been\n         // padded already.\n@@ -307,16 +307,16 @@ impl Layout {\n     /// start of the `next` embedded within the concatenated record\n     /// (assuming that the record itself starts at offset 0).\n     ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n+    /// On arithmetic overflow, returns `LayoutError`.\n     ///\n     /// # Examples\n     ///\n     /// To calculate the layout of a `#[repr(C)]` structure and the offsets of\n     /// the fields from its fields' layouts:\n     ///\n     /// ```rust\n-    /// # use std::alloc::{Layout, LayoutErr};\n-    /// pub fn repr_c(fields: &[Layout]) -> Result<(Layout, Vec<usize>), LayoutErr> {\n+    /// # use std::alloc::{Layout, LayoutError};\n+    /// pub fn repr_c(fields: &[Layout]) -> Result<(Layout, Vec<usize>), LayoutError> {\n     ///     let mut offsets = Vec::new();\n     ///     let mut layout = Layout::from_size_align(0, 1)?;\n     ///     for &field in fields {\n@@ -337,12 +337,12 @@ impl Layout {\n     /// ```\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n-    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n+    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutError> {\n         let new_align = cmp::max(self.align(), next.align());\n         let pad = self.padding_needed_for(next.align());\n \n-        let offset = self.size().checked_add(pad).ok_or(LayoutErr { private: () })?;\n-        let new_size = offset.checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n+        let offset = self.size().checked_add(pad).ok_or(LayoutError { private: () })?;\n+        let new_size = offset.checked_add(next.size()).ok_or(LayoutError { private: () })?;\n \n         let layout = Layout::from_size_align(new_size, new_align)?;\n         Ok((layout, offset))\n@@ -359,11 +359,11 @@ impl Layout {\n     /// guaranteed that all elements in the array will be properly\n     /// aligned.\n     ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n+    /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n-    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n-        let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n+    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutError> {\n+        let size = self.size().checked_mul(n).ok_or(LayoutError { private: () })?;\n         Layout::from_size_align(size, self.align())\n     }\n \n@@ -372,38 +372,46 @@ impl Layout {\n     /// padding is inserted, the alignment of `next` is irrelevant,\n     /// and is not incorporated *at all* into the resulting layout.\n     ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n+    /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n-    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutErr> {\n-        let new_size = self.size().checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n+    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutError> {\n+        let new_size = self.size().checked_add(next.size()).ok_or(LayoutError { private: () })?;\n         Layout::from_size_align(new_size, self.align())\n     }\n \n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n+    /// On arithmetic overflow, returns `LayoutError`.\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n-    pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n+    pub fn array<T>(n: usize) -> Result<Self, LayoutError> {\n         let (layout, offset) = Layout::new::<T>().repeat(n)?;\n         debug_assert_eq!(offset, mem::size_of::<T>());\n         Ok(layout.pad_to_align())\n     }\n }\n \n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+#[rustc_deprecated(\n+    since = \"1.51.0\",\n+    reason = \"Name does not follow std convention, use LayoutError\",\n+    suggestion = \"LayoutError\"\n+)]\n+pub type LayoutErr = LayoutError;\n+\n /// The parameters given to `Layout::from_size_align`\n /// or some other `Layout` constructor\n /// do not satisfy its documented constraints.\n-#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+#[stable(feature = \"alloc_layout_error\", since = \"1.49.0\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct LayoutErr {\n+pub struct LayoutError {\n     private: (),\n }\n \n // (we need this for downstream impl of trait Error)\n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-impl fmt::Display for LayoutErr {\n+impl fmt::Display for LayoutError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(\"invalid parameters to Layout::from_size_align\")\n     }"}, {"sha": "bc874e2e522425c4d9fc01616a9e9bc904cdc6e6", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -8,7 +8,18 @@ mod layout;\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n pub use self::global::GlobalAlloc;\n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-pub use self::layout::{Layout, LayoutErr};\n+pub use self::layout::Layout;\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+#[rustc_deprecated(\n+    since = \"1.51.0\",\n+    reason = \"Name does not follow std convention, use LayoutError\",\n+    suggestion = \"LayoutError\"\n+)]\n+#[allow(deprecated, deprecated_in_future)]\n+pub use self::layout::LayoutErr;\n+\n+#[stable(feature = \"alloc_layout_error\", since = \"1.49.0\")]\n+pub use self::layout::LayoutError;\n \n use crate::fmt;\n use crate::ptr::{self, NonNull};"}, {"sha": "a7cb1023229bb68d7c22dd82b5114675f270354b", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -12,6 +12,7 @@ use crate::convert::{Infallible, TryFrom};\n use crate::fmt;\n use crate::hash::{self, Hash};\n use crate::marker::Unsize;\n+use crate::ops::{Index, IndexMut};\n use crate::slice::{Iter, IterMut};\n \n mod iter;\n@@ -208,6 +209,30 @@ impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N] {\n     }\n }\n \n+#[stable(feature = \"index_trait_on_arrays\", since = \"1.50.0\")]\n+impl<T, I, const N: usize> Index<I> for [T; N]\n+where\n+    [T]: Index<I>,\n+{\n+    type Output = <[T] as Index<I>>::Output;\n+\n+    #[inline]\n+    fn index(&self, index: I) -> &Self::Output {\n+        Index::index(self as &[T], index)\n+    }\n+}\n+\n+#[stable(feature = \"index_trait_on_arrays\", since = \"1.50.0\")]\n+impl<T, I, const N: usize> IndexMut<I> for [T; N]\n+where\n+    [T]: IndexMut<I>,\n+{\n+    #[inline]\n+    fn index_mut(&mut self, index: I) -> &mut Self::Output {\n+        IndexMut::index_mut(self as &mut [T], index)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n where\n@@ -254,22 +279,22 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\n+impl<A, B, const N: usize> PartialEq<&[B]> for [A; N]\n where\n     A: PartialEq<B>,\n {\n     #[inline]\n-    fn eq(&self, other: &&'b [B]) -> bool {\n+    fn eq(&self, other: &&[B]) -> bool {\n         self[..] == other[..]\n     }\n     #[inline]\n-    fn ne(&self, other: &&'b [B]) -> bool {\n+    fn ne(&self, other: &&[B]) -> bool {\n         self[..] != other[..]\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\n+impl<A, B, const N: usize> PartialEq<[A; N]> for &[B]\n where\n     B: PartialEq<A>,\n {\n@@ -284,22 +309,22 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\n+impl<A, B, const N: usize> PartialEq<&mut [B]> for [A; N]\n where\n     A: PartialEq<B>,\n {\n     #[inline]\n-    fn eq(&self, other: &&'b mut [B]) -> bool {\n+    fn eq(&self, other: &&mut [B]) -> bool {\n         self[..] == other[..]\n     }\n     #[inline]\n-    fn ne(&self, other: &&'b mut [B]) -> bool {\n+    fn ne(&self, other: &&mut [B]) -> bool {\n         self[..] != other[..]\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\n+impl<A, B, const N: usize> PartialEq<[A; N]> for &mut [B]\n where\n     B: PartialEq<A>,\n {"}, {"sha": "e9d595e65e2b2f49af8652b2cad7c762ee96ef26", "filename": "library/core/tests/ops.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fops.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,4 +1,4 @@\n-use core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo};\n+use core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo, RangeToInclusive};\n \n // Test the Range structs and syntax.\n \n@@ -59,6 +59,12 @@ fn test_range_inclusive() {\n     assert_eq!(r.next(), None);\n }\n \n+#[test]\n+fn test_range_to_inclusive() {\n+    // Not much to test.\n+    let _ = RangeToInclusive { end: 42 };\n+}\n+\n #[test]\n fn test_range_is_empty() {\n     assert!(!(0.0..10.0).is_empty());\n@@ -151,3 +157,43 @@ fn test_range_syntax_in_return_statement() {\n     }\n     // Not much to test.\n }\n+\n+#[test]\n+fn range_structural_match() {\n+    // test that all range types can be structurally matched upon\n+\n+    const RANGE: Range<usize> = 0..1000;\n+    match RANGE {\n+        RANGE => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const RANGE_FROM: RangeFrom<usize> = 0..;\n+    match RANGE_FROM {\n+        RANGE_FROM => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const RANGE_FULL: RangeFull = ..;\n+    match RANGE_FULL {\n+        RANGE_FULL => {}\n+    }\n+\n+    const RANGE_INCLUSIVE: RangeInclusive<usize> = 0..=999;\n+    match RANGE_INCLUSIVE {\n+        RANGE_INCLUSIVE => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const RANGE_TO: RangeTo<usize> = ..1000;\n+    match RANGE_TO {\n+        RANGE_TO => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const RANGE_TO_INCLUSIVE: RangeToInclusive<usize> = ..=999;\n+    match RANGE_TO_INCLUSIVE {\n+        RANGE_TO_INCLUSIVE => {}\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "0044e59d697e3da55ffc1397a854731877b5341a", "filename": "library/std/src/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -19,7 +19,7 @@ mod tests;\n use core::array;\n use core::convert::Infallible;\n \n-use crate::alloc::{AllocError, LayoutErr};\n+use crate::alloc::{AllocError, LayoutError};\n use crate::any::TypeId;\n use crate::backtrace::Backtrace;\n use crate::borrow::Cow;\n@@ -390,7 +390,7 @@ impl Error for ! {}\n impl Error for AllocError {}\n \n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-impl Error for LayoutErr {}\n+impl Error for LayoutError {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for str::ParseBoolError {"}, {"sha": "6b3c86cb0df87ae176a17ecc30841279ed8aa241", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -209,20 +209,6 @@ impl<B: BufRead + ?Sized> BufRead for Box<B> {\n     }\n }\n \n-// Used by panicking::default_hook\n-#[cfg(test)]\n-/// This impl is only used by printing logic, so any error returned is always\n-/// of kind `Other`, and should be ignored.\n-impl Write for dyn ::realstd::io::LocalOutput {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        (*self).write(buf).map_err(|_| ErrorKind::Other.into())\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        (*self).flush().map_err(|_| ErrorKind::Other.into())\n-    }\n-}\n-\n // =============================================================================\n // In-memory buffer implementations\n "}, {"sha": "703c3755b63836212a841a20b2b949e4e24d307b", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -271,20 +271,18 @@ pub use self::copy::copy;\n pub use self::cursor::Cursor;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::error::{Error, ErrorKind, Result};\n+#[unstable(feature = \"internal_output_capture\", issue = \"none\")]\n+#[doc(no_inline, hidden)]\n+pub use self::stdio::set_output_capture;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n #[unstable(feature = \"print_internals\", issue = \"none\")]\n pub use self::stdio::{_eprint, _print};\n-#[unstable(feature = \"libstd_io_internals\", issue = \"42788\")]\n-#[doc(no_inline, hidden)]\n-pub use self::stdio::{set_panic, set_print, LocalOutput};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::util::{empty, repeat, sink, Empty, Repeat, Sink};\n \n-pub(crate) use self::stdio::clone_io;\n-\n mod buffered;\n pub(crate) mod copy;\n mod cursor;"}, {"sha": "6ea7704d42213463305f877536beff97859c899d", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 44, "deletions": 133, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -5,44 +5,38 @@ mod tests;\n \n use crate::io::prelude::*;\n \n-use crate::cell::RefCell;\n+use crate::cell::{Cell, RefCell};\n use crate::fmt;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n use crate::lazy::SyncOnceCell;\n use crate::sync::atomic::{AtomicBool, Ordering};\n-use crate::sync::{Mutex, MutexGuard};\n+use crate::sync::{Arc, Mutex, MutexGuard};\n use crate::sys::stdio;\n use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n-use crate::thread::LocalKey;\n \n-thread_local! {\n-    /// Used by the test crate to capture the output of the print! and println! macros.\n-    static LOCAL_STDOUT: RefCell<Option<Box<dyn LocalOutput>>> = {\n-        RefCell::new(None)\n-    }\n-}\n+type LocalStream = Arc<Mutex<Vec<u8>>>;\n \n thread_local! {\n-    /// Used by the test crate to capture the output of the eprint! and eprintln! macros, and panics.\n-    static LOCAL_STDERR: RefCell<Option<Box<dyn LocalOutput>>> = {\n-        RefCell::new(None)\n+    /// Used by the test crate to capture the output of the print macros and panics.\n+    static OUTPUT_CAPTURE: Cell<Option<LocalStream>> = {\n+        Cell::new(None)\n     }\n }\n \n-/// Flag to indicate LOCAL_STDOUT and/or LOCAL_STDERR is used.\n+/// Flag to indicate OUTPUT_CAPTURE is used.\n ///\n-/// If both are None and were never set on any thread, this flag is set to\n-/// false, and both LOCAL_STDOUT and LOCAL_STDOUT can be safely ignored on all\n-/// threads, saving some time and memory registering an unused thread local.\n+/// If it is None and was never set on any thread, this flag is set to false,\n+/// and OUTPUT_CAPTURE can be safely ignored on all threads, saving some time\n+/// and memory registering an unused thread local.\n ///\n-/// Note about memory ordering: This contains information about whether two\n-/// thread local variables might be in use. Although this is a global flag, the\n+/// Note about memory ordering: This contains information about whether a\n+/// thread local variable might be in use. Although this is a global flag, the\n /// memory ordering between threads does not matter: we only want this flag to\n-/// have a consistent order between set_print/set_panic and print_to *within\n+/// have a consistent order between set_output_capture and print_to *within\n /// the same thread*. Within the same thread, things always have a perfectly\n /// consistent order. So Ordering::Relaxed is fine.\n-static LOCAL_STREAMS: AtomicBool = AtomicBool::new(false);\n+static OUTPUT_CAPTURE_USED: AtomicBool = AtomicBool::new(false);\n \n /// A handle to a raw instance of the standard input stream of this process.\n ///\n@@ -896,97 +890,24 @@ impl fmt::Debug for StderrLock<'_> {\n     }\n }\n \n-/// A writer than can be cloned to new threads.\n-#[unstable(\n-    feature = \"set_stdio\",\n-    reason = \"this trait may disappear completely or be replaced \\\n-                     with a more general mechanism\",\n-    issue = \"none\"\n-)]\n-#[doc(hidden)]\n-pub trait LocalOutput: Write + Send {\n-    fn clone_box(&self) -> Box<dyn LocalOutput>;\n-}\n-\n-/// Resets the thread-local stderr handle to the specified writer\n-///\n-/// This will replace the current thread's stderr handle, returning the old\n-/// handle. All future calls to `panic!` and friends will emit their output to\n-/// this specified handle.\n-///\n-/// Note that this does not need to be called for all new threads; the default\n-/// output handle is to the process's stderr stream.\n-#[unstable(\n-    feature = \"set_stdio\",\n-    reason = \"this function may disappear completely or be replaced \\\n-                     with a more general mechanism\",\n-    issue = \"none\"\n-)]\n-#[doc(hidden)]\n-pub fn set_panic(sink: Option<Box<dyn LocalOutput>>) -> Option<Box<dyn LocalOutput>> {\n-    use crate::mem;\n-    if sink.is_none() && !LOCAL_STREAMS.load(Ordering::Relaxed) {\n-        // LOCAL_STDERR is definitely None since LOCAL_STREAMS is false.\n-        return None;\n-    }\n-    let s = LOCAL_STDERR.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n-        |mut s| {\n-            let _ = s.flush();\n-            Some(s)\n-        },\n-    );\n-    LOCAL_STREAMS.store(true, Ordering::Relaxed);\n-    s\n-}\n-\n-/// Resets the thread-local stdout handle to the specified writer\n-///\n-/// This will replace the current thread's stdout handle, returning the old\n-/// handle. All future calls to `print!` and friends will emit their output to\n-/// this specified handle.\n-///\n-/// Note that this does not need to be called for all new threads; the default\n-/// output handle is to the process's stdout stream.\n+/// Sets the thread-local output capture buffer and returns the old one.\n #[unstable(\n-    feature = \"set_stdio\",\n-    reason = \"this function may disappear completely or be replaced \\\n-                     with a more general mechanism\",\n+    feature = \"internal_output_capture\",\n+    reason = \"this function is meant for use in the test crate \\\n+        and may disappear in the future\",\n     issue = \"none\"\n )]\n #[doc(hidden)]\n-pub fn set_print(sink: Option<Box<dyn LocalOutput>>) -> Option<Box<dyn LocalOutput>> {\n-    use crate::mem;\n-    if sink.is_none() && !LOCAL_STREAMS.load(Ordering::Relaxed) {\n-        // LOCAL_STDOUT is definitely None since LOCAL_STREAMS is false.\n+pub fn set_output_capture(sink: Option<LocalStream>) -> Option<LocalStream> {\n+    if sink.is_none() && !OUTPUT_CAPTURE_USED.load(Ordering::Relaxed) {\n+        // OUTPUT_CAPTURE is definitely None since OUTPUT_CAPTURE_USED is false.\n         return None;\n     }\n-    let s = LOCAL_STDOUT.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n-        |mut s| {\n-            let _ = s.flush();\n-            Some(s)\n-        },\n-    );\n-    LOCAL_STREAMS.store(true, Ordering::Relaxed);\n-    s\n-}\n-\n-pub(crate) fn clone_io() -> (Option<Box<dyn LocalOutput>>, Option<Box<dyn LocalOutput>>) {\n-    // Don't waste time when LOCAL_{STDOUT,STDERR} are definitely None.\n-    if !LOCAL_STREAMS.load(Ordering::Relaxed) {\n-        return (None, None);\n-    }\n-\n-    LOCAL_STDOUT.with(|stdout| {\n-        LOCAL_STDERR.with(|stderr| {\n-            (\n-                stdout.borrow().as_ref().map(|o| o.clone_box()),\n-                stderr.borrow().as_ref().map(|o| o.clone_box()),\n-            )\n-        })\n-    })\n+    OUTPUT_CAPTURE_USED.store(true, Ordering::Relaxed);\n+    OUTPUT_CAPTURE.with(move |slot| slot.replace(sink))\n }\n \n-/// Write `args` to output stream `local_s` if possible, `global_s`\n+/// Write `args` to the capture buffer if enabled and possible, or `global_s`\n /// otherwise. `label` identifies the stream in a panic message.\n ///\n /// This function is used to print error messages, so it takes extra\n@@ -996,36 +917,26 @@ pub(crate) fn clone_io() -> (Option<Box<dyn LocalOutput>>, Option<Box<dyn LocalO\n /// thread, it will just fall back to the global stream.\n ///\n /// However, if the actual I/O causes an error, this function does panic.\n-fn print_to<T>(\n-    args: fmt::Arguments<'_>,\n-    local_s: &'static LocalKey<RefCell<Option<Box<dyn LocalOutput>>>>,\n-    global_s: fn() -> T,\n-    label: &str,\n-) where\n+fn print_to<T>(args: fmt::Arguments<'_>, global_s: fn() -> T, label: &str)\n+where\n     T: Write,\n {\n-    let result = LOCAL_STREAMS\n-        .load(Ordering::Relaxed)\n-        .then(|| {\n-            local_s\n-                .try_with(|s| {\n-                    // Note that we completely remove a local sink to write to in case\n-                    // our printing recursively panics/prints, so the recursive\n-                    // panic/print goes to the global sink instead of our local sink.\n-                    let prev = s.borrow_mut().take();\n-                    if let Some(mut w) = prev {\n-                        let result = w.write_fmt(args);\n-                        *s.borrow_mut() = Some(w);\n-                        return result;\n-                    }\n-                    global_s().write_fmt(args)\n-                })\n-                .ok()\n-        })\n-        .flatten()\n-        .unwrap_or_else(|| global_s().write_fmt(args));\n-\n-    if let Err(e) = result {\n+    if OUTPUT_CAPTURE_USED.load(Ordering::Relaxed)\n+        && OUTPUT_CAPTURE.try_with(|s| {\n+            // Note that we completely remove a local sink to write to in case\n+            // our printing recursively panics/prints, so the recursive\n+            // panic/print goes to the global sink instead of our local sink.\n+            s.take().map(|w| {\n+                let _ = w.lock().unwrap_or_else(|e| e.into_inner()).write_fmt(args);\n+                s.set(Some(w));\n+            })\n+        }) == Ok(Some(()))\n+    {\n+        // Succesfully wrote to capture buffer.\n+        return;\n+    }\n+\n+    if let Err(e) = global_s().write_fmt(args) {\n         panic!(\"failed printing to {}: {}\", label, e);\n     }\n }\n@@ -1038,7 +949,7 @@ fn print_to<T>(\n #[doc(hidden)]\n #[cfg(not(test))]\n pub fn _print(args: fmt::Arguments<'_>) {\n-    print_to(args, &LOCAL_STDOUT, stdout, \"stdout\");\n+    print_to(args, stdout, \"stdout\");\n }\n \n #[unstable(\n@@ -1049,7 +960,7 @@ pub fn _print(args: fmt::Arguments<'_>) {\n #[doc(hidden)]\n #[cfg(not(test))]\n pub fn _eprint(args: fmt::Arguments<'_>) {\n-    print_to(args, &LOCAL_STDERR, stderr, \"stderr\");\n+    print_to(args, stderr, \"stderr\");\n }\n \n #[cfg(test)]"}, {"sha": "ac11fcf73295827d422e360bfaba1fcc1d791788", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -207,7 +207,7 @@\n // std may use features in a platform-specific way\n #![allow(unused_features)]\n #![cfg_attr(not(bootstrap), feature(rustc_allow_const_fn_unstable))]\n-#![cfg_attr(test, feature(print_internals, set_stdio, update_panic_count))]\n+#![cfg_attr(test, feature(internal_output_capture, print_internals, update_panic_count))]\n #![cfg_attr(\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n@@ -298,6 +298,7 @@\n #![feature(raw)]\n #![feature(raw_ref_macros)]\n #![feature(ready_macro)]\n+#![feature(refcell_take)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]\n #![feature(shrink_to)]"}, {"sha": "8ba3feccb6bcc8f817efa43cd0b373124c27bcd8", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -24,11 +24,11 @@ use crate::sys_common::{thread_info, util};\n use crate::thread;\n \n #[cfg(not(test))]\n-use crate::io::set_panic;\n+use crate::io::set_output_capture;\n // make sure to use the stderr output configured\n // by libtest in the real copy of std\n #[cfg(test)]\n-use realstd::io::set_panic;\n+use realstd::io::set_output_capture;\n \n // Binary interface to the panic runtime that the standard library depends on.\n //\n@@ -218,11 +218,9 @@ fn default_hook(info: &PanicInfo<'_>) {\n         }\n     };\n \n-    if let Some(mut local) = set_panic(None) {\n-        // NB. In `cfg(test)` this uses the forwarding impl\n-        // for `dyn ::realstd::io::LocalOutput`.\n-        write(&mut local);\n-        set_panic(Some(local));\n+    if let Some(local) = set_output_capture(None) {\n+        write(&mut *local.lock().unwrap_or_else(|e| e.into_inner()));\n+        set_output_capture(Some(local));\n     } else if let Some(mut out) = panic_output() {\n         write(&mut out);\n     }"}, {"sha": "5d65f960fcd391eb14c66077bcc48de18a8a2292", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -456,15 +456,15 @@ impl Builder {\n         let my_packet: Arc<UnsafeCell<Option<Result<T>>>> = Arc::new(UnsafeCell::new(None));\n         let their_packet = my_packet.clone();\n \n-        let (stdout, stderr) = crate::io::clone_io();\n+        let output_capture = crate::io::set_output_capture(None);\n+        crate::io::set_output_capture(output_capture.clone());\n \n         let main = move || {\n             if let Some(name) = their_thread.cname() {\n                 imp::Thread::set_name(name);\n             }\n \n-            crate::io::set_print(stdout);\n-            crate::io::set_panic(stderr);\n+            crate::io::set_output_capture(output_capture);\n \n             // SAFETY: the stack guard passed is the one for the current thread.\n             // This means the current thread's stack and the new thread's stack"}, {"sha": "d4b37284ea7749e903988d6e40ee52701316426c", "filename": "library/test/src/bench.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Ftest%2Fsrc%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Ftest%2Fsrc%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fbench.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -2,8 +2,7 @@\n pub use std::hint::black_box;\n \n use super::{\n-    event::CompletedTest, helpers::sink::Sink, options::BenchMode, test_result::TestResult,\n-    types::TestDesc, Sender,\n+    event::CompletedTest, options::BenchMode, test_result::TestResult, types::TestDesc, Sender,\n };\n \n use crate::stats;\n@@ -185,21 +184,14 @@ where\n     let mut bs = Bencher { mode: BenchMode::Auto, summary: None, bytes: 0 };\n \n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let oldio = if !nocapture {\n-        Some((\n-            io::set_print(Some(Sink::new_boxed(&data))),\n-            io::set_panic(Some(Sink::new_boxed(&data))),\n-        ))\n-    } else {\n-        None\n-    };\n+\n+    if !nocapture {\n+        io::set_output_capture(Some(data.clone()));\n+    }\n \n     let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n \n-    if let Some((printio, panicio)) = oldio {\n-        io::set_print(printio);\n-        io::set_panic(panicio);\n-    }\n+    io::set_output_capture(None);\n \n     let test_result = match result {\n         //bs.bench(f) {"}, {"sha": "b7f00c4c86cdf27f61416b98c5461276989ee80e", "filename": "library/test/src/helpers/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Ftest%2Fsrc%2Fhelpers%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Ftest%2Fsrc%2Fhelpers%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fhelpers%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -5,4 +5,3 @@ pub mod concurrency;\n pub mod exit_code;\n pub mod isatty;\n pub mod metrics;\n-pub mod sink;"}, {"sha": "dfbf0a3b72f54cd9d4f744ba937a27b98ce39616", "filename": "library/test/src/helpers/sink.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f5230fbf76bafd86ee4376a0e26e551df8d17fec/library%2Ftest%2Fsrc%2Fhelpers%2Fsink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5230fbf76bafd86ee4376a0e26e551df8d17fec/library%2Ftest%2Fsrc%2Fhelpers%2Fsink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fhelpers%2Fsink.rs?ref=f5230fbf76bafd86ee4376a0e26e551df8d17fec", "patch": "@@ -1,31 +0,0 @@\n-//! Module providing a helper structure to capture output in subprocesses.\n-\n-use std::{\n-    io,\n-    io::prelude::Write,\n-    sync::{Arc, Mutex},\n-};\n-\n-#[derive(Clone)]\n-pub struct Sink(Arc<Mutex<Vec<u8>>>);\n-\n-impl Sink {\n-    pub fn new_boxed(data: &Arc<Mutex<Vec<u8>>>) -> Box<Self> {\n-        Box::new(Self(data.clone()))\n-    }\n-}\n-\n-impl io::LocalOutput for Sink {\n-    fn clone_box(&self) -> Box<dyn io::LocalOutput> {\n-        Box::new(self.clone())\n-    }\n-}\n-\n-impl Write for Sink {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Write::write(&mut *self.0.lock().unwrap(), data)\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}"}, {"sha": "816b4d51188034cf97afea7097942b04df5113f5", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -25,7 +25,7 @@\n #![feature(nll)]\n #![feature(bool_to_option)]\n #![feature(available_concurrency)]\n-#![feature(set_stdio)]\n+#![feature(internal_output_capture)]\n #![feature(panic_unwind)]\n #![feature(staged_api)]\n #![feature(termination_trait_lib)]\n@@ -89,7 +89,6 @@ mod tests;\n use event::{CompletedTest, TestEvent};\n use helpers::concurrency::get_concurrency;\n use helpers::exit_code::get_exit_code;\n-use helpers::sink::Sink;\n use options::{Concurrent, RunStrategy};\n use test_result::*;\n use time::TestExecTime;\n@@ -531,14 +530,9 @@ fn run_test_in_process(\n     // Buffer for capturing standard I/O\n     let data = Arc::new(Mutex::new(Vec::new()));\n \n-    let oldio = if !nocapture {\n-        Some((\n-            io::set_print(Some(Sink::new_boxed(&data))),\n-            io::set_panic(Some(Sink::new_boxed(&data))),\n-        ))\n-    } else {\n-        None\n-    };\n+    if !nocapture {\n+        io::set_output_capture(Some(data.clone()));\n+    }\n \n     let start = report_time.then(Instant::now);\n     let result = catch_unwind(AssertUnwindSafe(testfn));\n@@ -547,16 +541,13 @@ fn run_test_in_process(\n         TestExecTime(duration)\n     });\n \n-    if let Some((printio, panicio)) = oldio {\n-        io::set_print(printio);\n-        io::set_panic(panicio);\n-    }\n+    io::set_output_capture(None);\n \n     let test_result = match result {\n         Ok(()) => calc_result(&desc, Ok(()), &time_opts, &exec_time),\n         Err(e) => calc_result(&desc, Err(e.as_ref()), &time_opts, &exec_time),\n     };\n-    let stdout = data.lock().unwrap().to_vec();\n+    let stdout = data.lock().unwrap_or_else(|e| e.into_inner()).to_vec();\n     let message = CompletedTest::new(desc, test_result, exec_time, stdout);\n     monitor_ch.send(message).unwrap();\n }"}, {"sha": "7e1241fce985aa2f8544a5eca0ad8795155964b3", "filename": "src/doc/unstable-book/src/library-features/internal-output-capture.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finternal-output-capture.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finternal-output-capture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Finternal-output-capture.md?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,4 +1,4 @@\n-# `libstd_io_internals`\n+# `internal_output_capture`\n \n This feature is internal to the Rust compiler and is not intended for general use.\n ", "previous_filename": "src/doc/unstable-book/src/library-features/libstd-io-internals.md"}, {"sha": "7dbdcdaa1a2ff21816e4c7b8a255667b20458057", "filename": "src/doc/unstable-book/src/library-features/set-stdio.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5230fbf76bafd86ee4376a0e26e551df8d17fec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fset-stdio.md", "raw_url": "https://github.com/rust-lang/rust/raw/f5230fbf76bafd86ee4376a0e26e551df8d17fec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fset-stdio.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fset-stdio.md?ref=f5230fbf76bafd86ee4376a0e26e551df8d17fec", "patch": "@@ -1,5 +0,0 @@\n-# `set_stdio`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "ff996b2a9254e5ae51c6f5ac97962a14cf89051a", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -20,21 +20,21 @@ struct RegionDeps<'tcx> {\n     smaller: FxHashSet<RegionTarget<'tcx>>,\n }\n \n-pub struct AutoTraitFinder<'a, 'tcx> {\n-    pub cx: &'a core::DocContext<'tcx>,\n-    pub f: auto_trait::AutoTraitFinder<'tcx>,\n+crate struct AutoTraitFinder<'a, 'tcx> {\n+    crate cx: &'a core::DocContext<'tcx>,\n+    crate f: auto_trait::AutoTraitFinder<'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n+    crate fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n         let f = auto_trait::AutoTraitFinder::new(cx.tcx);\n \n         AutoTraitFinder { cx, f }\n     }\n \n     // FIXME(eddyb) figure out a better way to pass information about\n     // parametrization of `ty` than `param_env_def_id`.\n-    pub fn get_auto_trait_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n+    crate fn get_auto_trait_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n         let param_env = self.cx.tcx.param_env(param_env_def_id);\n \n         debug!(\"get_auto_trait_impls({:?})\", ty);"}, {"sha": "5721927d0ec8d58720e12a6938bdef4510530d55", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -9,18 +9,18 @@ use rustc_span::DUMMY_SP;\n \n use super::*;\n \n-pub struct BlanketImplFinder<'a, 'tcx> {\n-    pub cx: &'a core::DocContext<'tcx>,\n+crate struct BlanketImplFinder<'a, 'tcx> {\n+    crate cx: &'a core::DocContext<'tcx>,\n }\n \n impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n+    crate fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n         BlanketImplFinder { cx }\n     }\n \n     // FIXME(eddyb) figure out a better way to pass information about\n     // parametrization of `ty` than `param_env_def_id`.\n-    pub fn get_blanket_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n+    crate fn get_blanket_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n         let param_env = self.cx.tcx.param_env(param_env_def_id);\n \n         debug!(\"get_blanket_impls({:?})\", ty);"}, {"sha": "2f169d1d3f3a52b47d3a3c84f2211c90ed1616fb", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -20,7 +20,7 @@ use crate::html::escape::Escape;\n mod tests;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum Cfg {\n+crate enum Cfg {\n     /// Accepts all configurations.\n     True,\n     /// Denies all configurations.\n@@ -36,9 +36,9 @@ pub enum Cfg {\n }\n \n #[derive(PartialEq, Debug)]\n-pub struct InvalidCfgError {\n-    pub msg: &'static str,\n-    pub span: Span,\n+crate struct InvalidCfgError {\n+    crate msg: &'static str,\n+    crate span: Span,\n }\n \n impl Cfg {\n@@ -59,7 +59,7 @@ impl Cfg {\n     ///\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n-    pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+    crate fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n         let name = match cfg.ident() {\n             Some(ident) => ident.name,\n             None => {\n@@ -102,7 +102,7 @@ impl Cfg {\n     ///\n     /// Equivalent to `attr::cfg_matches`.\n     // FIXME: Actually make use of `features`.\n-    pub fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n+    crate fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n         match *self {\n             Cfg::False => false,\n             Cfg::True => true,"}, {"sha": "daca4f8a9332f4f790aae3b8d0fddf9a8a570570", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -3,11 +3,11 @@\n \n mod auto_trait;\n mod blanket_impl;\n-pub mod cfg;\n-pub mod inline;\n+crate mod cfg;\n+crate mod inline;\n mod simplify;\n-pub mod types;\n-pub mod utils;\n+crate mod types;\n+crate mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n@@ -39,18 +39,18 @@ use crate::doctree;\n \n use utils::*;\n \n-pub use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n+crate use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n-pub use self::types::FnRetTy::*;\n-pub use self::types::ItemKind::*;\n-pub use self::types::SelfTy::*;\n-pub use self::types::Type::*;\n-pub use self::types::Visibility::{Inherited, Public};\n-pub use self::types::*;\n+crate use self::types::FnRetTy::*;\n+crate use self::types::ItemKind::*;\n+crate use self::types::SelfTy::*;\n+crate use self::types::Type::*;\n+crate use self::types::Visibility::{Inherited, Public};\n+crate use self::types::*;\n \n const FN_OUTPUT_NAME: &str = \"Output\";\n \n-pub trait Clean<T> {\n+crate trait Clean<T> {\n     fn clean(&self, cx: &DocContext<'_>) -> T;\n }\n "}, {"sha": "121c9d2bc4cd6e06b8fa14769ed7672b8c4b44a1", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -21,7 +21,7 @@ use crate::clean::GenericArgs as PP;\n use crate::clean::WherePredicate as WP;\n use crate::core::DocContext;\n \n-pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n+crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components\n     let mut params: BTreeMap<_, Vec<_>> = BTreeMap::new();\n     let mut lifetimes = Vec::new();\n@@ -74,7 +74,7 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses\n }\n \n-pub fn merge_bounds(\n+crate fn merge_bounds(\n     cx: &clean::DocContext<'_>,\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,"}, {"sha": "9dd8415341e98cda3caf6e1e7ad7a06589c70d4a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 273, "deletions": 273, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -45,47 +45,47 @@ use self::ItemKind::*;\n use self::SelfTy::*;\n use self::Type::*;\n \n-thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Default::default());\n+thread_local!(crate static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Default::default());\n \n #[derive(Clone, Debug)]\n-pub struct Crate {\n-    pub name: String,\n-    pub version: Option<String>,\n-    pub src: FileName,\n-    pub module: Option<Item>,\n-    pub externs: Vec<(CrateNum, ExternalCrate)>,\n-    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n+crate struct Crate {\n+    crate name: String,\n+    crate version: Option<String>,\n+    crate src: FileName,\n+    crate module: Option<Item>,\n+    crate externs: Vec<(CrateNum, ExternalCrate)>,\n+    crate primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n-    pub masked_crates: FxHashSet<CrateNum>,\n-    pub collapsed: bool,\n+    crate external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n+    crate masked_crates: FxHashSet<CrateNum>,\n+    crate collapsed: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct ExternalCrate {\n-    pub name: String,\n-    pub src: FileName,\n-    pub attrs: Attributes,\n-    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n-    pub keywords: Vec<(DefId, String, Attributes)>,\n+crate struct ExternalCrate {\n+    crate name: String,\n+    crate src: FileName,\n+    crate attrs: Attributes,\n+    crate primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n+    crate keywords: Vec<(DefId, String, Attributes)>,\n }\n \n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n #[derive(Clone)]\n-pub struct Item {\n+crate struct Item {\n     /// Stringified span\n-    pub source: Span,\n+    crate source: Span,\n     /// Not everything has a name. E.g., impls\n-    pub name: Option<String>,\n-    pub attrs: Attributes,\n-    pub kind: ItemKind,\n-    pub visibility: Visibility,\n-    pub def_id: DefId,\n-    pub stability: Option<Stability>,\n-    pub deprecation: Option<Deprecation>,\n+    crate name: Option<String>,\n+    crate attrs: Attributes,\n+    crate visibility: Visibility,\n+    crate kind: ItemKind,\n+    crate def_id: DefId,\n+    crate stability: Option<Stability>,\n+    crate deprecation: Option<Deprecation>,\n }\n \n impl fmt::Debug for Item {\n@@ -108,80 +108,80 @@ impl fmt::Debug for Item {\n impl Item {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    pub fn doc_value(&self) -> Option<&str> {\n+    crate fn doc_value(&self) -> Option<&str> {\n         self.attrs.doc_value()\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n-    pub fn collapsed_doc_value(&self) -> Option<String> {\n+    crate fn collapsed_doc_value(&self) -> Option<String> {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    pub fn links(&self) -> Vec<RenderedLink> {\n+    crate fn links(&self) -> Vec<RenderedLink> {\n         self.attrs.links(&self.def_id.krate)\n     }\n \n-    pub fn is_crate(&self) -> bool {\n+    crate fn is_crate(&self) -> bool {\n         match self.kind {\n             StrippedItem(box ModuleItem(Module { is_crate: true, .. }))\n             | ModuleItem(Module { is_crate: true, .. }) => true,\n             _ => false,\n         }\n     }\n-    pub fn is_mod(&self) -> bool {\n+    crate fn is_mod(&self) -> bool {\n         self.type_() == ItemType::Module\n     }\n-    pub fn is_trait(&self) -> bool {\n+    crate fn is_trait(&self) -> bool {\n         self.type_() == ItemType::Trait\n     }\n-    pub fn is_struct(&self) -> bool {\n+    crate fn is_struct(&self) -> bool {\n         self.type_() == ItemType::Struct\n     }\n-    pub fn is_enum(&self) -> bool {\n+    crate fn is_enum(&self) -> bool {\n         self.type_() == ItemType::Enum\n     }\n-    pub fn is_variant(&self) -> bool {\n+    crate fn is_variant(&self) -> bool {\n         self.type_() == ItemType::Variant\n     }\n-    pub fn is_associated_type(&self) -> bool {\n+    crate fn is_associated_type(&self) -> bool {\n         self.type_() == ItemType::AssocType\n     }\n-    pub fn is_associated_const(&self) -> bool {\n+    crate fn is_associated_const(&self) -> bool {\n         self.type_() == ItemType::AssocConst\n     }\n-    pub fn is_method(&self) -> bool {\n+    crate fn is_method(&self) -> bool {\n         self.type_() == ItemType::Method\n     }\n-    pub fn is_ty_method(&self) -> bool {\n+    crate fn is_ty_method(&self) -> bool {\n         self.type_() == ItemType::TyMethod\n     }\n-    pub fn is_typedef(&self) -> bool {\n+    crate fn is_typedef(&self) -> bool {\n         self.type_() == ItemType::Typedef\n     }\n-    pub fn is_primitive(&self) -> bool {\n+    crate fn is_primitive(&self) -> bool {\n         self.type_() == ItemType::Primitive\n     }\n-    pub fn is_union(&self) -> bool {\n+    crate fn is_union(&self) -> bool {\n         self.type_() == ItemType::Union\n     }\n-    pub fn is_import(&self) -> bool {\n+    crate fn is_import(&self) -> bool {\n         self.type_() == ItemType::Import\n     }\n-    pub fn is_extern_crate(&self) -> bool {\n+    crate fn is_extern_crate(&self) -> bool {\n         self.type_() == ItemType::ExternCrate\n     }\n-    pub fn is_keyword(&self) -> bool {\n+    crate fn is_keyword(&self) -> bool {\n         self.type_() == ItemType::Keyword\n     }\n-    pub fn is_stripped(&self) -> bool {\n+    crate fn is_stripped(&self) -> bool {\n         match self.kind {\n             StrippedItem(..) => true,\n             ImportItem(ref i) => !i.should_be_displayed,\n             _ => false,\n         }\n     }\n-    pub fn has_stripped_fields(&self) -> Option<bool> {\n+    crate fn has_stripped_fields(&self) -> Option<bool> {\n         match self.kind {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n             UnionItem(ref union) => Some(union.fields_stripped),\n@@ -192,7 +192,7 @@ impl Item {\n         }\n     }\n \n-    pub fn stability_class(&self) -> Option<String> {\n+    crate fn stability_class(&self) -> Option<String> {\n         self.stability.as_ref().and_then(|ref s| {\n             let mut classes = Vec::with_capacity(2);\n \n@@ -209,23 +209,23 @@ impl Item {\n         })\n     }\n \n-    pub fn stable_since(&self) -> Option<SymbolStr> {\n+    crate fn stable_since(&self) -> Option<SymbolStr> {\n         match self.stability?.level {\n             StabilityLevel::Stable { since, .. } => Some(since.as_str()),\n             StabilityLevel::Unstable { .. } => None,\n         }\n     }\n \n-    pub fn is_non_exhaustive(&self) -> bool {\n+    crate fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter().any(|a| a.has_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n-    pub fn type_(&self) -> ItemType {\n+    crate fn type_(&self) -> ItemType {\n         ItemType::from(self)\n     }\n \n-    pub fn is_default(&self) -> bool {\n+    crate fn is_default(&self) -> bool {\n         match self.kind {\n             ItemKind::MethodItem(ref meth) => {\n                 if let Some(defaultness) = meth.defaultness {\n@@ -239,15 +239,15 @@ impl Item {\n     }\n \n     /// See comments on next_def_id\n-    pub fn is_fake(&self) -> bool {\n+    crate fn is_fake(&self) -> bool {\n         MAX_DEF_ID.with(|m| {\n             m.borrow().get(&self.def_id.krate).map(|id| self.def_id >= *id).unwrap_or(false)\n         })\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub enum ItemKind {\n+crate enum ItemKind {\n     ExternCrateItem(String, Option<String>),\n     ImportItem(Import),\n     StructItem(Struct),\n@@ -286,14 +286,14 @@ pub enum ItemKind {\n }\n \n impl ItemKind {\n-    pub fn is_type_alias(&self) -> bool {\n+    crate fn is_type_alias(&self) -> bool {\n         match *self {\n             ItemKind::TypedefItem(_, _) | ItemKind::AssocTypeItem(_, _) => true,\n             _ => false,\n         }\n     }\n \n-    pub fn as_assoc_kind(&self) -> Option<AssocKind> {\n+    crate fn as_assoc_kind(&self) -> Option<AssocKind> {\n         match *self {\n             ItemKind::AssocConstItem(..) => Some(AssocKind::Const),\n             ItemKind::AssocTypeItem(..) => Some(AssocKind::Type),\n@@ -304,12 +304,12 @@ impl ItemKind {\n }\n \n #[derive(Clone, Debug)]\n-pub struct Module {\n-    pub items: Vec<Item>,\n-    pub is_crate: bool,\n+crate struct Module {\n+    crate items: Vec<Item>,\n+    crate is_crate: bool,\n }\n \n-pub struct ListAttributesIter<'a> {\n+crate struct ListAttributesIter<'a> {\n     attrs: slice::Iter<'a, ast::Attribute>,\n     current_list: vec::IntoIter<ast::NestedMetaItem>,\n     name: Symbol,\n@@ -343,7 +343,7 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n     }\n }\n \n-pub trait AttributesExt {\n+crate trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n     fn lists(&self, name: Symbol) -> ListAttributesIter<'_>;\n }\n@@ -354,7 +354,7 @@ impl AttributesExt for [ast::Attribute] {\n     }\n }\n \n-pub trait NestedAttributesExt {\n+crate trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `Word`\n     fn has_word(self, word: Symbol) -> bool;\n }\n@@ -374,20 +374,20 @@ impl<I: IntoIterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n /// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n /// kept separate because of issue #42760.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct DocFragment {\n-    pub line: usize,\n-    pub span: rustc_span::Span,\n+crate struct DocFragment {\n+    crate line: usize,\n+    crate span: rustc_span::Span,\n     /// The module this doc-comment came from.\n     ///\n     /// This allows distinguishing between the original documentation and a pub re-export.\n     /// If it is `None`, the item was not re-exported.\n-    pub parent_module: Option<DefId>,\n-    pub doc: String,\n-    pub kind: DocFragmentKind,\n+    crate parent_module: Option<DefId>,\n+    crate doc: String,\n+    crate kind: DocFragmentKind,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum DocFragmentKind {\n+crate enum DocFragmentKind {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n     SugaredDoc,\n     /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n@@ -413,21 +413,21 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n }\n \n #[derive(Clone, Debug, Default)]\n-pub struct Attributes {\n-    pub doc_strings: Vec<DocFragment>,\n-    pub other_attrs: Vec<ast::Attribute>,\n-    pub cfg: Option<Arc<Cfg>>,\n-    pub span: Option<rustc_span::Span>,\n+crate struct Attributes {\n+    crate doc_strings: Vec<DocFragment>,\n+    crate other_attrs: Vec<ast::Attribute>,\n+    crate cfg: Option<Arc<Cfg>>,\n+    crate span: Option<rustc_span::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n-    pub links: Vec<ItemLink>,\n-    pub inner_docs: bool,\n+    crate links: Vec<ItemLink>,\n+    crate inner_docs: bool,\n }\n \n #[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n /// A link that has not yet been rendered.\n ///\n /// This link will be turned into a rendered link by [`Attributes::links`]\n-pub struct ItemLink {\n+crate struct ItemLink {\n     /// The original link written in the markdown\n     pub(crate) link: String,\n     /// The link text displayed in the HTML.\n@@ -453,7 +453,7 @@ pub struct RenderedLink {\n \n impl Attributes {\n     /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n-    pub fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n+    crate fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n         use rustc_ast::NestedMetaItem::MetaItem;\n \n         if let ast::MetaItemKind::List(ref nmis) = mi.kind {\n@@ -478,7 +478,7 @@ impl Attributes {\n     /// Reads a `MetaItem` from within an attribute, looks for whether it is a\n     /// `#[doc(include=\"file\")]`, and returns the filename and contents of the file as loaded from\n     /// its expansion.\n-    pub fn extract_include(mi: &ast::MetaItem) -> Option<(String, String)> {\n+    crate fn extract_include(mi: &ast::MetaItem) -> Option<(String, String)> {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n                 if meta.has_name(sym::include) {\n@@ -514,7 +514,7 @@ impl Attributes {\n         })\n     }\n \n-    pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n+    crate fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n             if !attr.has_name(sym::doc) {\n                 continue;\n@@ -530,7 +530,7 @@ impl Attributes {\n         false\n     }\n \n-    pub fn from_ast(\n+    crate fn from_ast(\n         diagnostic: &::rustc_errors::Handler,\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n@@ -634,20 +634,20 @@ impl Attributes {\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    pub fn doc_value(&self) -> Option<&str> {\n+    crate fn doc_value(&self) -> Option<&str> {\n         self.doc_strings.first().map(|s| s.doc.as_str())\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n-    pub fn collapsed_doc_value(&self) -> Option<String> {\n+    crate fn collapsed_doc_value(&self) -> Option<String> {\n         if !self.doc_strings.is_empty() { Some(self.doc_strings.iter().collect()) } else { None }\n     }\n \n     /// Gets links as a vector\n     ///\n     /// Cache must be populated before call\n-    pub fn links(&self, krate: &CrateNum) -> Vec<RenderedLink> {\n+    crate fn links(&self, krate: &CrateNum) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n         use crate::html::render::CURRENT_DEPTH;\n \n@@ -711,7 +711,7 @@ impl Attributes {\n             .collect()\n     }\n \n-    pub fn get_doc_aliases(&self) -> FxHashSet<String> {\n+    crate fn get_doc_aliases(&self) -> FxHashSet<String> {\n         self.other_attrs\n             .lists(sym::doc)\n             .filter(|a| a.has_name(sym::alias))\n@@ -756,13 +756,13 @@ impl AttributesExt for Attributes {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericBound {\n+crate enum GenericBound {\n     TraitBound(PolyTrait, hir::TraitBoundModifier),\n     Outlives(Lifetime),\n }\n \n impl GenericBound {\n-    pub fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n+    crate fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(LangItem::Sized, None);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, cx.tcx.item_name(did), Some(did), false, vec![], empty);\n@@ -776,7 +776,7 @@ impl GenericBound {\n         )\n     }\n \n-    pub fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n+    crate fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n             if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n@@ -786,14 +786,14 @@ impl GenericBound {\n         false\n     }\n \n-    pub fn get_poly_trait(&self) -> Option<PolyTrait> {\n+    crate fn get_poly_trait(&self) -> Option<PolyTrait> {\n         if let GenericBound::TraitBound(ref p, _) = *self {\n             return Some(p.clone());\n         }\n         None\n     }\n \n-    pub fn get_trait_type(&self) -> Option<Type> {\n+    crate fn get_trait_type(&self) -> Option<Type> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n             Some(trait_.clone())\n         } else {\n@@ -803,33 +803,33 @@ impl GenericBound {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Lifetime(pub String);\n+crate struct Lifetime(pub String);\n \n impl Lifetime {\n-    pub fn get_ref<'a>(&'a self) -> &'a str {\n+    crate fn get_ref<'a>(&'a self) -> &'a str {\n         let Lifetime(ref s) = *self;\n         let s: &'a str = s;\n         s\n     }\n \n-    pub fn statik() -> Lifetime {\n+    crate fn statik() -> Lifetime {\n         Lifetime(\"'static\".to_string())\n     }\n \n-    pub fn elided() -> Lifetime {\n+    crate fn elided() -> Lifetime {\n         Lifetime(\"'_\".to_string())\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub enum WherePredicate {\n+crate enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n     EqPredicate { lhs: Type, rhs: Type },\n }\n \n impl WherePredicate {\n-    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+    crate fn get_bounds(&self) -> Option<&[GenericBound]> {\n         match *self {\n             WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n             WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n@@ -839,7 +839,7 @@ impl WherePredicate {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericParamDefKind {\n+crate enum GenericParamDefKind {\n     Lifetime,\n     Type {\n         did: DefId,\n@@ -854,7 +854,7 @@ pub enum GenericParamDefKind {\n }\n \n impl GenericParamDefKind {\n-    pub fn is_type(&self) -> bool {\n+    crate fn is_type(&self) -> bool {\n         match *self {\n             GenericParamDefKind::Type { .. } => true,\n             _ => false,\n@@ -864,7 +864,7 @@ impl GenericParamDefKind {\n     // FIXME(eddyb) this either returns the default of a type parameter, or the\n     // type of a `const` parameter. It seems that the intention is to *visit*\n     // any embedded types, but `get_type` seems to be the wrong name for that.\n-    pub fn get_type(&self) -> Option<Type> {\n+    crate fn get_type(&self) -> Option<Type> {\n         match self {\n             GenericParamDefKind::Type { default, .. } => default.clone(),\n             GenericParamDefKind::Const { ty, .. } => Some(ty.clone()),\n@@ -874,28 +874,28 @@ impl GenericParamDefKind {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct GenericParamDef {\n-    pub name: String,\n-    pub kind: GenericParamDefKind,\n+crate struct GenericParamDef {\n+    crate name: String,\n+    crate kind: GenericParamDefKind,\n }\n \n impl GenericParamDef {\n-    pub fn is_synthetic_type_param(&self) -> bool {\n+    crate fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime | GenericParamDefKind::Const { .. } => false,\n             GenericParamDefKind::Type { ref synthetic, .. } => synthetic.is_some(),\n         }\n     }\n \n-    pub fn is_type(&self) -> bool {\n+    crate fn is_type(&self) -> bool {\n         self.kind.is_type()\n     }\n \n-    pub fn get_type(&self) -> Option<Type> {\n+    crate fn get_type(&self) -> Option<Type> {\n         self.kind.get_type()\n     }\n \n-    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+    crate fn get_bounds(&self) -> Option<&[GenericBound]> {\n         match self.kind {\n             GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n             _ => None,\n@@ -905,49 +905,49 @@ impl GenericParamDef {\n \n // maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, Debug, Default)]\n-pub struct Generics {\n-    pub params: Vec<GenericParamDef>,\n-    pub where_predicates: Vec<WherePredicate>,\n+crate struct Generics {\n+    crate params: Vec<GenericParamDef>,\n+    crate where_predicates: Vec<WherePredicate>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Method {\n-    pub generics: Generics,\n-    pub decl: FnDecl,\n-    pub header: hir::FnHeader,\n-    pub defaultness: Option<hir::Defaultness>,\n-    pub all_types: Vec<(Type, TypeKind)>,\n-    pub ret_types: Vec<(Type, TypeKind)>,\n+crate struct Method {\n+    crate generics: Generics,\n+    crate decl: FnDecl,\n+    crate header: hir::FnHeader,\n+    crate defaultness: Option<hir::Defaultness>,\n+    crate all_types: Vec<(Type, TypeKind)>,\n+    crate ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct TyMethod {\n-    pub header: hir::FnHeader,\n-    pub decl: FnDecl,\n-    pub generics: Generics,\n-    pub all_types: Vec<(Type, TypeKind)>,\n-    pub ret_types: Vec<(Type, TypeKind)>,\n+crate struct TyMethod {\n+    crate header: hir::FnHeader,\n+    crate decl: FnDecl,\n+    crate generics: Generics,\n+    crate all_types: Vec<(Type, TypeKind)>,\n+    crate ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Function {\n-    pub decl: FnDecl,\n-    pub generics: Generics,\n-    pub header: hir::FnHeader,\n-    pub all_types: Vec<(Type, TypeKind)>,\n-    pub ret_types: Vec<(Type, TypeKind)>,\n+crate struct Function {\n+    crate decl: FnDecl,\n+    crate generics: Generics,\n+    crate header: hir::FnHeader,\n+    crate all_types: Vec<(Type, TypeKind)>,\n+    crate ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct FnDecl {\n-    pub inputs: Arguments,\n-    pub output: FnRetTy,\n-    pub c_variadic: bool,\n-    pub attrs: Attributes,\n+crate struct FnDecl {\n+    crate inputs: Arguments,\n+    crate output: FnRetTy,\n+    crate c_variadic: bool,\n+    crate attrs: Attributes,\n }\n \n impl FnDecl {\n-    pub fn self_type(&self) -> Option<SelfTy> {\n+    crate fn self_type(&self) -> Option<SelfTy> {\n         self.inputs.values.get(0).and_then(|v| v.to_self())\n     }\n \n@@ -960,7 +960,7 @@ impl FnDecl {\n     ///\n     /// This function will panic if the return type does not match the expected sugaring for async\n     /// functions.\n-    pub fn sugared_async_return_type(&self) -> FnRetTy {\n+    crate fn sugared_async_return_type(&self) -> FnRetTy {\n         match &self.output {\n             FnRetTy::Return(Type::ImplTrait(bounds)) => match &bounds[0] {\n                 GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n@@ -975,25 +975,25 @@ impl FnDecl {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Arguments {\n-    pub values: Vec<Argument>,\n+crate struct Arguments {\n+    crate values: Vec<Argument>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Argument {\n-    pub type_: Type,\n-    pub name: String,\n+crate struct Argument {\n+    crate type_: Type,\n+    crate name: String,\n }\n \n #[derive(Clone, PartialEq, Debug)]\n-pub enum SelfTy {\n+crate enum SelfTy {\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n     SelfExplicit(Type),\n }\n \n impl Argument {\n-    pub fn to_self(&self) -> Option<SelfTy> {\n+    crate fn to_self(&self) -> Option<SelfTy> {\n         if self.name != \"self\" {\n             return None;\n         }\n@@ -1010,7 +1010,7 @@ impl Argument {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum FnRetTy {\n+crate enum FnRetTy {\n     Return(Type),\n     DefaultReturn,\n }\n@@ -1025,34 +1025,34 @@ impl GetDefId for FnRetTy {\n }\n \n #[derive(Clone, Debug)]\n-pub struct Trait {\n-    pub auto: bool,\n-    pub unsafety: hir::Unsafety,\n-    pub items: Vec<Item>,\n-    pub generics: Generics,\n-    pub bounds: Vec<GenericBound>,\n-    pub is_spotlight: bool,\n-    pub is_auto: bool,\n+crate struct Trait {\n+    crate auto: bool,\n+    crate unsafety: hir::Unsafety,\n+    crate items: Vec<Item>,\n+    crate generics: Generics,\n+    crate bounds: Vec<GenericBound>,\n+    crate is_spotlight: bool,\n+    crate is_auto: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct TraitAlias {\n-    pub generics: Generics,\n-    pub bounds: Vec<GenericBound>,\n+crate struct TraitAlias {\n+    crate generics: Generics,\n+    crate bounds: Vec<GenericBound>,\n }\n \n /// A trait reference, which may have higher ranked lifetimes.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct PolyTrait {\n-    pub trait_: Type,\n-    pub generic_params: Vec<GenericParamDef>,\n+crate struct PolyTrait {\n+    crate trait_: Type,\n+    crate generic_params: Vec<GenericParamDef>,\n }\n \n /// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n /// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n /// importantly, it does not preserve mutability or boxes.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum Type {\n+crate enum Type {\n     /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n     ResolvedPath {\n         path: Path,\n@@ -1095,7 +1095,7 @@ pub enum Type {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n-pub enum PrimitiveType {\n+crate enum PrimitiveType {\n     Isize,\n     I8,\n     I16,\n@@ -1124,7 +1124,7 @@ pub enum PrimitiveType {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n-pub enum TypeKind {\n+crate enum TypeKind {\n     Enum,\n     Function,\n     Module,\n@@ -1141,7 +1141,7 @@ pub enum TypeKind {\n     TraitAlias,\n }\n \n-pub trait GetDefId {\n+crate trait GetDefId {\n     fn def_id(&self) -> Option<DefId>;\n }\n \n@@ -1152,7 +1152,7 @@ impl<T: GetDefId> GetDefId for Option<T> {\n }\n \n impl Type {\n-    pub fn primitive_type(&self) -> Option<PrimitiveType> {\n+    crate fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n             Primitive(p) | BorrowedRef { type_: box Primitive(p), .. } => Some(p),\n             Slice(..) | BorrowedRef { type_: box Slice(..), .. } => Some(PrimitiveType::Slice),\n@@ -1172,21 +1172,21 @@ impl Type {\n         }\n     }\n \n-    pub fn is_generic(&self) -> bool {\n+    crate fn is_generic(&self) -> bool {\n         match *self {\n             ResolvedPath { is_generic, .. } => is_generic,\n             _ => false,\n         }\n     }\n \n-    pub fn is_self_type(&self) -> bool {\n+    crate fn is_self_type(&self) -> bool {\n         match *self {\n             Generic(ref name) => name == \"Self\",\n             _ => false,\n         }\n     }\n \n-    pub fn generics(&self) -> Option<Vec<Type>> {\n+    crate fn generics(&self) -> Option<Vec<Type>> {\n         match *self {\n             ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n                 if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n@@ -1206,7 +1206,7 @@ impl Type {\n         }\n     }\n \n-    pub fn bindings(&self) -> Option<&[TypeBinding]> {\n+    crate fn bindings(&self) -> Option<&[TypeBinding]> {\n         match *self {\n             ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n                 if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n@@ -1219,14 +1219,14 @@ impl Type {\n         }\n     }\n \n-    pub fn is_full_generic(&self) -> bool {\n+    crate fn is_full_generic(&self) -> bool {\n         match *self {\n             Type::Generic(_) => true,\n             _ => false,\n         }\n     }\n \n-    pub fn projection(&self) -> Option<(&Type, DefId, &str)> {\n+    crate fn projection(&self) -> Option<(&Type, DefId, &str)> {\n         let (self_, trait_, name) = match self {\n             QPath { ref self_type, ref trait_, ref name } => (self_type, trait_, name),\n             _ => return None,\n@@ -1267,7 +1267,7 @@ impl GetDefId for Type {\n }\n \n impl PrimitiveType {\n-    pub fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n+    crate fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n         match prim {\n             hir::PrimTy::Int(IntTy::Isize) => PrimitiveType::Isize,\n             hir::PrimTy::Int(IntTy::I8) => PrimitiveType::I8,\n@@ -1289,7 +1289,7 @@ impl PrimitiveType {\n         }\n     }\n \n-    pub fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n+    crate fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n         match s {\n             sym::isize => Some(PrimitiveType::Isize),\n             sym::i8 => Some(PrimitiveType::I8),\n@@ -1320,7 +1320,7 @@ impl PrimitiveType {\n         }\n     }\n \n-    pub fn as_str(&self) -> &'static str {\n+    crate fn as_str(&self) -> &'static str {\n         use self::PrimitiveType::*;\n         match *self {\n             Isize => \"isize\",\n@@ -1351,11 +1351,11 @@ impl PrimitiveType {\n         }\n     }\n \n-    pub fn impls(&self, tcx: TyCtxt<'_>) -> &'static SmallVec<[DefId; 4]> {\n+    crate fn impls(&self, tcx: TyCtxt<'_>) -> &'static SmallVec<[DefId; 4]> {\n         Self::all_impls(tcx).get(self).expect(\"missing impl for primitive type\")\n     }\n \n-    pub fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>> {\n+    crate fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>> {\n         static CELL: OnceCell<FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>>> = OnceCell::new();\n \n         CELL.get_or_init(move || {\n@@ -1431,7 +1431,7 @@ impl PrimitiveType {\n         })\n     }\n \n-    pub fn to_url_str(&self) -> &'static str {\n+    crate fn to_url_str(&self) -> &'static str {\n         self.as_str()\n     }\n }\n@@ -1485,71 +1485,71 @@ impl From<hir::PrimTy> for PrimitiveType {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Visibility {\n+crate enum Visibility {\n     Public,\n     Inherited,\n     Crate,\n     Restricted(DefId, Path),\n }\n \n #[derive(Clone, Debug)]\n-pub struct Struct {\n-    pub struct_type: doctree::StructType,\n-    pub generics: Generics,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n+crate struct Struct {\n+    crate struct_type: doctree::StructType,\n+    crate generics: Generics,\n+    crate fields: Vec<Item>,\n+    crate fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Union {\n-    pub struct_type: doctree::StructType,\n-    pub generics: Generics,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n+crate struct Union {\n+    crate struct_type: doctree::StructType,\n+    crate generics: Generics,\n+    crate fields: Vec<Item>,\n+    crate fields_stripped: bool,\n }\n \n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n #[derive(Clone, Debug)]\n-pub struct VariantStruct {\n-    pub struct_type: doctree::StructType,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n+crate struct VariantStruct {\n+    crate struct_type: doctree::StructType,\n+    crate fields: Vec<Item>,\n+    crate fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Enum {\n-    pub variants: IndexVec<VariantIdx, Item>,\n-    pub generics: Generics,\n-    pub variants_stripped: bool,\n+crate struct Enum {\n+    crate variants: IndexVec<VariantIdx, Item>,\n+    crate generics: Generics,\n+    crate variants_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Variant {\n-    pub kind: VariantKind,\n+crate struct Variant {\n+    crate kind: VariantKind,\n }\n \n #[derive(Clone, Debug)]\n-pub enum VariantKind {\n+crate enum VariantKind {\n     CLike,\n     Tuple(Vec<Type>),\n     Struct(VariantStruct),\n }\n \n #[derive(Clone, Debug)]\n-pub struct Span {\n-    pub filename: FileName,\n-    pub cnum: CrateNum,\n-    pub loline: usize,\n-    pub locol: usize,\n-    pub hiline: usize,\n-    pub hicol: usize,\n-    pub original: rustc_span::Span,\n+crate struct Span {\n+    crate filename: FileName,\n+    crate cnum: CrateNum,\n+    crate loline: usize,\n+    crate locol: usize,\n+    crate hiline: usize,\n+    crate hicol: usize,\n+    crate original: rustc_span::Span,\n }\n \n impl Span {\n-    pub fn empty() -> Span {\n+    crate fn empty() -> Span {\n         Span {\n             filename: FileName::Anon(0),\n             cnum: LOCAL_CRATE,\n@@ -1561,49 +1561,49 @@ impl Span {\n         }\n     }\n \n-    pub fn span(&self) -> rustc_span::Span {\n+    crate fn span(&self) -> rustc_span::Span {\n         self.original\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Path {\n-    pub global: bool,\n-    pub res: Res,\n-    pub segments: Vec<PathSegment>,\n+crate struct Path {\n+    crate global: bool,\n+    crate res: Res,\n+    crate segments: Vec<PathSegment>,\n }\n \n impl Path {\n-    pub fn last_name(&self) -> &str {\n+    crate fn last_name(&self) -> &str {\n         self.segments.last().expect(\"segments were empty\").name.as_str()\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericArg {\n+crate enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Type),\n     Const(Constant),\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericArgs {\n+crate enum GenericArgs {\n     AngleBracketed { args: Vec<GenericArg>, bindings: Vec<TypeBinding> },\n     Parenthesized { inputs: Vec<Type>, output: Option<Type> },\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct PathSegment {\n-    pub name: String,\n-    pub args: GenericArgs,\n+crate struct PathSegment {\n+    crate name: String,\n+    crate args: GenericArgs,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Typedef {\n-    pub type_: Type,\n-    pub generics: Generics,\n+crate struct Typedef {\n+    crate type_: Type,\n+    crate generics: Generics,\n     // Type of target item.\n-    pub item_type: Option<Type>,\n+    crate item_type: Option<Type>,\n }\n \n impl GetDefId for Typedef {\n@@ -1613,122 +1613,122 @@ impl GetDefId for Typedef {\n }\n \n #[derive(Clone, Debug)]\n-pub struct OpaqueTy {\n-    pub bounds: Vec<GenericBound>,\n-    pub generics: Generics,\n+crate struct OpaqueTy {\n+    crate bounds: Vec<GenericBound>,\n+    crate generics: Generics,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct BareFunctionDecl {\n-    pub unsafety: hir::Unsafety,\n-    pub generic_params: Vec<GenericParamDef>,\n-    pub decl: FnDecl,\n-    pub abi: Abi,\n+crate struct BareFunctionDecl {\n+    crate unsafety: hir::Unsafety,\n+    crate generic_params: Vec<GenericParamDef>,\n+    crate decl: FnDecl,\n+    crate abi: Abi,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Static {\n-    pub type_: Type,\n-    pub mutability: Mutability,\n+crate struct Static {\n+    crate type_: Type,\n+    crate mutability: Mutability,\n     /// It's useful to have the value of a static documented, but I have no\n     /// desire to represent expressions (that'd basically be all of the AST,\n     /// which is huge!). So, have a string.\n-    pub expr: String,\n+    crate expr: String,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct Constant {\n-    pub type_: Type,\n-    pub expr: String,\n-    pub value: Option<String>,\n-    pub is_literal: bool,\n+crate struct Constant {\n+    crate type_: Type,\n+    crate expr: String,\n+    crate value: Option<String>,\n+    crate is_literal: bool,\n }\n \n #[derive(Clone, PartialEq, Debug)]\n-pub enum ImplPolarity {\n+crate enum ImplPolarity {\n     Positive,\n     Negative,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Impl {\n-    pub unsafety: hir::Unsafety,\n-    pub generics: Generics,\n-    pub provided_trait_methods: FxHashSet<String>,\n-    pub trait_: Option<Type>,\n-    pub for_: Type,\n-    pub items: Vec<Item>,\n-    pub polarity: Option<ImplPolarity>,\n-    pub synthetic: bool,\n-    pub blanket_impl: Option<Type>,\n+crate struct Impl {\n+    crate unsafety: hir::Unsafety,\n+    crate generics: Generics,\n+    crate provided_trait_methods: FxHashSet<String>,\n+    crate trait_: Option<Type>,\n+    crate for_: Type,\n+    crate items: Vec<Item>,\n+    crate polarity: Option<ImplPolarity>,\n+    crate synthetic: bool,\n+    crate blanket_impl: Option<Type>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Import {\n-    pub kind: ImportKind,\n-    pub source: ImportSource,\n-    pub should_be_displayed: bool,\n+crate struct Import {\n+    crate kind: ImportKind,\n+    crate source: ImportSource,\n+    crate should_be_displayed: bool,\n }\n \n impl Import {\n-    pub fn new_simple(name: String, source: ImportSource, should_be_displayed: bool) -> Self {\n+    crate fn new_simple(name: String, source: ImportSource, should_be_displayed: bool) -> Self {\n         Self { kind: ImportKind::Simple(name), source, should_be_displayed }\n     }\n \n-    pub fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n+    crate fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n         Self { kind: ImportKind::Glob, source, should_be_displayed }\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub enum ImportKind {\n+crate enum ImportKind {\n     // use source as str;\n     Simple(String),\n     // use source::*;\n     Glob,\n }\n \n #[derive(Clone, Debug)]\n-pub struct ImportSource {\n-    pub path: Path,\n-    pub did: Option<DefId>,\n+crate struct ImportSource {\n+    crate path: Path,\n+    crate did: Option<DefId>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Macro {\n-    pub source: String,\n-    pub imported_from: Option<String>,\n+crate struct Macro {\n+    crate source: String,\n+    crate imported_from: Option<String>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct ProcMacro {\n-    pub kind: MacroKind,\n-    pub helpers: Vec<String>,\n+crate struct ProcMacro {\n+    crate kind: MacroKind,\n+    crate helpers: Vec<String>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Deprecation {\n-    pub since: Option<String>,\n-    pub note: Option<String>,\n-    pub is_since_rustc_version: bool,\n+crate struct Deprecation {\n+    crate since: Option<String>,\n+    crate note: Option<String>,\n+    crate is_since_rustc_version: bool,\n }\n \n /// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct TypeBinding {\n-    pub name: String,\n-    pub kind: TypeBindingKind,\n+crate struct TypeBinding {\n+    crate name: String,\n+    crate kind: TypeBindingKind,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TypeBindingKind {\n+crate enum TypeBindingKind {\n     Equality { ty: Type },\n     Constraint { bounds: Vec<GenericBound> },\n }\n \n impl TypeBinding {\n-    pub fn ty(&self) -> &Type {\n+    crate fn ty(&self) -> &Type {\n         match self.kind {\n             TypeBindingKind::Equality { ref ty } => ty,\n             _ => panic!(\"expected equality type binding for parenthesized generic args\"),"}, {"sha": "22917fbceb48a12dcb0fa773a8a1328fc6b8f341", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::mem;\n \n-pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n+crate fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n     use crate::visit_lib::LibEmbargoVisitor;\n \n     let krate = cx.tcx.hir().krate();\n@@ -102,11 +102,11 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n }\n \n // extract the stability index for a node from tcx, if possible\n-pub fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n+crate fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n     cx.tcx.lookup_stability(def_id).cloned()\n }\n \n-pub fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n+crate fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n     cx.tcx.lookup_deprecation(def_id).clean(cx)\n }\n \n@@ -183,7 +183,7 @@ pub(super) fn external_path(\n /// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n /// `[Display, Option]` (we just returns the list of the types, we don't care about the\n /// wrapped types in here).\n-pub fn get_real_types(\n+crate fn get_real_types(\n     generics: &Generics,\n     arg: &Type,\n     cx: &DocContext<'_>,\n@@ -261,7 +261,7 @@ pub fn get_real_types(\n ///\n /// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n /// `[u32, Display, Option]`.\n-pub fn get_all_types(\n+crate fn get_all_types(\n     generics: &Generics,\n     decl: &FnDecl,\n     cx: &DocContext<'_>,\n@@ -296,7 +296,7 @@ pub fn get_all_types(\n     (all_types.into_iter().collect(), ret_types)\n }\n \n-pub fn strip_type(ty: Type) -> Type {\n+crate fn strip_type(ty: Type) -> Type {\n     match ty {\n         Type::ResolvedPath { path, param_names, did, is_generic } => {\n             Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n@@ -319,7 +319,7 @@ pub fn strip_type(ty: Type) -> Type {\n     }\n }\n \n-pub fn strip_path(path: &Path) -> Path {\n+crate fn strip_path(path: &Path) -> Path {\n     let segments = path\n         .segments\n         .iter()\n@@ -332,7 +332,7 @@ pub fn strip_path(path: &Path) -> Path {\n     Path { global: path.global, res: path.res, segments }\n }\n \n-pub fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n+crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     let segments = match *p {\n         hir::QPath::Resolved(_, ref path) => &path.segments,\n         hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n@@ -351,7 +351,7 @@ pub fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     s\n }\n \n-pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n+crate fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -378,7 +378,7 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n     }\n }\n \n-pub trait ToSource {\n+crate trait ToSource {\n     fn to_src(&self, cx: &DocContext<'_>) -> String;\n }\n \n@@ -394,7 +394,7 @@ impl ToSource for rustc_span::Span {\n     }\n }\n \n-pub fn name_from_pat(p: &hir::Pat<'_>) -> String {\n+crate fn name_from_pat(p: &hir::Pat<'_>) -> String {\n     use rustc_hir::*;\n     debug!(\"trying to get a name from pattern: {:?}\", p);\n \n@@ -440,7 +440,7 @@ pub fn name_from_pat(p: &hir::Pat<'_>) -> String {\n     }\n }\n \n-pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n+crate fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     match n.val {\n         ty::ConstKind::Unevaluated(def, _, promoted) => {\n             let mut s = if let Some(def) = def.as_local() {\n@@ -470,7 +470,7 @@ pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     }\n }\n \n-pub fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<String> {\n+crate fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<String> {\n     cx.tcx.const_eval_poly(def_id).ok().and_then(|val| {\n         let ty = cx.tcx.type_of(def_id);\n         match (val, ty.kind()) {\n@@ -518,7 +518,7 @@ fn print_const_with_custom_print_scalar(cx: &DocContext<'_>, ct: &'tcx ty::Const\n     }\n }\n \n-pub fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n+crate fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n     if let hir::Node::Expr(expr) = cx.tcx.hir().get(hir_id) {\n         if let hir::ExprKind::Lit(_) = &expr.kind {\n             return true;\n@@ -534,7 +534,7 @@ pub fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n     false\n }\n \n-pub fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n+crate fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n     let value = &cx.tcx.hir().body(body).value;\n \n     let snippet = if !value.span.from_expansion() {\n@@ -547,7 +547,7 @@ pub fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-pub fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n+crate fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n \n     let is_generic = match path.res {\n@@ -565,7 +565,7 @@ pub fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n     ResolvedPath { path, param_names: None, did, is_generic }\n }\n \n-pub fn get_auto_trait_and_blanket_impls(\n+crate fn get_auto_trait_and_blanket_impls(\n     cx: &DocContext<'tcx>,\n     ty: Ty<'tcx>,\n     param_env_def_id: DefId,\n@@ -576,7 +576,7 @@ pub fn get_auto_trait_and_blanket_impls(\n         .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n }\n \n-pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n+crate fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n     debug!(\"register_res({:?})\", res);\n \n     let (did, kind) = match res {\n@@ -616,14 +616,14 @@ pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n     did\n }\n \n-pub fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n+crate fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n     ImportSource {\n         did: if path.res.opt_def_id().is_none() { None } else { Some(register_res(cx, path.res)) },\n         path,\n     }\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n+crate fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n where\n     F: FnOnce() -> R,\n {"}, {"sha": "e60970af0d341920153195353e54b1f074fbfecd", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -30,13 +30,13 @@ use crate::passes::{self, Condition, DefaultPassOption};\n use crate::theme;\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum OutputFormat {\n+crate enum OutputFormat {\n     Json,\n     Html,\n }\n \n impl OutputFormat {\n-    pub fn is_json(&self) -> bool {\n+    crate fn is_json(&self) -> bool {\n         match self {\n             OutputFormat::Json => true,\n             _ => false,\n@@ -58,96 +58,96 @@ impl TryFrom<&str> for OutputFormat {\n \n /// Configuration options for rustdoc.\n #[derive(Clone)]\n-pub struct Options {\n+crate struct Options {\n     // Basic options / Options passed directly to rustc\n     /// The crate root or Markdown file to load.\n-    pub input: PathBuf,\n+    crate input: PathBuf,\n     /// The name of the crate being documented.\n-    pub crate_name: Option<String>,\n+    crate crate_name: Option<String>,\n     /// Whether or not this is a proc-macro crate\n-    pub proc_macro_crate: bool,\n+    crate proc_macro_crate: bool,\n     /// How to format errors and warnings.\n-    pub error_format: ErrorOutputType,\n+    crate error_format: ErrorOutputType,\n     /// Library search paths to hand to the compiler.\n-    pub libs: Vec<SearchPath>,\n+    crate libs: Vec<SearchPath>,\n     /// Library search paths strings to hand to the compiler.\n-    pub lib_strs: Vec<String>,\n+    crate lib_strs: Vec<String>,\n     /// The list of external crates to link against.\n-    pub externs: Externs,\n+    crate externs: Externs,\n     /// The list of external crates strings to link against.\n-    pub extern_strs: Vec<String>,\n+    crate extern_strs: Vec<String>,\n     /// List of `cfg` flags to hand to the compiler. Always includes `rustdoc`.\n-    pub cfgs: Vec<String>,\n+    crate cfgs: Vec<String>,\n     /// Codegen options to hand to the compiler.\n-    pub codegen_options: CodegenOptions,\n+    crate codegen_options: CodegenOptions,\n     /// Codegen options strings to hand to the compiler.\n-    pub codegen_options_strs: Vec<String>,\n+    crate codegen_options_strs: Vec<String>,\n     /// Debugging (`-Z`) options to pass to the compiler.\n-    pub debugging_opts: DebuggingOptions,\n+    crate debugging_opts: DebuggingOptions,\n     /// Debugging (`-Z`) options strings to pass to the compiler.\n-    pub debugging_opts_strs: Vec<String>,\n+    crate debugging_opts_strs: Vec<String>,\n     /// The target used to compile the crate against.\n-    pub target: TargetTriple,\n+    crate target: TargetTriple,\n     /// Edition used when reading the crate. Defaults to \"2015\". Also used by default when\n     /// compiling doctests from the crate.\n-    pub edition: Edition,\n+    crate edition: Edition,\n     /// The path to the sysroot. Used during the compilation process.\n-    pub maybe_sysroot: Option<PathBuf>,\n+    crate maybe_sysroot: Option<PathBuf>,\n     /// Lint information passed over the command-line.\n-    pub lint_opts: Vec<(String, Level)>,\n+    crate lint_opts: Vec<(String, Level)>,\n     /// Whether to ask rustc to describe the lints it knows. Practically speaking, this will not be\n     /// used, since we abort if we have no input file, but it's included for completeness.\n-    pub describe_lints: bool,\n+    crate describe_lints: bool,\n     /// What level to cap lints at.\n-    pub lint_cap: Option<Level>,\n+    crate lint_cap: Option<Level>,\n \n     // Options specific to running doctests\n     /// Whether we should run doctests instead of generating docs.\n-    pub should_test: bool,\n+    crate should_test: bool,\n     /// List of arguments to pass to the test harness, if running tests.\n-    pub test_args: Vec<String>,\n+    crate test_args: Vec<String>,\n     /// Optional path to persist the doctest executables to, defaults to a\n     /// temporary directory if not set.\n-    pub persist_doctests: Option<PathBuf>,\n+    crate persist_doctests: Option<PathBuf>,\n     /// Runtool to run doctests with\n-    pub runtool: Option<String>,\n+    crate runtool: Option<String>,\n     /// Arguments to pass to the runtool\n-    pub runtool_args: Vec<String>,\n+    crate runtool_args: Vec<String>,\n     /// Whether to allow ignoring doctests on a per-target basis\n     /// For example, using ignore-foo to ignore running the doctest on any target that\n     /// contains \"foo\" as a substring\n-    pub enable_per_target_ignores: bool,\n+    crate enable_per_target_ignores: bool,\n \n     /// The path to a rustc-like binary to build tests with. If not set, we\n     /// default to loading from $sysroot/bin/rustc.\n-    pub test_builder: Option<PathBuf>,\n+    crate test_builder: Option<PathBuf>,\n \n     // Options that affect the documentation process\n     /// The selected default set of passes to use.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n-    pub default_passes: DefaultPassOption,\n+    crate default_passes: DefaultPassOption,\n     /// Any passes manually selected by the user.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n-    pub manual_passes: Vec<String>,\n+    crate manual_passes: Vec<String>,\n     /// Whether to display warnings during doc generation or while gathering doctests. By default,\n     /// all non-rustdoc-specific lints are allowed when generating docs.\n-    pub display_warnings: bool,\n+    crate display_warnings: bool,\n     /// Whether to run the `calculate-doc-coverage` pass, which counts the number of public items\n     /// with and without documentation.\n-    pub show_coverage: bool,\n+    crate show_coverage: bool,\n \n     // Options that alter generated documentation pages\n     /// Crate version to note on the sidebar of generated docs.\n-    pub crate_version: Option<String>,\n+    crate crate_version: Option<String>,\n     /// Collected options specific to outputting final pages.\n-    pub render_options: RenderOptions,\n+    crate render_options: RenderOptions,\n     /// Output format rendering (used only for \"show-coverage\" option for the moment)\n-    pub output_format: Option<OutputFormat>,\n+    crate output_format: Option<OutputFormat>,\n     /// If this option is set to `true`, rustdoc will only run checks and not generate\n     /// documentation.\n-    pub run_check: bool,\n+    crate run_check: bool,\n }\n \n impl fmt::Debug for Options {\n@@ -195,89 +195,89 @@ impl fmt::Debug for Options {\n \n /// Configuration options for the HTML page-creation process.\n #[derive(Clone, Debug)]\n-pub struct RenderOptions {\n+crate struct RenderOptions {\n     /// Output directory to generate docs into. Defaults to `doc`.\n-    pub output: PathBuf,\n+    crate output: PathBuf,\n     /// External files to insert into generated pages.\n-    pub external_html: ExternalHtml,\n+    crate external_html: ExternalHtml,\n     /// A pre-populated `IdMap` with the default headings and any headings added by Markdown files\n     /// processed by `external_html`.\n-    pub id_map: IdMap,\n+    crate id_map: IdMap,\n     /// If present, playground URL to use in the \"Run\" button added to code samples.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n-    pub playground_url: Option<String>,\n+    crate playground_url: Option<String>,\n     /// Whether to sort modules alphabetically on a module page instead of using declaration order.\n     /// `true` by default.\n     //\n     // FIXME(misdreavus): the flag name is `--sort-modules-by-appearance` but the meaning is\n     // inverted once read.\n-    pub sort_modules_alphabetically: bool,\n+    crate sort_modules_alphabetically: bool,\n     /// List of themes to extend the docs with. Original argument name is included to assist in\n     /// displaying errors if it fails a theme check.\n-    pub themes: Vec<StylePath>,\n+    crate themes: Vec<StylePath>,\n     /// If present, CSS file that contains rules to add to the default CSS.\n-    pub extension_css: Option<PathBuf>,\n+    crate extension_css: Option<PathBuf>,\n     /// A map of crate names to the URL to use instead of querying the crate's `html_root_url`.\n-    pub extern_html_root_urls: BTreeMap<String, String>,\n+    crate extern_html_root_urls: BTreeMap<String, String>,\n     /// A map of the default settings (values are as for DOM storage API). Keys should lack the\n     /// `rustdoc-` prefix.\n-    pub default_settings: HashMap<String, String>,\n+    crate default_settings: HashMap<String, String>,\n     /// If present, suffix added to CSS/JavaScript files when referencing them in generated pages.\n-    pub resource_suffix: String,\n+    crate resource_suffix: String,\n     /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by\n     /// default.\n     //\n     // FIXME(misdreavus): the flag name is `--disable-minification` but the meaning is inverted\n     // once read.\n-    pub enable_minification: bool,\n+    crate enable_minification: bool,\n     /// Whether to create an index page in the root of the output directory. If this is true but\n     /// `enable_index_page` is None, generate a static listing of crates instead.\n-    pub enable_index_page: bool,\n+    crate enable_index_page: bool,\n     /// A file to use as the index page at the root of the output directory. Overrides\n     /// `enable_index_page` to be true if set.\n-    pub index_page: Option<PathBuf>,\n+    crate index_page: Option<PathBuf>,\n     /// An optional path to use as the location of static files. If not set, uses combinations of\n     /// `../` to reach the documentation root.\n-    pub static_root_path: Option<String>,\n+    crate static_root_path: Option<String>,\n \n     // Options specific to reading standalone Markdown files\n     /// Whether to generate a table of contents on the output file when reading a standalone\n     /// Markdown file.\n-    pub markdown_no_toc: bool,\n+    crate markdown_no_toc: bool,\n     /// Additional CSS files to link in pages generated from standalone Markdown files.\n-    pub markdown_css: Vec<String>,\n+    crate markdown_css: Vec<String>,\n     /// If present, playground URL to use in the \"Run\" button added to code samples generated from\n     /// standalone Markdown files. If not present, `playground_url` is used.\n-    pub markdown_playground_url: Option<String>,\n+    crate markdown_playground_url: Option<String>,\n     /// If false, the `select` element to have search filtering by crates on rendered docs\n     /// won't be generated.\n-    pub generate_search_filter: bool,\n+    crate generate_search_filter: bool,\n     /// Document items that have lower than `pub` visibility.\n-    pub document_private: bool,\n+    crate document_private: bool,\n     /// Document items that have `doc(hidden)`.\n-    pub document_hidden: bool,\n-    pub unstable_features: rustc_feature::UnstableFeatures,\n+    crate document_hidden: bool,\n+    crate unstable_features: rustc_feature::UnstableFeatures,\n }\n \n /// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n /// Later on moved into `CACHE_KEY`.\n #[derive(Default, Clone)]\n-pub struct RenderInfo {\n-    pub inlined: FxHashSet<DefId>,\n-    pub external_paths: crate::core::ExternalPaths,\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-    pub access_levels: AccessLevels<DefId>,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n-    pub output_format: Option<OutputFormat>,\n+crate struct RenderInfo {\n+    crate inlined: FxHashSet<DefId>,\n+    crate external_paths: crate::core::ExternalPaths,\n+    crate exact_paths: FxHashMap<DefId, Vec<String>>,\n+    crate access_levels: AccessLevels<DefId>,\n+    crate deref_trait_did: Option<DefId>,\n+    crate deref_mut_trait_did: Option<DefId>,\n+    crate owned_box_did: Option<DefId>,\n+    crate output_format: Option<OutputFormat>,\n }\n \n impl Options {\n     /// Parses the given command-line for options. If an error message or other early-return has\n     /// been printed, returns `Err` with the exit code.\n-    pub fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n+    crate fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n         // Check for unstable options.\n         nightly_options::check_nightly_options(&matches, &opts());\n \n@@ -656,7 +656,7 @@ impl Options {\n     }\n \n     /// Returns `true` if the file given as `self.input` is a Markdown file.\n-    pub fn markdown_input(&self) -> bool {\n+    crate fn markdown_input(&self) -> bool {\n         self.input.extension().map_or(false, |e| e == \"md\" || e == \"markdown\")\n     }\n }"}, {"sha": "413f5bdf5214b912a41d065c3d43f9706b519db3", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -36,52 +36,51 @@ use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::config::{OutputFormat, RenderInfo};\n use crate::passes::{self, Condition::*, ConditionalPass};\n \n-pub use rustc_session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n-pub use rustc_session::search_paths::SearchPath;\n+crate use rustc_session::config::{DebuggingOptions, Input, Options};\n \n-pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n+crate type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n-pub struct DocContext<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n+crate struct DocContext<'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n+    crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n     /// Later on moved into `CACHE_KEY`\n-    pub renderinfo: RefCell<RenderInfo>,\n+    crate renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `CACHE_KEY`\n-    pub external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n+    crate external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n-    pub active_extern_traits: RefCell<FxHashSet<DefId>>,\n+    crate active_extern_traits: RefCell<FxHashSet<DefId>>,\n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n     /// Table `DefId` of type parameter -> substituted type\n-    pub ty_substs: RefCell<FxHashMap<DefId, clean::Type>>,\n+    crate ty_substs: RefCell<FxHashMap<DefId, clean::Type>>,\n     /// Table `DefId` of lifetime parameter -> substituted lifetime\n-    pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n+    crate lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n     /// Table `DefId` of const parameter -> substituted const\n-    pub ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n+    crate ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n-    pub impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n-    pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n-    pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n+    crate impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n+    crate fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n+    crate all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n-    pub generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n-    pub auto_traits: Vec<DefId>,\n+    crate generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n+    crate auto_traits: Vec<DefId>,\n     /// The options given to rustdoc that could be relevant to a pass.\n-    pub render_options: RenderOptions,\n+    crate render_options: RenderOptions,\n     /// The traits in scope for a given module.\n     ///\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     /// `map<module, set<trait>>`\n-    pub module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n+    crate module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n }\n \n impl<'tcx> DocContext<'tcx> {\n-    pub fn sess(&self) -> &Session {\n+    crate fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n \n-    pub fn enter_resolver<F, R>(&self, f: F) -> R\n+    crate fn enter_resolver<F, R>(&self, f: F) -> R\n     where\n         F: FnOnce(&mut resolve::Resolver<'_>) -> R,\n     {\n@@ -90,7 +89,7 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n-    pub fn enter_alias<F, R>(\n+    crate fn enter_alias<F, R>(\n         &self,\n         ty_substs: FxHashMap<DefId, clean::Type>,\n         lt_substs: FxHashMap<DefId, clean::Lifetime>,\n@@ -120,7 +119,7 @@ impl<'tcx> DocContext<'tcx> {\n     // Instead, we construct 'fake' def ids, which start immediately after the last DefId.\n     // In the Debug impl for clean::Item, we explicitly check for fake\n     // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n-    pub fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n+    crate fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n         let start_def_id = {\n             let num_def_ids = if crate_num == LOCAL_CRATE {\n                 self.tcx.hir().definitions().def_path_table().num_def_ids()\n@@ -150,23 +149,23 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+    crate fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None\n         } else {\n             def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n         }\n     }\n \n-    pub fn stability(&self, id: HirId) -> Option<attr::Stability> {\n+    crate fn stability(&self, id: HirId) -> Option<attr::Stability> {\n         self.tcx\n             .hir()\n             .opt_local_def_id(id)\n             .and_then(|def_id| self.tcx.lookup_stability(def_id.to_def_id()))\n             .cloned()\n     }\n \n-    pub fn deprecation(&self, id: HirId) -> Option<attr::Deprecation> {\n+    crate fn deprecation(&self, id: HirId) -> Option<attr::Deprecation> {\n         self.tcx\n             .hir()\n             .opt_local_def_id(id)\n@@ -178,7 +177,7 @@ impl<'tcx> DocContext<'tcx> {\n ///\n /// If the given `error_format` is `ErrorOutputType::Json` and no `SourceMap` is given, a new one\n /// will be created for the handler.\n-pub fn new_handler(\n+crate fn new_handler(\n     error_format: ErrorOutputType,\n     source_map: Option<Lrc<source_map::SourceMap>>,\n     debugging_opts: &DebuggingOptions,\n@@ -280,7 +279,7 @@ where\n     (lint_opts, lint_caps)\n }\n \n-pub fn run_core(\n+crate fn run_core(\n     options: RustdocOptions,\n ) -> (clean::Crate, RenderInfo, RenderOptions, Lrc<Session>) {\n     // Parse, resolve, and typecheck the given crate.\n@@ -725,7 +724,7 @@ impl<'tcx> Visitor<'tcx> for EmitIgnoredResolutionErrors<'tcx> {\n /// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter\n /// for `impl Trait` in argument position.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub enum ImplTraitParam {\n+crate enum ImplTraitParam {\n     DefId(DefId),\n     ParamIndex(u32),\n }"}, {"sha": "9b740acfcdfd7fe598e0e152e2e430008af5a58d", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -24,38 +24,38 @@ macro_rules! try_err {\n     };\n }\n \n-pub trait PathError {\n+crate trait PathError {\n     fn new<S, P: AsRef<Path>>(e: S, path: P) -> Self\n     where\n         S: ToString + Sized;\n }\n \n-pub struct DocFS {\n+crate struct DocFS {\n     sync_only: bool,\n     errors: Option<Sender<String>>,\n }\n \n impl DocFS {\n-    pub fn new(errors: Sender<String>) -> DocFS {\n+    crate fn new(errors: Sender<String>) -> DocFS {\n         DocFS { sync_only: false, errors: Some(errors) }\n     }\n \n-    pub fn set_sync_only(&mut self, sync_only: bool) {\n+    crate fn set_sync_only(&mut self, sync_only: bool) {\n         self.sync_only = sync_only;\n     }\n \n-    pub fn close(&mut self) {\n+    crate fn close(&mut self) {\n         self.errors = None;\n     }\n \n-    pub fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+    crate fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         // For now, dir creation isn't a huge time consideration, do it\n         // synchronously, which avoids needing ordering between write() actions\n         // and directory creation.\n         fs::create_dir_all(path)\n     }\n \n-    pub fn write<P, C, E>(&self, path: P, contents: C) -> Result<(), E>\n+    crate fn write<P, C, E>(&self, path: P, contents: C) -> Result<(), E>\n     where\n         P: AsRef<Path>,\n         C: AsRef<[u8]>,"}, {"sha": "c79b2395d231b138a17f301bda14940ec3b8ac95", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -31,17 +31,17 @@ use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n use crate::passes::span_of_attrs;\n \n #[derive(Clone, Default)]\n-pub struct TestOptions {\n+crate struct TestOptions {\n     /// Whether to disable the default `extern crate my_crate;` when creating doctests.\n-    pub no_crate_inject: bool,\n+    crate no_crate_inject: bool,\n     /// Whether to emit compilation warnings when compiling doctests. Setting this will suppress\n     /// the default `#![allow(unused)]`.\n-    pub display_warnings: bool,\n+    crate display_warnings: bool,\n     /// Additional crate-level attributes to add to doctests.\n-    pub attrs: Vec<String>,\n+    crate attrs: Vec<String>,\n }\n \n-pub fn run(options: Options) -> Result<(), ErrorReported> {\n+crate fn run(options: Options) -> Result<(), ErrorReported> {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -363,7 +363,7 @@ fn run_test(\n \n /// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n /// lines before the test code begins.\n-pub fn make_test(\n+crate fn make_test(\n     s: &str,\n     cratename: Option<&str>,\n     dont_insert_main: bool,\n@@ -605,16 +605,16 @@ fn partition_source(s: &str) -> (String, String, String) {\n     (before, after, crates)\n }\n \n-pub trait Tester {\n+crate trait Tester {\n     fn add_test(&mut self, test: String, config: LangString, line: usize);\n     fn get_line(&self) -> usize {\n         0\n     }\n     fn register_header(&mut self, _name: &str, _level: u32) {}\n }\n \n-pub struct Collector {\n-    pub tests: Vec<testing::TestDescAndFn>,\n+crate struct Collector {\n+    crate tests: Vec<testing::TestDescAndFn>,\n \n     // The name of the test displayed to the user, separated by `::`.\n     //\n@@ -650,7 +650,7 @@ pub struct Collector {\n }\n \n impl Collector {\n-    pub fn new(\n+    crate fn new(\n         cratename: String,\n         options: Options,\n         use_headers: bool,\n@@ -682,7 +682,7 @@ impl Collector {\n         format!(\"{} - {}(line {})\", filename, item_path, line)\n     }\n \n-    pub fn set_position(&mut self, position: Span) {\n+    crate fn set_position(&mut self, position: Span) {\n         self.position = position;\n     }\n "}, {"sha": "a80ac1e72fcaf17f024f45e087e851151ec70802", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 173, "deletions": 173, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,6 +1,6 @@\n //! This module is used to store stuff from Rust's AST in a more convenient\n //! manner (and with prettier names) before cleaning.\n-pub use self::StructType::*;\n+crate use self::StructType::*;\n \n use rustc_ast as ast;\n use rustc_span::hygiene::MacroKind;\n@@ -10,35 +10,35 @@ use rustc_hir as hir;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::HirId;\n \n-pub struct Module<'hir> {\n-    pub name: Option<Symbol>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub where_outer: Span,\n-    pub where_inner: Span,\n-    pub extern_crates: Vec<ExternCrate<'hir>>,\n-    pub imports: Vec<Import<'hir>>,\n-    pub structs: Vec<Struct<'hir>>,\n-    pub unions: Vec<Union<'hir>>,\n-    pub enums: Vec<Enum<'hir>>,\n-    pub fns: Vec<Function<'hir>>,\n-    pub mods: Vec<Module<'hir>>,\n-    pub id: hir::HirId,\n-    pub typedefs: Vec<Typedef<'hir>>,\n-    pub opaque_tys: Vec<OpaqueTy<'hir>>,\n-    pub statics: Vec<Static<'hir>>,\n-    pub constants: Vec<Constant<'hir>>,\n-    pub traits: Vec<Trait<'hir>>,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub impls: Vec<Impl<'hir>>,\n-    pub foreigns: Vec<ForeignItem<'hir>>,\n-    pub macros: Vec<Macro<'hir>>,\n-    pub proc_macros: Vec<ProcMacro<'hir>>,\n-    pub trait_aliases: Vec<TraitAlias<'hir>>,\n-    pub is_crate: bool,\n+crate struct Module<'hir> {\n+    crate name: Option<Symbol>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate where_outer: Span,\n+    crate where_inner: Span,\n+    crate extern_crates: Vec<ExternCrate<'hir>>,\n+    crate imports: Vec<Import<'hir>>,\n+    crate structs: Vec<Struct<'hir>>,\n+    crate unions: Vec<Union<'hir>>,\n+    crate enums: Vec<Enum<'hir>>,\n+    crate fns: Vec<Function<'hir>>,\n+    crate mods: Vec<Module<'hir>>,\n+    crate id: hir::HirId,\n+    crate typedefs: Vec<Typedef<'hir>>,\n+    crate opaque_tys: Vec<OpaqueTy<'hir>>,\n+    crate statics: Vec<Static<'hir>>,\n+    crate constants: Vec<Constant<'hir>>,\n+    crate traits: Vec<Trait<'hir>>,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate impls: Vec<Impl<'hir>>,\n+    crate foreigns: Vec<ForeignItem<'hir>>,\n+    crate macros: Vec<Macro<'hir>>,\n+    crate proc_macros: Vec<ProcMacro<'hir>>,\n+    crate trait_aliases: Vec<TraitAlias<'hir>>,\n+    crate is_crate: bool,\n }\n \n impl Module<'hir> {\n-    pub fn new(\n+    crate fn new(\n         name: Option<Symbol>,\n         attrs: &'hir [ast::Attribute],\n         vis: &'hir hir::Visibility<'hir>,\n@@ -73,7 +73,7 @@ impl Module<'hir> {\n }\n \n #[derive(Debug, Clone, Copy)]\n-pub enum StructType {\n+crate enum StructType {\n     /// A braced struct\n     Plain,\n     /// A tuple struct\n@@ -82,190 +82,190 @@ pub enum StructType {\n     Unit,\n }\n \n-pub struct Struct<'hir> {\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub struct_type: StructType,\n-    pub name: Symbol,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub fields: &'hir [hir::StructField<'hir>],\n-    pub span: Span,\n+crate struct Struct<'hir> {\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate struct_type: StructType,\n+    crate name: Symbol,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate fields: &'hir [hir::StructField<'hir>],\n+    crate span: Span,\n }\n \n-pub struct Union<'hir> {\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub struct_type: StructType,\n-    pub name: Symbol,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub fields: &'hir [hir::StructField<'hir>],\n-    pub span: Span,\n+crate struct Union<'hir> {\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate struct_type: StructType,\n+    crate name: Symbol,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate fields: &'hir [hir::StructField<'hir>],\n+    crate span: Span,\n }\n \n-pub struct Enum<'hir> {\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub variants: Vec<Variant<'hir>>,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub id: hir::HirId,\n-    pub span: Span,\n-    pub name: Symbol,\n+crate struct Enum<'hir> {\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate variants: Vec<Variant<'hir>>,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate id: hir::HirId,\n+    crate span: Span,\n+    crate name: Symbol,\n }\n \n-pub struct Variant<'hir> {\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub def: &'hir hir::VariantData<'hir>,\n-    pub span: Span,\n+crate struct Variant<'hir> {\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate def: &'hir hir::VariantData<'hir>,\n+    crate span: Span,\n }\n \n-pub struct Function<'hir> {\n-    pub decl: &'hir hir::FnDecl<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub id: hir::HirId,\n-    pub name: Symbol,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub header: hir::FnHeader,\n-    pub span: Span,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub body: hir::BodyId,\n+crate struct Function<'hir> {\n+    crate decl: &'hir hir::FnDecl<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate id: hir::HirId,\n+    crate name: Symbol,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate header: hir::FnHeader,\n+    crate span: Span,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate body: hir::BodyId,\n }\n \n-pub struct Typedef<'hir> {\n-    pub ty: &'hir hir::Ty<'hir>,\n-    pub gen: &'hir hir::Generics<'hir>,\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n+crate struct Typedef<'hir> {\n+    crate ty: &'hir hir::Ty<'hir>,\n+    crate gen: &'hir hir::Generics<'hir>,\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n-pub struct OpaqueTy<'hir> {\n-    pub opaque_ty: &'hir hir::OpaqueTy<'hir>,\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n+crate struct OpaqueTy<'hir> {\n+    crate opaque_ty: &'hir hir::OpaqueTy<'hir>,\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n-pub struct Static<'hir> {\n-    pub type_: &'hir hir::Ty<'hir>,\n-    pub mutability: hir::Mutability,\n-    pub expr: hir::BodyId,\n-    pub name: Symbol,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub span: Span,\n+crate struct Static<'hir> {\n+    crate type_: &'hir hir::Ty<'hir>,\n+    crate mutability: hir::Mutability,\n+    crate expr: hir::BodyId,\n+    crate name: Symbol,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate span: Span,\n }\n \n-pub struct Constant<'hir> {\n-    pub type_: &'hir hir::Ty<'hir>,\n-    pub expr: hir::BodyId,\n-    pub name: Symbol,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub span: Span,\n+crate struct Constant<'hir> {\n+    crate type_: &'hir hir::Ty<'hir>,\n+    crate expr: hir::BodyId,\n+    crate name: Symbol,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate span: Span,\n }\n \n-pub struct Trait<'hir> {\n-    pub is_auto: hir::IsAuto,\n-    pub unsafety: hir::Unsafety,\n-    pub name: Symbol,\n-    pub items: Vec<&'hir hir::TraitItem<'hir>>,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub bounds: &'hir [hir::GenericBound<'hir>],\n-    pub attrs: &'hir [ast::Attribute],\n-    pub id: hir::HirId,\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n+crate struct Trait<'hir> {\n+    crate is_auto: hir::IsAuto,\n+    crate unsafety: hir::Unsafety,\n+    crate name: Symbol,\n+    crate items: Vec<&'hir hir::TraitItem<'hir>>,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate bounds: &'hir [hir::GenericBound<'hir>],\n+    crate attrs: &'hir [ast::Attribute],\n+    crate id: hir::HirId,\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n-pub struct TraitAlias<'hir> {\n-    pub name: Symbol,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub bounds: &'hir [hir::GenericBound<'hir>],\n-    pub attrs: &'hir [ast::Attribute],\n-    pub id: hir::HirId,\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n+crate struct TraitAlias<'hir> {\n+    crate name: Symbol,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate bounds: &'hir [hir::GenericBound<'hir>],\n+    crate attrs: &'hir [ast::Attribute],\n+    crate id: hir::HirId,\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n-pub struct Impl<'hir> {\n-    pub unsafety: hir::Unsafety,\n-    pub polarity: hir::ImplPolarity,\n-    pub defaultness: hir::Defaultness,\n-    pub constness: hir::Constness,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub trait_: &'hir Option<hir::TraitRef<'hir>>,\n-    pub for_: &'hir hir::Ty<'hir>,\n-    pub items: Vec<&'hir hir::ImplItem<'hir>>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n+crate struct Impl<'hir> {\n+    crate unsafety: hir::Unsafety,\n+    crate polarity: hir::ImplPolarity,\n+    crate defaultness: hir::Defaultness,\n+    crate constness: hir::Constness,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate trait_: &'hir Option<hir::TraitRef<'hir>>,\n+    crate for_: &'hir hir::Ty<'hir>,\n+    crate items: Vec<&'hir hir::ImplItem<'hir>>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n }\n \n-pub struct ForeignItem<'hir> {\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub name: Symbol,\n-    pub kind: &'hir hir::ForeignItemKind<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n+crate struct ForeignItem<'hir> {\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate name: Symbol,\n+    crate kind: &'hir hir::ForeignItemKind<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n }\n \n // For Macro we store the DefId instead of the NodeId, since we also create\n // these imported macro_rules (which only have a DUMMY_NODE_ID).\n-pub struct Macro<'hir> {\n-    pub name: Symbol,\n-    pub hid: hir::HirId,\n-    pub def_id: hir::def_id::DefId,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n-    pub matchers: Vec<Span>,\n-    pub imported_from: Option<Symbol>,\n+crate struct Macro<'hir> {\n+    crate name: Symbol,\n+    crate hid: hir::HirId,\n+    crate def_id: hir::def_id::DefId,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n+    crate matchers: Vec<Span>,\n+    crate imported_from: Option<Symbol>,\n }\n \n-pub struct ExternCrate<'hir> {\n-    pub name: Symbol,\n-    pub hir_id: HirId,\n-    pub cnum: CrateNum,\n-    pub path: Option<String>,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n+crate struct ExternCrate<'hir> {\n+    crate name: Symbol,\n+    crate hir_id: HirId,\n+    crate cnum: CrateNum,\n+    crate path: Option<String>,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n }\n \n #[derive(Debug)]\n-pub struct Import<'hir> {\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub path: &'hir hir::Path<'hir>,\n-    pub glob: bool,\n-    pub span: Span,\n+crate struct Import<'hir> {\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate path: &'hir hir::Path<'hir>,\n+    crate glob: bool,\n+    crate span: Span,\n }\n \n-pub struct ProcMacro<'hir> {\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub kind: MacroKind,\n-    pub helpers: Vec<Symbol>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n+crate struct ProcMacro<'hir> {\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate kind: MacroKind,\n+    crate helpers: Vec<Symbol>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n }\n \n-pub fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n+crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,\n         hir::VariantData::Tuple(..) => Tuple,"}, {"sha": "82d0002b98b180d2ae514314740d8d6fd714d4a6", "filename": "src/librustdoc/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ferror.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -5,9 +5,9 @@ use std::path::{Path, PathBuf};\n use crate::docfs::PathError;\n \n #[derive(Debug)]\n-pub struct Error {\n-    pub file: PathBuf,\n-    pub error: String,\n+crate struct Error {\n+    crate file: PathBuf,\n+    crate error: String,\n }\n \n impl error::Error for Error {}"}, {"sha": "6c86baa36ac7de8dbf9e1f10e3d1c0306756c290", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -5,20 +5,20 @@ use std::path::Path;\n use std::str;\n \n #[derive(Clone, Debug)]\n-pub struct ExternalHtml {\n+crate struct ExternalHtml {\n     /// Content that will be included inline in the <head> section of a\n     /// rendered Markdown file or generated documentation\n-    pub in_header: String,\n+    crate in_header: String,\n     /// Content that will be included inline between <body> and the content of\n     /// a rendered Markdown file or generated documentation\n-    pub before_content: String,\n+    crate before_content: String,\n     /// Content that will be included inline between the content and </body> of\n     /// a rendered Markdown file or generated documentation\n-    pub after_content: String,\n+    crate after_content: String,\n }\n \n impl ExternalHtml {\n-    pub fn load(\n+    crate fn load(\n         in_header: &[String],\n         before_content: &[String],\n         after_content: &[String],\n@@ -50,12 +50,12 @@ impl ExternalHtml {\n     }\n }\n \n-pub enum LoadStringError {\n+crate enum LoadStringError {\n     ReadFail,\n     BadUtf8,\n }\n \n-pub fn load_string<P: AsRef<Path>>(\n+crate fn load_string<P: AsRef<Path>>(\n     file_path: P,\n     diag: &rustc_errors::Handler,\n ) -> Result<String, LoadStringError> {"}, {"sha": "a72860ef0a8fd1f01c3f4cf0bf48842ef6e9999d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,9 +1,9 @@\n use crate::clean::*;\n \n-pub struct StripItem(pub Item);\n+crate struct StripItem(pub Item);\n \n impl StripItem {\n-    pub fn strip(self) -> Option<Item> {\n+    crate fn strip(self) -> Option<Item> {\n         match self.0 {\n             Item { kind: StrippedItem(..), .. } => Some(self.0),\n             mut i => {\n@@ -14,7 +14,7 @@ impl StripItem {\n     }\n }\n \n-pub trait DocFolder: Sized {\n+crate trait DocFolder: Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         self.fold_item_recur(item)\n     }"}, {"sha": "917c1a95fdbf5c5e1f3050ea374e8f1b2c9c7d73", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -30,25 +30,25 @@ thread_local!(crate static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n /// to `Send` so it may be stored in a `Arc` instance and shared among the various\n /// rendering threads.\n #[derive(Default)]\n-pub struct Cache {\n+crate struct Cache {\n     /// Maps a type ID to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: FxHashMap<DefId, Vec<Impl>>,\n+    crate impls: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+    crate paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+    crate external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// Maps local `DefId`s of exported types to fully qualified paths.\n     /// Unlike 'paths', this mapping ignores any renames that occur\n@@ -60,36 +60,36 @@ pub struct Cache {\n     /// to the path used if the corresponding type is inlined. By\n     /// doing this, we can detect duplicate impls on a trait page, and only display\n     /// the impl for the inlined type.\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+    crate exact_paths: FxHashMap<DefId, Vec<String>>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    pub traits: FxHashMap<DefId, clean::Trait>,\n+    crate traits: FxHashMap<DefId, clean::Trait>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n+    crate implementors: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n+    crate extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+    crate primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from the privacy check pass.\n-    pub access_levels: AccessLevels<DefId>,\n+    crate access_levels: AccessLevels<DefId>,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    pub crate_version: Option<String>,\n+    crate crate_version: Option<String>,\n \n     /// Whether to document private items.\n     /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n-    pub document_private: bool,\n+    crate document_private: bool,\n \n     // Private fields only used when initially crawling a crate to build a cache\n     stack: Vec<String>,\n@@ -98,17 +98,17 @@ pub struct Cache {\n     stripped_mod: bool,\n     masked_crates: FxHashSet<CrateNum>,\n \n-    pub search_index: Vec<IndexItem>,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n+    crate search_index: Vec<IndexItem>,\n+    crate deref_trait_did: Option<DefId>,\n+    crate deref_mut_trait_did: Option<DefId>,\n+    crate owned_box_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n     // then the fully qualified name of the structure isn't presented in `paths`\n     // yet when its implementation methods are being indexed. Caches such methods\n     // and their parent id here and indexes them at the end of crate parsing.\n-    pub orphan_impl_items: Vec<(DefId, clean::Item)>,\n+    crate orphan_impl_items: Vec<(DefId, clean::Item)>,\n \n     // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n     // even though the trait itself is not exported. This can happen if a trait\n@@ -121,11 +121,11 @@ pub struct Cache {\n \n     /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n     /// we need the alias element to have an array of items.\n-    pub aliases: BTreeMap<String, Vec<usize>>,\n+    crate aliases: BTreeMap<String, Vec<usize>>,\n }\n \n impl Cache {\n-    pub fn from_krate(\n+    crate fn from_krate(\n         render_info: RenderInfo,\n         document_private: bool,\n         extern_html_root_urls: &BTreeMap<String, String>,"}, {"sha": "af512e3746092683c5a9616c5f1a64f2a9602ae8", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -20,7 +20,7 @@ use crate::clean;\n /// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n /// ordering based on a helper function inside `item_module`, in the same file.\n #[derive(Copy, PartialEq, Eq, Clone, Debug, PartialOrd, Ord)]\n-pub enum ItemType {\n+crate enum ItemType {\n     Module = 0,\n     ExternCrate = 1,\n     Import = 2,\n@@ -124,7 +124,7 @@ impl From<clean::TypeKind> for ItemType {\n }\n \n impl ItemType {\n-    pub fn as_str(&self) -> &'static str {\n+    crate fn as_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module => \"mod\",\n             ItemType::ExternCrate => \"externcrate\","}, {"sha": "55fd4948f45272299f10c22cdd959ab13c0576fe", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,8 +1,8 @@\n-pub mod cache;\n-pub mod item_type;\n-pub mod renderer;\n+crate mod cache;\n+crate mod item_type;\n+crate mod renderer;\n \n-pub use renderer::{run_format, FormatRenderer};\n+crate use renderer::{run_format, FormatRenderer};\n \n use rustc_span::def_id::DefId;\n \n@@ -11,34 +11,34 @@ use crate::clean::types::GetDefId;\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n-pub enum AssocItemRender<'a> {\n+crate enum AssocItemRender<'a> {\n     All,\n     DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type, deref_mut_: bool },\n }\n \n /// For different handling of associated items from the Deref target of a type rather than the type\n /// itself.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum RenderMode {\n+crate enum RenderMode {\n     Normal,\n     ForDeref { mut_: bool },\n }\n \n /// Metadata about implementations for a type or trait.\n #[derive(Clone, Debug)]\n-pub struct Impl {\n-    pub impl_item: clean::Item,\n+crate struct Impl {\n+    crate impl_item: clean::Item,\n }\n \n impl Impl {\n-    pub fn inner_impl(&self) -> &clean::Impl {\n+    crate fn inner_impl(&self) -> &clean::Impl {\n         match self.impl_item.kind {\n             clean::ImplItem(ref impl_) => impl_,\n             _ => panic!(\"non-impl item found in impl\"),\n         }\n     }\n \n-    pub fn trait_did(&self) -> Option<DefId> {\n+    crate fn trait_did(&self) -> Option<DefId> {\n         self.inner_impl().trait_.def_id()\n     }\n }"}, {"sha": "d0fdc69cc1932752574a796512635cc6a0b1b705", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -10,7 +10,7 @@ use crate::formats::cache::{Cache, CACHE_KEY};\n /// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n /// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n /// module, and cleanup/finalizing output.\n-pub trait FormatRenderer: Clone {\n+crate trait FormatRenderer: Clone {\n     /// Sets up any state required for the renderer. When this is called the cache has already been\n     /// populated.\n     fn init(\n@@ -43,7 +43,7 @@ pub trait FormatRenderer: Clone {\n }\n \n /// Main method for rendering a crate.\n-pub fn run_format<T: FormatRenderer>(\n+crate fn run_format<T: FormatRenderer>(\n     krate: clean::Crate,\n     options: RenderOptions,\n     render_info: RenderInfo,"}, {"sha": "60c19551983cdf577b15dd3d44e518b67be957f4", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -7,7 +7,7 @@ use std::fmt;\n \n /// Wrapper struct which will emit the HTML-escaped version of the contained\n /// string when passed to a format string.\n-pub struct Escape<'a>(pub &'a str);\n+crate struct Escape<'a>(pub &'a str);\n \n impl<'a> fmt::Display for Escape<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "d2722ed1cd23115f42ada67681fb69ada8c3122e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -21,7 +21,7 @@ use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n use crate::html::render::CURRENT_DEPTH;\n \n-pub trait Print {\n+crate trait Print {\n     fn print(self, buffer: &mut Buffer);\n }\n \n@@ -47,7 +47,7 @@ impl Print for &'_ str {\n }\n \n #[derive(Debug, Clone)]\n-pub struct Buffer {\n+crate struct Buffer {\n     for_html: bool,\n     buffer: String,\n }\n@@ -115,28 +115,28 @@ impl Buffer {\n }\n \n /// Wrapper struct for properly emitting a function or method declaration.\n-pub struct Function<'a> {\n+crate struct Function<'a> {\n     /// The declaration to emit.\n-    pub decl: &'a clean::FnDecl,\n+    crate decl: &'a clean::FnDecl,\n     /// The length of the function header and name. In other words, the number of characters in the\n     /// function declaration up to but not including the parentheses.\n     ///\n     /// Used to determine line-wrapping.\n-    pub header_len: usize,\n+    crate header_len: usize,\n     /// The number of spaces to indent each successive line with, if line-wrapping is necessary.\n-    pub indent: usize,\n+    crate indent: usize,\n     /// Whether the function is async or not.\n-    pub asyncness: hir::IsAsync,\n+    crate asyncness: hir::IsAsync,\n }\n \n /// Wrapper struct for emitting a where-clause from Generics.\n-pub struct WhereClause<'a> {\n+crate struct WhereClause<'a> {\n     /// The Generics from which to emit a where-clause.\n-    pub gens: &'a clean::Generics,\n+    crate gens: &'a clean::Generics,\n     /// The number of spaces to indent each line with.\n-    pub indent: usize,\n+    crate indent: usize,\n     /// Whether the where-clause needs to add a comma and newline after the last bound.\n-    pub end_newline: bool,\n+    crate end_newline: bool,\n }\n \n fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Display {\n@@ -480,7 +480,7 @@ impl clean::Path {\n     }\n }\n \n-pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n+crate fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n     let cache = cache();\n     if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n         return None;\n@@ -618,7 +618,7 @@ fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display\n     })\n }\n \n-pub fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n+crate fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n     display_fn(move |f| {\n         if let Some((url, short_ty, fqp)) = href(did) {\n             write!(\n@@ -910,7 +910,7 @@ impl clean::Impl {\n }\n \n // The difference from above is that trait is not hyperlinked.\n-pub fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut Buffer, use_absolute: bool) {\n+crate fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut Buffer, use_absolute: bool) {\n     f.from_display(i.print_inner(false, use_absolute))\n }\n "}, {"sha": "22233731411508be24c0d1cb079c04afafe50e4e", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -15,7 +15,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::with_default_session_globals;\n \n /// Highlights `src`, returning the HTML output.\n-pub fn render_with_highlighting(\n+crate fn render_with_highlighting(\n     src: String,\n     class: Option<&str>,\n     playground_button: Option<&str>,"}, {"sha": "e8039942f4f8325a0374bd917fb53ce00afcd3b4", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -7,33 +7,33 @@ use crate::html::format::{Buffer, Print};\n use crate::html::render::{ensure_trailing_slash, StylePath};\n \n #[derive(Clone)]\n-pub struct Layout {\n-    pub logo: String,\n-    pub favicon: String,\n-    pub external_html: ExternalHtml,\n-    pub default_settings: HashMap<String, String>,\n-    pub krate: String,\n+crate struct Layout {\n+    crate logo: String,\n+    crate favicon: String,\n+    crate external_html: ExternalHtml,\n+    crate default_settings: HashMap<String, String>,\n+    crate krate: String,\n     /// The given user css file which allow to customize the generated\n     /// documentation theme.\n-    pub css_file_extension: Option<PathBuf>,\n+    crate css_file_extension: Option<PathBuf>,\n     /// If false, the `select` element to have search filtering by crates on rendered docs\n     /// won't be generated.\n-    pub generate_search_filter: bool,\n+    crate generate_search_filter: bool,\n }\n \n-pub struct Page<'a> {\n-    pub title: &'a str,\n-    pub css_class: &'a str,\n-    pub root_path: &'a str,\n-    pub static_root_path: Option<&'a str>,\n-    pub description: &'a str,\n-    pub keywords: &'a str,\n-    pub resource_suffix: &'a str,\n-    pub extra_scripts: &'a [&'a str],\n-    pub static_extra_scripts: &'a [&'a str],\n+crate struct Page<'a> {\n+    crate title: &'a str,\n+    crate css_class: &'a str,\n+    crate root_path: &'a str,\n+    crate static_root_path: Option<&'a str>,\n+    crate description: &'a str,\n+    crate keywords: &'a str,\n+    crate resource_suffix: &'a str,\n+    crate extra_scripts: &'a [&'a str],\n+    crate static_extra_scripts: &'a [&'a str],\n }\n \n-pub fn render<T: Print, S: Print>(\n+crate fn render<T: Print, S: Print>(\n     layout: &Layout,\n     page: &Page<'_>,\n     sidebar: S,\n@@ -228,7 +228,7 @@ pub fn render<T: Print, S: Print>(\n     )\n }\n \n-pub fn redirect(url: &str) -> String {\n+crate fn redirect(url: &str) -> String {\n     // <script> triggers a redirect before refresh, so this is fine.\n     format!(\n         r##\"<!DOCTYPE html>"}, {"sha": "cdb9aea5ad6ce38c62b270ac6c4acaa320d691ea", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -62,23 +62,23 @@ pub struct Markdown<'a>(\n     pub &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n-pub struct MarkdownWithToc<'a>(\n-    pub &'a str,\n-    pub &'a mut IdMap,\n-    pub ErrorCodes,\n-    pub Edition,\n-    pub &'a Option<Playground>,\n+crate struct MarkdownWithToc<'a>(\n+    crate &'a str,\n+    crate &'a mut IdMap,\n+    crate ErrorCodes,\n+    crate Edition,\n+    crate &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(\n-    pub &'a str,\n-    pub &'a mut IdMap,\n-    pub ErrorCodes,\n-    pub Edition,\n-    pub &'a Option<Playground>,\n+crate struct MarkdownHtml<'a>(\n+    crate &'a str,\n+    crate &'a mut IdMap,\n+    crate ErrorCodes,\n+    crate Edition,\n+    crate &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders only the first paragraph.\n-pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n+crate struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ErrorCodes {\n@@ -87,14 +87,14 @@ pub enum ErrorCodes {\n }\n \n impl ErrorCodes {\n-    pub fn from(b: bool) -> Self {\n+    crate fn from(b: bool) -> Self {\n         match b {\n             true => ErrorCodes::Yes,\n             false => ErrorCodes::No,\n         }\n     }\n \n-    pub fn as_bool(self) -> bool {\n+    crate fn as_bool(self) -> bool {\n         match self {\n             ErrorCodes::Yes => true,\n             ErrorCodes::No => false,\n@@ -643,7 +643,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n     }\n }\n \n-pub fn find_testable_code<T: doctest::Tester>(\n+crate fn find_testable_code<T: doctest::Tester>(\n     doc: &str,\n     tests: &mut T,\n     error_codes: ErrorCodes,\n@@ -709,19 +709,19 @@ pub fn find_testable_code<T: doctest::Tester>(\n     }\n }\n \n-pub struct ExtraInfo<'a, 'b> {\n+crate struct ExtraInfo<'a, 'b> {\n     hir_id: Option<HirId>,\n     item_did: Option<DefId>,\n     sp: Span,\n     tcx: &'a TyCtxt<'b>,\n }\n \n impl<'a, 'b> ExtraInfo<'a, 'b> {\n-    pub fn new(tcx: &'a TyCtxt<'b>, hir_id: HirId, sp: Span) -> ExtraInfo<'a, 'b> {\n+    crate fn new(tcx: &'a TyCtxt<'b>, hir_id: HirId, sp: Span) -> ExtraInfo<'a, 'b> {\n         ExtraInfo { hir_id: Some(hir_id), item_did: None, sp, tcx }\n     }\n \n-    pub fn new_did(tcx: &'a TyCtxt<'b>, did: DefId, sp: Span) -> ExtraInfo<'a, 'b> {\n+    crate fn new_did(tcx: &'a TyCtxt<'b>, did: DefId, sp: Span) -> ExtraInfo<'a, 'b> {\n         ExtraInfo { hir_id: None, item_did: Some(did), sp, tcx }\n     }\n \n@@ -753,21 +753,21 @@ impl<'a, 'b> ExtraInfo<'a, 'b> {\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-pub struct LangString {\n+crate struct LangString {\n     original: String,\n-    pub should_panic: bool,\n-    pub no_run: bool,\n-    pub ignore: Ignore,\n-    pub rust: bool,\n-    pub test_harness: bool,\n-    pub compile_fail: bool,\n-    pub error_codes: Vec<String>,\n-    pub allow_fail: bool,\n-    pub edition: Option<Edition>,\n+    crate should_panic: bool,\n+    crate no_run: bool,\n+    crate ignore: Ignore,\n+    crate rust: bool,\n+    crate test_harness: bool,\n+    crate compile_fail: bool,\n+    crate error_codes: Vec<String>,\n+    crate allow_fail: bool,\n+    crate edition: Option<Edition>,\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-pub enum Ignore {\n+crate enum Ignore {\n     All,\n     None,\n     Some(Vec<String>),\n@@ -955,7 +955,7 @@ impl Markdown<'_> {\n }\n \n impl MarkdownWithToc<'_> {\n-    pub fn into_string(self) -> String {\n+    crate fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n         let p = Parser::new_ext(md, opts());\n@@ -976,7 +976,7 @@ impl MarkdownWithToc<'_> {\n }\n \n impl MarkdownHtml<'_> {\n-    pub fn into_string(self) -> String {\n+    crate fn into_string(self) -> String {\n         let MarkdownHtml(md, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n@@ -1003,7 +1003,7 @@ impl MarkdownHtml<'_> {\n }\n \n impl MarkdownSummaryLine<'_> {\n-    pub fn into_string(self) -> String {\n+    crate fn into_string(self) -> String {\n         let MarkdownSummaryLine(md, links) = self;\n         // This is actually common enough to special-case\n         if md.is_empty() {\n@@ -1039,7 +1039,7 @@ impl MarkdownSummaryLine<'_> {\n /// - Headings, links, and formatting are stripped.\n /// - Inline code is rendered as-is, surrounded by backticks.\n /// - HTML and code blocks are ignored.\n-pub fn plain_text_summary(md: &str) -> String {\n+crate fn plain_text_summary(md: &str) -> String {\n     if md.is_empty() {\n         return String::new();\n     }\n@@ -1064,7 +1064,7 @@ pub fn plain_text_summary(md: &str) -> String {\n     s\n }\n \n-pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n+crate fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     if md.is_empty() {\n         return vec![];\n     }\n@@ -1120,11 +1120,11 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n crate struct RustCodeBlock {\n     /// The range in the markdown that the code block occupies. Note that this includes the fences\n     /// for fenced code blocks.\n-    pub range: Range<usize>,\n+    crate range: Range<usize>,\n     /// The range in the markdown that the code within the code block occupies.\n-    pub code: Range<usize>,\n-    pub is_fenced: bool,\n-    pub syntax: Option<String>,\n+    crate code: Range<usize>,\n+    crate is_fenced: bool,\n+    crate syntax: Option<String>,\n }\n \n /// Returns a range of bytes for each code block in the markdown that is tagged as `rust` or\n@@ -1247,17 +1247,17 @@ impl IdMap {\n         IdMap { map: init_id_map() }\n     }\n \n-    pub fn populate<I: IntoIterator<Item = String>>(&mut self, ids: I) {\n+    crate fn populate<I: IntoIterator<Item = String>>(&mut self, ids: I) {\n         for id in ids {\n             let _ = self.derive(id);\n         }\n     }\n \n-    pub fn reset(&mut self) {\n+    crate fn reset(&mut self) {\n         self.map = init_id_map();\n     }\n \n-    pub fn derive(&mut self, candidate: String) -> String {\n+    crate fn derive(&mut self, candidate: String) -> String {\n         let id = match self.map.get_mut(&candidate) {\n             None => candidate,\n             Some(a) => {"}, {"sha": "403a9303c3ff0004171555ad4612a182d451fc2c", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -3,7 +3,7 @@ crate mod format;\n crate mod highlight;\n crate mod layout;\n pub mod markdown;\n-pub mod render;\n+crate mod render;\n crate mod sources;\n crate mod static_files;\n crate mod toc;"}, {"sha": "cef9b8952dd7d0b4f4324b2bb613b374e98ae1a8", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -13,7 +13,7 @@ use crate::html::render::{plain_text_summary, shorten};\n use crate::html::render::{Generic, IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n /// Indicates where an external crate can be found.\n-pub enum ExternalLocation {\n+crate enum ExternalLocation {\n     /// Remote URL root of the external crate\n     Remote(String),\n     /// This external crate can be found in the local doc/ folder\n@@ -24,7 +24,7 @@ pub enum ExternalLocation {\n \n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n-pub fn extern_location(\n+crate fn extern_location(\n     e: &clean::ExternalCrate,\n     extern_url: Option<&str>,\n     dst: &Path,\n@@ -62,7 +62,7 @@ pub fn extern_location(\n }\n \n /// Builds the search index from the collected metadata\n-pub fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];"}, {"sha": "78822e678d43edbe88f3fcb6b6c1a97af4639c0d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 86, "deletions": 72, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -25,7 +25,7 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-pub mod cache;\n+crate mod cache;\n \n #[cfg(test)]\n mod tests;\n@@ -82,7 +82,7 @@ use crate::html::{highlight, layout, static_files};\n use cache::{build_index, ExternalLocation};\n \n /// A pair of name and its optional document.\n-pub type NameDoc = (String, Option<String>);\n+crate type NameDoc = (String, Option<String>);\n \n crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     crate::html::format::display_fn(move |f| {\n@@ -101,60 +101,60 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n crate struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub current: Vec<String>,\n+    crate current: Vec<String>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n-    pub dst: PathBuf,\n+    crate dst: PathBuf,\n     /// A flag, which when `true`, will render pages which redirect to the\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n-    pub render_redirect_pages: bool,\n+    crate render_redirect_pages: bool,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n-    pub shared: Arc<SharedContext>,\n+    crate shared: Arc<SharedContext>,\n     all: Rc<RefCell<AllTypes>>,\n     /// Storage for the errors produced while generating documentation so they\n     /// can be printed together at the end.\n-    pub errors: Rc<Receiver<String>>,\n+    crate errors: Rc<Receiver<String>>,\n }\n \n crate struct SharedContext {\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n-    pub src_root: PathBuf,\n+    crate src_root: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n-    pub layout: layout::Layout,\n+    crate layout: layout::Layout,\n     /// This flag indicates whether `[src]` links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n-    pub include_sources: bool,\n+    crate include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n-    pub local_sources: FxHashMap<PathBuf, String>,\n+    crate local_sources: FxHashMap<PathBuf, String>,\n     /// Whether the collapsed pass ran\n-    pub collapsed: bool,\n+    crate collapsed: bool,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n     /// an issue number.\n-    pub issue_tracker_base_url: Option<String>,\n+    crate issue_tracker_base_url: Option<String>,\n     /// The directories that have already been created in this doc run. Used to reduce the number\n     /// of spurious `create_dir_all` calls.\n-    pub created_dirs: RefCell<FxHashSet<PathBuf>>,\n+    crate created_dirs: RefCell<FxHashSet<PathBuf>>,\n     /// This flag indicates whether listings of modules (in the side bar and documentation itself)\n     /// should be ordered alphabetically or in order of appearance (in the source code).\n-    pub sort_modules_alphabetically: bool,\n+    crate sort_modules_alphabetically: bool,\n     /// Additional CSS files to be added to the generated docs.\n-    pub style_files: Vec<StylePath>,\n+    crate style_files: Vec<StylePath>,\n     /// Suffix to be added on resource files (if suffix is \"-v2\" then \"light.css\" becomes\n     /// \"light-v2.css\").\n-    pub resource_suffix: String,\n+    crate resource_suffix: String,\n     /// Optional path string to be used to load static files on output pages. If not set, uses\n     /// combinations of `../` to reach the documentation root.\n-    pub static_root_path: Option<String>,\n+    crate static_root_path: Option<String>,\n     /// The fs handle we are working with.\n-    pub fs: DocFS,\n+    crate fs: DocFS,\n     /// The default edition used to parse doctests.\n-    pub edition: Edition,\n-    pub codes: ErrorCodes,\n+    crate edition: Edition,\n+    crate codes: ErrorCodes,\n     playground: Option<markdown::Playground>,\n }\n \n@@ -186,7 +186,7 @@ impl SharedContext {\n \n     /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n     /// `collapsed_doc_value` of the given item.\n-    pub fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n+    crate fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n         if self.collapsed {\n             item.collapsed_doc_value().map(|s| s.into())\n         } else {\n@@ -201,14 +201,14 @@ impl SharedContext {\n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n-pub struct IndexItem {\n-    pub ty: ItemType,\n-    pub name: String,\n-    pub path: String,\n-    pub desc: String,\n-    pub parent: Option<DefId>,\n-    pub parent_idx: Option<usize>,\n-    pub search_type: Option<IndexItemFunctionType>,\n+crate struct IndexItem {\n+    crate ty: ItemType,\n+    crate name: String,\n+    crate path: String,\n+    crate desc: String,\n+    crate parent: Option<DefId>,\n+    crate parent_idx: Option<usize>,\n+    crate search_type: Option<IndexItemFunctionType>,\n }\n \n impl Serialize for IndexItem {\n@@ -282,7 +282,7 @@ impl Serialize for Generic {\n \n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n-pub struct IndexItemFunctionType {\n+crate struct IndexItemFunctionType {\n     inputs: Vec<TypeWithKind>,\n     output: Option<Vec<TypeWithKind>>,\n }\n@@ -340,16 +340,16 @@ impl Serialize for TypeWithKind {\n }\n \n #[derive(Debug, Clone)]\n-pub struct StylePath {\n+crate struct StylePath {\n     /// The path to the theme\n-    pub path: PathBuf,\n+    crate path: PathBuf,\n     /// What the `disabled` attribute should be set to in the HTML tag\n-    pub disabled: bool,\n+    crate disabled: bool,\n }\n \n-thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n+thread_local!(crate static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n-pub fn initial_ids() -> Vec<String> {\n+crate fn initial_ids() -> Vec<String> {\n     [\n         \"main\",\n         \"search\",\n@@ -1701,7 +1701,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache)\n \n     // Write `src` tag\n     //\n-    // When this item is part of a `pub use` in a downstream crate, the\n+    // When this item is part of a `crate use` in a downstream crate, the\n     // [src] link in the downstream documentation will actually come back to\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n@@ -1994,7 +1994,7 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n }\n \n /// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n-pub fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n     /// Takes a non-numeric and a numeric part from the given &str.\n     fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n         let i = s.find(|c: char| c.is_ascii_digit());\n@@ -2081,14 +2081,14 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n     // This call is to remove re-export duplicates in cases such as:\n     //\n     // ```\n-    // pub mod foo {\n-    //     pub mod bar {\n-    //         pub trait Double { fn foo(); }\n+    // crate mod foo {\n+    //     crate mod bar {\n+    //         crate trait Double { fn foo(); }\n     //     }\n     // }\n     //\n-    // pub use foo::bar::*;\n-    // pub use foo::*;\n+    // crate use foo::bar::*;\n+    // crate use foo::*;\n     // ```\n     //\n     // `Double` will appear twice in the generated docs.\n@@ -2251,6 +2251,22 @@ fn stability_tags(item: &clean::Item, parent: &clean::Item) -> String {\n     tags\n }\n \n+fn portability(item: &clean::Item, parent: Option<&clean::Item>) -> Option<String> {\n+    let cfg = match (&item.attrs.cfg, parent.and_then(|p| p.attrs.cfg.as_ref())) {\n+        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n+        (cfg, _) => cfg.as_deref().cloned(),\n+    };\n+\n+    debug!(\n+        \"Portability {:?} - {:?} = {:?}\",\n+        item.attrs.cfg,\n+        parent.and_then(|p| p.attrs.cfg.as_ref()),\n+        cfg\n+    );\n+\n+    Some(format!(\"<div class=\\\"stab portability\\\">{}</div>\", cfg?.render_long_html()))\n+}\n+\n /// Render the stability and/or deprecation warning that is displayed at the top of the item's\n /// documentation.\n fn short_stability(item: &clean::Item, cx: &Context, parent: Option<&clean::Item>) -> Vec<String> {\n@@ -2328,19 +2344,8 @@ fn short_stability(item: &clean::Item, cx: &Context, parent: Option<&clean::Item\n         stability.push(format!(\"<div class=\\\"stab unstable\\\">{}</div>\", message));\n     }\n \n-    let cfg = match (&item.attrs.cfg, parent.and_then(|p| p.attrs.cfg.as_ref())) {\n-        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n-        (cfg, _) => cfg.as_deref().cloned(),\n-    };\n-\n-    debug!(\n-        \"Portability {:?} - {:?} = {:?}\",\n-        item.attrs.cfg,\n-        parent.and_then(|p| p.attrs.cfg.as_ref()),\n-        cfg\n-    );\n-    if let Some(cfg) = cfg {\n-        stability.push(format!(\"<div class=\\\"stab portability\\\">{}</div>\", cfg.render_long_html()));\n+    if let Some(portability) = portability(item, parent) {\n+        stability.push(portability);\n     }\n \n     stability\n@@ -2431,6 +2436,7 @@ fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Func\n fn render_implementor(\n     cx: &Context,\n     implementor: &Impl,\n+    parent: &clean::Item,\n     w: &mut Buffer,\n     implementor_dups: &FxHashMap<&str, (DefId, bool)>,\n     aliases: &[String],\n@@ -2450,7 +2456,7 @@ fn render_implementor(\n         w,\n         cx,\n         implementor,\n-        None,\n+        parent,\n         AssocItemLink::Anchor(None),\n         RenderMode::Normal,\n         implementor.impl_item.stable_since().as_deref(),\n@@ -2480,7 +2486,7 @@ fn render_impls(\n                 &mut buffer,\n                 cx,\n                 i,\n-                Some(containing_item),\n+                containing_item,\n                 assoc_link,\n                 RenderMode::Normal,\n                 containing_item.stable_since().as_deref(),\n@@ -2727,7 +2733,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n                     w,\n                     cx,\n                     &implementor,\n-                    None,\n+                    it,\n                     assoc_link,\n                     RenderMode::Normal,\n                     implementor.impl_item.stable_since().as_deref(),\n@@ -2749,7 +2755,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n             \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n         );\n         for implementor in concrete {\n-            render_implementor(cx, implementor, w, &implementor_dups, &[], cache);\n+            render_implementor(cx, implementor, it, w, &implementor_dups, &[], cache);\n         }\n         write_loading_content(w, \"</div>\");\n \n@@ -2764,6 +2770,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n                 render_implementor(\n                     cx,\n                     implementor,\n+                    it,\n                     w,\n                     &implementor_dups,\n                     &collect_paths_for_type(implementor.inner_impl().for_.clone()),\n@@ -3430,7 +3437,7 @@ fn render_assoc_items(\n                 w,\n                 cx,\n                 i,\n-                Some(containing_item),\n+                containing_item,\n                 AssocItemLink::Anchor(None),\n                 render_mode,\n                 containing_item.stable_since().as_deref(),\n@@ -3622,7 +3629,7 @@ fn render_impl(\n     w: &mut Buffer,\n     cx: &Context,\n     i: &Impl,\n-    parent: Option<&clean::Item>,\n+    parent: &clean::Item,\n     link: AssocItemLink<'_>,\n     render_mode: RenderMode,\n     outer_version: Option<&str>,\n@@ -3635,6 +3642,9 @@ fn render_impl(\n     aliases: &[String],\n     cache: &Cache,\n ) {\n+    let traits = &cache.traits;\n+    let trait_ = i.trait_did().map(|did| &traits[&did]);\n+\n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => {\n@@ -3687,6 +3697,13 @@ fn render_impl(\n             );\n         }\n         write!(w, \"</h3>\");\n+\n+        if trait_.is_some() {\n+            if let Some(portability) = portability(&i.impl_item, Some(parent)) {\n+                write!(w, \"<div class=\\\"stability\\\">{}</div>\", portability);\n+            }\n+        }\n+\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n             let mut ids = cx.id_map.borrow_mut();\n             write!(\n@@ -3709,7 +3726,7 @@ fn render_impl(\n         w: &mut Buffer,\n         cx: &Context,\n         item: &clean::Item,\n-        parent: Option<&clean::Item>,\n+        parent: &clean::Item,\n         link: AssocItemLink<'_>,\n         render_mode: RenderMode,\n         is_default_item: bool,\n@@ -3794,7 +3811,7 @@ fn render_impl(\n                     if let Some(it) = t.items.iter().find(|i| i.name == item.name) {\n                         // We need the stability of the item from the trait\n                         // because impls can't have a stability.\n-                        document_stability(w, cx, it, is_hidden, parent);\n+                        document_stability(w, cx, it, is_hidden, Some(parent));\n                         if item.doc_value().is_some() {\n                             document_full(w, item, cx, \"\", is_hidden);\n                         } else if show_def_docs {\n@@ -3804,30 +3821,27 @@ fn render_impl(\n                         }\n                     }\n                 } else {\n-                    document_stability(w, cx, item, is_hidden, parent);\n+                    document_stability(w, cx, item, is_hidden, Some(parent));\n                     if show_def_docs {\n                         document_full(w, item, cx, \"\", is_hidden);\n                     }\n                 }\n             } else {\n-                document_stability(w, cx, item, is_hidden, parent);\n+                document_stability(w, cx, item, is_hidden, Some(parent));\n                 if show_def_docs {\n                     document_short(w, item, link, \"\", is_hidden);\n                 }\n             }\n         }\n     }\n \n-    let traits = &cache.traits;\n-    let trait_ = i.trait_did().map(|did| &traits[&did]);\n-\n     write!(w, \"<div class=\\\"impl-items\\\">\");\n     for trait_item in &i.inner_impl().items {\n         doc_impl_item(\n             w,\n             cx,\n             trait_item,\n-            parent,\n+            if trait_.is_some() { &i.impl_item } else { parent },\n             link,\n             render_mode,\n             false,\n@@ -3843,7 +3857,7 @@ fn render_impl(\n         cx: &Context,\n         t: &clean::Trait,\n         i: &clean::Impl,\n-        parent: Option<&clean::Item>,\n+        parent: &clean::Item,\n         render_mode: RenderMode,\n         outer_version: Option<&str>,\n         show_def_docs: bool,\n@@ -3884,7 +3898,7 @@ fn render_impl(\n                 cx,\n                 t,\n                 &i.inner_impl(),\n-                parent,\n+                &i.impl_item,\n                 render_mode,\n                 outer_version,\n                 show_def_docs,"}, {"sha": "0f82649409f360ef83495821afac70a946832c18", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -137,7 +137,7 @@ impl<'a> SourceCollector<'a> {\n /// static HTML tree. Each component in the cleaned path will be passed as an\n /// argument to `f`. The very last component of the path (ie the file name) will\n /// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-pub fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+crate fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n where\n     F: FnMut(&OsStr),\n {"}, {"sha": "b8377dc15696dd77cb15df97dd5ca9ef6ed04ed3", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -2439,12 +2439,13 @@ function defocusSearchBar() {\n \n         var func = function(e) {\n             var next = e.nextElementSibling;\n+            if (next && hasClass(next, \"stability\")) {\n+              next = next.nextElementSibling;\n+            }\n             if (!next) {\n                 return;\n             }\n-            if (hasClass(next, \"docblock\") === true ||\n-                (hasClass(next, \"stability\") === true &&\n-                 hasClass(next.nextElementSibling, \"docblock\") === true)) {\n+            if (hasClass(next, \"docblock\")) {\n                 var newToggle = toggle.cloneNode(true);\n                 insertAfter(newToggle, e.childNodes[e.childNodes.length - 1]);\n                 if (hideMethodDocs === true && hasClass(e, \"method\") === true) {\n@@ -2455,6 +2456,9 @@ function defocusSearchBar() {\n \n         var funcImpl = function(e) {\n             var next = e.nextElementSibling;\n+            if (next && hasClass(next, \"stability\")) {\n+                next = next.nextElementSibling;\n+            }\n             if (next && hasClass(next, \"docblock\")) {\n                 next = next.nextElementSibling;\n             }"}, {"sha": "132ac42c4228369ee2185363825e3c8bcc023ec4", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -8,111 +8,111 @@\n //! directly written to a `Write` handle.\n \n /// The file contents of the main `rustdoc.css` file, responsible for the core layout of the page.\n-pub static RUSTDOC_CSS: &str = include_str!(\"static/rustdoc.css\");\n+crate static RUSTDOC_CSS: &str = include_str!(\"static/rustdoc.css\");\n \n /// The file contents of `settings.css`, responsible for the items on the settings page.\n-pub static SETTINGS_CSS: &str = include_str!(\"static/settings.css\");\n+crate static SETTINGS_CSS: &str = include_str!(\"static/settings.css\");\n \n /// The file contents of the `noscript.css` file, used in case JS isn't supported or is disabled.\n-pub static NOSCRIPT_CSS: &str = include_str!(\"static/noscript.css\");\n+crate static NOSCRIPT_CSS: &str = include_str!(\"static/noscript.css\");\n \n /// The file contents of `normalize.css`, included to even out standard elements between browser\n /// implementations.\n-pub static NORMALIZE_CSS: &str = include_str!(\"static/normalize.css\");\n+crate static NORMALIZE_CSS: &str = include_str!(\"static/normalize.css\");\n \n /// The file contents of `main.js`, which contains the core JavaScript used on documentation pages,\n /// including search behavior and docblock folding, among others.\n-pub static MAIN_JS: &str = include_str!(\"static/main.js\");\n+crate static MAIN_JS: &str = include_str!(\"static/main.js\");\n \n /// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n /// page.\n-pub static SETTINGS_JS: &str = include_str!(\"static/settings.js\");\n+crate static SETTINGS_JS: &str = include_str!(\"static/settings.js\");\n \n /// The file contents of `storage.js`, which contains functionality related to browser Local\n /// Storage, used to store documentation settings.\n-pub static STORAGE_JS: &str = include_str!(\"static/storage.js\");\n+crate static STORAGE_JS: &str = include_str!(\"static/storage.js\");\n \n /// The file contents of `brush.svg`, the icon used for the theme-switch button.\n-pub static BRUSH_SVG: &[u8] = include_bytes!(\"static/brush.svg\");\n+crate static BRUSH_SVG: &[u8] = include_bytes!(\"static/brush.svg\");\n \n /// The file contents of `wheel.svg`, the icon used for the settings button.\n-pub static WHEEL_SVG: &[u8] = include_bytes!(\"static/wheel.svg\");\n+crate static WHEEL_SVG: &[u8] = include_bytes!(\"static/wheel.svg\");\n \n /// The file contents of `down-arrow.svg`, the icon used for the crate choice combobox.\n-pub static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/down-arrow.svg\");\n+crate static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/down-arrow.svg\");\n \n /// The contents of `COPYRIGHT.txt`, the license listing for files distributed with documentation\n /// output.\n-pub static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n+crate static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n \n /// The contents of `LICENSE-APACHE.txt`, the text of the Apache License, version 2.0.\n-pub static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n+crate static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n \n /// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n-pub static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n+crate static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n \n /// The contents of `rust-logo.png`, the default icon of the documentation.\n-pub static RUST_LOGO: &[u8] = include_bytes!(\"static/rust-logo.png\");\n+crate static RUST_LOGO: &[u8] = include_bytes!(\"static/rust-logo.png\");\n /// The default documentation favicons (SVG and PNG fallbacks)\n-pub static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/favicon.svg\");\n-pub static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/favicon-16x16.png\");\n-pub static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/favicon-32x32.png\");\n+crate static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/favicon.svg\");\n+crate static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/favicon-16x16.png\");\n+crate static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/favicon-32x32.png\");\n \n /// The built-in themes given to every documentation site.\n-pub mod themes {\n+crate mod themes {\n     /// The \"light\" theme, selected by default when no setting is available. Used as the basis for\n     /// the `--check-theme` functionality.\n-    pub static LIGHT: &str = include_str!(\"static/themes/light.css\");\n+    crate static LIGHT: &str = include_str!(\"static/themes/light.css\");\n \n     /// The \"dark\" theme.\n-    pub static DARK: &str = include_str!(\"static/themes/dark.css\");\n+    crate static DARK: &str = include_str!(\"static/themes/dark.css\");\n \n     /// The \"ayu\" theme.\n-    pub static AYU: &str = include_str!(\"static/themes/ayu.css\");\n+    crate static AYU: &str = include_str!(\"static/themes/ayu.css\");\n }\n \n /// Files related to the Fira Sans font.\n-pub mod fira_sans {\n+crate mod fira_sans {\n     /// The file `FiraSans-Regular.woff`, the Regular variant of the Fira Sans font.\n-    pub static REGULAR: &[u8] = include_bytes!(\"static/FiraSans-Regular.woff\");\n+    crate static REGULAR: &[u8] = include_bytes!(\"static/FiraSans-Regular.woff\");\n \n     /// The file `FiraSans-Medium.woff`, the Medium variant of the Fira Sans font.\n-    pub static MEDIUM: &[u8] = include_bytes!(\"static/FiraSans-Medium.woff\");\n+    crate static MEDIUM: &[u8] = include_bytes!(\"static/FiraSans-Medium.woff\");\n \n     /// The file `FiraSans-LICENSE.txt`, the license text for the Fira Sans font.\n-    pub static LICENSE: &[u8] = include_bytes!(\"static/FiraSans-LICENSE.txt\");\n+    crate static LICENSE: &[u8] = include_bytes!(\"static/FiraSans-LICENSE.txt\");\n }\n \n /// Files related to the Source Serif Pro font.\n-pub mod source_serif_pro {\n+crate mod source_serif_pro {\n     /// The file `SourceSerifPro-Regular.ttf.woff`, the Regular variant of the Source Serif Pro\n     /// font.\n-    pub static REGULAR: &[u8] = include_bytes!(\"static/SourceSerifPro-Regular.ttf.woff\");\n+    crate static REGULAR: &[u8] = include_bytes!(\"static/SourceSerifPro-Regular.ttf.woff\");\n \n     /// The file `SourceSerifPro-Bold.ttf.woff`, the Bold variant of the Source Serif Pro font.\n-    pub static BOLD: &[u8] = include_bytes!(\"static/SourceSerifPro-Bold.ttf.woff\");\n+    crate static BOLD: &[u8] = include_bytes!(\"static/SourceSerifPro-Bold.ttf.woff\");\n \n     /// The file `SourceSerifPro-It.ttf.woff`, the Italic variant of the Source Serif Pro font.\n-    pub static ITALIC: &[u8] = include_bytes!(\"static/SourceSerifPro-It.ttf.woff\");\n+    crate static ITALIC: &[u8] = include_bytes!(\"static/SourceSerifPro-It.ttf.woff\");\n \n     /// The file `SourceSerifPro-LICENSE.txt`, the license text for the Source Serif Pro font.\n-    pub static LICENSE: &[u8] = include_bytes!(\"static/SourceSerifPro-LICENSE.md\");\n+    crate static LICENSE: &[u8] = include_bytes!(\"static/SourceSerifPro-LICENSE.md\");\n }\n \n /// Files related to the Source Code Pro font.\n-pub mod source_code_pro {\n+crate mod source_code_pro {\n     /// The file `SourceCodePro-Regular.woff`, the Regular variant of the Source Code Pro font.\n-    pub static REGULAR: &[u8] = include_bytes!(\"static/SourceCodePro-Regular.woff\");\n+    crate static REGULAR: &[u8] = include_bytes!(\"static/SourceCodePro-Regular.woff\");\n \n     /// The file `SourceCodePro-Semibold.woff`, the Semibold variant of the Source Code Pro font.\n-    pub static SEMIBOLD: &[u8] = include_bytes!(\"static/SourceCodePro-Semibold.woff\");\n+    crate static SEMIBOLD: &[u8] = include_bytes!(\"static/SourceCodePro-Semibold.woff\");\n \n     /// The file `SourceCodePro-LICENSE.txt`, the license text of the Source Code Pro font.\n-    pub static LICENSE: &[u8] = include_bytes!(\"static/SourceCodePro-LICENSE.txt\");\n+    crate static LICENSE: &[u8] = include_bytes!(\"static/SourceCodePro-LICENSE.txt\");\n }\n \n /// Files related to the sidebar in rustdoc sources.\n-pub mod sidebar {\n+crate mod sidebar {\n     /// File script to handle sidebar.\n-    pub static SOURCE_SCRIPT: &str = include_str!(\"static/source-script.js\");\n+    crate static SOURCE_SCRIPT: &str = include_str!(\"static/source-script.js\");\n }"}, {"sha": "b39a4e179cd164e35df536d1ac75b3f0828099f0", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -2,7 +2,7 @@\n \n /// A (recursive) table of contents\n #[derive(Debug, PartialEq)]\n-pub struct Toc {\n+crate struct Toc {\n     /// The levels are strictly decreasing, i.e.\n     ///\n     /// `entries[0].level >= entries[1].level >= ...`\n@@ -26,7 +26,7 @@ impl Toc {\n }\n \n #[derive(Debug, PartialEq)]\n-pub struct TocEntry {\n+crate struct TocEntry {\n     level: u32,\n     sec_number: String,\n     name: String,\n@@ -36,7 +36,7 @@ pub struct TocEntry {\n \n /// Progressive construction of a table of contents.\n #[derive(PartialEq)]\n-pub struct TocBuilder {\n+crate struct TocBuilder {\n     top_level: Toc,\n     /// The current hierarchy of parent headings, the levels are\n     /// strictly increasing (i.e., `chain[0].level < chain[1].level <\n@@ -50,12 +50,12 @@ pub struct TocBuilder {\n }\n \n impl TocBuilder {\n-    pub fn new() -> TocBuilder {\n+    crate fn new() -> TocBuilder {\n         TocBuilder { top_level: Toc { entries: Vec::new() }, chain: Vec::new() }\n     }\n \n     /// Converts into a true `Toc` struct.\n-    pub fn into_toc(mut self) -> Toc {\n+    crate fn into_toc(mut self) -> Toc {\n         // we know all levels are >= 1.\n         self.fold_until(0);\n         self.top_level\n@@ -115,7 +115,7 @@ impl TocBuilder {\n     /// Push a level `level` heading into the appropriate place in the\n     /// hierarchy, returning a string containing the section number in\n     /// `<num>.<num>.<num>` format.\n-    pub fn push(&mut self, level: u32, name: String, id: String) -> &str {\n+    crate fn push(&mut self, level: u32, name: String, id: String) -> &str {\n         assert!(level >= 1);\n \n         // collapse all previous sections into their parents until we"}, {"sha": "5eb1f7b1f7780ff04e6655ad9c663e585b6bdd1a", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -7,7 +7,7 @@ use crate::formats::FormatRenderer;\n use rustc_span::edition::Edition;\n \n #[derive(Clone)]\n-pub struct JsonRenderer {}\n+crate struct JsonRenderer {}\n \n impl FormatRenderer for JsonRenderer {\n     fn init("}, {"sha": "963f2cf71f389761c9bd8f4f367c13df5a7c737f", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -32,7 +32,7 @@ fn extract_leading_metadata(s: &str) -> (Vec<&str>, &str) {\n \n /// Render `input` (e.g., \"foo.md\") into an HTML file in `output`\n /// (e.g., output = \"bar\" => \"bar/foo.html\").\n-pub fn render<P: AsRef<Path>>(\n+crate fn render<P: AsRef<Path>>(\n     input: P,\n     options: RenderOptions,\n     edition: Edition,\n@@ -114,7 +114,7 @@ pub fn render<P: AsRef<Path>>(\n }\n \n /// Runs any tests/code examples in the markdown file `input`.\n-pub fn test(mut options: Options) -> Result<(), String> {\n+crate fn test(mut options: Options) -> Result<(), String> {\n     let input_str = read_to_string(&options.input)\n         .map_err(|err| format!(\"{}: {}\", options.input.display(), err))?;\n     let mut opts = TestOptions::default();"}, {"sha": "aca218e538165c87b0c758c4e355ab7facd83590", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -14,7 +14,7 @@ use serde::Serialize;\n use std::collections::BTreeMap;\n use std::ops;\n \n-pub const CALCULATE_DOC_COVERAGE: Pass = Pass {\n+crate const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     name: \"calculate-doc-coverage\",\n     run: calculate_doc_coverage,\n     description: \"counts the number of items with and without documentation\","}, {"sha": "a48fa738e3b727cc944500e82bc5c0006e92be88", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -11,13 +11,13 @@ use crate::fold::DocFolder;\n use crate::html::markdown::{self, RustCodeBlock};\n use crate::passes::{span_of_attrs, Pass};\n \n-pub const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n+crate const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     name: \"check-code-block-syntax\",\n     run: check_code_block_syntax,\n     description: \"validates syntax inside Rust code blocks\",\n };\n \n-pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n     SyntaxChecker { cx }.fold_crate(krate)\n }\n "}, {"sha": "1f9f5c58e5a93279277231a38c2edf09c6bc6d2f", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -6,13 +6,13 @@ use crate::passes::Pass;\n \n use std::mem::take;\n \n-pub const COLLAPSE_DOCS: Pass = Pass {\n+crate const COLLAPSE_DOCS: Pass = Pass {\n     name: \"collapse-docs\",\n     run: collapse_docs,\n     description: \"concatenates all document attributes into one document attribute\",\n };\n \n-pub fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     let mut krate = Collapser.fold_crate(krate);\n     krate.collapsed = true;\n     krate\n@@ -66,7 +66,7 @@ fn collapse(doc_strings: &mut Vec<DocFragment>) {\n }\n \n impl clean::Attributes {\n-    pub fn collapse_doc_comments(&mut self) {\n+    crate fn collapse_doc_comments(&mut self) {\n         collapse(&mut self.doc_strings);\n     }\n }"}, {"sha": "895414b1d7e4c8c1e280ad6681fca0192ff2d356", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -39,13 +39,13 @@ use crate::passes::Pass;\n \n use super::span_of_attrs;\n \n-pub const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n+crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n     run: collect_intra_doc_links,\n     description: \"reads a crate's documentation to resolve intra-doc-links\",\n };\n \n-pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     LinkCollector::new(cx).fold_crate(krate)\n }\n "}, {"sha": "2946db1f46206d2acbcd6128deba7c2aea461fda", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -7,13 +7,13 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::symbol::sym;\n \n-pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n+crate const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     name: \"collect-trait-impls\",\n     run: collect_trait_impls,\n     description: \"retrieves trait impls for items in the crate\",\n };\n \n-pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     let mut synth = SyntheticImplCollector::new(cx);\n     let mut krate = synth.fold_crate(krate);\n "}, {"sha": "60fe8080f56b41dc817c8f5714788c3cfb0d270a", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -12,7 +12,7 @@ use crate::html::markdown::{find_testable_code, ErrorCodes, Ignore, LangString};\n use rustc_middle::lint::LintSource;\n use rustc_session::lint;\n \n-pub const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n+crate const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n     name: \"check-private-items-doc-tests\",\n     run: check_private_items_doc_tests,\n     description: \"check private items doc tests\",\n@@ -28,7 +28,7 @@ impl<'a, 'tcx> PrivateItemDocTestLinter<'a, 'tcx> {\n     }\n }\n \n-pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     let mut coll = PrivateItemDocTestLinter::new(cx);\n \n     coll.fold_crate(krate)\n@@ -57,7 +57,7 @@ impl crate::doctest::Tester for Tests {\n     }\n }\n \n-pub fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n+crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n     if matches!(item.kind,\n         clean::StructFieldItem(_)\n         | clean::VariantItem(_)\n@@ -79,7 +79,7 @@ pub fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool\n     level != lint::Level::Allow || matches!(source, LintSource::Default)\n }\n \n-pub fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n+crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n         Some(hir_id) => hir_id,\n         None => {"}, {"sha": "01efd07cbcde7a48c6953acbf941539cb729c553", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -9,7 +9,7 @@ use rustc_session::lint;\n use std::iter::Peekable;\n use std::str::CharIndices;\n \n-pub const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n+crate const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n     name: \"check-invalid-html-tags\",\n     run: check_invalid_html_tags,\n     description: \"detects invalid HTML tags in doc comments\",\n@@ -25,7 +25,7 @@ impl<'a, 'tcx> InvalidHtmlTagsLinter<'a, 'tcx> {\n     }\n }\n \n-pub fn check_invalid_html_tags(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_invalid_html_tags(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {"}, {"sha": "51818d7faf0071f70243dfe11f78cd69dcc66080", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -9,67 +9,67 @@ use crate::clean::{self, DocFragmentKind};\n use crate::core::DocContext;\n \n mod stripper;\n-pub use stripper::*;\n+crate use stripper::*;\n \n mod non_autolinks;\n-pub use self::non_autolinks::CHECK_NON_AUTOLINKS;\n+crate use self::non_autolinks::CHECK_NON_AUTOLINKS;\n \n mod collapse_docs;\n-pub use self::collapse_docs::COLLAPSE_DOCS;\n+crate use self::collapse_docs::COLLAPSE_DOCS;\n \n mod strip_hidden;\n-pub use self::strip_hidden::STRIP_HIDDEN;\n+crate use self::strip_hidden::STRIP_HIDDEN;\n \n mod strip_private;\n-pub use self::strip_private::STRIP_PRIVATE;\n+crate use self::strip_private::STRIP_PRIVATE;\n \n mod strip_priv_imports;\n-pub use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n+crate use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n \n mod unindent_comments;\n-pub use self::unindent_comments::UNINDENT_COMMENTS;\n+crate use self::unindent_comments::UNINDENT_COMMENTS;\n \n mod propagate_doc_cfg;\n-pub use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n+crate use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n \n mod collect_intra_doc_links;\n-pub use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n+crate use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n \n mod doc_test_lints;\n-pub use self::doc_test_lints::CHECK_PRIVATE_ITEMS_DOC_TESTS;\n+crate use self::doc_test_lints::CHECK_PRIVATE_ITEMS_DOC_TESTS;\n \n mod collect_trait_impls;\n-pub use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n+crate use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n \n mod check_code_block_syntax;\n-pub use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n+crate use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n \n mod calculate_doc_coverage;\n-pub use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n+crate use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n \n mod html_tags;\n-pub use self::html_tags::CHECK_INVALID_HTML_TAGS;\n+crate use self::html_tags::CHECK_INVALID_HTML_TAGS;\n \n /// A single pass over the cleaned documentation.\n ///\n /// Runs in the compiler context, so it has access to types and traits and the like.\n #[derive(Copy, Clone)]\n-pub struct Pass {\n-    pub name: &'static str,\n-    pub run: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n-    pub description: &'static str,\n+crate struct Pass {\n+    crate name: &'static str,\n+    crate run: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n+    crate description: &'static str,\n }\n \n /// In a list of passes, a pass that may or may not need to be run depending on options.\n #[derive(Copy, Clone)]\n-pub struct ConditionalPass {\n-    pub pass: Pass,\n-    pub condition: Condition,\n+crate struct ConditionalPass {\n+    crate pass: Pass,\n+    crate condition: Condition,\n }\n \n /// How to decide whether to run a conditional pass.\n #[derive(Copy, Clone)]\n-pub enum Condition {\n+crate enum Condition {\n     Always,\n     /// When `--document-private-items` is passed.\n     WhenDocumentPrivate,\n@@ -80,7 +80,7 @@ pub enum Condition {\n }\n \n /// The full list of passes.\n-pub const PASSES: &[Pass] = &[\n+crate const PASSES: &[Pass] = &[\n     CHECK_PRIVATE_ITEMS_DOC_TESTS,\n     STRIP_HIDDEN,\n     UNINDENT_COMMENTS,\n@@ -97,7 +97,7 @@ pub const PASSES: &[Pass] = &[\n ];\n \n /// The list of passes run by default.\n-pub const DEFAULT_PASSES: &[ConditionalPass] = &[\n+crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n     ConditionalPass::always(COLLAPSE_DOCS),\n     ConditionalPass::always(UNINDENT_COMMENTS),\n@@ -113,34 +113,34 @@ pub const DEFAULT_PASSES: &[ConditionalPass] = &[\n ];\n \n /// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n-pub const COVERAGE_PASSES: &[ConditionalPass] = &[\n+crate const COVERAGE_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n     ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),\n     ConditionalPass::always(CALCULATE_DOC_COVERAGE),\n ];\n \n impl ConditionalPass {\n-    pub const fn always(pass: Pass) -> Self {\n+    crate const fn always(pass: Pass) -> Self {\n         Self::new(pass, Always)\n     }\n \n-    pub const fn new(pass: Pass, condition: Condition) -> Self {\n+    crate const fn new(pass: Pass, condition: Condition) -> Self {\n         ConditionalPass { pass, condition }\n     }\n }\n \n /// A shorthand way to refer to which set of passes to use, based on the presence of\n /// `--no-defaults` and `--show-coverage`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum DefaultPassOption {\n+crate enum DefaultPassOption {\n     Default,\n     Coverage,\n     None,\n }\n \n /// Returns the given default set of passes.\n-pub fn defaults(default_set: DefaultPassOption) -> &'static [ConditionalPass] {\n+crate fn defaults(default_set: DefaultPassOption) -> &'static [ConditionalPass] {\n     match default_set {\n         DefaultPassOption::Default => DEFAULT_PASSES,\n         DefaultPassOption::Coverage => COVERAGE_PASSES,\n@@ -149,7 +149,7 @@ pub fn defaults(default_set: DefaultPassOption) -> &'static [ConditionalPass] {\n }\n \n /// If the given name matches a known pass, returns its information.\n-pub fn find_pass(pass_name: &str) -> Option<Pass> {\n+crate fn find_pass(pass_name: &str) -> Option<Pass> {\n     PASSES.iter().find(|p| p.name == pass_name).copied()\n }\n "}, {"sha": "c9c49968b93e1be6b1918147cb33d586ff7c6294", "filename": "src/librustdoc/passes/non_autolinks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -9,7 +9,7 @@ use regex::Regex;\n use rustc_errors::Applicability;\n use rustc_session::lint;\n \n-pub const CHECK_NON_AUTOLINKS: Pass = Pass {\n+crate const CHECK_NON_AUTOLINKS: Pass = Pass {\n     name: \"check-non-autolinks\",\n     run: check_non_autolinks,\n     description: \"detects URLS that could be written using angle brackets\",\n@@ -52,7 +52,7 @@ impl<'a, 'tcx> NonAutolinksLinter<'a, 'tcx> {\n     }\n }\n \n-pub fn check_non_autolinks(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_non_autolinks(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {"}, {"sha": "fbfc693c5347de06801e391469df798a1fee6f87", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -6,13 +6,13 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::Pass;\n \n-pub const PROPAGATE_DOC_CFG: Pass = Pass {\n+crate const PROPAGATE_DOC_CFG: Pass = Pass {\n     name: \"propagate-doc-cfg\",\n     run: propagate_doc_cfg,\n     description: \"propagates `#[doc(cfg(...))]` to child items\",\n };\n \n-pub fn propagate_doc_cfg(cr: Crate, _: &DocContext<'_>) -> Crate {\n+crate fn propagate_doc_cfg(cr: Crate, _: &DocContext<'_>) -> Crate {\n     CfgPropagator { parent_cfg: None }.fold_crate(cr)\n }\n "}, {"sha": "6da753ea6e695b91c5bd7271a752c2e34513ff22", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -8,14 +8,14 @@ use crate::core::DocContext;\n use crate::fold::{DocFolder, StripItem};\n use crate::passes::{ImplStripper, Pass};\n \n-pub const STRIP_HIDDEN: Pass = Pass {\n+crate const STRIP_HIDDEN: Pass = Pass {\n     name: \"strip-hidden\",\n     run: strip_hidden,\n     description: \"strips all doc(hidden) items from the output\",\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_hidden(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items"}, {"sha": "6eeaabacbc138fe9212d04e4d628fed4fd74635b", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -3,12 +3,12 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImportStripper, Pass};\n \n-pub const STRIP_PRIV_IMPORTS: Pass = Pass {\n+crate const STRIP_PRIV_IMPORTS: Pass = Pass {\n     name: \"strip-priv-imports\",\n     run: strip_priv_imports,\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "e812bcd87fe3c8c838a764c4e7b1a346ba9e58b9", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -5,7 +5,7 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImplStripper, ImportStripper, Pass, Stripper};\n \n-pub const STRIP_PRIVATE: Pass = Pass {\n+crate const STRIP_PRIVATE: Pass = Pass {\n     name: \"strip-private\",\n     run: strip_private,\n     description: \"strips all private items from a crate which cannot be seen externally, \\\n@@ -14,7 +14,7 @@ pub const STRIP_PRIVATE: Pass = Pass {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet::default();\n     let access_levels = cx.renderinfo.borrow().access_levels.clone();"}, {"sha": "3a10142adcfcd943bae0a6e42323935026da3023", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -5,10 +5,10 @@ use std::mem;\n use crate::clean::{self, GetDefId, Item};\n use crate::fold::{DocFolder, StripItem};\n \n-pub struct Stripper<'a> {\n-    pub retained: &'a mut DefIdSet,\n-    pub access_levels: &'a AccessLevels<DefId>,\n-    pub update_retained: bool,\n+crate struct Stripper<'a> {\n+    crate retained: &'a mut DefIdSet,\n+    crate access_levels: &'a AccessLevels<DefId>,\n+    crate update_retained: bool,\n }\n \n impl<'a> DocFolder for Stripper<'a> {\n@@ -117,8 +117,8 @@ impl<'a> DocFolder for Stripper<'a> {\n }\n \n /// This stripper discards all impls which reference stripped items\n-pub struct ImplStripper<'a> {\n-    pub retained: &'a DefIdSet,\n+crate struct ImplStripper<'a> {\n+    crate retained: &'a DefIdSet,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {\n@@ -158,7 +158,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n }\n \n /// This stripper discards all private import statements (`use`, `extern crate`)\n-pub struct ImportStripper;\n+crate struct ImportStripper;\n \n impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {"}, {"sha": "eb2f066bbdebb1afb64a2e4d34863275e520e5cb", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -8,13 +8,13 @@ use crate::passes::Pass;\n #[cfg(test)]\n mod tests;\n \n-pub const UNINDENT_COMMENTS: Pass = Pass {\n+crate const UNINDENT_COMMENTS: Pass = Pass {\n     name: \"unindent-comments\",\n     run: unindent_comments,\n     description: \"removes excess indentation on comments in order for markdown to like it\",\n };\n \n-pub fn unindent_comments(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn unindent_comments(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     CommentCleaner.fold_crate(krate)\n }\n \n@@ -28,7 +28,7 @@ impl fold::DocFolder for CommentCleaner {\n }\n \n impl clean::Attributes {\n-    pub fn unindent_doc_comments(&mut self) {\n+    crate fn unindent_doc_comments(&mut self) {\n         unindent_fragments(&mut self.doc_strings);\n     }\n }"}, {"sha": "3bcf64f91c9a695c384d1bd5310ffd4c697f2e08", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -9,9 +9,9 @@ use rustc_errors::Handler;\n mod tests;\n \n #[derive(Debug, Clone, Eq)]\n-pub struct CssPath {\n-    pub name: String,\n-    pub children: FxHashSet<CssPath>,\n+crate struct CssPath {\n+    crate name: String,\n+    crate children: FxHashSet<CssPath>,\n }\n \n // This PartialEq implementation IS NOT COMMUTATIVE!!!\n@@ -212,7 +212,7 @@ fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> FxHashSet<CssPath> {\n     paths.iter().cloned().collect()\n }\n \n-pub fn load_css_paths(v: &[u8]) -> CssPath {\n+crate fn load_css_paths(v: &[u8]) -> CssPath {\n     let events = load_css_events(v);\n     let mut pos = 0;\n \n@@ -221,7 +221,7 @@ pub fn load_css_paths(v: &[u8]) -> CssPath {\n     parent\n }\n \n-pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n+crate fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n     if against.name == other.name {\n         for child in &against.children {\n             let mut found = false;\n@@ -248,7 +248,7 @@ pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>)\n     }\n }\n \n-pub fn test_theme_against<P: AsRef<Path>>(\n+crate fn test_theme_against<P: AsRef<Path>>(\n     f: &P,\n     against: &CssPath,\n     diag: &Handler,"}, {"sha": "509cc47caf86da8a19453701d75f722a1f2298f0", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -34,7 +34,7 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<String> {\n // Also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?.\n \n-pub struct RustdocVisitor<'a, 'tcx> {\n+crate struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n@@ -44,7 +44,7 @@ pub struct RustdocVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n+    crate fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n         stack.insert(hir::CRATE_HIR_ID);\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.exact_paths.entry(did).or_insert_with(|| def_id_to_path(tcx, did));\n     }\n \n-    pub fn visit(mut self, krate: &'tcx hir::Crate<'_>) -> Module<'tcx> {\n+    crate fn visit(mut self, krate: &'tcx hir::Crate<'_>) -> Module<'tcx> {\n         let mut module = self.visit_mod_contents(\n             krate.item.span,\n             krate.item.attrs,\n@@ -251,7 +251,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om\n     }\n \n-    /// Tries to resolve the target of a `pub use` statement and inlines the\n+    /// Tries to resolve the target of a `crate use` statement and inlines the\n     /// target if it is defined locally and would not be documented otherwise,\n     /// or when it is specifically requested with `please_inline`.\n     /// (the latter is the case when the import is marked `doc(inline)`)"}, {"sha": "0bf22562eaedee649bcef1ae732038e4c714098a", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -11,7 +11,7 @@ use crate::clean::{AttributesExt, NestedAttributesExt};\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n-pub struct LibEmbargoVisitor<'a, 'tcx> {\n+crate struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     // Accessibility levels for reachable nodes\n     access_levels: &'a mut AccessLevels<DefId>,\n@@ -22,7 +22,7 @@ pub struct LibEmbargoVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n+    crate fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n             tcx: cx.tcx,\n             access_levels: &mut cx.renderinfo.get_mut().access_levels,\n@@ -31,7 +31,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn visit_lib(&mut self, cnum: CrateNum) {\n+    crate fn visit_lib(&mut self, cnum: CrateNum) {\n         let did = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n         self.update(did, Some(AccessLevel::Public));\n         self.visit_mod(did);\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn visit_mod(&mut self, def_id: DefId) {\n+    crate fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n             return;\n         }"}, {"sha": "13407b2c791fe2a16ea6cd8188373e9470e7a03e", "filename": "src/test/rustdoc/doc-cfg-traits.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Frustdoc%2Fdoc-cfg-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Frustdoc%2Fdoc-cfg-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg-traits.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -0,0 +1,124 @@\n+#![crate_name = \"myrmecophagous\"]\n+#![feature(doc_cfg, associated_type_defaults)]\n+\n+// @has 'myrmecophagous/index.html'\n+// @count   - '//*[@class=\"stab portability\"]' 2\n+// @matches - '//*[@class=\"stab portability\"]' '^jurisconsult$'\n+// @matches - '//*[@class=\"stab portability\"]' '^quarter$'\n+\n+pub trait Lea {}\n+\n+// @has 'myrmecophagous/trait.Vortoscope.html'\n+// @count   - '//*[@class=\"stab portability\"]' 6\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature zibib'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature poriform'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature ethopoeia'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature lea'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature unit'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature quarter'\n+pub trait Vortoscope {\n+    type Batology = ();\n+\n+    #[doc(cfg(feature = \"zibib\"))]\n+    type Zibib = ();\n+\n+    const YAHRZEIT: () = ();\n+\n+    #[doc(cfg(feature = \"poriform\"))]\n+    const PORIFORM: () = ();\n+\n+    fn javanais() {}\n+\n+    #[doc(cfg(feature = \"ethopoeia\"))]\n+    fn ethopoeia() {}\n+}\n+\n+#[doc(cfg(feature = \"lea\"))]\n+impl<T: Lea> Vortoscope for T {}\n+\n+#[doc(cfg(feature = \"unit\"))]\n+impl Vortoscope for () {}\n+\n+// @has 'myrmecophagous/trait.Jurisconsult.html'\n+// @count   - '//*[@class=\"stab portability\"]' 7\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature jurisconsult'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature lithomancy'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature boodle'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature mistetch'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature lea'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature unit'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature quarter'\n+#[doc(cfg(feature = \"jurisconsult\"))]\n+pub trait Jurisconsult {\n+    type Urbanist = ();\n+\n+    #[doc(cfg(feature = \"lithomancy\"))]\n+    type Lithomancy = ();\n+\n+    const UNIFILAR: () = ();\n+\n+    #[doc(cfg(feature = \"boodle\"))]\n+    const BOODLE: () = ();\n+\n+    fn mersion() {}\n+\n+    #[doc(cfg(feature = \"mistetch\"))]\n+    fn mistetch() {}\n+}\n+\n+#[doc(cfg(feature = \"lea\"))]\n+impl<T: Lea> Jurisconsult for T {}\n+\n+#[doc(cfg(feature = \"unit\"))]\n+impl Jurisconsult for () {}\n+\n+// @has 'myrmecophagous/struct.Ultimogeniture.html'\n+// @count   - '//*[@class=\"stab portability\"]' 8\n+//\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature zibib'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature poriform'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature ethopoeia'\n+//\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature jurisconsult'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature lithomancy'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature boodle'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature mistetch'\n+//\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature copy'\n+#[derive(Clone)]\n+pub struct Ultimogeniture;\n+\n+impl Vortoscope for Ultimogeniture {}\n+\n+#[doc(cfg(feature = \"jurisconsult\"))]\n+impl Jurisconsult for Ultimogeniture {}\n+\n+#[doc(cfg(feature = \"copy\"))]\n+impl Copy for Ultimogeniture {}\n+\n+// @has 'myrmecophagous/struct.Quarter.html'\n+// @count   - '//*[@class=\"stab portability\"]' 9\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature quarter'\n+//\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature zibib'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature poriform'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature ethopoeia'\n+//\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature jurisconsult'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature lithomancy'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature boodle'\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature mistetch'\n+//\n+// @matches - '//*[@class=\"stab portability\"]' 'crate feature copy'\n+#[doc(cfg(feature = \"quarter\"))]\n+#[derive(Clone)]\n+pub struct Quarter;\n+\n+#[doc(cfg(feature = \"quarter\"))]\n+impl Vortoscope for Quarter {}\n+\n+#[doc(cfg(all(feature = \"jurisconsult\", feature = \"quarter\")))]\n+impl Jurisconsult for Quarter {}\n+\n+#[doc(cfg(all(feature = \"copy\", feature = \"quarter\")))]\n+impl Copy for Quarter {}"}, {"sha": "8440e47968e9aea21a91ae4a465600d6be346565", "filename": "src/test/ui/const-generics/const-param-shadowing.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-shadowing.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -0,0 +1,9 @@\n+#![feature(min_const_generics)]\n+\n+type N = u32;\n+struct Foo<const M: usize>;\n+fn test<const N: usize>() -> Foo<N> { //~ ERROR type provided when\n+    Foo\n+}\n+\n+fn main() {}"}, {"sha": "df17027802672b08aa2b8161800422315771f3ed", "filename": "src/test/ui/const-generics/const-param-shadowing.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-shadowing.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -0,0 +1,14 @@\n+error[E0747]: type provided when a constant was expected\n+  --> $DIR/const-param-shadowing.rs:5:34\n+   |\n+LL | fn test<const N: usize>() -> Foo<N> {\n+   |                                  ^\n+   |\n+help: if this generic argument was intended as a const parameter, try surrounding it with braces:\n+   |\n+LL | fn test<const N: usize>() -> Foo<{ N }> {\n+   |                                  ^   ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0747`."}, {"sha": "38ad510e5d7f0d4ca587a832c14f15b72de6e8d5", "filename": "src/test/ui/const-generics/invalid-constant-in-args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,3 +1,4 @@\n fn main() {\n-    let _: Vec<&str, \"a\"> = Vec::new(); //~ ERROR wrong number of const arguments\n+    let _: Vec<&str, \"a\"> = Vec::new();\n+    //~^ ERROR wrong number of generic arguments\n }"}, {"sha": "5111815e002f11b914a999833de143403199b2b9", "filename": "src/test/ui/const-generics/invalid-constant-in-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,4 +1,4 @@\n-error[E0107]: wrong number of const arguments: expected 0, found 1\n+error[E0107]: wrong number of generic arguments: expected 1, found 2\n   --> $DIR/invalid-constant-in-args.rs:2:22\n    |\n LL |     let _: Vec<&str, \"a\"> = Vec::new();"}, {"sha": "4ca10ed8b71a25d9c941b0c449fe76db9389bbcd", "filename": "src/test/ui/const-generics/invalid-enum.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-enum.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -20,20 +20,16 @@ impl<const CF: CompileFlag, T> Example<CF, T> {\n pub fn main() {\n   test_1::<CompileFlag::A>();\n   //~^ ERROR: expected type, found variant\n-  //~| ERROR: wrong number of const arguments\n-  //~| ERROR: wrong number of type arguments\n+  //~| ERROR: type provided when a constant was expected\n \n   test_2::<_, CompileFlag::A>(0);\n   //~^ ERROR: expected type, found variant\n-  //~| ERROR: wrong number of const arguments\n-  //~| ERROR: wrong number of type arguments\n+  //~| ERROR: type provided when a constant was expected\n \n   let _: Example<CompileFlag::A, _> = Example { x: 0 };\n   //~^ ERROR: expected type, found variant\n-  //~| ERROR: wrong number of const arguments\n-  //~| ERROR: wrong number of type arguments\n+  //~| ERROR: type provided when a constant was expected\n \n   let _: Example<Example::ASSOC_FLAG, _> = Example { x: 0 };\n-  //~^ ERROR: wrong number of const arguments\n-  //~| ERROR: wrong number of type arguments\n+  //~^ ERROR: type provided when a constant was expected\n }"}, {"sha": "7822fc072e35ce81f716bc428181162d35f9e610", "filename": "src/test/ui/const-generics/invalid-enum.stderr", "status": "modified", "additions": 20, "deletions": 44, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-enum.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -8,7 +8,7 @@ LL |   test_1::<CompileFlag::A>();\n    |            help: try using the variant's enum: `CompileFlag`\n \n error[E0573]: expected type, found variant `CompileFlag::A`\n-  --> $DIR/invalid-enum.rs:26:15\n+  --> $DIR/invalid-enum.rs:25:15\n    |\n LL |   test_2::<_, CompileFlag::A>(0);\n    |               ^^^^^^^^^^^^^^\n@@ -17,83 +17,59 @@ LL |   test_2::<_, CompileFlag::A>(0);\n    |               help: try using the variant's enum: `CompileFlag`\n \n error[E0573]: expected type, found variant `CompileFlag::A`\n-  --> $DIR/invalid-enum.rs:31:18\n+  --> $DIR/invalid-enum.rs:29:18\n    |\n LL |   let _: Example<CompileFlag::A, _> = Example { x: 0 };\n    |                  ^^^^^^^^^^^^^^\n    |                  |\n    |                  not a type\n    |                  help: try using the variant's enum: `CompileFlag`\n \n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/invalid-enum.rs:31:10\n+error[E0747]: type provided when a constant was expected\n+  --> $DIR/invalid-enum.rs:29:18\n    |\n LL |   let _: Example<CompileFlag::A, _> = Example { x: 0 };\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 const argument\n-\n-error[E0107]: wrong number of type arguments: expected at most 1, found 2\n-  --> $DIR/invalid-enum.rs:31:10\n-   |\n-LL |   let _: Example<CompileFlag::A, _> = Example { x: 0 };\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected at most 1 type argument\n+   |                  ^^^^^^^^^^^^^^\n    |\n-help: If this generic argument was intended as a const parameter, try surrounding it with braces:\n+help: if this generic argument was intended as a const parameter, try surrounding it with braces:\n    |\n LL |   let _: Example<{ CompileFlag::A }, _> = Example { x: 0 };\n    |                  ^                ^\n \n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/invalid-enum.rs:36:10\n+error[E0747]: type provided when a constant was expected\n+  --> $DIR/invalid-enum.rs:33:18\n    |\n LL |   let _: Example<Example::ASSOC_FLAG, _> = Example { x: 0 };\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 const argument\n-\n-error[E0107]: wrong number of type arguments: expected at most 1, found 2\n-  --> $DIR/invalid-enum.rs:36:10\n-   |\n-LL |   let _: Example<Example::ASSOC_FLAG, _> = Example { x: 0 };\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected at most 1 type argument\n+   |                  ^^^^^^^^^^^^^^^^^^^\n    |\n-help: If this generic argument was intended as a const parameter, try surrounding it with braces:\n+help: if this generic argument was intended as a const parameter, try surrounding it with braces:\n    |\n LL |   let _: Example<{ Example::ASSOC_FLAG }, _> = Example { x: 0 };\n    |                  ^                     ^\n \n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/invalid-enum.rs:21:3\n-   |\n-LL |   test_1::<CompileFlag::A>();\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 const argument\n-\n-error[E0107]: wrong number of type arguments: expected 0, found 1\n+error[E0747]: type provided when a constant was expected\n   --> $DIR/invalid-enum.rs:21:12\n    |\n LL |   test_1::<CompileFlag::A>();\n-   |            ^^^^^^^^^^^^^^ unexpected type argument\n+   |            ^^^^^^^^^^^^^^\n    |\n-help: If this generic argument was intended as a const parameter, try surrounding it with braces:\n+help: if this generic argument was intended as a const parameter, try surrounding it with braces:\n    |\n LL |   test_1::<{ CompileFlag::A }>();\n    |            ^                ^\n \n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/invalid-enum.rs:26:3\n+error[E0747]: type provided when a constant was expected\n+  --> $DIR/invalid-enum.rs:25:15\n    |\n LL |   test_2::<_, CompileFlag::A>(0);\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 const argument\n-\n-error[E0107]: wrong number of type arguments: expected 1, found 2\n-  --> $DIR/invalid-enum.rs:26:15\n-   |\n-LL |   test_2::<_, CompileFlag::A>(0);\n-   |               ^^^^^^^^^^^^^^ unexpected type argument\n+   |               ^^^^^^^^^^^^^^\n    |\n-help: If this generic argument was intended as a const parameter, try surrounding it with braces:\n+help: if this generic argument was intended as a const parameter, try surrounding it with braces:\n    |\n LL |   test_2::<_, { CompileFlag::A }>(0);\n    |               ^                ^\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0107, E0573.\n-For more information about an error, try `rustc --explain E0107`.\n+Some errors have detailed explanations: E0573, E0747.\n+For more information about an error, try `rustc --explain E0573`."}, {"sha": "fc70be404971e93af88389ce4dde577f1717f62b", "filename": "src/test/ui/const-generics/issues/issue-62878.full.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.full.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -4,25 +4,19 @@ error[E0770]: the type of const parameters must not depend on other generic para\n LL | fn foo<const N: usize, const A: [u8; N]>() {}\n    |                                      ^ the type must not depend on the parameter `N`\n \n-error[E0107]: wrong number of const arguments: expected 2, found 1\n-  --> $DIR/issue-62878.rs:11:5\n-   |\n-LL |     foo::<_, {[1]}>();\n-   |     ^^^^^^^^^^^^^^^ expected 2 const arguments\n-\n-error[E0107]: wrong number of type arguments: expected 0, found 1\n+error[E0747]: type provided when a constant was expected\n   --> $DIR/issue-62878.rs:11:11\n    |\n LL |     foo::<_, {[1]}>();\n-   |           ^ unexpected type argument\n+   |           ^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-62878.rs:11:15\n    |\n LL |     foo::<_, {[1]}>();\n    |               ^^^ expected `usize`, found array `[{integer}; 1]`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0107, E0308, E0770.\n-For more information about an error, try `rustc --explain E0107`.\n+Some errors have detailed explanations: E0308, E0747, E0770.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "c087711e5f9adff179f7df24bed53838ef347340", "filename": "src/test/ui/const-generics/issues/issue-62878.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -9,7 +9,6 @@ fn foo<const N: usize, const A: [u8; N]>() {}\n \n fn main() {\n     foo::<_, {[1]}>();\n-    //[full]~^ ERROR wrong number of const arguments\n-    //[full]~| ERROR wrong number of type arguments\n+    //[full]~^ ERROR type provided when a constant was expected\n     //[full]~| ERROR mismatched types\n }"}, {"sha": "04c019015179e08460e78158dc239b81f022449c", "filename": "src/test/ui/const-generics/issues/issue-76595.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -13,5 +13,5 @@ fn test<T, const P: usize>() where Bool<{core::mem::size_of::<T>() > 4}>: True {\n \n fn main() {\n     test::<2>();\n-    //~^ ERROR wrong number of type\n+    //~^ ERROR wrong number of generic arguments\n }"}, {"sha": "1e37f9dcb1925c82016fab0e7c48e1597e11a5ff", "filename": "src/test/ui/const-generics/issues/issue-76595.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,8 +1,8 @@\n-error[E0107]: wrong number of type arguments: expected 1, found 0\n+error[E0107]: wrong number of generic arguments: expected 2, found 1\n   --> $DIR/issue-76595.rs:15:5\n    |\n LL |     test::<2>();\n-   |     ^^^^^^^^^ expected 1 type argument\n+   |     ^^^^^^^^^ expected 2 generic arguments\n \n error: aborting due to previous error\n "}, {"sha": "b96d5c561ff515dc40e0414cd1a4e1b7d9758fd4", "filename": "src/test/ui/const-generics/min_const_generics/const-expression-suggest-missing-braces.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -13,8 +13,7 @@ fn b() {\n     foo::<BAR + BAR>();\n     //~^ ERROR expected trait, found constant `BAR`\n     //~| ERROR expected trait, found constant `BAR`\n-    //~| ERROR wrong number of const arguments: expected 1, found 0\n-    //~| ERROR wrong number of type arguments: expected 0, found 1\n+    //~| ERROR type provided when a constant was expected\n     //~| WARN trait objects without an explicit `dyn` are deprecated\n }\n fn c() {"}, {"sha": "6adcf6a3e36d804359b2334ad4f6ee81a0595852", "filename": "src/test/ui/const-generics/min_const_generics/const-expression-suggest-missing-braces.stderr", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -10,7 +10,7 @@ LL |     foo::<{ BAR + 3 }>();\n    |           ^         ^\n \n error: expressions must be enclosed in braces to be used as const generic arguments\n-  --> $DIR/const-expression-suggest-missing-braces.rs:21:11\n+  --> $DIR/const-expression-suggest-missing-braces.rs:20:11\n    |\n LL |     foo::<3 + 3>();\n    |           ^^^^^\n@@ -21,7 +21,7 @@ LL |     foo::<{ 3 + 3 }>();\n    |           ^       ^\n \n error: expected one of `,` or `>`, found `-`\n-  --> $DIR/const-expression-suggest-missing-braces.rs:24:15\n+  --> $DIR/const-expression-suggest-missing-braces.rs:23:15\n    |\n LL |     foo::<BAR - 3>();\n    |               ^ expected one of `,` or `>`\n@@ -32,7 +32,7 @@ LL |     foo::<{ BAR - 3 }>();\n    |           ^         ^\n \n error: expected one of `,` or `>`, found `-`\n-  --> $DIR/const-expression-suggest-missing-braces.rs:27:15\n+  --> $DIR/const-expression-suggest-missing-braces.rs:26:15\n    |\n LL |     foo::<BAR - BAR>();\n    |               ^ expected one of `,` or `>`\n@@ -43,7 +43,7 @@ LL |     foo::<{ BAR - BAR }>();\n    |           ^           ^\n \n error: expressions must be enclosed in braces to be used as const generic arguments\n-  --> $DIR/const-expression-suggest-missing-braces.rs:30:11\n+  --> $DIR/const-expression-suggest-missing-braces.rs:29:11\n    |\n LL |     foo::<100 - BAR>();\n    |           ^^^^^^^^^\n@@ -54,7 +54,7 @@ LL |     foo::<{ 100 - BAR }>();\n    |           ^           ^\n \n error: expected one of `,` or `>`, found `(`\n-  --> $DIR/const-expression-suggest-missing-braces.rs:33:19\n+  --> $DIR/const-expression-suggest-missing-braces.rs:32:19\n    |\n LL |     foo::<bar<i32>()>();\n    |                   ^ expected one of `,` or `>`\n@@ -65,7 +65,7 @@ LL |     foo::<{ bar<i32>() }>();\n    |           ^            ^\n \n error: expected one of `,` or `>`, found `(`\n-  --> $DIR/const-expression-suggest-missing-braces.rs:36:21\n+  --> $DIR/const-expression-suggest-missing-braces.rs:35:21\n    |\n LL |     foo::<bar::<i32>()>();\n    |                     ^ expected one of `,` or `>`\n@@ -76,7 +76,7 @@ LL |     foo::<{ bar::<i32>() }>();\n    |           ^              ^\n \n error: expected one of `,` or `>`, found `(`\n-  --> $DIR/const-expression-suggest-missing-braces.rs:39:21\n+  --> $DIR/const-expression-suggest-missing-braces.rs:38:21\n    |\n LL |     foo::<bar::<i32>() + BAR>();\n    |                     ^ expected one of `,` or `>`\n@@ -87,7 +87,7 @@ LL |     foo::<{ bar::<i32>() + BAR }>();\n    |           ^                    ^\n \n error: expected one of `,` or `>`, found `(`\n-  --> $DIR/const-expression-suggest-missing-braces.rs:42:21\n+  --> $DIR/const-expression-suggest-missing-braces.rs:41:21\n    |\n LL |     foo::<bar::<i32>() - BAR>();\n    |                     ^ expected one of `,` or `>`\n@@ -98,7 +98,7 @@ LL |     foo::<{ bar::<i32>() - BAR }>();\n    |           ^                    ^\n \n error: expected one of `,` or `>`, found `-`\n-  --> $DIR/const-expression-suggest-missing-braces.rs:45:15\n+  --> $DIR/const-expression-suggest-missing-braces.rs:44:15\n    |\n LL |     foo::<BAR - bar::<i32>()>();\n    |               ^ expected one of `,` or `>`\n@@ -109,7 +109,7 @@ LL |     foo::<{ BAR - bar::<i32>() }>();\n    |           ^                    ^\n \n error: expected one of `,` or `>`, found `-`\n-  --> $DIR/const-expression-suggest-missing-braces.rs:48:15\n+  --> $DIR/const-expression-suggest-missing-braces.rs:47:15\n    |\n LL |     foo::<BAR - bar::<i32>()>();\n    |               ^ expected one of `,` or `>`\n@@ -139,19 +139,13 @@ LL |     foo::<BAR + BAR>();\n    |\n    = note: `#[warn(bare_trait_objects)]` on by default\n \n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/const-expression-suggest-missing-braces.rs:13:5\n-   |\n-LL |     foo::<BAR + BAR>();\n-   |     ^^^^^^^^^^^^^^^^ expected 1 const argument\n-\n-error[E0107]: wrong number of type arguments: expected 0, found 1\n+error[E0747]: type provided when a constant was expected\n   --> $DIR/const-expression-suggest-missing-braces.rs:13:11\n    |\n LL |     foo::<BAR + BAR>();\n-   |           ^^^^^^^^^ unexpected type argument\n+   |           ^^^^^^^^^\n \n-error: aborting due to 15 previous errors; 1 warning emitted\n+error: aborting due to 14 previous errors; 1 warning emitted\n \n-Some errors have detailed explanations: E0107, E0404.\n-For more information about an error, try `rustc --explain E0107`.\n+Some errors have detailed explanations: E0404, E0747.\n+For more information about an error, try `rustc --explain E0404`."}, {"sha": "1bd0c46f55e2ddf5e9835d33d66017ccac357ecb", "filename": "src/test/ui/const-generics/min_const_generics/macro-fail.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -14,11 +14,9 @@ trait Marker<const N: usize> {}\n impl<const N: usize> Marker<N> for Example<N> {}\n \n fn make_marker() -> impl Marker<gimme_a_const!(marker)> {\n-  //~^ ERROR wrong number of const\n-  //~| ERROR wrong number of type\n+  //~^ ERROR: type provided when a constant was expected\n   Example::<gimme_a_const!(marker)>\n-  //~^ ERROR wrong number of const\n-  //~| ERROR wrong number of type\n+  //~^ ERROR: type provided when a constant was expected\n }\n \n fn from_marker(_: impl Marker<{\n@@ -38,11 +36,9 @@ fn main() {\n   }>;\n \n   let _fail = Example::<external_macro!()>;\n-  //~^ ERROR wrong number of const\n-  //~| ERROR wrong number of type\n+  //~^ ERROR: type provided when a constant was expected\n \n   let _fail = Example::<gimme_a_const!()>;\n-  //~^ ERROR wrong number of const\n-  //~| ERROR wrong number of type\n+  //~^ ERROR: type provided when a constant was expected\n   //~| ERROR unexpected end of macro invocation\n }"}, {"sha": "a5dedf6fe2053ef2b7d8474091bda36860b4dd92", "filename": "src/test/ui/const-generics/min_const_generics/macro-fail.stderr", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fmacro-fail.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,5 +1,5 @@\n error: expected type, found `{`\n-  --> $DIR/macro-fail.rs:33:27\n+  --> $DIR/macro-fail.rs:31:27\n    |\n LL | fn make_marker() -> impl Marker<gimme_a_const!(marker)> {\n    |                                 ----------------------\n@@ -13,7 +13,7 @@ LL |       ($rusty: ident) => {{ let $rusty = 3; *&$rusty }}\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected type, found `{`\n-  --> $DIR/macro-fail.rs:33:27\n+  --> $DIR/macro-fail.rs:31:27\n    |\n LL |   Example::<gimme_a_const!(marker)>\n    |             ----------------------\n@@ -46,62 +46,38 @@ LL |     let _fail = Example::<external_macro!()>;\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unexpected end of macro invocation\n-  --> $DIR/macro-fail.rs:44:25\n+  --> $DIR/macro-fail.rs:41:25\n    |\n LL |     macro_rules! gimme_a_const {\n    |     -------------------------- when calling this macro\n ...\n LL |   let _fail = Example::<gimme_a_const!()>;\n    |                         ^^^^^^^^^^^^^^^^ missing tokens in macro arguments\n \n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/macro-fail.rs:16:26\n-   |\n-LL | fn make_marker() -> impl Marker<gimme_a_const!(marker)> {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 const argument\n-\n-error[E0107]: wrong number of type arguments: expected 0, found 1\n+error[E0747]: type provided when a constant was expected\n   --> $DIR/macro-fail.rs:16:33\n    |\n LL | fn make_marker() -> impl Marker<gimme_a_const!(marker)> {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^ unexpected type argument\n-\n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/macro-fail.rs:19:3\n-   |\n-LL |   Example::<gimme_a_const!(marker)>\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 const argument\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/macro-fail.rs:19:13\n+error[E0747]: type provided when a constant was expected\n+  --> $DIR/macro-fail.rs:18:13\n    |\n LL |   Example::<gimme_a_const!(marker)>\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ unexpected type argument\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/macro-fail.rs:40:15\n+error[E0747]: type provided when a constant was expected\n+  --> $DIR/macro-fail.rs:38:25\n    |\n LL |   let _fail = Example::<external_macro!()>;\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 const argument\n-\n-error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/macro-fail.rs:40:25\n-   |\n-LL |   let _fail = Example::<external_macro!()>;\n-   |                         ^^^^^^^^^^^^^^^^^ unexpected type argument\n-\n-error[E0107]: wrong number of const arguments: expected 1, found 0\n-  --> $DIR/macro-fail.rs:44:15\n-   |\n-LL |   let _fail = Example::<gimme_a_const!()>;\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 const argument\n+   |                         ^^^^^^^^^^^^^^^^^\n \n-error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/macro-fail.rs:44:25\n+error[E0747]: type provided when a constant was expected\n+  --> $DIR/macro-fail.rs:41:25\n    |\n LL |   let _fail = Example::<gimme_a_const!()>;\n-   |                         ^^^^^^^^^^^^^^^^ unexpected type argument\n+   |                         ^^^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 8 previous errors\n \n-For more information about this error, try `rustc --explain E0107`.\n+For more information about this error, try `rustc --explain E0747`."}, {"sha": "380e9209e6c608126f19122e1c20f24beb39c94f", "filename": "src/test/ui/generics/generic-impl-more-params-with-defaults.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-impl-more-params-with-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-impl-more-params-with-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-impl-more-params-with-defaults.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,8 +1,8 @@\n error[E0107]: wrong number of type arguments: expected at most 2, found 3\n-  --> $DIR/generic-impl-more-params-with-defaults.rs:13:5\n+  --> $DIR/generic-impl-more-params-with-defaults.rs:13:24\n    |\n LL |     Vec::<isize, Heap, bool>::new();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected at most 2 type arguments\n+   |                        ^^^^ unexpected type argument\n \n error: aborting due to previous error\n "}, {"sha": "cc296b5105a4027aef02dd21fc54d136b06d667e", "filename": "src/test/ui/generics/generic-type-more-params-with-defaults.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-type-more-params-with-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-type-more-params-with-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-type-more-params-with-defaults.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,8 +1,8 @@\n error[E0107]: wrong number of type arguments: expected at most 2, found 3\n-  --> $DIR/generic-type-more-params-with-defaults.rs:9:12\n+  --> $DIR/generic-type-more-params-with-defaults.rs:9:29\n    |\n LL |     let _: Vec<isize, Heap, bool>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ expected at most 2 type arguments\n+   |                             ^^^^ unexpected type argument\n \n error: aborting due to previous error\n "}, {"sha": "96b35e45535a6a4851aa1f032711262f4337fb60", "filename": "src/test/ui/panic-while-printing.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fpanic-while-printing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fpanic-while-printing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-while-printing.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,11 +1,12 @@\n // run-pass\n // ignore-emscripten no subprocess support\n \n-#![feature(set_stdio)]\n+#![feature(internal_output_capture)]\n \n use std::fmt;\n use std::fmt::{Display, Formatter};\n-use std::io::{self, set_panic, LocalOutput, Write};\n+use std::io::set_output_capture;\n+use std::sync::{Arc, Mutex};\n \n pub struct A;\n \n@@ -15,23 +16,8 @@ impl Display for A {\n     }\n }\n \n-struct Sink;\n-impl Write for Sink {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        Ok(buf.len())\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-impl LocalOutput for Sink {\n-    fn clone_box(&self) -> Box<dyn LocalOutput> {\n-        Box::new(Sink)\n-    }\n-}\n-\n fn main() {\n-    set_panic(Some(Box::new(Sink)));\n+    set_output_capture(Some(Arc::new(Mutex::new(Vec::new()))));\n     assert!(std::panic::catch_unwind(|| {\n         eprintln!(\"{}\", A);\n     })"}, {"sha": "cdda0d001c7dc575c7fb5f49c8aa86f4edebfad6", "filename": "src/test/ui/parser/issue-14303-fncall.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -3,8 +3,6 @@ error[E0747]: type provided when a lifetime was expected\n    |\n LL |         .collect::<Vec<S<_, 'a>>>();\n    |                          ^\n-   |\n-   = note: lifetime arguments must be provided before type arguments\n \n error: aborting due to previous error\n "}, {"sha": "841e63ecbe9d5128c40f5d27ebed08470bc57375", "filename": "src/test/ui/parser/issue-14303-path.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -3,8 +3,6 @@ error[E0747]: type provided when a lifetime was expected\n    |\n LL | fn bar<'a, 'b, 'c, T>(x: foo::X<'a, T, 'b, 'c>) {}\n    |                                     ^\n-   |\n-   = note: lifetime arguments must be provided before type arguments\n \n error: aborting due to previous error\n "}, {"sha": "1af5b857e9df6f1b438ec1d552ad7e6f4c08720a", "filename": "src/test/ui/privacy/privacy-ns1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -32,8 +32,8 @@ pub mod foo2 {\n fn test_glob2() {\n     use foo2::*;\n \n-    let _x: Box<Bar>;  //~ ERROR wrong number of const arguments: expected 0, found 1\n-    //~^ ERROR wrong number of type arguments: expected at least 1, found 0\n+    let _x: Box<Bar>;\n+    //~^ ERROR constant provided when a type was expected\n }\n \n // neither public"}, {"sha": "714f28941f11ff49f188e2bd954079a09fed1a03", "filename": "src/test/ui/privacy/privacy-ns1.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -52,19 +52,13 @@ help: consider importing this trait\n LL | use foo1::Bar;\n    |\n \n-error[E0107]: wrong number of const arguments: expected 0, found 1\n+error[E0747]: constant provided when a type was expected\n   --> $DIR/privacy-ns1.rs:35:17\n    |\n LL |     let _x: Box<Bar>;\n-   |                 ^^^ unexpected const argument\n-\n-error[E0107]: wrong number of type arguments: expected at least 1, found 0\n-  --> $DIR/privacy-ns1.rs:35:13\n-   |\n-LL |     let _x: Box<Bar>;\n-   |             ^^^^^^^^ expected at least 1 type argument\n+   |                 ^^^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0107, E0412, E0423, E0425.\n-For more information about an error, try `rustc --explain E0107`.\n+Some errors have detailed explanations: E0412, E0423, E0425, E0747.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "47035ef3af5a2a537e42dd4b8e0ed4d64b310bbc", "filename": "src/test/ui/privacy/privacy-ns2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -38,16 +38,14 @@ pub mod foo2 {\n fn test_single2() {\n     use foo2::Bar;\n \n-    let _x : Box<Bar>; //~ ERROR wrong number of const arguments: expected 0, found 1\n-    //~^ ERROR wrong number of type arguments: expected at least 1, found 0\n+    let _x : Box<Bar>; //~ ERROR constant provided when a type was expected\n     let _x : Bar(); //~ ERROR expected type, found function `Bar`\n }\n \n fn test_list2() {\n     use foo2::{Bar,Baz};\n \n-    let _x: Box<Bar>; //~ ERROR wrong number of const arguments: expected 0, found 1\n-    //~^ ERROR wrong number of type arguments: expected at least 1, found 0\n+    let _x: Box<Bar>; //~ ERROR constant provided when a type was expected\n }\n \n // neither public"}, {"sha": "c7ad8ec503654c7e0b378840200705977fffeaf4", "filename": "src/test/ui/privacy/privacy-ns2.stderr", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -28,7 +28,7 @@ LL | use foo2::Bar;\n    |\n \n error[E0573]: expected type, found function `Bar`\n-  --> $DIR/privacy-ns2.rs:43:14\n+  --> $DIR/privacy-ns2.rs:42:14\n    |\n LL |     let _x : Bar();\n    |              ^^^^^ not a type\n@@ -43,66 +43,54 @@ LL | use foo1::Bar;\n    |\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:63:15\n+  --> $DIR/privacy-ns2.rs:61:15\n    |\n LL |     use foo3::Bar;\n    |               ^^^ private trait\n    |\n note: the trait `Bar` is defined here\n-  --> $DIR/privacy-ns2.rs:55:5\n+  --> $DIR/privacy-ns2.rs:53:5\n    |\n LL |     trait Bar {\n    |     ^^^^^^^^^\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:67:15\n+  --> $DIR/privacy-ns2.rs:65:15\n    |\n LL |     use foo3::Bar;\n    |               ^^^ private trait\n    |\n note: the trait `Bar` is defined here\n-  --> $DIR/privacy-ns2.rs:55:5\n+  --> $DIR/privacy-ns2.rs:53:5\n    |\n LL |     trait Bar {\n    |     ^^^^^^^^^\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:74:16\n+  --> $DIR/privacy-ns2.rs:72:16\n    |\n LL |     use foo3::{Bar,Baz};\n    |                ^^^ private trait\n    |\n note: the trait `Bar` is defined here\n-  --> $DIR/privacy-ns2.rs:55:5\n+  --> $DIR/privacy-ns2.rs:53:5\n    |\n LL |     trait Bar {\n    |     ^^^^^^^^^\n \n-error[E0107]: wrong number of const arguments: expected 0, found 1\n+error[E0747]: constant provided when a type was expected\n   --> $DIR/privacy-ns2.rs:41:18\n    |\n LL |     let _x : Box<Bar>;\n-   |                  ^^^ unexpected const argument\n+   |                  ^^^\n \n-error[E0107]: wrong number of type arguments: expected at least 1, found 0\n-  --> $DIR/privacy-ns2.rs:41:14\n-   |\n-LL |     let _x : Box<Bar>;\n-   |              ^^^^^^^^ expected at least 1 type argument\n-\n-error[E0107]: wrong number of const arguments: expected 0, found 1\n-  --> $DIR/privacy-ns2.rs:49:17\n-   |\n-LL |     let _x: Box<Bar>;\n-   |                 ^^^ unexpected const argument\n-\n-error[E0107]: wrong number of type arguments: expected at least 1, found 0\n-  --> $DIR/privacy-ns2.rs:49:13\n+error[E0747]: constant provided when a type was expected\n+  --> $DIR/privacy-ns2.rs:48:17\n    |\n LL |     let _x: Box<Bar>;\n-   |             ^^^^^^^^ expected at least 1 type argument\n+   |                 ^^^\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 8 previous errors\n \n-Some errors have detailed explanations: E0107, E0423, E0573, E0603.\n-For more information about an error, try `rustc --explain E0107`.\n+Some errors have detailed explanations: E0423, E0573, E0603, E0747.\n+For more information about an error, try `rustc --explain E0423`."}, {"sha": "df064f22f358450d0a52ccd36e089837060fc796", "filename": "src/test/ui/suggestions/suggest-move-types.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -107,16 +107,12 @@ error[E0747]: type provided when a lifetime was expected\n    |\n LL | struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n    |                                           ^\n-   |\n-   = note: lifetime arguments must be provided before type arguments\n \n error[E0747]: type provided when a lifetime was expected\n   --> $DIR/suggest-move-types.rs:48:71\n    |\n LL | struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n    |                                                                       ^\n-   |\n-   = note: lifetime arguments must be provided before type arguments\n \n error[E0747]: lifetime provided when a type was expected\n   --> $DIR/suggest-move-types.rs:65:56"}, {"sha": "78145e337dafbc5c91c82eaf15110f9b44388060", "filename": "src/test/ui/threads-sendsync/task-stderr.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fthreads-sendsync%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Fthreads-sendsync%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthreads-sendsync%2Ftask-stderr.rs?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -1,33 +1,21 @@\n // run-pass\n // ignore-emscripten no threads support\n \n-#![feature(box_syntax, set_stdio)]\n+#![feature(internal_output_capture)]\n \n-use std::io::prelude::*;\n use std::io;\n use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n-struct Sink(Arc<Mutex<Vec<u8>>>);\n-impl Write for Sink {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Write::write(&mut *self.0.lock().unwrap(), data)\n-    }\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-}\n-impl io::LocalOutput for Sink {\n-    fn clone_box(&self) -> Box<dyn io::LocalOutput> {\n-        Box::new(Sink(self.0.clone()))\n-    }\n-}\n-\n fn main() {\n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let sink = Sink(data.clone());\n-    let res = thread::Builder::new().spawn(move|| -> () {\n-        io::set_panic(Some(Box::new(sink)));\n-        panic!(\"Hello, world!\")\n+    let res = thread::Builder::new().spawn({\n+        let data = data.clone();\n+        move || {\n+            io::set_output_capture(Some(data));\n+            panic!(\"Hello, world!\")\n+        }\n     }).unwrap().join();\n     assert!(res.is_err());\n "}, {"sha": "8958547e82709085b480d7b350f26b50f3f61eba", "filename": "src/test/ui/traits/trait-object-vs-lifetime.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr?ref=c6a6105bccd5599daf0ecef40c4b5ffa175fc1c1", "patch": "@@ -27,8 +27,6 @@ error[E0747]: type provided when a lifetime was expected\n    |\n LL |     let _: S<dyn 'static +, 'static>;\n    |              ^^^^^^^^^^^^^\n-   |\n-   = note: lifetime arguments must be provided before type arguments\n \n error: aborting due to 5 previous errors\n "}]}