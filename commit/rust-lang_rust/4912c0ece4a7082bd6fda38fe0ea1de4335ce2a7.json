{"sha": "4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "node_id": "C_kwDOAAsO6NoAKDQ5MTJjMGVjZTRhNzA4MmJkNmZkYTM4ZmUwZWExZGU0MzM1Y2UyYTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-08T15:20:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-08T15:20:24Z"}, "message": "Auto merge of #9126 - Jarcho:auto_deref_sugg, r=Manishearth\n\n`explicit_auto_deref` changes\n\nfixes #9123\nfixes #9109\nfixes #9143\nfixes #9101\n\nThis avoid suggesting code which hits a rustc bug. Basically `&{x}` won't use auto-deref if the target type is `Sized`.\n\nchangelog: Don't suggest using auto deref for block expressions when the target type is `Sized`\nchangelog: Include the borrow in the suggestion for `explicit_auto_deref`\nchangelog: Don't lint `explicit_auto_deref` on `dyn Trait` return\nchangelog: Don't lint `explicit_auto_deref` when other adjustments are required\nchangelog: Lint `explicit_auto_deref` in implicit return positions for closures", "tree": {"sha": "02b6aa25592d003805f89864e72a35389fe83165", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02b6aa25592d003805f89864e72a35389fe83165"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "html_url": "https://github.com/rust-lang/rust/commit/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ee702514e482ee7901fba03d03dc9bd68809c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee702514e482ee7901fba03d03dc9bd68809c92", "html_url": "https://github.com/rust-lang/rust/commit/0ee702514e482ee7901fba03d03dc9bd68809c92"}, {"sha": "ecb51fe6a55f975f2d3bfd65d3568c263c248460", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecb51fe6a55f975f2d3bfd65d3568c263c248460", "html_url": "https://github.com/rust-lang/rust/commit/ecb51fe6a55f975f2d3bfd65d3568c263c248460"}], "stats": {"total": 634, "additions": 436, "deletions": 198}, "files": [{"sha": "5d41c63928dfb0daeb6cb3a2bb2eed9bd9e80af9", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 211, "deletions": 123, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n-use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, variant_of_res};\n+use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, ty_sig, variant_of_res};\n use clippy_utils::{get_parent_expr, is_lint_allowed, path_to_local, walk_to_expr_usage};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n@@ -15,9 +15,9 @@ use rustc_hir::{\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable, TypeckResults};\n+use rustc_middle::ty::{self, Binder, BoundVariableKind, List, Ty, TyCtxt, TypeVisitable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n declare_clippy_lint! {\n@@ -183,24 +183,24 @@ enum State {\n     },\n     DerefedBorrow(DerefedBorrow),\n     ExplicitDeref {\n-        // Span and id of the top-level deref expression if the parent expression is a borrow.\n-        deref_span_id: Option<(Span, HirId)>,\n+        mutability: Option<Mutability>,\n     },\n     ExplicitDerefField {\n         name: Symbol,\n     },\n     Reborrow {\n-        deref_span: Span,\n-        deref_hir_id: HirId,\n+        mutability: Mutability,\n+    },\n+    Borrow {\n+        mutability: Mutability,\n     },\n-    Borrow,\n }\n \n // A reference operation considered by this lint pass\n enum RefOp {\n     Method(Mutability),\n     Deref,\n-    AddrOf,\n+    AddrOf(Mutability),\n }\n \n struct RefPat {\n@@ -263,7 +263,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             ));\n                         } else if position.is_deref_stable() {\n                             self.state = Some((\n-                                State::ExplicitDeref { deref_span_id: None },\n+                                State::ExplicitDeref { mutability: None },\n                                 StateData { span: expr.span, hir_id: expr.hir_id, position },\n                             ));\n                         }\n@@ -289,7 +289,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             },\n                         ));\n                     },\n-                    RefOp::AddrOf => {\n+                    RefOp::AddrOf(mutability) => {\n                         // Find the number of times the borrow is auto-derefed.\n                         let mut iter = adjustments.iter();\n                         let mut deref_count = 0usize;\n@@ -357,9 +357,13 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                 }),\n                                 StateData { span: expr.span, hir_id: expr.hir_id, position },\n                             ));\n-                        } else if position.is_deref_stable() {\n+                        } else if position.is_deref_stable()\n+                            // Auto-deref doesn't combine with other adjustments\n+                            && next_adjust.map_or(true, |a| matches!(a.kind, Adjust::Deref(_) | Adjust::Borrow(_)))\n+                            && iter.all(|a| matches!(a.kind, Adjust::Deref(_) | Adjust::Borrow(_)))\n+                        {\n                             self.state = Some((\n-                                State::Borrow,\n+                                State::Borrow { mutability },\n                                 StateData {\n                                     span: expr.span,\n                                     hir_id: expr.hir_id,\n@@ -395,7 +399,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     data,\n                 ));\n             },\n-            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) if state.count != 0 => {\n+            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf(_)) if state.count != 0 => {\n                 self.state = Some((\n                     State::DerefedBorrow(DerefedBorrow {\n                         count: state.count - 1,\n@@ -404,12 +408,12 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     data,\n                 ));\n             },\n-            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) => {\n+            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf(mutability)) => {\n                 let position = data.position;\n                 report(cx, expr, State::DerefedBorrow(state), data);\n                 if position.is_deref_stable() {\n                     self.state = Some((\n-                        State::Borrow,\n+                        State::Borrow { mutability },\n                         StateData {\n                             span: expr.span,\n                             hir_id: expr.hir_id,\n@@ -430,43 +434,28 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     ));\n                 } else if position.is_deref_stable() {\n                     self.state = Some((\n-                        State::ExplicitDeref { deref_span_id: None },\n+                        State::ExplicitDeref { mutability: None },\n                         StateData { span: expr.span, hir_id: expr.hir_id, position },\n                     ));\n                 }\n             },\n \n-            (Some((State::Borrow, data)), RefOp::Deref) => {\n+            (Some((State::Borrow { mutability }, data)), RefOp::Deref) => {\n                 if typeck.expr_ty(sub_expr).is_ref() {\n-                    self.state = Some((\n-                        State::Reborrow {\n-                            deref_span: expr.span,\n-                            deref_hir_id: expr.hir_id,\n-                        },\n-                        data,\n-                    ));\n+                    self.state = Some((State::Reborrow { mutability }, data));\n                 } else {\n                     self.state = Some((\n                         State::ExplicitDeref {\n-                            deref_span_id: Some((expr.span, expr.hir_id)),\n+                            mutability: Some(mutability),\n                         },\n                         data,\n                     ));\n                 }\n             },\n-            (\n-                Some((\n-                    State::Reborrow {\n-                        deref_span,\n-                        deref_hir_id,\n-                    },\n-                    data,\n-                )),\n-                RefOp::Deref,\n-            ) => {\n+            (Some((State::Reborrow { mutability }, data)), RefOp::Deref) => {\n                 self.state = Some((\n                     State::ExplicitDeref {\n-                        deref_span_id: Some((deref_span, deref_hir_id)),\n+                        mutability: Some(mutability),\n                     },\n                     data,\n                 ));\n@@ -573,7 +562,7 @@ fn try_parse_ref_op<'tcx>(\n         ExprKind::Unary(UnOp::Deref, sub_expr) if !typeck.expr_ty(sub_expr).is_unsafe_ptr() => {\n             return Some((RefOp::Deref, sub_expr));\n         },\n-        ExprKind::AddrOf(BorrowKind::Ref, _, sub_expr) => return Some((RefOp::AddrOf, sub_expr)),\n+        ExprKind::AddrOf(BorrowKind::Ref, mutability, sub_expr) => return Some((RefOp::AddrOf(mutability), sub_expr)),\n         _ => return None,\n     };\n     if tcx.is_diagnostic_item(sym::deref_method, def_id) {\n@@ -609,26 +598,29 @@ enum Position {\n     Postfix,\n     Deref,\n     /// Any other location which will trigger auto-deref to a specific time.\n-    DerefStable(i8),\n+    /// Contains the precedence of the parent expression and whether the target type is sized.\n+    DerefStable(i8, bool),\n     /// Any other location which will trigger auto-reborrowing.\n+    /// Contains the precedence of the parent expression.\n     ReborrowStable(i8),\n+    /// Contains the precedence of the parent expression.\n     Other(i8),\n }\n impl Position {\n     fn is_deref_stable(self) -> bool {\n-        matches!(self, Self::DerefStable(_))\n+        matches!(self, Self::DerefStable(..))\n     }\n \n     fn is_reborrow_stable(self) -> bool {\n-        matches!(self, Self::DerefStable(_) | Self::ReborrowStable(_))\n+        matches!(self, Self::DerefStable(..) | Self::ReborrowStable(_))\n     }\n \n     fn can_auto_borrow(self) -> bool {\n         matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n     }\n \n     fn lint_explicit_deref(self) -> bool {\n-        matches!(self, Self::Other(_) | Self::DerefStable(_) | Self::ReborrowStable(_))\n+        matches!(self, Self::Other(_) | Self::DerefStable(..) | Self::ReborrowStable(_))\n     }\n \n     fn precedence(self) -> i8 {\n@@ -639,7 +631,7 @@ impl Position {\n             | Self::FieldAccess(_)\n             | Self::Postfix => PREC_POSTFIX,\n             Self::Deref => PREC_PREFIX,\n-            Self::DerefStable(p) | Self::ReborrowStable(p) | Self::Other(p) => p,\n+            Self::DerefStable(p, _) | Self::ReborrowStable(p) | Self::Other(p) => p,\n         }\n     }\n }\n@@ -659,7 +651,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n         }\n         match parent {\n             Node::Local(Local { ty: Some(ty), span, .. }) if span.ctxt() == ctxt => {\n-                Some(binding_ty_auto_deref_stability(ty, precedence))\n+                Some(binding_ty_auto_deref_stability(cx, ty, precedence, List::empty()))\n             },\n             Node::Item(&Item {\n                 kind: ItemKind::Static(..) | ItemKind::Const(..),\n@@ -680,11 +672,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 ..\n             }) if span.ctxt() == ctxt => {\n                 let ty = cx.tcx.type_of(def_id);\n-                Some(if ty.is_ref() {\n-                    Position::DerefStable(precedence)\n-                } else {\n-                    Position::Other(precedence)\n-                })\n+                Some(ty_auto_deref_stability(cx, ty, precedence).position_for_result(cx))\n             },\n \n             Node::Item(&Item {\n@@ -705,45 +693,38 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 span,\n                 ..\n             }) if span.ctxt() == ctxt => {\n-                let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n-                Some(if !output.is_ref() {\n-                    Position::Other(precedence)\n-                } else if output.has_placeholders() || output.has_opaque_types() {\n-                    Position::ReborrowStable(precedence)\n-                } else {\n-                    Position::DerefStable(precedence)\n-                })\n+                let output = cx\n+                    .tcx\n+                    .erase_late_bound_regions(cx.tcx.fn_sig(def_id.to_def_id()).output());\n+                Some(ty_auto_deref_stability(cx, output, precedence).position_for_result(cx))\n             },\n \n             Node::Expr(parent) if parent.span.ctxt() == ctxt => match parent.kind {\n                 ExprKind::Ret(_) => {\n                     let owner_id = cx.tcx.hir().body_owner(cx.enclosing_body.unwrap());\n                     Some(\n-                        if let Node::Expr(Expr {\n-                            kind: ExprKind::Closure(&Closure { fn_decl, .. }),\n-                            ..\n-                        }) = cx.tcx.hir().get(owner_id)\n+                        if let Node::Expr(\n+                            closure_expr @ Expr {\n+                                kind: ExprKind::Closure(closure),\n+                                ..\n+                            },\n+                        ) = cx.tcx.hir().get(owner_id)\n                         {\n-                            match fn_decl.output {\n-                                FnRetTy::Return(ty) => binding_ty_auto_deref_stability(ty, precedence),\n-                                FnRetTy::DefaultReturn(_) => Position::Other(precedence),\n-                            }\n+                            closure_result_position(cx, closure, cx.typeck_results().expr_ty(closure_expr), precedence)\n                         } else {\n                             let output = cx\n                                 .tcx\n-                                .fn_sig(cx.tcx.hir().local_def_id(owner_id))\n-                                .skip_binder()\n-                                .output();\n-                            if !output.is_ref() {\n-                                Position::Other(precedence)\n-                            } else if output.has_placeholders() || output.has_opaque_types() {\n-                                Position::ReborrowStable(precedence)\n-                            } else {\n-                                Position::DerefStable(precedence)\n-                            }\n+                                .erase_late_bound_regions(cx.tcx.fn_sig(cx.tcx.hir().local_def_id(owner_id)).output());\n+                            ty_auto_deref_stability(cx, output, precedence).position_for_result(cx)\n                         },\n                     )\n                 },\n+                ExprKind::Closure(closure) => Some(closure_result_position(\n+                    cx,\n+                    closure,\n+                    cx.typeck_results().expr_ty(parent),\n+                    precedence,\n+                )),\n                 ExprKind::Call(func, _) if func.hir_id == child_id => {\n                     (child_id == e.hir_id).then_some(Position::Callee)\n                 },\n@@ -755,8 +736,9 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                     .map(|(hir_ty, ty)| match hir_ty {\n                         // Type inference for closures can depend on how they're called. Only go by the explicit\n                         // types here.\n-                        Some(ty) => binding_ty_auto_deref_stability(ty, precedence),\n-                        None => param_auto_deref_stability(ty.skip_binder(), precedence),\n+                        Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n+                        None => ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n+                            .position_for_arg(),\n                     }),\n                 ExprKind::MethodCall(_, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n@@ -797,7 +779,12 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                 Position::MethodReceiver\n                             }\n                         } else {\n-                            param_auto_deref_stability(cx.tcx.fn_sig(id).skip_binder().inputs()[i], precedence)\n+                            ty_auto_deref_stability(\n+                                cx,\n+                                cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n+                                precedence,\n+                            )\n+                            .position_for_arg()\n                         }\n                     })\n                 },\n@@ -808,7 +795,9 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                         .find(|f| f.expr.hir_id == child_id)\n                         .zip(variant)\n                         .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n-                        .map(|field| param_auto_deref_stability(cx.tcx.type_of(field.did), precedence))\n+                        .map(|field| {\n+                            ty_auto_deref_stability(cx, cx.tcx.type_of(field.did), precedence).position_for_arg()\n+                        })\n                 },\n                 ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n@@ -831,6 +820,26 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n     (position, adjustments)\n }\n \n+fn closure_result_position<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    closure: &'tcx Closure<'_>,\n+    ty: Ty<'tcx>,\n+    precedence: i8,\n+) -> Position {\n+    match closure.fn_decl.output {\n+        FnRetTy::Return(hir_ty) => {\n+            if let Some(sig) = ty_sig(cx, ty)\n+                && let Some(output) = sig.output()\n+            {\n+                binding_ty_auto_deref_stability(cx, hir_ty, precedence, output.bound_vars())\n+            } else {\n+                Position::Other(precedence)\n+            }\n+        },\n+        FnRetTy::DefaultReturn(_) => Position::Other(precedence),\n+    }\n+}\n+\n // Checks the stability of auto-deref when assigned to a binding with the given explicit type.\n //\n // e.g.\n@@ -840,7 +849,12 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n //\n // Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n // switching to auto-dereferencing.\n-fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>, precedence: i8) -> Position {\n+fn binding_ty_auto_deref_stability<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: &'tcx hir::Ty<'_>,\n+    precedence: i8,\n+    binder_args: &'tcx List<BoundVariableKind>,\n+) -> Position {\n     let TyKind::Rptr(_, ty) = &ty.kind else {\n         return Position::Other(precedence);\n     };\n@@ -870,21 +884,33 @@ fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>, precedence: i8) -> Position\n                 {\n                     Position::ReborrowStable(precedence)\n                 } else {\n-                    Position::DerefStable(precedence)\n+                    Position::DerefStable(\n+                        precedence,\n+                        cx.tcx\n+                            .erase_late_bound_regions(Binder::bind_with_vars(\n+                                cx.typeck_results().node_type(ty.ty.hir_id),\n+                                binder_args,\n+                            ))\n+                            .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                    )\n                 }\n             },\n-            TyKind::Slice(_)\n-            | TyKind::Array(..)\n-            | TyKind::BareFn(_)\n-            | TyKind::Never\n+            TyKind::Slice(_) => Position::DerefStable(precedence, false),\n+            TyKind::Array(..) | TyKind::Ptr(_) | TyKind::BareFn(_) => Position::DerefStable(precedence, true),\n+            TyKind::Never\n             | TyKind::Tup(_)\n-            | TyKind::Ptr(_)\n-            | TyKind::TraitObject(..)\n-            | TyKind::Path(_) => Position::DerefStable(precedence),\n-            TyKind::OpaqueDef(..)\n-            | TyKind::Infer\n-            | TyKind::Typeof(..)\n-            | TyKind::Err => Position::ReborrowStable(precedence),\n+            | TyKind::Path(_) => Position::DerefStable(\n+                precedence,\n+                cx.tcx\n+                    .erase_late_bound_regions(Binder::bind_with_vars(\n+                        cx.typeck_results().node_type(ty.ty.hir_id),\n+                        binder_args,\n+                    ))\n+                    .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+            ),\n+            TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::TraitObject(..) | TyKind::Err => {\n+                Position::ReborrowStable(precedence)\n+            },\n         };\n     }\n }\n@@ -920,10 +946,39 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n     v.0\n }\n \n+struct TyPosition<'tcx> {\n+    position: Position,\n+    ty: Option<Ty<'tcx>>,\n+}\n+impl From<Position> for TyPosition<'_> {\n+    fn from(position: Position) -> Self {\n+        Self { position, ty: None }\n+    }\n+}\n+impl<'tcx> TyPosition<'tcx> {\n+    fn new_deref_stable_for_result(precedence: i8, ty: Ty<'tcx>) -> Self {\n+        Self {\n+            position: Position::ReborrowStable(precedence),\n+            ty: Some(ty),\n+        }\n+    }\n+    fn position_for_result(self, cx: &LateContext<'tcx>) -> Position {\n+        match (self.position, self.ty) {\n+            (Position::ReborrowStable(precedence), Some(ty)) => {\n+                Position::DerefStable(precedence, ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env))\n+            },\n+            (position, _) => position,\n+        }\n+    }\n+    fn position_for_arg(self) -> Position {\n+        self.position\n+    }\n+}\n+\n // Checks whether a type is stable when switching to auto dereferencing,\n-fn param_auto_deref_stability(ty: Ty<'_>, precedence: i8) -> Position {\n+fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedence: i8) -> TyPosition<'tcx> {\n     let ty::Ref(_, mut ty, _) = *ty.kind() else {\n-        return Position::Other(precedence);\n+        return Position::Other(precedence).into();\n     };\n \n     loop {\n@@ -932,35 +987,38 @@ fn param_auto_deref_stability(ty: Ty<'_>, precedence: i8) -> Position {\n                 ty = ref_ty;\n                 continue;\n             },\n-            ty::Infer(_)\n-            | ty::Error(_)\n-            | ty::Param(_)\n-            | ty::Bound(..)\n-            | ty::Opaque(..)\n-            | ty::Placeholder(_)\n-            | ty::Dynamic(..) => Position::ReborrowStable(precedence),\n-            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => {\n-                Position::ReborrowStable(precedence)\n+            ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Infer(_) | ty::Error(_) | ty::Bound(..) | ty::Opaque(..) | ty::Placeholder(_) | ty::Dynamic(..) => {\n+                Position::ReborrowStable(precedence).into()\n             },\n-            ty::Adt(..)\n-            | ty::Bool\n+            ty::Adt(..) if ty.has_placeholders() || ty.has_opaque_types() => {\n+                Position::ReborrowStable(precedence).into()\n+            },\n+            ty::Adt(_, substs) if substs.has_param_types_or_consts() => {\n+                TyPosition::new_deref_stable_for_result(precedence, ty)\n+            },\n+            ty::Bool\n             | ty::Char\n             | ty::Int(_)\n             | ty::Uint(_)\n-            | ty::Float(_)\n-            | ty::Foreign(_)\n-            | ty::Str\n             | ty::Array(..)\n-            | ty::Slice(..)\n+            | ty::Float(_)\n             | ty::RawPtr(..)\n+            | ty::FnPtr(_) => Position::DerefStable(precedence, true).into(),\n+            ty::Str | ty::Slice(..) => Position::DerefStable(precedence, false).into(),\n+            ty::Adt(..)\n+            | ty::Foreign(_)\n             | ty::FnDef(..)\n-            | ty::FnPtr(_)\n-            | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n+            | ty::Closure(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Projection(_) => Position::DerefStable(precedence),\n+            | ty::Projection(_) => Position::DerefStable(\n+                precedence,\n+                ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+            )\n+            .into(),\n         };\n     }\n }\n@@ -1040,34 +1098,64 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n                 diag.span_suggestion(data.span, \"change this to\", sugg, app);\n             });\n         },\n-        State::ExplicitDeref { deref_span_id } => {\n-            let (span, hir_id, precedence) = if let Some((span, hir_id)) = deref_span_id\n+        State::ExplicitDeref { mutability } => {\n+            if matches!(\n+                expr.kind,\n+                ExprKind::Block(..)\n+                    | ExprKind::ConstBlock(_)\n+                    | ExprKind::If(..)\n+                    | ExprKind::Loop(..)\n+                    | ExprKind::Match(..)\n+            ) && matches!(data.position, Position::DerefStable(_, true))\n+            {\n+                // Rustc bug: auto deref doesn't work on block expression when targeting sized types.\n+                return;\n+            }\n+\n+            let (prefix, precedence) = if let Some(mutability) = mutability\n                 && !cx.typeck_results().expr_ty(expr).is_ref()\n             {\n-                (span, hir_id, PREC_PREFIX)\n+                let prefix = match mutability {\n+                    Mutability::Not => \"&\",\n+                    Mutability::Mut => \"&mut \",\n+                };\n+                (prefix, 0)\n             } else {\n-                (data.span, data.hir_id, data.position.precedence())\n+                (\"\", data.position.precedence())\n             };\n             span_lint_hir_and_then(\n                 cx,\n                 EXPLICIT_AUTO_DEREF,\n-                hir_id,\n-                span,\n+                data.hir_id,\n+                data.span,\n                 \"deref which would be done by auto-deref\",\n                 |diag| {\n                     let mut app = Applicability::MachineApplicable;\n-                    let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, span.ctxt(), \"..\", &mut app);\n+                    let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n                     let sugg =\n                         if !snip_is_macro && expr.precedence().order() < precedence && !has_enclosing_paren(&snip) {\n-                            format!(\"({})\", snip)\n+                            format!(\"{}({})\", prefix, snip)\n                         } else {\n-                            snip.into()\n+                            format!(\"{}{}\", prefix, snip)\n                         };\n-                    diag.span_suggestion(span, \"try this\", sugg, app);\n+                    diag.span_suggestion(data.span, \"try this\", sugg, app);\n                 },\n             );\n         },\n         State::ExplicitDerefField { .. } => {\n+            if matches!(\n+                expr.kind,\n+                ExprKind::Block(..)\n+                    | ExprKind::ConstBlock(_)\n+                    | ExprKind::If(..)\n+                    | ExprKind::Loop(..)\n+                    | ExprKind::Match(..)\n+            ) && matches!(data.position, Position::DerefStable(_, true))\n+            {\n+                // Rustc bug: auto deref doesn't work on block expression when targeting sized types.\n+                return;\n+            }\n+\n             span_lint_hir_and_then(\n                 cx,\n                 EXPLICIT_AUTO_DEREF,\n@@ -1081,7 +1169,7 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n                 },\n             );\n         },\n-        State::Borrow | State::Reborrow { .. } => (),\n+        State::Borrow { .. } | State::Reborrow { .. } => (),\n     }\n }\n "}, {"sha": "e7d670766a050203793c22970b12c09bc26c2806", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "patch": "@@ -503,7 +503,7 @@ pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(P\n pub enum ExprFnSig<'tcx> {\n     Sig(Binder<'tcx, FnSig<'tcx>>, Option<DefId>),\n     Closure(Option<&'tcx FnDecl<'tcx>>, Binder<'tcx, FnSig<'tcx>>),\n-    Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>),\n+    Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>, Option<DefId>),\n }\n impl<'tcx> ExprFnSig<'tcx> {\n     /// Gets the argument type at the given offset. This will return `None` when the index is out of\n@@ -518,7 +518,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n                 }\n             },\n             Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])),\n-            Self::Trait(inputs, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n+            Self::Trait(inputs, _, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n         }\n     }\n \n@@ -541,7 +541,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n                 decl.and_then(|decl| decl.inputs.get(i)),\n                 sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n             )),\n-            Self::Trait(inputs, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))),\n+            Self::Trait(inputs, _, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))),\n         }\n     }\n \n@@ -550,12 +550,16 @@ impl<'tcx> ExprFnSig<'tcx> {\n     pub fn output(self) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n             Self::Sig(sig, _) | Self::Closure(_, sig) => Some(sig.output()),\n-            Self::Trait(_, output) => output,\n+            Self::Trait(_, output, _) => output,\n         }\n     }\n \n     pub fn predicates_id(&self) -> Option<DefId> {\n-        if let ExprFnSig::Sig(_, id) = *self { id } else { None }\n+        if let ExprFnSig::Sig(_, id) | ExprFnSig::Trait(_, _, id) = *self {\n+            id\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -568,7 +572,8 @@ pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnS\n     }\n }\n \n-fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+/// If the type is function like, get the signature for it.\n+pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n     if ty.is_box() {\n         return ty_sig(cx, ty.boxed_ty());\n     }\n@@ -580,7 +585,7 @@ fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>>\n             Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n         },\n         ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id))),\n-        ty::Opaque(id, _) => ty_sig(cx, cx.tcx.type_of(id)),\n+        ty::Opaque(id, _) => sig_from_bounds(cx, ty, cx.tcx.item_bounds(id), cx.tcx.opt_parent(id)),\n         ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig, None)),\n         ty::Dynamic(bounds, _) => {\n             let lang_items = cx.tcx.lang_items();\n@@ -594,38 +599,44 @@ fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>>\n                         .projection_bounds()\n                         .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n                         .map(|p| p.map_bound(|p| p.term.ty().unwrap()));\n-                    Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n+                    Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output, None))\n                 },\n                 _ => None,\n             }\n         },\n         ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n             Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n-            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty)),\n+            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None)),\n         },\n-        ty::Param(_) => sig_from_bounds(cx, ty),\n+        ty::Param(_) => sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None),\n         _ => None,\n     }\n }\n \n-fn sig_from_bounds<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+fn sig_from_bounds<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    predicates: &'tcx [Predicate<'tcx>],\n+    predicates_id: Option<DefId>,\n+) -> Option<ExprFnSig<'tcx>> {\n     let mut inputs = None;\n     let mut output = None;\n     let lang_items = cx.tcx.lang_items();\n \n-    for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n+    for pred in predicates {\n         match pred.kind().skip_binder() {\n             PredicateKind::Trait(p)\n                 if (lang_items.fn_trait() == Some(p.def_id())\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id()))\n                     && p.self_ty() == ty =>\n             {\n-                if inputs.is_some() {\n+                let i = pred.kind().rebind(p.trait_ref.substs.type_at(1));\n+                if inputs.map_or(false, |inputs| i != inputs) {\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n                 }\n-                inputs = Some(pred.kind().rebind(p.trait_ref.substs.type_at(1)));\n+                inputs = Some(i);\n             },\n             PredicateKind::Projection(p)\n                 if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n@@ -641,7 +652,7 @@ fn sig_from_bounds<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnS\n         }\n     }\n \n-    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output, predicates_id))\n }\n \n fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n@@ -661,14 +672,15 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id())) =>\n             {\n-                if inputs.is_some() {\n+                let i = pred\n+                    .map_bound(|pred| pred.kind().rebind(p.trait_ref.substs.type_at(1)))\n+                    .subst(cx.tcx, ty.substs);\n+\n+                if inputs.map_or(false, |inputs| inputs != i) {\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n                 }\n-                inputs = Some(\n-                    pred.map_bound(|pred| pred.kind().rebind(p.trait_ref.substs.type_at(1)))\n-                        .subst(cx.tcx, ty.substs),\n-                );\n+                inputs = Some(i);\n             },\n             PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n                 if output.is_some() {\n@@ -684,7 +696,7 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n         }\n     }\n \n-    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output, None))\n }\n \n #[derive(Clone, Copy)]"}, {"sha": "d1d35e5c0eb46f493aaa3c7b07fdda965be3bef4", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n \n+#![feature(closure_lifetime_binder)]\n #![warn(clippy::explicit_auto_deref)]\n #![allow(\n     dead_code,\n@@ -67,6 +68,8 @@ fn main() {\n     let s = String::new();\n \n     let _: &str = &s;\n+    let _: &str = &{ String::new() };\n+    let _: &str = &mut { String::new() };\n     let _ = &*s; // Don't lint. Inferred type would change.\n     let _: &_ = &*s; // Don't lint. Inferred type would change.\n \n@@ -215,4 +218,52 @@ fn main() {\n     let s = &\"str\";\n     let _ = || return *s;\n     let _ = || -> &'static str { return s };\n+\n+    struct X;\n+    struct Y(X);\n+    impl core::ops::Deref for Y {\n+        type Target = X;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    let _: &X = &*{ Y(X) };\n+    let _: &X = &*match 0 {\n+        #[rustfmt::skip]\n+        0 => { Y(X) },\n+        _ => panic!(),\n+    };\n+    let _: &X = &*if true { Y(X) } else { panic!() };\n+\n+    fn deref_to_u<U, T: core::ops::Deref<Target = U>>(x: &T) -> &U {\n+        x\n+    }\n+\n+    let _ = |x: &'static Box<dyn Iterator<Item = u32>>| -> &'static dyn Iterator<Item = u32> { &**x };\n+    fn ret_any(x: &Box<dyn std::any::Any>) -> &dyn std::any::Any {\n+        &**x\n+    }\n+\n+    let x = String::new();\n+    let _: *const str = &*x;\n+\n+    struct S7([u32; 1]);\n+    impl core::ops::Deref for S7 {\n+        type Target = [u32; 1];\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    let x = S7([0]);\n+    let _: &[u32] = &*x;\n+\n+    let c1 = |_: &Vec<&u32>| {};\n+    let x = &&vec![&1u32];\n+    c1(x);\n+    let _ = for<'a, 'b> |x: &'a &'a Vec<&'b u32>, b: bool| -> &'a Vec<&'b u32> {\n+        if b {\n+            return x;\n+        }\n+        x\n+    };\n }"}, {"sha": "deedafad153b97ae0edd6d777637516d65c33410", "filename": "tests/ui/explicit_auto_deref.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n \n+#![feature(closure_lifetime_binder)]\n #![warn(clippy::explicit_auto_deref)]\n #![allow(\n     dead_code,\n@@ -67,6 +68,8 @@ fn main() {\n     let s = String::new();\n \n     let _: &str = &*s;\n+    let _: &str = &*{ String::new() };\n+    let _: &str = &mut *{ String::new() };\n     let _ = &*s; // Don't lint. Inferred type would change.\n     let _: &_ = &*s; // Don't lint. Inferred type would change.\n \n@@ -215,4 +218,52 @@ fn main() {\n     let s = &\"str\";\n     let _ = || return *s;\n     let _ = || -> &'static str { return *s };\n+\n+    struct X;\n+    struct Y(X);\n+    impl core::ops::Deref for Y {\n+        type Target = X;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    let _: &X = &*{ Y(X) };\n+    let _: &X = &*match 0 {\n+        #[rustfmt::skip]\n+        0 => { Y(X) },\n+        _ => panic!(),\n+    };\n+    let _: &X = &*if true { Y(X) } else { panic!() };\n+\n+    fn deref_to_u<U, T: core::ops::Deref<Target = U>>(x: &T) -> &U {\n+        &**x\n+    }\n+\n+    let _ = |x: &'static Box<dyn Iterator<Item = u32>>| -> &'static dyn Iterator<Item = u32> { &**x };\n+    fn ret_any(x: &Box<dyn std::any::Any>) -> &dyn std::any::Any {\n+        &**x\n+    }\n+\n+    let x = String::new();\n+    let _: *const str = &*x;\n+\n+    struct S7([u32; 1]);\n+    impl core::ops::Deref for S7 {\n+        type Target = [u32; 1];\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    let x = S7([0]);\n+    let _: &[u32] = &*x;\n+\n+    let c1 = |_: &Vec<&u32>| {};\n+    let x = &&vec![&1u32];\n+    c1(*x);\n+    let _ = for<'a, 'b> |x: &'a &'a Vec<&'b u32>, b: bool| -> &'a Vec<&'b u32> {\n+        if b {\n+            return *x;\n+        }\n+        *x\n+    };\n }"}, {"sha": "91863abcc5d2436cb297493c45c8f88a74e88703", "filename": "tests/ui/explicit_auto_deref.stderr", "status": "modified", "additions": 90, "deletions": 54, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/tests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7/tests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.stderr?ref=4912c0ece4a7082bd6fda38fe0ea1de4335ce2a7", "patch": "@@ -1,202 +1,238 @@\n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:69:20\n+  --> $DIR/explicit_auto_deref.rs:70:19\n    |\n LL |     let _: &str = &*s;\n-   |                    ^^ help: try this: `s`\n+   |                   ^^^ help: try this: `&s`\n    |\n    = note: `-D clippy::explicit-auto-deref` implied by `-D warnings`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:73:12\n+  --> $DIR/explicit_auto_deref.rs:71:19\n+   |\n+LL |     let _: &str = &*{ String::new() };\n+   |                   ^^^^^^^^^^^^^^^^^^^ help: try this: `&{ String::new() }`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:72:19\n+   |\n+LL |     let _: &str = &mut *{ String::new() };\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&mut { String::new() }`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:76:11\n    |\n LL |     f_str(&*s);\n-   |            ^^ help: try this: `s`\n+   |           ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:77:14\n+  --> $DIR/explicit_auto_deref.rs:80:13\n    |\n LL |     f_str_t(&*s, &*s); // Don't lint second param.\n-   |              ^^ help: try this: `s`\n+   |             ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:80:25\n+  --> $DIR/explicit_auto_deref.rs:83:24\n    |\n LL |     let _: &Box<i32> = &**b;\n-   |                         ^^^ help: try this: `b`\n+   |                        ^^^^ help: try this: `&b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:86:8\n+  --> $DIR/explicit_auto_deref.rs:89:7\n    |\n LL |     c(&*s);\n-   |        ^^ help: try this: `s`\n+   |       ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:92:9\n+  --> $DIR/explicit_auto_deref.rs:95:9\n    |\n LL |         &**x\n    |         ^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:96:11\n+  --> $DIR/explicit_auto_deref.rs:99:11\n    |\n LL |         { &**x }\n    |           ^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:100:9\n+  --> $DIR/explicit_auto_deref.rs:103:9\n    |\n LL |         &**{ x }\n    |         ^^^^^^^^ help: try this: `{ x }`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:104:9\n+  --> $DIR/explicit_auto_deref.rs:107:9\n    |\n LL |         &***x\n    |         ^^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:121:13\n+  --> $DIR/explicit_auto_deref.rs:124:12\n    |\n LL |         f1(&*x);\n-   |             ^^ help: try this: `x`\n+   |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:122:13\n+  --> $DIR/explicit_auto_deref.rs:125:12\n    |\n LL |         f2(&*x);\n-   |             ^^ help: try this: `x`\n+   |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:123:13\n+  --> $DIR/explicit_auto_deref.rs:126:12\n    |\n LL |         f3(&*x);\n-   |             ^^ help: try this: `x`\n+   |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:124:28\n+  --> $DIR/explicit_auto_deref.rs:127:27\n    |\n LL |         f4.callable_str()(&*x);\n-   |                            ^^ help: try this: `x`\n+   |                           ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:125:13\n+  --> $DIR/explicit_auto_deref.rs:128:12\n    |\n LL |         f5(&*x);\n-   |             ^^ help: try this: `x`\n+   |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:126:13\n+  --> $DIR/explicit_auto_deref.rs:129:12\n    |\n LL |         f6(&*x);\n-   |             ^^ help: try this: `x`\n+   |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:127:28\n+  --> $DIR/explicit_auto_deref.rs:130:27\n    |\n LL |         f7.callable_str()(&*x);\n-   |                            ^^ help: try this: `x`\n+   |                           ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:128:26\n+  --> $DIR/explicit_auto_deref.rs:131:25\n    |\n LL |         f8.callable_t()(&*x);\n-   |                          ^^ help: try this: `x`\n+   |                         ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:129:13\n+  --> $DIR/explicit_auto_deref.rs:132:12\n    |\n LL |         f9(&*x);\n-   |             ^^ help: try this: `x`\n+   |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:130:14\n+  --> $DIR/explicit_auto_deref.rs:133:13\n    |\n LL |         f10(&*x);\n-   |              ^^ help: try this: `x`\n+   |             ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:131:27\n+  --> $DIR/explicit_auto_deref.rs:134:26\n    |\n LL |         f11.callable_t()(&*x);\n-   |                           ^^ help: try this: `x`\n+   |                          ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:135:17\n+  --> $DIR/explicit_auto_deref.rs:138:16\n    |\n LL |     let _ = S1(&*s);\n-   |                 ^^ help: try this: `s`\n+   |                ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:140:22\n+  --> $DIR/explicit_auto_deref.rs:143:21\n    |\n LL |     let _ = S2 { s: &*s };\n-   |                      ^^ help: try this: `s`\n+   |                     ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:156:30\n+  --> $DIR/explicit_auto_deref.rs:159:30\n    |\n LL |             let _ = Self::S1(&**s);\n    |                              ^^^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:157:35\n+  --> $DIR/explicit_auto_deref.rs:160:35\n    |\n LL |             let _ = Self::S2 { s: &**s };\n    |                                   ^^^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:160:21\n+  --> $DIR/explicit_auto_deref.rs:163:20\n    |\n LL |     let _ = E1::S1(&*s);\n-   |                     ^^ help: try this: `s`\n+   |                    ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:161:26\n+  --> $DIR/explicit_auto_deref.rs:164:25\n    |\n LL |     let _ = E1::S2 { s: &*s };\n-   |                          ^^ help: try this: `s`\n+   |                         ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:179:13\n+  --> $DIR/explicit_auto_deref.rs:182:13\n    |\n LL |     let _ = (*b).foo;\n    |             ^^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:180:13\n+  --> $DIR/explicit_auto_deref.rs:183:13\n    |\n LL |     let _ = (**b).foo;\n    |             ^^^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:195:19\n+  --> $DIR/explicit_auto_deref.rs:198:19\n    |\n LL |     let _ = f_str(*ref_str);\n    |                   ^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:197:19\n+  --> $DIR/explicit_auto_deref.rs:200:19\n    |\n LL |     let _ = f_str(**ref_ref_str);\n    |                   ^^^^^^^^^^^^^ help: try this: `ref_ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:207:13\n+  --> $DIR/explicit_auto_deref.rs:210:13\n    |\n LL |     f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n    |             ^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:208:12\n+  --> $DIR/explicit_auto_deref.rs:211:12\n    |\n LL |     f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n    |            ^^^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:217:41\n+  --> $DIR/explicit_auto_deref.rs:220:41\n    |\n LL |     let _ = || -> &'static str { return *s };\n    |                                         ^^ help: try this: `s`\n \n-error: aborting due to 33 previous errors\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:239:9\n+   |\n+LL |         &**x\n+   |         ^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:262:8\n+   |\n+LL |     c1(*x);\n+   |        ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:265:20\n+   |\n+LL |             return *x;\n+   |                    ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:267:9\n+   |\n+LL |         *x\n+   |         ^^ help: try this: `x`\n+\n+error: aborting due to 39 previous errors\n "}]}