{"sha": "a51e3e46effc07f5e7ce5a698ddc8be65244b3a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MWUzZTQ2ZWZmYzA3ZjVlN2NlNWE2OThkZGM4YmU2NTI0NGIzYTU=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-08-03T10:35:33Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-08-03T13:03:58Z"}, "message": "trans_arg_expr: Omit extra copies for rvalues\n\nrvalues aren't going to be used anywhere but as the argument, so\nthere's no point in copying them. LLVM used to eliminate the copy\nlater, but why bother emitting it in the first place?", "tree": {"sha": "f42224d47438ebcf99894a3ecae2e943a1958608", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f42224d47438ebcf99894a3ecae2e943a1958608"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a51e3e46effc07f5e7ce5a698ddc8be65244b3a5", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a51e3e46effc07f5e7ce5a698ddc8be65244b3a5", "html_url": "https://github.com/rust-lang/rust/commit/a51e3e46effc07f5e7ce5a698ddc8be65244b3a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a51e3e46effc07f5e7ce5a698ddc8be65244b3a5/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2765811cb6530eb73c5450bd25e915e67bd512cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2765811cb6530eb73c5450bd25e915e67bd512cf", "html_url": "https://github.com/rust-lang/rust/commit/2765811cb6530eb73c5450bd25e915e67bd512cf"}], "stats": {"total": 75, "additions": 24, "deletions": 51}, "files": [{"sha": "f43303e5aebf580d74e4d7b536431c1dcf63b64b", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 24, "deletions": 51, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a51e3e46effc07f5e7ce5a698ddc8be65244b3a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51e3e46effc07f5e7ce5a698ddc8be65244b3a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a51e3e46effc07f5e7ce5a698ddc8be65244b3a5", "patch": "@@ -834,60 +834,33 @@ pub fn trans_arg_expr(bcx: @mut Block,\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n-                match self_mode {\n+                let need_scratch = ty::type_needs_drop(bcx.tcx(), arg_datum.ty) ||\n+                    (bcx.expr_is_lval(arg_expr) &&\n+                     arg_datum.appropriate_mode(bcx.tcx()).is_by_ref());\n+\n+                let arg_datum = if need_scratch {\n+                    let scratch = scratch_datum(bcx, arg_datum.ty, \"__self\", false);\n+                    arg_datum.store_to_datum(bcx, INIT, scratch);\n+\n+                    // Technically, ownership of val passes to the callee.\n+                    // However, we must cleanup should we fail before the\n+                    // callee is actually invoked.\n+                    scratch.add_clean(bcx);\n+                    temp_cleanups.push(scratch.val);\n+\n+                    scratch\n+                } else {\n+                    arg_datum\n+                };\n+\n+                val = match self_mode {\n                     ty::ByRef => {\n-                        // This assertion should really be valid, but because\n-                        // the explicit self code currently passes by-ref, it\n-                        // does not hold.\n-                        //\n-                        //assert !bcx.ccx().maps.moves_map.contains_key(\n-                        //    &arg_expr.id);\n-                        debug!(\"by ref arg with type %s, storing to scratch\",\n-                               bcx.ty_to_str(arg_datum.ty));\n-                        let scratch = scratch_datum(bcx, arg_datum.ty,\n-                                                    \"__self\", false);\n-\n-                        arg_datum.store_to_datum(bcx,\n-                                                 INIT,\n-                                                 scratch);\n-\n-                        // Technically, ownership of val passes to the callee.\n-                        // However, we must cleanup should we fail before the\n-                        // callee is actually invoked.\n-                        scratch.add_clean(bcx);\n-                        temp_cleanups.push(scratch.val);\n-\n-                        val = scratch.to_ref_llval(bcx);\n+                        debug!(\"by ref arg with type %s\", bcx.ty_to_str(arg_datum.ty));\n+                        arg_datum.to_ref_llval(bcx)\n                     }\n                     ty::ByCopy => {\n-                        if ty::type_needs_drop(bcx.tcx(), arg_datum.ty) ||\n-                                arg_datum.appropriate_mode(bcx.tcx()).is_by_ref() {\n-                            debug!(\"by copy arg with type %s, storing to scratch\",\n-                                   bcx.ty_to_str(arg_datum.ty));\n-                            let scratch = scratch_datum(bcx, arg_datum.ty,\n-                                                        \"__arg\", false);\n-\n-                            arg_datum.store_to_datum(bcx,\n-                                                     INIT,\n-                                                     scratch);\n-\n-                            // Technically, ownership of val passes to the callee.\n-                            // However, we must cleanup should we fail before the\n-                            // callee is actually invoked.\n-                            scratch.add_clean(bcx);\n-                            temp_cleanups.push(scratch.val);\n-\n-                            match scratch.appropriate_mode(bcx.tcx()) {\n-                                ByValue => val = Load(bcx, scratch.val),\n-                                ByRef(_) => val = scratch.val,\n-                            }\n-                        } else {\n-                            debug!(\"by copy arg with type %s\", bcx.ty_to_str(arg_datum.ty));\n-                            match arg_datum.mode {\n-                                ByRef(_) => val = Load(bcx, arg_datum.val),\n-                                ByValue => val = arg_datum.val,\n-                            }\n-                        }\n+                        debug!(\"by copy arg with type %s\", bcx.ty_to_str(arg_datum.ty));\n+                        arg_datum.to_appropriate_llval(bcx)\n                     }\n                 }\n             }"}]}