{"sha": "2ea2628ca907e83cba63cc19d29a995c848a3434", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYTI2MjhjYTkwN2U4M2NiYTYzY2MxOWQyOWE5OTVjODQ4YTM0MzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T23:48:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T23:48:50Z"}, "message": "librustc: De-export back, lib, and util. rs=deexporting", "tree": {"sha": "edc6d5872105821f7f370e6941ef9ead85aaaff2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edc6d5872105821f7f370e6941ef9ead85aaaff2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ea2628ca907e83cba63cc19d29a995c848a3434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea2628ca907e83cba63cc19d29a995c848a3434", "html_url": "https://github.com/rust-lang/rust/commit/2ea2628ca907e83cba63cc19d29a995c848a3434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ea2628ca907e83cba63cc19d29a995c848a3434/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3105bcfdc11030abf9855af7a693cbf904460813", "url": "https://api.github.com/repos/rust-lang/rust/commits/3105bcfdc11030abf9855af7a693cbf904460813", "html_url": "https://github.com/rust-lang/rust/commit/3105bcfdc11030abf9855af7a693cbf904460813"}], "stats": {"total": 1493, "additions": 763, "deletions": 730}, "files": [{"sha": "06625c1ddd96580e9581662f489ec3331b6e0478", "filename": "src/librustc/back/abi.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fabi.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -11,72 +11,72 @@\n \n \n \n-const rc_base_field_refcnt: uint = 0u;\n+pub const rc_base_field_refcnt: uint = 0u;\n \n-const task_field_refcnt: uint = 0u;\n+pub const task_field_refcnt: uint = 0u;\n \n-const task_field_stk: uint = 2u;\n+pub const task_field_stk: uint = 2u;\n \n-const task_field_runtime_sp: uint = 3u;\n+pub const task_field_runtime_sp: uint = 3u;\n \n-const task_field_rust_sp: uint = 4u;\n+pub const task_field_rust_sp: uint = 4u;\n \n-const task_field_gc_alloc_chain: uint = 5u;\n+pub const task_field_gc_alloc_chain: uint = 5u;\n \n-const task_field_dom: uint = 6u;\n+pub const task_field_dom: uint = 6u;\n \n-const n_visible_task_fields: uint = 7u;\n+pub const n_visible_task_fields: uint = 7u;\n \n-const dom_field_interrupt_flag: uint = 1u;\n+pub const dom_field_interrupt_flag: uint = 1u;\n \n-const frame_glue_fns_field_mark: uint = 0u;\n+pub const frame_glue_fns_field_mark: uint = 0u;\n \n-const frame_glue_fns_field_drop: uint = 1u;\n+pub const frame_glue_fns_field_drop: uint = 1u;\n \n-const frame_glue_fns_field_reloc: uint = 2u;\n+pub const frame_glue_fns_field_reloc: uint = 2u;\n \n-const box_field_refcnt: uint = 0u;\n-const box_field_tydesc: uint = 1u;\n-const box_field_prev: uint = 2u;\n-const box_field_next: uint = 3u;\n-const box_field_body: uint = 4u;\n+pub const box_field_refcnt: uint = 0u;\n+pub const box_field_tydesc: uint = 1u;\n+pub const box_field_prev: uint = 2u;\n+pub const box_field_next: uint = 3u;\n+pub const box_field_body: uint = 4u;\n \n-const general_code_alignment: uint = 16u;\n+pub const general_code_alignment: uint = 16u;\n \n-const tydesc_field_size: uint = 0u;\n-const tydesc_field_align: uint = 1u;\n-const tydesc_field_take_glue: uint = 2u;\n-const tydesc_field_drop_glue: uint = 3u;\n-const tydesc_field_free_glue: uint = 4u;\n-const tydesc_field_visit_glue: uint = 5u;\n-const tydesc_field_shape: uint = 6u;\n-const tydesc_field_shape_tables: uint = 7u;\n-const n_tydesc_fields: uint = 8u;\n+pub const tydesc_field_size: uint = 0u;\n+pub const tydesc_field_align: uint = 1u;\n+pub const tydesc_field_take_glue: uint = 2u;\n+pub const tydesc_field_drop_glue: uint = 3u;\n+pub const tydesc_field_free_glue: uint = 4u;\n+pub const tydesc_field_visit_glue: uint = 5u;\n+pub const tydesc_field_shape: uint = 6u;\n+pub const tydesc_field_shape_tables: uint = 7u;\n+pub const n_tydesc_fields: uint = 8u;\n \n // The two halves of a closure: code and environment.\n-const fn_field_code: uint = 0u;\n-const fn_field_box: uint = 1u;\n+pub const fn_field_code: uint = 0u;\n+pub const fn_field_box: uint = 1u;\n \n-const vec_elt_fill: uint = 0u;\n+pub const vec_elt_fill: uint = 0u;\n \n-const vec_elt_alloc: uint = 1u;\n+pub const vec_elt_alloc: uint = 1u;\n \n-const vec_elt_elems: uint = 2u;\n+pub const vec_elt_elems: uint = 2u;\n \n-const slice_elt_base: uint = 0u;\n-const slice_elt_len: uint = 1u;\n+pub const slice_elt_base: uint = 0u;\n+pub const slice_elt_len: uint = 1u;\n \n-const worst_case_glue_call_args: uint = 7u;\n+pub const worst_case_glue_call_args: uint = 7u;\n \n-const abi_version: uint = 1u;\n+pub const abi_version: uint = 1u;\n \n-fn memcpy_glue_name() -> ~str { return ~\"rust_memcpy_glue\"; }\n+pub fn memcpy_glue_name() -> ~str { return ~\"rust_memcpy_glue\"; }\n \n-fn bzero_glue_name() -> ~str { return ~\"rust_bzero_glue\"; }\n+pub fn bzero_glue_name() -> ~str { return ~\"rust_bzero_glue\"; }\n \n-fn yield_glue_name() -> ~str { return ~\"rust_yield_glue\"; }\n+pub fn yield_glue_name() -> ~str { return ~\"rust_yield_glue\"; }\n \n-fn no_op_type_glue_name() -> ~str { return ~\"rust_no_op_type_glue\"; }\n+pub fn no_op_type_glue_name() -> ~str { return ~\"rust_no_op_type_glue\"; }\n //\n // Local Variables:\n // mode: rust"}, {"sha": "6ea2c5918ae26667001700ea7fa9683533503dcd", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -13,7 +13,7 @@ use driver::session;\n use session::sess_os_to_meta_os;\n use metadata::loader::meta_section_name;\n \n-fn get_target_strs(target_os: session::os) -> target_strs::t {\n+pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n     return {\n         module_asm: ~\"\",\n "}, {"sha": "53179d4377e06a540634472c0e304ee23b381ec5", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -43,7 +43,8 @@ use syntax::ast_map::{path, path_mod, path_name};\n use syntax::attr;\n use syntax::print::pprust;\n \n-enum output_type {\n+#[deriving_eq]\n+pub enum output_type {\n     output_type_none,\n     output_type_bitcode,\n     output_type_assembly,\n@@ -52,13 +53,6 @@ enum output_type {\n     output_type_exe,\n }\n \n-impl output_type : cmp::Eq {\n-    pure fn eq(&self, other: &output_type) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &output_type) -> bool { !(*self).eq(other) }\n-}\n-\n pub fn llvm_err(sess: Session, +msg: ~str) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n@@ -170,15 +164,15 @@ pub mod jit {\n     }\n }\n \n-mod write {\n+pub mod write {\n     use back::link::jit;\n-    use back::link::{ModuleRef, WriteOutputFile, output_type};\n+    use back::link::{WriteOutputFile, output_type};\n     use back::link::{output_type_assembly, output_type_bitcode};\n     use back::link::{output_type_exe, output_type_llvm_assembly};\n     use back::link::{output_type_object};\n     use driver::session;\n     use lib::llvm::llvm;\n-    use lib::llvm::{False, True, mk_pass_manager, mk_target_data};\n+    use lib::llvm::{False, True, ModuleRef, mk_pass_manager, mk_target_data};\n     use lib;\n     use session::Session;\n \n@@ -456,7 +450,7 @@ mod write {\n  *\n  */\n \n-fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n+pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n                    symbol_hasher: &hash::State) -> link_meta {\n \n     type provided_metas =\n@@ -575,15 +569,15 @@ fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n     return {name: name, vers: vers, extras_hash: extras_hash};\n }\n \n-fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n+pub fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n     unsafe {\n         symbol_hasher.result_str()\n     }\n }\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n+pub fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n                link_meta: link_meta) -> @str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n@@ -601,7 +595,7 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n     hash.to_managed()\n }\n \n-fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> @str {\n+pub fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> @str {\n     match ccx.type_hashcodes.find(t) {\n       Some(h) => h,\n       None => {\n@@ -615,7 +609,7 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> @str {\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n-fn sanitize(s: ~str) -> ~str {\n+pub fn sanitize(s: ~str) -> ~str {\n     let mut result = ~\"\";\n     for str::chars_each(s) |c| {\n         match c {\n@@ -648,7 +642,7 @@ fn sanitize(s: ~str) -> ~str {\n     return result;\n }\n \n-fn mangle(sess: Session, ss: path) -> ~str {\n+pub fn mangle(sess: Session, ss: path) -> ~str {\n     // Follow C++ namespace-mangling style\n \n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n@@ -663,26 +657,26 @@ fn mangle(sess: Session, ss: path) -> ~str {\n     n\n }\n \n-fn exported_name(sess: Session,\n-                 +path: path,\n-                 hash: &str,\n-                 vers: &str) -> ~str {\n+pub fn exported_name(sess: Session,\n+                     +path: path,\n+                     hash: &str,\n+                     vers: &str) -> ~str {\n     return mangle(sess,\n             vec::append_one(\n             vec::append_one(path, path_name(sess.ident_of(hash.to_owned()))),\n             path_name(sess.ident_of(vers.to_owned()))));\n }\n \n-fn mangle_exported_name(ccx: @crate_ctxt, +path: path, t: ty::t) -> ~str {\n+pub fn mangle_exported_name(ccx: @crate_ctxt, +path: path, t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n     return exported_name(ccx.sess, path,\n                          hash,\n                          ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n-                                     t: ty::t,\n-                                     name: &str) -> ~str {\n+pub fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n+                                         t: ty::t,\n+                                         name: &str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n@@ -691,23 +685,23 @@ fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n           path_name(ccx.sess.ident_of(hash.to_owned()))]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt,\n-                                        +path: path,\n-                                        +flav: ~str) -> ~str {\n+pub fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt,\n+                                            +path: path,\n+                                            +flav: ~str) -> ~str {\n     return mangle(ccx.sess,\n                   vec::append_one(path, path_name((ccx.names)(flav))));\n }\n \n-fn mangle_internal_name_by_path(ccx: @crate_ctxt, +path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: @crate_ctxt, +path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: @crate_ctxt, +flav: ~str) -> ~str {\n+pub fn mangle_internal_name_by_seq(ccx: @crate_ctxt, +flav: ~str) -> ~str {\n     return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n }\n \n \n-fn output_dll_filename(os: session::os, lm: link_meta) -> ~str {\n+pub fn output_dll_filename(os: session::os, lm: link_meta) -> ~str {\n     let libname = fmt!(\"%s-%s-%s\", lm.name, lm.extras_hash, lm.vers);\n     let (dll_prefix, dll_suffix) = match os {\n         session::os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n@@ -722,10 +716,10 @@ fn output_dll_filename(os: session::os, lm: link_meta) -> ~str {\n \n // If the user wants an exe generated we need to invoke\n // cc to link the object file with some libs\n-fn link_binary(sess: Session,\n-               obj_filename: &Path,\n-               out_filename: &Path,\n-               lm: link_meta) {\n+pub fn link_binary(sess: Session,\n+                   obj_filename: &Path,\n+                   out_filename: &Path,\n+                   lm: link_meta) {\n     // Converts a library file-stem into a cc -l argument\n     fn unlib(config: @session::config, +stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&"}, {"sha": "7440f3f70ac8c368e4eb9d38c12d078159adbc54", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -21,22 +21,15 @@ use core::vec;\n use std::map::HashMap;\n use std::map;\n \n-export get_absolute_rpath;\n-export get_install_prefix_rpath;\n-export get_relative_to;\n-export get_rpath_flags;\n-export get_rpath_relative_to_output;\n-export minimize_rpaths;\n-export rpaths_to_flags;\n-\n pure fn not_win32(os: session::os) -> bool {\n   match os {\n       session::os_win32 => false,\n       _ => true\n   }\n }\n \n-fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n+pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n+                    -> ~[~str] {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n@@ -63,7 +56,7 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n     sess.filesearch.sysroot().push_rel(&r).push(os::dll_filename(\"rustrt\"))\n }\n \n-fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n+pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n     vec::map(rpaths, |rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str()))\n }\n \n@@ -120,10 +113,10 @@ fn get_rpaths_relative_to_output(os: session::os,\n     })\n }\n \n-fn get_rpath_relative_to_output(os: session::os,\n-                                output: &Path,\n-                                lib: &Path)\n-                             -> Path {\n+pub fn get_rpath_relative_to_output(os: session::os,\n+                                    output: &Path,\n+                                    lib: &Path)\n+                                 -> Path {\n     use core::os;\n \n     assert not_win32(os);\n@@ -141,7 +134,7 @@ fn get_rpath_relative_to_output(os: session::os,\n }\n \n // Find the relative path from one file to another\n-fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n+pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     assert abs1.is_absolute;\n     assert abs2.is_absolute;\n     let abs1 = abs1.normalize();\n@@ -178,11 +171,11 @@ fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n     vec::map(libs, |a| get_absolute_rpath(a) )\n }\n \n-fn get_absolute_rpath(lib: &Path) -> Path {\n+pub fn get_absolute_rpath(lib: &Path) -> Path {\n     os::make_absolute(lib).dir_path()\n }\n \n-fn get_install_prefix_rpath(target_triple: &str) -> Path {\n+pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n     if install_prefix == ~\"\" {\n@@ -193,7 +186,7 @@ fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n }\n \n-fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n+pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let set = map::HashMap();\n     let mut minimized = ~[];\n     for rpaths.each |rpath| {"}, {"sha": "da7e1056982cc8d7b66b64e0f9e706ab2c361b45", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-type t = {\n+pub type t = {\n     module_asm: ~str,\n     meta_sect_name: ~str,\n     data_layout: ~str,"}, {"sha": "aa1189bb1143a18d0e1be1ce0d1561c21fdc18bd", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -17,15 +17,15 @@ use middle::trans::common::{T_fn, T_i1, T_i8, T_i32,\n                                T_size_t, T_void, T_vec2};\n use lib::llvm::{type_names, ModuleRef, ValueRef, TypeRef};\n \n-type upcalls =\n+pub type upcalls =\n     {trace: ValueRef,\n      call_shim_on_c_stack: ValueRef,\n      call_shim_on_rust_stack: ValueRef,\n      rust_personality: ValueRef,\n      reset_stack_limit: ValueRef};\n \n-fn declare_upcalls(targ_cfg: @session::config,\n-                   llmod: ModuleRef) -> @upcalls {\n+pub fn declare_upcalls(targ_cfg: @session::config,\n+                       llmod: ModuleRef) -> @upcalls {\n     fn decl(llmod: ModuleRef, prefix: ~str, name: ~str,\n             tys: ~[TypeRef], rv: TypeRef) ->\n        ValueRef {"}, {"sha": "19cce9bf61999ab977d3cd354b9e99ba9d373821", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -14,7 +14,7 @@ use driver::session;\n use metadata::loader::meta_section_name;\n use session::sess_os_to_meta_os;\n \n-fn get_target_strs(target_os: session::os) -> target_strs::t {\n+pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n     return {\n         module_asm: ~\"\",\n "}, {"sha": "f3a400506964b5c83ad80068a0c89d424074815d", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -14,7 +14,7 @@ use driver::session;\n use metadata::loader::meta_section_name;\n use session::sess_os_to_meta_os;\n \n-fn get_target_strs(target_os: session::os) -> target_strs::t {\n+pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n     return {\n         module_asm: ~\"\",\n "}, {"sha": "9195da2a166c762d86570dbc04e3fc6c58bda469", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -15,10 +15,6 @@ use syntax::{ast, fold, attr};\n use core::option;\n use core::vec;\n \n-export strip_unconfigured_items;\n-export metas_in_cfg;\n-export strip_items;\n-\n type in_cfg_pred = fn@(+attrs: ~[ast::attribute]) -> bool;\n \n type ctxt = @{\n@@ -27,13 +23,13 @@ type ctxt = @{\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n+pub fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n     do strip_items(crate) |attrs| {\n         in_cfg(/*bad*/copy crate.node.config, attrs)\n     }\n }\n \n-fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n+pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     -> @ast::crate {\n \n     let ctxt = @{in_cfg: in_cfg};\n@@ -179,7 +175,8 @@ fn in_cfg(+cfg: ast::crate_cfg, +attrs: ~[ast::attribute]) -> bool {\n     metas_in_cfg(cfg, attr::attr_metas(attrs))\n }\n \n-fn metas_in_cfg(cfg: ast::crate_cfg, +metas: ~[@ast::meta_item]) -> bool {\n+pub fn metas_in_cfg(cfg: ast::crate_cfg,\n+                    +metas: ~[@ast::meta_item]) -> bool {\n     // The \"cfg\" attributes on the item\n     let cfg_metas = attr::find_meta_items_by_name(metas, ~\"cfg\");\n "}, {"sha": "835203f4efe17c4ab688e008041c2597fcd337cc", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -19,12 +19,10 @@ use syntax::attr;\n use syntax::codemap;\n use syntax::fold;\n \n-export maybe_inject_libcore_ref;\n-\n const CORE_VERSION: &static/str = \"0.6\";\n \n-fn maybe_inject_libcore_ref(sess: Session,\n-                            crate: @ast::crate) -> @ast::crate {\n+pub fn maybe_inject_libcore_ref(sess: Session,\n+                                crate: @ast::crate) -> @ast::crate {\n     if use_core(crate) {\n         inject_libcore_ref(sess, crate)\n     } else {"}, {"sha": "94333e0126c9087551f2a58adc70a60a25841a51", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -16,9 +16,7 @@ use syntax::ast;\n \n use core::vec;\n \n-export inject_intrinsic;\n-\n-fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n+pub fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n     let intrinsic_module = @(include_str!(\"intrinsic.rs\").to_owned());\n \n     let item = parse::parse_item_from_source_str(~\"<intrinsic>\","}, {"sha": "5dc0a619cf2650c9483a85e32a3db6914cb8b035", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -27,8 +27,6 @@ use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::attr::attrs_contains_name;\n \n-export modify_for_testing;\n-\n type node_id_gen = fn@() -> ast::node_id;\n \n type test = {span: span, path: ~[ast::ident],\n@@ -42,8 +40,8 @@ type test_ctxt =\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-fn modify_for_testing(sess: session::Session,\n-                      crate: @ast::crate) -> @ast::crate {\n+pub fn modify_for_testing(sess: session::Session,\n+                          crate: @ast::crate) -> @ast::crate {\n \n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'"}, {"sha": "8f2774f15fa8eb333451f88c27a273e2dfe02263", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 625, "deletions": 554, "changes": 1179, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -22,29 +22,29 @@ use core::uint;\n use core::vec;\n use std::map::HashMap;\n \n-type Opcode = u32;\n-type Bool = c_uint;\n+pub type Opcode = u32;\n+pub type Bool = c_uint;\n \n-const True: Bool = 1 as Bool;\n-const False: Bool = 0 as Bool;\n+pub const True: Bool = 1 as Bool;\n+pub const False: Bool = 0 as Bool;\n \n // Consts for the LLVM CallConv type, pre-cast to uint.\n \n-enum CallConv {\n+pub enum CallConv {\n     CCallConv = 0,\n     FastCallConv = 8,\n     ColdCallConv = 9,\n     X86StdcallCallConv = 64,\n     X86FastcallCallConv = 65,\n }\n \n-enum Visibility {\n+pub enum Visibility {\n     LLVMDefaultVisibility = 0,\n     HiddenVisibility = 1,\n     ProtectedVisibility = 2,\n }\n \n-enum Linkage {\n+pub enum Linkage {\n     ExternalLinkage = 0,\n     AvailableExternallyLinkage = 1,\n     LinkOnceAnyLinkage = 2,\n@@ -64,7 +64,7 @@ enum Linkage {\n     LinkerPrivateWeakLinkage = 16,\n }\n \n-enum Attribute {\n+pub enum Attribute {\n     ZExtAttribute = 1,\n     SExtAttribute = 2,\n     NoReturnAttribute = 4,\n@@ -97,7 +97,7 @@ enum Attribute {\n }\n \n // enum for the LLVM IntPredicate type\n-enum IntPredicate {\n+pub enum IntPredicate {\n     IntEQ = 32,\n     IntNE = 33,\n     IntUGT = 34,\n@@ -111,7 +111,7 @@ enum IntPredicate {\n }\n \n // enum for the LLVM RealPredicate type\n-enum RealPredicate {\n+pub enum RealPredicate {\n     RealPredicateFalse = 0,\n     RealOEQ = 1,\n     RealOGT = 2,\n@@ -132,7 +132,7 @@ enum RealPredicate {\n \n // enum for the LLVM TypeKind type - must stay in sync with the def of\n // LLVMTypeKind in llvm/include/llvm-c/Core.h\n-enum TypeKind {\n+pub enum TypeKind {\n     Void      = 0,\n     Half      = 1,\n     Float     = 2,\n@@ -151,7 +151,7 @@ enum TypeKind {\n     X86_MMX   = 15\n }\n \n-impl TypeKind : cmp::Eq {\n+pub impl TypeKind : cmp::Eq {\n     pure fn eq(&self, other: &TypeKind) -> bool {\n         match ((*self), (*other)) {\n             (Void, Void) => true,\n@@ -191,7 +191,7 @@ impl TypeKind : cmp::Eq {\n     pure fn ne(&self, other: &TypeKind) -> bool { !(*self).eq(other) }\n }\n \n-enum AtomicBinOp {\n+pub enum AtomicBinOp {\n     Xchg = 0,\n     Add  = 1,\n     Sub  = 2,\n@@ -205,7 +205,7 @@ enum AtomicBinOp {\n     UMin = 10,\n }\n \n-enum AtomicOrdering {\n+pub enum AtomicOrdering {\n     NotAtomic = 0,\n     Unordered = 1,\n     Monotonic = 2,\n@@ -218,969 +218,1039 @@ enum AtomicOrdering {\n \n // FIXME: Not used right now, but will be once #2334 is fixed\n // Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n-enum FileType {\n+pub enum FileType {\n     AssemblyFile = 0,\n     ObjectFile = 1\n }\n \n // Opaque pointer types\n-enum Module_opaque {}\n-type ModuleRef = *Module_opaque;\n-enum Context_opaque {}\n-type ContextRef = *Context_opaque;\n-enum Type_opaque {}\n-type TypeRef = *Type_opaque;\n-enum Value_opaque {}\n-type ValueRef = *Value_opaque;\n-enum BasicBlock_opaque {}\n-type BasicBlockRef = *BasicBlock_opaque;\n-enum Builder_opaque {}\n-type BuilderRef = *Builder_opaque;\n-enum MemoryBuffer_opaque {}\n-type MemoryBufferRef = *MemoryBuffer_opaque;\n-enum PassManager_opaque {}\n-type PassManagerRef = *PassManager_opaque;\n-enum PassManagerBuilder_opaque {}\n-type PassManagerBuilderRef = *PassManagerBuilder_opaque;\n-enum Use_opaque {}\n-type UseRef = *Use_opaque;\n-enum TargetData_opaque {}\n-type TargetDataRef = *TargetData_opaque;\n-enum ObjectFile_opaque {}\n-type ObjectFileRef = *ObjectFile_opaque;\n-enum SectionIterator_opaque {}\n-type SectionIteratorRef = *SectionIterator_opaque;\n+pub enum Module_opaque {}\n+pub type ModuleRef = *Module_opaque;\n+pub enum Context_opaque {}\n+pub type ContextRef = *Context_opaque;\n+pub enum Type_opaque {}\n+pub type TypeRef = *Type_opaque;\n+pub enum Value_opaque {}\n+pub type ValueRef = *Value_opaque;\n+pub enum BasicBlock_opaque {}\n+pub type BasicBlockRef = *BasicBlock_opaque;\n+pub enum Builder_opaque {}\n+pub type BuilderRef = *Builder_opaque;\n+pub enum MemoryBuffer_opaque {}\n+pub type MemoryBufferRef = *MemoryBuffer_opaque;\n+pub enum PassManager_opaque {}\n+pub type PassManagerRef = *PassManager_opaque;\n+pub enum PassManagerBuilder_opaque {}\n+pub type PassManagerBuilderRef = *PassManagerBuilder_opaque;\n+pub enum Use_opaque {}\n+pub type UseRef = *Use_opaque;\n+pub enum TargetData_opaque {}\n+pub type TargetDataRef = *TargetData_opaque;\n+pub enum ObjectFile_opaque {}\n+pub type ObjectFileRef = *ObjectFile_opaque;\n+pub enum SectionIterator_opaque {}\n+pub type SectionIteratorRef = *SectionIterator_opaque;\n \n #[link_args = \"-Lrustllvm\"]\n #[link_name = \"rustllvm\"]\n #[abi = \"cdecl\"]\n-extern mod llvm {\n-    #[legacy_exports];\n+pub extern mod llvm {\n     /* Create and destroy contexts. */\n-    unsafe fn LLVMContextCreate() -> ContextRef;\n-    unsafe fn LLVMGetGlobalContext() -> ContextRef;\n-    unsafe fn LLVMContextDispose(C: ContextRef);\n-    unsafe fn LLVMGetMDKindIDInContext(C: ContextRef,\n+    pub unsafe fn LLVMContextCreate() -> ContextRef;\n+    pub unsafe fn LLVMGetGlobalContext() -> ContextRef;\n+    pub unsafe fn LLVMContextDispose(C: ContextRef);\n+    pub unsafe fn LLVMGetMDKindIDInContext(C: ContextRef,\n                                        Name: *c_char,\n                                        SLen: c_uint)\n                                     -> c_uint;\n-    unsafe fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n+    pub unsafe fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n \n     /* Create and destroy modules. */\n-    unsafe fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n+    pub unsafe fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n                                                 C: ContextRef)\n                                              -> ModuleRef;\n-    unsafe fn LLVMDisposeModule(M: ModuleRef);\n+    pub unsafe fn LLVMDisposeModule(M: ModuleRef);\n \n     /** Data layout. See Module::getDataLayout. */\n-    unsafe fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n-    unsafe fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n+    pub unsafe fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n+    pub unsafe fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n \n     /** Target triple. See Module::getTargetTriple. */\n-    unsafe fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n-    unsafe fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n+    pub unsafe fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n+    pub unsafe fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n \n     /** See Module::dump. */\n-    unsafe fn LLVMDumpModule(M: ModuleRef);\n+    pub unsafe fn LLVMDumpModule(M: ModuleRef);\n \n     /** See Module::setModuleInlineAsm. */\n-    unsafe fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n+    pub unsafe fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n \n     /** See llvm::LLVMTypeKind::getTypeID. */\n-    unsafe fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n+    pub unsafe fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n \n     /** See llvm::LLVMType::getContext. */\n-    unsafe fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n+    pub unsafe fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n \n     /* Operations on integer types */\n-    unsafe fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint) -> TypeRef;\n-\n-    unsafe fn LLVMInt1Type() -> TypeRef;\n-    unsafe fn LLVMInt8Type() -> TypeRef;\n-    unsafe fn LLVMInt16Type() -> TypeRef;\n-    unsafe fn LLVMInt32Type() -> TypeRef;\n-    unsafe fn LLVMInt64Type() -> TypeRef;\n-    unsafe fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n-    unsafe fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n+    pub unsafe fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMIntTypeInContext(C: ContextRef,\n+                                       NumBits: c_uint) -> TypeRef;\n+\n+    pub unsafe fn LLVMInt1Type() -> TypeRef;\n+    pub unsafe fn LLVMInt8Type() -> TypeRef;\n+    pub unsafe fn LLVMInt16Type() -> TypeRef;\n+    pub unsafe fn LLVMInt32Type() -> TypeRef;\n+    pub unsafe fn LLVMInt64Type() -> TypeRef;\n+    pub unsafe fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n+    pub unsafe fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n \n     /* Operations on real types */\n-    unsafe fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n-\n-    unsafe fn LLVMFloatType() -> TypeRef;\n-    unsafe fn LLVMDoubleType() -> TypeRef;\n-    unsafe fn LLVMX86FP80Type() -> TypeRef;\n-    unsafe fn LLVMFP128Type() -> TypeRef;\n-    unsafe fn LLVMPPCFP128Type() -> TypeRef;\n+    pub unsafe fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n+\n+    pub unsafe fn LLVMFloatType() -> TypeRef;\n+    pub unsafe fn LLVMDoubleType() -> TypeRef;\n+    pub unsafe fn LLVMX86FP80Type() -> TypeRef;\n+    pub unsafe fn LLVMFP128Type() -> TypeRef;\n+    pub unsafe fn LLVMPPCFP128Type() -> TypeRef;\n \n     /* Operations on function types */\n-    unsafe fn LLVMFunctionType(ReturnType: TypeRef, ParamTypes: *TypeRef,\n+    pub unsafe fn LLVMFunctionType(ReturnType: TypeRef, ParamTypes: *TypeRef,\n                         ParamCount: c_uint, IsVarArg: Bool) -> TypeRef;\n-    unsafe fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n-    unsafe fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    unsafe fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    unsafe fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n+    pub unsafe fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n+    pub unsafe fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n+    pub unsafe fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n+    pub unsafe fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n \n     /* Operations on struct types */\n-    unsafe fn LLVMStructTypeInContext(C: ContextRef, ElementTypes: *TypeRef,\n-                               ElementCount: c_uint,\n-                               Packed: Bool) -> TypeRef;\n-    unsafe fn LLVMStructType(ElementTypes: *TypeRef, ElementCount: c_uint,\n+    pub unsafe fn LLVMStructTypeInContext(C: ContextRef,\n+                                          ElementTypes: *TypeRef,\n+                                          ElementCount: c_uint,\n+                                          Packed: Bool) -> TypeRef;\n+    pub unsafe fn LLVMStructType(ElementTypes: *TypeRef, ElementCount: c_uint,\n                       Packed: Bool) -> TypeRef;\n-    unsafe fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n-    unsafe fn LLVMGetStructElementTypes(StructTy: TypeRef,\n+    pub unsafe fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n+    pub unsafe fn LLVMGetStructElementTypes(StructTy: TypeRef,\n                                         Dest: *mut TypeRef);\n-    unsafe fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n+    pub unsafe fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n \n     /* Operations on array, pointer, and vector types (sequence types) */\n-    unsafe fn LLVMArrayType(ElementType: TypeRef,\n+    pub unsafe fn LLVMArrayType(ElementType: TypeRef,\n                      ElementCount: c_uint) -> TypeRef;\n-    unsafe fn LLVMPointerType(ElementType: TypeRef,\n+    pub unsafe fn LLVMPointerType(ElementType: TypeRef,\n                        AddressSpace: c_uint) -> TypeRef;\n-    unsafe fn LLVMVectorType(ElementType: TypeRef,\n+    pub unsafe fn LLVMVectorType(ElementType: TypeRef,\n                       ElementCount: c_uint) -> TypeRef;\n \n-    unsafe fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    unsafe fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n-    unsafe fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n-    unsafe fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n+    pub unsafe fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n+    pub unsafe fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+    pub unsafe fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n+    pub unsafe fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n     /* Operations on other types */\n-    unsafe fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n-    unsafe fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+    pub unsafe fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n \n-    unsafe fn LLVMVoidType() -> TypeRef;\n-    unsafe fn LLVMLabelType() -> TypeRef;\n-    unsafe fn LLVMMetadataType() -> TypeRef;\n+    pub unsafe fn LLVMVoidType() -> TypeRef;\n+    pub unsafe fn LLVMLabelType() -> TypeRef;\n+    pub unsafe fn LLVMMetadataType() -> TypeRef;\n \n     /* Operations on all values */\n-    unsafe fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-    unsafe fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n-    unsafe fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n-    unsafe fn LLVMDumpValue(Val: ValueRef);\n-    unsafe fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    unsafe fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n-    unsafe fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n-    unsafe fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n+    pub unsafe fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+    pub unsafe fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n+    pub unsafe fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n+    pub unsafe fn LLVMDumpValue(Val: ValueRef);\n+    pub unsafe fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n+    pub unsafe fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n+    pub unsafe fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n+    pub unsafe fn LLVMSetMetadata(Val: ValueRef,\n+                                  KindID: c_uint,\n+                                  Node: ValueRef);\n \n     /* Operations on Uses */\n-    unsafe fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n-    unsafe fn LLVMGetNextUse(U: UseRef) -> UseRef;\n-    unsafe fn LLVMGetUser(U: UseRef) -> ValueRef;\n-    unsafe fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n+    pub unsafe fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+    pub unsafe fn LLVMGetNextUse(U: UseRef) -> UseRef;\n+    pub unsafe fn LLVMGetUser(U: UseRef) -> ValueRef;\n+    pub unsafe fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n \n     /* Operations on Users */\n-    unsafe fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n-    unsafe fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n+    pub unsafe fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n+    pub unsafe fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n \n     /* Operations on constants of any type */\n-    unsafe fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n+    pub unsafe fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n     /* all zeroes */\n-    unsafe fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n+    pub unsafe fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n     /* only for int/vector */\n-    unsafe fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-    unsafe fn LLVMIsConstant(Val: ValueRef) -> Bool;\n-    unsafe fn LLVMIsNull(Val: ValueRef) -> Bool;\n-    unsafe fn LLVMIsUndef(Val: ValueRef) -> Bool;\n-    unsafe fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n+    pub unsafe fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+    pub unsafe fn LLVMIsConstant(Val: ValueRef) -> Bool;\n+    pub unsafe fn LLVMIsNull(Val: ValueRef) -> Bool;\n+    pub unsafe fn LLVMIsUndef(Val: ValueRef) -> Bool;\n+    pub unsafe fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n \n     /* Operations on metadata */\n-    unsafe fn LLVMMDStringInContext(C: ContextRef,\n+    pub unsafe fn LLVMMDStringInContext(C: ContextRef,\n                                     Str: *c_char,\n                                     SLen: c_uint)\n                                  -> ValueRef;\n-    unsafe fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n-    unsafe fn LLVMMDNodeInContext(C: ContextRef,\n+    pub unsafe fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n+    pub unsafe fn LLVMMDNodeInContext(C: ContextRef,\n                                   Vals: *ValueRef,\n                                   Count: c_uint)\n                                -> ValueRef;\n-    unsafe fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n-    unsafe fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n+    pub unsafe fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n+    pub unsafe fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n                                    Val: ValueRef);\n \n     /* Operations on scalar constants */\n-    unsafe fn LLVMConstInt(IntTy: TypeRef,\n+    pub unsafe fn LLVMConstInt(IntTy: TypeRef,\n                            N: c_ulonglong,\n                            SignExtend: Bool)\n                         -> ValueRef;\n-    unsafe fn LLVMConstIntOfString(IntTy: TypeRef,\n+    pub unsafe fn LLVMConstIntOfString(IntTy: TypeRef,\n                                    Text: *c_char,\n                                    Radix: u8)\n                                 -> ValueRef;\n-    unsafe fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: *c_char,\n+    pub unsafe fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: *c_char,\n                                    SLen: c_uint,\n                                    Radix: u8) -> ValueRef;\n-    unsafe fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-    unsafe fn LLVMConstRealOfString(RealTy: TypeRef,\n+    pub unsafe fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n+    pub unsafe fn LLVMConstRealOfString(RealTy: TypeRef,\n                                     Text: *c_char)\n                                  -> ValueRef;\n-    unsafe fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: *c_char,\n+    pub unsafe fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: *c_char,\n                                     SLen: c_uint) -> ValueRef;\n-    unsafe fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n-    unsafe fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+    pub unsafe fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef)\n+                                        -> c_ulonglong;\n+    pub unsafe fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef)\n+                                        -> c_longlong;\n \n \n     /* Operations on composite constants */\n-    unsafe fn LLVMConstStringInContext(C: ContextRef,\n+    pub unsafe fn LLVMConstStringInContext(C: ContextRef,\n                                        Str: *c_char,\n                                        Length: c_uint,\n                                        DontNullTerminate: Bool)\n                                     -> ValueRef;\n-    unsafe fn LLVMConstStructInContext(C: ContextRef, ConstantVals: *ValueRef,\n-                                Count: c_uint, Packed: Bool) -> ValueRef;\n+    pub unsafe fn LLVMConstStructInContext(C: ContextRef,\n+                                           ConstantVals: *ValueRef,\n+                                           Count: c_uint,\n+                                           Packed: Bool) -> ValueRef;\n \n-    unsafe fn LLVMConstString(Str: *c_char, Length: c_uint,\n+    pub unsafe fn LLVMConstString(Str: *c_char, Length: c_uint,\n                        DontNullTerminate: Bool) -> ValueRef;\n-    unsafe fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n+    pub unsafe fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n                       Length: c_uint) -> ValueRef;\n-    unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n+    pub unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n                        Count: c_uint, Packed: Bool) -> ValueRef;\n-    unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n+    pub unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n                        Size: c_uint) -> ValueRef;\n \n     /* Constant expressions */\n-    unsafe fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n-    unsafe fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n-    unsafe fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n-    unsafe fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    unsafe fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n-    unsafe fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n-    unsafe fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n-    unsafe fn LLVMConstAdd(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n+    pub unsafe fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+    pub unsafe fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMConstAdd(LHSConstant: ValueRef,\n                            RHSConstant: ValueRef)\n                         -> ValueRef;\n-    unsafe fn LLVMConstNSWAdd(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstNSWAdd(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstNUWAdd(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstNUWAdd(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstFAdd(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstFAdd(LHSConstant: ValueRef,\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstSub(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstSub(LHSConstant: ValueRef,\n                            RHSConstant: ValueRef)\n                         -> ValueRef;\n-    unsafe fn LLVMConstNSWSub(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstNSWSub(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstNUWSub(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstNUWSub(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    unsafe fn LLVMConstMul(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstFSub(LHSConstant: ValueRef,\n+                                RHSConstant: ValueRef)\n+                             -> ValueRef;\n+    pub unsafe fn LLVMConstMul(LHSConstant: ValueRef,\n                            RHSConstant: ValueRef)\n                         -> ValueRef;\n-    unsafe fn LLVMConstNSWMul(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstNSWMul(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstNUWMul(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstNUWMul(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstFMul(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstFMul(LHSConstant: ValueRef,\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstUDiv(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstUDiv(LHSConstant: ValueRef,\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstSDiv(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstSDiv(LHSConstant: ValueRef,\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n                                  RHSConstant: ValueRef)\n                               -> ValueRef;\n-    unsafe fn LLVMConstFDiv(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstFDiv(LHSConstant: ValueRef,\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstURem(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstURem(LHSConstant: ValueRef,\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstSRem(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstSRem(LHSConstant: ValueRef,\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstFRem(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstFRem(LHSConstant: ValueRef,\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstAnd(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstAnd(LHSConstant: ValueRef,\n                            RHSConstant: ValueRef)\n                         -> ValueRef;\n-    unsafe fn LLVMConstOr(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstOr(LHSConstant: ValueRef,\n                           RHSConstant: ValueRef)\n                        -> ValueRef;\n-    unsafe fn LLVMConstXor(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstXor(LHSConstant: ValueRef,\n                            RHSConstant: ValueRef)\n                         -> ValueRef;\n-    unsafe fn LLVMConstShl(LHSConstant: ValueRef,\n+    pub unsafe fn LLVMConstShl(LHSConstant: ValueRef,\n                            RHSConstant: ValueRef)\n                         -> ValueRef;\n-    unsafe fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    unsafe fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) ->\n-       ValueRef;\n-    unsafe fn LLVMConstGEP(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstLShr(LHSConstant: ValueRef,\n+                                RHSConstant: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMConstAShr(LHSConstant: ValueRef,\n+                                RHSConstant: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMConstGEP(ConstantVal: ValueRef,\n                     ConstantIndices: *ValueRef,\n                     NumIndices: c_uint) -> ValueRef;\n-    unsafe fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n                                    ConstantIndices: *ValueRef,\n                                    NumIndices: c_uint)\n                                 -> ValueRef;\n-    unsafe fn LLVMConstTrunc(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstTrunc(ConstantVal: ValueRef,\n                              ToType: TypeRef)\n                           -> ValueRef;\n-    unsafe fn LLVMConstSExt(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstSExt(ConstantVal: ValueRef,\n                             ToType: TypeRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstZExt(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstZExt(ConstantVal: ValueRef,\n                             ToType: TypeRef)\n                          -> ValueRef;\n-    unsafe fn LLVMConstFPTrunc(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstFPTrunc(ConstantVal: ValueRef,\n                                ToType: TypeRef)\n                             -> ValueRef;\n-    unsafe fn LLVMConstFPExt(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstFPExt(ConstantVal: ValueRef,\n                              ToType: TypeRef)\n                           -> ValueRef;\n-    unsafe fn LLVMConstUIToFP(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstUIToFP(ConstantVal: ValueRef,\n                               ToType: TypeRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstSIToFP(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstSIToFP(ConstantVal: ValueRef,\n                               ToType: TypeRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstFPToUI(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstFPToUI(ConstantVal: ValueRef,\n                               ToType: TypeRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstFPToSI(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstFPToSI(ConstantVal: ValueRef,\n                               ToType: TypeRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstPtrToInt(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstPtrToInt(ConstantVal: ValueRef,\n                                 ToType: TypeRef)\n                              -> ValueRef;\n-    unsafe fn LLVMConstIntToPtr(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstIntToPtr(ConstantVal: ValueRef,\n                                 ToType: TypeRef)\n                              -> ValueRef;\n-    unsafe fn LLVMConstBitCast(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstBitCast(ConstantVal: ValueRef,\n                                ToType: TypeRef)\n                             -> ValueRef;\n-    unsafe fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef,\n                                      ToType: TypeRef)\n                                   -> ValueRef;\n-    unsafe fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef,\n                                      ToType: TypeRef)\n                                   -> ValueRef;\n-    unsafe fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef,\n                                       ToType: TypeRef)\n                                    -> ValueRef;\n-    unsafe fn LLVMConstPointerCast(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstPointerCast(ConstantVal: ValueRef,\n                                    ToType: TypeRef)\n                                 -> ValueRef;\n-    unsafe fn LLVMConstIntCast(ConstantVal: ValueRef, ToType: TypeRef,\n+    pub unsafe fn LLVMConstIntCast(ConstantVal: ValueRef, ToType: TypeRef,\n                         isSigned: Bool) -> ValueRef;\n-    unsafe fn LLVMConstFPCast(ConstantVal: ValueRef,\n+    pub unsafe fn LLVMConstFPCast(ConstantVal: ValueRef,\n                               ToType: TypeRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstSelect(ConstantCondition: ValueRef,\n+    pub unsafe fn LLVMConstSelect(ConstantCondition: ValueRef,\n                               ConstantIfTrue: ValueRef,\n                               ConstantIfFalse: ValueRef)\n                            -> ValueRef;\n-    unsafe fn LLVMConstExtractElement(VectorConstant: ValueRef,\n+    pub unsafe fn LLVMConstExtractElement(VectorConstant: ValueRef,\n                                IndexConstant: ValueRef) -> ValueRef;\n-    unsafe fn LLVMConstInsertElement(VectorConstant: ValueRef,\n+    pub unsafe fn LLVMConstInsertElement(VectorConstant: ValueRef,\n                               ElementValueConstant: ValueRef,\n                               IndexConstant: ValueRef) -> ValueRef;\n-    unsafe fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n+    pub unsafe fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n                               VectorBConstant: ValueRef,\n                               MaskConstant: ValueRef) -> ValueRef;\n-    unsafe fn LLVMConstExtractValue(AggConstant: ValueRef, IdxList: *c_uint,\n-                             NumIdx: c_uint) -> ValueRef;\n-    unsafe fn LLVMConstInsertValue(AggConstant: ValueRef,\n+    pub unsafe fn LLVMConstExtractValue(AggConstant: ValueRef,\n+                                        IdxList: *c_uint,\n+                                        NumIdx: c_uint) -> ValueRef;\n+    pub unsafe fn LLVMConstInsertValue(AggConstant: ValueRef,\n                             ElementValueConstant: ValueRef, IdxList: *c_uint,\n                             NumIdx: c_uint) -> ValueRef;\n-    unsafe fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *c_char,\n+    pub unsafe fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *c_char,\n                           Constraints: *c_char, HasSideEffects: Bool,\n                           IsAlignStack: Bool) -> ValueRef;\n-    unsafe fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n+    pub unsafe fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef)\n+                                -> ValueRef;\n \n \n \n     /* Operations on global variables, functions, and aliases (globals) */\n-    unsafe fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n-    unsafe fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-    unsafe fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n-    unsafe fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-    unsafe fn LLVMGetSection(Global: ValueRef) -> *c_char;\n-    unsafe fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n-    unsafe fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n-    unsafe fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n-    unsafe fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n-    unsafe fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n+    pub unsafe fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n+    pub unsafe fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n+    pub unsafe fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n+    pub unsafe fn LLVMGetSection(Global: ValueRef) -> *c_char;\n+    pub unsafe fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n+    pub unsafe fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+    pub unsafe fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n     /* Operations on global variables */\n-    unsafe fn LLVMAddGlobal(M: ModuleRef,\n+    pub unsafe fn LLVMAddGlobal(M: ModuleRef,\n                             Ty: TypeRef,\n                             Name: *c_char)\n                          -> ValueRef;\n-    unsafe fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n+    pub unsafe fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n                                           Ty: TypeRef,\n                                           Name: *c_char,\n                                           AddressSpace: c_uint)\n                                        -> ValueRef;\n-    unsafe fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n-    unsafe fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n-    unsafe fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    unsafe fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    unsafe fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n-    unsafe fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n-    unsafe fn LLVMSetInitializer(GlobalVar: ValueRef, ConstantVal: ValueRef);\n-    unsafe fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n-    unsafe fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n-    unsafe fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n-    unsafe fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n+    pub unsafe fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+    pub unsafe fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n+    pub unsafe fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n+    pub unsafe fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMSetInitializer(GlobalVar: ValueRef,\n+                                     ConstantVal: ValueRef);\n+    pub unsafe fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n+    pub unsafe fn LLVMSetThreadLocal(GlobalVar: ValueRef,\n+                                     IsThreadLocal: Bool);\n+    pub unsafe fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n+    pub unsafe fn LLVMSetGlobalConstant(GlobalVar: ValueRef,\n+                                        IsConstant: Bool);\n \n     /* Operations on aliases */\n-    unsafe fn LLVMAddAlias(M: ModuleRef, Ty: TypeRef, Aliasee: ValueRef,\n+    pub unsafe fn LLVMAddAlias(M: ModuleRef, Ty: TypeRef, Aliasee: ValueRef,\n                     Name: *c_char) -> ValueRef;\n \n     /* Operations on functions */\n-    unsafe fn LLVMAddFunction(M: ModuleRef,\n+    pub unsafe fn LLVMAddFunction(M: ModuleRef,\n                               Name: *c_char,\n                               FunctionTy: TypeRef)\n                            -> ValueRef;\n-    unsafe fn LLVMGetNamedFunction(M: ModuleRef, Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n-    unsafe fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n-    unsafe fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-    unsafe fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n-    unsafe fn LLVMDeleteFunction(Fn: ValueRef);\n-    unsafe fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *c_char,\n+    pub unsafe fn LLVMGetNamedFunction(M: ModuleRef,\n+                                       Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+    pub unsafe fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n+    pub unsafe fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMDeleteFunction(Fn: ValueRef);\n+    pub unsafe fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *c_char,\n                                FunctionTy: TypeRef) -> ValueRef;\n-    unsafe fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n-    unsafe fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n-    unsafe fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    unsafe fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n-    unsafe fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n-    unsafe fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n+    pub unsafe fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+    pub unsafe fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n+    pub unsafe fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n+    pub unsafe fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n                            c_ulonglong);\n-    unsafe fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n-    unsafe fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: c_ulonglong, HighPA:\n-                              c_ulonglong);\n+    pub unsafe fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n+    pub unsafe fn LLVMRemoveFunctionAttr(Fn: ValueRef,\n+                                         PA: c_ulonglong,\n+                                         HighPA: c_ulonglong);\n \n     /* Operations on parameters */\n-    unsafe fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-    unsafe fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n-    unsafe fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n-    unsafe fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n-    unsafe fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n-    unsafe fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n-    unsafe fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n-    unsafe fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    unsafe fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n-    unsafe fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n-    unsafe fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n-    unsafe fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n+    pub unsafe fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n+    pub unsafe fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+    pub unsafe fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+    pub unsafe fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+    pub unsafe fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n \n     /* Operations on basic blocks */\n-    unsafe fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n-    unsafe fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n-    unsafe fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n-    unsafe fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    unsafe fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n-    unsafe fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *ValueRef);\n-    unsafe fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    unsafe fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    unsafe fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    unsafe fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-    unsafe fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-\n-    unsafe fn LLVMAppendBasicBlockInContext(C: ContextRef, Fn: ValueRef,\n-                                     Name: *c_char) -> BasicBlockRef;\n-    unsafe fn LLVMInsertBasicBlockInContext(C: ContextRef, BB: BasicBlockRef,\n+    pub unsafe fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n+    pub unsafe fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n+    pub unsafe fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n+    pub unsafe fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n+    pub unsafe fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *ValueRef);\n+    pub unsafe fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub unsafe fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub unsafe fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub unsafe fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef)\n+                                         -> BasicBlockRef;\n+    pub unsafe fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+\n+    pub unsafe fn LLVMAppendBasicBlockInContext(C: ContextRef, Fn: ValueRef,\n                                      Name: *c_char) -> BasicBlockRef;\n+    pub unsafe fn LLVMInsertBasicBlockInContext(C: ContextRef,\n+                                                BB: BasicBlockRef,\n+                                                Name: *c_char)\n+                                             -> BasicBlockRef;\n \n-    unsafe fn LLVMAppendBasicBlock(Fn: ValueRef,\n+    pub unsafe fn LLVMAppendBasicBlock(Fn: ValueRef,\n                                    Name: *c_char)\n                                 -> BasicBlockRef;\n-    unsafe fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef,\n+    pub unsafe fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef,\n                                    Name: *c_char)\n                                 -> BasicBlockRef;\n-    unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n+    pub unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n     /* Operations on instructions */\n-    unsafe fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n-    unsafe fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n-    unsafe fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n-    unsafe fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n-    unsafe fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n+    pub unsafe fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub unsafe fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub unsafe fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n \n     /* Operations on call sites */\n-    unsafe fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n-    unsafe fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n-    unsafe fn LLVMAddInstrAttribute(Instr: ValueRef,\n+    pub unsafe fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+    pub unsafe fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMAddInstrAttribute(Instr: ValueRef,\n                                     index: c_uint,\n                                     IA: c_uint);\n-    unsafe fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint,\n+    pub unsafe fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint,\n                                 IA: c_uint);\n-    unsafe fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint,\n+    pub unsafe fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint,\n                                   align: c_uint);\n \n     /* Operations on call instructions (only) */\n-    unsafe fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n-    unsafe fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n+    pub unsafe fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n+    pub unsafe fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n     /* Operations on phi nodes */\n-    unsafe fn LLVMAddIncoming(PhiNode: ValueRef, IncomingValues: *ValueRef,\n-                       IncomingBlocks: *BasicBlockRef, Count: c_uint);\n-    unsafe fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n-    unsafe fn LLVMGetIncomingValue(PhiNode: ValueRef,\n+    pub unsafe fn LLVMAddIncoming(PhiNode: ValueRef,\n+                                  IncomingValues: *ValueRef,\n+                                  IncomingBlocks: *BasicBlockRef,\n+                                  Count: c_uint);\n+    pub unsafe fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+    pub unsafe fn LLVMGetIncomingValue(PhiNode: ValueRef,\n                                    Index: c_uint)\n                                 -> ValueRef;\n-    unsafe fn LLVMGetIncomingBlock(PhiNode: ValueRef,\n+    pub unsafe fn LLVMGetIncomingBlock(PhiNode: ValueRef,\n                             Index: c_uint) -> BasicBlockRef;\n \n     /* Instruction builders */\n-    unsafe fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n-    unsafe fn LLVMCreateBuilder() -> BuilderRef;\n-    unsafe fn LLVMPositionBuilder(Builder: BuilderRef, Block: BasicBlockRef,\n-                           Instr: ValueRef);\n-    unsafe fn LLVMPositionBuilderBefore(Builder: BuilderRef, Instr: ValueRef);\n-    unsafe fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n-                                       Block: BasicBlockRef);\n-    unsafe fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n-    unsafe fn LLVMClearInsertionPosition(Builder: BuilderRef);\n-    unsafe fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n-    unsafe fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n+    pub unsafe fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+    pub unsafe fn LLVMCreateBuilder() -> BuilderRef;\n+    pub unsafe fn LLVMPositionBuilder(Builder: BuilderRef,\n+                                      Block: BasicBlockRef,\n+                                      Instr: ValueRef);\n+    pub unsafe fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n+                                            Instr: ValueRef);\n+    pub unsafe fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n+                                           Block: BasicBlockRef);\n+    pub unsafe fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n+    pub unsafe fn LLVMClearInsertionPosition(Builder: BuilderRef);\n+    pub unsafe fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n+    pub unsafe fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n                                             Instr: ValueRef,\n                                             Name: *c_char);\n-    unsafe fn LLVMDisposeBuilder(Builder: BuilderRef);\n+    pub unsafe fn LLVMDisposeBuilder(Builder: BuilderRef);\n \n     /* Metadata */\n-    unsafe fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n-    unsafe fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n-    unsafe fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n+    pub unsafe fn LLVMSetCurrentDebugLocation(Builder: BuilderRef,\n+                                              L: ValueRef);\n+    pub unsafe fn LLVMGetCurrentDebugLocation(Builder: BuilderRef)\n+                                           -> ValueRef;\n+    pub unsafe fn LLVMSetInstDebugLocation(Builder: BuilderRef,\n+                                           Inst: ValueRef);\n \n     /* Terminators */\n-    unsafe fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n-    unsafe fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n-    unsafe fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef,\n+    pub unsafe fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n+    pub unsafe fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef,\n                              N: c_uint) -> ValueRef;\n-    unsafe fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n-    unsafe fn LLVMBuildCondBr(B: BuilderRef,\n+    pub unsafe fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n+    pub unsafe fn LLVMBuildCondBr(B: BuilderRef,\n                               If: ValueRef,\n                               Then: BasicBlockRef,\n                               Else: BasicBlockRef)\n                            -> ValueRef;\n-    unsafe fn LLVMBuildSwitch(B: BuilderRef, V: ValueRef, Else: BasicBlockRef,\n-                       NumCases: c_uint) -> ValueRef;\n-    unsafe fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef,\n+    pub unsafe fn LLVMBuildSwitch(B: BuilderRef, V: ValueRef,\n+                                  Else: BasicBlockRef, NumCases: c_uint)\n+                               -> ValueRef;\n+    pub unsafe fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef,\n                            NumDests: c_uint) -> ValueRef;\n-    unsafe fn LLVMBuildInvoke(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n-                       NumArgs: c_uint, Then: BasicBlockRef,\n-                       Catch: BasicBlockRef, Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildLandingPad(B: BuilderRef,\n+    pub unsafe fn LLVMBuildInvoke(B: BuilderRef,\n+                                  Fn: ValueRef,\n+                                  Args: *ValueRef,\n+                                  NumArgs: c_uint,\n+                                  Then: BasicBlockRef,\n+                                  Catch: BasicBlockRef,\n+                                  Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildLandingPad(B: BuilderRef,\n                                   Ty: TypeRef,\n                                   PersFn: ValueRef,\n                                   NumClauses: c_uint,\n                                   Name: *c_char)\n                                -> ValueRef;\n-    unsafe fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n-    unsafe fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n+    pub unsafe fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n     /* Add a case to the switch instruction */\n-    unsafe fn LLVMAddCase(Switch: ValueRef,\n+    pub unsafe fn LLVMAddCase(Switch: ValueRef,\n                           OnVal: ValueRef,\n                           Dest: BasicBlockRef);\n \n     /* Add a destination to the indirectbr instruction */\n-    unsafe fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n+    pub unsafe fn LLVMAddDestination(IndirectBr: ValueRef,\n+                                     Dest: BasicBlockRef);\n \n     /* Add a clause to the landing pad instruction */\n-    unsafe fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n+    pub unsafe fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n \n     /* Set the cleanup on a landing pad instruction */\n-    unsafe fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n+    pub unsafe fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n \n     /* Arithmetic */\n-    unsafe fn LLVMBuildAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildNSWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildNSWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildNUWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildNUWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildFAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildNSWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildNSWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildNUWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildNUWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildFSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildNSWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildNSWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildNUWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildNUWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildFMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildUDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildUDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildExactSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                          Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildExactSDiv(B: BuilderRef, LHS: ValueRef,\n+                                     RHS: ValueRef, Name: *c_char)\n+                                  -> ValueRef;\n+    pub unsafe fn LLVMBuildFDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildURem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildURem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildSRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildSRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildFRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildShl(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildShl(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildLShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildLShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildAShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildAShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildAnd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildAnd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildOr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildOr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                    Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildXor(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n+    pub unsafe fn LLVMBuildXor(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n                     Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildBinOp(B: BuilderRef,\n+    pub unsafe fn LLVMBuildBinOp(B: BuilderRef,\n                              Op: Opcode,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n                              Name: *c_char)\n                           -> ValueRef;\n-    unsafe fn LLVMBuildNeg(B: BuilderRef,\n+    pub unsafe fn LLVMBuildNeg(B: BuilderRef,\n                            V: ValueRef,\n                            Name: *c_char)\n                         -> ValueRef;\n-    unsafe fn LLVMBuildNSWNeg(B: BuilderRef,\n+    pub unsafe fn LLVMBuildNSWNeg(B: BuilderRef,\n                               V: ValueRef,\n                               Name: *c_char)\n                            -> ValueRef;\n-    unsafe fn LLVMBuildNUWNeg(B: BuilderRef,\n+    pub unsafe fn LLVMBuildNUWNeg(B: BuilderRef,\n                               V: ValueRef,\n                               Name: *c_char)\n                            -> ValueRef;\n-    unsafe fn LLVMBuildFNeg(B: BuilderRef,\n+    pub unsafe fn LLVMBuildFNeg(B: BuilderRef,\n                             V: ValueRef,\n                             Name: *c_char)\n                          -> ValueRef;\n-    unsafe fn LLVMBuildNot(B: BuilderRef,\n+    pub unsafe fn LLVMBuildNot(B: BuilderRef,\n                            V: ValueRef,\n                            Name: *c_char)\n                         -> ValueRef;\n \n     /* Memory */\n-    unsafe fn LLVMBuildMalloc(B: BuilderRef,\n-                              Ty: TypeRef,\n-                              Name: *c_char)\n-                           -> ValueRef;\n-    unsafe fn LLVMBuildArrayMalloc(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n-                            Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildAlloca(B: BuilderRef,\n+    pub unsafe fn LLVMBuildMalloc(B: BuilderRef,\n+                                  Ty: TypeRef,\n+                                  Name: *c_char)\n+                               -> ValueRef;\n+    pub unsafe fn LLVMBuildArrayMalloc(B: BuilderRef,\n+                                       Ty: TypeRef,\n+                                       Val: ValueRef,\n+                                       Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildAlloca(B: BuilderRef,\n                               Ty: TypeRef,\n                               Name: *c_char)\n                            -> ValueRef;\n-    unsafe fn LLVMBuildArrayAlloca(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n-                            Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-    unsafe fn LLVMBuildLoad(B: BuilderRef,\n+    pub unsafe fn LLVMBuildArrayAlloca(B: BuilderRef,\n+                                       Ty: TypeRef,\n+                                       Val: ValueRef,\n+                                       Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildFree(B: BuilderRef,\n+                                PointerVal: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMBuildLoad(B: BuilderRef,\n                             PointerVal: ValueRef,\n                             Name: *c_char)\n                          -> ValueRef;\n-    unsafe fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef) ->\n-       ValueRef;\n-    unsafe fn LLVMBuildGEP(B: BuilderRef,\n+    pub unsafe fn LLVMBuildStore(B: BuilderRef,\n+                                 Val: ValueRef,\n+                                 Ptr: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMBuildGEP(B: BuilderRef,\n                            Pointer: ValueRef,\n                            Indices: *ValueRef,\n                            NumIndices: c_uint,\n                            Name: *c_char)\n                         -> ValueRef;\n-    unsafe fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n+    pub unsafe fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n                             Indices: *ValueRef, NumIndices: c_uint,\n                             Name: *c_char)\n        -> ValueRef;\n-    unsafe fn LLVMBuildStructGEP(B: BuilderRef,\n+    pub unsafe fn LLVMBuildStructGEP(B: BuilderRef,\n                                  Pointer: ValueRef,\n                                  Idx: c_uint,\n                                  Name: *c_char)\n                               -> ValueRef;\n-    unsafe fn LLVMBuildGlobalString(B: BuilderRef,\n+    pub unsafe fn LLVMBuildGlobalString(B: BuilderRef,\n                                     Str: *c_char,\n                                     Name: *c_char)\n                                  -> ValueRef;\n-    unsafe fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n+    pub unsafe fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n                                        Str: *c_char,\n                                        Name: *c_char)\n                                     -> ValueRef;\n \n     /* Casts */\n-    unsafe fn LLVMBuildTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildZExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    pub unsafe fn LLVMBuildTrunc(B: BuilderRef,\n+                                 Val: ValueRef,\n+                                 DestTy: TypeRef,\n+                                 Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildZExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildSExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n+    pub unsafe fn LLVMBuildSExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFPToUI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFPToSI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildUIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildSIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFPTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFPExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                      Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildPtrToInt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                         Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildIntToPtr(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                         Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n+    pub unsafe fn LLVMBuildFPToUI(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildFPToSI(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildUIToFP(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildSIToFP(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildFPTrunc(B: BuilderRef,\n+                                   Val: ValueRef,\n+                                   DestTy: TypeRef,\n+                                   Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildFPExt(B: BuilderRef,\n+                                 Val: ValueRef,\n+                                 DestTy: TypeRef,\n+                                 Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildPtrToInt(B: BuilderRef,\n+                                    Val: ValueRef,\n+                                    DestTy: TypeRef,\n+                                    Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildIntToPtr(B: BuilderRef,\n+                                    Val: ValueRef,\n+                                    DestTy: TypeRef,\n+                                    Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildBitCast(B: BuilderRef,\n+                                   Val: ValueRef,\n+                                   DestTy: TypeRef,\n+                                   Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n                                      Val: ValueRef,\n                                      DestTy: TypeRef,\n                                      Name: *c_char)\n                                   -> ValueRef;\n-    unsafe fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n+    pub unsafe fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n                                      Val: ValueRef,\n                                      DestTy: TypeRef,\n                                      Name: *c_char)\n                                   -> ValueRef;\n-    unsafe fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n+    pub unsafe fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n-    unsafe fn LLVMBuildCast(B: BuilderRef, Op: Opcode, Val: ValueRef,\n+    pub unsafe fn LLVMBuildCast(B: BuilderRef, Op: Opcode, Val: ValueRef,\n                      DestTy: TypeRef, Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildPointerCast(B: BuilderRef,\n+    pub unsafe fn LLVMBuildPointerCast(B: BuilderRef,\n                                    Val: ValueRef,\n                                    DestTy: TypeRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n-    unsafe fn LLVMBuildIntCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFPCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildIntCast(B: BuilderRef,\n+                                   Val: ValueRef,\n+                                   DestTy: TypeRef,\n+                                   Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildFPCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *c_char) -> ValueRef;\n \n     /* Comparisons */\n-    unsafe fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n+    pub unsafe fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                      RHS: ValueRef, Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n+    pub unsafe fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                      RHS: ValueRef, Name: *c_char) -> ValueRef;\n \n     /* Miscellaneous instructions */\n-    unsafe fn LLVMBuildPhi(B: BuilderRef,\n+    pub unsafe fn LLVMBuildPhi(B: BuilderRef,\n                            Ty: TypeRef,\n                            Name: *c_char)\n                         -> ValueRef;\n-    unsafe fn LLVMBuildCall(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n+    pub unsafe fn LLVMBuildCall(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n                      NumArgs: c_uint, Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildSelect(B: BuilderRef, If: ValueRef, Then: ValueRef,\n+    pub unsafe fn LLVMBuildSelect(B: BuilderRef, If: ValueRef, Then: ValueRef,\n                        Else: ValueRef, Name: *c_char) -> ValueRef;\n-    unsafe fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef,\n+    pub unsafe fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef,\n                       Name: *c_char)\n        -> ValueRef;\n-    unsafe fn LLVMBuildExtractElement(B: BuilderRef,\n+    pub unsafe fn LLVMBuildExtractElement(B: BuilderRef,\n                                       VecVal: ValueRef,\n                                       Index: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n-    unsafe fn LLVMBuildInsertElement(B: BuilderRef,\n+    pub unsafe fn LLVMBuildInsertElement(B: BuilderRef,\n                                      VecVal: ValueRef,\n                                      EltVal: ValueRef,\n                                      Index: ValueRef,\n                                      Name: *c_char)\n                                   -> ValueRef;\n-    unsafe fn LLVMBuildShuffleVector(B: BuilderRef,\n+    pub unsafe fn LLVMBuildShuffleVector(B: BuilderRef,\n                                      V1: ValueRef,\n                                      V2: ValueRef,\n                                      Mask: ValueRef,\n                                      Name: *c_char)\n                                   -> ValueRef;\n-    unsafe fn LLVMBuildExtractValue(B: BuilderRef,\n+    pub unsafe fn LLVMBuildExtractValue(B: BuilderRef,\n                                     AggVal: ValueRef,\n                                     Index: c_uint,\n                                     Name: *c_char)\n                                  -> ValueRef;\n-    unsafe fn LLVMBuildInsertValue(B: BuilderRef,\n+    pub unsafe fn LLVMBuildInsertValue(B: BuilderRef,\n                                    AggVal: ValueRef,\n                                    EltVal: ValueRef,\n                                    Index: c_uint,\n                                    Name: *c_char)\n                                 -> ValueRef;\n \n-    unsafe fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n+    pub unsafe fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n                            -> ValueRef;\n-    unsafe fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n-                              -> ValueRef;\n-    unsafe fn LLVMBuildPtrDiff(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                        Name: *c_char) -> ValueRef;\n+    pub unsafe fn LLVMBuildIsNotNull(B: BuilderRef,\n+                                     Val: ValueRef,\n+                                     Name: *c_char)\n+                                  -> ValueRef;\n+    pub unsafe fn LLVMBuildPtrDiff(B: BuilderRef,\n+                                   LHS: ValueRef,\n+                                   RHS: ValueRef,\n+                                   Name: *c_char) -> ValueRef;\n \n     /* Atomic Operations */\n-    unsafe fn LLVMBuildAtomicCmpXchg(B: BuilderRef, LHS: ValueRef,\n+    pub unsafe fn LLVMBuildAtomicCmpXchg(B: BuilderRef, LHS: ValueRef,\n                               CMP: ValueRef, RHS: ValueRef,\n                               ++Order: AtomicOrdering) -> ValueRef;\n-    unsafe fn LLVMBuildAtomicRMW(B: BuilderRef, ++Op: AtomicBinOp,\n+    pub unsafe fn LLVMBuildAtomicRMW(B: BuilderRef, ++Op: AtomicBinOp,\n                           LHS: ValueRef, RHS: ValueRef,\n                           ++Order: AtomicOrdering) -> ValueRef;\n \n     /* Selected entries from the downcasts. */\n-    unsafe fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n+    pub unsafe fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n \n     /** Writes a module to the specified path. Returns 0 on success. */\n-    unsafe fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *c_char) -> c_int;\n+    pub unsafe fn LLVMWriteBitcodeToFile(M: ModuleRef,\n+                                         Path: *c_char) -> c_int;\n \n     /** Creates target data from a target layout string. */\n-    unsafe fn LLVMCreateTargetData(StringRep: *c_char) -> TargetDataRef;\n+    pub unsafe fn LLVMCreateTargetData(StringRep: *c_char) -> TargetDataRef;\n     /** Adds the target data to the given pass manager. The pass manager\n         references the target data only weakly. */\n-    unsafe fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n+    pub unsafe fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n     /** Number of bytes clobbered when doing a Store to *T. */\n-    unsafe fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n+    pub unsafe fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n         -> c_ulonglong;\n \n     /** Number of bytes clobbered when doing a Store to *T. */\n-    unsafe fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n+    pub unsafe fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n         -> c_ulonglong;\n \n     /** Distance between successive elements in an array of T.\n     Includes ABI padding. */\n-    unsafe fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n+    pub unsafe fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n \n     /** Returns the preferred alignment of a type. */\n-    unsafe fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n+    pub unsafe fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n                                     Ty: TypeRef) -> c_uint;\n     /** Returns the minimum alignment of a type. */\n-    unsafe fn LLVMABIAlignmentOfType(TD: TargetDataRef,\n+    pub unsafe fn LLVMABIAlignmentOfType(TD: TargetDataRef,\n                               Ty: TypeRef) -> c_uint;\n     /** Returns the minimum alignment of a type when part of a call frame. */\n-    unsafe fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef,\n+    pub unsafe fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef,\n                                     Ty: TypeRef) -> c_uint;\n \n     /** Disposes target data. */\n-    unsafe fn LLVMDisposeTargetData(TD: TargetDataRef);\n+    pub unsafe fn LLVMDisposeTargetData(TD: TargetDataRef);\n \n     /** Creates a pass manager. */\n-    unsafe fn LLVMCreatePassManager() -> PassManagerRef;\n+    pub unsafe fn LLVMCreatePassManager() -> PassManagerRef;\n     /** Disposes a pass manager. */\n-    unsafe fn LLVMDisposePassManager(PM: PassManagerRef);\n+    pub unsafe fn LLVMDisposePassManager(PM: PassManagerRef);\n     /** Runs a pass manager on a module. */\n-    unsafe fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n+    pub unsafe fn LLVMRunPassManager(PM: PassManagerRef,\n+                                     M: ModuleRef) -> Bool;\n \n     /** Adds a verification pass. */\n-    unsafe fn LLVMAddVerifierPass(PM: PassManagerRef);\n-\n-    unsafe fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n-    unsafe fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddReassociatePass(PM: PassManagerRef);\n-    unsafe fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n-    unsafe fn LLVMAddLICMPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddGVNPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddSCCPPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddConstantMergePass(PM: PassManagerRef);\n-    unsafe fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddPruneEHPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n-    unsafe fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n-\n-    unsafe fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n-    unsafe fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n-    unsafe fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n-                                         OptimizationLevel: c_uint);\n-    unsafe fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n-                                          Value: Bool);\n-    unsafe fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n+    pub unsafe fn LLVMAddVerifierPass(PM: PassManagerRef);\n+\n+    pub unsafe fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddReassociatePass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddLICMPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddGVNPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddSCCPPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddConstantMergePass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddPruneEHPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n+    pub unsafe fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n+\n+    pub unsafe fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n+    pub unsafe fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n+    pub unsafe fn LLVMPassManagerBuilderSetOptLevel(\n+        PMB: PassManagerBuilderRef, OptimizationLevel: c_uint);\n+    pub unsafe fn LLVMPassManagerBuilderSetSizeLevel(\n+        PMB: PassManagerBuilderRef, Value: Bool);\n+    pub unsafe fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n         PMB: PassManagerBuilderRef, Value: Bool);\n-    unsafe fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n+    pub unsafe fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n         PMB: PassManagerBuilderRef, Value: Bool);\n-    unsafe fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n+    pub unsafe fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n         (PMB: PassManagerBuilderRef, Value: Bool);\n-    unsafe fn LLVMPassManagerBuilderUseInlinerWithThreshold\n+    pub unsafe fn LLVMPassManagerBuilderUseInlinerWithThreshold\n         (PMB: PassManagerBuilderRef, threshold: c_uint);\n-    unsafe fn LLVMPassManagerBuilderPopulateModulePassManager\n+    pub unsafe fn LLVMPassManagerBuilderPopulateModulePassManager\n         (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n-    unsafe fn LLVMPassManagerBuilderPopulateFunctionPassManager\n+    pub unsafe fn LLVMPassManagerBuilderPopulateFunctionPassManager\n         (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n     /** Destroys a memory buffer. */\n-    unsafe fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n+    pub unsafe fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n \n \n     /* Stuff that's in rustllvm/ because it's not upstream yet. */\n \n     /** Opens an object file. */\n-    unsafe fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n+    pub unsafe fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef)\n+                                    -> ObjectFileRef;\n     /** Closes an object file. */\n-    unsafe fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n+    pub unsafe fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n \n     /** Enumerates the sections in an object file. */\n-    unsafe fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n+    pub unsafe fn LLVMGetSections(ObjFile: ObjectFileRef)\n+                               -> SectionIteratorRef;\n     /** Destroys a section iterator. */\n-    unsafe fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n+    pub unsafe fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n     /** Returns true if the section iterator is at the end of the section\n         list: */\n-    unsafe fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n+    pub unsafe fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n                                   SI: SectionIteratorRef) -> Bool;\n     /** Moves the section iterator to point to the next section. */\n-    unsafe fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n+    pub unsafe fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n     /** Returns the current section name. */\n-    unsafe fn LLVMGetSectionName(SI: SectionIteratorRef) -> *c_char;\n+    pub unsafe fn LLVMGetSectionName(SI: SectionIteratorRef) -> *c_char;\n     /** Returns the current section size. */\n-    unsafe fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n+    pub unsafe fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n     /** Returns the current section contents as a string buffer. */\n-    unsafe fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *c_char;\n+    pub unsafe fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *c_char;\n \n     /** Reads the given file and returns it as a memory buffer. Use\n         LLVMDisposeMemoryBuffer() to get rid of it. */\n-    unsafe fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *c_char) ->\n-       MemoryBufferRef;\n+    pub unsafe fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *c_char)\n+                                -> MemoryBufferRef;\n \n-    unsafe fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef,\n+    pub unsafe fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef,\n                                Triple: *c_char,\n                                // FIXME: When #2334 is fixed, change\n                                // c_uint to FileType\n@@ -1190,94 +1260,95 @@ extern mod llvm {\n \n     /** Returns a string describing the last error caused by an LLVMRust*\n         call. */\n-    unsafe fn LLVMRustGetLastError() -> *c_char;\n+    pub unsafe fn LLVMRustGetLastError() -> *c_char;\n \n     /** Prepare the JIT. Returns a memory manager that can load crates. */\n-    unsafe fn LLVMRustPrepareJIT(__morestack: *()) -> *();\n+    pub unsafe fn LLVMRustPrepareJIT(__morestack: *()) -> *();\n \n     /** Load a crate into the memory manager. */\n-    unsafe fn LLVMRustLoadCrate(MM: *(),\n+    pub unsafe fn LLVMRustLoadCrate(MM: *(),\n                          Filename: *c_char) -> bool;\n \n     /** Execute the JIT engine. */\n-    unsafe fn LLVMRustExecuteJIT(MM: *(),\n+    pub unsafe fn LLVMRustExecuteJIT(MM: *(),\n                           PM: PassManagerRef,\n                           M: ModuleRef,\n                           OptLevel: c_int,\n                           EnableSegmentedStacks: bool) -> *();\n \n     /** Parses the bitcode in the given memory buffer. */\n-    unsafe fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef) -> ModuleRef;\n+    pub unsafe fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef) -> ModuleRef;\n \n     /** Parses LLVM asm in the given file */\n-    unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char) -> ModuleRef;\n+    pub unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char) -> ModuleRef;\n \n-    unsafe fn LLVMRustAddPrintModulePass(PM: PassManagerRef, M: ModuleRef,\n+    pub unsafe fn LLVMRustAddPrintModulePass(PM: PassManagerRef, M: ModuleRef,\n                                   Output: *c_char);\n \n     /** Turn on LLVM pass-timing. */\n-    unsafe fn LLVMRustEnableTimePasses();\n+    pub unsafe fn LLVMRustEnableTimePasses();\n \n     /** Print the pass timings since static dtors aren't picking them up. */\n-    unsafe fn LLVMRustPrintPassTimings();\n+    pub unsafe fn LLVMRustPrintPassTimings();\n \n-    unsafe fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char) -> TypeRef;\n+    pub unsafe fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char)\n+                                     -> TypeRef;\n \n-    unsafe fn LLVMStructSetBody(StructTy: TypeRef, ElementTypes: *TypeRef,\n+    pub unsafe fn LLVMStructSetBody(StructTy: TypeRef, ElementTypes: *TypeRef,\n                          ElementCount: c_uint, Packed: Bool);\n \n-    unsafe fn LLVMConstNamedStruct(S: TypeRef, ConstantVals: *ValueRef,\n+    pub unsafe fn LLVMConstNamedStruct(S: TypeRef, ConstantVals: *ValueRef,\n                             Count: c_uint) -> ValueRef;\n \n     /** Enables LLVM debug output. */\n-    unsafe fn LLVMSetDebug(Enabled: c_int);\n+    pub unsafe fn LLVMSetDebug(Enabled: c_int);\n }\n \n-fn SetInstructionCallConv(Instr: ValueRef, CC: CallConv) {\n+pub fn SetInstructionCallConv(Instr: ValueRef, CC: CallConv) {\n     unsafe {\n         llvm::LLVMSetInstructionCallConv(Instr, CC as c_uint);\n     }\n }\n-fn SetFunctionCallConv(Fn: ValueRef, CC: CallConv) {\n+pub fn SetFunctionCallConv(Fn: ValueRef, CC: CallConv) {\n     unsafe {\n         llvm::LLVMSetFunctionCallConv(Fn, CC as c_uint);\n     }\n }\n-fn SetLinkage(Global: ValueRef, Link: Linkage) {\n+pub fn SetLinkage(Global: ValueRef, Link: Linkage) {\n     unsafe {\n         llvm::LLVMSetLinkage(Global, Link as c_uint);\n     }\n }\n \n /* Memory-managed object interface to type handles. */\n \n-type type_names = @{type_names: HashMap<TypeRef, @str>,\n+pub type type_names = @{type_names: HashMap<TypeRef, @str>,\n                     named_types: HashMap<@str, TypeRef>};\n \n-fn associate_type(tn: type_names, s: @str, t: TypeRef) {\n+pub fn associate_type(tn: type_names, s: @str, t: TypeRef) {\n     assert tn.type_names.insert(t, s);\n     assert tn.named_types.insert(s, t);\n }\n \n-fn type_has_name(tn: type_names, t: TypeRef) -> Option<@str> {\n+pub fn type_has_name(tn: type_names, t: TypeRef) -> Option<@str> {\n     return tn.type_names.find(t);\n }\n \n-fn name_has_type(tn: type_names, s: @str) -> Option<TypeRef> {\n+pub fn name_has_type(tn: type_names, s: @str) -> Option<TypeRef> {\n     return tn.named_types.find(s);\n }\n \n-fn mk_type_names() -> type_names {\n+pub fn mk_type_names() -> type_names {\n     @{type_names: HashMap(),\n       named_types: HashMap()}\n }\n \n-fn type_to_str(names: type_names, ty: TypeRef) -> @str {\n+pub fn type_to_str(names: type_names, ty: TypeRef) -> @str {\n     return type_to_str_inner(names, ~[], ty);\n }\n \n-fn type_to_str_inner(names: type_names, +outer0: ~[TypeRef], ty: TypeRef) ->\n-   @str {\n+pub fn type_to_str_inner(names: type_names, +outer0: ~[TypeRef], ty: TypeRef)\n+                      -> @str {\n     unsafe {\n         match type_has_name(names, ty) {\n           option::Some(n) => return n,\n@@ -1374,7 +1445,7 @@ fn type_to_str_inner(names: type_names, +outer0: ~[TypeRef], ty: TypeRef) ->\n     }\n }\n \n-fn float_width(llt: TypeRef) -> uint {\n+pub fn float_width(llt: TypeRef) -> uint {\n     unsafe {\n         return match llvm::LLVMGetTypeKind(llt) as int {\n               1 => 32u,\n@@ -1386,7 +1457,7 @@ fn float_width(llt: TypeRef) -> uint {\n     }\n }\n \n-fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n+pub fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n     unsafe {\n         let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n                                  0 as TypeRef);\n@@ -1395,7 +1466,7 @@ fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n     }\n }\n \n-fn struct_element_types(struct_ty: TypeRef) -> ~[TypeRef] {\n+pub fn struct_element_types(struct_ty: TypeRef) -> ~[TypeRef] {\n     unsafe {\n         let count = llvm::LLVMCountStructElementTypes(struct_ty);\n         let mut buf: ~[TypeRef] =\n@@ -1412,7 +1483,7 @@ fn struct_element_types(struct_ty: TypeRef) -> ~[TypeRef] {\n \n /* Memory-managed interface to target data. */\n \n-struct target_data_res {\n+pub struct target_data_res {\n     TD: TargetDataRef,\n     drop {\n         unsafe {\n@@ -1421,15 +1492,15 @@ struct target_data_res {\n     }\n }\n \n-fn target_data_res(TD: TargetDataRef) -> target_data_res {\n+pub fn target_data_res(TD: TargetDataRef) -> target_data_res {\n     target_data_res {\n         TD: TD\n     }\n }\n \n-type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n+pub type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n-fn mk_target_data(string_rep: ~str) -> target_data {\n+pub fn mk_target_data(string_rep: ~str) -> target_data {\n     let lltd =\n         str::as_c_str(string_rep, |buf| unsafe {\n             llvm::LLVMCreateTargetData(buf)\n@@ -1439,7 +1510,7 @@ fn mk_target_data(string_rep: ~str) -> target_data {\n \n /* Memory-managed interface to pass managers. */\n \n-struct pass_manager_res {\n+pub struct pass_manager_res {\n     PM: PassManagerRef,\n     drop {\n         unsafe {\n@@ -1448,15 +1519,15 @@ struct pass_manager_res {\n     }\n }\n \n-fn pass_manager_res(PM: PassManagerRef) -> pass_manager_res {\n+pub fn pass_manager_res(PM: PassManagerRef) -> pass_manager_res {\n     pass_manager_res {\n         PM: PM\n     }\n }\n \n-type pass_manager = {llpm: PassManagerRef, dtor: @pass_manager_res};\n+pub type pass_manager = {llpm: PassManagerRef, dtor: @pass_manager_res};\n \n-fn mk_pass_manager() -> pass_manager {\n+pub fn mk_pass_manager() -> pass_manager {\n     unsafe {\n         let llpm = llvm::LLVMCreatePassManager();\n         return {llpm: llpm, dtor: @pass_manager_res(llpm)};\n@@ -1465,7 +1536,7 @@ fn mk_pass_manager() -> pass_manager {\n \n /* Memory-managed interface to object files. */\n \n-struct object_file_res {\n+pub struct object_file_res {\n     ObjectFile: ObjectFileRef,\n     drop {\n         unsafe {\n@@ -1474,15 +1545,15 @@ struct object_file_res {\n     }\n }\n \n-fn object_file_res(ObjFile: ObjectFileRef) -> object_file_res {\n+pub fn object_file_res(ObjFile: ObjectFileRef) -> object_file_res {\n     object_file_res {\n         ObjectFile: ObjFile\n     }\n }\n \n-type object_file = {llof: ObjectFileRef, dtor: @object_file_res};\n+pub type object_file = {llof: ObjectFileRef, dtor: @object_file_res};\n \n-fn mk_object_file(llmb: MemoryBufferRef) -> Option<object_file> {\n+pub fn mk_object_file(llmb: MemoryBufferRef) -> Option<object_file> {\n     unsafe {\n         let llof = llvm::LLVMCreateObjectFile(llmb);\n         if llof as int == 0 { return option::None::<object_file>; }\n@@ -1492,7 +1563,7 @@ fn mk_object_file(llmb: MemoryBufferRef) -> Option<object_file> {\n \n /* Memory-managed interface to section iterators. */\n \n-struct section_iter_res {\n+pub struct section_iter_res {\n     SI: SectionIteratorRef,\n     drop {\n         unsafe {\n@@ -1501,15 +1572,15 @@ struct section_iter_res {\n     }\n }\n \n-fn section_iter_res(SI: SectionIteratorRef) -> section_iter_res {\n+pub fn section_iter_res(SI: SectionIteratorRef) -> section_iter_res {\n     section_iter_res {\n         SI: SI\n     }\n }\n \n-type section_iter = {llsi: SectionIteratorRef, dtor: @section_iter_res};\n+pub type section_iter = {llsi: SectionIteratorRef, dtor: @section_iter_res};\n \n-fn mk_section_iter(llof: ObjectFileRef) -> section_iter {\n+pub fn mk_section_iter(llof: ObjectFileRef) -> section_iter {\n     unsafe {\n         let llsi = llvm::LLVMGetSections(llof);\n         return {llsi: llsi, dtor: @section_iter_res(llsi)};"}, {"sha": "5b99a8209e430c7c15b75e6b4dbc6ba2d4e96944", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -144,32 +144,20 @@ pub mod middle {\n }\n \n pub mod front {\n-    #[legacy_exports]\n     pub mod config;\n-    #[legacy_exports]\n     pub mod test;\n-    #[legacy_exports]\n     pub mod core_inject;\n-    #[legacy_exports]\n     pub mod intrinsic_inject;\n }\n \n pub mod back {\n-    #[legacy_exports]\n     pub mod link;\n-    #[legacy_exports]\n     pub mod abi;\n-    #[legacy_exports]\n     pub mod upcall;\n-    #[legacy_exports]\n     pub mod arm;\n-    #[legacy_exports]\n     pub mod x86;\n-    #[legacy_exports]\n     pub mod x86_64;\n-    #[legacy_exports]\n     pub mod rpath;\n-    #[legacy_exports]\n     pub mod target_strs;\n }\n \n@@ -180,14 +168,11 @@ pub mod metadata;\n pub mod driver;\n \n pub mod util {\n-    #[legacy_exports]\n     pub mod common;\n-    #[legacy_exports]\n     pub mod ppaux;\n }\n \n pub mod lib {\n-    #[legacy_exports]\n     pub mod llvm;\n }\n "}, {"sha": "04cd9c4c03bd93432353b1018e186b7343e6d11a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -21,7 +21,7 @@ use core::str;\n use core::vec;\n use std::map::HashMap;\n \n-fn indent<R>(op: fn() -> R) -> R {\n+pub fn indent<R>(op: fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");\n@@ -30,33 +30,33 @@ fn indent<R>(op: fn() -> R) -> R {\n     move r\n }\n \n-struct _indenter {\n+pub struct _indenter {\n     _i: (),\n     drop { debug!(\"<<\"); }\n }\n \n-fn _indenter(_i: ()) -> _indenter {\n+pub fn _indenter(_i: ()) -> _indenter {\n     _indenter {\n         _i: ()\n     }\n }\n \n-fn indenter() -> _indenter {\n+pub fn indenter() -> _indenter {\n     debug!(\">>\");\n     _indenter(())\n }\n \n-type flag = HashMap<~str, ()>;\n+pub type flag = HashMap<~str, ()>;\n \n-fn field_expr(f: ast::field) -> @ast::expr { return f.node.expr; }\n+pub fn field_expr(f: ast::field) -> @ast::expr { return f.node.expr; }\n \n-fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n+pub fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n     fields.map(|f| f.node.expr)\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n+pub fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n                         &&flag: @mut bool,\n@@ -79,7 +79,7 @@ fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-fn block_query(b: ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n+pub fn block_query(b: ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n                         &&flag: @mut bool,\n@@ -94,20 +94,20 @@ fn block_query(b: ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n     return *rs;\n }\n \n-fn local_rhs_span(l: @ast::local, def: span) -> span {\n+pub fn local_rhs_span(l: @ast::local, def: span) -> span {\n     match l.node.init {\n       Some(i) => return i.span,\n       _ => return def\n     }\n }\n \n-fn pluralize(n: uint, +s: ~str) -> ~str {\n+pub fn pluralize(n: uint, +s: ~str) -> ~str {\n     if n == 1 { s }\n     else { str::concat([s, ~\"s\"]) }\n }\n \n // A set of node IDs (used to keep track of which node IDs are for statements)\n-type stmt_set = HashMap<ast::node_id, ()>;\n+pub type stmt_set = HashMap<ast::node_id, ()>;\n \n //\n // Local Variables:"}, {"sha": "fbbcc904160011744357c7e0d8fa2db502b957c7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea2628ca907e83cba63cc19d29a995c848a3434/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2ea2628ca907e83cba63cc19d29a995c848a3434", "patch": "@@ -38,10 +38,10 @@ use core::str;\n use core::vec;\n use std::map::HashMap;\n \n-fn note_and_explain_region(cx: ctxt,\n-                           prefix: ~str,\n-                           region: ty::Region,\n-                           suffix: ~str) {\n+pub fn note_and_explain_region(cx: ctxt,\n+                               prefix: ~str,\n+                               region: ty::Region,\n+                               suffix: ~str) {\n     match explain_region_and_span(cx, region) {\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n@@ -57,15 +57,14 @@ fn note_and_explain_region(cx: ctxt,\n \n /// Returns a string like \"the block at 27:31\" that attempts to explain a\n /// lifetime in a way it might plausibly be understood.\n-fn explain_region(cx: ctxt, region: ty::Region) -> ~str {\n+pub fn explain_region(cx: ctxt, region: ty::Region) -> ~str {\n   let (res, _) = explain_region_and_span(cx, region);\n   return res;\n }\n \n \n-fn explain_region_and_span(cx: ctxt, region: ty::Region)\n-    -> (~str, Option<span>)\n-{\n+pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n+                            -> (~str, Option<span>) {\n     return match region {\n       re_scope(node_id) => {\n         match cx.items.find(node_id) {\n@@ -136,12 +135,12 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n     }\n }\n \n-fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n+pub fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n     bound_region_to_str_adorned(cx, \"&\", br, \"\")\n }\n \n-fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n-                               br: bound_region, sep: &str) -> ~str {\n+pub fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n+                                   br: bound_region, sep: &str) -> ~str {\n     if cx.sess.verbose() { return fmt!(\"%s%?%s\", prefix, br, sep); }\n \n     match br {\n@@ -154,7 +153,7 @@ fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n     }\n }\n \n-fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n+pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n     match cx.items.find(node_id) {\n       Some(ast_map::node_block(ref blk)) => {\n         fmt!(\"<block at %s>\",\n@@ -197,12 +196,12 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n-fn region_to_str(cx: ctxt, region: Region) -> ~str {\n+pub fn region_to_str(cx: ctxt, region: Region) -> ~str {\n     region_to_str_adorned(cx, \"&\", region, \"\")\n }\n \n-fn region_to_str_adorned(cx: ctxt, prefix: &str,\n-                         region: Region, sep: &str) -> ~str {\n+pub fn region_to_str_adorned(cx: ctxt, prefix: &str,\n+                             region: Region, sep: &str) -> ~str {\n     if cx.sess.verbose() {\n         return fmt!(\"%s%?%s\", prefix, region, sep);\n     }\n@@ -223,7 +222,7 @@ fn region_to_str_adorned(cx: ctxt, prefix: &str,\n     }\n }\n \n-fn mt_to_str(cx: ctxt, m: mt) -> ~str {\n+pub fn mt_to_str(cx: ctxt, m: mt) -> ~str {\n     let mstr = match m.mutbl {\n       ast::m_mutbl => \"mut \",\n       ast::m_imm => \"\",\n@@ -232,7 +231,7 @@ fn mt_to_str(cx: ctxt, m: mt) -> ~str {\n     return fmt!(\"%s%s\", mstr, ty_to_str(cx, m.ty));\n }\n \n-fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n+pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n     match vs {\n       ty::vstore_fixed(n) => fmt!(\"%u\", n),\n       ty::vstore_uniq => ~\"~\",\n@@ -241,7 +240,7 @@ fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n     }\n }\n \n-fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n+pub fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     match vs {\n       ty::vstore_fixed(_) => {\n         fmt!(\"%s/%s\", ty, vstore_to_str(cx, vs))\n@@ -253,8 +252,8 @@ fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     }\n }\n \n-fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto,\n-                   followed_by_word: bool) -> &static/str {\n+pub fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto,\n+                       followed_by_word: bool) -> &static/str {\n     match proto {\n         ast::ProtoBare if followed_by_word => \"extern \",\n         ast::ProtoBare => \"extern\",\n@@ -264,34 +263,34 @@ fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto,\n     }\n }\n \n-fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n+pub fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n     fmt!(\"expr(%d: %s)\",\n          expr.id,\n          pprust::expr_to_str(expr, cx.sess.intr()))\n }\n \n-fn pat_repr(cx: ctxt, pat: @ast::pat) -> ~str {\n+pub fn pat_repr(cx: ctxt, pat: @ast::pat) -> ~str {\n     fmt!(\"pat(%d: %s)\",\n          pat.id,\n          pprust::pat_to_str(pat, cx.sess.intr()))\n }\n \n-fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n+pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n     let tstrs = ts.map(|t| ty_to_str(cx, *t));\n     fmt!(\"(%s)\", str::connect(tstrs, \", \"))\n }\n \n-fn bound_to_str(cx: ctxt, b: param_bound) -> ~str {\n+pub fn bound_to_str(cx: ctxt, b: param_bound) -> ~str {\n     ty::param_bound_to_str(cx, &b)\n }\n \n-fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n+pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n     fmt!(\"fn%s -> %s\",\n          tys_to_str(cx, typ.inputs.map(|a| a.ty)),\n          ty_to_str(cx, typ.output))\n }\n \n-fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n+pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn fn_input_to_str(cx: ctxt, input: ty::arg) -> ~str {\n         let ty::arg {mode: mode, ty: ty} = input;\n         let modestr = match canon_mode(cx, mode) {\n@@ -449,10 +448,10 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n }\n \n-fn parameterized(cx: ctxt,\n-                 base: &str,\n-                 self_r: Option<ty::Region>,\n-                 tps: &[ty::t]) -> ~str {\n+pub fn parameterized(cx: ctxt,\n+                     base: &str,\n+                     self_r: Option<ty::Region>,\n+                     tps: &[ty::t]) -> ~str {\n \n     let r_str = match self_r {\n       None => ~\"\",\n@@ -469,7 +468,7 @@ fn parameterized(cx: ctxt,\n     }\n }\n \n-fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n+pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n     let mut s = encoder::encoded_ty(cx, typ);\n     if str::len(s) >= 32u { s = str::slice(s, 0u, 32u); }\n     return s;"}]}