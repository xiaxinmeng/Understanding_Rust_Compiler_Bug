{"sha": "f82756180bec5a8405e1fc6ee1b22949db24861f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4Mjc1NjE4MGJlYzVhODQwNWUxZmM2ZWUxYjIyOTQ5ZGIyNDg2MWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-23T21:58:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-23T21:58:58Z"}, "message": "auto merge of #7314 : bblum/rust/trait-bounds2, r=nikomatsakis\n\nFixed a merge conflict, some tests, some bitrotting, etc., from #7248.", "tree": {"sha": "76bc5be01aa0605cb212ea1b0556cd48f69facdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76bc5be01aa0605cb212ea1b0556cd48f69facdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f82756180bec5a8405e1fc6ee1b22949db24861f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f82756180bec5a8405e1fc6ee1b22949db24861f", "html_url": "https://github.com/rust-lang/rust/commit/f82756180bec5a8405e1fc6ee1b22949db24861f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f82756180bec5a8405e1fc6ee1b22949db24861f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb58b19f023f95614e4a2bc3c812614d0938a9f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb58b19f023f95614e4a2bc3c812614d0938a9f2", "html_url": "https://github.com/rust-lang/rust/commit/cb58b19f023f95614e4a2bc3c812614d0938a9f2"}, {"sha": "ba3f43e506de97109788e4a96df438b3c89f5e49", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba3f43e506de97109788e4a96df438b3c89f5e49", "html_url": "https://github.com/rust-lang/rust/commit/ba3f43e506de97109788e4a96df438b3c89f5e49"}], "stats": {"total": 763, "additions": 583, "deletions": 180}, "files": [{"sha": "625424ac8709eaf16c546410b6f951337fb31c1f", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -2,7 +2,7 @@\n \" Language:     Rust\n \" Maintainer:   Patrick Walton <pcwalton@mozilla.com>\n \" Maintainer:   Ben Blum <bblum@cs.cmu.edu>\n-\" Last Change:  2012 Dec 25\n+\" Last Change:  2012 Jun 14\n \n if version < 600\n   syntax clear\n@@ -13,13 +13,16 @@ endif\n syn keyword   rustConditional match if else\n syn keyword   rustOperator    as\n \n+syn match     rustAssert      \"\\<assert\\(\\w\\)*!\"\n+syn match     rustFail        \"\\<fail\\(\\w\\)*!\"\n syn keyword   rustKeyword     break copy do drop extern\n syn keyword   rustKeyword     for if impl let log\n syn keyword   rustKeyword     copy do extern\n syn keyword   rustKeyword     for impl let log\n syn keyword   rustKeyword     loop mod once priv pub\n syn keyword   rustKeyword     return\n-syn keyword   rustKeyword     unsafe use while\n+syn keyword   rustKeyword     unsafe while\n+syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite\n \" FIXME: Scoped impl's name is also fallen in this category\n syn keyword   rustKeyword     mod trait struct enum type nextgroup=rustIdentifier skipwhite\n syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite\n@@ -45,7 +48,8 @@ syn keyword   rustType        c_longlong c_ulonglong intptr_t uintptr_t\n syn keyword   rustType        off_t dev_t ino_t pid_t mode_t ssize_t\n \n syn keyword   rustTrait       Const Copy Send Owned Sized \" inherent traits\n-syn keyword   rustTrait       Eq Ord Num Ptr\n+syn keyword   rustTrait       Clone Decodable Encodable IterBytes Rand ToStr\n+syn keyword   rustTrait       Eq Ord TotalEq TotalOrd Num Ptr\n syn keyword   rustTrait       Drop Add Sub Mul Quot Rem Neg BitAnd BitOr\n syn keyword   rustTrait       BitXor Shl Shr Index\n \n@@ -72,19 +76,21 @@ syn keyword   rustConstant    STDIN_FILENO STDOUT_FILENO STDERR_FILENO\n \" If foo::bar changes to foo.bar, change this (\"::\" to \"\\.\").\n \" If foo::bar changes to Foo::bar, change this (first \"\\w\" to \"\\u\").\n syn match     rustModPath     \"\\w\\(\\w\\)*::[^<]\"he=e-3,me=e-3\n+syn match     rustModPath     \"\\w\\(\\w\\)*\" contained \" only for 'use path;'\n syn match     rustModPathSep  \"::\"\n \n syn match     rustFuncCall    \"\\w\\(\\w\\)*(\"he=e-1,me=e-1\n syn match     rustFuncCall    \"\\w\\(\\w\\)*::<\"he=e-3,me=e-3 \" foo::<T>();\n \n-syn match     rustMacro       '\\w\\(\\w\\)*!'\n-syn match     rustMacro       '#\\w\\(\\w\\)*'\n+syn match     rustMacro       '\\w\\(\\w\\)*!' contains=rustAssert,rustFail\n+syn match     rustMacro       '#\\w\\(\\w\\)*' contains=rustAssert,rustFail\n \n syn match     rustFormat      display \"%\\(\\d\\+\\$\\)\\=[-+' #0*]*\\(\\d*\\|\\*\\|\\*\\d\\+\\$\\)\\(\\.\\(\\d*\\|\\*\\|\\*\\d\\+\\$\\)\\)\\=\\([hlLjzt]\\|ll\\|hh\\)\\=\\([aAbdiuoxXDOUfFeEgGcCsSpn?]\\|\\[\\^\\=.[^]]*\\]\\)\" contained\n syn match     rustFormat      display \"%%\" contained\n syn region    rustString      start=+L\\=\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustTodo,rustFormat\n \n-syn region    rustAttribute   start=\"#\\[\" end=\"\\]\" contains=rustString\n+syn region    rustAttribute   start=\"#\\[\" end=\"\\]\" contains=rustString,rustDeriving\n+syn region    rustDeriving    start=\"deriving(\" end=\")\" contains=rustTrait\n \n \" Number literals\n syn match     rustNumber      display \"\\<[0-9][0-9_]*\\>\"\n@@ -143,11 +149,17 @@ hi def link rustMacro         Macro\n hi def link rustType          Type\n hi def link rustTodo          Todo\n hi def link rustAttribute     PreProc\n+hi def link rustDeriving      PreProc\n hi def link rustStorage       StorageClass\n hi def link rustLifetime      Special\n \n \" Other Suggestions:\n+\" hi rustAttribute ctermfg=cyan\n+\" hi rustDeriving ctermfg=cyan\n+\" hi rustAssert ctermfg=yellow\n+\" hi rustFail ctermfg=red\n \" hi rustMacro ctermfg=magenta\n+\" hi rustModPathSep ctermfg=grey\n \n syn sync minlines=200\n syn sync maxlines=500"}, {"sha": "94cad18ece2cdcf8f702bf8be515e1c0e0ffe4b1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -954,7 +954,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(path, _) if path.idents.len() == 1 => {\n+            ast::ty_path(path, bounds, _) if path.idents.len() == 1 => {\n+                assert!(bounds.is_empty());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));\n             }"}, {"sha": "b53bdcc9bbe0bf2870e880c6fe6aeb3585a34b79", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -311,8 +311,9 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let substs = parse_substs(st, conv);\n         let store = parse_trait_store(st);\n         let mt = parse_mutability(st);\n+        let bounds = parse_bounds(st, conv);\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, def, substs, store, mt);\n+        return ty::mk_trait(st.tcx, def, substs, store, mt, bounds.builtin_bounds);\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, conv);"}, {"sha": "dd62a8e11cb7f797bfdc052bcad007cbdc0dda89", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -261,13 +261,16 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n-      ty::ty_trait(def, ref substs, store, mt) => {\n+      ty::ty_trait(def, ref substs, store, mt, bounds) => {\n         w.write_str(&\"x[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n         enc_substs(w, cx, substs);\n         enc_trait_store(w, cx, store);\n         enc_mutability(w, mt);\n+        let bounds = ty::ParamBounds {builtin_bounds: bounds,\n+                                      trait_bounds: ~[]};\n+        enc_bounds(w, cx, &bounds);\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) => {"}, {"sha": "7f7a81fa974a6bb69cc4b797acb4d1be0db1dd60", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 83, "deletions": 40, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -81,8 +81,6 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-type check_fn = @fn(Context, @freevar_entry);\n-\n fn check_struct_safe_for_destructor(cx: Context,\n                                     span: span,\n                                     struct_did: def_id) {\n@@ -129,7 +127,8 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n                         if cx.tcx.lang_items.drop_trait() == trait_def_id {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n-                                ty_path(_, path_node_id) => {\n+                                ty_path(_, bounds, path_node_id) => {\n+                                    assert!(bounds.is_empty());\n                                     let struct_def = cx.tcx.def_map.get_copy(\n                                         &path_node_id);\n                                     let struct_did =\n@@ -162,30 +161,43 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n-    fn check_for_uniq(cx: Context, fv: @freevar_entry) {\n+fn with_appropriate_checker(cx: Context, id: node_id,\n+                            b: &fn(checker: &fn(Context, @freevar_entry))) {\n+    fn check_for_uniq(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n+\n+        // FIXME(#3569): Once closure capabilities are restricted based on their\n+        // incoming bounds, make this check conditional based on the bounds.\n         if !check_owned(cx, var_t, fv.span) { return; }\n \n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n+\n+        check_freevar_bounds(cx, fv.span, var_t, bounds);\n     }\n \n-    fn check_for_box(cx: Context, fv: @freevar_entry) {\n+    fn check_for_box(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n+\n+        // FIXME(#3569): Once closure capabilities are restricted based on their\n+        // incoming bounds, make this check conditional based on the bounds.\n         if !check_durable(cx.tcx, var_t, fv.span) { return; }\n \n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n+\n+        check_freevar_bounds(cx, fv.span, var_t, bounds);\n     }\n \n-    fn check_for_block(_cx: Context, _fv: @freevar_entry) {\n-        // no restrictions\n+    fn check_for_block(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n+        let id = ast_util::def_id_of_def(fv.def).node;\n+        let var_t = ty::node_id_to_type(cx.tcx, id);\n+        check_freevar_bounds(cx, fv.span, var_t, bounds);\n     }\n \n     fn check_for_bare(cx: Context, fv: @freevar_entry) {\n@@ -196,14 +208,14 @@ fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::get(fty).sty {\n-        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, _}) => {\n-            b(check_for_uniq)\n+        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, bounds: bounds, _}) => {\n+            b(|cx, fv| check_for_uniq(cx, fv, bounds))\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, _}) => {\n-            b(check_for_box)\n+        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, bounds: bounds, _}) => {\n+            b(|cx, fv| check_for_box(cx, fv, bounds))\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, _}) => {\n-            b(check_for_block)\n+        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, bounds: bounds, _}) => {\n+            b(|cx, fv| check_for_block(cx, fv, bounds))\n         }\n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n@@ -271,15 +283,21 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n                       type_param_defs.repr(cx.tcx));\n             }\n             for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n-                check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n+                check_typaram_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n             }\n         }\n     }\n \n     match e.node {\n         expr_cast(source, _) => {\n             check_cast_for_escaping_regions(cx, source, e);\n-            check_kind_bounds_of_cast(cx, source, e);\n+            match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n+                ty::ty_trait(_, _, store, _, bounds) => {\n+                    let source_ty = ty::expr_ty(cx.tcx, source);\n+                    check_trait_cast_bounds(cx, e.span, source_ty, bounds, store)\n+                }\n+                _ => { }\n+            }\n         }\n         expr_copy(expr) => {\n             // Note: This is the only place where we must check whether the\n@@ -307,14 +325,14 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n \n fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n-      ty_path(_, id) => {\n+      ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n           for r.iter().advance |ts| {\n               let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n               let type_param_defs =\n                   ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n               for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n-                  check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n+                  check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n               }\n           }\n       }\n@@ -323,20 +341,29 @@ fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n     visit::visit_ty(aty, (cx, v));\n }\n \n-pub fn check_bounds(cx: Context,\n-                    _type_parameter_id: node_id,\n-                    sp: span,\n-                    ty: ty::t,\n-                    type_param_def: &ty::TypeParameterDef)\n+// Calls \"any_missing\" if any bounds were missing.\n+pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n+                            any_missing: &fn(ty::BuiltinBounds))\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ty::EmptyBuiltinBounds();\n-    for type_param_def.bounds.builtin_bounds.each |bound| {\n+    for bounds.each |bound| {\n         if !kind.meets_bound(cx.tcx, bound) {\n             missing.add(bound);\n         }\n     }\n     if !missing.is_empty() {\n+        any_missing(missing);\n+    }\n+}\n+\n+pub fn check_typaram_bounds(cx: Context,\n+                    _type_parameter_id: node_id,\n+                    sp: span,\n+                    ty: ty::t,\n+                    type_param_def: &ty::TypeParameterDef)\n+{\n+    do check_builtin_bounds(cx, ty, type_param_def.bounds.builtin_bounds) |missing| {\n         cx.tcx.sess.span_err(\n             sp,\n             fmt!(\"instantiating a type parameter with an incompatible type \\\n@@ -346,6 +373,38 @@ pub fn check_bounds(cx: Context,\n     }\n }\n \n+pub fn check_freevar_bounds(cx: Context, sp: span, ty: ty::t,\n+                            bounds: ty::BuiltinBounds)\n+{\n+    do check_builtin_bounds(cx, ty, bounds) |missing| {\n+        cx.tcx.sess.span_err(\n+            sp,\n+            fmt!(\"cannot capture variable of type `%s`, which does not fulfill \\\n+                  `%s`, in a bounded closure\",\n+                 ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx)));\n+        cx.tcx.sess.span_note(\n+            sp,\n+            fmt!(\"this closure's environment must satisfy `%s`\",\n+                 bounds.user_string(cx.tcx)));\n+    }\n+}\n+\n+pub fn check_trait_cast_bounds(cx: Context, sp: span, ty: ty::t,\n+                               bounds: ty::BuiltinBounds, store: ty::TraitStore) {\n+    do check_builtin_bounds(cx, ty, bounds) |missing| {\n+        cx.tcx.sess.span_err(sp,\n+            fmt!(\"cannot pack type `%s`, which does not fulfill \\\n+                  `%s`, as a trait bounded by %s\",\n+                 ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n+                 bounds.user_string(cx.tcx)));\n+    }\n+    // FIXME(#3569): Remove this check when the corresponding restriction\n+    // is made with type contents.\n+    if store == ty::UniqTraitStore && !ty::type_is_owned(cx.tcx, ty) {\n+        cx.tcx.sess.span_err(sp, \"uniquely-owned trait objects must be sendable\");\n+    }\n+}\n+\n fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n@@ -528,19 +587,3 @@ pub fn check_cast_for_escaping_regions(\n         cx.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n }\n-\n-/// Ensures that values placed into a ~Trait are copyable and sendable.\n-pub fn check_kind_bounds_of_cast(cx: Context, source: @expr, target: @expr) {\n-    let target_ty = ty::expr_ty(cx.tcx, target);\n-    match ty::get(target_ty).sty {\n-        ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n-            let source_ty = ty::expr_ty(cx.tcx, source);\n-            if !ty::type_is_owned(cx.tcx, source_ty) {\n-                cx.tcx.sess.span_err(\n-                    target.span,\n-                    \"uniquely-owned trait objects must be sendable\");\n-            }\n-        }\n-        _ => {} // Nothing to do.\n-    }\n-}"}, {"sha": "821aed731c2298d108cd36308e26d721b90b5713", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -714,7 +714,7 @@ fn check_item_ctypes(cx: &Context, it: @ast::item) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n-              ast::ty_path(_, id) => {\n+              ast::ty_path(_, _, id) => {\n                 match cx.tcx.def_map.get_copy(&id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n                     cx.span_lint(ctypes, ty.span,"}, {"sha": "0e6d8617ba424003c580b886d4326a77cb719055", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -804,7 +804,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     // then check whether it is region-parameterized and consider\n     // that as a direct dependency.\n     match ty.node {\n-      ast::ty_path(path, id) => {\n+      ast::ty_path(path, _bounds, id) => {\n         match cx.def_map.find(&id) {\n           Some(&ast::def_ty(did)) |\n           Some(&ast::def_trait(did)) |\n@@ -840,7 +840,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         visit_mt(mt, (cx, visitor));\n       }\n \n-      ast::ty_path(path, _) => {\n+      ast::ty_path(path, _bounds, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.iter().advance |tp| {"}, {"sha": "eed0b12b9e123a0f89807336c05e60e94babb1d6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -1250,7 +1250,7 @@ impl Resolver {\n                 // If there are static methods, then create the module\n                 // and add them.\n                 match (trait_ref_opt, ty) {\n-                    (None, @Ty { node: ty_path(path, _), _ }) if\n+                    (None, @Ty { node: ty_path(path, _, _), _ }) if\n                             has_static_methods && path.idents.len() == 1 => {\n                         let name = path_to_ident(path);\n \n@@ -4120,7 +4120,7 @@ impl Resolver {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n-            ty_path(path, path_id) => {\n+            ty_path(path, bounds, path_id) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // scopes looking for it.\n                 let mut result_def = None;\n@@ -4179,6 +4179,10 @@ impl Resolver {\n                                            self.idents_to_str(path.idents)));\n                     }\n                 }\n+\n+                for bounds.each |bound| {\n+                    self.resolve_type_parameter_bound(bound, visitor);\n+                }\n             }\n \n             ty_closure(c) => {"}, {"sha": "11eecf82bacaf7416ed26b1916cb55e8b5573feb", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -561,7 +561,7 @@ fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n             cx.sess.span_note(span, \"debuginfo for closure NYI\");\n             create_unimpl_ty(cx, t)\n         },\n-        ty::ty_trait(_did, ref _substs, ref _vstore, _) => {\n+        ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n             cx.sess.span_note(span, \"debuginfo for trait NYI\");\n             create_unimpl_ty(cx, t)\n         },"}, {"sha": "7d86f743a8e48a92529692c9b5756dc774c416a2", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -683,7 +683,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_cast(val, _) => {\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n-                ty::ty_trait(_, _, store, _) => {\n+                ty::ty_trait(_, _, store, _, _) => {\n                     return meth::trans_trait_cast(bcx, val, expr.id, dest,\n                                                   store);\n                 }"}, {"sha": "d8ba524b2bd117657629874255251df39c57b0ea", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -486,13 +486,13 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v0, t, drop_ty)\n       }\n-      ty::ty_trait(_, _, ty::BoxTraitStore, _) => {\n+      ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n           let llbox_ptr = GEPi(bcx, v0, [0u, abi::trt_field_box]);\n           let llbox = Load(bcx, llbox_ptr);\n           decr_refcnt_maybe_free(bcx, llbox, Some(llbox_ptr),\n                                  ty::mk_opaque_box(ccx.tcx))\n       }\n-      ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n+      ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n           let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n           // Only drop the value when it is non-null\n           do with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue))) |bcx| {\n@@ -571,12 +571,12 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n-      ty::ty_trait(_, _, ty::BoxTraitStore, _) => {\n+      ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]));\n         incr_refcnt_of_boxed(bcx, llbox);\n         bcx\n       }\n-      ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n+      ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n           let lluniquevalue = GEPi(bcx, v, [0, abi::trt_field_box]);\n           let llvtable = Load(bcx, GEPi(bcx, v, [0, abi::trt_field_vtable]));\n "}, {"sha": "4f4bbf84a72bff5cf9eff4e11fbc8330f12a484d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -293,7 +293,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n         ty::ty_closure(ref fty) => {\n             Some(normalized_closure_ty(tcx, fty.sigil))\n         }\n-        ty::ty_trait(_, _, ref store, _) => {\n+        ty::ty_trait(_, _, ref store, _, _) => {\n             let sigil = match *store {\n                 ty::UniqTraitStore => ast::OwnedSigil,\n                 ty::BoxTraitStore => ast::ManagedSigil,"}, {"sha": "6a40c1f75e9eee41f6ea2e0d9faeb4888a268e93", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -160,7 +160,7 @@ fn traverse_ty<'a>(ty: @Ty, (cx, v): (@mut ctx<'a>, visit::vt<@mut ctx<'a>>)) {\n     }\n \n     match ty.node {\n-      ty_path(p, p_id) => {\n+      ty_path(p, _bounds, p_id) => {\n         match cx.tcx.def_map.find(&p_id) {\n           // Kind of a hack to check this here, but I'm not sure what else\n           // to do"}, {"sha": "316eb6893f25b8111fefbbae7977f7d606b096f8", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -335,7 +335,7 @@ impl Reflector {\n           }\n \n           // Miscallaneous extra types\n-          ty::ty_trait(_, _, _, _) => self.leaf(~\"trait\"),\n+          ty::ty_trait(_, _, _, _, _) => self.leaf(~\"trait\"),\n           ty::ty_infer(_) => self.leaf(~\"infer\"),\n           ty::ty_err => self.leaf(~\"err\"),\n           ty::ty_param(ref p) => {"}, {"sha": "3699314a1d2cf561d051c826af90b003f0b81f47", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -140,7 +140,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n         ty::ty_bare_fn(*) => Type::i8p(),\n         ty::ty_closure(*) => Type::struct_([Type::i8p(), Type::i8p()], false),\n-        ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n+        ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n \n         ty::ty_estr(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n         ty::ty_evec(mt, ty::vstore_fixed(size)) => {\n@@ -271,7 +271,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n           let ty = type_of_fn_from_ty(cx, t);\n           Type::func_pair(cx, &ty)\n       }\n-      ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n+      ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n       ty::ty_type => cx.tydesc_type.ptr_to(),\n       ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);"}, {"sha": "f2446d1a11536e71359152be9b57e725505a069b", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -208,7 +208,7 @@ pub fn type_needs_inner(cx: Context,\n                 ty::ty_bare_fn(*) |\n                 ty::ty_ptr(_) |\n                 ty::ty_rptr(_, _) |\n-                ty::ty_trait(_, _, _, _) => false,\n+                ty::ty_trait(*) => false,\n \n               ty::ty_enum(did, ref substs) => {\n                 if list::find(enums_seen, |id| *id == did).is_none() {"}, {"sha": "90cd8a8665ea7cb7fb6b5c068ee842d8c99a92a6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -419,7 +419,8 @@ impl to_bytes::IterBytes for ClosureTy {\n         self.sigil.iter_bytes(lsb0, f) &&\n         self.onceness.iter_bytes(lsb0, f) &&\n         self.region.iter_bytes(lsb0, f) &&\n-        self.sig.iter_bytes(lsb0, f)\n+        self.sig.iter_bytes(lsb0, f) &&\n+        self.bounds.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -600,7 +601,7 @@ pub enum sty {\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n     ty_closure(ClosureTy),\n-    ty_trait(def_id, substs, TraitStore, ast::mutability),\n+    ty_trait(def_id, substs, TraitStore, ast::mutability, BuiltinBounds),\n     ty_struct(def_id, substs),\n     ty_tup(~[t]),\n \n@@ -1046,7 +1047,7 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n       &ty_infer(_) => flags |= needs_infer as uint,\n       &ty_self(_) => flags |= has_self as uint,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) |\n-      &ty_trait(_, ref substs, _, _) => {\n+      &ty_trait(_, ref substs, _, _, _) => {\n         flags |= sflags(substs);\n       }\n       &ty_box(ref m) | &ty_uniq(ref m) | &ty_evec(ref m, _) |\n@@ -1268,10 +1269,11 @@ pub fn mk_trait(cx: ctxt,\n                 did: ast::def_id,\n                 substs: substs,\n                 store: TraitStore,\n-                mutability: ast::mutability)\n+                mutability: ast::mutability,\n+                bounds: BuiltinBounds)\n              -> t {\n     // take a copy of substs so that we own the vectors inside\n-    mk_t(cx, ty_trait(did, substs, store, mutability))\n+    mk_t(cx, ty_trait(did, substs, store, mutability, bounds))\n }\n \n pub fn mk_struct(cx: ctxt, struct_id: ast::def_id, substs: substs) -> t {\n@@ -1319,7 +1321,7 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n-      ty_trait(_, ref substs, _, _) => {\n+      ty_trait(_, ref substs, _, _, _) => {\n         for (*substs).tps.iter().advance |subty| { maybe_walk_ty(*subty, f); }\n       }\n       ty_tup(ref ts) => { for ts.iter().advance |tt| { maybe_walk_ty(*tt, f); } }\n@@ -1380,8 +1382,8 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n         ty_enum(tid, ref substs) => {\n             ty_enum(tid, fold_substs(substs, fldop))\n         }\n-        ty_trait(did, ref substs, st, mutbl) => {\n-            ty_trait(did, fold_substs(substs, fldop), st, mutbl)\n+        ty_trait(did, ref substs, st, mutbl, bounds) => {\n+            ty_trait(did, fold_substs(substs, fldop), st, mutbl, bounds)\n         }\n         ty_tup(ref ts) => {\n             let new_ts = ts.map(|tt| fldop(*tt));\n@@ -1470,8 +1472,12 @@ pub fn fold_regions_and_ty(\n       ty_struct(def_id, ref substs) => {\n         ty::mk_struct(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      ty_trait(def_id, ref substs, st, mutbl) => {\n-        ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), st, mutbl)\n+      ty_trait(def_id, ref substs, st, mutbl, bounds) => {\n+        let st = match st {\n+            RegionTraitStore(region) => RegionTraitStore(fldr(region)),\n+            st => st,\n+        };\n+        ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), st, mutbl, bounds)\n       }\n       ty_bare_fn(ref f) => {\n           ty::mk_bare_fn(cx, BareFnTy {sig: fold_sig(&f.sig, fldfnt),\n@@ -1850,7 +1856,7 @@ impl TypeContents {\n     }\n \n     pub fn noncopyable(_cx: ctxt) -> TypeContents {\n-        TC_DTOR + TC_BORROWED_MUT + TC_ONCE_CLOSURE + TC_OWNED_CLOSURE +\n+        TC_DTOR + TC_BORROWED_MUT + TC_ONCE_CLOSURE + TC_NONCOPY_TRAIT +\n             TC_EMPTY_ENUM\n     }\n \n@@ -1899,13 +1905,19 @@ impl TypeContents {\n     }\n \n     pub fn needs_drop(&self, cx: ctxt) -> bool {\n+        if self.intersects(TC_NONCOPY_TRAIT) {\n+            // Currently all noncopyable existentials are 2nd-class types\n+            // behind owned pointers. With dynamically-sized types, remove\n+            // this assertion.\n+            assert!(self.intersects(TC_OWNED_POINTER));\n+        }\n         let tc = TC_MANAGED + TC_DTOR + TypeContents::owned(cx);\n         self.intersects(tc)\n     }\n \n     pub fn owned(_cx: ctxt) -> TypeContents {\n         //! Any kind of owned contents.\n-        TC_OWNED_CLOSURE + TC_OWNED_POINTER + TC_OWNED_VEC\n+        TC_OWNED_POINTER + TC_OWNED_VEC\n     }\n }\n \n@@ -1939,8 +1951,8 @@ static TC_OWNED_POINTER: TypeContents =    TypeContents{bits: 0b0000_0000_0010};\n /// Contains an owned vector ~[] or owned string ~str\n static TC_OWNED_VEC: TypeContents =        TypeContents{bits: 0b0000_0000_0100};\n \n-/// Contains a ~fn() or a ~Trait, which is non-copyable.\n-static TC_OWNED_CLOSURE: TypeContents =    TypeContents{bits: 0b0000_0000_1000};\n+/// Contains a non-copyable ~fn() or a ~Trait (NOT a ~fn:Copy() or ~Trait:Copy).\n+static TC_NONCOPY_TRAIT: TypeContents =    TypeContents{bits: 0b0000_0000_1000};\n \n /// Type with a destructor\n static TC_DTOR: TypeContents =             TypeContents{bits: 0b0000_0001_0000};\n@@ -2054,18 +2066,19 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_MANAGED + statically_sized(nonowned(tc_mt(cx, mt, cache)))\n             }\n \n-            ty_trait(_, _, UniqTraitStore, _) => {\n-                TC_OWNED_CLOSURE\n+            ty_trait(_, _, UniqTraitStore, _, _bounds) => {\n+                // FIXME(#3569): Make this conditional on the trait's bounds.\n+                TC_NONCOPY_TRAIT + TC_OWNED_POINTER\n             }\n \n-            ty_trait(_, _, BoxTraitStore, mutbl) => {\n+            ty_trait(_, _, BoxTraitStore, mutbl, _bounds) => {\n                 match mutbl {\n                     ast::m_mutbl => TC_MANAGED + TC_MUTABLE,\n                     _ => TC_MANAGED\n                 }\n             }\n \n-            ty_trait(_, _, RegionTraitStore(r), mutbl) => {\n+            ty_trait(_, _, RegionTraitStore(r), mutbl, _bounds) => {\n                 borrowed_contents(r, mutbl)\n             }\n \n@@ -2178,7 +2191,9 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 match sigil {\n                     ast::BorrowedSigil => TC_BORROWED_POINTER,\n                     ast::ManagedSigil => TC_MANAGED,\n-                    ast::OwnedSigil => TC_OWNED_CLOSURE\n+                    // FIXME(#3569): Looks like noncopyability should depend\n+                    // on the bounds, but I don't think this case ever comes up.\n+                    ast::OwnedSigil => TC_NONCOPY_TRAIT + TC_OWNED_POINTER,\n                 }\n             }\n \n@@ -2252,7 +2267,11 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         let st = match cty.sigil {\n             ast::BorrowedSigil => TC_BORROWED_POINTER,\n             ast::ManagedSigil => TC_MANAGED,\n-            ast::OwnedSigil => TC_OWNED_CLOSURE\n+            ast::OwnedSigil => if cty.bounds.contains_elem(BoundCopy) {\n+                TC_OWNED_POINTER\n+            } else {\n+                TC_OWNED_POINTER + TC_NONCOPY_TRAIT\n+            }\n         };\n         let rt = borrowed_contents(cty.region, m_imm);\n         let ot = match cty.onceness {\n@@ -2347,7 +2366,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 false           // unsafe ptrs can always be NULL\n             }\n \n-            ty_trait(_, _, _, _) => {\n+            ty_trait(_, _, _, _, _) => {\n                 false\n             }\n \n@@ -2500,7 +2519,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_box(_) | ty_uniq(_) | ty_closure(_) |\n       ty_estr(vstore_uniq) | ty_estr(vstore_box) |\n       ty_evec(_, vstore_uniq) | ty_evec(_, vstore_box) |\n-      ty_trait(_, _, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n+      ty_trait(_, _, _, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n@@ -2791,12 +2810,13 @@ impl to_bytes::IterBytes for sty {\n \n             ty_uniq(ref mt) => 19u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n \n-            ty_trait(ref did, ref substs, ref v, ref mutbl) => {\n+            ty_trait(ref did, ref substs, ref v, ref mutbl, bounds) => {\n                 20u8.iter_bytes(lsb0, f) &&\n                 did.iter_bytes(lsb0, f) &&\n                 substs.iter_bytes(lsb0, f) &&\n                 v.iter_bytes(lsb0, f) &&\n-                mutbl.iter_bytes(lsb0, f)\n+                mutbl.iter_bytes(lsb0, f) &&\n+                bounds.iter_bytes(lsb0, f)\n             }\n \n             ty_opaque_closure_ptr(ref ck) => 21u8.iter_bytes(lsb0, f) && ck.iter_bytes(lsb0, f),\n@@ -3440,7 +3460,7 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_rptr(_, _) => ~\"&-ptr\",\n       ty_bare_fn(_) => ~\"extern fn\",\n       ty_closure(_) => ~\"fn\",\n-      ty_trait(id, _, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n+      ty_trait(id, _, _, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n       ty_struct(id, _) => fmt!(\"struct %s\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n       ty_infer(TyVar(_)) => ~\"inferred type\",\n@@ -3774,7 +3794,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n \n pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n     match get(ty).sty {\n-      ty_trait(id, _, _, _) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n+      ty_trait(id, _, _, _, _) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n       _ => None\n     }\n }\n@@ -4454,5 +4474,6 @@ pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n     assert!(tcx.intrinsic_traits.contains_key(&ty_visitor_name));\n     let trait_ref = tcx.intrinsic_traits.get_copy(&ty_visitor_name);\n     (trait_ref,\n-     mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs, BoxTraitStore, ast::m_imm))\n+     mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs,\n+              BoxTraitStore, ast::m_imm, EmptyBuiltinBounds()))\n }"}, {"sha": "3b651451db84777061eb7dd700711caf9d678d28", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -277,7 +277,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n-            ast::ty_path(path, id) => {\n+            ast::ty_path(path, bounds, id) => {\n+                // Note that the \"bounds must be empty if path is not a trait\"\n+                // restriction is enforced in the below case for ty_path, which\n+                // will run after this as long as the path isn't a trait.\n                 match tcx.def_map.find(&id) {\n                     Some(&ast::def_prim_ty(ast::ty_str)) if a_seq_ty.mutbl == ast::m_imm => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -300,11 +303,13 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                 ty::BoxTraitStore\n                             }\n                         };\n+                        let bounds = conv_builtin_bounds(this.tcx(), bounds);\n                         return ty::mk_trait(tcx,\n                                             result.def_id,\n                                             copy result.substs,\n                                             trait_store,\n-                                            a_seq_ty.mutbl);\n+                                            a_seq_ty.mutbl,\n+                                            bounds);\n                     }\n                     _ => {}\n                 }\n@@ -395,13 +400,22 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n-      ast::ty_path(path, id) => {\n+      ast::ty_path(path, bounds, id) => {\n         let a_def = match tcx.def_map.find(&id) {\n           None => tcx.sess.span_fatal(\n               ast_ty.span, fmt!(\"unbound path %s\",\n                                 path_to_str(path, tcx.sess.intr()))),\n           Some(&d) => d\n         };\n+        // Kind bounds on path types are only supported for traits.\n+        match a_def {\n+            // But don't emit the error if the user meant to do a trait anyway.\n+            ast::def_trait(*) => { },\n+            _ if !bounds.is_empty() =>\n+                tcx.sess.span_err(ast_ty.span,\n+                    \"kind bounds can only be used on trait types\"),\n+            _ => { },\n+        }\n         match a_def {\n           ast::def_trait(_) => {\n               let path_str = path_to_str(path, tcx.sess.intr());"}, {"sha": "60855e6cd96987b7415fc11854a6c6155d6c83e2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -292,7 +292,7 @@ impl<'self> LookupContext<'self> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, p);\n                 }\n-                ty_trait(did, ref substs, store, _) => {\n+                ty_trait(did, ref substs, store, _, _) => {\n                     self.push_inherent_candidates_from_trait(\n                         self_ty, did, substs, store);\n                     self.push_inherent_impl_candidates_for_type(did);"}, {"sha": "69d4d82d15f28e5b49ae9e29c152f79ec5b6b6ba", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -360,7 +360,7 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             // explaining how it goes about doing that.\n             let target_ty = rcx.resolve_node_type(expr.id);\n             match ty::get(target_ty).sty {\n-                ty::ty_trait(_, _, ty::RegionTraitStore(trait_region), _) => {\n+                ty::ty_trait(_, _, ty::RegionTraitStore(trait_region), _, _) => {\n                     let source_ty = rcx.fcx.expr_ty(source);\n                     constrain_regions_in_type(rcx, trait_region,\n                                               expr.span, source_ty);"}, {"sha": "bd78e9cc5fb46cbb98dc187580dc3a172f0f53e8", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -139,10 +139,11 @@ fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n                          ty::RegionTraitStore(ty::re_static),\n-                         ast::m_imm);\n+                         ast::m_imm,\n+                         ty::EmptyBuiltinBounds());\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n-          ty::ty_trait(_, ref substs_f, _, _) => (/*bad*/copy *substs_f),\n+          ty::ty_trait(_, ref substs_f, _, _, _) => (/*bad*/copy *substs_f),\n           _ => fail!(\"t_f should be a trait\")\n         }\n     }\n@@ -530,7 +531,9 @@ pub fn early_resolve_expr(ex: @ast::expr,\n           debug!(\"vtable resolution on expr %s\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n-              ty::ty_trait(target_def_id, ref target_substs, store, target_mutbl) => {\n+              // Bounds of type's contents are not checked here, but in kind.rs.\n+              ty::ty_trait(target_def_id, ref target_substs, store,\n+                           target_mutbl, _bounds) => {\n                   fn mutability_allowed(a_mutbl: ast::mutability,\n                                         b_mutbl: ast::mutability) -> bool {\n                       a_mutbl == b_mutbl ||"}, {"sha": "7ad27077cd8673f2e8ecd632360561a772a14358", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -114,7 +114,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n     do ty::walk_ty(original_type) |t| {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n-            ty_trait(def_id, _, _, _) |\n+            ty_trait(def_id, _, _, _, _) |\n             ty_struct(def_id, _) => {\n                 if def_id.crate == ast::local_crate {\n                     found_nominal = true;\n@@ -140,7 +140,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n             match get(base_type).sty {\n                 ty_enum(def_id, _) |\n                 ty_struct(def_id, _) |\n-                ty_trait(def_id, _, _, _) => {\n+                ty_trait(def_id, _, _, _, _) => {\n                     return Some(def_id);\n                 }\n                 _ => {\n@@ -753,7 +753,7 @@ impl CoherenceChecker {\n     pub fn ast_type_is_defined_in_local_crate(&self, original_type: @ast::Ty)\n                                               -> bool {\n         match original_type.node {\n-            ty_path(_, path_id) => {\n+            ty_path(_, _, path_id) => {\n                 match self.crate_context.tcx.def_map.get_copy(&path_id) {\n                     def_ty(def_id) | def_struct(def_id) => {\n                         if def_id.crate != local_crate {"}, {"sha": "884f72b57f081cc4b08491719df634bf939d87b9", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -508,13 +508,15 @@ pub fn super_tys<C:Combine>(\n           }\n       }\n \n-      (&ty::ty_trait(a_id, ref a_substs, a_store, a_mutbl),\n-       &ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl))\n+      (&ty::ty_trait(a_id, ref a_substs, a_store, a_mutbl, a_bounds),\n+       &ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl, b_bounds))\n       if a_id == b_id && a_mutbl == b_mutbl => {\n           let trait_def = ty::lookup_trait_def(tcx, a_id);\n           do this.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n               do this.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n-                  Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s, a_mutbl))\n+                  do this.bounds(a_bounds, b_bounds).chain |bounds| {\n+                    Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s, a_mutbl, bounds))\n+                  }\n               }\n           }\n       }"}, {"sha": "1bfe452f25e09a54448abb6a6ed8ed228a2d66a1", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -717,10 +717,11 @@ impl InferCtxt {\n                                   trait_ref.def_id,\n                                   copy trait_ref.substs,\n                                   ty::UniqTraitStore,\n-                                  ast::m_imm);\n+                                  ast::m_imm,\n+                                  ty::EmptyBuiltinBounds());\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {\n-            ty::ty_trait(ref def_id, ref substs, _, _) => {\n+            ty::ty_trait(ref def_id, ref substs, _, _, _) => {\n                 ty::TraitRef {def_id: *def_id,\n                               substs: copy *substs}\n             }"}, {"sha": "e25267f4441236f4aeea9775125fb829b904fb4d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -365,6 +365,11 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n         s.push_str(\"fn\");\n \n+        if !cty.bounds.is_empty() {\n+            s.push_str(\":\");\n+        }\n+        s.push_str(cty.bounds.repr(cx));\n+\n         push_sig_to_str(cx, &mut s, &cty.sig);\n \n         return s;\n@@ -451,11 +456,14 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n         parameterized(cx, base, substs.self_r, substs.tps)\n       }\n-      ty_trait(did, ref substs, s, mutbl) => {\n+      ty_trait(did, ref substs, s, mutbl, ref bounds) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n         let ty = parameterized(cx, base, substs.self_r, substs.tps);\n-        fmt!(\"%s%s%s\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty)\n+        let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n+        let bound_str = bounds.repr(cx);\n+        fmt!(\"%s%s%s%s%s\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n+                           bound_sep, bound_str)\n       }\n       ty_evec(ref mt, vs) => {\n         vstore_ty_to_str(cx, mt, vs)"}, {"sha": "2e3d557daa90f21a00e8be83040281e072840723", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -797,7 +797,7 @@ pub enum ty_ {\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),\n-    ty_path(@Path, node_id),\n+    ty_path(@Path, @OptVec<TyParamBound>, node_id),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not"}, {"sha": "24cf5662a36b1c372bbce9c58a4b2df4d6c36349", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -473,7 +473,7 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n \n         visit_ty: |ty, (t, vt)| {\n             match ty.node {\n-              ty_path(_, id) => vfn(id, copy t),\n+              ty_path(_, _, id) => vfn(id, copy t),\n               _ => { /* fall through */ }\n             }\n             visit::visit_ty(ty, (t, vt));"}, {"sha": "b63997944774526ca97c11fcfeb2637f248394cd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -48,7 +48,7 @@ pub trait AstBuilder {\n     fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n \n     fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n-    fn ty_path(&self, @ast::Path) -> @ast::Ty;\n+    fn ty_path(&self, @ast::Path, @OptVec<ast::TyParamBound>) -> @ast::Ty;\n     fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n \n     fn ty_rptr(&self, span: span,\n@@ -267,14 +267,17 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_path(&self, path: @ast::Path) -> @ast::Ty {\n+    fn ty_path(&self, path: @ast::Path, bounds: @OptVec<ast::TyParamBound>)\n+              -> @ast::Ty {\n         self.ty(path.span,\n-                ast::ty_path(path, self.next_id()))\n+                ast::ty_path(path, bounds, self.next_id()))\n     }\n \n+    // Might need to take bounds as an argument in the future, if you ever want\n+    // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: span, ident: ast::ident)\n         -> @ast::Ty {\n-        self.ty_path(self.path_ident(span, ident))\n+        self.ty_path(self.path_ident(span, ident), @opt_vec::Empty)\n     }\n \n     fn ty_rptr(&self,\n@@ -304,7 +307,8 @@ impl AstBuilder for @ExtCtxt {\n                               self.ident_of(\"Option\")\n                           ],\n                           None,\n-                          ~[ ty ]))\n+                          ~[ ty ]),\n+            @opt_vec::Empty)\n     }\n \n     fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field {\n@@ -342,7 +346,7 @@ impl AstBuilder for @ExtCtxt {\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.path_global(dummy_sp(), ~[p.ident]))))\n+                self.path_global(dummy_sp(), ~[p.ident]), @opt_vec::Empty)))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {"}, {"sha": "981b28afd022755ad61794203674635563cad274", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -358,7 +358,8 @@ impl<'self> TraitDef<'self> {\n \n         // Create the type of `self`.\n         let self_type = cx.ty_path(cx.path_all(span, false, ~[ type_ident ], self_lifetime,\n-                                               opt_vec::take_vec(self_ty_params)));\n+                                               opt_vec::take_vec(self_ty_params)),\n+                                   @opt_vec::Empty);\n \n         let doc_attr = cx.attribute(\n             span,"}, {"sha": "d28613f52faf795f6280e419df3b8a63e53c0e3b", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -65,7 +65,7 @@ impl<'self> Path<'self> {\n                  self_generics: &Generics)\n                  -> @ast::Ty {\n         cx.ty_path(self.to_path(cx, span,\n-                                self_ty, self_generics))\n+                                self_ty, self_generics), @opt_vec::Empty)\n     }\n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n@@ -144,7 +144,8 @@ impl<'self> Ty<'self> {\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n-                cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n+                cx.ty_path(self.to_path(cx, span, self_ty, self_generics),\n+                           @opt_vec::Empty)\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {"}, {"sha": "a20528082ab55dd59769cc1d8fc456534784838c", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -61,7 +61,7 @@ impl gen_send for message {\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars(&this.generics.ty_params)));\n+                .add_tys(cx.ty_vars(&this.generics.ty_params)), @opt_vec::Empty);\n             let args_ast = vec::append(\n                 ~[cx.arg(span, cx.ident_of(\"pipe\"), pipe_ty)],\n                 args_ast);\n@@ -117,7 +117,7 @@ impl gen_send for message {\n \n             let mut rty = cx.ty_path(path(~[next.data_name()],\n                                           span)\n-                                     .add_tys(copy next_state.tys));\n+                                     .add_tys(copy next_state.tys), @opt_vec::Empty);\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -146,7 +146,7 @@ impl gen_send for message {\n                              cx.ty_path(\n                                  path(~[this.data_name()], span)\n                                  .add_tys(cx.ty_vars(\n-                                     &this.generics.ty_params))))],\n+                                     &this.generics.ty_params)), @opt_vec::Empty))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {\n@@ -192,7 +192,7 @@ impl gen_send for message {\n \n     fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars(&self.get_generics().ty_params)))\n+          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), @opt_vec::Empty)\n     }\n }\n \n@@ -226,7 +226,7 @@ impl to_type_decls for state {\n                                 cx.ty_path(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(copy next_state.tys)))\n+                                    .add_tys(copy next_state.tys), @opt_vec::Empty))\n               }\n               None => tys\n             };\n@@ -279,7 +279,8 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                  dummy_sp())\n                             .add_tys(cx.ty_vars(\n-                                &self.generics.ty_params))))),\n+                                &self.generics.ty_params)), @opt_vec::Empty)),\n+                        @opt_vec::Empty),\n                     cx.strip_bounds(&self.generics)));\n         }\n         else {\n@@ -298,8 +299,8 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                         dummy_sp())\n                             .add_tys(cx.ty_vars_global(\n-                                &self.generics.ty_params))),\n-                                   self.proto.buffer_ty_path(cx)])),\n+                                &self.generics.ty_params)), @opt_vec::Empty),\n+                                   self.proto.buffer_ty_path(cx)]), @opt_vec::Empty),\n                     cx.strip_bounds(&self.generics)));\n         };\n         items\n@@ -384,7 +385,7 @@ impl gen_init for protocol {\n         cx.ty_path(path(~[cx.ident_of(\"super\"),\n                           cx.ident_of(\"__Buffer\")],\n                         copy self.span)\n-                   .add_tys(cx.ty_vars_global(&params)))\n+                   .add_tys(cx.ty_vars_global(&params)), @opt_vec::Empty)\n     }\n \n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {"}, {"sha": "87aaf7781fae554de9ee5d6f066d0b25eff3b83f", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -15,6 +15,7 @@ use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::pipes::ast_builder::{append_types, path};\n+use opt_vec;\n \n #[deriving(Eq)]\n pub enum direction { send, recv }\n@@ -101,7 +102,7 @@ impl state_ {\n     pub fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n-                cx.ty_vars(&self.generics.ty_params)))\n+                cx.ty_vars(&self.generics.ty_params)), @opt_vec::Empty)\n     }\n \n     /// Iterate over the states that can be reached in one message"}, {"sha": "4bd2c0a3de1ffcd02ff815adb115f96e5ed33d79", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -680,7 +680,9 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n             })\n         }\n         ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n-        ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n+        ty_path(path, bounds, id) =>\n+            ty_path(fld.fold_path(path),\n+                    @bounds.map(|x| fold_ty_param_bound(x, fld)), fld.new_id(id)),\n         ty_fixed_length_vec(ref mt, e) => {\n             ty_fixed_length_vec(\n                 fold_mt(mt, fld),"}, {"sha": "0c5731c8b29b981ad7ca8b408e41bf18b307ce3a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -494,7 +494,7 @@ mod test {\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       2),\n+                                                       @opt_vec::Empty, 2),\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n                                       node: ast::pat_ident(ast::bind_infer,\n@@ -530,7 +530,7 @@ mod test {\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       2),\n+                                                       @opt_vec::Empty, 2),\n                                                 span:sp(10,13)},\n                                     pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident("}, {"sha": "19b4d254580811b6d7a733ec22d534ffd18aa66a", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -46,7 +46,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteUnsafeBlock,\n     ObsoleteUnenforcedBound,\n     ObsoleteImplSyntax,\n-    ObsoleteTraitBoundSeparator,\n     ObsoleteMutOwnedPointer,\n     ObsoleteMutVector,\n     ObsoleteImplVisibility,\n@@ -143,10 +142,6 @@ impl Parser {\n                 \"colon-separated impl syntax\",\n                 \"write `impl Trait for Type`\"\n             ),\n-            ObsoleteTraitBoundSeparator => (\n-                \"space-separated trait bounds\",\n-                \"write `+` between trait bounds\"\n-            ),\n             ObsoleteMutOwnedPointer => (\n                 \"const or mutable owned pointer\",\n                 \"mutability inherits through `~` pointers; place the `~` box"}, {"sha": "f2443f9e533592dde6cb07f71036d61e4a289a73", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -75,7 +75,7 @@ use parse::obsolete::{ObsoleteLet, ObsoleteFieldTerminator};\n use parse::obsolete::{ObsoleteMoveInit, ObsoleteBinaryMove, ObsoleteSwap};\n use parse::obsolete::{ObsoleteSyntax, ObsoleteLowerCaseKindBounds};\n use parse::obsolete::{ObsoleteUnsafeBlock, ObsoleteImplSyntax};\n-use parse::obsolete::{ObsoleteTraitBoundSeparator, ObsoleteMutOwnedPointer};\n+use parse::obsolete::{ObsoleteMutOwnedPointer};\n use parse::obsolete::{ObsoleteMutVector, ObsoleteImplVisibility};\n use parse::obsolete::{ObsoleteRecordType, ObsoleteRecordPattern};\n use parse::obsolete::{ObsoletePostFnTySigil};\n@@ -710,8 +710,8 @@ impl Parser {\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(self.token) {\n             // NAMED TYPE\n-            let path = self.parse_path_with_tps(false);\n-            ty_path(path, self.get_id())\n+            let (path, bounds) = self.parse_type_path();\n+            ty_path(path, @bounds, self.get_id())\n         } else {\n             self.fatal(fmt!(\"expected type, found token %?\",\n                             *self.token));\n@@ -974,10 +974,8 @@ impl Parser {\n                      types: ~[] }\n     }\n \n-    // parse a path optionally with type parameters. If 'colons'\n-    // is true, then type parameters must be preceded by colons,\n-    // as in a::t::<t1,t2>\n-    pub fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n+    pub fn parse_bounded_path_with_tps(&self, colons: bool,\n+                                        before_tps: Option<&fn()>) -> @ast::Path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -987,6 +985,10 @@ impl Parser {\n             return path;\n         }\n \n+        // If the path might have bounds on it, they should be parsed before\n+        // the parameters, e.g. module::TraitName:B1+B2<T>\n+        before_tps.map_consume(|callback| callback());\n+\n         // Parse the (obsolete) trailing region parameter, if any, which will\n         // be written \"foo/&x\"\n         let rp_slash = {\n@@ -1038,6 +1040,25 @@ impl Parser {\n                      .. copy *path }\n     }\n \n+    // parse a path optionally with type parameters. If 'colons'\n+    // is true, then type parameters must be preceded by colons,\n+    // as in a::t::<t1,t2>\n+    pub fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n+        self.parse_bounded_path_with_tps(colons, None)\n+    }\n+\n+    // Like the above, but can also parse kind bounds in the case of a\n+    // path to be used as a type that might be a trait.\n+    pub fn parse_type_path(&self) -> (@ast::Path, OptVec<TyParamBound>) {\n+        let mut bounds = opt_vec::Empty;\n+        let path = self.parse_bounded_path_with_tps(false, Some(|| {\n+            // Note: this closure might not even get called in the case of a\n+            // macro-generated path. But that's the macro parser's job.\n+            bounds = self.parse_optional_ty_param_bounds();\n+        }));\n+        (path, bounds)\n+    }\n+\n     /// parses 0 or 1 lifetime\n     pub fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n         match *self.token {\n@@ -2847,16 +2868,6 @@ impl Parser {\n         spanned(lo, hi, bloc)\n     }\n \n-    fn mk_ty_path(&self, i: ident) -> @Ty {\n-        @Ty {\n-            id: self.get_id(),\n-            node: ty_path(\n-                ident_to_path(*self.last_span, i),\n-                self.get_id()),\n-            span: *self.last_span,\n-        }\n-    }\n-\n     fn parse_optional_purity(&self) -> ast::purity {\n         if self.eat_keyword(keywords::Pure) {\n             self.obsolete(*self.last_span, ObsoletePurity);\n@@ -2921,13 +2932,8 @@ impl Parser {\n                 _ => break,\n             }\n \n-            if self.eat(&token::BINOP(token::PLUS)) {\n-                loop;\n-            }\n-\n-            if is_ident_or_path(self.token) {\n-                self.obsolete(*self.span,\n-                              ObsoleteTraitBoundSeparator);\n+            if !self.eat(&token::BINOP(token::PLUS)) {\n+                break;\n             }\n         }\n \n@@ -3284,14 +3290,19 @@ impl Parser {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                ty_path(path, node_id) => {\n+                ty_path(path, @opt_vec::Empty, node_id) => {\n                     Some(@trait_ref {\n                         path: path,\n                         ref_id: node_id\n                     })\n                 }\n+                ty_path(*) => {\n+                    self.span_err(ty.span,\n+                                  \"bounded traits are only valid in type position\");\n+                    None\n+                }\n                 _ => {\n-                    self.span_err(*self.span, \"not a trait\");\n+                    self.span_err(ty.span, \"not a trait\");\n                     None\n                 }\n             };"}, {"sha": "fa22b7ceb71006026c526734669f550583c2271d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -422,7 +422,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n                       f.purity, f.onceness, &f.decl, None,\n                       Some(&generics), None);\n       }\n-      ast::ty_path(path, _) => print_path(s, path, false),\n+      ast::ty_path(path, bounds, _) => print_bounded_path(s, path, bounds),\n       ast::ty_fixed_length_vec(ref mt, v) => {\n         word(s.s, \"[\");\n         match mt.mutbl {\n@@ -1483,14 +1483,18 @@ pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n     print_expr(s, coll);\n }\n \n-pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n+fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n+               opt_bounds: Option<@OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n     for path.idents.iter().advance |id| {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         print_ident(s, *id);\n     }\n+    do opt_bounds.map_consume |bounds| {\n+        print_bounds(s, bounds);\n+    };\n     if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, \"::\"); }\n \n@@ -1511,6 +1515,15 @@ pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n     }\n }\n \n+pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n+    print_path_(s, path, colons_before_params, None)\n+}\n+\n+pub fn print_bounded_path(s: @ps, path: @ast::Path,\n+                          bounds: @OptVec<ast::TyParamBound>) {\n+    print_path_(s, path, false, Some(bounds))\n+}\n+\n pub fn print_irrefutable_pat(s: @ps, pat: @ast::pat) {\n     print_pat(s, pat, false)\n }"}, {"sha": "5aa38c0348c003e0782ad92c0998629d08150d85", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -247,13 +247,17 @@ pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n         },\n         ty_closure(ref f) => {\n             for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n-            (v.visit_ty)(f.decl.output, (e, v));\n+            (v.visit_ty)(f.decl.output, (copy e, v));\n+            visit_ty_param_bounds(&f.bounds, (e, v));\n         },\n         ty_bare_fn(ref f) => {\n             for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n-        ty_path(p, _) => visit_path(p, (e, v)),\n+        ty_path(p, bounds, _) => {\n+            visit_path(p, (copy e, v));\n+            visit_ty_param_bounds(bounds, (e, v));\n+        },\n         ty_fixed_length_vec(ref mt, ex) => {\n             (v.visit_ty)(mt.ty, (copy e, v));\n             (v.visit_expr)(ex, (copy e, v));\n@@ -328,7 +332,7 @@ pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, (e, v): (E, vt<E>)) {\n     }\n }\n \n-pub fn visit_ty_param_bounds<E: Copy>(bounds: @OptVec<TyParamBound>,\n+pub fn visit_ty_param_bounds<E: Copy>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n     for bounds.each |bound| {\n         match *bound {"}, {"sha": "0d1582bf85713b654dc3c68efa5cbb5d58cce8b6", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -58,5 +58,5 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n fn main() {\n   let nyan : @noisy  = @cat(0, 2, ~\"nyan\") as @noisy;\n-  nyan.eat(); //~ ERROR type `@noisy` does not implement any method in scope named `eat`\n+  nyan.eat(); //~ ERROR does not implement any method in scope named `eat`\n }"}, {"sha": "c3c8467233c4ddbfc28b1b1c739d92be4b7ad544", "filename": "src/test/compile-fail/closure-bounds-cant-promote-superkind-in-struct.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct X {\n+    field: @fn:Copy(),\n+}\n+\n+fn foo(blk: @fn()) -> X {\n+    return X { field: blk }; //~ ERROR expected bounds `Copy` but found no bounds\n+}\n+\n+fn main() {\n+}"}, {"sha": "0b11da14e71a9b280128172161faefd4f7ab6267", "filename": "src/test/compile-fail/closure-bounds-copy-cant-capture-noncopyable.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-copy-cant-capture-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-copy-cant-capture-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-copy-cant-capture-noncopyable.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::comm;\n+\n+// If this were legal you could use it to copy captured noncopyables.\n+// Issue (#2828)\n+\n+fn foo(blk: ~fn:Copy()) {\n+    blk();\n+}\n+\n+fn main() {\n+    let (p,c) = comm::stream();\n+    do foo {\n+        c.send(()); //~ ERROR does not fulfill `Copy`\n+    }\n+    p.recv();\n+}"}, {"sha": "cac1244a560920b3180b05f2261ad0f437b2682b", "filename": "src/test/compile-fail/closure-bounds-static-cant-capture-borrowed.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn bar(blk: &fn:'static()) {\n+}\n+\n+fn foo(x: &()) {\n+    do bar {\n+        let _ = x; //~ ERROR does not fulfill `'static`\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "a975349e7302289ce672f33226eb93d0e13093a2", "filename": "src/test/compile-fail/closure-bounds-subtype.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -1,3 +1,4 @@\n+\n fn take_any(_: &fn()) {\n }\n \n@@ -7,6 +8,9 @@ fn take_copyable(_: &fn:Copy()) {\n fn take_copyable_owned(_: &fn:Copy+Owned()) {\n }\n \n+fn take_const_owned(_: &fn:Const+Owned()) {\n+}\n+\n fn give_any(f: &fn()) {\n     take_any(f);\n     take_copyable(f); //~ ERROR expected bounds `Copy` but found no bounds\n@@ -29,6 +33,7 @@ fn give_copyable_owned(f: &fn:Copy+Owned()) {\n     take_any(f);\n     take_copyable(f);\n     take_copyable_owned(f);\n+    take_const_owned(f); //~ ERROR expected bounds `Owned+Const` but found bounds `Copy+Owned`\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "fbb0f6e46a1c4a8b2a553c31050eb13b362e2469", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -13,5 +13,5 @@ extern fn f() {\n \n fn main() {\n     // extern functions are *u8 types\n-    let _x: &fn() = f; //~ ERROR mismatched types: expected `&fn()` but found `*u8`\n+    let _x: &fn() = f; //~ ERROR found `*u8`\n }"}, {"sha": "332db60c836fc3634615a483047842ca760f4a43", "filename": "src/test/compile-fail/issue-4523.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -10,7 +10,7 @@\n \n fn foopy() {}\n \n-static f: &'static fn() = foopy; //~ ERROR mismatched types: expected `&'static fn()`\n+static f: &'static fn() = foopy; //~ ERROR found extern fn\n \n fn main () {\n     f();"}, {"sha": "fcd15a2121931c37534dec8ff7ad85b56d89f0dc", "filename": "src/test/compile-fail/issue-4972.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -16,8 +16,8 @@ pub enum TraitWrapper {\n \n fn get_tw_map<'lt>(tw: &'lt TraitWrapper) -> &'lt MyTrait {\n     match *tw {\n-        A(~ref map) => map, //~ ERROR mismatched types: expected `~MyTrait` but found a ~-box pattern\n+        A(~ref map) => map, //~ ERROR found a ~-box pattern\n     }\n }\n \n-pub fn main() {}\n\\ No newline at end of file\n+pub fn main() {}"}, {"sha": "f6fd8e29a4f4d274307b71439aaac90d8876b2db", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -17,5 +17,5 @@ fn main() {\n     let x: @Map<~str, ~str> = @HashMap::new::<~str, ~str>() as\n         @Map<~str, ~str>;\n     let y: @Map<uint, ~str> = @x;\n-    //~^ ERROR mismatched types: expected `@std::container::Map<uint,~str>`\n+    //~^ ERROR expected trait std::container::Map but found @-ptr\n }"}, {"sha": "e6a7698d0f07519326345507c16d9d0900dbb90e", "filename": "src/test/compile-fail/missing-do.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -13,7 +13,7 @@\n fn foo(f: &fn()) { f() }\n \n fn main() {\n-    ~\"\" || 42; //~ ERROR binary operation || cannot be applied to type `~str`\n-    foo || {}; //~ ERROR binary operation || cannot be applied to type `extern \"Rust\" fn(&fn())`\n+    ~\"\" || 42; //~ ERROR binary operation || cannot be applied to type\n+    foo || {}; //~ ERROR binary operation || cannot be applied to type\n     //~^ NOTE did you forget the `do` keyword for the call?\n }"}, {"sha": "88c2d49174733b1888269c063eaeae09bc239eb3", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+}\n+\n+fn a(_x: ~Foo:Owned) {\n+}\n+\n+fn b(_x: ~Foo:Owned+Copy) {\n+}\n+\n+fn c(x: ~Foo:Const+Owned) {\n+    b(x); //~ ERROR expected bounds `Copy+Owned`\n+}\n+\n+fn d(x: ~Foo) {\n+    a(x); //~ ERROR found no bounds\n+}\n+\n+fn main() { }"}, {"sha": "e9cc9575003d9884c7054784d44316e6fe546486", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+}\n+\n+// This should emit the less confusing error, not the more confusing one.\n+\n+fn foo(_x: Foo:Owned) { //~ERROR reference to trait `Foo` where a type is expected\n+}\n+\n+fn main() { }"}, {"sha": "ac88b21b456e148815e8914437e6f602b695e104", "filename": "src/test/compile-fail/trait-bounds-not-on-impl.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-impl.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+}\n+\n+struct Bar;\n+\n+impl Foo:Owned for Bar { //~ ERROR bounded traits are only valid in type position\n+}\n+\n+fn main() { }"}, {"sha": "45bb5e29a884f67540b685ce967ce837a92d3dc0", "filename": "src/test/compile-fail/trait-bounds-not-on-struct.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+fn foo(_x: ~Foo:Owned) { } //~ ERROR kind bounds can only be used on trait types\n+\n+fn main() { }"}, {"sha": "26bea0e514151e4e1e0da9f5e5fbeb04ba74f5e5", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::comm;\n+\n+fn foo(blk: ~fn:Owned()) {\n+    blk();\n+}\n+\n+fn main() {\n+    let (p,c) = comm::stream();\n+    do foo {\n+        c.send(());\n+    }\n+    p.recv();\n+}"}, {"sha": "f39c914916ff7b812084f8d81fb2254b7a0162cf", "filename": "src/test/run-pass/closure-bounds-copyable-squiggle-closure.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-pretty\n+\n+// Tests correct copying of heap closures' environments.\n+\n+fn foo(x: ~fn:Copy()) -> (~fn(), ~fn()) {\n+    (copy x, x)\n+}\n+fn main() {\n+    let v = ~[~[1,2,3],~[4,5,6]]; // shouldn't get double-freed\n+    let (f1,f2) = do foo {\n+        assert!(v.len() == 2);\n+    };\n+    f1();\n+    f2();\n+}"}, {"sha": "2fdce4e5c7cdfbb89e5c89ee309fd9cad8341bed", "filename": "src/test/run-pass/closure-bounds-squiggle-closure-as-copyable-typaram.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-pretty\n+\n+// Tests correct copying of heap closures' environments.\n+\n+fn bar<T: Copy>(x: T) -> (T, T) {\n+    (copy x, x)\n+}\n+fn foo(x: ~fn:Copy()) -> (~fn(), ~fn()) {\n+    bar(x)\n+}\n+fn main() {\n+    let v = ~[~[1,2,3],~[4,5,6]]; // shouldn't get double-freed\n+    let (f1,f2) = do foo {\n+        assert!(v.len() == 2);\n+    };\n+    f1();\n+    f2();\n+}"}, {"sha": "b9251c038afaa291f845c11f23c2a5bdb7c0fb15", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82756180bec5a8405e1fc6ee1b22949db24861f/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=f82756180bec5a8405e1fc6ee1b22949db24861f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+}\n+\n+fn a(_x: ~Foo) {\n+}\n+\n+fn b(_x: ~Foo:Owned) {\n+}\n+\n+fn c(x: ~Foo:Const+Owned) {\n+    a(x);\n+}\n+\n+fn d(x: ~Foo:Owned+Copy) {\n+    b(x);\n+}\n+\n+fn main() { }"}]}