{"sha": "1002623201c0368af2120885189fcdc979bff6fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMDI2MjMyMDFjMDM2OGFmMjEyMDg4NTE4OWZjZGM5NzliZmY2ZmU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-16T21:37:58Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-16T21:38:04Z"}, "message": "Make move-mode arguments unwind correctly. Closes #939", "tree": {"sha": "cd14a2b67b164236d205b90da521991eecab9473", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd14a2b67b164236d205b90da521991eecab9473"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1002623201c0368af2120885189fcdc979bff6fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1002623201c0368af2120885189fcdc979bff6fe", "html_url": "https://github.com/rust-lang/rust/commit/1002623201c0368af2120885189fcdc979bff6fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1002623201c0368af2120885189fcdc979bff6fe/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99236d64d05b2f58f11a5d2a55318024365ec1f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/99236d64d05b2f58f11a5d2a55318024365ec1f5", "html_url": "https://github.com/rust-lang/rust/commit/99236d64d05b2f58f11a5d2a55318024365ec1f5"}], "stats": {"total": 96, "additions": 65, "deletions": 31}, "files": [{"sha": "c46438281cb8bb346a7494e515754a31fc883c87", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1002623201c0368af2120885189fcdc979bff6fe/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1002623201c0368af2120885189fcdc979bff6fe/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1002623201c0368af2120885189fcdc979bff6fe", "patch": "@@ -3752,7 +3752,8 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n        for the call itself is unreachable. */\n     let retval = C_nil();\n     if !is_terminated(bcx) {\n-        bcx = invoke_fastcall(bcx, faddr, llargs).bcx;\n+        bcx = invoke_fastcall(bcx, faddr, llargs,\n+                              args_res.to_zero, args_res.to_revoke).bcx;\n         alt lliterbody {\n           none. {\n             if !ty::type_is_nil(bcx_tcx(cx), ret_ty) {\n@@ -3775,12 +3776,8 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         }\n \n         // Forget about anything we moved out.\n-        for {v: v, t: t}: {v: ValueRef, t: ty::t} in args_res.to_zero {\n-            bcx = zero_alloca(bcx, v, t).bcx;\n-        }\n-        for {v: v, t: t} in args_res.to_revoke {\n-            bcx = revoke_clean(bcx, v, t);\n-        }\n+        bcx = zero_and_revoke(bcx, args_res.to_zero, args_res.to_revoke);\n+\n         if !by_ref { bcx = trans_block_cleanups(bcx, cx); }\n         let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n         Br(bcx, next_cx.llbb);\n@@ -3789,45 +3786,70 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     ret {res: rslt(bcx, retval), by_ref: by_ref};\n }\n \n+fn zero_and_revoke(bcx: @block_ctxt,\n+                   to_zero: [{v: ValueRef, t: ty::t}],\n+                   to_revoke: [{v: ValueRef, t: ty::t}]) -> @block_ctxt {\n+    let bcx = bcx;\n+    for {v, t} in to_zero {\n+        bcx = zero_alloca(bcx, v, t).bcx;\n+    }\n+    for {v, t} in to_revoke {\n+        bcx = revoke_clean(bcx, v, t);\n+    }\n+    ret bcx;\n+}\n+\n fn invoke(bcx: @block_ctxt, llfn: ValueRef,\n           llargs: [ValueRef]) -> result {\n-    ret invoke_(bcx, llfn, llargs, Invoke);\n+    ret invoke_(bcx, llfn, llargs, [], [], Invoke);\n }\n \n fn invoke_fastcall(bcx: @block_ctxt, llfn: ValueRef,\n-                   llargs: [ValueRef]) -> result {\n-    ret invoke_(bcx, llfn, llargs, FastInvoke);\n+                   llargs: [ValueRef],\n+                   to_zero: [{v: ValueRef, t: ty::t}],\n+                   to_revoke: [{v: ValueRef, t: ty::t}]) -> result {\n+    ret invoke_(bcx, llfn, llargs,\n+                to_zero, to_revoke,\n+                FastInvoke);\n }\n \n-fn invoke_(bcx: @block_ctxt, llfn: ValueRef,\n-           llargs: [ValueRef],\n+fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n+           to_zero: [{v: ValueRef, t: ty::t}],\n+           to_revoke: [{v: ValueRef, t: ty::t}],\n            invoker: fn(@block_ctxt, ValueRef, [ValueRef],\n                        BasicBlockRef, BasicBlockRef) -> ValueRef) -> result {\n     // FIXME: May be worth turning this into a plain call when there are no\n     // cleanups to run\n     let normal_bcx = new_sub_block_ctxt(bcx, \"normal return\");\n     let retval = invoker(bcx, llfn, llargs,\n                          normal_bcx.llbb,\n-                         get_landing_pad(bcx));\n+                         get_landing_pad(bcx, to_zero, to_revoke));\n     ret rslt(normal_bcx, retval);\n }\n \n-fn get_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n-    let scope_bcx = find_scope_for_lpad(bcx);\n-    if scope_bcx.cleanups_dirty {\n+fn get_landing_pad(bcx: @block_ctxt,\n+                   to_zero: [{v: ValueRef, t: ty::t}],\n+                   to_revoke: [{v: ValueRef, t: ty::t}]\n+                  ) -> BasicBlockRef {\n+    let have_zero_or_revoke = vec::is_not_empty(to_zero)\n+        || vec::is_not_empty(to_revoke);\n+    let scope_bcx = find_scope_for_lpad(bcx, have_zero_or_revoke);\n+    if scope_bcx.lpad_dirty || have_zero_or_revoke {\n         let unwind_bcx = new_sub_block_ctxt(bcx, \"unwind\");\n-        let lpadbb = trans_landing_pad(unwind_bcx);\n+        let lpadbb = trans_landing_pad(unwind_bcx, to_zero, to_revoke);\n         scope_bcx.lpad = some(lpadbb);\n-        scope_bcx.cleanups_dirty = false;\n+        scope_bcx.lpad_dirty = have_zero_or_revoke;\n     }\n     assert option::is_some(scope_bcx.lpad);\n     ret option::get(scope_bcx.lpad);\n \n-    fn find_scope_for_lpad(bcx: @block_ctxt) -> @block_ctxt {\n+    fn find_scope_for_lpad(bcx: @block_ctxt,\n+                           have_zero_or_revoke: bool) -> @block_ctxt {\n         let scope_bcx = bcx;\n         while true {\n             scope_bcx = find_scope_cx(scope_bcx);\n-            if vec::is_not_empty(scope_bcx.cleanups) {\n+            if vec::is_not_empty(scope_bcx.cleanups)\n+                || have_zero_or_revoke {\n                 ret scope_bcx;\n             } else {\n                 scope_bcx = alt scope_bcx.parent {\n@@ -3842,7 +3864,10 @@ fn get_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n     }\n }\n \n-fn trans_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n+fn trans_landing_pad(bcx: @block_ctxt,\n+                     to_zero: [{v: ValueRef, t: ty::t}],\n+                     to_revoke: [{v: ValueRef, t: ty::t}]\n+                    ) -> BasicBlockRef {\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n@@ -3863,7 +3888,7 @@ fn trans_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n     // FIXME: This seems like a very naive and redundant way to generate the\n     // landing pads, as we're re-generating all in-scope cleanups for each\n     // function call. Probably good optimization opportunities here.\n-    let bcx = bcx;\n+    let bcx = zero_and_revoke(bcx, to_zero, to_revoke);\n     let scope_cx = bcx;\n     while true {\n         scope_cx = find_scope_cx(scope_cx);\n@@ -4372,7 +4397,7 @@ fn trans_put(in_cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n         llargs += [r.val];\n       }\n     }\n-    bcx = invoke_fastcall(bcx, llcallee, llargs).bcx;\n+    bcx = invoke_fastcall(bcx, llcallee, llargs, [], []).bcx;\n     bcx = trans_block_cleanups(bcx, cx);\n     let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n     Br(bcx, next_cx.llbb);\n@@ -4638,7 +4663,7 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n           parent: parent,\n           kind: kind,\n           mutable cleanups: [],\n-          mutable cleanups_dirty: true,\n+          mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: cx.sp,\n           fcx: cx};\n@@ -4674,7 +4699,7 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n           parent: parent_none,\n           kind: NON_SCOPE_BLOCK,\n           mutable cleanups: [],\n-          mutable cleanups_dirty: true,\n+          mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n           fcx: fcx};\n@@ -4741,7 +4766,7 @@ fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           parent: parent_none,\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n-          mutable cleanups_dirty: true,\n+          mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n           fcx: fcx};\n@@ -4753,7 +4778,7 @@ fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           parent: parent_none,\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n-          mutable cleanups_dirty: true,\n+          mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n           fcx: fcx};"}, {"sha": "ac145af273a134b37faface3bfb09045b76eb8c7", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1002623201c0368af2120885189fcdc979bff6fe/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1002623201c0368af2120885189fcdc979bff6fe/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=1002623201c0368af2120885189fcdc979bff6fe", "patch": "@@ -273,7 +273,7 @@ tag cleanup {\n fn add_clean(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     let scope_cx = find_scope_cx(cx);\n     scope_cx.cleanups += [clean(bind drop_ty(_, val, ty))];\n-    scope_cx.cleanups_dirty = true;\n+    scope_cx.lpad_dirty = true;\n }\n fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     fn spill_and_drop(cx: @block_ctxt, val: ValueRef, ty: ty::t) ->\n@@ -287,7 +287,7 @@ fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     let scope_cx = find_scope_cx(cx);\n     scope_cx.cleanups +=\n         [clean_temp(val, bind spill_and_drop(_, val, ty))];\n-    scope_cx.cleanups_dirty = true;\n+    scope_cx.lpad_dirty = true;\n }\n \n // Note that this only works for temporaries. We should, at some point, move\n@@ -321,7 +321,7 @@ fn revoke_clean(cx: @block_ctxt, val: ValueRef, t: ty::t) -> @block_ctxt {\n         std::vec::slice(sc_cx.cleanups, 0u, found as uint) +\n             std::vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n                             std::vec::len(sc_cx.cleanups));\n-    sc_cx.cleanups_dirty = true;\n+    sc_cx.lpad_dirty = true;\n     ret cx;\n }\n \n@@ -396,7 +396,7 @@ type block_ctxt =\n      parent: block_parent,\n      kind: block_kind,\n      mutable cleanups: [cleanup],\n-     mutable cleanups_dirty: bool,\n+     mutable lpad_dirty: bool,\n      mutable lpad: option::t<BasicBlockRef>,\n      sp: span,\n      fcx: @fn_ctxt};"}, {"sha": "311cb52b13455a13ac2ccccd82d5e2b8d251e2ff", "filename": "src/test/run-fail/unwind-move.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1002623201c0368af2120885189fcdc979bff6fe/src%2Ftest%2Frun-fail%2Funwind-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1002623201c0368af2120885189fcdc979bff6fe/src%2Ftest%2Frun-fail%2Funwind-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-move.rs?ref=1002623201c0368af2120885189fcdc979bff6fe", "patch": "@@ -0,0 +1,9 @@\n+// error-pattern:fail\n+fn f(-a: @int) {\n+    fail;\n+}\n+\n+fn main() {\n+    let a = @0;\n+    f(a);\n+}\n\\ No newline at end of file"}]}