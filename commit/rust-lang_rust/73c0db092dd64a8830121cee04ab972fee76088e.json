{"sha": "73c0db092dd64a8830121cee04ab972fee76088e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYzBkYjA5MmRkNjRhODgzMDEyMWNlZTA0YWI5NzJmZWU3NjA4OGU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-04-16T09:59:20Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-04-16T09:59:20Z"}, "message": "Rustup to rustc 1.53.0-nightly (132b4e5d1 2021-04-13)", "tree": {"sha": "8480b83ec4ad1a9b66a1b6700b8c83994c33221b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8480b83ec4ad1a9b66a1b6700b8c83994c33221b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73c0db092dd64a8830121cee04ab972fee76088e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73c0db092dd64a8830121cee04ab972fee76088e", "html_url": "https://github.com/rust-lang/rust/commit/73c0db092dd64a8830121cee04ab972fee76088e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73c0db092dd64a8830121cee04ab972fee76088e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "607ed9190f1b2437cd41204f144bf95b76e24126", "url": "https://api.github.com/repos/rust-lang/rust/commits/607ed9190f1b2437cd41204f144bf95b76e24126", "html_url": "https://github.com/rust-lang/rust/commit/607ed9190f1b2437cd41204f144bf95b76e24126"}], "stats": {"total": 166, "additions": 84, "deletions": 82}, "files": [{"sha": "b6e27245b8f293f651123290b6e7f94de1cffc42", "filename": "build_sysroot/Cargo.lock", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/73c0db092dd64a8830121cee04ab972fee76088e/build_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/73c0db092dd64a8830121cee04ab972fee76088e/build_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.lock?ref=73c0db092dd64a8830121cee04ab972fee76088e", "patch": "@@ -56,7 +56,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.39\"\n+version = \"0.1.40\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -167,6 +167,7 @@ dependencies = [\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc\",\n  \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n@@ -242,10 +243,22 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"rustc-demangle\",\n+ \"std_detect\",\n  \"unwind\",\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"std_detect\"\n+version = \"0.1.5\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"sysroot\"\n version = \"0.0.0\""}, {"sha": "f7fcef10774102706c7a5169a3882eec5930bee1", "filename": "build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73c0db092dd64a8830121cee04ab972fee76088e/build_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/73c0db092dd64a8830121cee04ab972fee76088e/build_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fprepare_sysroot_src.sh?ref=73c0db092dd64a8830121cee04ab972fee76088e", "patch": "@@ -32,7 +32,7 @@ popd\n git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/compiler-builtins has already been cloned\"\n pushd compiler-builtins\n git checkout -- .\n-git checkout 0.1.39\n+git checkout 0.1.40\n git apply ../../crate_patches/000*-compiler-builtins-*.patch\n popd\n "}, {"sha": "b4acc4f5b73659923b329cc9fae53339f8335fa0", "filename": "crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73c0db092dd64a8830121cee04ab972fee76088e/crate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "raw_url": "https://github.com/rust-lang/rust/raw/73c0db092dd64a8830121cee04ab972fee76088e/crate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch?ref=73c0db092dd64a8830121cee04ab972fee76088e", "patch": "@@ -17,8 +17,8 @@ index 06054c8..3bea17b 100644\n      fn wrapping_shr(self, other: u32) -> Self;\n -    fn rotate_left(self, other: u32) -> Self;\n      fn overflowing_add(self, other: Self) -> (Self, bool);\n-     fn aborting_div(self, other: Self) -> Self;\n-     fn aborting_rem(self, other: Self) -> Self;\n+     fn leading_zeros(self) -> u32;\n+ }\n @@ -209,10 +208,6 @@ macro_rules! int_impl_common {\n              <Self>::wrapping_shr(self, other)\n          }"}, {"sha": "ef7fc7baba251dfae98a2e49825f70c67924ede7", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73c0db092dd64a8830121cee04ab972fee76088e/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/73c0db092dd64a8830121cee04ab972fee76088e/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=73c0db092dd64a8830121cee04ab972fee76088e", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-04-07\"\n+channel = \"nightly-2021-04-14\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "3ec5c14ff17a2d8308657936aa5c21f15cfc6160", "filename": "src/base.rs", "status": "modified", "additions": 6, "deletions": 76, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/73c0db092dd64a8830121cee04ab972fee76088e/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c0db092dd64a8830121cee04ab972fee76088e/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=73c0db092dd64a8830121cee04ab972fee76088e", "patch": "@@ -744,85 +744,15 @@ fn codegen_stmt<'tcx>(\n         | StatementKind::AscribeUserType(..) => {}\n \n         StatementKind::LlvmInlineAsm(asm) => {\n-            use rustc_span::symbol::Symbol;\n-            let LlvmInlineAsm { asm, outputs, inputs } = &**asm;\n-            let rustc_hir::LlvmInlineAsmInner {\n-                asm: asm_code,         // Name\n-                outputs: output_names, // Vec<LlvmInlineAsmOutput>\n-                inputs: input_names,   // Vec<Name>\n-                clobbers,              // Vec<Name>\n-                volatile,              // bool\n-                alignstack,            // bool\n-                dialect: _,\n-                asm_str_style: _,\n-            } = asm;\n-            match asm_code.as_str().trim() {\n+            match asm.asm.asm.as_str().trim() {\n                 \"\" => {\n                     // Black box\n                 }\n-                \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n-                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n-                    assert_eq!(output_names.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n-                        assert_eq!(&output_names[i].constraint.as_str(), c);\n-                        assert!(!output_names[i].is_rw);\n-                        assert!(!output_names[i].is_indirect);\n-                    }\n-\n-                    assert_eq!(clobbers, &[]);\n-\n-                    assert!(!volatile);\n-                    assert!(!alignstack);\n-\n-                    assert_eq!(inputs.len(), 2);\n-                    let leaf = codegen_operand(fx, &inputs[0].1).load_scalar(fx); // %eax\n-                    let subleaf = codegen_operand(fx, &inputs[1].1).load_scalar(fx); // %ecx\n-\n-                    let (eax, ebx, ecx, edx) =\n-                        crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n-\n-                    assert_eq!(outputs.len(), 4);\n-                    codegen_place(fx, outputs[0])\n-                        .write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[1])\n-                        .write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[2])\n-                        .write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[3])\n-                        .write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n-                }\n-                \"xgetbv\" => {\n-                    assert_eq!(input_names, &[Symbol::intern(\"{ecx}\")]);\n-\n-                    assert_eq!(output_names.len(), 2);\n-                    for (i, c) in (&[\"={eax}\", \"={edx}\"]).iter().enumerate() {\n-                        assert_eq!(&output_names[i].constraint.as_str(), c);\n-                        assert!(!output_names[i].is_rw);\n-                        assert!(!output_names[i].is_indirect);\n-                    }\n-\n-                    assert_eq!(clobbers, &[]);\n-\n-                    assert!(!volatile);\n-                    assert!(!alignstack);\n-\n-                    crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n-                }\n-                // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n-                    crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n-                }\n-                _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n-                    crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n-                }\n-                // Used in sys::windows::abort_internal\n-                \"int $$0x29\" => {\n-                    crate::trap::trap_unimplemented(fx, \"Windows abort\");\n-                }\n-                _ => fx\n-                    .tcx\n-                    .sess\n-                    .span_fatal(stmt.source_info.span, \"Inline assembly is not supported\"),\n+                _ => fx.tcx.sess.span_fatal(\n+                    stmt.source_info.span,\n+                    \"Legacy `llvm_asm!` inline assembly is not supported. \\\n+                    Try using the new `asm!` instead.\",\n+                ),\n             }\n         }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),"}, {"sha": "4ab4c2957ca4e3f29fa06902f9332d26712e9b86", "filename": "src/inline_asm.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/73c0db092dd64a8830121cee04ab972fee76088e/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c0db092dd64a8830121cee04ab972fee76088e/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=73c0db092dd64a8830121cee04ab972fee76088e", "patch": "@@ -24,6 +24,64 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         let true_ = fx.bcx.ins().iconst(types::I32, 1);\n         fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n         return;\n+    } else if template[0] == InlineAsmTemplatePiece::String(\"mov rsi, rbx\".to_string())\n+        && template[1] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+        && template[2] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+        && template[3] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+        && template[4] == InlineAsmTemplatePiece::String(\"xchg rsi, rbx\".to_string())\n+    {\n+        assert_eq!(operands.len(), 4);\n+        let (leaf, eax_place) = match operands[0] {\n+            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::ax));\n+                (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place.unwrap()),\n+                )\n+            }\n+            _ => unreachable!(),\n+        };\n+        let ebx_place = match operands[1] {\n+            InlineAsmOperand::Out { reg, late: true, place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::si));\n+                crate::base::codegen_place(fx, place.unwrap())\n+            }\n+            _ => unreachable!(),\n+        };\n+        let (sub_leaf, ecx_place) = match operands[2] {\n+            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::cx));\n+                (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place.unwrap()),\n+                )\n+            }\n+            _ => unreachable!(),\n+        };\n+        let edx_place = match operands[3] {\n+            InlineAsmOperand::Out { reg, late: true, place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::dx));\n+                crate::base::codegen_place(fx, place.unwrap())\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n+\n+        eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+        ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+        ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+        edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+        return;\n+    } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+        // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n+        crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+    } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n+        crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n     }\n \n     let mut slot_size = Size::from_bytes(0);"}, {"sha": "9de12e759bcc8826d8dca15c789cccc5c37f80e7", "filename": "src/intrinsics/cpuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73c0db092dd64a8830121cee04ab972fee76088e/src%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c0db092dd64a8830121cee04ab972fee76088e/src%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fcpuid.rs?ref=73c0db092dd64a8830121cee04ab972fee76088e", "patch": "@@ -8,7 +8,7 @@ use crate::prelude::*;\n pub(crate) fn codegen_cpuid_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     leaf: Value,\n-    _subleaf: Value,\n+    _sub_leaf: Value,\n ) -> (Value, Value, Value, Value) {\n     let leaf_0 = fx.bcx.create_block();\n     let leaf_1 = fx.bcx.create_block();"}, {"sha": "ca853aac15892285208581ed6884e4835babf864", "filename": "src/linkage.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73c0db092dd64a8830121cee04ab972fee76088e/src%2Flinkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c0db092dd64a8830121cee04ab972fee76088e/src%2Flinkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flinkage.rs?ref=73c0db092dd64a8830121cee04ab972fee76088e", "patch": "@@ -13,6 +13,7 @@ pub(crate) fn get_clif_linkage(\n         (RLinkage::External, Visibility::Default) => Linkage::Export,\n         (RLinkage::Internal, Visibility::Default) => Linkage::Local,\n         (RLinkage::External, Visibility::Hidden) => Linkage::Hidden,\n+        (RLinkage::WeakAny, Visibility::Default) => Linkage::Preemptible,\n         _ => panic!(\"{:?} = {:?} {:?}\", mono_item, linkage, visibility),\n     }\n }"}]}