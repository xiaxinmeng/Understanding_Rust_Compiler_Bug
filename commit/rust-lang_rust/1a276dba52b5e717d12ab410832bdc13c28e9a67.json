{"sha": "1a276dba52b5e717d12ab410832bdc13c28e9a67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMjc2ZGJhNTJiNWU3MTdkMTJhYjQxMDgzMmJkYzEzYzI4ZTlhNjc=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-11T21:50:39Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-13T01:16:00Z"}, "message": "Switch map-reduce control protocol to use pipes. This exposed a bug in the pipe compiler, which is now fixed.\n\nUse hashmaps in MapReduce\n\nTweak word-count difficulty", "tree": {"sha": "471ec60c468939e07008f3a423a8064ffa87236b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/471ec60c468939e07008f3a423a8064ffa87236b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a276dba52b5e717d12ab410832bdc13c28e9a67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a276dba52b5e717d12ab410832bdc13c28e9a67", "html_url": "https://github.com/rust-lang/rust/commit/1a276dba52b5e717d12ab410832bdc13c28e9a67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a276dba52b5e717d12ab410832bdc13c28e9a67/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5b8bbb4b20a5d88eea0b317102ed747deed802d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b8bbb4b20a5d88eea0b317102ed747deed802d", "html_url": "https://github.com/rust-lang/rust/commit/d5b8bbb4b20a5d88eea0b317102ed747deed802d"}], "stats": {"total": 166, "additions": 101, "deletions": 65}, "files": [{"sha": "9f46e6b10ae05e2597235b959f051c2b8fc49694", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1a276dba52b5e717d12ab410832bdc13c28e9a67/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a276dba52b5e717d12ab410832bdc13c28e9a67/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=1a276dba52b5e717d12ab410832bdc13c28e9a67", "patch": "@@ -56,34 +56,11 @@ impl methods for message {\n \n     // Return the type parameters actually used by this message\n     fn get_params() -> ~[ast::ty_param] {\n-        let mut used = ~[];\n         alt self {\n-          message(_, tys, this, _, next_tys) {\n-            let parms = this.ty_params;\n-            for vec::append(tys, next_tys).each |ty| {\n-                alt ty.node {\n-                  ast::ty_path(path, _) {\n-                    if path.idents.len() == 1 {\n-                        let id = path.idents[0];\n-\n-                        let found = parms.find(|p| id == p.ident);\n-\n-                        alt found {\n-                          some(p) {\n-                            if !used.contains(p) {\n-                                vec::push(used, p);\n-                            }\n-                          }\n-                          none { }\n-                        }\n-                    }\n-                  }\n-                  _ { }\n-                }\n-            }\n+          message(_, _, this, _, _) {\n+            this.ty_params\n           }\n         }\n-        used\n     }\n \n     fn gen_send(cx: ext_ctxt) -> @ast::item {"}, {"sha": "9829c97b445824009ee8aad7cb362b7a43957800", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 99, "deletions": 40, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1a276dba52b5e717d12ab410832bdc13c28e9a67/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a276dba52b5e717d12ab410832bdc13c28e9a67/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=1a276dba52b5e717d12ab410832bdc13c28e9a67", "patch": "@@ -14,7 +14,8 @@ import option = option;\n import option::some;\n import option::none;\n import str;\n-import std::treemap;\n+import std::map;\n+import std::map::hashmap;\n import vec;\n import io;\n import io::{reader_util, writer_util};\n@@ -30,10 +31,30 @@ import comm::recv;\n import comm::send;\n import comm::methods;\n \n+macro_rules! move {\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n+}\n+\n trait word_reader {\n     fn read_word() -> option<str>;\n }\n \n+trait hash_key {\n+    fn hash() -> uint;\n+    fn eq(self) -> bool;\n+}\n+\n+fn mk_hash<K: const hash_key, V: copy>() -> map::hashmap<K, V> {\n+    fn hashfn<K: const hash_key>(k: K) -> uint { k.hash() }\n+\n+    map::hashmap(hashfn::<K>, |x, y| x.eq(y))\n+}\n+\n+impl of hash_key for str {\n+    fn hash() -> uint { str::hash(self) }\n+    fn eq(&&x: str) -> bool { str::eq(self, x) }\n+}\n+\n // These used to be in task, but they disappeard.\n type joinable_task = port<()>;\n fn spawn_joinable(+f: fn~()) -> joinable_task {\n@@ -79,6 +100,23 @@ fn reduce(&&word: str, get: map_reduce::getter<int>) {\n     io::println(#fmt(\"%s\\t%?\", word, count));\n }\n \n+class box<T> {\n+    let mut contents: option<T>;\n+    new(+x: T) { self.contents = some(x); }\n+\n+    fn swap(f: fn(+T) -> T) {\n+        let mut tmp = none;\n+        self.contents <-> tmp;\n+        self.contents = some(f(option::unwrap(tmp)));\n+    }\n+\n+    fn unwrap() -> T {\n+        let mut tmp = none;\n+        self.contents <-> tmp;\n+        option::unwrap(tmp)\n+    }\n+}\n+\n mod map_reduce {\n     export putter;\n     export getter;\n@@ -99,54 +137,74 @@ mod map_reduce {\n         mapper_done\n     }\n \n+\n+    proto! ctrl_proto {\n+        open: send<K: copy send, V: copy send> {\n+            find_reducer(K) -> reducer_response<K, V>,\n+            mapper_done -> terminated\n+        }\n+\n+        reducer_response: recv<K: copy send, V: copy send> {\n+            reducer(chan<reduce_proto<V>>) -> open<K, V>\n+        }\n+\n+        terminated: send { }\n+    }\n+\n     enum reduce_proto<V: copy send> { emit_val(V), done, ref, release }\n \n-    fn start_mappers<K1: copy send, K2: copy send, V: copy send>(\n+    fn start_mappers<K1: copy send, K2: const copy send hash_key,\n+                     V: copy send>(\n         map: mapper<K1, K2, V>,\n-        ctrl: chan<ctrl_proto<K2, V>>, inputs: ~[K1])\n+        &ctrls: ~[ctrl_proto::server::open<K2, V>],\n+        inputs: ~[K1])\n         -> ~[joinable_task]\n     {\n         let mut tasks = ~[];\n         for inputs.each |i| {\n+            let (ctrl, ctrl_server) = ctrl_proto::init();\n+            let ctrl = box(ctrl);\n             vec::push(tasks, spawn_joinable(|| map_task(map, ctrl, i) ));\n+            vec::push(ctrls, ctrl_server);\n         }\n         ret tasks;\n     }\n \n-    fn map_task<K1: copy send, K2: copy send, V: copy send>(\n+    fn map_task<K1: copy send, K2: const copy send hash_key, V: copy send>(\n         map: mapper<K1, K2, V>,\n-        ctrl: chan<ctrl_proto<K2, V>>,\n+        ctrl: box<ctrl_proto::client::open<K2, V>>,\n         input: K1)\n     {\n         // log(error, \"map_task \" + input);\n-        let intermediates = treemap::treemap();\n+        let intermediates = mk_hash();\n \n-        fn emit<K2: copy send, V: copy send>(\n-            im: treemap::treemap<K2, chan<reduce_proto<V>>>,\n-            ctrl: chan<ctrl_proto<K2, V>>, key: K2, val: V)\n-        {\n-            let c;\n-            alt treemap::find(im, key) {\n-              some(_c) { c = _c; }\n+        do map(input) |key, val| {\n+            let mut c = none;\n+            alt intermediates.find(key) {\n+              some(_c) { c = some(_c); }\n               none {\n-                let p = port();\n-                send(ctrl, find_reducer(key, chan(p)));\n-                c = recv(p);\n-                treemap::insert(im, key, c);\n-                send(c, ref);\n+                do ctrl.swap |ctrl| {\n+                    let ctrl = ctrl_proto::client::find_reducer(ctrl, key);\n+                    alt pipes::recv(ctrl) {\n+                      ctrl_proto::reducer(c_, ctrl) {\n+                        c = some(c_);\n+                        move!{ctrl}\n+                      }\n+                    }\n+                }\n+                intermediates.insert(key, c.get());\n+                send(c.get(), ref);\n               }\n             }\n-            send(c, emit_val(val));\n+            send(c.get(), emit_val(val));\n         }\n \n-        map(input, {|a,b|emit(intermediates, ctrl, a, b)});\n-\n         fn finish<K: copy send, V: copy send>(_k: K, v: chan<reduce_proto<V>>)\n         {\n             send(v, release);\n         }\n-        treemap::traverse(intermediates, finish);\n-        send(ctrl, mapper_done);\n+        for intermediates.each_value |v| { send(v, release) }\n+        ctrl_proto::client::mapper_done(ctrl.unwrap());\n     }\n \n     fn reduce_task<K: copy send, V: copy send>(\n@@ -184,30 +242,32 @@ mod map_reduce {\n         reduce(key, || get(p, ref_count, is_done) );\n     }\n \n-    fn map_reduce<K1: copy send, K2: copy send, V: copy send>(\n+    fn map_reduce<K1: copy send, K2: const copy send hash_key, V: copy send>(\n         map: mapper<K1, K2, V>,\n         reduce: reducer<K2, V>,\n         inputs: ~[K1])\n     {\n-        let ctrl = port();\n+        let mut ctrl = ~[];\n \n         // This task becomes the master control task. It task::_spawns\n         // to do the rest.\n \n-        let reducers = treemap::treemap();\n-        let mut tasks = start_mappers(map, chan(ctrl), inputs);\n+        let reducers = mk_hash();\n+        let mut tasks = start_mappers(map, ctrl, inputs);\n         let mut num_mappers = vec::len(inputs) as int;\n \n         while num_mappers > 0 {\n-            alt recv(ctrl) {\n-              mapper_done {\n+            let (_ready, message, ctrls) = pipes::select(ctrl);\n+            alt option::unwrap(message) {\n+              ctrl_proto::mapper_done(_) {\n                 // #error(\"received mapper terminated.\");\n                 num_mappers -= 1;\n+                ctrl = ctrls;\n               }\n-              find_reducer(k, cc) {\n+              ctrl_proto::find_reducer(k, cc) {\n                 let c;\n                 // log(error, \"finding reducer for \" + k);\n-                alt treemap::find(reducers, k) {\n+                alt reducers.find(k) {\n                   some(_c) {\n                     // log(error,\n                     // \"reusing existing reducer for \" + k);\n@@ -221,19 +281,17 @@ mod map_reduce {\n                     vec::push(tasks,\n                               spawn_joinable(|| reduce_task(r, kk, ch) ));\n                     c = recv(p);\n-                    treemap::insert(reducers, k, c);\n+                    reducers.insert(k, c);\n                   }\n                 }\n-                send(cc, c);\n+                ctrl = vec::append_one(\n+                    ctrls,\n+                    ctrl_proto::server::reducer(move!{cc}, c));\n               }\n             }\n         }\n \n-        fn finish<K: copy send, V: copy send>(_k: K, v: chan<reduce_proto<V>>)\n-        {\n-            send(v, done);\n-        }\n-        treemap::traverse(reducers, finish);\n+        for reducers.each_value |v| { send(v, done) }\n \n         for tasks.each |t| { join(t); }\n     }\n@@ -254,7 +312,7 @@ fn main(argv: ~[str]) {\n     }\n     else {\n         let num_readers = 50;\n-        let words_per_reader = 1000;\n+        let words_per_reader = 600;\n         vec::from_fn(\n             num_readers,\n             |_i| fn~() -> word_reader {\n@@ -301,7 +359,8 @@ class random_word_reader: word_reader {\n     fn read_word() -> option<str> {\n         if self.remaining > 0 {\n             self.remaining -= 1;\n-            some(self.rng.gen_str(5))\n+            let len = self.rng.gen_uint_range(1, 4);\n+            some(self.rng.gen_str(len))\n         }\n         else { none }\n     }"}]}