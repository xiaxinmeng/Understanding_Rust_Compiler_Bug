{"sha": "7c2aeb9d974e85e54efa18cd63195bfd95347a44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMmFlYjlkOTc0ZTg1ZTU0ZWZhMThjZDYzMTk1YmZkOTUzNDdhNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-27T07:16:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-27T07:16:12Z"}, "message": "Auto merge of #52650 - oli-obk:associated_existential_types, r=nikomatsakis\n\nImplement associated existential types\n\nr? @nikomatsakis\n\nno idea if these work with generic traits. I'm going home for the day :rofl:", "tree": {"sha": "eda24586b4082ba5251124cf3fbef61aad0f74fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eda24586b4082ba5251124cf3fbef61aad0f74fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c2aeb9d974e85e54efa18cd63195bfd95347a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c2aeb9d974e85e54efa18cd63195bfd95347a44", "html_url": "https://github.com/rust-lang/rust/commit/7c2aeb9d974e85e54efa18cd63195bfd95347a44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c2aeb9d974e85e54efa18cd63195bfd95347a44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d0e93309d61636585cfe5ac75c0db8cb5ba03e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0e93309d61636585cfe5ac75c0db8cb5ba03e1", "html_url": "https://github.com/rust-lang/rust/commit/3d0e93309d61636585cfe5ac75c0db8cb5ba03e1"}, {"sha": "33712a8a10eb193e1d90c52b666a053309b7a8dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/33712a8a10eb193e1d90c52b666a053309b7a8dc", "html_url": "https://github.com/rust-lang/rust/commit/33712a8a10eb193e1d90c52b666a053309b7a8dc"}], "stats": {"total": 216, "additions": 186, "deletions": 30}, "files": [{"sha": "205f8c5ad068caee0ab33b171f14b2aa715f0762", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=7c2aeb9d974e85e54efa18cd63195bfd95347a44", "patch": "@@ -691,25 +691,41 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     // }\n                     // ```\n                     if let Some(anon_node_id) = tcx.hir.as_local_node_id(def_id) {\n-                        let in_definition_scope = match tcx.hir.expect_item(anon_node_id).node {\n-                            // impl trait\n-                            hir::ItemKind::Existential(hir::ExistTy {\n-                                impl_trait_fn: Some(parent),\n-                                ..\n-                            }) => parent == self.parent_def_id,\n-                            // named existential types\n-                            hir::ItemKind::Existential(hir::ExistTy {\n-                                impl_trait_fn: None,\n-                                ..\n-                            }) => may_define_existential_type(\n-                                tcx,\n-                                self.parent_def_id,\n-                                anon_node_id,\n-                            ),\n-                            _ => {\n-                                let anon_parent_node_id = tcx.hir.get_parent(anon_node_id);\n-                                self.parent_def_id == tcx.hir.local_def_id(anon_parent_node_id)\n+                        let parent_def_id = self.parent_def_id;\n+                        let def_scope_default = || {\n+                            let anon_parent_node_id = tcx.hir.get_parent(anon_node_id);\n+                            parent_def_id == tcx.hir.local_def_id(anon_parent_node_id)\n+                        };\n+                        let in_definition_scope = match tcx.hir.find(anon_node_id) {\n+                            Some(hir::map::NodeItem(item)) => match item.node {\n+                                // impl trait\n+                                hir::ItemKind::Existential(hir::ExistTy {\n+                                    impl_trait_fn: Some(parent),\n+                                    ..\n+                                }) => parent == self.parent_def_id,\n+                                // named existential types\n+                                hir::ItemKind::Existential(hir::ExistTy {\n+                                    impl_trait_fn: None,\n+                                    ..\n+                                }) => may_define_existential_type(\n+                                    tcx,\n+                                    self.parent_def_id,\n+                                    anon_node_id,\n+                                ),\n+                                _ => def_scope_default(),\n                             },\n+                            Some(hir::map::NodeImplItem(item)) => match item.node {\n+                                hir::ImplItemKind::Existential(_) => may_define_existential_type(\n+                                    tcx,\n+                                    self.parent_def_id,\n+                                    anon_node_id,\n+                                ),\n+                                _ => def_scope_default(),\n+                            },\n+                            _ => bug!(\n+                                \"expected (impl) item, found {}\",\n+                                tcx.hir.node_to_string(anon_node_id),\n+                            ),\n                         };\n                         if in_definition_scope {\n                             return self.fold_anon_ty(ty, def_id, substs);"}, {"sha": "1ce60d8f05599e630905b5cf04fa5571106c8492", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=7c2aeb9d974e85e54efa18cd63195bfd95347a44", "patch": "@@ -1502,19 +1502,26 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     let param_env = obligation.param_env;\n     let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_def_id);\n \n-    let ty = if !assoc_ty.item.defaultness.has_value() {\n+    if !assoc_ty.item.defaultness.has_value() {\n         // This means that the impl is missing a definition for the\n         // associated type. This error will be reported by the type\n         // checker method `check_impl_items_against_trait`, so here we\n         // just return TyError.\n         debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n                assoc_ty.item.ident,\n                obligation.predicate);\n-        tcx.types.err\n+        return Progress {\n+            ty: tcx.types.err,\n+            obligations: nested,\n+        };\n+    }\n+    let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n+    let ty = if let ty::AssociatedKind::Existential = assoc_ty.item.kind {\n+        let item_substs = Substs::identity_for_item(tcx, assoc_ty.item.def_id);\n+        tcx.mk_anon(assoc_ty.item.def_id, item_substs)\n     } else {\n         tcx.type_of(assoc_ty.item.def_id)\n     };\n-    let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n     Progress {\n         ty: ty.subst(tcx, substs),\n         obligations: nested,"}, {"sha": "6562526a2ea731822db752323746c43c374ebcb3", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=7c2aeb9d974e85e54efa18cd63195bfd95347a44", "patch": "@@ -377,9 +377,19 @@ impl<'a, 'gcx, 'tcx> Ancestors {\n         trait_def_id: DefId,\n     ) -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + Captures<'gcx> + Captures<'tcx> + 'a {\n         self.flat_map(move |node| {\n-            node.items(tcx).filter(move |impl_item| {\n-                impl_item.kind == trait_item_kind &&\n-                tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id)\n+            use ty::AssociatedKind::*;\n+            node.items(tcx).filter(move |impl_item| match (trait_item_kind, impl_item.kind) {\n+                | (Const, Const)\n+                | (Method, Method)\n+                | (Type, Type)\n+                | (Type, Existential)\n+                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n+\n+                | (Const, _)\n+                | (Method, _)\n+                | (Type, _)\n+                | (Existential, _)\n+                => false,\n             }).map(move |item| NodeItem { node: node, item: item })\n         })\n     }"}, {"sha": "38743cc9cf65f4d8bfdbaa529567a3a0cae4d02c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7c2aeb9d974e85e54efa18cd63195bfd95347a44", "patch": "@@ -211,8 +211,7 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n             }\n             ty::AssociatedKind::Existential => {\n-                // FIXME(oli-obk) implement existential types in trait impls\n-                unimplemented!()\n+                // do nothing, existential types check themselves\n             }\n         }\n "}, {"sha": "cd84a61bb2c3551b04375c128b7e46d2e95db5cd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7c2aeb9d974e85e54efa18cd63195bfd95347a44", "patch": "@@ -1046,12 +1046,12 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     tcx.mk_fn_def(def_id, substs)\n                 }\n                 ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n-                ImplItemKind::Existential(ref _bounds) => {\n+                ImplItemKind::Existential(_) => {\n                     if tcx.impl_trait_ref(tcx.hir.get_parent_did(node_id)).is_none() {\n                         report_assoc_ty_on_inherent_impl(tcx, item.span);\n                     }\n-                    // FIXME(oli-obk) implement existential types in trait impls\n-                    unimplemented!()\n+\n+                    find_existential_constraints(tcx, def_id)\n                 }\n                 ImplItemKind::Type(ref ty) => {\n                     if tcx.impl_trait_ref(tcx.hir.get_parent_did(node_id)).is_none() {\n@@ -1186,8 +1186,10 @@ fn find_existential_constraints<'a, 'tcx>(\n     }\n     impl<'a, 'tcx> ConstraintLocator<'a, 'tcx> {\n         fn check(&mut self, def_id: DefId) {\n+            trace!(\"checking {:?}\", def_id);\n             // don't try to check items that cannot possibly constrain the type\n             if !self.tcx.has_typeck_tables(def_id) {\n+                trace!(\"no typeck tables for {:?}\", def_id);\n                 return;\n             }\n             let ty = self\n@@ -1244,9 +1246,11 @@ fn find_existential_constraints<'a, 'tcx>(\n     let mut locator = ConstraintLocator { def_id, tcx, found: None };\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let parent = tcx.hir.get_parent(node_id);\n+    trace!(\"parent_id: {:?}\", parent);\n     if parent == ast::CRATE_NODE_ID {\n         intravisit::walk_crate(&mut locator, tcx.hir.krate());\n     } else {\n+        trace!(\"parent: {:?}\", tcx.hir.get(parent));\n         match tcx.hir.get(parent) {\n             NodeItem(ref it) => intravisit::walk_item(&mut locator, it),\n             NodeImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n@@ -1485,7 +1489,23 @@ fn explicit_predicates_of<'a, 'tcx>(\n             &item.generics\n         }\n \n-        NodeImplItem(item) => &item.generics,\n+        NodeImplItem(item) => match item.node {\n+            ImplItemKind::Existential(ref bounds) => {\n+                let substs = Substs::identity_for_item(tcx, def_id);\n+                let anon_ty = tcx.mk_anon(def_id, substs);\n+\n+                // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n+                let bounds = compute_bounds(&icx,\n+                                            anon_ty,\n+                                            bounds,\n+                                            SizedByDefault::Yes,\n+                                            tcx.def_span(def_id));\n+\n+                predicates.extend(bounds.predicates(tcx, anon_ty));\n+                &item.generics\n+            },\n+            _ => &item.generics,\n+        }\n \n         NodeItem(item) => {\n             match item.node {"}, {"sha": "c9bf7b87ef4a9885fad5f1fb4a39a0e003ae79a2", "filename": "src/test/ui/impl-trait/associated-existential-type-generic-trait.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type-generic-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type-generic-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type-generic-trait.rs?ref=7c2aeb9d974e85e54efa18cd63195bfd95347a44", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(existential_type)]\n+// compile-pass\n+\n+trait Bar {}\n+struct Dummy<U>(U);\n+impl<V> Bar for Dummy<V> {}\n+\n+trait Foo<T> {\n+    type Assoc: Bar;\n+    fn foo(t: T) -> Self::Assoc;\n+}\n+\n+impl<W> Foo<W> for i32 {\n+    existential type Assoc: Bar;\n+    fn foo(w: W) -> Self::Assoc {\n+        Dummy(w)\n+    }\n+}\n+\n+struct NonGeneric;\n+impl Bar for NonGeneric {}\n+\n+impl<W> Foo<W> for u32 {\n+    existential type Assoc: Bar;\n+    fn foo(_: W) -> Self::Assoc {\n+        NonGeneric\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "78593fe319c0cfc0498b1f149516ea4f43105f08", "filename": "src/test/ui/impl-trait/associated-existential-type-trivial.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type-trivial.rs?ref=7c2aeb9d974e85e54efa18cd63195bfd95347a44", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(existential_type)]\n+// compile-pass\n+\n+trait Bar {}\n+struct Dummy;\n+impl Bar for Dummy {}\n+\n+trait Foo {\n+    type Assoc: Bar;\n+    fn foo() -> Self::Assoc;\n+}\n+\n+impl Foo for i32 {\n+    existential type Assoc: Bar;\n+    fn foo() -> Self::Assoc {\n+        Dummy\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d880428411f9e5b91e068e40075caf131143f115", "filename": "src/test/ui/impl-trait/associated-existential-type.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2aeb9d974e85e54efa18cd63195bfd95347a44/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fassociated-existential-type.rs?ref=7c2aeb9d974e85e54efa18cd63195bfd95347a44", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(existential_type)]\n+// compile-pass\n+\n+trait Bar {}\n+struct Dummy;\n+impl Bar for Dummy {}\n+\n+trait Foo {\n+    type Assoc: Bar;\n+    fn foo() -> Self::Assoc;\n+    fn bar() -> Self::Assoc;\n+}\n+\n+impl Foo for i32 {\n+    existential type Assoc: Bar;\n+    fn foo() -> Self::Assoc {\n+        Dummy\n+    }\n+    fn bar() -> Self::Assoc {\n+        Dummy\n+    }\n+}\n+\n+fn main() {}"}]}