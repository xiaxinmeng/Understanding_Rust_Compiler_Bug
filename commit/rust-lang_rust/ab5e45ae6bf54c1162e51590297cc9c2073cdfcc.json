{"sha": "ab5e45ae6bf54c1162e51590297cc9c2073cdfcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNWU0NWFlNmJmNTRjMTE2MmU1MTU5MDI5N2NjOWMyMDczY2RmY2M=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-25T16:05:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-25T16:05:01Z"}, "message": "Rollup merge of #56075 - alexcrichton:wasm-producer-section, r=estebank\n\nEncode a custom \"producers\" section in wasm files\n\nThis commit implements WebAssembly/tool-conventions#65 for wasm files\nproduced by the Rust compiler. This adds a bit of metadata to wasm\nmodules to indicate that the file's language includes Rust and the\nfile's \"processed-by\" tools includes rustc.\n\nThe thinking with this section is to eventually have telemetry in\nbrowsers tracking all this.", "tree": {"sha": "f0a9bb4500e364d0c91ba3d74735e89790a39d7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0a9bb4500e364d0c91ba3d74735e89790a39d7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb+sgtCRBK7hj4Ov3rIwAAdHIIADUotKVsf6aGom/OoSLrcCL0\nUCJIVn/k6DVZ7tEcxeV4BqrtUSl2AaiesRDhM8r/dOd7CE8dQ8O2qbwAi8qPkLqn\n/xB08E1B64VlvK2egInOFD/S7kuu9O+mIG7Ro+q+D37ZYY8xrZNUjvXQwFO0MPg2\nh8MjUb6Ag2n2Ia1DKiH6f5fci42jbsg3+E54Oc3eUoRsayWOrunZTfR6/QvjO5Ak\njl9kIMwXt1dfIbMZCc/n+qzzfXUu3WZtsuuVN4wvDSdDm9NDwXeNQ1GoQgPGndFw\n8W2KIyMhLFsi82fZaJgTkgxiVK5kgADpcXHK87pvOSTOh8ckbCly2a2wiiQ/kVU=\n=P7Cl\n-----END PGP SIGNATURE-----\n", "payload": "tree f0a9bb4500e364d0c91ba3d74735e89790a39d7f\nparent b16d8eb3f2e42a720d9da5aff7119b2fd2b4805b\nparent 089a50411f3bceb233dd5da8057252ff7b6b47e1\nauthor Pietro Albini <pietro@pietroalbini.org> 1543161901 +0100\ncommitter GitHub <noreply@github.com> 1543161901 +0100\n\nRollup merge of #56075 - alexcrichton:wasm-producer-section, r=estebank\n\nEncode a custom \"producers\" section in wasm files\n\nThis commit implements WebAssembly/tool-conventions#65 for wasm files\nproduced by the Rust compiler. This adds a bit of metadata to wasm\nmodules to indicate that the file's language includes Rust and the\nfile's \"processed-by\" tools includes rustc.\n\nThe thinking with this section is to eventually have telemetry in\nbrowsers tracking all this.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc", "html_url": "https://github.com/rust-lang/rust/commit/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b16d8eb3f2e42a720d9da5aff7119b2fd2b4805b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b16d8eb3f2e42a720d9da5aff7119b2fd2b4805b", "html_url": "https://github.com/rust-lang/rust/commit/b16d8eb3f2e42a720d9da5aff7119b2fd2b4805b"}, {"sha": "089a50411f3bceb233dd5da8057252ff7b6b47e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/089a50411f3bceb233dd5da8057252ff7b6b47e1", "html_url": "https://github.com/rust-lang/rust/commit/089a50411f3bceb233dd5da8057252ff7b6b47e1"}], "stats": {"total": 112, "additions": 112, "deletions": 0}, "files": [{"sha": "89d84acdd88764427f787144078451d66b3a308b", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=ab5e45ae6bf54c1162e51590297cc9c2073cdfcc", "patch": "@@ -700,6 +700,11 @@ fn link_natively(sess: &Session,\n \n     if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n         wasm::rewrite_imports(&out_filename, &codegen_results.crate_info.wasm_imports);\n+        wasm::add_producer_section(\n+            &out_filename,\n+            &sess.edition().to_string(),\n+            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n+        );\n     }\n }\n "}, {"sha": "1a5c65f3c43974e42ddfae1ff49502c367ea2a11", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=ab5e45ae6bf54c1162e51590297cc9c2073cdfcc", "patch": "@@ -17,6 +17,7 @@ use serialize::leb128;\n \n // https://webassembly.github.io/spec/core/binary/modules.html#binary-importsec\n const WASM_IMPORT_SECTION_ID: u8 = 2;\n+const WASM_CUSTOM_SECTION_ID: u8 = 0;\n \n const WASM_EXTERNAL_KIND_FUNCTION: u8 = 0;\n const WASM_EXTERNAL_KIND_TABLE: u8 = 1;\n@@ -121,6 +122,112 @@ pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n     }\n }\n \n+/// Add or augment the existing `producers` section to encode information about\n+/// the Rust compiler used to produce the wasm file.\n+pub fn add_producer_section(\n+    path: &Path,\n+    rust_version: &str,\n+    rustc_version: &str,\n+) {\n+    struct Field<'a> {\n+        name: &'a str,\n+        values: Vec<FieldValue<'a>>,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    struct FieldValue<'a> {\n+        name: &'a str,\n+        version: &'a str,\n+    }\n+\n+    let wasm = fs::read(path).expect(\"failed to read wasm output\");\n+    let mut ret = WasmEncoder::new();\n+    ret.data.extend(&wasm[..8]);\n+\n+    // skip the 8 byte wasm/version header\n+    let rustc_value = FieldValue {\n+        name: \"rustc\",\n+        version: rustc_version,\n+    };\n+    let rust_value = FieldValue {\n+        name: \"Rust\",\n+        version: rust_version,\n+    };\n+    let mut fields = Vec::new();\n+    let mut wrote_rustc = false;\n+    let mut wrote_rust = false;\n+\n+    // Move all sections from the original wasm file to our output, skipping\n+    // everything except the producers section\n+    for (id, raw) in WasmSections(WasmDecoder::new(&wasm[8..])) {\n+        if id != WASM_CUSTOM_SECTION_ID {\n+            ret.byte(id);\n+            ret.bytes(raw);\n+            continue\n+        }\n+        let mut decoder = WasmDecoder::new(raw);\n+        if decoder.str() != \"producers\" {\n+            ret.byte(id);\n+            ret.bytes(raw);\n+            continue\n+        }\n+\n+        // Read off the producers section into our fields outside the loop,\n+        // we'll re-encode the producers section when we're done (to handle an\n+        // entirely missing producers section as well).\n+        info!(\"rewriting existing producers section\");\n+\n+        for _ in 0..decoder.u32() {\n+            let name = decoder.str();\n+            let mut values = Vec::new();\n+            for _ in 0..decoder.u32() {\n+                let name = decoder.str();\n+                let version = decoder.str();\n+                values.push(FieldValue { name, version });\n+            }\n+\n+            if name == \"language\" {\n+                values.push(rust_value);\n+                wrote_rust = true;\n+            } else if name == \"processed-by\" {\n+                values.push(rustc_value);\n+                wrote_rustc = true;\n+            }\n+            fields.push(Field { name, values });\n+        }\n+    }\n+\n+    if !wrote_rust {\n+        fields.push(Field {\n+            name: \"language\",\n+            values: vec![rust_value],\n+        });\n+    }\n+    if !wrote_rustc {\n+        fields.push(Field {\n+            name: \"processed-by\",\n+            values: vec![rustc_value],\n+        });\n+    }\n+\n+    // Append the producers section to the end of the wasm file.\n+    let mut section = WasmEncoder::new();\n+    section.str(\"producers\");\n+    section.u32(fields.len() as u32);\n+    for field in fields {\n+        section.str(field.name);\n+        section.u32(field.values.len() as u32);\n+        for value in field.values {\n+            section.str(value.name);\n+            section.str(value.version);\n+        }\n+    }\n+    ret.byte(WASM_CUSTOM_SECTION_ID);\n+    ret.bytes(&section.data);\n+\n+    fs::write(path, &ret.data).expect(\"failed to write wasm output\");\n+}\n+\n struct WasmSections<'a>(WasmDecoder<'a>);\n \n impl<'a> Iterator for WasmSections<'a> {"}]}