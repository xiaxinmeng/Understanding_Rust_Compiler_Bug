{"sha": "27d6f55f47e8875e71083a28ed84ea5a88e1b596", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZDZmNTVmNDdlODg3NWU3MTA4M2EyOGVkODRlYTVhODhlMWI1OTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-11T19:39:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-11T19:39:06Z"}, "message": "Auto merge of #65345 - davidtwco:issue-64130-async-send-sync-error-improvements, r=nikomatsakis\n\nasync/await: improve not-send errors, part 2\n\nPart of #64130. Fixes #65667.\n\nThis PR improves the errors introduced in #64895 so that they have specialized messages for `Send` and `Sync`.\n\nr? @nikomatsakis", "tree": {"sha": "2f0866ff8e08df5d73b14362a3a4c0d9991dbfd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f0866ff8e08df5d73b14362a3a4c0d9991dbfd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27d6f55f47e8875e71083a28ed84ea5a88e1b596", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27d6f55f47e8875e71083a28ed84ea5a88e1b596", "html_url": "https://github.com/rust-lang/rust/commit/27d6f55f47e8875e71083a28ed84ea5a88e1b596", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27d6f55f47e8875e71083a28ed84ea5a88e1b596/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90b957a17c1abba979aa41234ce0993a61030e67", "url": "https://api.github.com/repos/rust-lang/rust/commits/90b957a17c1abba979aa41234ce0993a61030e67", "html_url": "https://github.com/rust-lang/rust/commit/90b957a17c1abba979aa41234ce0993a61030e67"}, {"sha": "5cd9f22464a3ae2620c384094986d9549eca182e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd9f22464a3ae2620c384094986d9549eca182e", "html_url": "https://github.com/rust-lang/rust/commit/5cd9f22464a3ae2620c384094986d9549eca182e"}], "stats": {"total": 649, "additions": 502, "deletions": 147}, "files": [{"sha": "288017b7ca53ef1d83bc0c512df7e748199bec6e", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -29,6 +29,7 @@ use crate::hash::Hasher;\n /// [arc]: ../../std/sync/struct.Arc.html\n /// [ub]: ../../reference/behavior-considered-undefined.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"send_trait\")]\n #[rustc_on_unimplemented(\n     message=\"`{Self}` cannot be sent between threads safely\",\n     label=\"`{Self}` cannot be sent between threads safely\"\n@@ -440,6 +441,7 @@ pub macro Copy($item:item) { /* compiler built-in */ }\n /// [ub]: ../../reference/behavior-considered-undefined.html\n /// [transmute]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"sync_trait\")]\n #[lang = \"sync\"]\n #[rustc_on_unimplemented(\n     message=\"`{Self}` cannot be shared between threads safely\","}, {"sha": "6a111895b5637bd982c4a7eb9e8aad19f60e50e4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 223, "deletions": 83, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -25,6 +25,7 @@ use crate::infer::{self, InferCtxt};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::session::DiagnosticMessageId;\n use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::TypeckTables;\n use crate::ty::GenericParamDefKind;\n use crate::ty::error::ExpectedFound;\n use crate::ty::fast_reject;\n@@ -2104,52 +2105,69 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         // First, attempt to add note to this error with an async-await-specific\n         // message, and fall back to regular note otherwise.\n-        if !self.note_obligation_cause_for_async_await(err, obligation) {\n+        if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n             self.note_obligation_cause_code(err, &obligation.predicate, &obligation.cause.code,\n                                             &mut vec![]);\n         }\n     }\n \n-    /// Adds an async-await specific note to the diagnostic:\n+    /// Adds an async-await specific note to the diagnostic when the future does not implement\n+    /// an auto trait because of a captured type.\n     ///\n     /// ```ignore (diagnostic)\n-    /// note: future does not implement `std::marker::Send` because this value is used across an\n-    ///       await\n-    ///   --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n+    /// note: future does not implement `Qux` as this value is used across an await\n+    ///   --> $DIR/issue-64130-3-other.rs:17:5\n     ///    |\n-    /// LL |     let g = x.lock().unwrap();\n-    ///    |         - has type `std::sync::MutexGuard<'_, u32>`\n+    /// LL |     let x = Foo;\n+    ///    |         - has type `Foo`\n     /// LL |     baz().await;\n-    ///    |     ^^^^^^^^^^^ await occurs here, with `g` maybe used later\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n     /// LL | }\n-    ///    | - `g` is later dropped here\n+    ///    | - `x` is later dropped here\n+    /// ```\n+    ///\n+    /// When the diagnostic does not implement `Send` or `Sync` specifically, then the diagnostic\n+    /// is \"replaced\" with a different message and a more specific error.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// error: future cannot be sent between threads safely\n+    ///   --> $DIR/issue-64130-2-send.rs:21:5\n+    ///    |\n+    /// LL | fn is_send<T: Send>(t: T) { }\n+    ///    |    -------    ---- required by this bound in `is_send`\n+    /// ...\n+    /// LL |     is_send(bar());\n+    ///    |     ^^^^^^^ future returned by `bar` is not send\n+    ///    |\n+    ///    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not\n+    ///            implemented for `Foo`\n+    /// note: future is not send as this value is used across an await\n+    ///   --> $DIR/issue-64130-2-send.rs:15:5\n+    ///    |\n+    /// LL |     let x = Foo;\n+    ///    |         - has type `Foo`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+    /// LL | }\n+    ///    | - `x` is later dropped here\n     /// ```\n     ///\n     /// Returns `true` if an async-await specific note was added to the diagnostic.\n-    fn note_obligation_cause_for_async_await(\n+    fn maybe_note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n-        debug!(\"note_obligation_cause_for_async_await: obligation.predicate={:?} \\\n+        debug!(\"maybe_note_obligation_cause_for_async_await: obligation.predicate={:?} \\\n                 obligation.cause.span={:?}\", obligation.predicate, obligation.cause.span);\n         let source_map = self.tcx.sess.source_map();\n \n-        // Look into the obligation predicate to determine the type in the generator which meant\n-        // that the predicate was not satisifed.\n-        let (trait_ref, target_ty) = match obligation.predicate {\n-            ty::Predicate::Trait(trait_predicate) =>\n-                (trait_predicate.skip_binder().trait_ref, trait_predicate.skip_binder().self_ty()),\n-            _ => return false,\n-        };\n-        debug!(\"note_obligation_cause_for_async_await: target_ty={:?}\", target_ty);\n-\n         // Attempt to detect an async-await error by looking at the obligation causes, looking\n-        // for only generators, generator witnesses, opaque types or `std::future::GenFuture` to\n-        // be present.\n+        // for a generator to be present.\n         //\n         // When a future does not implement a trait because of a captured type in one of the\n         // generators somewhere in the call stack, then the result is a chain of obligations.\n+        //\n         // Given a `async fn` A that calls a `async fn` B which captures a non-send type and that\n         // future is passed as an argument to a function C which requires a `Send` type, then the\n         // chain looks something like this:\n@@ -2166,100 +2184,222 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n         // - `BindingObligation` with `impl_send (Send requirement)\n         //\n-        // The first obligations in the chain can be used to get the details of the type that is\n-        // captured but the entire chain must be inspected to detect this case.\n+        // The first obligation in the chain is the most useful and has the generator that captured\n+        // the type. The last generator has information about where the bound was introduced. At\n+        // least one generator should be present for this diagnostic to be modified.\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate {\n+            ty::Predicate::Trait(p) =>\n+                (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty())),\n+            _ => (None, None),\n+        };\n         let mut generator = None;\n+        let mut last_generator = None;\n         let mut next_code = Some(&obligation.cause.code);\n         while let Some(code) = next_code {\n-            debug!(\"note_obligation_cause_for_async_await: code={:?}\", code);\n+            debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n             match code {\n                 ObligationCauseCode::BuiltinDerivedObligation(derived_obligation) |\n                 ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n-                    debug!(\"note_obligation_cause_for_async_await: self_ty.kind={:?}\",\n-                           derived_obligation.parent_trait_ref.self_ty().kind);\n-                    match derived_obligation.parent_trait_ref.self_ty().kind {\n-                        ty::Adt(ty::AdtDef { did, .. }, ..) if\n-                            self.tcx.is_diagnostic_item(sym::gen_future, *did) => {},\n-                        ty::Generator(did, ..) => generator = generator.or(Some(did)),\n-                        ty::GeneratorWitness(_) | ty::Opaque(..) => {},\n-                        _ => return false,\n+                    let ty = derived_obligation.parent_trait_ref.self_ty();\n+                    debug!(\"maybe_note_obligation_cause_for_async_await: \\\n+                            parent_trait_ref={:?} self_ty.kind={:?}\",\n+                           derived_obligation.parent_trait_ref, ty.kind);\n+\n+                    match ty.kind {\n+                        ty::Generator(did, ..) => {\n+                            generator = generator.or(Some(did));\n+                            last_generator = Some(did);\n+                        },\n+                        ty::GeneratorWitness(..) => {},\n+                        _ if generator.is_none() => {\n+                            trait_ref = Some(*derived_obligation.parent_trait_ref.skip_binder());\n+                            target_ty = Some(ty);\n+                        },\n+                        _ => {},\n                     }\n \n                     next_code = Some(derived_obligation.parent_code.as_ref());\n                 },\n-                ObligationCauseCode::ItemObligation(_) | ObligationCauseCode::BindingObligation(..)\n-                    if generator.is_some() => break,\n-                _ => return false,\n+                _ => break,\n             }\n         }\n \n-        let generator_did = generator.expect(\"can only reach this if there was a generator\");\n-\n-        // Only continue to add a note if the generator is from an `async` function.\n-        let parent_node = self.tcx.parent(generator_did)\n-            .and_then(|parent_did| self.tcx.hir().get_if_local(parent_did));\n-        debug!(\"note_obligation_cause_for_async_await: parent_node={:?}\", parent_node);\n-        if let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(sig, _, _),\n-            ..\n-        })) = parent_node {\n-            debug!(\"note_obligation_cause_for_async_await: header={:?}\", sig.header);\n-            if sig.header.asyncness != hir::IsAsync::Async {\n-                return false;\n-            }\n-        }\n+        // Only continue if a generator was found.\n+        debug!(\"maybe_note_obligation_cause_for_async_await: generator={:?} trait_ref={:?} \\\n+                target_ty={:?}\", generator, trait_ref, target_ty);\n+        let (generator_did, trait_ref, target_ty) = match (generator, trait_ref, target_ty) {\n+            (Some(generator_did), Some(trait_ref), Some(target_ty)) =>\n+                (generator_did, trait_ref, target_ty),\n+            _ => return false,\n+        };\n \n         let span = self.tcx.def_span(generator_did);\n+\n         // Do not ICE on closure typeck (#66868).\n         if let None = self.tcx.hir().as_local_hir_id(generator_did) {\n             return false;\n         }\n-        let tables = self.tcx.typeck_tables_of(generator_did);\n-        debug!(\"note_obligation_cause_for_async_await: generator_did={:?} span={:?} \",\n-               generator_did, span);\n+\n+        // Get the tables from the infcx if the generator is the function we are\n+        // currently type-checking; otherwise, get them by performing a query.\n+        // This is needed to avoid cycles.\n+        let in_progress_tables = self.in_progress_tables.map(|t| t.borrow());\n+        let generator_did_root = self.tcx.closure_base_def_id(generator_did);\n+        debug!(\"maybe_note_obligation_cause_for_async_await: generator_did={:?} \\\n+             generator_did_root={:?} in_progress_tables.local_id_root={:?} span={:?}\",\n+            generator_did, generator_did_root,\n+            in_progress_tables.as_ref().map(|t| t.local_id_root), span);\n+        let query_tables;\n+        let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n+            Some(t) if t.local_id_root == Some(generator_did_root) => t,\n+            _ => {\n+                query_tables = self.tcx.typeck_tables_of(generator_did);\n+                &query_tables\n+            }\n+        };\n \n         // Look for a type inside the generator interior that matches the target type to get\n         // a span.\n+        let target_ty_erased = self.tcx.erase_regions(&target_ty);\n         let target_span = tables.generator_interior_types.iter()\n-            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty::TyS::same_type(*ty, target_ty))\n+            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| {\n+                // Careful: the regions for types that appear in the\n+                // generator interior are not generally known, so we\n+                // want to erase them when comparing (and anyway,\n+                // `Send` and other bounds are generally unaffected by\n+                // the choice of region).  When erasing regions, we\n+                // also have to erase late-bound regions. This is\n+                // because the types that appear in the generator\n+                // interior generally contain \"bound regions\" to\n+                // represent regions that are part of the suspended\n+                // generator frame. Bound regions are preserved by\n+                // `erase_regions` and so we must also call\n+                // `erase_late_bound_regions`.\n+                let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(*ty));\n+                let ty_erased = self.tcx.erase_regions(&ty_erased);\n+                let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n+                debug!(\"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n+                        target_ty_erased={:?} eq={:?}\", ty_erased, target_ty_erased, eq);\n+                eq\n+            })\n             .map(|ty::GeneratorInteriorTypeCause { span, scope_span, .. }|\n                  (span, source_map.span_to_snippet(*span), scope_span));\n+        debug!(\"maybe_note_obligation_cause_for_async_await: target_ty={:?} \\\n+                generator_interior_types={:?} target_span={:?}\",\n+                target_ty, tables.generator_interior_types, target_span);\n         if let Some((target_span, Ok(snippet), scope_span)) = target_span {\n-            // Look at the last interior type to get a span for the `.await`.\n-            let await_span = tables.generator_interior_types.iter().map(|i| i.span).last().unwrap();\n-            let mut span = MultiSpan::from_span(await_span);\n-            span.push_span_label(\n-                await_span, format!(\"await occurs here, with `{}` maybe used later\", snippet));\n-\n-            span.push_span_label(*target_span, format!(\"has type `{}`\", target_ty));\n+            self.note_obligation_cause_for_async_await(\n+                err, *target_span, scope_span, snippet, generator_did, last_generator,\n+                trait_ref, target_ty, tables, obligation, next_code,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n \n-            // If available, use the scope span to annotate the drop location.\n-            if let Some(scope_span) = scope_span {\n-                span.push_span_label(\n-                    source_map.end_point(*scope_span),\n-                    format!(\"`{}` is later dropped here\", snippet),\n-                );\n-            }\n+    /// Unconditionally adds the diagnostic note described in\n+    /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n+    fn note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        target_span: Span,\n+        scope_span: &Option<Span>,\n+        snippet: String,\n+        first_generator: DefId,\n+        last_generator: Option<DefId>,\n+        trait_ref: ty::TraitRef<'_>,\n+        target_ty: Ty<'tcx>,\n+        tables: &ty::TypeckTables<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        next_code: Option<&ObligationCauseCode<'tcx>>,\n+    ) {\n+        let source_map = self.tcx.sess.source_map();\n \n-            err.span_note(span, &format!(\n-                \"future does not implement `{}` as this value is used across an await\",\n-                trait_ref.print_only_trait_path(),\n-            ));\n+        let is_async_fn = self.tcx.parent(first_generator)\n+            .map(|parent_did| self.tcx.asyncness(parent_did))\n+            .map(|parent_asyncness| parent_asyncness == hir::IsAsync::Async)\n+            .unwrap_or(false);\n+        let is_async_move = self.tcx.hir().as_local_hir_id(first_generator)\n+            .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n+            .map(|body_id| self.tcx.hir().body(body_id))\n+            .and_then(|body| body.generator_kind())\n+            .map(|generator_kind| match generator_kind {\n+                hir::GeneratorKind::Async(..) => true,\n+                _ => false,\n+            })\n+            .unwrap_or(false);\n+        let await_or_yield = if is_async_fn || is_async_move { \"await\" } else { \"yield\" };\n+\n+        // Special case the primary error message when send or sync is the trait that was\n+        // not implemented.\n+        let is_send = self.tcx.is_diagnostic_item(sym::send_trait, trait_ref.def_id);\n+        let is_sync = self.tcx.is_diagnostic_item(sym::sync_trait, trait_ref.def_id);\n+        let trait_explanation = if is_send || is_sync {\n+            let (trait_name, trait_verb) = if is_send {\n+                (\"`Send`\", \"sent\")\n+            } else {\n+                (\"`Sync`\", \"shared\")\n+            };\n \n-            // Add a note for the item obligation that remains - normally a note pointing to the\n-            // bound that introduced the obligation (e.g. `T: Send`).\n-            debug!(\"note_obligation_cause_for_async_await: next_code={:?}\", next_code);\n-            self.note_obligation_cause_code(\n-                err,\n-                &obligation.predicate,\n-                next_code.unwrap(),\n-                &mut Vec::new(),\n+            err.clear_code();\n+            err.set_primary_message(\n+                format!(\"future cannot be {} between threads safely\", trait_verb)\n             );\n \n-            true\n+            let original_span = err.span.primary_span().unwrap();\n+            let mut span = MultiSpan::from_span(original_span);\n+\n+            let message = if let Some(name) = last_generator\n+                .and_then(|generator_did| self.tcx.parent(generator_did))\n+                .and_then(|parent_did| self.tcx.hir().as_local_hir_id(parent_did))\n+                .map(|parent_hir_id| self.tcx.hir().name(parent_hir_id))\n+            {\n+                format!(\"future returned by `{}` is not {}\", name, trait_name)\n+            } else {\n+                format!(\"future is not {}\", trait_name)\n+            };\n+\n+            span.push_span_label(original_span, message);\n+            err.set_span(span);\n+\n+            format!(\"is not {}\", trait_name)\n         } else {\n-            false\n+            format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n+        };\n+\n+        // Look at the last interior type to get a span for the `.await`.\n+        let await_span = tables.generator_interior_types.iter().map(|i| i.span).last().unwrap();\n+        let mut span = MultiSpan::from_span(await_span);\n+        span.push_span_label(\n+            await_span,\n+            format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet));\n+\n+        span.push_span_label(target_span, format!(\"has type `{}`\", target_ty));\n+\n+        // If available, use the scope span to annotate the drop location.\n+        if let Some(scope_span) = scope_span {\n+            span.push_span_label(\n+                source_map.end_point(*scope_span),\n+                format!(\"`{}` is later dropped here\", snippet),\n+            );\n         }\n+\n+        err.span_note(span, &format!(\n+            \"future {} as this value is used across an {}\",\n+            trait_explanation,\n+            await_or_yield,\n+        ));\n+\n+        // Add a note for the item obligation that remains - normally a note pointing to the\n+        // bound that introduced the obligation (e.g. `T: Send`).\n+        debug!(\"note_obligation_cause_for_async_await: next_code={:?}\", next_code);\n+        self.note_obligation_cause_code(\n+            err,\n+            &obligation.predicate,\n+            next_code.unwrap(),\n+            &mut Vec::new(),\n+        );\n     }\n \n     fn note_obligation_cause_code<T>(&self,"}, {"sha": "744f4a47b6035763c666ac9ac75849b8805300ea", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -498,10 +498,20 @@ impl Diagnostic {\n         self\n     }\n \n+    pub fn clear_code(&mut self) -> &mut Self {\n+        self.code = None;\n+        self\n+    }\n+\n     pub fn get_code(&self) -> Option<DiagnosticId> {\n         self.code.clone()\n     }\n \n+    pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n+        self.message[0] = (msg.into(), Style::NoStyle);\n+        self\n+    }\n+\n     pub fn message(&self) -> String {\n         self.message.iter().map(|i| i.0.as_str()).collect::<String>()\n     }"}, {"sha": "ac1ef3e1d8b72a6b319636ebaa17c8e7c5c084aa", "filename": "src/libstd/future.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -26,7 +26,6 @@ pub fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T:\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"gen_future\")]\n struct GenFuture<T: Generator<Yield = ()>>(T);\n \n // We rely on the fact that async/await futures are immovable in order to create"}, {"sha": "92de56bd09a7acc4d150b75fb1020de360d22e3e", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -660,6 +660,7 @@ symbols! {\n         _Self,\n         self_in_typedefs,\n         self_struct_ctor,\n+        send_trait,\n         should_panic,\n         simd,\n         simd_extract,\n@@ -697,6 +698,7 @@ symbols! {\n         sty,\n         sub_with_overflow,\n         suggestion,\n+        sync_trait,\n         target_feature,\n         target_has_atomic,\n         target_has_atomic_load_store,"}, {"sha": "645c903c6bab20c62e86e9953397592ee55ca7bd", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -48,10 +48,10 @@ fn assert_send(_: impl Send) {}\n \n pub fn pass_assert() {\n     assert_send(local_dropped_before_await());\n-    //~^ ERROR `std::rc::Rc<()>` cannot be sent between threads safely\n+    //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_send_temporary_in_match());\n-    //~^ ERROR `std::rc::Rc<()>` cannot be sent between threads safely\n+    //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_sync_with_method_call());\n-    //~^ ERROR `dyn std::fmt::Write` cannot be sent between threads safely\n-    //~^^ ERROR `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+    //~^ ERROR future cannot be sent between threads safely\n+    //~^^ ERROR future cannot be sent between threads safely\n }"}, {"sha": "5c870ca2d0276825fe84e72a4054d53c6c1a6e32", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -1,79 +1,88 @@\n-error[E0277]: `std::rc::Rc<()>` cannot be sent between threads safely\n+error: future cannot be sent between threads safely\n   --> $DIR/async-fn-nonsend.rs:50:5\n    |\n LL | fn assert_send(_: impl Send) {}\n    |    -----------         ---- required by this bound in `assert_send`\n ...\n LL |     assert_send(local_dropped_before_await());\n-   |     ^^^^^^^^^^^ `std::rc::Rc<()>` cannot be sent between threads safely\n+   |     ^^^^^^^^^^^ future returned by `local_dropped_before_await` is not `Send`\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n-   = note: required because it appears within the type `impl std::fmt::Debug`\n-   = note: required because it appears within the type `{impl std::fmt::Debug, impl std::future::Future, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, impl std::future::Future, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:21:39: 26:2 {impl std::fmt::Debug, impl std::future::Future, impl std::future::Future, ()}]>`\n-   = note: required because it appears within the type `impl std::future::Future`\n-   = note: required because it appears within the type `impl std::future::Future`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-fn-nonsend.rs:25:5\n+   |\n+LL |     let x = non_send();\n+   |         - has type `impl std::fmt::Debug`\n+LL |     drop(x);\n+LL |     fut().await;\n+   |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+LL | }\n+   | - `x` is later dropped here\n \n-error[E0277]: `std::rc::Rc<()>` cannot be sent between threads safely\n+error: future cannot be sent between threads safely\n   --> $DIR/async-fn-nonsend.rs:52:5\n    |\n LL | fn assert_send(_: impl Send) {}\n    |    -----------         ---- required by this bound in `assert_send`\n ...\n LL |     assert_send(non_send_temporary_in_match());\n-   |     ^^^^^^^^^^^ `std::rc::Rc<()>` cannot be sent between threads safely\n+   |     ^^^^^^^^^^^ future returned by `non_send_temporary_in_match` is not `Send`\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n-   = note: required because it appears within the type `impl std::fmt::Debug`\n-   = note: required because it appears within the type `{impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:28:40: 37:2 {impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, impl std::future::Future, ()}]>`\n-   = note: required because it appears within the type `impl std::future::Future`\n-   = note: required because it appears within the type `impl std::future::Future`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-fn-nonsend.rs:34:20\n+   |\n+LL |     match Some(non_send()) {\n+   |                ---------- has type `impl std::fmt::Debug`\n+LL |         Some(_) => fut().await,\n+   |                    ^^^^^^^^^^^ await occurs here, with `non_send()` maybe used later\n+...\n+LL | }\n+   | - `non_send()` is later dropped here\n \n-error[E0277]: `dyn std::fmt::Write` cannot be sent between threads safely\n+error: future cannot be sent between threads safely\n   --> $DIR/async-fn-nonsend.rs:54:5\n    |\n LL | fn assert_send(_: impl Send) {}\n    |    -----------         ---- required by this bound in `assert_send`\n ...\n LL |     assert_send(non_sync_with_method_call());\n-   |     ^^^^^^^^^^^ `dyn std::fmt::Write` cannot be sent between threads safely\n+   |     ^^^^^^^^^^^ future returned by `non_sync_with_method_call` is not `Send`\n    |\n    = help: the trait `std::marker::Send` is not implemented for `dyn std::fmt::Write`\n-   = note: required because of the requirements on the impl of `std::marker::Send` for `&mut dyn std::fmt::Write`\n-   = note: required because it appears within the type `std::fmt::Formatter<'_>`\n-   = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n-   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, impl std::future::Future, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, impl std::future::Future, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, impl std::future::Future, impl std::future::Future, ()}]>`\n-   = note: required because it appears within the type `impl std::future::Future`\n-   = note: required because it appears within the type `impl std::future::Future`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-fn-nonsend.rs:43:9\n+   |\n+LL |     let f: &mut std::fmt::Formatter = panic!();\n+   |         - has type `&mut std::fmt::Formatter<'_>`\n+LL |     if non_sync().fmt(f).unwrap() == () {\n+LL |         fut().await;\n+   |         ^^^^^^^^^^^ await occurs here, with `f` maybe used later\n+LL |     }\n+LL | }\n+   | - `f` is later dropped here\n \n-error[E0277]: `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+error: future cannot be sent between threads safely\n   --> $DIR/async-fn-nonsend.rs:54:5\n    |\n LL | fn assert_send(_: impl Send) {}\n    |    -----------         ---- required by this bound in `assert_send`\n ...\n LL |     assert_send(non_sync_with_method_call());\n-   |     ^^^^^^^^^^^ `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+   |     ^^^^^^^^^^^ future returned by `non_sync_with_method_call` is not `Send`\n    |\n    = help: within `std::fmt::ArgumentV1<'_>`, the trait `std::marker::Sync` is not implemented for `*mut (dyn std::ops::Fn() + 'static)`\n-   = note: required because it appears within the type `std::marker::PhantomData<*mut (dyn std::ops::Fn() + 'static)>`\n-   = note: required because it appears within the type `core::fmt::Void`\n-   = note: required because it appears within the type `&core::fmt::Void`\n-   = note: required because it appears within the type `std::fmt::ArgumentV1<'_>`\n-   = note: required because of the requirements on the impl of `std::marker::Send` for `std::slice::Iter<'_, std::fmt::ArgumentV1<'_>>`\n-   = note: required because it appears within the type `std::fmt::Formatter<'_>`\n-   = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n-   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, impl std::future::Future, impl std::future::Future, ()}`\n-   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, impl std::future::Future, impl std::future::Future, ()}]`\n-   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:39:38: 45:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, bool, impl std::future::Future, impl std::future::Future, ()}]>`\n-   = note: required because it appears within the type `impl std::future::Future`\n-   = note: required because it appears within the type `impl std::future::Future`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-fn-nonsend.rs:43:9\n+   |\n+LL |     let f: &mut std::fmt::Formatter = panic!();\n+   |         - has type `&mut std::fmt::Formatter<'_>`\n+LL |     if non_sync().fmt(f).unwrap() == () {\n+LL |         fut().await;\n+   |         ^^^^^^^^^^^ await occurs here, with `f` maybe used later\n+LL |     }\n+LL | }\n+   | - `f` is later dropped here\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "cc5ca89f03af0ebce8adebc5650e9a4cd6daf941", "filename": "src/test/ui/async-await/issue-64130-1-sync.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -0,0 +1,23 @@\n+#![feature(optin_builtin_traits)]\n+// edition:2018\n+\n+// This tests the the specialized async-await-specific error when futures don't implement an\n+// auto trait (which is specifically Sync) due to some type that was captured.\n+\n+struct Foo;\n+\n+impl !Sync for Foo {}\n+\n+fn is_sync<T: Sync>(t: T) { }\n+\n+async fn bar() {\n+    let x = Foo;\n+    baz().await;\n+}\n+\n+async fn baz() { }\n+\n+fn main() {\n+    is_sync(bar());\n+    //~^ ERROR future cannot be shared between threads safely\n+}"}, {"sha": "8beb31f152a9d49f8df222c9715cbd86a0309796", "filename": "src/test/ui/async-await/issue-64130-1-sync.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.stderr?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -0,0 +1,22 @@\n+error: future cannot be shared between threads safely\n+  --> $DIR/issue-64130-1-sync.rs:21:5\n+   |\n+LL | fn is_sync<T: Sync>(t: T) { }\n+   |    -------    ---- required by this bound in `is_sync`\n+...\n+LL |     is_sync(bar());\n+   |     ^^^^^^^ future returned by `bar` is not `Sync`\n+   |\n+   = help: within `impl std::future::Future`, the trait `std::marker::Sync` is not implemented for `Foo`\n+note: future is not `Sync` as this value is used across an await\n+  --> $DIR/issue-64130-1-sync.rs:15:5\n+   |\n+LL |     let x = Foo;\n+   |         - has type `Foo`\n+LL |     baz().await;\n+   |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+LL | }\n+   | - `x` is later dropped here\n+\n+error: aborting due to previous error\n+"}, {"sha": "1efe2ab3f85e270a5d1a0d8c3f60b94e4903a7bb", "filename": "src/test/ui/async-await/issue-64130-2-send.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -0,0 +1,23 @@\n+#![feature(optin_builtin_traits)]\n+// edition:2018\n+\n+// This tests the the specialized async-await-specific error when futures don't implement an\n+// auto trait (which is specifically Send) due to some type that was captured.\n+\n+struct Foo;\n+\n+impl !Send for Foo {}\n+\n+fn is_send<T: Send>(t: T) { }\n+\n+async fn bar() {\n+    let x = Foo;\n+    baz().await;\n+}\n+\n+async fn baz() { }\n+\n+fn main() {\n+    is_send(bar());\n+    //~^ ERROR future cannot be sent between threads safely\n+}"}, {"sha": "823b88e18c5b6d8ee57a1f6336fe1b2f8f568c4a", "filename": "src/test/ui/async-await/issue-64130-2-send.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.stderr?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -0,0 +1,22 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-64130-2-send.rs:21:5\n+   |\n+LL | fn is_send<T: Send>(t: T) { }\n+   |    -------    ---- required by this bound in `is_send`\n+...\n+LL |     is_send(bar());\n+   |     ^^^^^^^ future returned by `bar` is not `Send`\n+   |\n+   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `Foo`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/issue-64130-2-send.rs:15:5\n+   |\n+LL |     let x = Foo;\n+   |         - has type `Foo`\n+LL |     baz().await;\n+   |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+LL | }\n+   | - `x` is later dropped here\n+\n+error: aborting due to previous error\n+"}, {"sha": "901544edba18a65fa0b01185a5c87bf156e40c90", "filename": "src/test/ui/async-await/issue-64130-3-other.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -0,0 +1,25 @@\n+#![feature(optin_builtin_traits)]\n+// edition:2018\n+\n+// This tests the the unspecialized async-await-specific error when futures don't implement an\n+// auto trait (which is not Send or Sync) due to some type that was captured.\n+\n+auto trait Qux { }\n+\n+struct Foo;\n+\n+impl !Qux for Foo {}\n+\n+fn is_qux<T: Qux>(t: T) { }\n+\n+async fn bar() {\n+    let x = Foo;\n+    baz().await;\n+}\n+\n+async fn baz() { }\n+\n+fn main() {\n+    is_qux(bar());\n+    //~^ ERROR the trait bound `Foo: Qux` is not satisfied in `impl std::future::Future`\n+}"}, {"sha": "155c5cc8ea13796a9a690453155bf39549b7e0e6", "filename": "src/test/ui/async-await/issue-64130-3-other.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: the trait bound `Foo: Qux` is not satisfied in `impl std::future::Future`\n+  --> $DIR/issue-64130-3-other.rs:23:5\n+   |\n+LL | fn is_qux<T: Qux>(t: T) { }\n+   |    ------    --- required by this bound in `is_qux`\n+...\n+LL |     is_qux(bar());\n+   |     ^^^^^^ within `impl std::future::Future`, the trait `Qux` is not implemented for `Foo`\n+   |\n+   = help: the following implementations were found:\n+             <Foo as Qux>\n+note: future does not implement `Qux` as this value is used across an await\n+  --> $DIR/issue-64130-3-other.rs:17:5\n+   |\n+LL |     let x = Foo;\n+   |         - has type `Foo`\n+LL |     baz().await;\n+   |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+LL | }\n+   | - `x` is later dropped here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2538f34351e5a51fab1fc4432a1445861b08202c", "filename": "src/test/ui/async-await/issue-64130-4-async-move.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -0,0 +1,28 @@\n+// edition:2018\n+use std::any::Any;\n+use std::future::Future;\n+\n+struct Client(Box<dyn Any + Send>);\n+\n+impl Client {\n+    fn status(&self) -> u16 {\n+        200\n+    }\n+}\n+\n+async fn get() { }\n+\n+pub fn foo() -> impl Future + Send {\n+    //~^ ERROR future cannot be sent between threads safely\n+    let client = Client(Box::new(true));\n+    async move {\n+        match client.status() {\n+            200 => {\n+                let _x = get().await;\n+            },\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ddbb469b99c2489a1f4e33907d586830ca54d59d", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -0,0 +1,22 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-64130-4-async-move.rs:15:17\n+   |\n+LL | pub fn foo() -> impl Future + Send {\n+   |                 ^^^^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `(dyn std::any::Any + std::marker::Send + 'static)`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/issue-64130-4-async-move.rs:21:26\n+   |\n+LL |         match client.status() {\n+   |               ------ has type `&Client`\n+LL |             200 => {\n+LL |                 let _x = get().await;\n+   |                          ^^^^^^^^^^^ await occurs here, with `client` maybe used later\n+...\n+LL |     }\n+   |     - `client` is later dropped here\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to previous error\n+"}, {"sha": "656ade67c71a7a3eb9d165cce773fcd154a98811", "filename": "src/test/ui/async-await/issue-64130-non-send-future-diags.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -1,10 +1,10 @@\n // edition:2018\n \n-use std::sync::Mutex;\n+// This tests the basic example case for the async-await-specific error.\n \n-fn is_send<T: Send>(t: T) {\n+use std::sync::Mutex;\n \n-}\n+fn is_send<T: Send>(t: T) { }\n \n async fn foo() {\n     bar(&Mutex::new(22)).await;\n@@ -15,11 +15,9 @@ async fn bar(x: &Mutex<u32>) {\n     baz().await;\n }\n \n-async fn baz() {\n-\n-}\n+async fn baz() { }\n \n fn main() {\n     is_send(foo());\n-    //~^ ERROR `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely [E0277]\n+    //~^ ERROR future cannot be sent between threads safely\n }"}, {"sha": "662407f7017f5384364a805692bc71eda1874fdd", "filename": "src/test/ui/async-await/issue-64130-non-send-future-diags.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-non-send-future-diags.stderr?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -1,14 +1,14 @@\n-error[E0277]: `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely\n-  --> $DIR/issue-64130-non-send-future-diags.rs:23:5\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-64130-non-send-future-diags.rs:21:5\n    |\n-LL | fn is_send<T: Send>(t: T) {\n+LL | fn is_send<T: Send>(t: T) { }\n    |    -------    ---- required by this bound in `is_send`\n ...\n LL |     is_send(foo());\n-   |     ^^^^^^^ `std::sync::MutexGuard<'_, u32>` cannot be sent between threads safely\n+   |     ^^^^^^^ future returned by `foo` is not `Send`\n    |\n    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard<'_, u32>`\n-note: future does not implement `std::marker::Send` as this value is used across an await\n+note: future is not `Send` as this value is used across an await\n   --> $DIR/issue-64130-non-send-future-diags.rs:15:5\n    |\n LL |     let g = x.lock().unwrap();\n@@ -20,4 +20,3 @@ LL | }\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "0db01c6f756aca80e8fc910a64b289b55b3b63f0", "filename": "src/test/ui/generator/not-send-sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     fn assert_send<T: Send>(_: T) {}\n \n     assert_sync(|| {\n-        //~^ ERROR: E0277\n+        //~^ ERROR: future cannot be shared between threads safely\n         let a = Cell::new(2);\n         yield;\n     });"}, {"sha": "0ac1d189b79b06e255f40c4ac024386a25f04ead", "filename": "src/test/ui/generator/not-send-sync.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -11,18 +11,25 @@ LL |     assert_send(|| {\n    = note: required because of the requirements on the impl of `std::marker::Send` for `&std::cell::Cell<i32>`\n    = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:16:17: 20:6 a:&std::cell::Cell<i32> _]`\n \n-error[E0277]: `std::cell::Cell<i32>` cannot be shared between threads safely\n+error: future cannot be shared between threads safely\n   --> $DIR/not-send-sync.rs:9:5\n    |\n LL |     fn assert_sync<T: Sync>(_: T) {}\n    |        -----------    ---- required by this bound in `main::assert_sync`\n ...\n LL |     assert_sync(|| {\n-   |     ^^^^^^^^^^^ `std::cell::Cell<i32>` cannot be shared between threads safely\n+   |     ^^^^^^^^^^^ future returned by `main` is not `Sync`\n    |\n    = help: within `[generator@$DIR/not-send-sync.rs:9:17: 13:6 {std::cell::Cell<i32>, ()}]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n-   = note: required because it appears within the type `{std::cell::Cell<i32>, ()}`\n-   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:9:17: 13:6 {std::cell::Cell<i32>, ()}]`\n+note: future is not `Sync` as this value is used across an yield\n+  --> $DIR/not-send-sync.rs:12:9\n+   |\n+LL |         let a = Cell::new(2);\n+   |             - has type `std::cell::Cell<i32>`\n+LL |         yield;\n+   |         ^^^^^ yield occurs here, with `a` maybe used later\n+LL |     });\n+   |     - `a` is later dropped here\n \n error: aborting due to 2 previous errors\n "}]}