{"sha": "1335608dae47cf8baa1dd2e8809264b030e85c3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMzU2MDhkYWU0N2NmOGJhYTFkZDJlODgwOTI2NGIwMzBlODVjM2U=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-03-31T21:50:45Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-04-01T10:03:56Z"}, "message": "Unite record completion logic into a single module", "tree": {"sha": "82146ddc9953c579aa779135d6d06b7a0366f484", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82146ddc9953c579aa779135d6d06b7a0366f484"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1335608dae47cf8baa1dd2e8809264b030e85c3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1335608dae47cf8baa1dd2e8809264b030e85c3e", "html_url": "https://github.com/rust-lang/rust/commit/1335608dae47cf8baa1dd2e8809264b030e85c3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1335608dae47cf8baa1dd2e8809264b030e85c3e/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d35b94352090c201f7e0cceae43035ee0e72df98", "url": "https://api.github.com/repos/rust-lang/rust/commits/d35b94352090c201f7e0cceae43035ee0e72df98", "html_url": "https://github.com/rust-lang/rust/commit/d35b94352090c201f7e0cceae43035ee0e72df98"}], "stats": {"total": 863, "additions": 413, "deletions": 450}, "files": [{"sha": "93157bbba63f4879e7a6dfef5fe6cbcb1b705194", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 2, "deletions": 64, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1335608dae47cf8baa1dd2e8809264b030e85c3e/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1335608dae47cf8baa1dd2e8809264b030e85c3e/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=1335608dae47cf8baa1dd2e8809264b030e85c3e", "patch": "@@ -5,8 +5,7 @@ mod completion_context;\n mod presentation;\n \n mod complete_dot;\n-mod complete_record_literal;\n-mod complete_record_pattern;\n+mod complete_record;\n mod complete_pattern;\n mod complete_fn_param;\n mod complete_keyword;\n@@ -32,12 +31,6 @@ use crate::{\n pub use crate::completion::completion_item::{\n     CompletionItem, CompletionItemKind, InsertTextFormat,\n };\n-use either::Either;\n-use hir::{StructField, Type};\n-use ra_syntax::{\n-    ast::{self, NameOwner},\n-    SmolStr,\n-};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct CompletionConfig {\n@@ -95,66 +88,11 @@ pub(crate) fn completions(\n     complete_path::complete_path(&mut acc, &ctx);\n     complete_scope::complete_scope(&mut acc, &ctx);\n     complete_dot::complete_dot(&mut acc, &ctx);\n-    complete_record_literal::complete_record_literal(&mut acc, &ctx);\n-    complete_record_pattern::complete_record_pattern(&mut acc, &ctx);\n+    complete_record::complete_record(&mut acc, &ctx);\n     complete_pattern::complete_pattern(&mut acc, &ctx);\n     complete_postfix::complete_postfix(&mut acc, &ctx);\n     complete_macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);\n     complete_trait_impl::complete_trait_impl(&mut acc, &ctx);\n \n     Some(acc)\n }\n-\n-pub(crate) fn get_missing_fields(\n-    ctx: &CompletionContext,\n-    record: Either<&ast::RecordLit, &ast::RecordPat>,\n-) -> Option<Vec<(StructField, Type)>> {\n-    let (ty, variant) = match record {\n-        Either::Left(record_lit) => (\n-            ctx.sema.type_of_expr(&record_lit.clone().into())?,\n-            ctx.sema.resolve_record_literal(record_lit)?,\n-        ),\n-        Either::Right(record_pat) => (\n-            ctx.sema.type_of_pat(&record_pat.clone().into())?,\n-            ctx.sema.resolve_record_pattern(record_pat)?,\n-        ),\n-    };\n-\n-    let already_present_names = get_already_present_names(record);\n-    Some(\n-        ty.variant_fields(ctx.db, variant)\n-            .into_iter()\n-            .filter(|(field, _)| {\n-                !already_present_names.contains(&SmolStr::from(field.name(ctx.db).to_string()))\n-            })\n-            .collect(),\n-    )\n-}\n-\n-fn get_already_present_names(record: Either<&ast::RecordLit, &ast::RecordPat>) -> Vec<SmolStr> {\n-    // TODO kb have a single match\n-    match record {\n-        Either::Left(record_lit) => record_lit\n-            .record_field_list()\n-            .map(|field_list| field_list.fields())\n-            .map(|fields| {\n-                fields\n-                    .into_iter()\n-                    .filter_map(|field| field.name_ref())\n-                    .map(|name_ref| name_ref.text().clone())\n-                    .collect()\n-            })\n-            .unwrap_or_default(),\n-        Either::Right(record_pat) => record_pat\n-            .record_field_pat_list()\n-            .map(|pat_list| pat_list.bind_pats())\n-            .map(|bind_pats| {\n-                bind_pats\n-                    .into_iter()\n-                    .filter_map(|pat| pat.name())\n-                    .map(|name| name.text().clone())\n-                    .collect()\n-            })\n-            .unwrap_or_default(),\n-    }\n-}"}, {"sha": "01dd8c6db70853f5b0b176179b9acd35764ce4fb", "filename": "crates/ra_ide/src/completion/complete_record.rs", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/1335608dae47cf8baa1dd2e8809264b030e85c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1335608dae47cf8baa1dd2e8809264b030e85c3e/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs?ref=1335608dae47cf8baa1dd2e8809264b030e85c3e", "patch": "@@ -0,0 +1,411 @@\n+//! Complete fields in record literals and patterns.\n+use crate::completion::{CompletionContext, Completions};\n+use ra_syntax::{ast, ast::NameOwner, SmolStr};\n+\n+pub(super) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    let (ty, variant, already_present_fields) =\n+        match (ctx.record_lit_pat.as_ref(), ctx.record_lit_syntax.as_ref()) {\n+            (None, None) => return None,\n+            (Some(_), Some(_)) => panic!(\"A record cannot be both a literal and a pattern\"),\n+            (Some(record_pat), _) => (\n+                ctx.sema.type_of_pat(&record_pat.clone().into())?,\n+                ctx.sema.resolve_record_pattern(record_pat)?,\n+                pattern_ascribed_fields(record_pat),\n+            ),\n+            (_, Some(record_lit)) => (\n+                ctx.sema.type_of_expr(&record_lit.clone().into())?,\n+                ctx.sema.resolve_record_literal(record_lit)?,\n+                literal_ascribed_fields(record_lit),\n+            ),\n+        };\n+\n+    for (field, field_ty) in ty.variant_fields(ctx.db, variant).into_iter().filter(|(field, _)| {\n+        // FIXME: already_present_names better be `Vec<hir::Name>`\n+        !already_present_fields.contains(&SmolStr::from(field.name(ctx.db).to_string()))\n+    }) {\n+        acc.add_field(ctx, field, &field_ty);\n+    }\n+    Some(())\n+}\n+\n+fn literal_ascribed_fields(record_lit: &ast::RecordLit) -> Vec<SmolStr> {\n+    record_lit\n+        .record_field_list()\n+        .map(|field_list| field_list.fields())\n+        .map(|fields| {\n+            fields\n+                .into_iter()\n+                .filter_map(|field| field.name_ref())\n+                .map(|name_ref| name_ref.text().clone())\n+                .collect()\n+        })\n+        .unwrap_or_default()\n+}\n+\n+fn pattern_ascribed_fields(record_pat: &ast::RecordPat) -> Vec<SmolStr> {\n+    record_pat\n+        .record_field_pat_list()\n+        .map(|pat_list| {\n+            pat_list\n+                .record_field_pats()\n+                .filter_map(|fild_pat| fild_pat.name())\n+                .chain(pat_list.bind_pats().filter_map(|bind_pat| bind_pat.name()))\n+                .map(|name| name.text().clone())\n+                .collect()\n+        })\n+        .unwrap_or_default()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    mod record_lit_tests {\n+        use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n+        use insta::assert_debug_snapshot;\n+\n+        fn complete(code: &str) -> Vec<CompletionItem> {\n+            do_completion(code, CompletionKind::Reference)\n+        }\n+\n+        #[test]\n+        fn test_record_pattern_field() {\n+            let completions = complete(\n+                r\"\n+            struct S { foo: u32 }\n+\n+            fn process(f: S) {\n+                match f {\n+                    S { f<|>: 92 } => (),\n+                }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"foo\",\n+                source_range: [117; 118),\n+                delete: [117; 118),\n+                insert: \"foo\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_pattern_enum_variant() {\n+            let completions = complete(\n+                r\"\n+            enum E {\n+                S { foo: u32, bar: () }\n+            }\n+\n+            fn process(e: E) {\n+                match e {\n+                    E::S { <|> } => (),\n+                }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"bar\",\n+                source_range: [161; 161),\n+                delete: [161; 161),\n+                insert: \"bar\",\n+                kind: Field,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"foo\",\n+                source_range: [161; 161),\n+                delete: [161; 161),\n+                insert: \"foo\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_pattern_field_in_simple_macro() {\n+            let completions = complete(\n+                r\"\n+            macro_rules! m { ($e:expr) => { $e } }\n+            struct S { foo: u32 }\n+\n+            fn process(f: S) {\n+                m!(match f {\n+                    S { f<|>: 92 } => (),\n+                })\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"foo\",\n+                source_range: [171; 172),\n+                delete: [171; 172),\n+                insert: \"foo\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn only_missing_fields_are_completed_in_destruct_pats() {\n+            let completions = complete(\n+                r\"\n+            struct S {\n+                foo1: u32,\n+                foo2: u32,\n+                bar: u32,\n+                baz: u32,\n+            }\n+\n+            fn main() {\n+                let s = S {\n+                    foo1: 1,\n+                    foo2: 2,\n+                    bar: 3,\n+                    baz: 4,\n+                };\n+                if let S { foo1, foo2: a, <|> } = s {}\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"bar\",\n+                source_range: [372; 372),\n+                delete: [372; 372),\n+                insert: \"bar\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"baz\",\n+                source_range: [372; 372),\n+                delete: [372; 372),\n+                insert: \"baz\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+    }\n+\n+    mod record_pat_tests {\n+        use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n+        use insta::assert_debug_snapshot;\n+\n+        fn complete(code: &str) -> Vec<CompletionItem> {\n+            do_completion(code, CompletionKind::Reference)\n+        }\n+\n+        #[test]\n+        fn test_record_literal_deprecated_field() {\n+            let completions = complete(\n+                r\"\n+            struct A {\n+                #[deprecated]\n+                the_field: u32,\n+            }\n+            fn foo() {\n+               A { the<|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [142; 145),\n+                delete: [142; 145),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                deprecated: true,\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_field() {\n+            let completions = complete(\n+                r\"\n+            struct A { the_field: u32 }\n+            fn foo() {\n+               A { the<|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [83; 86),\n+                delete: [83; 86),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_enum_variant() {\n+            let completions = complete(\n+                r\"\n+            enum E {\n+                A { a: u32 }\n+            }\n+            fn foo() {\n+                let _ = E::A { <|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"a\",\n+                source_range: [119; 119),\n+                delete: [119; 119),\n+                insert: \"a\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_two_structs() {\n+            let completions = complete(\n+                r\"\n+            struct A { a: u32 }\n+            struct B { b: u32 }\n+\n+            fn foo() {\n+               let _: A = B { <|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"b\",\n+                source_range: [119; 119),\n+                delete: [119; 119),\n+                insert: \"b\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_generic_struct() {\n+            let completions = complete(\n+                r\"\n+            struct A<T> { a: T }\n+\n+            fn foo() {\n+               let _: A<u32> = A { <|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"a\",\n+                source_range: [93; 93),\n+                delete: [93; 93),\n+                insert: \"a\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_field_in_simple_macro() {\n+            let completions = complete(\n+                r\"\n+            macro_rules! m { ($e:expr) => { $e } }\n+            struct A { the_field: u32 }\n+            fn foo() {\n+               m!(A { the<|> })\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [137; 140),\n+                delete: [137; 140),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn only_missing_fields_are_completed() {\n+            let completions = complete(\n+                r\"\n+            struct S {\n+                foo1: u32,\n+                foo2: u32,\n+                bar: u32,\n+                baz: u32,\n+            }\n+\n+            fn main() {\n+                let foo1 = 1;\n+                let s = S {\n+                    foo1,\n+                    foo2: 5,\n+                    <|>\n+                }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"bar\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"bar\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"baz\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"baz\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+    }\n+}"}, {"sha": "8b67d3ba2ab203d6c25b957675d4bde0989faed3", "filename": "crates/ra_ide/src/completion/complete_record_literal.rs", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/d35b94352090c201f7e0cceae43035ee0e72df98/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35b94352090c201f7e0cceae43035ee0e72df98/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs?ref=d35b94352090c201f7e0cceae43035ee0e72df98", "patch": "@@ -1,224 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use super::get_missing_fields;\n-use crate::completion::{CompletionContext, Completions};\n-use either::Either;\n-\n-/// Complete fields in fields literals.\n-pub(super) fn complete_record_literal(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-) -> Option<()> {\n-    let record_lit = ctx.record_lit_syntax.as_ref()?;\n-    for (field, field_ty) in get_missing_fields(ctx, Either::Left(record_lit))? {\n-        acc.add_field(ctx, field, &field_ty);\n-    }\n-    Some(())\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n-    use insta::assert_debug_snapshot;\n-\n-    fn complete(code: &str) -> Vec<CompletionItem> {\n-        do_completion(code, CompletionKind::Reference)\n-    }\n-\n-    #[test]\n-    fn test_record_literal_deprecated_field() {\n-        let completions = complete(\n-            r\"\n-            struct A {\n-                #[deprecated]\n-                the_field: u32,\n-            }\n-            fn foo() {\n-               A { the<|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [142; 145),\n-                delete: [142; 145),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                deprecated: true,\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field() {\n-        let completions = complete(\n-            r\"\n-            struct A { the_field: u32 }\n-            fn foo() {\n-               A { the<|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [83; 86),\n-                delete: [83; 86),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_enum_variant() {\n-        let completions = complete(\n-            r\"\n-            enum E {\n-                A { a: u32 }\n-            }\n-            fn foo() {\n-                let _ = E::A { <|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"a\",\n-                source_range: [119; 119),\n-                delete: [119; 119),\n-                insert: \"a\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_two_structs() {\n-        let completions = complete(\n-            r\"\n-            struct A { a: u32 }\n-            struct B { b: u32 }\n-\n-            fn foo() {\n-               let _: A = B { <|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"b\",\n-                source_range: [119; 119),\n-                delete: [119; 119),\n-                insert: \"b\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_generic_struct() {\n-        let completions = complete(\n-            r\"\n-            struct A<T> { a: T }\n-\n-            fn foo() {\n-               let _: A<u32> = A { <|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"a\",\n-                source_range: [93; 93),\n-                delete: [93; 93),\n-                insert: \"a\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_in_simple_macro() {\n-        let completions = complete(\n-            r\"\n-            macro_rules! m { ($e:expr) => { $e } }\n-            struct A { the_field: u32 }\n-            fn foo() {\n-               m!(A { the<|> })\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [137; 140),\n-                delete: [137; 140),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn only_missing_fields_are_completed() {\n-        let completions = complete(\n-            r\"\n-            struct S {\n-                foo1: u32,\n-                foo2: u32,\n-                bar: u32,\n-                baz: u32,\n-            }\n-\n-            fn main() {\n-                let foo1 = 1;\n-                let s = S {\n-                    foo1,\n-                    foo2: 5,\n-                    <|>\n-                }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"bar\",\n-                source_range: [302; 302),\n-                delete: [302; 302),\n-                insert: \"bar\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"baz\",\n-                source_range: [302; 302),\n-                delete: [302; 302),\n-                insert: \"baz\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-}"}, {"sha": "f94dced045abc4e8ca67363909cedfceb04bf51b", "filename": "crates/ra_ide/src/completion/complete_record_pattern.rs", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d35b94352090c201f7e0cceae43035ee0e72df98/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35b94352090c201f7e0cceae43035ee0e72df98/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs?ref=d35b94352090c201f7e0cceae43035ee0e72df98", "patch": "@@ -1,162 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use super::get_missing_fields;\n-use crate::completion::{CompletionContext, Completions};\n-use either::Either;\n-\n-pub(super) fn complete_record_pattern(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-) -> Option<()> {\n-    let record_pat = ctx.record_lit_pat.as_ref()?;\n-    for (field, field_ty) in get_missing_fields(ctx, Either::Right(record_pat))? {\n-        acc.add_field(ctx, field, &field_ty);\n-    }\n-    Some(())\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n-    use insta::assert_debug_snapshot;\n-\n-    fn complete(code: &str) -> Vec<CompletionItem> {\n-        do_completion(code, CompletionKind::Reference)\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_field() {\n-        let completions = complete(\n-            r\"\n-            struct S { foo: u32 }\n-\n-            fn process(f: S) {\n-                match f {\n-                    S { f<|>: 92 } => (),\n-                }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo\",\n-                source_range: [117; 118),\n-                delete: [117; 118),\n-                insert: \"foo\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_enum_variant() {\n-        let completions = complete(\n-            r\"\n-            enum E {\n-                S { foo: u32, bar: () }\n-            }\n-\n-            fn process(e: E) {\n-                match e {\n-                    E::S { <|> } => (),\n-                }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"bar\",\n-                source_range: [161; 161),\n-                delete: [161; 161),\n-                insert: \"bar\",\n-                kind: Field,\n-                detail: \"()\",\n-            },\n-            CompletionItem {\n-                label: \"foo\",\n-                source_range: [161; 161),\n-                delete: [161; 161),\n-                insert: \"foo\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_field_in_simple_macro() {\n-        let completions = complete(\n-            r\"\n-            macro_rules! m { ($e:expr) => { $e } }\n-            struct S { foo: u32 }\n-\n-            fn process(f: S) {\n-                m!(match f {\n-                    S { f<|>: 92 } => (),\n-                })\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo\",\n-                source_range: [171; 172),\n-                delete: [171; 172),\n-                insert: \"foo\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn only_missing_fields_are_completed_in_destruct_pats() {\n-        let completions = complete(\n-            r\"\n-            struct S {\n-                foo1: u32,\n-                foo2: u32,\n-                bar: u32,\n-                baz: u32,\n-            }\n-\n-            fn main() {\n-                let s = S {\n-                    foo1: 1,\n-                    foo2: 2,\n-                    bar: 3,\n-                    baz: 4,\n-                };\n-                if let S { foo1, foo2: a, <|> } = s {}\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"bar\",\n-                source_range: [372; 372),\n-                delete: [372; 372),\n-                insert: \"bar\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"baz\",\n-                source_range: [372; 372),\n-                delete: [372; 372),\n-                insert: \"baz\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-}"}]}