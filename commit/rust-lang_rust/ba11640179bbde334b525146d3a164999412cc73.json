{"sha": "ba11640179bbde334b525146d3a164999412cc73", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMTE2NDAxNzliYmRlMzM0YjUyNTE0NmQzYTE2NDk5OTQxMmNjNzM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-14T09:32:00Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T16:35:25Z"}, "message": "rustc_typeck: hook up collect and item/body check to on-demand.", "tree": {"sha": "7335fd5d4cccc29807bc5dcbf780647d1f92ebbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7335fd5d4cccc29807bc5dcbf780647d1f92ebbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba11640179bbde334b525146d3a164999412cc73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba11640179bbde334b525146d3a164999412cc73", "html_url": "https://github.com/rust-lang/rust/commit/ba11640179bbde334b525146d3a164999412cc73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba11640179bbde334b525146d3a164999412cc73/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c3c306800313a119d236e607209e831187e7501", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3c306800313a119d236e607209e831187e7501", "html_url": "https://github.com/rust-lang/rust/commit/9c3c306800313a119d236e607209e831187e7501"}], "stats": {"total": 1861, "additions": 773, "deletions": 1088}, "files": [{"sha": "cc6d6e88dee4ee068424be59d0d10ee853903fe1", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -159,10 +159,9 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemStruct(..) | hir::ItemUnion(..) => {\n-                        self.struct_has_extern_repr = item.attrs.iter().any(|attr| {\n-                            attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n-                                .contains(&attr::ReprExtern)\n-                        });\n+                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        let def = self.tcx.lookup_adt_def(def_id);\n+                        self.struct_has_extern_repr = def.repr.c;\n \n                         intravisit::walk_item(self, &item);\n                     }"}, {"sha": "50a80305bee273e4163e67059bf2955b5ae21370", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -173,9 +173,7 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Discriminant(ref lval) => {\n                 let ty = lval.ty(mir, tcx).to_ty(tcx);\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    let repr_hints = tcx.lookup_repr_hints(adt_def.did);\n-                    let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n-                    Some(repr_type.to_ty(tcx))\n+                    Some(adt_def.repr.discr_type().to_ty(tcx))\n                 } else {\n                     // Undefined behaviour, bug for now; may want to return something for\n                     // the `discriminant` intrinsic later."}, {"sha": "b87d18464377f6b3f4481210de7eb09651fff63b", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 134, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -11,21 +11,18 @@\n use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt, ToPredicate};\n-use ty::subst::Subst;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n-use std::mem;\n use syntax::ast;\n use util::nodemap::{FxHashSet, NodeMap};\n use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n-use super::{FulfillmentError, FulfillmentErrorCode, SelectionError};\n-use super::{ObligationCause, BuiltinDerivedObligation};\n-use super::{PredicateObligation, TraitObligation, Obligation};\n+use super::{FulfillmentError, FulfillmentErrorCode};\n+use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n use super::select::SelectionContext;\n use super::Unimplemented;\n@@ -82,10 +79,6 @@ pub struct FulfillmentContext<'tcx> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n-\n-    // A list of obligations that need to be deferred to\n-    // a later time for them to be properly fulfilled.\n-    deferred_obligations: Vec<DeferredObligation<'tcx>>,\n }\n \n #[derive(Clone)]\n@@ -101,100 +94,12 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n-/// An obligation which cannot be fulfilled in the context\n-/// it was registered in, such as auto trait obligations on\n-/// `impl Trait`, which require the concrete type to be\n-/// available, only guaranteed after finishing type-checking.\n-#[derive(Clone, Debug)]\n-pub struct DeferredObligation<'tcx> {\n-    pub predicate: ty::PolyTraitPredicate<'tcx>,\n-    pub cause: ObligationCause<'tcx>\n-}\n-\n-impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n-    /// If possible, create a `DeferredObligation` from\n-    /// a trait predicate which had failed selection,\n-    /// but could succeed later.\n-    pub fn from_select_error(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             obligation: &TraitObligation<'tcx>,\n-                             selection_err: &SelectionError<'tcx>)\n-                             -> Option<DeferredObligation<'tcx>> {\n-        if let Unimplemented = *selection_err {\n-            if DeferredObligation::must_defer(tcx, &obligation.predicate) {\n-                return Some(DeferredObligation {\n-                    predicate: obligation.predicate.clone(),\n-                    cause: obligation.cause.clone()\n-                });\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Returns true if the given trait predicate can be\n-    /// fulfilled at a later time.\n-    pub fn must_defer(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      predicate: &ty::PolyTraitPredicate<'tcx>)\n-                      -> bool {\n-        // Auto trait obligations on `impl Trait`.\n-        if tcx.trait_has_default_impl(predicate.def_id()) {\n-            let substs = predicate.skip_binder().trait_ref.substs;\n-            if substs.types().count() == 1 && substs.regions().next().is_none() {\n-                if let ty::TyAnon(..) = predicate.skip_binder().self_ty().sty {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    /// If possible, return the nested obligations required\n-    /// to fulfill this obligation.\n-    pub fn try_select(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                      -> Option<Vec<PredicateObligation<'tcx>>> {\n-        if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n-            let ty = if def_id.is_local() {\n-                tcx.maps.ty.borrow().get(&def_id).cloned()\n-            } else {\n-                Some(tcx.item_type(def_id))\n-            };\n-            // We can resolve the `impl Trait` to its concrete type.\n-            if let Some(concrete_ty) = ty.subst(tcx, substs) {\n-                let predicate = ty::TraitRef {\n-                    def_id: self.predicate.def_id(),\n-                    substs: tcx.mk_substs_trait(concrete_ty, &[])\n-                }.to_predicate();\n-\n-                let original_obligation = Obligation::new(self.cause.clone(),\n-                                                          self.predicate.clone());\n-                let cause = original_obligation.derived_cause(BuiltinDerivedObligation);\n-                return Some(vec![Obligation::new(cause, predicate)]);\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Return the `PredicateObligation` this was created from.\n-    pub fn to_obligation(&self) -> PredicateObligation<'tcx> {\n-        let predicate = ty::Predicate::Trait(self.predicate.clone());\n-        Obligation::new(self.cause.clone(), predicate)\n-    }\n-\n-    /// Return an error as if this obligation had failed.\n-    pub fn to_error(&self) -> FulfillmentError<'tcx> {\n-        FulfillmentError::new(self.to_obligation(), CodeSelectionError(Unimplemented))\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             region_obligations: NodeMap(),\n-            deferred_obligations: vec![],\n         }\n     }\n \n@@ -294,16 +199,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     {\n         self.select_where_possible(infcx)?;\n \n-        // Fail all of the deferred obligations that haven't\n-        // been otherwise removed from the context.\n-        let deferred_errors = self.deferred_obligations.iter()\n-                                  .map(|d| d.to_error());\n-\n         let errors: Vec<_> =\n             self.predicates.to_errors(CodeAmbiguity)\n                            .into_iter()\n                            .map(|e| to_fulfillment_error(e))\n-                           .chain(deferred_errors)\n                            .collect();\n         if errors.is_empty() {\n             Ok(())\n@@ -324,10 +223,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n-    pub fn take_deferred_obligations(&mut self) -> Vec<DeferredObligation<'tcx>> {\n-        mem::replace(&mut self.deferred_obligations, vec![])\n-    }\n-\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n@@ -343,7 +238,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n                 selcx: selcx,\n                 region_obligations: &mut self.region_obligations,\n-                deferred_obligations: &mut self.deferred_obligations\n             });\n             debug!(\"select: outcome={:?}\", outcome);\n \n@@ -378,7 +272,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    deferred_obligations: &'a mut Vec<DeferredObligation<'tcx>>\n }\n \n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n@@ -391,8 +284,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n     {\n         process_predicate(self.selcx,\n                           obligation,\n-                          self.region_obligations,\n-                          self.deferred_obligations)\n+                          self.region_obligations)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n                 stalled_on: vec![]\n@@ -432,8 +324,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    deferred_obligations: &mut Vec<DeferredObligation<'tcx>>)\n+    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n {\n@@ -502,21 +393,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                     info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n                           data, obligation.recursion_depth);\n \n-                    let defer = DeferredObligation::from_select_error(selcx.tcx(),\n-                                                                      &trait_obligation,\n-                                                                      &selection_err);\n-                    if let Some(deferred_obligation) = defer {\n-                        if let Some(nested) = deferred_obligation.try_select(selcx.tcx()) {\n-                            Ok(Some(nested))\n-                        } else {\n-                            // Pretend that the obligation succeeded,\n-                            // but record it for later.\n-                            deferred_obligations.push(deferred_obligation);\n-                            Ok(Some(vec![]))\n-                        }\n-                    } else {\n-                        Err(CodeSelectionError(selection_err))\n-                    }\n+                    Err(CodeSelectionError(selection_err))\n                 }\n             }\n         }\n@@ -714,12 +591,6 @@ impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n             // already has the required read edges, so we don't need\n             // to add any more edges here.\n             if data.is_global() {\n-                // Don't cache predicates which were fulfilled\n-                // by deferring them for later fulfillment.\n-                if DeferredObligation::must_defer(tcx, data) {\n-                    return;\n-                }\n-\n                 if let Some(data) = tcx.lift_to_global(data) {\n                     if self.set.insert(data.clone()) {\n                         debug!(\"add_if_global: global predicate `{:?}` added\", data);"}, {"sha": "117e16da26c3f3371c040a3b1819379dc3fdd96d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -31,7 +31,6 @@ pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n-pub use self::fulfill::DeferredObligation;\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};"}, {"sha": "4c4ace0d8baf9629d64a1cb7a0c805405e27d731", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -1478,8 +1478,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     // `assemble_candidates_from_object_ty`.\n                 }\n                 ty::TyParam(..) |\n-                ty::TyProjection(..) |\n-                ty::TyAnon(..) => {\n+                ty::TyProjection(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -1902,7 +1901,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyDynamic(..) |\n             ty::TyParam(..) |\n             ty::TyProjection(..) |\n-            ty::TyAnon(..) |\n             ty::TyInfer(ty::TyVar(_)) |\n             ty::TyInfer(ty::FreshTy(_)) |\n             ty::TyInfer(ty::FreshIntTy(_)) |\n@@ -1947,6 +1945,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     .map(|f| f.ty(self.tcx(), substs))\n                     .collect()\n             }\n+\n+            ty::TyAnon(def_id, substs) => {\n+                // We can resolve the `impl Trait` to its concrete type,\n+                // which enforces a DAG between the functions requiring\n+                // the auto trait bounds in question.\n+                vec![self.tcx().item_type(def_id).subst(self.tcx(), substs)]\n+            }\n         }\n     }\n "}, {"sha": "717c171db2ac7106a78ac11ff92dab42fbea2df1", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -269,20 +269,6 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::DeferredObligation<'a> {\n-    type Lifted = traits::DeferredObligation<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.predicate).and_then(|predicate| {\n-            tcx.lift(&self.cause).map(|cause| {\n-                traits::DeferredObligation {\n-                    predicate: predicate,\n-                    cause: cause\n-                }\n-            })\n-        })\n-    }\n-}\n-\n // For trans only.\n impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     type Lifted = traits::Vtable<'tcx, ()>;\n@@ -589,16 +575,3 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCause<'tcx> {\n         self.code.visit_with(visitor)\n     }\n }\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::DeferredObligation<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::DeferredObligation {\n-            predicate: self.predicate.fold_with(folder),\n-            cause: self.cause.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicate.visit_with(visitor) || self.cause.visit_with(visitor)\n-    }\n-}"}, {"sha": "318c866a59fbefb97c582e4ac37fd7e683452b1f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -38,7 +38,6 @@ use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n-use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -50,7 +49,6 @@ use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n-use std::rc::Rc;\n use std::iter;\n use std::cmp::Ordering;\n use syntax::abi;\n@@ -242,6 +240,10 @@ pub struct TypeckTables<'tcx> {\n \n     /// Lints for the body of this fn generated by typeck.\n     pub lints: lint::LintTable,\n+\n+    /// Set of trait imports actually used in the method resolution.\n+    /// This is used for warning unused imports.\n+    pub used_trait_imports: DefIdSet,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -259,6 +261,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             fru_field_types: NodeMap(),\n             cast_kinds: NodeMap(),\n             lints: lint::LintTable::new(),\n+            used_trait_imports: DefIdSet(),\n         }\n     }\n \n@@ -531,11 +534,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// shouldn't taint the common path (hence the RefCell).\n     pub all_traits: RefCell<Option<Vec<DefId>>>,\n \n-    /// Obligations which will have to be checked at the end of\n-    /// type-checking, after all functions have been inferred.\n-    /// The key is the NodeId of the item the obligations were from.\n-    pub deferred_obligations: RefCell<NodeMap<Vec<traits::DeferredObligation<'tcx>>>>,\n-\n     /// HIR Ty -> Ty lowering cache.\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n }\n@@ -734,7 +732,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n             all_traits: RefCell::new(None),\n-            deferred_obligations: RefCell::new(NodeMap()),\n             ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n        }, f)\n     }\n@@ -1449,15 +1446,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.mk_substs(iter::once(s).chain(t.into_iter().cloned()).map(Kind::from))\n     }\n-\n-    /// Obtain the representation annotation for a struct definition.\n-    pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-        self.maps.repr_hints.memoize(did, || {\n-            Rc::new(self.get_attrs(did).iter().flat_map(|meta| {\n-                attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n-            }).collect())\n-        })\n-    }\n }\n \n pub trait InternAs<T: ?Sized, R> {"}, {"sha": "3773796e47d47f2b40f72f6ac4f0f1f7ac1450da", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -1147,7 +1147,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.is_simd() => {\n+            ty::TyAdt(def, ..) if def.repr.simd => {\n                 let element = ty.simd_type(tcx);\n                 match *element.layout(infcx)? {\n                     Scalar { value, .. } => {\n@@ -1227,9 +1227,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let fields = def.variants[0].fields.iter().map(|field| {\n                         field.ty(tcx, substs).layout(infcx)\n                     }).collect::<Result<Vec<_>, _>>()?;\n-                    let packed = tcx.lookup_packed(def.did);\n                     let layout = if def.is_union() {\n-                        let mut un = Union::new(dl, packed);\n+                        let mut un = Union::new(dl, def.repr.packed);\n                         un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n@@ -1353,9 +1352,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }\n \n-                let repr_hints = tcx.lookup_repr_hints(def.did);\n-                let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n-                let typeck_ity = Integer::from_attr(dl, repr_type);\n+                let typeck_ity = Integer::from_attr(dl, def.repr.discr_type());\n                 if typeck_ity < min_ity {\n                     // It is a bug if Layout decided on a greater discriminant size than typeck for\n                     // some reason at this point (based on values discriminant can take on). Mostly"}, {"sha": "ce4d1f5ec974c3541f8162f5d145048ba045a9a6", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 53, "deletions": 31, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -14,28 +14,33 @@ use middle::const_val::ConstVal;\n use mir;\n use ty::{self, Ty, TyCtxt};\n use util::common::MemoizationMap;\n-use util::nodemap::DefIdSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::RefCell;\n use std::rc::Rc;\n-use syntax::attr;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n trait Key {\n     fn map_crate(&self) -> CrateNum;\n+    fn default_span(&self, tcx: TyCtxt) -> Span;\n }\n \n impl Key for DefId {\n     fn map_crate(&self) -> CrateNum {\n         self.krate\n     }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(*self)\n+    }\n }\n \n impl Key for (DefId, DefId) {\n     fn map_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n }\n \n trait Value<'tcx>: Sized {\n@@ -83,7 +88,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    pub fn cycle_check<F, R>(self, span: Span, query: Query, compute: F) -> R\n+    fn cycle_check<F, R>(self, span: Span, query: Query, compute: F) -> R\n         where F: FnOnce() -> R\n     {\n         {\n@@ -104,23 +109,28 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl Query {\n-    fn describe(&self, tcx: TyCtxt) -> String {\n-        match *self {\n-            Query::ty(def_id) => {\n-                format!(\"processing `{}`\", tcx.item_path_str(def_id))\n-            }\n-            Query::super_predicates(def_id) => {\n-                format!(\"computing the supertraits of `{}`\",\n-                        tcx.item_path_str(def_id))\n-            }\n-            Query::type_param_predicates((_, def_id)) => {\n-                let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                format!(\"computing the bounds for type parameter `{}`\",\n-                        tcx.hir.ty_param_name(id))\n-            }\n-            _ => bug!(\"unexpected `{:?}`\", self)\n-        }\n+trait QueryDescription: DepTrackingMapConfig {\n+    fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n+}\n+\n+impl<M: DepTrackingMapConfig<Key=DefId>> QueryDescription for M {\n+    default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::super_predicates<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"computing the supertraits of `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n+    fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        format!(\"computing the bounds for type parameter `{}`\",\n+                tcx.hir.ty_param_name(id))\n     }\n }\n \n@@ -152,6 +162,14 @@ macro_rules! define_maps {\n             $($(#[$attr])* $name($K)),*\n         }\n \n+        impl Query {\n+            pub fn describe(&self, tcx: TyCtxt) -> String {\n+                match *self {\n+                    $(Query::$name(key) => queries::$name::describe(tcx, key)),*\n+                }\n+            }\n+        }\n+\n         pub mod queries {\n             use std::marker::PhantomData;\n \n@@ -186,11 +204,22 @@ macro_rules! define_maps {\n             }\n         }\n \n-        impl<$tcx> Maps<$tcx> {\n+        impl<'a, $tcx, 'lcx> Maps<$tcx> {\n             $($(#[$attr])*\n-              pub fn $name<'a, 'lcx>(&self, tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n+              pub fn $name(&self,\n+                           tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                           mut span: Span,\n+                           key: $K) -> $V {\n                 self.$name.memoize(key, || {\n-                    (self.providers[key.map_crate()].$name)(tcx.global_tcx(), key)\n+                    // FIXME(eddyb) Get more valid Span's on queries.\n+                    if span == DUMMY_SP {\n+                        span = key.default_span(tcx);\n+                    }\n+\n+                    tcx.cycle_check(span, Query::$name(key), || {\n+                        let provider = self.providers[key.map_crate()].$name;\n+                        provider(tcx.global_tcx(), key)\n+                    })\n                 })\n             })*\n         }\n@@ -246,9 +275,6 @@ define_maps! { <'tcx>\n     /// Methods in these implementations don't need to be exported.\n     pub inherent_impls: InherentImpls(DefId) -> Vec<DefId>,\n \n-    /// Caches the representation hints for struct definitions.\n-    pub repr_hints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>>,\n-\n     /// Maps from the def-id of a function/method or const/static\n     /// to its MIR. Mutation is done at an item granularity to\n     /// allow MIR optimization passes to function and still\n@@ -272,10 +298,6 @@ define_maps! { <'tcx>\n \n     pub typeck_tables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n-    /// Set of trait imports actually used in the method resolution.\n-    /// This is used for warning unused imports.\n-    pub used_trait_imports: UsedTraitImports(DefId) -> DefIdSet,\n-\n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n     pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal, ()>"}, {"sha": "357d12bc4dd6c64c4e838b8bc5d89215e7e832ee", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 38, "deletions": 66, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -1296,10 +1296,9 @@ bitflags! {\n         const IS_DTORCK           = 1 << 1, // is this a dtorck type?\n         const IS_DTORCK_VALID     = 1 << 2,\n         const IS_PHANTOM_DATA     = 1 << 3,\n-        const IS_SIMD             = 1 << 4,\n-        const IS_FUNDAMENTAL      = 1 << 5,\n-        const IS_UNION            = 1 << 6,\n-        const IS_BOX              = 1 << 7,\n+        const IS_FUNDAMENTAL      = 1 << 4,\n+        const IS_UNION            = 1 << 5,\n+        const IS_BOX              = 1 << 6,\n     }\n }\n \n@@ -1384,18 +1383,29 @@ pub struct ReprOptions {\n impl ReprOptions {\n     pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut ret = ReprOptions::default();\n-        let attrs = tcx.lookup_repr_hints(did);\n-        for r in attrs.iter() {\n-            match *r {\n-                attr::ReprExtern => ret.c = true,\n-                attr::ReprPacked => ret.packed = true,\n-                attr::ReprSimd => ret.simd = true,\n-                attr::ReprInt(i) => ret.int = Some(i),\n-                attr::ReprAny => (),\n+\n+        for attr in tcx.get_attrs(did).iter() {\n+            for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n+                match r {\n+                    attr::ReprExtern => ret.c = true,\n+                    attr::ReprPacked => ret.packed = true,\n+                    attr::ReprSimd => ret.simd = true,\n+                    attr::ReprInt(i) => ret.int = Some(i),\n+                }\n             }\n         }\n+\n+        // FIXME(eddyb) This is deprecated and should be removed.\n+        if tcx.has_attr(did, \"simd\") {\n+            ret.simd = true;\n+        }\n+\n         ret\n     }\n+\n+    pub fn discr_type(&self) -> attr::IntType {\n+        self.int.unwrap_or(attr::SignedInt(ast::IntTy::Is))\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n@@ -1409,9 +1419,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         if attr::contains_name(&attrs, \"fundamental\") {\n             flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n-        if tcx.lookup_simd(did) {\n-            flags = flags | AdtFlags::IS_SIMD;\n-        }\n         if Some(did) == tcx.lang_items.phantom_data() {\n             flags = flags | AdtFlags::IS_PHANTOM_DATA;\n         }\n@@ -1500,11 +1507,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.get().intersects(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n-    #[inline]\n-    pub fn is_simd(&self) -> bool {\n-        self.flags.get().intersects(AdtFlags::IS_SIMD)\n-    }\n-\n     /// Returns true if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n@@ -1584,8 +1586,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                          -> impl Iterator<Item=ConstInt> + 'a {\n-        let repr_hints = tcx.lookup_repr_hints(self.did);\n-        let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n+        let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<ConstInt>;\n         self.variants.iter().map(move |v| {\n@@ -1946,25 +1947,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn item_tables(self, def_id: DefId) -> &'gcx TypeckTables<'gcx> {\n-        self.maps.typeck_tables.memoize(def_id, || {\n-            if def_id.is_local() {\n-                // Closures' tables come from their outermost function,\n-                // as they are part of the same \"inference environment\".\n-                let outer_def_id = self.closure_base_def_id(def_id);\n-                if outer_def_id != def_id {\n-                    return self.item_tables(outer_def_id);\n-                }\n-\n-                bug!(\"No def'n found for {:?} in tcx.tables\", def_id);\n-            }\n-\n-            // Cross-crate side-tables only exist alongside serialized HIR.\n-            self.sess.cstore.maybe_get_item_body(self.global_tcx(), def_id).map(|_| {\n-                self.maps.typeck_tables.borrow()[&def_id]\n-            }).unwrap_or_else(|| {\n-                bug!(\"tcx.item_tables({:?}): missing from metadata\", def_id)\n-            })\n-        })\n+        self.maps.typeck_tables(self, DUMMY_SP, def_id)\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2072,12 +2055,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        self.maps.custom_coerce_unsized_kind(self, did)\n+        self.maps.custom_coerce_unsized_kind(self, DUMMY_SP, did)\n     }\n \n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n         if !def_id.is_local() {\n-            return self.maps.associated_item(self, def_id);\n+            return self.maps.associated_item(self, DUMMY_SP, def_id);\n         }\n \n         self.maps.associated_item.memoize(def_id, || {\n@@ -2182,7 +2165,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n         if !def_id.is_local() {\n-            return self.maps.associated_item_def_ids(self, def_id);\n+            return self.maps.associated_item_def_ids(self, DUMMY_SP, def_id);\n         }\n \n         self.maps.associated_item_def_ids.memoize(def_id, || {\n@@ -2217,7 +2200,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n     pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'gcx>> {\n-        self.maps.impl_trait_ref(self, id)\n+        self.maps.impl_trait_ref(self, DUMMY_SP, id)\n     }\n \n     // Returns `ty::VariantDef` if `def` refers to a struct,\n@@ -2296,37 +2279,37 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n     pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n-        self.maps.ty(self, did)\n+        self.maps.ty(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n     pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n-        self.maps.trait_def(self, did)\n+        self.maps.trait_def(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n     pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n-        self.maps.adt_def(self, did)\n+        self.maps.adt_def(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its generics.\n     pub fn item_generics(self, did: DefId) -> &'gcx Generics {\n-        self.maps.generics(self, did)\n+        self.maps.generics(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n     pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        self.maps.predicates(self, did)\n+        self.maps.predicates(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n     pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        self.maps.super_predicates(self, did)\n+        self.maps.super_predicates(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its MIR, borrowed immutably.\n     pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        self.maps.mir(self, did).borrow()\n+        self.maps.mir(self, DUMMY_SP, did).borrow()\n     }\n \n     /// If `type_needs_drop` returns true, then `ty` is definitely\n@@ -2377,19 +2360,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.get_attrs(did).iter().any(|item| item.check_name(attr))\n     }\n \n-    /// Determine whether an item is annotated with `#[repr(packed)]`\n-    pub fn lookup_packed(self, did: DefId) -> bool {\n-        self.lookup_repr_hints(did).contains(&attr::ReprPacked)\n-    }\n-\n-    /// Determine whether an item is annotated with `#[simd]`\n-    pub fn lookup_simd(self, did: DefId) -> bool {\n-        self.has_attr(did, \"simd\")\n-            || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n-    }\n-\n     pub fn item_variances(self, item_id: DefId) -> Rc<Vec<ty::Variance>> {\n-        self.maps.variances(self, item_id)\n+        self.maps.variances(self, DUMMY_SP, item_id)\n     }\n \n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n@@ -2464,11 +2436,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n-        self.maps.closure_kind(self, def_id)\n+        self.maps.closure_kind(self, DUMMY_SP, def_id)\n     }\n \n     pub fn closure_type(self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-        self.maps.closure_type(self, def_id)\n+        self.maps.closure_type(self, DUMMY_SP, def_id)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements."}, {"sha": "aa2990679b6acc27efbdae1f2a3718f8994cb7ed", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -1077,7 +1077,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyAdt(def, _) => def.is_simd(),\n+            TyAdt(def, _) => def.repr.simd,\n             _ => false\n         }\n     }"}, {"sha": "d1c22651a9e008d791dcc02bb65f223c07166209", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -232,21 +232,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns the IntType representation.\n-    /// This used to ensure `int_ty` doesn't contain `usize` and `isize`\n-    /// by converting them to their actual types. That doesn't happen anymore.\n-    pub fn enum_repr_type(self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n-        match opt_hint {\n-            // Feed in the given type\n-            Some(&attr::ReprInt(int_t)) => int_t,\n-            // ... but provide sensible default if none provided\n-            //\n-            // NB. Historically `fn enum_variants` generate i64 here, while\n-            // rustc_typeck::check would generate isize.\n-            _ => SignedInt(ast::IntTy::Is),\n-        }\n-    }\n-\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy."}, {"sha": "f8c0044774a010eb2cadd0e604802105b12fd64f", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -677,9 +677,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 // Additionally, we do not want to switch on the\n                 // discriminant after it is free-ed, because that\n                 // way lies only trouble.\n-                let repr_hints = self.tcx.lookup_repr_hints(adt.did);\n-                let repr_type = self.tcx.enum_repr_type(repr_hints.get(0));\n-                let discr_ty = repr_type.to_ty(self.tcx);\n+                let discr_ty = adt.repr.discr_type().to_ty(self.tcx);\n                 let discr = Lvalue::Local(self.patch.new_temp(discr_ty));\n                 let switch_block = self.patch.new_block(BasicBlockData {\n                     statements: vec!["}, {"sha": "eadb49a0731a4832ffbd7b87978425c067ab8f58", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -902,8 +902,7 @@ fn infer<'a, 'tcx>(i: ConstInt,\n         (&ty::TyUint(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n \n         (&ty::TyAdt(adt, _), i) if adt.is_enum() => {\n-            let hints = tcx.lookup_repr_hints(adt.did);\n-            let int_ty = tcx.enum_repr_type(hints.iter().next());\n+            let int_ty = adt.repr.discr_type();\n             infer(i, tcx, &int_ty.to_ty(tcx).sty)\n         },\n         (_, i) => Err(BadType(ConstVal::Integral(i))),\n@@ -1093,8 +1092,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n                 },\n                 None => Ok(Integral(Infer(n as u128))),\n                 Some(&ty::TyAdt(adt, _)) => {\n-                    let hints = tcx.lookup_repr_hints(adt.did);\n-                    let int_ty = tcx.enum_repr_type(hints.iter().next());\n+                    let int_ty = adt.repr.discr_type();\n                     infer(Infer(n as u128), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n                 },\n                 Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),"}, {"sha": "156f8b9e7c489a27750f346b7266b86898bc31e4", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -257,6 +257,12 @@ pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.check_item(item.id, item.span);\n+\n+        if let hir::ItemEnum(ref def, _) = item.node {\n+            for v in &def.variants {\n+                self.check_item(v.node.data.id(), v.span);\n+            }\n+        }\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem) {"}, {"sha": "3301a98968ee8c943357a153e03c2e7906d80e6e", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -381,6 +381,17 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     false\n }\n \n+fn is_ffi_safe(ty: attr::IntType) -> bool {\n+    match ty {\n+        attr::SignedInt(ast::IntTy::I8) | attr::UnsignedInt(ast::UintTy::U8) |\n+        attr::SignedInt(ast::IntTy::I16) | attr::UnsignedInt(ast::UintTy::U16) |\n+        attr::SignedInt(ast::IntTy::I32) | attr::UnsignedInt(ast::UintTy::U32) |\n+        attr::SignedInt(ast::IntTy::I64) | attr::UnsignedInt(ast::UintTy::U64) |\n+        attr::SignedInt(ast::IntTy::I128) | attr::UnsignedInt(ast::UintTy::U128) => true,\n+        attr::SignedInt(ast::IntTy::Is) | attr::UnsignedInt(ast::UintTy::Us) => false\n+    }\n+}\n+\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n@@ -406,7 +417,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n                 match def.adt_kind() {\n                     AdtKind::Struct => {\n-                        if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                        if !def.repr.c {\n                             return FfiUnsafe(\"found struct without foreign-function-safe \\\n                                               representation annotation in foreign module, \\\n                                               consider adding a #[repr(C)] attribute to the type\");\n@@ -440,7 +451,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if all_phantom { FfiPhantom } else { FfiSafe }\n                     }\n                     AdtKind::Union => {\n-                        if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                        if !def.repr.c {\n                             return FfiUnsafe(\"found union without foreign-function-safe \\\n                                               representation annotation in foreign module, \\\n                                               consider adding a #[repr(C)] attribute to the type\");\n@@ -479,35 +490,28 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         // Check for a repr() attribute to specify the size of the\n                         // discriminant.\n-                        let repr_hints = cx.lookup_repr_hints(def.did);\n-                        match &repr_hints[..] {\n-                            &[] => {\n-                                // Special-case types like `Option<extern fn()>`.\n-                                if !is_repr_nullable_ptr(cx, def, substs) {\n-                                    return FfiUnsafe(\"found enum without foreign-function-safe \\\n-                                                      representation annotation in foreign \\\n-                                                      module, consider adding a #[repr(...)] \\\n-                                                      attribute to the type\");\n-                                }\n+                        if !def.repr.c && def.repr.int.is_none() {\n+                            // Special-case types like `Option<extern fn()>`.\n+                            if !is_repr_nullable_ptr(cx, def, substs) {\n+                                return FfiUnsafe(\"found enum without foreign-function-safe \\\n+                                                  representation annotation in foreign \\\n+                                                  module, consider adding a #[repr(...)] \\\n+                                                  attribute to the type\");\n                             }\n-                            &[ref hint] => {\n-                                if !hint.is_ffi_safe() {\n-                                    // FIXME: This shouldn't be reachable: we should check\n-                                    // this earlier.\n-                                    return FfiUnsafe(\"enum has unexpected #[repr(...)] attribute\");\n-                                }\n-\n-                                // Enum with an explicitly sized discriminant; either\n-                                // a C-style enum or a discriminated union.\n+                        }\n \n-                                // The layout of enum variants is implicitly repr(C).\n-                                // FIXME: Is that correct?\n-                            }\n-                            _ => {\n+                        if let Some(int_ty) = def.repr.int {\n+                            if !is_ffi_safe(int_ty) {\n                                 // FIXME: This shouldn't be reachable: we should check\n                                 // this earlier.\n-                                return FfiUnsafe(\"enum has too many #[repr(...)] attributes\");\n+                                return FfiUnsafe(\"enum has unexpected #[repr(...)] attribute\");\n                             }\n+\n+                            // Enum with an explicitly sized discriminant; either\n+                            // a C-style enum or a discriminated union.\n+\n+                            // The layout of enum variants is implicitly repr(C).\n+                            // FIXME: Is that correct?\n                         }\n \n                         // Check the contained variants."}, {"sha": "fc7b50f11da966908517b499b69be8cdafa26d48", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -101,6 +101,7 @@ provide! { <'tcx> tcx, def_id, cdata\n \n         mir\n     }\n+    typeck_tables => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n }"}, {"sha": "e81d752fde047a47fddf6c52a1ed6709ae625382", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -780,16 +780,19 @@ impl<'a, 'tcx> CrateMetadata {\n         if self.is_proc_macro(id) { return None; }\n         self.entry(id).ast.map(|ast| {\n             let def_id = self.local_def_id(id);\n-            let ast = ast.decode(self);\n-\n-            let tables = ast.tables.decode((self, tcx));\n-            tcx.maps.typeck_tables.borrow_mut().insert(def_id, tcx.alloc_tables(tables));\n-\n-            let body = ast.body.decode((self, tcx));\n+            let body = ast.decode(self).body.decode(self);\n             tcx.hir.intern_inlined_body(def_id, body)\n         })\n     }\n \n+    pub fn item_body_tables(&self,\n+                            id: DefIndex,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                            -> &'tcx ty::TypeckTables<'tcx> {\n+        let ast = self.entry(id).ast.unwrap().decode(self);\n+        tcx.alloc_tables(ast.tables.decode((self, tcx)))\n+    }\n+\n     pub fn item_body_nested_bodies(&self, id: DefIndex) -> BTreeMap<hir::BodyId, hir::Body> {\n         self.entry(id).ast.into_iter().flat_map(|ast| {\n             ast.decode(self).nested_bodies.decode(self).map(|body| (body.id(), body))"}, {"sha": "f5fd7a152a87ef34e8585323f43dcc827dc69638", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -36,7 +36,7 @@ use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax::attr;\n use syntax::symbol::Symbol;\n-use syntax_pos;\n+use syntax_pos::{self, DUMMY_SP};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             discr: variant.discr,\n             evaluated_discr: match variant.discr {\n                 ty::VariantDiscr::Explicit(def_id) => {\n-                    tcx.maps.monomorphic_const_eval.borrow()[&def_id].clone().ok()\n+                    tcx.maps.monomorphic_const_eval(tcx, DUMMY_SP, def_id).ok()\n                 }\n                 ty::VariantDiscr::Relative(_) => None\n             },"}, {"sha": "fa8d7ffccde40c0a831e4a257d8764c86a39677f", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -209,9 +209,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n                 debug!(\"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n                        num_enum_variants, values, variants);\n-                let repr_hints = tcx.lookup_repr_hints(adt_def.did);\n-                let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n-                let discr_ty = repr_type.to_ty(tcx);\n+                let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty);\n                 self.cfg.push_assign(block, source_info, &discr,\n                                      Rvalue::Discriminant(lvalue.clone()));"}, {"sha": "2d373ca7473e536bd2e24cf00d635c0872856915", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 73, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -11,17 +11,6 @@\n //! Conversion from AST representation of types to the ty.rs\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n //! is parameterized by an instance of `AstConv`.\n-//!\n-//! The parameterization of `ast_ty_to_ty()` is because it behaves\n-//! somewhat differently during the collect and check phases,\n-//! particularly with respect to looking up the types of top-level\n-//! items.  In the collect phase, the crate context is used as the\n-//! `AstConv` instance; in this phase, the `get_item_type()`\n-//! function triggers a recursive call to `type_of_item()`\n-//! (note that `ast_ty_to_ty()` will detect recursive types and report\n-//! an error).  In the check phase, when the FnCtxt is used as the\n-//! `AstConv`, `get_item_type()` just looks up the item type in\n-//! `tcx.types` (using `TyCtxt::item_type`).\n \n use rustc_const_eval::eval_length;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -51,18 +40,10 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// A cache used for the result of `ast_ty_to_ty_cache`\n     fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>>;\n \n-    /// Identify the type for an item, like a type alias, fn, or struct.\n-    fn get_item_type(&self, span: Span, id: DefId) -> Ty<'tcx>;\n-\n-    /// Ensure that the super-predicates for the trait with the given\n-    /// id are available and also for the transitive set of\n-    /// super-predicates.\n-    fn ensure_super_predicates(&self, span: Span, id: DefId);\n-\n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n-                                 -> Vec<ty::Predicate<'tcx>>;\n+                                 -> ty::GenericPredicates<'tcx>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n     /// are in scope into free ones. This function should only return Some\n@@ -262,7 +243,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n         let default_needs_object_self = |p: &ty::TypeParameterDef| {\n             if is_object && p.has_default {\n-                if self.get_item_type(span, p.def_id).has_self_ty() {\n+                if tcx.maps.ty(tcx, span, p.def_id).has_self_ty() {\n                     // There is no suitable inference default for a type parameter\n                     // that references self, in an object type.\n                     return true;\n@@ -329,7 +310,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     tcx.types.err\n                 } else {\n                     // This is a default type parameter.\n-                    self.get_item_type(span, def.def_id).subst_spanned(tcx, substs, Some(span))\n+                    tcx.maps.ty(tcx, span, def.def_id).subst_spanned(tcx, substs, Some(span))\n                 }\n             } else {\n                 // We've already errored above about the mismatch.\n@@ -591,8 +572,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Otherwise, we have to walk through the supertraits to find\n         // those that do.\n-        self.ensure_super_predicates(binding.span, trait_ref.def_id());\n-\n         let candidates =\n             traits::supertraits(tcx, trait_ref.clone())\n             .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name));\n@@ -620,7 +599,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> Ty<'tcx>\n     {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        self.get_item_type(span, did).subst(self.tcx(), substs)\n+        self.tcx().maps.ty(self.tcx(), span, did).subst(self.tcx(), substs)\n     }\n \n     /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n@@ -677,9 +656,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             })\n         });\n \n-        // ensure the super predicates\n-        self.ensure_super_predicates(span, principal.def_id());\n-\n         // check that there are no gross object safety violations,\n         // most importantly, that the supertraits don't contain Self,\n         // to avoid ICE-s.\n@@ -776,12 +752,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         let bounds: Vec<_> = self.get_type_parameter_bounds(span, ty_param_def_id)\n-            .into_iter().filter_map(|p| p.to_opt_poly_trait_ref()).collect();\n-\n-        // Ensure the super predicates.\n-        for b in &bounds {\n-            self.ensure_super_predicates(span, b.def_id());\n-        }\n+            .predicates.into_iter().filter_map(|p| p.to_opt_poly_trait_ref()).collect();\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n@@ -880,28 +851,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait - we have a concrete self type and a\n                 // trait reference.\n-                // FIXME: Self type is not always computed when we are here because type parameter\n-                // bounds may affect Self type and have to be converted before it.\n-                let trait_ref = if impl_def_id.is_local() {\n-                    tcx.maps.impl_trait_ref.borrow().get(&impl_def_id)\n-                       .cloned().and_then(|x| x)\n-                } else {\n-                    tcx.impl_trait_ref(impl_def_id)\n-                };\n-                let trait_ref = if let Some(trait_ref) = trait_ref {\n-                    trait_ref\n-                } else {\n-                    tcx.sess.span_err(span, \"`Self` type is used before it's determined\");\n-                    return (tcx.types.err, Def::Err);\n+                let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n+                    Some(trait_ref) => trait_ref,\n+                    None => {\n+                        // A cycle error occurred, most likely.\n+                        return (tcx.types.err, Def::Err);\n+                    }\n                 };\n+\n                 let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n                     trait_ref.subst(tcx, free_substs)\n                 } else {\n                     trait_ref\n                 };\n \n-                self.ensure_super_predicates(span, trait_ref.def_id);\n-\n                 let candidates =\n                     traits::supertraits(tcx, ty::Binder(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n@@ -1022,7 +985,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(&path.segments);\n \n-                let ty = self.get_item_type(span, def_id);\n+                let ty = tcx.maps.ty(tcx, span, def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {\n@@ -1137,9 +1100,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyImplTrait(ref bounds) => {\n-                use collect::{compute_bounds, SizedByDefault};\n-\n+            hir::TyImplTrait(_) => {\n                 // Figure out if we can allow an `impl Trait` here, by walking up\n                 // to a `fn` or inherent `impl` method, going only through `Ty`\n                 // or `TraitRef` nodes (as nothing else should be in types) and\n@@ -1179,22 +1140,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Create the anonymized type.\n                 if allow {\n                     let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                    tcx.item_generics(def_id);\n-                    let substs = Substs::identity_for_item(tcx, def_id);\n-                    let ty = tcx.mk_anon(tcx.hir.local_def_id(ast_ty.id), substs);\n-\n-                    // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n-                    let bounds = compute_bounds(self, ty, bounds,\n-                                                SizedByDefault::Yes,\n-                                                ast_ty.span);\n-                    let predicates = bounds.predicates(tcx, ty);\n-                    let predicates = tcx.lift_to_global(&predicates).unwrap();\n-                    tcx.maps.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n-                        parent: None,\n-                        predicates: predicates\n-                    });\n-\n-                    ty\n+                    tcx.mk_anon(def_id, Substs::identity_for_item(tcx, def_id))\n                 } else {\n                     span_err!(tcx.sess, ast_ty.span, E0562,\n                               \"`impl Trait` not allowed outside of function \\\n@@ -1353,10 +1299,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"compute_opt_region_bound(existential_predicates={:?})\",\n                existential_predicates);\n \n-        if let Some(principal) = existential_predicates.principal() {\n-            self.ensure_super_predicates(span, principal.def_id());\n-        }\n-\n         // No explicit region bound specified. Therefore, examine trait\n         // bounds and see if we can derive region bounds from those.\n         let derived_region_bounds ="}, {"sha": "4085a171bbef53801977e1efa5a026c107968e5f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n-            self.used_trait_imports.borrow_mut().insert(import_def_id);\n+            self.tables.borrow_mut().used_trait_imports.insert(import_def_id);\n         }\n \n         self.tcx.check_stability(pick.item.def_id, call_expr.id, span);\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n-            self.used_trait_imports.borrow_mut().insert(import_def_id);\n+            self.tables.borrow_mut().used_trait_imports.insert(import_def_id);\n         }\n \n         let def = pick.item.def();"}, {"sha": "68d8280d397d7aadb706759fa86cf30ae583206b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 166, "deletions": 140, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -95,21 +95,21 @@ use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n+use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use session::{Session, CompileResult};\n use TypeAndSubsts;\n use lint;\n use util::common::{ErrorReported, indenter};\n-use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::mem::replace;\n use std::ops::{self, Deref};\n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::attr;\n use syntax::codemap::{self, original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n@@ -174,16 +174,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n     // deanonymize TyAnon, after typeck is done with all functions.\n-    anon_types: RefCell<DefIdMap<Ty<'tcx>>>,\n-\n-    // Obligations which will have to be checked at the end of\n-    // type-checking, after all functions have been inferred.\n-    deferred_obligations: RefCell<Vec<traits::DeferredObligation<'tcx>>>,\n-\n-    // a set of trait import def-ids that we use during method\n-    // resolution; during writeback, this is written into\n-    // `tcx.used_trait_imports` for this item def-id\n-    used_trait_imports: RefCell<FxHashSet<DefId>>,\n+    anon_types: RefCell<NodeMap<Ty<'tcx>>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -507,9 +498,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n-            anon_types: RefCell::new(DefIdMap()),\n-            deferred_obligations: RefCell::new(Vec::new()),\n-            used_trait_imports: RefCell::new(DefIdSet()),\n+            anon_types: RefCell::new(NodeMap()),\n         }\n     }\n \n@@ -545,7 +534,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyArray(_, length) => {\n-                check_const_with_type(self.tcx, length, self.tcx.types.usize, length.node_id);\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(length.node_id));\n             }\n             _ => {}\n         }\n@@ -556,7 +545,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         match e.node {\n             hir::ExprRepeat(_, count) => {\n-                check_const_with_type(self.tcx, count, self.tcx.types.usize, count.node_id);\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(count.node_id));\n             }\n             _ => {}\n         }\n@@ -568,20 +557,18 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemFn(ref decl, .., body_id) => {\n-                check_bare_fn(self.tcx, &decl, body_id, item.id, item.span);\n+            hir::ItemFn(..) => {\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(item.id));\n             }\n             _ => { }\n         }\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n-            hir::TraitItemKind::Const(_, Some(expr)) => {\n-                check_const(self.tcx, expr, trait_item.id)\n-            }\n-            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body_id)) => {\n-                check_bare_fn(self.tcx, &sig.decl, body_id, trait_item.id, trait_item.span);\n+            hir::TraitItemKind::Const(_, Some(_)) |\n+            hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(trait_item.id));\n             }\n             hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n             hir::TraitItemKind::Const(_, None) |\n@@ -593,11 +580,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n-            hir::ImplItemKind::Const(_, expr) => {\n-                check_const(self.tcx, expr, impl_item.id)\n-            }\n-            hir::ImplItemKind::Method(ref sig, body_id) => {\n-                check_bare_fn(self.tcx, &sig.decl, body_id, impl_item.id, impl_item.span);\n+            hir::ImplItemKind::Const(..) |\n+            hir::ImplItemKind::Method(..) => {\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(impl_item.id));\n             }\n             hir::ImplItemKind::Type(_) => {\n                 // Nothing to do here.\n@@ -625,26 +610,6 @@ pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult\n     tcx.sess.track_errors(|| {\n         let mut visit = CheckItemBodiesVisitor { tcx: tcx };\n         tcx.visit_all_item_likes_in_krate(DepNode::TypeckTables, &mut visit);\n-\n-        // Process deferred obligations, now that all functions\n-        // bodies have been fully inferred.\n-        for (&item_id, obligations) in tcx.deferred_obligations.borrow().iter() {\n-            // Use the same DepNode as for the body of the original function/item.\n-            let def_id = tcx.hir.local_def_id(item_id);\n-            let _task = tcx.dep_graph.in_task(DepNode::TypeckTables(def_id));\n-\n-            let param_env = ParameterEnvironment::for_item(tcx, item_id);\n-            tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n-                let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                for obligation in obligations.iter().map(|o| o.to_obligation()) {\n-                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                }\n-\n-                if let Err(errors) = fulfillment_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&errors);\n-                }\n-            });\n-        }\n     })\n }\n \n@@ -668,38 +633,145 @@ pub fn check_drop_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult\n     })\n }\n \n-fn check_bare_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           decl: &'tcx hir::FnDecl,\n-                           body_id: hir::BodyId,\n-                           fn_id: ast::NodeId,\n-                           span: Span) {\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        typeck_tables,\n+        closure_type,\n+        closure_kind,\n+        ..*providers\n+    };\n+}\n+\n+fn closure_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          def_id: DefId)\n+                          -> ty::PolyFnSig<'tcx> {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    tcx.item_tables(def_id).closure_tys[&node_id]\n+}\n+\n+fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          def_id: DefId)\n+                          -> ty::ClosureKind {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    tcx.item_tables(def_id).closure_kinds[&node_id]\n+}\n+\n+fn typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> &'tcx ty::TypeckTables<'tcx> {\n+    // Closures' tables come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    if outer_def_id != def_id {\n+        return tcx.item_tables(outer_def_id);\n+    }\n+\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let span = tcx.hir.span(id);\n+    let unsupported = || {\n+        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n+    };\n+\n+    // Figure out what primary body this item has.\n+    let mut fn_decl = None;\n+    let body_id = match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemConst(_, body) |\n+                hir::ItemStatic(_, _, body) => body,\n+                hir::ItemFn(ref decl, .., body) => {\n+                    fn_decl = Some(decl);\n+                    body\n+                }\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeTraitItem(item) => {\n+            match item.node {\n+                hir::TraitItemKind::Const(_, Some(body)) => body,\n+                hir::TraitItemKind::Method(ref sig,\n+                    hir::TraitMethod::Provided(body)) => {\n+                        fn_decl = Some(&sig.decl);\n+                        body\n+                    }\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeImplItem(item) => {\n+            match item.node {\n+                hir::ImplItemKind::Const(_, body) => body,\n+                hir::ImplItemKind::Method(ref sig, body) => {\n+                    fn_decl = Some(&sig.decl);\n+                    body\n+                }\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeExpr(expr) => {\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            // Type-checking should not let closures get\n+            // this far in a constant position.\n+            // Assume that everything other than closures\n+            // is a constant \"initializer\" expression.\n+            match expr.node {\n+                hir::ExprClosure(..) => {\n+                    // We should've bailed out above for closures.\n+                    span_bug!(expr.span, \"unexpected closure\")\n+                }\n+                _ => hir::BodyId { node_id: expr.id }\n+            }\n+        }\n+        _ => unsupported()\n+    };\n     let body = tcx.hir.body(body_id);\n \n-    let fn_sig = tcx.item_type(tcx.hir.local_def_id(fn_id)).fn_sig();\n+    Inherited::build(tcx, id).enter(|inh| {\n+        let fcx = if let Some(decl) = fn_decl {\n+            let fn_sig = tcx.item_type(def_id).fn_sig();\n+\n+            check_abi(tcx, span, fn_sig.abi());\n \n-    check_abi(tcx, span, fn_sig.abi());\n+            // Compute the fty from point of view of inside fn.\n+            let fn_scope = inh.tcx.region_maps.call_site_extent(id, body_id.node_id);\n+            let fn_sig =\n+                fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n+            let fn_sig =\n+                inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n+            let fn_sig =\n+                inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n \n-    Inherited::build(tcx, fn_id).enter(|inh| {\n-        // Compute the fty from point of view of inside fn.\n-        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id);\n-        let fn_sig =\n-            fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n-        let fn_sig =\n-            inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n-        let fn_sig =\n-            inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n+            check_fn(&inh, fn_sig, decl, id, body)\n+        } else {\n+            let expected_type = tcx.item_type(def_id);\n+            let fcx = FnCtxt::new(&inh, None, body.value.id);\n+            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n-        let fcx = check_fn(&inh, fn_sig, decl, fn_id, body);\n+            // Gather locals in statics (because of block expressions).\n+            // This is technically unnecessary because locals in static items are forbidden,\n+            // but prevents type checking from blowing up before const checking can properly\n+            // emit an error.\n+            GatherLocalsVisitor { fcx: &fcx }.visit_body(body);\n+\n+            fcx.check_expr_coercable_to_type(&body.value, expected_type);\n+\n+            fcx\n+        };\n \n         fcx.select_all_obligations_and_apply_defaults();\n         fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n-        fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n+        fcx.select_all_obligations_or_error();\n \n-        fcx.regionck_fn(fn_id, body);\n-        fcx.resolve_type_vars_in_body(body);\n-    });\n+        if fn_decl.is_some() {\n+            fcx.regionck_fn(id, body);\n+        } else {\n+            fcx.regionck_expr(body);\n+        }\n+\n+        fcx.resolve_type_vars_in_body(body)\n+    })\n }\n \n fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n@@ -772,7 +844,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                 _: hir::BodyId, _: Span, _: ast::NodeId) { }\n }\n \n-/// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n+/// Helper used for fns and closures. Does the grungy work of checking a function\n /// body and returns the function context used for that purpose, since in the case of a fn item\n /// there is still a bit more to do.\n ///\n@@ -835,7 +907,7 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let def_id = tcx.hir.local_def_id(id);\n     check_representable(tcx, span, def_id);\n \n-    if tcx.lookup_simd(def_id) {\n+    if tcx.lookup_adt_def(def_id).repr.simd {\n         check_simd(tcx, span, def_id);\n     }\n }\n@@ -853,8 +925,10 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n-      hir::ItemStatic(.., e) |\n-      hir::ItemConst(_, e) => check_const(tcx, e, it.id),\n+      hir::ItemStatic(..) |\n+      hir::ItemConst(..) => {\n+        tcx.item_tables(tcx.hir.local_def_id(it.id));\n+      }\n       hir::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(tcx,\n                             it.span,\n@@ -1197,42 +1271,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-/// Checks a constant with a given type.\n-fn check_const_with_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   body: hir::BodyId,\n-                                   expected_type: Ty<'tcx>,\n-                                   id: ast::NodeId) {\n-    let body = tcx.hir.body(body);\n-    Inherited::build(tcx, id).enter(|inh| {\n-        let fcx = FnCtxt::new(&inh, None, body.value.id);\n-        fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n-\n-        // Gather locals in statics (because of block expressions).\n-        // This is technically unnecessary because locals in static items are forbidden,\n-        // but prevents type checking from blowing up before const checking can properly\n-        // emit an error.\n-        GatherLocalsVisitor { fcx: &fcx }.visit_body(body);\n-\n-        fcx.check_expr_coercable_to_type(&body.value, expected_type);\n-\n-        fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze(body);\n-        fcx.select_obligations_where_possible();\n-        fcx.check_casts();\n-        fcx.select_all_obligations_or_error();\n-\n-        fcx.regionck_expr(body);\n-        fcx.resolve_type_vars_in_body(body);\n-    });\n-}\n-\n-fn check_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         body: hir::BodyId,\n-                         id: ast::NodeId) {\n-    let decl_ty = tcx.item_type(tcx.hir.local_def_id(id));\n-    check_const_with_type(tcx, body, decl_ty, id);\n-}\n-\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n@@ -1293,17 +1331,17 @@ pub fn check_enum_variants<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      vs: &'tcx [hir::Variant],\n                                      id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(id);\n-    let hint = *tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n+    let def = tcx.lookup_adt_def(def_id);\n \n-    if hint != attr::ReprAny && vs.is_empty() {\n+    if vs.is_empty() && tcx.has_attr(def_id, \"repr\") {\n         struct_span_err!(\n             tcx.sess, sp, E0084,\n             \"unsupported representation for zero-variant enum\")\n             .span_label(sp, &format!(\"unsupported enum representation\"))\n             .emit();\n     }\n \n-    let repr_type_ty = tcx.enum_repr_type(Some(&hint)).to_ty(tcx);\n+    let repr_type_ty = def.repr.discr_type().to_ty(tcx);\n     if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n         if !tcx.sess.features.borrow().i128_type {\n             emit_feature_err(&tcx.sess.parse_sess,\n@@ -1313,13 +1351,10 @@ pub fn check_enum_variants<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for v in vs {\n         if let Some(e) = v.node.disr_expr {\n-            check_const_with_type(tcx, e, repr_type_ty, e.node_id);\n+            tcx.item_tables(tcx.hir.local_def_id(e.node_id));\n         }\n     }\n \n-    let def_id = tcx.hir.local_def_id(id);\n-\n-    let def = tcx.lookup_adt_def(def_id);\n     let mut disr_vals: Vec<ConstInt> = Vec::new();\n     for (discr, v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n@@ -1353,35 +1388,30 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         &self.ast_ty_to_ty_cache\n     }\n \n-    fn get_item_type(&self, _: Span, id: DefId) -> Ty<'tcx> {\n-        self.tcx().item_type(id)\n-    }\n-\n-    fn ensure_super_predicates(&self, _: Span, _: DefId) {\n-        // all super predicates are ensured during collect pass\n-    }\n-\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         Some(&self.parameter_environment.free_substs)\n     }\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n-                                 -> Vec<ty::Predicate<'tcx>>\n+                                 -> ty::GenericPredicates<'tcx>\n     {\n         let tcx = self.tcx;\n         let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let item_id = tcx.hir.ty_param_owner(node_id);\n         let item_def_id = tcx.hir.local_def_id(item_id);\n         let generics = tcx.item_generics(item_def_id);\n         let index = generics.type_param_to_index[&def_id.index];\n-        self.parameter_environment.caller_bounds.iter().filter(|predicate| {\n-            match **predicate {\n-                ty::Predicate::Trait(ref data) => {\n-                    data.0.self_ty().is_param(index)\n+        ty::GenericPredicates {\n+            parent: None,\n+            predicates: self.parameter_environment.caller_bounds.iter().filter(|predicate| {\n+                match **predicate {\n+                    ty::Predicate::Trait(ref data) => {\n+                        data.0.self_ty().is_param(index)\n+                    }\n+                    _ => false\n                 }\n-                _ => false\n-            }\n-        }).cloned().collect()\n+            }).cloned().collect()\n+        }\n     }\n \n     fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n@@ -1666,12 +1696,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let ty::TyAnon(def_id, substs) = ty.sty {\n                 // Use the same type variable if the exact same TyAnon appears more\n                 // than once in the return type (e.g. if it's pased to a type alias).\n-                if let Some(ty_var) = self.anon_types.borrow().get(&def_id) {\n+                let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+                if let Some(ty_var) = self.anon_types.borrow().get(&id) {\n                     return ty_var;\n                 }\n                 let span = self.tcx.def_span(def_id);\n                 let ty_var = self.next_ty_var(TypeVariableOrigin::TypeInference(span));\n-                self.anon_types.borrow_mut().insert(def_id, ty_var);\n+                self.anon_types.borrow_mut().insert(id, ty_var);\n \n                 let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n@@ -2206,11 +2237,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n \n-        // Steal the deferred obligations before the fulfillment\n-        // context can turn all of them into errors.\n-        let obligations = fulfillment_cx.take_deferred_obligations();\n-        self.deferred_obligations.borrow_mut().extend(obligations);\n-\n         match fulfillment_cx.select_all_or_error(self) {\n             Ok(()) => { }\n             Err(errors) => { self.report_fulfillment_errors(&errors); }"}, {"sha": "4f0cfa8d014e6db83a60aeaffbbbaff76c4ca26c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -14,7 +14,6 @@\n use self::ResolveReason::*;\n \n use check::FnCtxt;\n-use hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n@@ -34,7 +33,8 @@ use rustc::hir;\n // Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) {\n+    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body)\n+                                     -> &'gcx ty::TypeckTables<'gcx> {\n         assert_eq!(self.writeback_errors.get(), false);\n \n         let item_id = self.tcx.hir.body_owner(body.id());\n@@ -50,18 +50,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n         wbcx.visit_anon_types();\n-        wbcx.visit_deferred_obligations(item_id);\n         wbcx.visit_type_nodes();\n         wbcx.visit_cast_types();\n         wbcx.visit_lints();\n \n-        let tables = self.tcx.alloc_tables(wbcx.tables);\n-        self.tcx.maps.typeck_tables.borrow_mut().insert(item_def_id, tables);\n-\n-        let used_trait_imports = mem::replace(&mut *self.used_trait_imports.borrow_mut(),\n+        let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n                                               DefIdSet());\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n-        self.tcx.maps.used_trait_imports.borrow_mut().insert(item_def_id, used_trait_imports);\n+        wbcx.tables.used_trait_imports = used_trait_imports;\n+\n+        self.tcx.alloc_tables(wbcx.tables)\n     }\n }\n \n@@ -282,20 +280,18 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_closures(&self) {\n+    fn visit_closures(&mut self) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n         for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n-            let def_id = self.tcx().hir.local_def_id(id);\n-            self.tcx().maps.closure_type.borrow_mut().insert(def_id, closure_ty);\n+            self.tables.closure_tys.insert(id, closure_ty);\n         }\n \n         for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n-            let def_id = self.tcx().hir.local_def_id(id);\n-            self.tcx().maps.closure_kind.borrow_mut().insert(def_id, closure_kind);\n+            self.tables.closure_kinds.insert(id, closure_kind);\n         }\n     }\n \n@@ -316,14 +312,14 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tables.borrow_mut().lints.transfer(&mut self.tables.lints);\n     }\n \n-    fn visit_anon_types(&self) {\n+    fn visit_anon_types(&mut self) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n         let gcx = self.tcx().global_tcx();\n-        for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n-            let reason = ResolvingAnonTy(def_id);\n+        for (&node_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n+            let reason = ResolvingAnonTy(node_id);\n             let inside_ty = self.resolve(&concrete_ty, reason);\n \n             // Convert the type from the function into a type valid outside\n@@ -361,7 +357,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.maps.ty.borrow_mut().insert(def_id, outside_ty);\n+            self.tables.node_types.insert(node_id, outside_ty);\n         }\n     }\n \n@@ -483,19 +479,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_deferred_obligations(&mut self, item_id: ast::NodeId) {\n-        let deferred_obligations = self.fcx.deferred_obligations.borrow();\n-        let obligations: Vec<_> = deferred_obligations.iter().map(|obligation| {\n-            let reason = ResolvingDeferredObligation(obligation.cause.span);\n-            self.resolve(obligation, reason)\n-        }).collect();\n-\n-        if !obligations.is_empty() {\n-            assert!(self.fcx.tcx.deferred_obligations.borrow_mut()\n-                                .insert(item_id, obligations).is_none());\n-        }\n-    }\n-\n     fn visit_type_nodes(&self) {\n         for (&id, ty) in self.fcx.ast_ty_to_ty_cache.borrow().iter() {\n             let ty = self.resolve(ty, ResolvingTyNode(id));\n@@ -528,8 +511,7 @@ enum ResolveReason {\n     ResolvingClosure(ast::NodeId),\n     ResolvingFnSig(ast::NodeId),\n     ResolvingFieldTypes(ast::NodeId),\n-    ResolvingAnonTy(DefId),\n-    ResolvingDeferredObligation(Span),\n+    ResolvingAnonTy(ast::NodeId),\n     ResolvingTyNode(ast::NodeId),\n }\n \n@@ -545,13 +527,10 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingClosure(id) |\n             ResolvingFnSig(id) |\n             ResolvingFieldTypes(id) |\n-            ResolvingTyNode(id) => {\n+            ResolvingTyNode(id) |\n+            ResolvingAnonTy(id) => {\n                 tcx.hir.span(id)\n             }\n-            ResolvingAnonTy(did) => {\n-                tcx.def_span(did)\n-            }\n-            ResolvingDeferredObligation(span) => span\n         }\n     }\n }\n@@ -626,7 +605,6 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n \n                 ResolvingFnSig(_) |\n                 ResolvingFieldTypes(_) |\n-                ResolvingDeferredObligation(_) |\n                 ResolvingTyNode(_) => {\n                     // any failures here should also fail when\n                     // resolving the patterns, closure types, or"}, {"sha": "3791079dc812cb0b6d69ffb017c38af77a64a59d", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -70,7 +70,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let item_def_id = tcx.hir.local_def_id(item_id);\n \n         // this will have been written by the main typeck pass\n-        if let Some(imports) = tcx.maps.used_trait_imports.borrow().get(&item_def_id) {\n+        if let Some(tables) = tcx.maps.typeck_tables.borrow().get(&item_def_id) {\n+            let imports = &tables.used_trait_imports;\n             debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n             used_trait_imports.extend(imports);\n         } else {"}, {"sha": "2a95f5f5d08040aea91c2993186f2fd5a69352ff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 376, "deletions": 415, "changes": 791, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -47,10 +47,6 @@ item, we may need to compute the *type scheme* or *trait definition*\n for other items.\n \n There are some shortcomings in this design:\n-\n-- Before walking the set of supertraits for a given trait, you must\n-  call `ensure_super_predicates` on that trait def-id. Otherwise,\n-  `item_super_predicates` will result in ICEs.\n - Because the item generics include defaults, cycles through type\n   parameter defaults are illegal even if those defaults are never\n   employed. This is not necessarily a bug.\n@@ -66,7 +62,7 @@ use middle::resolve_lifetime as rl;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer, ReprOptions};\n+use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n@@ -80,6 +76,7 @@ use std::cell::RefCell;\n use std::collections::BTreeMap;\n \n use syntax::{abi, ast, attr};\n+use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -98,9 +95,14 @@ pub fn collect_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n+        ty,\n         generics,\n+        predicates,\n+        super_predicates,\n+        type_param_predicates,\n         trait_def,\n         adt_def,\n+        impl_trait_ref,\n         ..*providers\n     };\n }\n@@ -190,7 +192,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n         for param in &generics.ty_params {\n             if param.default.is_some() {\n                 let def_id = self.tcx.hir.local_def_id(param.id);\n-                type_of_def_id(self.tcx, def_id);\n+                self.tcx.item_type(def_id);\n             }\n         }\n         intravisit::walk_generics(self, generics);\n@@ -200,7 +202,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n         if let hir::ExprClosure(..) = expr.node {\n             let def_id = self.tcx.hir.local_def_id(expr.id);\n             self.tcx.item_generics(def_id);\n-            type_of_def_id(self.tcx, def_id);\n+            self.tcx.item_type(def_id);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n@@ -209,6 +211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n         if let hir::TyImplTrait(..) = ty.node {\n             let def_id = self.tcx.hir.local_def_id(ty.id);\n             self.tcx.item_generics(def_id);\n+            self.tcx.item_predicates(def_id);\n         }\n         intravisit::walk_ty(self, ty);\n     }\n@@ -254,42 +257,12 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         &self.tcx.ast_ty_to_ty_cache\n     }\n \n-    fn get_item_type(&self, span: Span, id: DefId) -> Ty<'tcx> {\n-        self.tcx.cycle_check(span, ty::maps::Query::ty(id), || {\n-            type_of_def_id(self.tcx, id)\n-        })\n-    }\n-\n-    /// Ensure that the (transitive) super predicates for\n-    /// `trait_def_id` are available. This will report a cycle error\n-    /// if a trait `X` (transitively) extends itself in some form.\n-    fn ensure_super_predicates(&self,\n-                               span: Span,\n-                               trait_def_id: DefId) {\n-        if !trait_def_id.is_local() {\n-            // If this trait comes from an external crate, then all of the\n-            // supertraits it may depend on also must come from external\n-            // crates, and hence all of them already have their\n-            // super-predicates \"converted\" (and available from crate\n-            // meta-data), so there is no need to transitively test them.\n-            return;\n-        }\n-\n-        self.tcx.maps.super_predicates.memoize(trait_def_id, || {\n-            self.tcx.cycle_check(span, ty::maps::Query::super_predicates(trait_def_id), || {\n-                super_predicates(self.tcx, trait_def_id)\n-            })\n-        });\n-    }\n-\n     fn get_type_parameter_bounds(&self,\n                                  span: Span,\n                                  def_id: DefId)\n-                                 -> Vec<ty::Predicate<'tcx>>\n+                                 -> ty::GenericPredicates<'tcx>\n     {\n-        self.tcx.cycle_check(span,\n-            ty::maps::Query::type_param_predicates((self.item_def_id, def_id)),\n-            || get_type_parameter_bounds(self.tcx, self.item_def_id, def_id))\n+        self.tcx.maps.type_param_predicates(self.tcx, span, (self.item_def_id, def_id))\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n@@ -343,89 +316,91 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n }\n \n-    fn get_type_parameter_bounds<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           item_def_id: DefId,\n-                                           def_id: DefId)\n-                                           -> Vec<ty::Predicate<'tcx>>\n-    {\n-        use rustc::hir::map::*;\n-        use rustc::hir::*;\n-\n-        // In the AST, bounds can derive from two places. Either\n-        // written inline like `<T:Foo>` or in a where clause like\n-        // `where T:Foo`.\n-\n-        let param_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let param_owner = tcx.hir.ty_param_owner(param_id);\n-        let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n-        let generics = tcx.item_generics(param_owner_def_id);\n-        let index = generics.type_param_to_index[&def_id.index];\n-        let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id));\n-\n-        // Don't look for bounds where the type parameter isn't in scope.\n-        let parent = if item_def_id == param_owner_def_id {\n-            None\n-        } else {\n-            tcx.item_generics(item_def_id).parent\n-        };\n+fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   (item_def_id, def_id): (DefId, DefId))\n+                                   -> ty::GenericPredicates<'tcx> {\n+    use rustc::hir::map::*;\n+    use rustc::hir::*;\n \n-        let mut results = parent.map_or(vec![], |parent| {\n-            let icx = ItemCtxt::new(tcx, parent);\n-            icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n-        });\n+    // In the AST, bounds can derive from two places. Either\n+    // written inline like `<T:Foo>` or in a where clause like\n+    // `where T:Foo`.\n \n-        let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n-        let ast_generics = match tcx.hir.get(item_node_id) {\n-            NodeTraitItem(item) => {\n-                match item.node {\n-                    TraitItemKind::Method(ref sig, _) => &sig.generics,\n-                    _ => return results\n-                }\n+    let param_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let param_owner = tcx.hir.ty_param_owner(param_id);\n+    let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n+    let generics = tcx.item_generics(param_owner_def_id);\n+    let index = generics.type_param_to_index[&def_id.index];\n+    let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id));\n+\n+    // Don't look for bounds where the type parameter isn't in scope.\n+    let parent = if item_def_id == param_owner_def_id {\n+        None\n+    } else {\n+        tcx.item_generics(item_def_id).parent\n+    };\n+\n+    let mut result = parent.map_or(ty::GenericPredicates {\n+        parent: None,\n+        predicates: vec![]\n+    }, |parent| {\n+        let icx = ItemCtxt::new(tcx, parent);\n+        icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n+    });\n+\n+    let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n+    let ast_generics = match tcx.hir.get(item_node_id) {\n+        NodeTraitItem(item) => {\n+            match item.node {\n+                TraitItemKind::Method(ref sig, _) => &sig.generics,\n+                _ => return result\n             }\n+        }\n \n-            NodeImplItem(item) => {\n-                match item.node {\n-                    ImplItemKind::Method(ref sig, _) => &sig.generics,\n-                    _ => return results\n-                }\n+        NodeImplItem(item) => {\n+            match item.node {\n+                ImplItemKind::Method(ref sig, _) => &sig.generics,\n+                _ => return result\n             }\n+        }\n \n-            NodeItem(item) => {\n-                match item.node {\n-                    ItemFn(.., ref generics, _) |\n-                    ItemImpl(_, _, ref generics, ..) |\n-                    ItemTy(_, ref generics) |\n-                    ItemEnum(_, ref generics) |\n-                    ItemStruct(_, ref generics) |\n-                    ItemUnion(_, ref generics) => generics,\n-                    ItemTrait(_, ref generics, ..) => {\n-                        // Implied `Self: Trait` and supertrait bounds.\n-                        if param_id == item_node_id {\n-                            results.push(ty::TraitRef {\n-                                def_id: item_def_id,\n-                                substs: Substs::identity_for_item(tcx, item_def_id)\n-                            }.to_predicate());\n-                        }\n-                        generics\n+        NodeItem(item) => {\n+            match item.node {\n+                ItemFn(.., ref generics, _) |\n+                ItemImpl(_, _, ref generics, ..) |\n+                ItemTy(_, ref generics) |\n+                ItemEnum(_, ref generics) |\n+                ItemStruct(_, ref generics) |\n+                ItemUnion(_, ref generics) => generics,\n+                ItemTrait(_, ref generics, ..) => {\n+                    // Implied `Self: Trait` and supertrait bounds.\n+                    if param_id == item_node_id {\n+                        result.predicates.push(ty::TraitRef {\n+                            def_id: item_def_id,\n+                            substs: Substs::identity_for_item(tcx, item_def_id)\n+                        }.to_predicate());\n                     }\n-                    _ => return results\n+                    generics\n                 }\n+                _ => return result\n             }\n+        }\n \n-            NodeForeignItem(item) => {\n-                match item.node {\n-                    ForeignItemFn(_, _, ref generics) => generics,\n-                    _ => return results\n-                }\n+        NodeForeignItem(item) => {\n+            match item.node {\n+                ForeignItemFn(_, _, ref generics) => generics,\n+                _ => return result\n             }\n+        }\n \n-            _ => return results\n-        };\n+        _ => return result\n+    };\n \n-        let icx = ItemCtxt::new(tcx, item_def_id);\n-        results.extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty));\n-        results\n-    }\n+    let icx = ItemCtxt::new(tcx, item_def_id);\n+    result.predicates.extend(\n+        icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty));\n+    result\n+}\n \n impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     /// Find bounds from hir::Generics. This requires scanning through the\n@@ -483,63 +458,6 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_field<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           field: &hir::StructField,\n-                           ty_f: &'tcx ty::FieldDef)\n-{\n-    tcx.item_generics(ty_f.did);\n-    let tt = ItemCtxt::new(tcx, ty_f.did).to_ty(&field.ty);\n-    tcx.maps.ty.borrow_mut().insert(ty_f.did, tt);\n-    tcx.maps.predicates.borrow_mut().insert(ty_f.did, ty::GenericPredicates {\n-        parent: Some(tcx.hir.get_parent_did(field.id)),\n-        predicates: vec![]\n-    });\n-}\n-\n-fn convert_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            id: ast::NodeId,\n-                            sig: &hir::MethodSig) {\n-    let def_id = tcx.hir.local_def_id(id);\n-\n-    let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), sig.unsafety, sig.abi, &sig.decl);\n-    let substs = Substs::identity_for_item(tcx, def_id);\n-    let fty = tcx.mk_fn_def(def_id, substs, fty);\n-    tcx.maps.ty.borrow_mut().insert(def_id, fty);\n-\n-    ty_generic_predicates(tcx, def_id, &sig.generics);\n-}\n-\n-fn convert_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      container: AssociatedItemContainer,\n-                                      id: ast::NodeId,\n-                                      ty: ty::Ty<'tcx>)\n-{\n-    let predicates = ty::GenericPredicates {\n-        parent: Some(container.id()),\n-        predicates: vec![]\n-    };\n-    let def_id = tcx.hir.local_def_id(id);\n-    tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n-    tcx.maps.ty.borrow_mut().insert(def_id, ty);\n-}\n-\n-fn convert_associated_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     container: AssociatedItemContainer,\n-                                     id: ast::NodeId,\n-                                     ty: Option<Ty<'tcx>>)\n-{\n-    let predicates = ty::GenericPredicates {\n-        parent: Some(container.id()),\n-        predicates: vec![]\n-    };\n-    let def_id = tcx.hir.local_def_id(id);\n-    tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n-\n-    if let Some(ty) = ty {\n-        tcx.maps.ty.borrow_mut().insert(def_id, ty);\n-    }\n-}\n-\n fn ensure_no_ty_param_bounds(tcx: TyCtxt,\n                              span: Span,\n                              generics: &hir::Generics,\n@@ -582,195 +500,125 @@ fn ensure_no_ty_param_bounds(tcx: TyCtxt,\n fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n     let def_id = tcx.hir.local_def_id(it.id);\n-    let icx = ItemCtxt::new(tcx, def_id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(..) | hir::ItemMod(_) => {\n         }\n         hir::ItemForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n-                convert_foreign_item(tcx, item);\n+                let def_id = tcx.hir.local_def_id(item.id);\n+                tcx.item_generics(def_id);\n+                tcx.item_type(def_id);\n+                tcx.item_predicates(def_id);\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n             tcx.item_generics(def_id);\n-            predicates_of_item(tcx, it);\n-            let ty = type_of_def_id(tcx, def_id);\n-            convert_enum_variant_types(tcx,\n-                                       tcx.lookup_adt_def(tcx.hir.local_def_id(it.id)),\n-                                       ty,\n-                                       &enum_definition.variants);\n+            tcx.item_type(def_id);\n+            tcx.item_predicates(def_id);\n+            convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n         },\n-        hir::ItemDefaultImpl(_, ref ast_trait_ref) => {\n-            let trait_ref =\n-                AstConv::instantiate_mono_trait_ref(&icx,\n-                                                    ast_trait_ref,\n-                                                    tcx.mk_self_type());\n-\n-            tcx.record_trait_has_default_impl(trait_ref.def_id);\n-\n-            tcx.maps.impl_trait_ref.borrow_mut().insert(tcx.hir.local_def_id(it.id),\n-                                                         Some(trait_ref));\n+        hir::ItemDefaultImpl(..) => {\n+            if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n+                tcx.record_trait_has_default_impl(trait_ref.def_id);\n+            }\n         }\n-        hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n+        hir::ItemImpl(..) => {\n             tcx.item_generics(def_id);\n-            let selfty = type_of_def_id(tcx, def_id);\n-\n-            let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n-                AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n-            });\n-            tcx.maps.impl_trait_ref.borrow_mut().insert(def_id, trait_ref);\n-\n-            predicates_of_item(tcx, it);\n+            tcx.item_type(def_id);\n+            tcx.impl_trait_ref(def_id);\n+            tcx.item_predicates(def_id);\n         },\n         hir::ItemTrait(..) => {\n             tcx.item_generics(def_id);\n             tcx.lookup_trait_def(def_id);\n-            icx.ensure_super_predicates(it.span, def_id);\n-            predicates_of_item(tcx, it);\n+            tcx.maps.super_predicates(tcx, it.span, def_id);\n+            tcx.item_predicates(def_id);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n             tcx.item_generics(def_id);\n-            predicates_of_item(tcx, it);\n-            let ty = type_of_def_id(tcx, def_id);\n-\n-            let variant = tcx.lookup_adt_def(def_id).struct_variant();\n-\n-            for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n-                convert_field(tcx, f, ty_f)\n+            tcx.item_type(def_id);\n+            tcx.item_predicates(def_id);\n+\n+            for f in struct_def.fields() {\n+                let def_id = tcx.hir.local_def_id(f.id);\n+                tcx.item_generics(def_id);\n+                tcx.item_type(def_id);\n+                tcx.item_predicates(def_id);\n             }\n \n             if !struct_def.is_struct() {\n-                convert_variant_ctor(tcx, struct_def.id(), variant, ty);\n+                convert_variant_ctor(tcx, struct_def.id());\n             }\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(tcx, it.span, generics, \"type\");\n             tcx.item_generics(def_id);\n-            predicates_of_item(tcx, it);\n-            type_of_def_id(tcx, def_id);\n+            tcx.item_type(def_id);\n+            tcx.item_predicates(def_id);\n         },\n         _ => {\n             tcx.item_generics(def_id);\n-            predicates_of_item(tcx, it);\n-            type_of_def_id(tcx, def_id);\n+            tcx.item_type(def_id);\n+            tcx.item_predicates(def_id);\n         },\n     }\n }\n \n fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item: &hir::TraitItem) {\n-    // we can lookup details about the trait because items are visited\n-    // before trait-items\n-    let trait_def_id = tcx.hir.get_parent_did(trait_item.id);\n-\n     let def_id = tcx.hir.local_def_id(trait_item.id);\n+    tcx.item_generics(def_id);\n+\n     match trait_item.node {\n-        hir::TraitItemKind::Const(ref ty, _) => {\n-            tcx.item_generics(def_id);\n-            let ty = ItemCtxt::new(tcx, def_id).to_ty(&ty);\n-            convert_associated_const(tcx,\n-                                     TraitContainer(trait_def_id),\n-                                     trait_item.id,\n-                                     ty);\n+        hir::TraitItemKind::Const(..) |\n+        hir::TraitItemKind::Type(_, Some(_)) |\n+        hir::TraitItemKind::Method(..) => {\n+            tcx.item_type(def_id);\n         }\n \n-        hir::TraitItemKind::Type(_, ref opt_ty) => {\n-            tcx.item_generics(def_id);\n-\n-            let typ = opt_ty.as_ref().map(|ty| ItemCtxt::new(tcx, def_id).to_ty(&ty));\n-\n-            convert_associated_type(tcx, TraitContainer(trait_def_id), trait_item.id, typ);\n-        }\n+        hir::TraitItemKind::Type(_, None) => {}\n+    };\n \n-        hir::TraitItemKind::Method(ref sig, _) => {\n-            convert_method(tcx, trait_item.id, sig);\n-        }\n-    }\n+    tcx.item_predicates(def_id);\n }\n \n fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item: &hir::ImplItem) {\n-    // we can lookup details about the impl because items are visited\n-    // before impl-items\n-    let impl_def_id = tcx.hir.get_parent_did(impl_item.id);\n-\n     let def_id = tcx.hir.local_def_id(impl_item.id);\n-    match impl_item.node {\n-        hir::ImplItemKind::Const(ref ty, _) => {\n-            tcx.item_generics(def_id);\n-            let ty = ItemCtxt::new(tcx, def_id).to_ty(&ty);\n-            convert_associated_const(tcx,\n-                                     ImplContainer(impl_def_id),\n-                                     impl_item.id,\n-                                     ty);\n-        }\n-\n-        hir::ImplItemKind::Type(ref ty) => {\n-            tcx.item_generics(def_id);\n-\n-            if tcx.impl_trait_ref(impl_def_id).is_none() {\n-                span_err!(tcx.sess, impl_item.span, E0202,\n-                          \"associated types are not allowed in inherent impls\");\n-            }\n-\n-            let typ = ItemCtxt::new(tcx, def_id).to_ty(ty);\n-\n-            convert_associated_type(tcx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n-        }\n-\n-        hir::ImplItemKind::Method(ref sig, _) => {\n-            convert_method(tcx, impl_item.id, sig);\n-        }\n-    }\n+    tcx.item_generics(def_id);\n+    tcx.item_type(def_id);\n+    tcx.item_predicates(def_id);\n }\n \n fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  ctor_id: ast::NodeId,\n-                                  variant: &'tcx ty::VariantDef,\n-                                  ty: Ty<'tcx>) {\n+                                  ctor_id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(ctor_id);\n     tcx.item_generics(def_id);\n-    let ctor_ty = match variant.ctor_kind {\n-        CtorKind::Fictive | CtorKind::Const => ty,\n-        CtorKind::Fn => {\n-            let inputs = variant.fields.iter().map(|field| tcx.item_type(field.did));\n-            let substs = Substs::identity_for_item(tcx, def_id);\n-            tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n-                inputs,\n-                ty,\n-                false,\n-                hir::Unsafety::Normal,\n-                abi::Abi::Rust\n-            )))\n-        }\n-    };\n-    tcx.maps.ty.borrow_mut().insert(def_id, ctor_ty);\n-    tcx.maps.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n-        parent: Some(tcx.hir.get_parent_did(ctor_id)),\n-        predicates: vec![]\n-    });\n+    tcx.item_type(def_id);\n+    tcx.item_predicates(def_id);\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        def: &'tcx ty::AdtDef,\n-                                        ty: Ty<'tcx>,\n+                                        def_id: DefId,\n                                         variants: &[hir::Variant]) {\n-    let repr_hints = tcx.lookup_repr_hints(def.did);\n-    let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n+    let def = tcx.lookup_adt_def(def_id);\n+    let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_discr = None::<ConstInt>;\n \n     // fill the discriminant values and field types\n-    for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n+    for variant in variants {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n-            let result = evaluate_disr_expr(tcx, repr_type, e);\n-\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n-            tcx.maps.monomorphic_const_eval.borrow_mut()\n-               .insert(expr_did, result.map(ConstVal::Integral));\n+            let result = tcx.maps.monomorphic_const_eval.memoize(expr_did, || {\n+                evaluate_disr_expr(tcx, repr_type, e).map(ConstVal::Integral)\n+            });\n \n-            result.ok()\n+            match result {\n+                Ok(ConstVal::Integral(x)) => Some(x),\n+                _ => None\n+            }\n         } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n             Some(discr)\n         } else {\n@@ -784,13 +632,16 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             None\n         }.unwrap_or(wrapped_discr));\n \n-        for (f, ty_f) in variant.node.data.fields().iter().zip(ty_variant.fields.iter()) {\n-            convert_field(tcx, f, ty_f)\n+        for f in variant.node.data.fields() {\n+            let def_id = tcx.hir.local_def_id(f.id);\n+            tcx.item_generics(def_id);\n+            tcx.item_type(def_id);\n+            tcx.item_predicates(def_id);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        convert_variant_ctor(tcx, variant.node.data.id(), ty_variant, ty);\n+        convert_variant_ctor(tcx, variant.node.data.id());\n     }\n }\n \n@@ -985,7 +836,7 @@ fn super_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Now require that immediate supertraits are converted,\n     // which will, in turn, reach indirect supertraits.\n     for bound in superbounds.iter().filter_map(|p| p.to_opt_poly_trait_ref()) {\n-        icx.ensure_super_predicates(item.span, bound.def_id());\n+        tcx.maps.super_predicates(tcx, item.span, bound.def_id());\n     }\n \n     ty::GenericPredicates {\n@@ -1212,121 +1063,179 @@ fn generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn type_of_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def_id: DefId)\n-                            -> Ty<'tcx> {\n-    let node_id = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n-        id\n-    } else {\n-        return tcx.item_type(def_id);\n-    };\n-    tcx.maps.ty.memoize(def_id, || {\n-        use rustc::hir::map::*;\n-        use rustc::hir::*;\n+fn ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                def_id: DefId)\n+                -> Ty<'tcx> {\n+    use rustc::hir::map::*;\n+    use rustc::hir::*;\n \n-        // Alway bring in generics, as computing the type needs them.\n-        tcx.item_generics(def_id);\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n-        let icx = ItemCtxt::new(tcx, def_id);\n+    let icx = ItemCtxt::new(tcx, def_id);\n \n-        match tcx.hir.get(node_id) {\n-            NodeItem(item) => {\n-                match item.node {\n-                    ItemStatic(ref t, ..) | ItemConst(ref t, _) |\n-                    ItemTy(ref t, _) | ItemImpl(.., ref t, _) => {\n-                        icx.to_ty(t)\n-                    }\n-                    ItemFn(ref decl, unsafety, _, abi, _, _) => {\n-                        let tofd = AstConv::ty_of_fn(&icx, unsafety, abi, &decl);\n-                        let substs = Substs::identity_for_item(tcx, def_id);\n-                        tcx.mk_fn_def(def_id, substs, tofd)\n-                    }\n-                    ItemEnum(..) |\n-                    ItemStruct(..) |\n-                    ItemUnion(..) => {\n-                        let def = tcx.lookup_adt_def(def_id);\n-                        let substs = Substs::identity_for_item(tcx, def_id);\n-                        tcx.mk_adt(def, substs)\n-                    }\n-                    ItemDefaultImpl(..) |\n-                    ItemTrait(..) |\n-                    ItemMod(..) |\n-                    ItemForeignMod(..) |\n-                    ItemExternCrate(..) |\n-                    ItemUse(..) => {\n-                        span_bug!(\n-                            item.span,\n-                            \"compute_type_of_item: unexpected item type: {:?}\",\n-                            item.node);\n-                    }\n+    match tcx.hir.get(node_id) {\n+        NodeTraitItem(item) => {\n+            match item.node {\n+                TraitItemKind::Method(ref sig, _) => {\n+                    let fty = AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl);\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs, fty)\n+                }\n+                TraitItemKind::Const(ref ty, _) |\n+                TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n+                TraitItemKind::Type(_, None) => {\n+                    span_bug!(item.span, \"associated type missing default\");\n                 }\n             }\n-            NodeForeignItem(foreign_item) => {\n-                let abi = tcx.hir.get_foreign_abi(node_id);\n+        }\n \n-                match foreign_item.node {\n-                    ForeignItemFn(ref fn_decl, _, _) => {\n-                        compute_type_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n+        NodeImplItem(item) => {\n+            match item.node {\n+                ImplItemKind::Method(ref sig, _) => {\n+                    let fty = AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl);\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs, fty)\n+                }\n+                ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n+                ImplItemKind::Type(ref ty) => {\n+                    if tcx.impl_trait_ref(tcx.hir.get_parent_did(node_id)).is_none() {\n+                        span_err!(tcx.sess, item.span, E0202,\n+                                  \"associated types are not allowed in inherent impls\");\n                     }\n-                    ForeignItemStatic(ref t, _) => icx.to_ty(t)\n+\n+                    icx.to_ty(ty)\n                 }\n             }\n-            NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n-                tcx.mk_closure(def_id, Substs::for_item(\n-                    tcx, def_id,\n-                    |def, _| {\n-                        let region = def.to_early_bound_region_data();\n-                        tcx.mk_region(ty::ReEarlyBound(region))\n-                    },\n-                    |def, _| tcx.mk_param_from_def(def)\n-                ))\n+        }\n+\n+        NodeItem(item) => {\n+            match item.node {\n+                ItemStatic(ref t, ..) | ItemConst(ref t, _) |\n+                ItemTy(ref t, _) | ItemImpl(.., ref t, _) => {\n+                    icx.to_ty(t)\n+                }\n+                ItemFn(ref decl, unsafety, _, abi, _, _) => {\n+                    let tofd = AstConv::ty_of_fn(&icx, unsafety, abi, &decl);\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs, tofd)\n+                }\n+                ItemEnum(..) |\n+                ItemStruct(..) |\n+                ItemUnion(..) => {\n+                    let def = tcx.lookup_adt_def(def_id);\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    tcx.mk_adt(def, substs)\n+                }\n+                ItemDefaultImpl(..) |\n+                ItemTrait(..) |\n+                ItemMod(..) |\n+                ItemForeignMod(..) |\n+                ItemExternCrate(..) |\n+                ItemUse(..) => {\n+                    span_bug!(\n+                        item.span,\n+                        \"compute_type_of_item: unexpected item type: {:?}\",\n+                        item.node);\n+                }\n             }\n-            NodeTyParam(&hir::TyParam { default: Some(ref ty), .. }) => {\n-                icx.to_ty(ty)\n+        }\n+\n+        NodeForeignItem(foreign_item) => {\n+            let abi = tcx.hir.get_foreign_abi(node_id);\n+\n+            match foreign_item.node {\n+                ForeignItemFn(ref fn_decl, _, _) => {\n+                    compute_type_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n+                }\n+                ForeignItemStatic(ref t, _) => icx.to_ty(t)\n             }\n-            x => {\n-                bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n+        }\n+\n+        NodeStructCtor(&ref def) |\n+        NodeVariant(&Spanned { node: hir::Variant_ { data: ref def, .. }, .. }) => {\n+            let ty = tcx.item_type(tcx.hir.get_parent_did(node_id));\n+            match *def {\n+                VariantData::Unit(..) | VariantData::Struct(..) => ty,\n+                VariantData::Tuple(ref fields, _) => {\n+                    let inputs = fields.iter().map(|f| {\n+                        tcx.item_type(tcx.hir.local_def_id(f.id))\n+                    });\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n+                        inputs,\n+                        ty,\n+                        false,\n+                        hir::Unsafety::Normal,\n+                        abi::Abi::Rust\n+                    )))\n+                }\n             }\n         }\n-    })\n-}\n \n-fn predicates_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n-    let def_id = tcx.hir.local_def_id(it.id);\n+        NodeField(field) => icx.to_ty(&field.ty),\n \n-    let no_generics = hir::Generics::empty();\n-    let generics = match it.node {\n-        hir::ItemFn(.., ref generics, _) |\n-        hir::ItemTy(_, ref generics) |\n-        hir::ItemEnum(_, ref generics) |\n-        hir::ItemStruct(_, ref generics) |\n-        hir::ItemUnion(_, ref generics) |\n-        hir::ItemTrait(_, ref generics, _, _) |\n-        hir::ItemImpl(_, _, ref generics, ..) => generics,\n-        _ => &no_generics\n-    };\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+            tcx.mk_closure(def_id, Substs::for_item(\n+                tcx, def_id,\n+                |def, _| {\n+                    let region = def.to_early_bound_region_data();\n+                    tcx.mk_region(ty::ReEarlyBound(region))\n+                },\n+                |def, _| tcx.mk_param_from_def(def)\n+            ))\n+        }\n \n-    ty_generic_predicates(tcx, def_id, generics);\n-}\n+        NodeExpr(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n+            NodeTy(&hir::Ty { node: TyArray(_, body), .. }) |\n+            NodeExpr(&hir::Expr { node: ExprRepeat(_, body), .. })\n+                if body.node_id == node_id => tcx.types.usize,\n \n-fn convert_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  it: &hir::ForeignItem)\n-{\n-    // For reasons I cannot fully articulate, I do so hate the AST\n-    // map, and I regard each time that I use it as a personal and\n-    // moral failing, but at the moment it seems like the only\n-    // convenient way to extract the ABI. - ndm\n-    let def_id = tcx.hir.local_def_id(it.id);\n-    tcx.item_generics(def_id);\n-    type_of_def_id(tcx, def_id);\n+            NodeVariant(&Spanned { node: Variant_ { disr_expr: Some(e), .. }, .. })\n+                if e.node_id == node_id => {\n+                    tcx.lookup_adt_def(tcx.hir.get_parent_did(node_id))\n+                        .repr.discr_type().to_ty(tcx)\n+                }\n \n-    let no_generics = hir::Generics::empty();\n-    let generics = match it.node {\n-        hir::ForeignItemFn(_, _, ref generics) => generics,\n-        hir::ForeignItemStatic(..) => &no_generics\n-    };\n+            x => {\n+                bug!(\"unexpected expr parent in type_of_def_id(): {:?}\", x);\n+            }\n+        },\n+\n+        NodeTyParam(&hir::TyParam { default: Some(ref ty), .. }) => {\n+            icx.to_ty(ty)\n+        }\n+\n+        NodeTy(&hir::Ty { node: TyImplTrait(..), .. }) => {\n+            let owner = tcx.hir.get_parent_did(node_id);\n+            tcx.item_tables(owner).node_id_to_type(node_id)\n+        }\n \n-    ty_generic_predicates(tcx, def_id, generics);\n+        x => {\n+            bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n+        }\n+    }\n+}\n+\n+fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            def_id: DefId)\n+                            -> Option<ty::TraitRef<'tcx>> {\n+    let icx = ItemCtxt::new(tcx, def_id);\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    match tcx.hir.expect_item(node_id).node {\n+        hir::ItemDefaultImpl(_, ref ast_trait_ref) => {\n+            Some(AstConv::instantiate_mono_trait_ref(&icx,\n+                                                     ast_trait_ref,\n+                                                     tcx.mk_self_type()))\n+        }\n+        hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n+            opt_trait_ref.as_ref().map(|ast_trait_ref| {\n+                let selfty = tcx.item_type(def_id);\n+                AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n+            })\n+        }\n+        _ => bug!()\n+    }\n }\n \n // Is it marked with ?Sized\n@@ -1389,37 +1298,87 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n         .filter(move |l| !tcx.named_region_map.late_bound.contains(&l.lifetime.id))\n }\n \n-fn ty_generic_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   def_id: DefId,\n-                                   ast_generics: &hir::Generics) {\n+fn predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        def_id: DefId)\n+                        -> ty::GenericPredicates<'tcx> {\n+    use rustc::hir::map::*;\n+    use rustc::hir::*;\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let node = tcx.hir.get(node_id);\n+\n+    let mut is_trait = None;\n+\n     let icx = ItemCtxt::new(tcx, def_id);\n-    let generics = tcx.item_generics(def_id);\n-    let parent_count = generics.parent_count() as u32;\n-    let has_own_self = generics.has_self && parent_count == 0;\n+    let no_generics = hir::Generics::empty();\n+    let ast_generics = match node {\n+        NodeTraitItem(item) => {\n+            match item.node {\n+                TraitItemKind::Method(ref sig, _) => &sig.generics,\n+                _ => &no_generics\n+            }\n+        }\n \n-    let mut predicates = vec![];\n+        NodeImplItem(item) => {\n+            match item.node {\n+                ImplItemKind::Method(ref sig, _) => &sig.generics,\n+                _ => &no_generics\n+            }\n+        }\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let (is_trait, is_impl) = match tcx.hir.get(node_id) {\n-        hir::map::NodeItem(item) => {\n+        NodeItem(item) => {\n             match item.node {\n-                hir::ItemTrait(.., ref items) => {\n-                    (Some((ty::TraitRef {\n+                ItemFn(.., ref generics, _) |\n+                ItemImpl(_, _, ref generics, ..) |\n+                ItemTy(_, ref generics) |\n+                ItemEnum(_, ref generics) |\n+                ItemStruct(_, ref generics) |\n+                ItemUnion(_, ref generics) => {\n+                    generics\n+                }\n+\n+                ItemTrait(_, ref generics, .., ref items) => {\n+                    is_trait = Some((ty::TraitRef {\n                         def_id: def_id,\n                         substs: Substs::identity_for_item(tcx, def_id)\n-                    }, items)), None)\n-                }\n-                hir::ItemImpl(..) => {\n-                    let self_ty = type_of_def_id(tcx, def_id);\n-                    let trait_ref = tcx.impl_trait_ref(def_id);\n-                    (None, Some((self_ty, trait_ref)))\n+                    }, items));\n+                    generics\n                 }\n-                _ => (None, None)\n+\n+                _ => &no_generics\n             }\n         }\n-        _ => (None, None)\n+\n+        NodeForeignItem(item) => {\n+            match item.node {\n+                ForeignItemStatic(..) => &no_generics,\n+                ForeignItemFn(_, _, ref generics) => generics\n+            }\n+        }\n+\n+        NodeTy(&Ty { node: TyImplTrait(ref bounds), span, .. }) => {\n+            let substs = Substs::identity_for_item(tcx, def_id);\n+            let anon_ty = tcx.mk_anon(def_id, substs);\n+\n+            // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n+            let bounds = compute_bounds(&icx, anon_ty, bounds,\n+                                        SizedByDefault::Yes,\n+                                        span);\n+            return ty::GenericPredicates {\n+                parent: None,\n+                predicates: bounds.predicates(tcx, anon_ty)\n+            };\n+        }\n+\n+        _ => &no_generics\n     };\n \n+    let generics = tcx.item_generics(def_id);\n+    let parent_count = generics.parent_count() as u32;\n+    let has_own_self = generics.has_self && parent_count == 0;\n+\n+    let mut predicates = vec![];\n+\n     // Below we'll consider the bounds on the type parameters (including `Self`)\n     // and the explicit where-clauses, but to get the full set of predicates\n     // on a trait we need to add in the supertrait bounds and bounds found on\n@@ -1543,16 +1502,18 @@ fn ty_generic_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let Some((self_ty, trait_ref)) = is_impl {\n+    if let NodeItem(&Item { node: ItemImpl(..), .. }) = node {\n+        let self_ty = tcx.item_type(def_id);\n+        let trait_ref = tcx.impl_trait_ref(def_id);\n         ctp::setup_constraining_predicates(&mut predicates,\n                                            trait_ref,\n                                            &mut ctp::parameters_for_impl(self_ty, trait_ref));\n     }\n \n-    tcx.maps.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+    ty::GenericPredicates {\n         parent: generics.parent,\n         predicates: predicates\n-    });\n+    }\n }\n \n pub enum SizedByDefault { Yes, No, }"}, {"sha": "0f425baec10bbaf7b7df3bccc61cd9514f64da3f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -287,6 +287,7 @@ fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n pub fn provide(providers: &mut Providers) {\n     collect::provide(providers);\n+    check::provide(providers);\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)"}, {"sha": "096657a6e7ac82e0e213c586e03f5a71a1b97815", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -909,25 +909,12 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n \n #[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub enum ReprAttr {\n-    ReprAny,\n     ReprInt(IntType),\n     ReprExtern,\n     ReprPacked,\n     ReprSimd,\n }\n \n-impl ReprAttr {\n-    pub fn is_ffi_safe(&self) -> bool {\n-        match *self {\n-            ReprAny => false,\n-            ReprInt(ity) => ity.is_ffi_safe(),\n-            ReprExtern => true,\n-            ReprPacked => false,\n-            ReprSimd => true,\n-        }\n-    }\n-}\n-\n #[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n@@ -942,16 +929,6 @@ impl IntType {\n             UnsignedInt(..) => false\n         }\n     }\n-    fn is_ffi_safe(self) -> bool {\n-        match self {\n-            SignedInt(ast::IntTy::I8) | UnsignedInt(ast::UintTy::U8) |\n-            SignedInt(ast::IntTy::I16) | UnsignedInt(ast::UintTy::U16) |\n-            SignedInt(ast::IntTy::I32) | UnsignedInt(ast::UintTy::U32) |\n-            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) |\n-            SignedInt(ast::IntTy::I128) | UnsignedInt(ast::UintTy::U128) => true,\n-            SignedInt(ast::IntTy::Is) | UnsignedInt(ast::UintTy::Us) => false\n-        }\n-    }\n }\n \n pub trait HasAttrs: Sized {"}, {"sha": "fe492bd7fc849bbaa46cce06734570adefb8cfda", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -773,7 +773,7 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n             repr_type_name = match *r {\n-                attr::ReprAny | attr::ReprPacked | attr::ReprSimd => continue,\n+                attr::ReprPacked | attr::ReprSimd => continue,\n                 attr::ReprExtern => \"i32\",\n \n                 attr::ReprInt(attr::SignedInt(ast::IntTy::Is)) => \"isize\","}, {"sha": "e6caeb34a8c8f30fddd833c1140200f73f2ea113", "filename": "src/test/compile-fail/cycle-trait-default-type-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -13,7 +13,6 @@\n \n trait Foo<X = Box<Foo>> {\n     //~^ ERROR unsupported cyclic reference\n-    //~| ERROR unsupported cyclic reference\n }\n \n fn main() { }"}, {"sha": "13e53cab17226d385107b551928608cb95c56a1a", "filename": "src/test/compile-fail/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -52,23 +52,20 @@ fn after() -> impl Fn(i32) {\n // independently resolved and only require the concrete\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n+    //~^ ERROR unsupported cyclic reference between types/traits detected\n+    //~| cyclic reference\n+    //~| NOTE the cycle begins when processing `cycle1`...\n+    //~| NOTE ...which then requires processing `cycle1::{{impl-Trait}}`...\n+    //~| NOTE ...which then again requires processing `cycle1`, completing the cycle.\n     send(cycle2().clone());\n-    //~^ ERROR the trait bound `std::rc::Rc<std::string::String>: std::marker::Send` is not satisfied\n-    //~| NOTE the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::string::String>`\n-    //~| NOTE `std::rc::Rc<std::string::String>` cannot be sent between threads safely\n-    //~| NOTE required because it appears within the type `impl std::clone::Clone`\n-    //~| NOTE required by `send`\n \n     Rc::new(Cell::new(5))\n }\n \n fn cycle2() -> impl Clone {\n+    //~^ NOTE ...which then requires processing `cycle2::{{impl-Trait}}`...\n+    //~| NOTE ...which then requires processing `cycle2`...\n     send(cycle1().clone());\n-    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n-    //~| NOTE the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n-    //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n-    //~| NOTE required because it appears within the type `impl std::clone::Clone`\n-    //~| NOTE required by `send`\n \n     Rc::new(String::from(\"foo\"))\n }"}, {"sha": "36df4f0eb4d46f7cc25792807680fa6c622dd3cc", "filename": "src/test/compile-fail/impl-trait/equality.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -49,17 +49,6 @@ impl Leak for i32 {\n     fn leak(self) -> i32 { self }\n }\n \n-trait CheckIfSend: Sized {\n-    type T: Default;\n-    fn check(self) -> Self::T { Default::default() }\n-}\n-impl<T> CheckIfSend for T {\n-    default type T = ();\n-}\n-impl<T: Send> CheckIfSend for T {\n-    type T = bool;\n-}\n-\n fn main() {\n     let _: u32 = hide(0_u32);\n     //~^ ERROR mismatched types\n@@ -73,12 +62,6 @@ fn main() {\n     //~| found type `<impl Foo as Leak>::T`\n     //~| expected i32, found associated type\n \n-    let _: bool = CheckIfSend::check(hide(0_i32));\n-    //~^ ERROR mismatched types\n-    //~| expected type `bool`\n-    //~| found type `<impl Foo as CheckIfSend>::T`\n-    //~| expected bool, found associated type\n-\n     let mut x = (hide(0_u32), hide(0_i32));\n     x = (x.1,\n     //~^ ERROR mismatched types"}, {"sha": "710d8e11ff03420964d691d587428e81cc60a97f", "filename": "src/test/compile-fail/resolve-self-in-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -26,6 +26,6 @@ impl Tr for Self {} //~ ERROR unsupported cyclic reference between types/traits\n impl Tr for S<Self> {} //~ ERROR unsupported cyclic reference between types/traits detected\n impl Self {} //~ ERROR unsupported cyclic reference between types/traits detected\n impl S<Self> {} //~ ERROR unsupported cyclic reference between types/traits detected\n-impl Tr<Self::A> for S {} //~ ERROR `Self` type is used before it's determined\n+impl Tr<Self::A> for S {} //~ ERROR unsupported cyclic reference between types/traits detected\n \n fn main() {}"}, {"sha": "048ccb529a24fc9a516eaeea9667189c55c454fd", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -112,10 +112,13 @@ enum EnumChangeValueCStyleVariant0 {\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeValueCStyleVariant0 {\n     Variant1,\n+\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     Variant2 = 22,\n }\n "}, {"sha": "011d910c5a50f6c5721445c3ea92e3cb8a49e6be", "filename": "src/test/run-pass/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -29,16 +29,3 @@ fn after() -> impl FnMut(i32) {\n     let mut p = Box::new(0);\n     move |x| *p = x\n }\n-\n-// Cycles should work as the deferred obligations are\n-// independently resolved and only require the concrete\n-// return type, which can't depend on the obligation.\n-fn cycle1() -> impl Clone {\n-    send(cycle2().clone());\n-    5\n-}\n-\n-fn cycle2() -> impl Clone {\n-    send(cycle1().clone());\n-    String::from(\"foo\")\n-}"}, {"sha": "ceed454e5ad7e79698ccc8a3b6cf9fdb7b3825e2", "filename": "src/test/run-pass/impl-trait/equality.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11640179bbde334b525146d3a164999412cc73/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs?ref=ba11640179bbde334b525146d3a164999412cc73", "patch": "@@ -28,6 +28,17 @@ impl<T> Leak<T> for T {\n     fn leak(self) -> T { self }\n }\n \n+trait CheckIfSend: Sized {\n+    type T: Default;\n+    fn check(self) -> Self::T { Default::default() }\n+}\n+impl<T> CheckIfSend for T {\n+    default type T = ();\n+}\n+impl<T: Send> CheckIfSend for T {\n+    type T = bool;\n+}\n+\n fn lucky_seven() -> impl Fn(usize) -> u8 {\n     let a = [1, 2, 3, 4, 5, 6, 7];\n     move |i| a[i]\n@@ -40,4 +51,6 @@ fn main() {\n     assert_eq!(std::mem::size_of_val(&lucky_seven()), 7);\n \n     assert_eq!(Leak::<i32>::leak(hide(5_i32)), 5_i32);\n+\n+    assert_eq!(CheckIfSend::check(hide(0_i32)), false);\n }"}]}