{"sha": "c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2OGQ3MTBkNTI1Y2U0ZWY1NmYxZGU0YmEzMzllN2M3YjM5ZGRkNzc=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-22T19:09:40Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-03T18:36:11Z"}, "message": "Support backward dataflow analyses", "tree": {"sha": "8fe635a699e084e6314792b2d3579421a298cb88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fe635a699e084e6314792b2d3579421a298cb88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "html_url": "https://github.com/rust-lang/rust/commit/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "032be94d2367af4a82a4b4ff0da1ea75f2257f01", "url": "https://api.github.com/repos/rust-lang/rust/commits/032be94d2367af4a82a4b4ff0da1ea75f2257f01", "html_url": "https://github.com/rust-lang/rust/commit/032be94d2367af4a82a4b4ff0da1ea75f2257f01"}], "stats": {"total": 1755, "additions": 1094, "deletions": 661}, "files": [{"sha": "7d8a2b540a94470b2a4d3e31ae1cb71091e3da70", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -518,7 +518,7 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n     type FlowState = Flows<'cx, 'tcx>;\n \n-    fn visit_statement(\n+    fn visit_statement_before_primary_effect(\n         &mut self,\n         flow_state: &Flows<'cx, 'tcx>,\n         stmt: &'cx Statement<'tcx>,\n@@ -607,7 +607,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n         }\n     }\n \n-    fn visit_terminator(\n+    fn visit_terminator_before_primary_effect(\n         &mut self,\n         flow_state: &Flows<'cx, 'tcx>,\n         term: &'cx Terminator<'tcx>,\n@@ -701,7 +701,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n         }\n     }\n \n-    fn visit_terminator_exit(\n+    fn visit_terminator_after_primary_effect(\n         &mut self,\n         flow_state: &Flows<'cx, 'tcx>,\n         term: &'cx Terminator<'tcx>,"}, {"sha": "41c77cf21a76f9c8d5702168a2b5f2f204cb6586", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -408,7 +408,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     /// DROP of some local variable will have an effect -- note that\n     /// drops, as they may unwind, are always terminators.\n     fn initialized_at_terminator(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n-        self.flow_inits.seek_before(self.body.terminator_loc(block));\n+        self.flow_inits.seek_before_primary_effect(self.body.terminator_loc(block));\n         self.initialized_at_curr_loc(mpi)\n     }\n \n@@ -418,7 +418,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     /// **Warning:** Does not account for the result of `Call`\n     /// instructions.\n     fn initialized_at_exit(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n-        self.flow_inits.seek_after(self.body.terminator_loc(block));\n+        self.flow_inits.seek_after_primary_effect(self.body.terminator_loc(block));\n         self.initialized_at_curr_loc(mpi)\n     }\n "}, {"sha": "82c8f8575c0f1c8ce11dd121cf6e39382e4e3143", "filename": "src/librustc_mir/dataflow/framework/cursor.rs", "status": "modified", "additions": 115, "deletions": 189, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -1,21 +1,22 @@\n //! Random access inspection of the results of a dataflow analysis.\n \n use std::borrow::Borrow;\n+use std::cmp::Ordering;\n \n use rustc_index::bit_set::BitSet;\n-use rustc_middle::mir::{self, BasicBlock, Location, TerminatorKind};\n+use rustc_middle::mir::{self, BasicBlock, Location};\n \n-use super::{Analysis, Results};\n+use super::{Analysis, Direction, Effect, EffectIndex, Results};\n \n /// A `ResultsCursor` that borrows the underlying `Results`.\n pub type ResultsRefCursor<'a, 'mir, 'tcx, A> = ResultsCursor<'mir, 'tcx, A, &'a Results<'tcx, A>>;\n \n /// Allows random access inspection of the results of a dataflow analysis.\n ///\n /// This cursor only has linear performance within a basic block when its statements are visited in\n-/// order. In the worst case\u2014when statements are visited in *reverse* order\u2014performance will be\n-/// quadratic in the number of statements in the block. The order in which basic blocks are\n-/// inspected has no impact on performance.\n+/// the same order as the `DIRECTION` of the analysis. In the worst case\u2014when statements are\n+/// visited in *reverse* order\u2014performance will be quadratic in the number of statements in the\n+/// block. The order in which basic blocks are inspected has no impact on performance.\n ///\n /// A `ResultsCursor` can either own (the default) or borrow the dataflow results it inspects. The\n /// type of ownership is determined by `R` (see `ResultsRefCursor` above).\n@@ -29,32 +30,32 @@ where\n \n     pos: CursorPosition,\n \n-    /// When this flag is set, the cursor is pointing at a `Call` or `Yield` terminator whose call\n-    /// return or resume effect has been applied to `state`.\n+    /// Indicates that `state` has been modified with a custom effect.\n     ///\n-    /// This flag helps to ensure that multiple calls to `seek_after_assume_success` with the\n-    /// same target will result in exactly one invocation of `apply_call_return_effect`. It is\n-    /// sufficient to clear this only in `seek_to_block_start`, since seeking away from a\n-    /// terminator will always require a cursor reset.\n-    success_effect_applied: bool,\n+    /// When this flag is set, we need to reset to an entry set before doing a seek.\n+    state_needs_reset: bool,\n }\n \n impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n where\n     A: Analysis<'tcx>,\n     R: Borrow<Results<'tcx, A>>,\n {\n-    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n+    /// Returns a new cursor for `results` that points to the entry of the `START_BLOCK`.\n     pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n         ResultsCursor {\n             body,\n-            pos: CursorPosition::BlockStart(mir::START_BLOCK),\n-            state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n-            success_effect_applied: false,\n+            pos: CursorPosition::block_entry(mir::START_BLOCK),\n+            state: results.borrow().entry_set_for_block(mir::START_BLOCK).clone(),\n+            state_needs_reset: false,\n             results,\n         }\n     }\n \n+    pub fn body(&self) -> &'mir mir::Body<'tcx> {\n+        self.body\n+    }\n+\n     /// Returns the `Analysis` used to generate the underlying results.\n     pub fn analysis(&self) -> &A {\n         &self.results.borrow().analysis\n@@ -72,209 +73,134 @@ where\n         self.state.contains(elem)\n     }\n \n-    /// Resets the cursor to the start of the given basic block.\n-    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n-        self.state.overwrite(&self.results.borrow().entry_sets[block]);\n-        self.pos = CursorPosition::BlockStart(block);\n-        self.success_effect_applied = false;\n-    }\n-\n-    /// Advances the cursor to hold all effects up to and including to the \"before\" effect of the\n-    /// statement (or terminator) at the given location.\n+    /// Resets the cursor to hold the dataflow state for the given basic block at fixpoint.\n     ///\n-    /// If you wish to observe the full effect of a statement or terminator, not just the \"before\"\n-    /// effect, use `seek_after` or `seek_after_assume_success`.\n-    pub fn seek_before(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-        self.seek_(target, false);\n+    /// For forward dataflow analyses, this is the dataflow state prior to the first statement.\n+    ///\n+    /// For backward dataflow analyses, this is the dataflow state after the terminator.\n+    pub(super) fn seek_to_block_entry(&mut self, block: BasicBlock) {\n+        self.state.overwrite(&self.results.borrow().entry_set_for_block(block));\n+        self.pos = CursorPosition::block_entry(block);\n+        self.state_needs_reset = false;\n     }\n \n-    /// Advances the cursor to hold the full effect of all statements (and possibly closing\n-    /// terminators) up to and including the `target`.\n+    /// Resets the cursor to hold the state at the entry to the given block.\n     ///\n-    /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n-    /// **not** be observed. Use `seek_after_assume_success` if you wish to observe the call\n-    /// return effect.\n-    pub fn seek_after(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-\n-        // If we have already applied the call return effect, we are currently pointing at a `Call`\n-        // terminator. Unconditionally reset the dataflow cursor, since there is no way to \"undo\"\n-        // the call return effect.\n-        if self.success_effect_applied {\n-            self.seek_to_block_start(target.block);\n+    /// For forward analyses, this is the block's state at fixpoint.\n+    ///\n+    /// For backward analyses, this is the state that will be propagated to its\n+    /// predecessors (ignoring edge-specific effects).\n+    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n+        if A::Direction::is_forward() {\n+            self.seek_to_block_entry(block)\n+        } else {\n+            self.seek_after(Location { block, statement_index: 0 }, Effect::Primary)\n         }\n-\n-        self.seek_(target, true);\n     }\n \n-    /// Advances the cursor to hold all effects up to and including of the statement (or\n-    /// terminator) at the given location.\n+    /// Resets the cursor to hold the state at the exit of the given block.\n     ///\n-    /// If the `target` is a `Call` or `Yield` terminator, any call return or resume effect for that\n-    /// terminator will be observed. Use `seek_after` if you do **not** wish to observe the\n-    /// \"success\" effect.\n-    pub fn seek_after_assume_success(&mut self, target: Location) {\n-        let terminator_loc = self.body.terminator_loc(target.block);\n-        assert!(target.statement_index <= terminator_loc.statement_index);\n-\n-        self.seek_(target, true);\n-\n-        if target != terminator_loc || self.success_effect_applied {\n-            return;\n-        }\n-\n-        // Apply the effect of the \"success\" path of the terminator.\n-\n-        self.success_effect_applied = true;\n-        let terminator = self.body.basic_blocks()[target.block].terminator();\n-        match &terminator.kind {\n-            TerminatorKind::Call { destination: Some((return_place, _)), func, args, .. } => {\n-                self.results.borrow().analysis.apply_call_return_effect(\n-                    &mut self.state,\n-                    target.block,\n-                    func,\n-                    args,\n-                    *return_place,\n-                );\n-            }\n-            TerminatorKind::Yield { resume, resume_arg, .. } => {\n-                self.results.borrow().analysis.apply_yield_resume_effect(\n-                    &mut self.state,\n-                    *resume,\n-                    *resume_arg,\n-                );\n-            }\n-            _ => {}\n+    /// For backward analyses, this is the block's state at fixpoint.\n+    ///\n+    /// For forward analyses, this is the state that will be propagated to its\n+    /// successors (ignoring edge-specific effects).\n+    pub fn seek_to_block_end(&mut self, block: BasicBlock) {\n+        if A::Direction::is_backward() {\n+            self.seek_to_block_entry(block)\n+        } else {\n+            self.seek_after(self.body.terminator_loc(block), Effect::Primary)\n         }\n     }\n \n-    fn seek_(&mut self, target: Location, apply_after_effect_at_target: bool) {\n-        use CursorPosition::*;\n-\n-        match self.pos {\n-            // Return early if we are already at the target location.\n-            Before(curr) if curr == target && !apply_after_effect_at_target => return,\n-            After(curr) if curr == target && apply_after_effect_at_target => return,\n+    /// Advances the cursor to hold the dataflow state at `target` before its \"primary\" effect is\n+    /// applied.\n+    ///\n+    /// The \"before\" effect at the target location *will be* applied.\n+    pub fn seek_before_primary_effect(&mut self, target: Location) {\n+        self.seek_after(target, Effect::Before)\n+    }\n \n-            // Otherwise, we must reset to the start of the target block if...\n+    /// Advances the cursor to hold the dataflow state at `target` after its \"primary\" effect is\n+    /// applied.\n+    ///\n+    /// The \"before\" effect at the target location will be applied as well.\n+    pub fn seek_after_primary_effect(&mut self, target: Location) {\n+        self.seek_after(target, Effect::Primary)\n+    }\n \n-            // we are in a different block entirely.\n-            BlockStart(block) | Before(Location { block, .. }) | After(Location { block, .. })\n-                if block != target.block =>\n-            {\n-                self.seek_to_block_start(target.block)\n-            }\n+    fn seek_after(&mut self, target: Location, effect: Effect) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n \n-            // we are in the same block but have advanced past the target statement.\n-            Before(curr) | After(curr) if curr.statement_index > target.statement_index => {\n-                self.seek_to_block_start(target.block)\n+        // Reset to the entry of the target block if any of the following are true:\n+        //   - A custom effect has been applied to the cursor state.\n+        //   - We are in a different block than the target.\n+        //   - We are in the same block but have advanced past the target effect.\n+        if self.state_needs_reset || self.pos.block != target.block {\n+            self.seek_to_block_entry(target.block);\n+        } else if let Some(curr_effect) = self.pos.curr_effect_index {\n+            let mut ord = curr_effect.statement_index.cmp(&target.statement_index);\n+            if A::Direction::is_backward() {\n+                ord = ord.reverse()\n             }\n \n-            // we have already applied the entire effect of a statement but only wish to observe\n-            // its \"before\" effect.\n-            After(curr)\n-                if curr.statement_index == target.statement_index\n-                    && !apply_after_effect_at_target =>\n-            {\n-                self.seek_to_block_start(target.block)\n+            match ord.then_with(|| curr_effect.effect.cmp(&effect)) {\n+                Ordering::Equal => return,\n+                Ordering::Greater => self.seek_to_block_entry(target.block),\n+                Ordering::Less => {}\n             }\n-\n-            // N.B., `success_effect_applied` is checked in `seek_after`, not here.\n-            _ => (),\n         }\n \n-        let analysis = &self.results.borrow().analysis;\n-        let block_data = &self.body.basic_blocks()[target.block];\n-\n         // At this point, the cursor is in the same block as the target location at an earlier\n         // statement.\n-        debug_assert_eq!(target.block, self.pos.block());\n-\n-        // Find the first statement whose transfer function has not yet been applied.\n-        let first_unapplied_statement = match self.pos {\n-            BlockStart(_) => 0,\n-            After(Location { statement_index, .. }) => statement_index + 1,\n-\n-            // If we have only applied the \"before\" effect for the current statement, apply the\n-            // remainder before continuing.\n-            Before(curr) => {\n-                if curr.statement_index == block_data.statements.len() {\n-                    let terminator = block_data.terminator();\n-                    analysis.apply_terminator_effect(&mut self.state, terminator, curr);\n-                } else {\n-                    let statement = &block_data.statements[curr.statement_index];\n-                    analysis.apply_statement_effect(&mut self.state, statement, curr);\n-                }\n-\n-                // If all we needed to do was go from `Before` to `After` in the same statement,\n-                // we are now done.\n-                if curr.statement_index == target.statement_index {\n-                    debug_assert!(apply_after_effect_at_target);\n-                    self.pos = After(target);\n-                    return;\n-                }\n-\n-                curr.statement_index + 1\n-            }\n+        debug_assert_eq!(target.block, self.pos.block);\n+\n+        let block_data = &self.body[target.block];\n+        let next_effect = if A::Direction::is_forward() {\n+            #[rustfmt::skip]\n+            self.pos.curr_effect_index.map_or_else(\n+                || Effect::Before.at_index(0),\n+                EffectIndex::next_in_forward_order,\n+            )\n+        } else {\n+            self.pos.curr_effect_index.map_or_else(\n+                || Effect::Before.at_index(block_data.statements.len()),\n+                EffectIndex::next_in_backward_order,\n+            )\n         };\n \n-        // We have now applied all effects prior to `first_unapplied_statement`.\n-\n-        // Apply the effects of all statements before `target`.\n-        let mut location = Location { block: target.block, statement_index: 0 };\n-        for statement_index in first_unapplied_statement..target.statement_index {\n-            location.statement_index = statement_index;\n-            let statement = &block_data.statements[statement_index];\n-            analysis.apply_before_statement_effect(&mut self.state, statement, location);\n-            analysis.apply_statement_effect(&mut self.state, statement, location);\n-        }\n-\n-        // Apply the effect of the statement (or terminator) at `target`.\n-        location.statement_index = target.statement_index;\n-        if target.statement_index == block_data.statements.len() {\n-            let terminator = &block_data.terminator();\n-            analysis.apply_before_terminator_effect(&mut self.state, terminator, location);\n-\n-            if apply_after_effect_at_target {\n-                analysis.apply_terminator_effect(&mut self.state, terminator, location);\n-                self.pos = After(target);\n-            } else {\n-                self.pos = Before(target);\n-            }\n-        } else {\n-            let statement = &block_data.statements[target.statement_index];\n-            analysis.apply_before_statement_effect(&mut self.state, statement, location);\n+        let analysis = &self.results.borrow().analysis;\n+        let target_effect_index = effect.at_index(target.statement_index);\n+\n+        A::Direction::apply_effects_in_range(\n+            analysis,\n+            &mut self.state,\n+            target.block,\n+            block_data,\n+            next_effect..=target_effect_index,\n+        );\n+\n+        self.pos =\n+            CursorPosition { block: target.block, curr_effect_index: Some(target_effect_index) };\n+    }\n \n-            if apply_after_effect_at_target {\n-                analysis.apply_statement_effect(&mut self.state, statement, location);\n-                self.pos = After(target)\n-            } else {\n-                self.pos = Before(target);\n-            }\n-        }\n+    /// Applies `f` to the cursor's internal state.\n+    ///\n+    /// This can be used, e.g., to apply the call return effect directly to the cursor without\n+    /// creating an extra copy of the dataflow state.\n+    pub fn apply_custom_effect(&mut self, f: impl FnOnce(&A, &mut BitSet<A::Idx>)) {\n+        f(&self.results.borrow().analysis, &mut self.state);\n+        self.state_needs_reset = true;\n     }\n }\n \n #[derive(Clone, Copy, Debug)]\n-enum CursorPosition {\n-    /// No effects within this block have been applied.\n-    BlockStart(BasicBlock),\n-\n-    /// Only the \"before\" effect of the statement (or terminator) at this location has been\n-    /// applied (along with the effects of all previous statements).\n-    Before(Location),\n-\n-    /// The effects of all statements up to and including the one at this location have been\n-    /// applied.\n-    After(Location),\n+struct CursorPosition {\n+    block: BasicBlock,\n+    curr_effect_index: Option<EffectIndex>,\n }\n \n impl CursorPosition {\n-    fn block(&self) -> BasicBlock {\n-        match *self {\n-            Self::BlockStart(block) => block,\n-            Self::Before(loc) | Self::After(loc) => loc.block,\n-        }\n+    fn block_entry(block: BasicBlock) -> CursorPosition {\n+        CursorPosition { block, curr_effect_index: None }\n     }\n }"}, {"sha": "76f703ec9136fd20a636587374f0ac860eedcd55", "filename": "src/librustc_mir/dataflow/framework/direction.rs", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -0,0 +1,570 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::{self, BasicBlock, Location};\n+use rustc_middle::ty::{self, TyCtxt};\n+use std::ops::RangeInclusive;\n+\n+use super::visitor::{ResultsVisitable, ResultsVisitor};\n+use super::{Analysis, Effect, EffectIndex, GenKillAnalysis, GenKillSet};\n+\n+pub trait Direction {\n+    fn is_forward() -> bool;\n+\n+    fn is_backward() -> bool {\n+        !Self::is_forward()\n+    }\n+\n+    /// Applies all effects between the given `EffectIndex`s.\n+    ///\n+    /// `effects.start()` must precede or equal `effects.end()` in this direction.\n+    fn apply_effects_in_range<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        effects: RangeInclusive<EffectIndex>,\n+    ) where\n+        A: Analysis<'tcx>;\n+\n+    fn apply_effects_in_block<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: Analysis<'tcx>;\n+\n+    fn gen_kill_effects_in_block<A>(\n+        analysis: &A,\n+        trans: &mut GenKillSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: GenKillAnalysis<'tcx>;\n+\n+    fn visit_results_in_block<F, R>(\n+        state: &mut F,\n+        block: BasicBlock,\n+        block_data: &'mir mir::BasicBlockData<'tcx>,\n+        results: &R,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n+    ) where\n+        R: ResultsVisitable<'tcx, FlowState = F>;\n+\n+    fn join_state_into_successors_of<A>(\n+        analysis: &A,\n+        tcx: TyCtxt<'tcx>,\n+        body: &mir::Body<'tcx>,\n+        dead_unwinds: Option<&BitSet<BasicBlock>>,\n+        exit_state: &mut BitSet<A::Idx>,\n+        block: (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n+        propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+    ) where\n+        A: Analysis<'tcx>;\n+}\n+\n+/// Dataflow that runs from the exit of a block (the terminator), to its entry (the first statement).\n+pub struct Backward;\n+\n+impl Direction for Backward {\n+    fn is_forward() -> bool {\n+        false\n+    }\n+\n+    fn apply_effects_in_block<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        analysis.apply_before_terminator_effect(state, terminator, location);\n+        analysis.apply_terminator_effect(state, terminator, location);\n+\n+        for (statement_index, statement) in block_data.statements.iter().enumerate().rev() {\n+            let location = Location { block, statement_index };\n+            analysis.apply_before_statement_effect(state, statement, location);\n+            analysis.apply_statement_effect(state, statement, location);\n+        }\n+    }\n+\n+    fn gen_kill_effects_in_block<A>(\n+        analysis: &A,\n+        trans: &mut GenKillSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: GenKillAnalysis<'tcx>,\n+    {\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        analysis.before_terminator_effect(trans, terminator, location);\n+        analysis.terminator_effect(trans, terminator, location);\n+\n+        for (statement_index, statement) in block_data.statements.iter().enumerate().rev() {\n+            let location = Location { block, statement_index };\n+            analysis.before_statement_effect(trans, statement, location);\n+            analysis.statement_effect(trans, statement, location);\n+        }\n+    }\n+\n+    fn apply_effects_in_range<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        effects: RangeInclusive<EffectIndex>,\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        let (from, to) = (*effects.start(), *effects.end());\n+        let terminator_index = block_data.statements.len();\n+\n+        assert!(from.statement_index <= terminator_index);\n+        assert!(!to.precedes_in_backward_order(from));\n+\n+        // Handle the statement (or terminator) at `from`.\n+\n+        let next_effect = match from.effect {\n+            // If we need to apply the terminator effect in all or in part, do so now.\n+            _ if from.statement_index == terminator_index => {\n+                let location = Location { block, statement_index: from.statement_index };\n+                let terminator = block_data.terminator();\n+\n+                if from.effect == Effect::Before {\n+                    analysis.apply_before_terminator_effect(state, terminator, location);\n+                    if to == Effect::Before.at_index(terminator_index) {\n+                        return;\n+                    }\n+                }\n+\n+                analysis.apply_terminator_effect(state, terminator, location);\n+                if to == Effect::Primary.at_index(terminator_index) {\n+                    return;\n+                }\n+\n+                // If `from.statement_index` is `0`, we will have hit one of the earlier comparisons\n+                // with `to`.\n+                from.statement_index - 1\n+            }\n+\n+            Effect::Primary => {\n+                let location = Location { block, statement_index: from.statement_index };\n+                let statement = &block_data.statements[from.statement_index];\n+\n+                analysis.apply_statement_effect(state, statement, location);\n+                if to == Effect::Primary.at_index(from.statement_index) {\n+                    return;\n+                }\n+\n+                from.statement_index - 1\n+            }\n+\n+            Effect::Before => from.statement_index,\n+        };\n+\n+        // Handle all statements between `first_unapplied_idx` and `to.statement_index`.\n+\n+        for statement_index in (to.statement_index..next_effect).rev().map(|i| i + 1) {\n+            let location = Location { block, statement_index };\n+            let statement = &block_data.statements[statement_index];\n+            analysis.apply_before_statement_effect(state, statement, location);\n+            analysis.apply_statement_effect(state, statement, location);\n+        }\n+\n+        // Handle the statement at `to`.\n+\n+        let location = Location { block, statement_index: to.statement_index };\n+        let statement = &block_data.statements[to.statement_index];\n+        analysis.apply_before_statement_effect(state, statement, location);\n+\n+        if to.effect == Effect::Before {\n+            return;\n+        }\n+\n+        analysis.apply_statement_effect(state, statement, location);\n+    }\n+\n+    fn visit_results_in_block<F, R>(\n+        state: &mut F,\n+        block: BasicBlock,\n+        block_data: &'mir mir::BasicBlockData<'tcx>,\n+        results: &R,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n+    ) where\n+        R: ResultsVisitable<'tcx, FlowState = F>,\n+    {\n+        results.reset_to_block_entry(state, block);\n+\n+        vis.visit_block_end(&state, block_data, block);\n+\n+        // Terminator\n+        let loc = Location { block, statement_index: block_data.statements.len() };\n+        let term = block_data.terminator();\n+        results.reconstruct_before_terminator_effect(state, term, loc);\n+        vis.visit_terminator_before_primary_effect(state, term, loc);\n+        results.reconstruct_terminator_effect(state, term, loc);\n+        vis.visit_terminator_after_primary_effect(state, term, loc);\n+\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate().rev() {\n+            let loc = Location { block, statement_index };\n+            results.reconstruct_before_statement_effect(state, stmt, loc);\n+            vis.visit_statement_before_primary_effect(state, stmt, loc);\n+            results.reconstruct_statement_effect(state, stmt, loc);\n+            vis.visit_statement_after_primary_effect(state, stmt, loc);\n+        }\n+\n+        vis.visit_block_start(state, block_data, block);\n+    }\n+\n+    fn join_state_into_successors_of<A>(\n+        analysis: &A,\n+        _tcx: TyCtxt<'tcx>,\n+        body: &mir::Body<'tcx>,\n+        dead_unwinds: Option<&BitSet<BasicBlock>>,\n+        exit_state: &mut BitSet<A::Idx>,\n+        (bb, _bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n+        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        for pred in body.predecessors()[bb].iter().copied() {\n+            match body[pred].terminator().kind {\n+                // Apply terminator-specific edge effects.\n+                //\n+                // FIXME(ecstaticmorse): Avoid cloning the exit state unconditionally.\n+                mir::TerminatorKind::Call {\n+                    destination: Some((return_place, dest)),\n+                    ref func,\n+                    ref args,\n+                    ..\n+                } if dest == bb => {\n+                    let mut tmp = exit_state.clone();\n+                    analysis.apply_call_return_effect(&mut tmp, pred, func, args, return_place);\n+                    propagate(pred, &tmp);\n+                }\n+\n+                mir::TerminatorKind::Yield { resume, resume_arg, .. } if resume == bb => {\n+                    let mut tmp = exit_state.clone();\n+                    analysis.apply_yield_resume_effect(&mut tmp, resume, resume_arg);\n+                    propagate(pred, &tmp);\n+                }\n+\n+                // Ignore dead unwinds.\n+                mir::TerminatorKind::Call { cleanup: Some(unwind), .. }\n+                | mir::TerminatorKind::Assert { cleanup: Some(unwind), .. }\n+                | mir::TerminatorKind::Drop { unwind: Some(unwind), .. }\n+                | mir::TerminatorKind::DropAndReplace { unwind: Some(unwind), .. }\n+                | mir::TerminatorKind::FalseUnwind { unwind: Some(unwind), .. }\n+                    if unwind == bb =>\n+                {\n+                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n+                        propagate(pred, exit_state);\n+                    }\n+                }\n+\n+                _ => propagate(pred, exit_state),\n+            }\n+        }\n+    }\n+}\n+\n+/// Dataflow that runs from the entry of a block (the first statement), to its exit (terminator).\n+pub struct Forward;\n+\n+impl Direction for Forward {\n+    fn is_forward() -> bool {\n+        true\n+    }\n+\n+    fn apply_effects_in_block<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        for (statement_index, statement) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            analysis.apply_before_statement_effect(state, statement, location);\n+            analysis.apply_statement_effect(state, statement, location);\n+        }\n+\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        analysis.apply_before_terminator_effect(state, terminator, location);\n+        analysis.apply_terminator_effect(state, terminator, location);\n+    }\n+\n+    fn gen_kill_effects_in_block<A>(\n+        analysis: &A,\n+        trans: &mut GenKillSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: GenKillAnalysis<'tcx>,\n+    {\n+        for (statement_index, statement) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            analysis.before_statement_effect(trans, statement, location);\n+            analysis.statement_effect(trans, statement, location);\n+        }\n+\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        analysis.before_terminator_effect(trans, terminator, location);\n+        analysis.terminator_effect(trans, terminator, location);\n+    }\n+\n+    fn apply_effects_in_range<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        effects: RangeInclusive<EffectIndex>,\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        let (from, to) = (*effects.start(), *effects.end());\n+        let terminator_index = block_data.statements.len();\n+\n+        assert!(to.statement_index <= terminator_index);\n+        assert!(!to.precedes_in_forward_order(from));\n+\n+        // If we have applied the before affect of the statement or terminator at `from` but not its\n+        // after effect, do so now and start the loop below from the next statement.\n+\n+        let first_unapplied_index = match from.effect {\n+            Effect::Before => from.statement_index,\n+\n+            Effect::Primary if from.statement_index == terminator_index => {\n+                debug_assert_eq!(from, to);\n+\n+                let location = Location { block, statement_index: terminator_index };\n+                let terminator = block_data.terminator();\n+                analysis.apply_terminator_effect(state, terminator, location);\n+                return;\n+            }\n+\n+            Effect::Primary => {\n+                let location = Location { block, statement_index: from.statement_index };\n+                let statement = &block_data.statements[from.statement_index];\n+                analysis.apply_statement_effect(state, statement, location);\n+\n+                // If we only needed to apply the after effect of the statement at `idx`, we are done.\n+                if from == to {\n+                    return;\n+                }\n+\n+                from.statement_index + 1\n+            }\n+        };\n+\n+        // Handle all statements between `from` and `to` whose effects must be applied in full.\n+\n+        for statement_index in first_unapplied_index..to.statement_index {\n+            let location = Location { block, statement_index };\n+            let statement = &block_data.statements[statement_index];\n+            analysis.apply_before_statement_effect(state, statement, location);\n+            analysis.apply_statement_effect(state, statement, location);\n+        }\n+\n+        // Handle the statement or terminator at `to`.\n+\n+        let location = Location { block, statement_index: to.statement_index };\n+        if to.statement_index == terminator_index {\n+            let terminator = block_data.terminator();\n+            analysis.apply_before_terminator_effect(state, terminator, location);\n+\n+            if to.effect == Effect::Primary {\n+                analysis.apply_terminator_effect(state, terminator, location);\n+            }\n+        } else {\n+            let statement = &block_data.statements[to.statement_index];\n+            analysis.apply_before_statement_effect(state, statement, location);\n+\n+            if to.effect == Effect::Primary {\n+                analysis.apply_statement_effect(state, statement, location);\n+            }\n+        }\n+    }\n+\n+    fn visit_results_in_block<F, R>(\n+        state: &mut F,\n+        block: BasicBlock,\n+        block_data: &'mir mir::BasicBlockData<'tcx>,\n+        results: &R,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n+    ) where\n+        R: ResultsVisitable<'tcx, FlowState = F>,\n+    {\n+        results.reset_to_block_entry(state, block);\n+\n+        vis.visit_block_start(state, block_data, block);\n+\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n+            let loc = Location { block, statement_index };\n+            results.reconstruct_before_statement_effect(state, stmt, loc);\n+            vis.visit_statement_before_primary_effect(state, stmt, loc);\n+            results.reconstruct_statement_effect(state, stmt, loc);\n+            vis.visit_statement_after_primary_effect(state, stmt, loc);\n+        }\n+\n+        let loc = Location { block, statement_index: block_data.statements.len() };\n+        let term = block_data.terminator();\n+        results.reconstruct_before_terminator_effect(state, term, loc);\n+        vis.visit_terminator_before_primary_effect(state, term, loc);\n+        results.reconstruct_terminator_effect(state, term, loc);\n+        vis.visit_terminator_after_primary_effect(state, term, loc);\n+\n+        vis.visit_block_end(state, block_data, block);\n+    }\n+\n+    fn join_state_into_successors_of<A>(\n+        analysis: &A,\n+        tcx: TyCtxt<'tcx>,\n+        body: &mir::Body<'tcx>,\n+        dead_unwinds: Option<&BitSet<BasicBlock>>,\n+        exit_state: &mut BitSet<A::Idx>,\n+        (bb, bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n+        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        use mir::TerminatorKind::*;\n+        match bb_data.terminator().kind {\n+            Return | Resume | Abort | GeneratorDrop | Unreachable => {}\n+\n+            Goto { target } => propagate(target, exit_state),\n+\n+            Assert { target, cleanup: unwind, expected: _, msg: _, cond: _ }\n+            | Drop { target, unwind, location: _ }\n+            | DropAndReplace { target, unwind, value: _, location: _ }\n+            | FalseUnwind { real_target: target, unwind } => {\n+                if let Some(unwind) = unwind {\n+                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n+                        propagate(unwind, exit_state);\n+                    }\n+                }\n+\n+                propagate(target, exit_state);\n+            }\n+\n+            FalseEdges { real_target, imaginary_target } => {\n+                propagate(real_target, exit_state);\n+                propagate(imaginary_target, exit_state);\n+            }\n+\n+            Yield { resume: target, drop, resume_arg, value: _ } => {\n+                if let Some(drop) = drop {\n+                    propagate(drop, exit_state);\n+                }\n+\n+                analysis.apply_yield_resume_effect(exit_state, target, resume_arg);\n+                propagate(target, exit_state);\n+            }\n+\n+            Call { cleanup, destination, ref func, ref args, from_hir_call: _ } => {\n+                if let Some(unwind) = cleanup {\n+                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n+                        propagate(unwind, exit_state);\n+                    }\n+                }\n+\n+                if let Some((dest_place, target)) = destination {\n+                    // N.B.: This must be done *last*, otherwise the unwind path will see the call\n+                    // return effect.\n+                    analysis.apply_call_return_effect(exit_state, bb, func, args, dest_place);\n+                    propagate(target, exit_state);\n+                }\n+            }\n+\n+            SwitchInt { ref targets, ref values, ref discr, switch_ty: _ } => {\n+                let enum_ = discr\n+                    .place()\n+                    .and_then(|discr| switch_on_enum_discriminant(tcx, &body, bb_data, discr));\n+                match enum_ {\n+                    // If this is a switch on an enum discriminant, a custom effect may be applied\n+                    // along each outgoing edge.\n+                    Some((enum_place, enum_def)) => {\n+                        // MIR building adds discriminants to the `values` array in the same order as they\n+                        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+                        // discriminant in `values` to its corresponding variant in linear time.\n+                        let mut tmp = BitSet::new_empty(exit_state.domain_size());\n+                        let mut discriminants = enum_def.discriminants(tcx);\n+                        for (value, target) in values.iter().zip(targets.iter().copied()) {\n+                            let (variant_idx, _) =\n+                                discriminants.find(|&(_, discr)| discr.val == *value).expect(\n+                                    \"Order of `AdtDef::discriminants` differed \\\n+                                         from that of `SwitchInt::values`\",\n+                                );\n+\n+                            tmp.overwrite(exit_state);\n+                            analysis.apply_discriminant_switch_effect(\n+                                &mut tmp,\n+                                bb,\n+                                enum_place,\n+                                enum_def,\n+                                variant_idx,\n+                            );\n+                            propagate(target, &tmp);\n+                        }\n+\n+                        // Move out of `tmp` so we don't accidentally use it below.\n+                        std::mem::drop(tmp);\n+\n+                        // Propagate dataflow state along the \"otherwise\" edge.\n+                        let otherwise = targets.last().copied().unwrap();\n+                        propagate(otherwise, exit_state)\n+                    }\n+\n+                    // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n+                    // exit state.\n+                    None => {\n+                        for target in targets.iter().copied() {\n+                            propagate(target, exit_state);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n+/// an enum discriminant.\n+///\n+/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n+///   _42 = discriminant(_1)\n+///   SwitchInt(_42, ..)\n+///\n+/// If the basic block matches this pattern, this function returns the place corresponding to the\n+/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n+fn switch_on_enum_discriminant(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n+    block: &'mir mir::BasicBlockData<'tcx>,\n+    switch_on: mir::Place<'tcx>,\n+) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n+    match block.statements.last().map(|stmt| &stmt.kind) {\n+        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n+            if *lhs == switch_on =>\n+        {\n+            match &discriminated.ty(body, tcx).ty.kind {\n+                ty::Adt(def, _) => Some((*discriminated, def)),\n+\n+                // `Rvalue::Discriminant` is also used to get the active yield point for a\n+                // generator, but we do not need edge-specific effects in that case. This may\n+                // change in the future.\n+                ty::Generator(..) => None,\n+\n+                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n+            }\n+        }\n+\n+        _ => None,\n+    }\n+}"}, {"sha": "32e569fdc3589f9b754dd319827a7bfa84ea4979", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 102, "deletions": 236, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -9,14 +9,58 @@ use rustc_data_structures::work_queue::WorkQueue;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::{self, traversal, BasicBlock, Location};\n+use rustc_middle::mir::{self, traversal, BasicBlock};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n use super::graphviz;\n-use super::{Analysis, GenKillAnalysis, GenKillSet, Results};\n+use super::{\n+    visit_results, Analysis, Direction, GenKillAnalysis, GenKillSet, ResultsCursor, ResultsVisitor,\n+};\n use crate::util::pretty::dump_enabled;\n \n+/// A dataflow analysis that has converged to fixpoint.\n+pub struct Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub analysis: A,\n+    pub(super) entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+impl<A> Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// Creates a `ResultsCursor` that can inspect these `Results`.\n+    pub fn into_results_cursor(self, body: &'mir mir::Body<'tcx>) -> ResultsCursor<'mir, 'tcx, A> {\n+        ResultsCursor::new(body, self)\n+    }\n+\n+    /// Gets the dataflow state for the given block.\n+    pub fn entry_set_for_block(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n+        &self.entry_sets[block]\n+    }\n+\n+    pub fn visit_with(\n+        &self,\n+        body: &'mir mir::Body<'tcx>,\n+        blocks: impl IntoIterator<Item = BasicBlock>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+    ) {\n+        visit_results(body, blocks, self, vis)\n+    }\n+\n+    pub fn visit_in_rpo_with(\n+        &self,\n+        body: &'mir mir::Body<'tcx>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+    ) {\n+        let blocks = mir::traversal::reverse_postorder(body);\n+        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n+    }\n+}\n+\n /// A solver for dataflow problems.\n pub struct Engine<'a, 'tcx, A>\n where\n@@ -61,17 +105,7 @@ where\n \n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n             let trans = &mut trans_for_block[block];\n-\n-            for (i, statement) in block_data.statements.iter().enumerate() {\n-                let loc = Location { block, statement_index: i };\n-                analysis.before_statement_effect(trans, statement, loc);\n-                analysis.statement_effect(trans, statement, loc);\n-            }\n-\n-            let terminator = block_data.terminator();\n-            let loc = Location { block, statement_index: block_data.statements.len() };\n-            analysis.before_terminator_effect(trans, terminator, loc);\n-            analysis.terminator_effect(trans, terminator, loc);\n+            A::Direction::gen_kill_effects_in_block(&analysis, trans, block, block_data);\n         }\n \n         Self::new(tcx, body, def_id, analysis, Some(trans_for_block))\n@@ -111,9 +145,13 @@ where\n             BitSet::new_empty(bits_per_block)\n         };\n \n-        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n+        let mut entry_sets = IndexVec::from_elem(bottom_value_set.clone(), body.basic_blocks());\n         analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n \n+        if A::Direction::is_backward() && entry_sets[mir::START_BLOCK] != bottom_value_set {\n+            bug!(\"`initialize_start_block` is not yet supported for backward dataflow analyses\");\n+        }\n+\n         Engine {\n             analysis,\n             bits_per_block,\n@@ -137,251 +175,79 @@ where\n     }\n \n     /// Computes the fixpoint for this dataflow problem and returns it.\n-    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n-        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n+    pub fn iterate_to_fixpoint(self) -> Results<'tcx, A> {\n+        let Engine {\n+            analysis,\n+            bits_per_block,\n+            body,\n+            dead_unwinds,\n+            def_id,\n+            mut entry_sets,\n+            tcx,\n+            trans_for_block,\n+            ..\n+        } = self;\n \n         let mut dirty_queue: WorkQueue<BasicBlock> =\n-            WorkQueue::with_none(self.body.basic_blocks().len());\n+            WorkQueue::with_none(body.basic_blocks().len());\n \n-        for (bb, _) in traversal::reverse_postorder(self.body) {\n-            dirty_queue.insert(bb);\n+        if A::Direction::is_forward() {\n+            for (bb, _) in traversal::reverse_postorder(body) {\n+                dirty_queue.insert(bb);\n+            }\n+        } else {\n+            // Reverse post-order on the reverse CFG may generate a better iteration order for\n+            // backward dataflow analyses, but probably not enough to matter.\n+            for (bb, _) in traversal::postorder(body) {\n+                dirty_queue.insert(bb);\n+            }\n         }\n \n         // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n         // be processed after the ones added above.\n-        for bb in self.body.basic_blocks().indices() {\n+        //\n+        // FIXME(ecstaticmorse): Is this actually necessary? In principle, we shouldn't need to\n+        // know the dataflow state in unreachable basic blocks.\n+        for bb in body.basic_blocks().indices() {\n             dirty_queue.insert(bb);\n         }\n \n+        let mut state = BitSet::new_empty(bits_per_block);\n         while let Some(bb) = dirty_queue.pop() {\n-            let bb_data = &self.body[bb];\n-            let on_entry = &self.entry_sets[bb];\n+            let bb_data = &body[bb];\n \n-            temp_state.overwrite(on_entry);\n-            self.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n+            // Apply the block transfer function, using the cached one if it exists.\n+            state.overwrite(&entry_sets[bb]);\n+            match &trans_for_block {\n+                Some(trans_for_block) => trans_for_block[bb].apply(&mut state),\n+                None => A::Direction::apply_effects_in_block(&analysis, &mut state, bb, bb_data),\n+            }\n \n-            self.propagate_bits_into_graph_successors_of(\n-                &mut temp_state,\n+            A::Direction::join_state_into_successors_of(\n+                &analysis,\n+                tcx,\n+                body,\n+                dead_unwinds,\n+                &mut state,\n                 (bb, bb_data),\n-                &mut dirty_queue,\n+                |target: BasicBlock, state: &BitSet<A::Idx>| {\n+                    let set_changed = analysis.join(&mut entry_sets[target], state);\n+                    if set_changed {\n+                        dirty_queue.insert(target);\n+                    }\n+                },\n             );\n         }\n \n-        let Engine { tcx, body, def_id, trans_for_block, entry_sets, analysis, .. } = self;\n         let results = Results { analysis, entry_sets };\n \n-        let res = write_graphviz_results(tcx, def_id, body, &results, trans_for_block);\n+        let res = write_graphviz_results(tcx, def_id, &body, &results, trans_for_block);\n         if let Err(e) = res {\n             warn!(\"Failed to write graphviz dataflow results: {}\", e);\n         }\n \n         results\n     }\n-\n-    /// Applies the cumulative effect of an entire block, excluding the call return effect if one\n-    /// exists.\n-    fn apply_whole_block_effect(\n-        &self,\n-        state: &mut BitSet<A::Idx>,\n-        block: BasicBlock,\n-        block_data: &mir::BasicBlockData<'tcx>,\n-    ) {\n-        // Use the cached block transfer function if available.\n-        if let Some(trans_for_block) = &self.trans_for_block {\n-            trans_for_block[block].apply(state);\n-            return;\n-        }\n-\n-        // Otherwise apply effects one-by-one.\n-\n-        for (statement_index, statement) in block_data.statements.iter().enumerate() {\n-            let location = Location { block, statement_index };\n-            self.analysis.apply_before_statement_effect(state, statement, location);\n-            self.analysis.apply_statement_effect(state, statement, location);\n-        }\n-\n-        let terminator = block_data.terminator();\n-        let location = Location { block, statement_index: block_data.statements.len() };\n-        self.analysis.apply_before_terminator_effect(state, terminator, location);\n-        self.analysis.apply_terminator_effect(state, terminator, location);\n-    }\n-\n-    fn propagate_bits_into_graph_successors_of(\n-        &mut self,\n-        in_out: &mut BitSet<A::Idx>,\n-        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n-        dirty_list: &mut WorkQueue<BasicBlock>,\n-    ) {\n-        use mir::TerminatorKind::*;\n-\n-        match bb_data.terminator().kind {\n-            Return | Resume | Abort | GeneratorDrop | Unreachable => {}\n-\n-            Goto { target }\n-            | Assert { target, cleanup: None, .. }\n-            | Drop { target, location: _, unwind: None }\n-            | DropAndReplace { target, value: _, location: _, unwind: None } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list)\n-            }\n-\n-            Yield { resume: target, drop, resume_arg, .. } => {\n-                if let Some(drop) = drop {\n-                    self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n-                }\n-\n-                self.analysis.apply_yield_resume_effect(in_out, target, resume_arg);\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-            }\n-\n-            Assert { target, cleanup: Some(unwind), .. }\n-            | Drop { target, location: _, unwind: Some(unwind) }\n-            | DropAndReplace { target, value: _, location: _, unwind: Some(unwind) } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n-                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                }\n-            }\n-\n-            SwitchInt { ref targets, ref values, ref discr, .. } => {\n-                let Engine { tcx, body, .. } = *self;\n-                let enum_ = discr\n-                    .place()\n-                    .and_then(|discr| switch_on_enum_discriminant(tcx, body, bb_data, discr));\n-                match enum_ {\n-                    // If this is a switch on an enum discriminant, a custom effect may be applied\n-                    // along each outgoing edge.\n-                    Some((enum_place, enum_def)) => {\n-                        self.propagate_bits_into_enum_discriminant_switch_successors(\n-                            in_out, bb, enum_def, enum_place, dirty_list, &*values, &*targets,\n-                        );\n-                    }\n-\n-                    // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n-                    // exit state.\n-                    None => {\n-                        for target in targets.iter().copied() {\n-                            self.propagate_bits_into_entry_set_for(&in_out, target, dirty_list);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            Call { cleanup, ref destination, ref func, ref args, .. } => {\n-                if let Some(unwind) = cleanup {\n-                    if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-\n-                if let Some((dest_place, dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, otherwise the unwind path will see the call\n-                    // return effect.\n-                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n-                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n-                }\n-            }\n-\n-            FalseEdges { real_target, imaginary_target } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n-            }\n-\n-            FalseUnwind { real_target, unwind } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                if let Some(unwind) = unwind {\n-                    if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(\n-        &mut self,\n-        in_out: &BitSet<A::Idx>,\n-        bb: BasicBlock,\n-        dirty_queue: &mut WorkQueue<BasicBlock>,\n-    ) {\n-        let entry_set = &mut self.entry_sets[bb];\n-        let set_changed = self.analysis.join(entry_set, &in_out);\n-        if set_changed {\n-            dirty_queue.insert(bb);\n-        }\n-    }\n-\n-    fn propagate_bits_into_enum_discriminant_switch_successors(\n-        &mut self,\n-        in_out: &mut BitSet<A::Idx>,\n-        bb: BasicBlock,\n-        enum_def: &'tcx ty::AdtDef,\n-        enum_place: mir::Place<'tcx>,\n-        dirty_list: &mut WorkQueue<BasicBlock>,\n-        values: &[u128],\n-        targets: &[BasicBlock],\n-    ) {\n-        // MIR building adds discriminants to the `values` array in the same order as they\n-        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n-        // discriminant in `values` to its corresponding variant in linear time.\n-        let mut tmp = BitSet::new_empty(in_out.domain_size());\n-        let mut discriminants = enum_def.discriminants(self.tcx);\n-        for (value, target) in values.iter().zip(targets.iter().copied()) {\n-            let (variant_idx, _) = discriminants.find(|&(_, discr)| discr.val == *value).expect(\n-                \"Order of `AdtDef::discriminants` differed from that of `SwitchInt::values`\",\n-            );\n-\n-            tmp.overwrite(in_out);\n-            self.analysis.apply_discriminant_switch_effect(\n-                &mut tmp,\n-                bb,\n-                enum_place,\n-                enum_def,\n-                variant_idx,\n-            );\n-            self.propagate_bits_into_entry_set_for(&tmp, target, dirty_list);\n-        }\n-\n-        std::mem::drop(tmp);\n-\n-        // Propagate dataflow state along the \"otherwise\" edge.\n-        let otherwise = targets.last().copied().unwrap();\n-        self.propagate_bits_into_entry_set_for(&in_out, otherwise, dirty_list);\n-    }\n-}\n-\n-/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n-/// an enum discriminant.\n-///\n-/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n-///   _42 = discriminant(_1)\n-///   SwitchInt(_42, ..)\n-///\n-/// If the basic block matches this pattern, this function returns the place corresponding to the\n-/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n-fn switch_on_enum_discriminant(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-    block: &'mir mir::BasicBlockData<'tcx>,\n-    switch_on: mir::Place<'tcx>,\n-) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n-    match block.statements.last().map(|stmt| &stmt.kind) {\n-        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n-            if *lhs == switch_on =>\n-        {\n-            match &discriminated.ty(body, tcx).ty.kind {\n-                ty::Adt(def, _) => Some((*discriminated, def)),\n-\n-                // `Rvalue::Discriminant` is also used to get the active yield point for a\n-                // generator, but we do not need edge-specific effects in that case. This may\n-                // change in the future.\n-                ty::Generator(..) => None,\n-\n-                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n-            }\n-        }\n-\n-        _ => None,\n-    }\n }\n \n // Graphviz\n@@ -431,12 +297,12 @@ where\n             if let Some(trans_for_block) = block_transfer_functions {\n                 Box::new(graphviz::BlockTransferFunc::new(body, trans_for_block))\n             } else {\n-                Box::new(graphviz::SimpleDiff::new(bits_per_block))\n+                Box::new(graphviz::SimpleDiff::new(body, &results))\n             }\n         }\n \n         // Default to the `SimpleDiff` output style.\n-        _ => Box::new(graphviz::SimpleDiff::new(bits_per_block)),\n+        _ => Box::new(graphviz::SimpleDiff::new(body, &results)),\n     };\n \n     debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());"}, {"sha": "e3ba26eaf8b372ba74e40c22b899c2aef11e15ad", "filename": "src/librustc_mir/dataflow/framework/graphviz.rs", "status": "modified", "additions": 91, "deletions": 44, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -8,7 +8,7 @@ use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, BasicBlock, Body, Location};\n \n-use super::{Analysis, GenKillSet, Results, ResultsRefCursor};\n+use super::{Analysis, Direction, GenKillSet, Results, ResultsRefCursor};\n use crate::util::graphviz_safe_def_name;\n \n pub struct Formatter<'a, 'tcx, A>\n@@ -49,7 +49,7 @@ pub struct CfgEdge {\n     index: usize,\n }\n \n-fn outgoing_edges(body: &Body<'_>, bb: BasicBlock) -> Vec<CfgEdge> {\n+fn dataflow_successors(body: &Body<'tcx>, bb: BasicBlock) -> Vec<CfgEdge> {\n     body[bb]\n         .terminator()\n         .successors()\n@@ -105,7 +105,7 @@ where\n         self.body\n             .basic_blocks()\n             .indices()\n-            .flat_map(|bb| outgoing_edges(self.body, bb))\n+            .flat_map(|bb| dataflow_successors(self.body, bb))\n             .collect::<Vec<_>>()\n             .into()\n     }\n@@ -192,12 +192,12 @@ where\n             self.write_block_header_with_state_columns(w, block)?;\n         }\n \n-        // C: Entry state\n+        // C: State at start of block\n         self.bg = Background::Light;\n         self.results.seek_to_block_start(block);\n         let block_entry_state = self.results.get().clone();\n \n-        self.write_row_with_full_state(w, \"\", \"(on entry)\")?;\n+        self.write_row_with_full_state(w, \"\", \"(on start)\")?;\n \n         // D: Statement transfer functions\n         for (i, statement) in body[block].statements.iter().enumerate() {\n@@ -214,37 +214,72 @@ where\n \n         self.write_row_for_location(w, \"T\", &terminator_str, terminator_loc)?;\n \n-        // F: Exit state\n+        // F: State at end of block\n \n         // Write the full dataflow state immediately after the terminator if it differs from the\n         // state at block entry.\n-        self.results.seek_after(terminator_loc);\n-        if self.results.get() != &block_entry_state {\n+        self.results.seek_to_block_end(block);\n+        if self.results.get() != &block_entry_state || A::Direction::is_backward() {\n             let after_terminator_name = match terminator.kind {\n                 mir::TerminatorKind::Call { destination: Some(_), .. } => \"(on unwind)\",\n-                _ => \"(on exit)\",\n+                _ => \"(on end)\",\n             };\n \n             self.write_row_with_full_state(w, \"\", after_terminator_name)?;\n         }\n \n         // Write any changes caused by terminator-specific effects\n-        if let mir::TerminatorKind::Call { destination: Some(_), .. } = terminator.kind {\n-            let num_state_columns = self.num_state_columns();\n-            self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n-                write!(\n-                    w,\n-                    r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n-                    colspan = num_state_columns,\n-                    fmt = fmt,\n-                )?;\n-\n-                let state_on_unwind = this.results.get().clone();\n-                this.results.seek_after_assume_success(terminator_loc);\n-                write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n-\n-                write!(w, \"</td>\")\n-            })?;\n+        let num_state_columns = self.num_state_columns();\n+        match terminator.kind {\n+            mir::TerminatorKind::Call {\n+                destination: Some((return_place, _)),\n+                ref func,\n+                ref args,\n+                ..\n+            } => {\n+                self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n+                    write!(\n+                        w,\n+                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n+                        colspan = num_state_columns,\n+                        fmt = fmt,\n+                    )?;\n+\n+                    let state_on_unwind = this.results.get().clone();\n+                    this.results.apply_custom_effect(|analysis, state| {\n+                        analysis.apply_call_return_effect(state, block, func, args, return_place);\n+                    });\n+\n+                    write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n+                    write!(w, \"</td>\")\n+                })?;\n+            }\n+\n+            mir::TerminatorKind::Yield { resume, resume_arg, .. } => {\n+                self.write_row(w, \"\", \"(on yield resume)\", |this, w, fmt| {\n+                    write!(\n+                        w,\n+                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n+                        colspan = num_state_columns,\n+                        fmt = fmt,\n+                    )?;\n+\n+                    let state_on_generator_drop = this.results.get().clone();\n+                    this.results.apply_custom_effect(|analysis, state| {\n+                        analysis.apply_yield_resume_effect(state, resume, resume_arg);\n+                    });\n+\n+                    write_diff(\n+                        w,\n+                        this.results.analysis(),\n+                        &state_on_generator_drop,\n+                        this.results.get(),\n+                    )?;\n+                    write!(w, \"</td>\")\n+                })?;\n+            }\n+\n+            _ => {}\n         };\n \n         write!(w, \"</table>\")\n@@ -403,18 +438,23 @@ where\n }\n \n /// Prints a single column containing the state vector immediately *after* each statement.\n-pub struct SimpleDiff<T: Idx> {\n-    prev_state: BitSet<T>,\n-    prev_loc: Location,\n+pub struct SimpleDiff<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    prev_state: ResultsRefCursor<'a, 'a, 'tcx, A>,\n }\n \n-impl<T: Idx> SimpleDiff<T> {\n-    pub fn new(bits_per_block: usize) -> Self {\n-        SimpleDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n+impl<A> SimpleDiff<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn new(body: &'a Body<'tcx>, results: &'a Results<'tcx, A>) -> Self {\n+        SimpleDiff { prev_state: ResultsRefCursor::new(body, results) }\n     }\n }\n \n-impl<A> StateFormatter<'tcx, A> for SimpleDiff<A::Idx>\n+impl<A> StateFormatter<'tcx, A> for SimpleDiff<'_, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n@@ -429,20 +469,27 @@ where\n         results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n         location: Location,\n     ) -> io::Result<()> {\n-        if location.statement_index == 0 {\n-            results.seek_to_block_start(location.block);\n-            self.prev_state.overwrite(results.get());\n+        if A::Direction::is_forward() {\n+            if location.statement_index == 0 {\n+                self.prev_state.seek_to_block_start(location.block);\n+            } else {\n+                self.prev_state.seek_after_primary_effect(Location {\n+                    statement_index: location.statement_index - 1,\n+                    ..location\n+                });\n+            }\n         } else {\n-            // Ensure that we are visiting statements in order, so `prev_state` is correct.\n-            assert_eq!(self.prev_loc.successor_within_block(), location);\n+            if location == results.body().terminator_loc(location.block) {\n+                self.prev_state.seek_to_block_end(location.block);\n+            } else {\n+                self.prev_state.seek_after_primary_effect(location.successor_within_block());\n+            }\n         }\n \n-        self.prev_loc = location;\n         write!(w, r#\"<td {fmt} balign=\"left\" align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_after(location);\n+        results.seek_after_primary_effect(location);\n         let curr_state = results.get();\n-        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n-        self.prev_state.overwrite(curr_state);\n+        write_diff(&mut w, results.analysis(), self.prev_state.get(), curr_state)?;\n         write!(w, \"</td>\")\n     }\n }\n@@ -476,7 +523,7 @@ where\n         location: Location,\n     ) -> io::Result<()> {\n         if location.statement_index == 0 {\n-            results.seek_to_block_start(location.block);\n+            results.seek_to_block_entry(location.block);\n             self.prev_state.overwrite(results.get());\n         } else {\n             // Ensure that we are visiting statements in order, so `prev_state` is correct.\n@@ -488,7 +535,7 @@ where\n         // Before\n \n         write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_before(location);\n+        results.seek_before_primary_effect(location);\n         let curr_state = results.get();\n         write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n         self.prev_state.overwrite(curr_state);\n@@ -497,7 +544,7 @@ where\n         // After\n \n         write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_after(location);\n+        results.seek_after_primary_effect(location);\n         let curr_state = results.get();\n         write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n         self.prev_state.overwrite(curr_state);"}, {"sha": "a21bbacb4676646ae5aca028f2e608e95ea6bc71", "filename": "src/librustc_mir/dataflow/framework/mod.rs", "status": "modified", "additions": 77, "deletions": 45, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -30,67 +30,28 @@\n //!\n //! [gen-kill]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n \n+use std::cmp::Ordering;\n use std::io;\n \n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n mod cursor;\n+mod direction;\n mod engine;\n mod graphviz;\n mod visitor;\n \n pub use self::cursor::{ResultsCursor, ResultsRefCursor};\n-pub use self::engine::Engine;\n+pub use self::direction::{Backward, Direction, Forward};\n+pub use self::engine::{Engine, Results};\n pub use self::visitor::{visit_results, ResultsVisitor};\n pub use self::visitor::{BorrowckFlowState, BorrowckResults};\n \n-/// A dataflow analysis that has converged to fixpoint.\n-pub struct Results<'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    pub analysis: A,\n-    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n-}\n-\n-impl<A> Results<'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    /// Creates a `ResultsCursor` that can inspect these `Results`.\n-    pub fn into_results_cursor(self, body: &'mir mir::Body<'tcx>) -> ResultsCursor<'mir, 'tcx, A> {\n-        ResultsCursor::new(body, self)\n-    }\n-\n-    /// Gets the entry set for the given block.\n-    pub fn entry_set_for_block(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n-        &self.entry_sets[block]\n-    }\n-\n-    pub fn visit_with(\n-        &self,\n-        body: &'mir mir::Body<'tcx>,\n-        blocks: impl IntoIterator<Item = BasicBlock>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n-    ) {\n-        visit_results(body, blocks, self, vis)\n-    }\n-\n-    pub fn visit_in_rpo_with(\n-        &self,\n-        body: &'mir mir::Body<'tcx>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n-    ) {\n-        let blocks = mir::traversal::reverse_postorder(body);\n-        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n-    }\n-}\n-\n /// Parameterization for the precise form of data flow that is used.\n ///\n /// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n@@ -144,6 +105,9 @@ pub trait AnalysisDomain<'tcx>: BottomValue {\n     /// The type of the elements in the state vector.\n     type Idx: Idx;\n \n+    /// The direction of this analyis. Either `Forward` or `Backward`.\n+    type Direction: Direction = Forward;\n+\n     /// A descriptive name for this analysis. Used only for debugging.\n     ///\n     /// This name should be brief and contain no spaces, periods or other characters that are not\n@@ -155,6 +119,13 @@ pub trait AnalysisDomain<'tcx>: BottomValue {\n \n     /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n     /// analysis.\n+    ///\n+    /// For backward analyses, initial state besides the bottom value is not yet supported. Trying\n+    /// to mutate the initial state will result in a panic.\n+    //\n+    // FIXME: For backward dataflow analyses, the initial state should be applied to every basic\n+    // block where control flow could exit the MIR body (e.g., those terminated with `return` or\n+    // `resume`). It's not obvious how to handle `yield` points in generators, however.\n     fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n \n     /// Prints an element in the state vector for debugging.\n@@ -247,6 +218,8 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     ///\n     /// Much like `apply_call_return_effect`, this effect is only propagated along a single\n     /// outgoing edge from this basic block.\n+    ///\n+    /// FIXME: This class of effects is not supported for backward dataflow analyses.\n     fn apply_discriminant_switch_effect(\n         &self,\n         _state: &mut BitSet<Self::Idx>,\n@@ -338,7 +311,7 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n     /// See `Analysis::apply_yield_resume_effect`.\n     fn yield_resume_effect(\n         &self,\n-        _trans: &mut BitSet<Self::Idx>,\n+        _trans: &mut impl GenKill<Self::Idx>,\n         _resume_block: BasicBlock,\n         _resume_place: mir::Place<'tcx>,\n     ) {\n@@ -520,5 +493,64 @@ impl<T: Idx> GenKill<T> for BitSet<T> {\n     }\n }\n \n+// NOTE: DO NOT CHANGE VARIANT ORDER. The derived `Ord` impls rely on the current order.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum Effect {\n+    /// The \"before\" effect (e.g., `apply_before_statement_effect`) for a statement (or\n+    /// terminator).\n+    Before,\n+\n+    /// The \"primary\" effect (e.g., `apply_statement_effect`) for a statement (or terminator).\n+    Primary,\n+}\n+\n+impl Effect {\n+    pub const fn at_index(self, statement_index: usize) -> EffectIndex {\n+        EffectIndex { effect: self, statement_index }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub struct EffectIndex {\n+    statement_index: usize,\n+    effect: Effect,\n+}\n+\n+impl EffectIndex {\n+    fn next_in_forward_order(self) -> Self {\n+        match self.effect {\n+            Effect::Before => Effect::Primary.at_index(self.statement_index),\n+            Effect::Primary => Effect::Before.at_index(self.statement_index + 1),\n+        }\n+    }\n+\n+    fn next_in_backward_order(self) -> Self {\n+        match self.effect {\n+            Effect::Before => Effect::Primary.at_index(self.statement_index),\n+            Effect::Primary => Effect::Before.at_index(self.statement_index - 1),\n+        }\n+    }\n+\n+    /// Returns `true` if the effect at `self` should be applied eariler than the effect at `other`\n+    /// in forward order.\n+    fn precedes_in_forward_order(self, other: Self) -> bool {\n+        let ord = self\n+            .statement_index\n+            .cmp(&other.statement_index)\n+            .then_with(|| self.effect.cmp(&other.effect));\n+        ord == Ordering::Less\n+    }\n+\n+    /// Returns `true` if the effect at `self` should be applied earlier than the effect at `other`\n+    /// in backward order.\n+    fn precedes_in_backward_order(self, other: Self) -> bool {\n+        let ord = other\n+            .statement_index\n+            .cmp(&self.statement_index)\n+            .then_with(|| self.effect.cmp(&other.effect));\n+        ord == Ordering::Less\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "a8dce7079b7a8b08ff8a564776a3ae13d57abc0f", "filename": "src/librustc_mir/dataflow/framework/tests.rs", "status": "modified", "additions": 77, "deletions": 86, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -1,5 +1,7 @@\n //! A test for the logic that updates the state in a `ResultsCursor` during seek.\n \n+use std::marker::PhantomData;\n+\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::{self, BasicBlock, Location};\n@@ -9,16 +11,6 @@ use rustc_span::DUMMY_SP;\n use super::*;\n use crate::dataflow::BottomValue;\n \n-/// Returns `true` if the given location points to a `Call` terminator that can return\n-/// successfully.\n-fn is_call_terminator_non_diverging(body: &mir::Body<'_>, loc: Location) -> bool {\n-    loc == body.terminator_loc(loc.block)\n-        && matches!(\n-            body[loc.block].terminator().kind,\n-            mir::TerminatorKind::Call { destination: Some(_), ..  }\n-        )\n-}\n-\n /// Creates a `mir::Body` with a few disconnected basic blocks.\n ///\n /// This is the `Body` that will be used by the `MockAnalysis` below. The shape of its CFG is not\n@@ -79,20 +71,20 @@ fn mock_body() -> mir::Body<'static> {\n /// | Location               | Before            | After  |\n /// |------------------------|-------------------|--------|\n /// | (on_entry)             | {102}                     ||\n-/// | Statement 0            | +0                | +1     |\n+/// | statement 0            | +0                | +1     |\n /// | statement 1            | +2                | +3     |\n /// | `Call` terminator      | +4                | +5     |\n /// | (on unwind)            | {102,0,1,2,3,4,5}         ||\n-/// | (on successful return) | +6                        ||\n ///\n /// The `102` in the block's entry set is derived from the basic block index and ensures that the\n /// expected state is unique across all basic blocks. Remember, it is generated by\n /// `mock_entry_sets`, not from actually running `MockAnalysis` to fixpoint.\n-struct MockAnalysis<'tcx> {\n+struct MockAnalysis<'tcx, D> {\n     body: &'tcx mir::Body<'tcx>,\n+    dir: PhantomData<D>,\n }\n \n-impl MockAnalysis<'tcx> {\n+impl<D: Direction> MockAnalysis<'tcx, D> {\n     const BASIC_BLOCK_OFFSET: usize = 100;\n \n     /// The entry set for each `BasicBlock` is the ID of that block offset by a fixed amount to\n@@ -115,25 +107,14 @@ impl MockAnalysis<'tcx> {\n     }\n \n     /// Returns the index that should be added to the dataflow state at the given target.\n-    ///\n-    /// This index is only unique within a given basic block. `SeekAfter` and\n-    /// `SeekAfterAssumeCallReturns` have the same effect unless `target` is a `Call` terminator.\n-    fn effect_at_target(&self, target: SeekTarget) -> Option<usize> {\n-        use SeekTarget::*;\n-\n-        let idx = match target {\n-            BlockStart(_) => return None,\n-\n-            AfterAssumeCallReturns(loc) if is_call_terminator_non_diverging(self.body, loc) => {\n-                loc.statement_index * 2 + 2\n-            }\n-\n-            Before(loc) => loc.statement_index * 2,\n-            After(loc) | AfterAssumeCallReturns(loc) => loc.statement_index * 2 + 1,\n+    fn effect(&self, loc: EffectIndex) -> usize {\n+        let idx = match loc.effect {\n+            Effect::Before => loc.statement_index * 2,\n+            Effect::Primary => loc.statement_index * 2 + 1,\n         };\n \n         assert!(idx < Self::BASIC_BLOCK_OFFSET, \"Too many statements in basic block\");\n-        Some(idx)\n+        idx\n     }\n \n     /// Returns the expected state at the given `SeekTarget`.\n@@ -143,27 +124,48 @@ impl MockAnalysis<'tcx> {\n     /// basic block.\n     ///\n     /// For example, the expected state when calling\n-    /// `seek_before(Location { block: 2, statement_index: 2 })` would be `[102, 0, 1, 2, 3, 4]`.\n+    /// `seek_before_primary_effect(Location { block: 2, statement_index: 2 })`\n+    /// would be `[102, 0, 1, 2, 3, 4]`.\n     fn expected_state_at_target(&self, target: SeekTarget) -> BitSet<usize> {\n+        let block = target.block();\n         let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n-        ret.insert(Self::BASIC_BLOCK_OFFSET + target.block().index());\n+        ret.insert(Self::BASIC_BLOCK_OFFSET + block.index());\n \n-        if let Some(target_effect) = self.effect_at_target(target) {\n-            for i in 0..=target_effect {\n-                ret.insert(i);\n+        let target = match target {\n+            SeekTarget::BlockEntry { .. } => return ret,\n+            SeekTarget::Before(loc) => Effect::Before.at_index(loc.statement_index),\n+            SeekTarget::After(loc) => Effect::Primary.at_index(loc.statement_index),\n+        };\n+\n+        let mut pos = if D::is_forward() {\n+            Effect::Before.at_index(0)\n+        } else {\n+            Effect::Before.at_index(self.body[block].statements.len())\n+        };\n+\n+        loop {\n+            ret.insert(self.effect(pos));\n+\n+            if pos == target {\n+                return ret;\n             }\n-        }\n \n-        ret\n+            if D::is_forward() {\n+                pos = pos.next_in_forward_order();\n+            } else {\n+                pos = pos.next_in_backward_order();\n+            }\n+        }\n     }\n }\n \n-impl BottomValue for MockAnalysis<'tcx> {\n+impl<D: Direction> BottomValue for MockAnalysis<'tcx, D> {\n     const BOTTOM_VALUE: bool = false;\n }\n \n-impl AnalysisDomain<'tcx> for MockAnalysis<'tcx> {\n+impl<D: Direction> AnalysisDomain<'tcx> for MockAnalysis<'tcx, D> {\n     type Idx = usize;\n+    type Direction = D;\n \n     const NAME: &'static str = \"mock\";\n \n@@ -176,14 +178,14 @@ impl AnalysisDomain<'tcx> for MockAnalysis<'tcx> {\n     }\n }\n \n-impl Analysis<'tcx> for MockAnalysis<'tcx> {\n+impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n     fn apply_statement_effect(\n         &self,\n         state: &mut BitSet<Self::Idx>,\n         _statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        let idx = self.effect_at_target(SeekTarget::After(location)).unwrap();\n+        let idx = self.effect(Effect::Primary.at_index(location.statement_index));\n         assert!(state.insert(idx));\n     }\n \n@@ -193,7 +195,7 @@ impl Analysis<'tcx> for MockAnalysis<'tcx> {\n         _statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        let idx = self.effect_at_target(SeekTarget::Before(location)).unwrap();\n+        let idx = self.effect(Effect::Before.at_index(location.statement_index));\n         assert!(state.insert(idx));\n     }\n \n@@ -203,7 +205,7 @@ impl Analysis<'tcx> for MockAnalysis<'tcx> {\n         _terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n-        let idx = self.effect_at_target(SeekTarget::After(location)).unwrap();\n+        let idx = self.effect(Effect::Primary.at_index(location.statement_index));\n         assert!(state.insert(idx));\n     }\n \n@@ -213,90 +215,62 @@ impl Analysis<'tcx> for MockAnalysis<'tcx> {\n         _terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n-        let idx = self.effect_at_target(SeekTarget::Before(location)).unwrap();\n+        let idx = self.effect(Effect::Before.at_index(location.statement_index));\n         assert!(state.insert(idx));\n     }\n \n     fn apply_call_return_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n-        block: BasicBlock,\n+        _state: &mut BitSet<Self::Idx>,\n+        _block: BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n         _return_place: mir::Place<'tcx>,\n     ) {\n-        let location = self.body.terminator_loc(block);\n-        let idx = self.effect_at_target(SeekTarget::AfterAssumeCallReturns(location)).unwrap();\n-        assert!(state.insert(idx));\n     }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n enum SeekTarget {\n-    BlockStart(BasicBlock),\n+    BlockEntry(BasicBlock),\n     Before(Location),\n     After(Location),\n-    AfterAssumeCallReturns(Location),\n }\n \n impl SeekTarget {\n     fn block(&self) -> BasicBlock {\n         use SeekTarget::*;\n \n         match *self {\n-            BlockStart(block) => block,\n-            Before(loc) | After(loc) | AfterAssumeCallReturns(loc) => loc.block,\n+            BlockEntry(block) => block,\n+            Before(loc) | After(loc) => loc.block,\n         }\n     }\n \n     /// An iterator over all possible `SeekTarget`s in a given block in order, starting with\n-    /// `BlockStart`.\n-    ///\n-    /// This includes both `After` and `AfterAssumeCallReturns` for every `Location`.\n+    /// `BlockEntry`.\n     fn iter_in_block(body: &mir::Body<'_>, block: BasicBlock) -> impl Iterator<Item = Self> {\n         let statements_and_terminator = (0..=body[block].statements.len())\n-            .flat_map(|i| (0..3).map(move |j| (i, j)))\n+            .flat_map(|i| (0..2).map(move |j| (i, j)))\n             .map(move |(i, kind)| {\n                 let loc = Location { block, statement_index: i };\n                 match kind {\n                     0 => SeekTarget::Before(loc),\n                     1 => SeekTarget::After(loc),\n-                    2 => SeekTarget::AfterAssumeCallReturns(loc),\n                     _ => unreachable!(),\n                 }\n             });\n \n-        std::iter::once(SeekTarget::BlockStart(block)).chain(statements_and_terminator)\n+        std::iter::once(SeekTarget::BlockEntry(block)).chain(statements_and_terminator)\n     }\n }\n \n-#[test]\n-fn cursor_seek() {\n-    let body = mock_body();\n-    let body = &body;\n-    let analysis = MockAnalysis { body };\n+fn test_cursor<D: Direction>(analysis: MockAnalysis<'tcx, D>) {\n+    let body = analysis.body;\n \n     let mut cursor =\n         Results { entry_sets: analysis.mock_entry_sets(), analysis }.into_results_cursor(body);\n \n-    // Sanity check: the mock call return effect is unique and actually being applied.\n-    let call_terminator_loc = Location { block: BasicBlock::from_usize(2), statement_index: 2 };\n-    assert!(is_call_terminator_non_diverging(body, call_terminator_loc));\n-\n-    let call_return_effect = cursor\n-        .analysis()\n-        .effect_at_target(SeekTarget::AfterAssumeCallReturns(call_terminator_loc))\n-        .unwrap();\n-    assert_ne!(\n-        call_return_effect,\n-        cursor.analysis().effect_at_target(SeekTarget::After(call_terminator_loc)).unwrap()\n-    );\n-\n-    cursor.seek_after(call_terminator_loc);\n-    assert!(!cursor.get().contains(call_return_effect));\n-    cursor.seek_after_assume_success(call_terminator_loc);\n-    assert!(cursor.get().contains(call_return_effect));\n-\n     let every_target = || {\n         body.basic_blocks()\n             .iter_enumerated()\n@@ -307,10 +281,9 @@ fn cursor_seek() {\n         use SeekTarget::*;\n \n         match targ {\n-            BlockStart(block) => cursor.seek_to_block_start(block),\n-            Before(loc) => cursor.seek_before(loc),\n-            After(loc) => cursor.seek_after(loc),\n-            AfterAssumeCallReturns(loc) => cursor.seek_after_assume_success(loc),\n+            BlockEntry(block) => cursor.seek_to_block_entry(block),\n+            Before(loc) => cursor.seek_before_primary_effect(loc),\n+            After(loc) => cursor.seek_after_primary_effect(loc),\n         }\n \n         assert_eq!(cursor.get(), &cursor.analysis().expected_state_at_target(targ));\n@@ -325,8 +298,26 @@ fn cursor_seek() {\n         seek_to_target(from);\n \n         for to in every_target() {\n+            dbg!(from);\n+            dbg!(to);\n             seek_to_target(to);\n             seek_to_target(from);\n         }\n     }\n }\n+\n+#[test]\n+fn backward_cursor() {\n+    let body = mock_body();\n+    let body = &body;\n+    let analysis = MockAnalysis { body, dir: PhantomData::<Backward> };\n+    test_cursor(analysis)\n+}\n+\n+#[test]\n+fn forward_cursor() {\n+    let body = mock_body();\n+    let body = &body;\n+    let analysis = MockAnalysis { body, dir: PhantomData::<Forward> };\n+    test_cursor(analysis)\n+}"}, {"sha": "0df9322e7fe088e222a71fd632ad6d0817732a8f", "filename": "src/librustc_mir/dataflow/framework/visitor.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -1,50 +1,41 @@\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Location};\n \n-use super::{Analysis, Results};\n+use super::{Analysis, Direction, Results};\n use crate::dataflow::impls::{borrows::Borrows, EverInitializedPlaces, MaybeUninitializedPlaces};\n \n /// Calls the corresponding method in `ResultsVisitor` for every location in a `mir::Body` with the\n /// dataflow state at that location.\n-pub fn visit_results<F>(\n+pub fn visit_results<F, V>(\n     body: &'mir mir::Body<'tcx>,\n     blocks: impl IntoIterator<Item = BasicBlock>,\n-    results: &impl ResultsVisitable<'tcx, FlowState = F>,\n+    results: &V,\n     vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n-) {\n+) where\n+    V: ResultsVisitable<'tcx, FlowState = F>,\n+{\n     let mut state = results.new_flow_state(body);\n \n     for block in blocks {\n         let block_data = &body[block];\n-        results.reset_to_block_start(&mut state, block);\n-\n-        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n-            let loc = Location { block, statement_index };\n-\n-            results.reconstruct_before_statement_effect(&mut state, stmt, loc);\n-            vis.visit_statement(&state, stmt, loc);\n-\n-            results.reconstruct_statement_effect(&mut state, stmt, loc);\n-            vis.visit_statement_exit(&state, stmt, loc);\n-        }\n-\n-        let loc = body.terminator_loc(block);\n-        let term = block_data.terminator();\n-\n-        results.reconstruct_before_terminator_effect(&mut state, term, loc);\n-        vis.visit_terminator(&state, term, loc);\n-\n-        results.reconstruct_terminator_effect(&mut state, term, loc);\n-        vis.visit_terminator_exit(&state, term, loc);\n+        V::Direction::visit_results_in_block(&mut state, block, block_data, results, vis);\n     }\n }\n \n pub trait ResultsVisitor<'mir, 'tcx> {\n     type FlowState;\n \n+    fn visit_block_start(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _block_data: &'mir mir::BasicBlockData<'tcx>,\n+        _block: BasicBlock,\n+    ) {\n+    }\n+\n     /// Called with the `before_statement_effect` of the given statement applied to `state` but not\n     /// its `statement_effect`.\n-    fn visit_statement(\n+    fn visit_statement_before_primary_effect(\n         &mut self,\n         _state: &Self::FlowState,\n         _statement: &'mir mir::Statement<'tcx>,\n@@ -54,7 +45,7 @@ pub trait ResultsVisitor<'mir, 'tcx> {\n \n     /// Called with both the `before_statement_effect` and the `statement_effect` of the given\n     /// statement applied to `state`.\n-    fn visit_statement_exit(\n+    fn visit_statement_after_primary_effect(\n         &mut self,\n         _state: &Self::FlowState,\n         _statement: &'mir mir::Statement<'tcx>,\n@@ -64,7 +55,7 @@ pub trait ResultsVisitor<'mir, 'tcx> {\n \n     /// Called with the `before_terminator_effect` of the given terminator applied to `state` but not\n     /// its `terminator_effect`.\n-    fn visit_terminator(\n+    fn visit_terminator_before_primary_effect(\n         &mut self,\n         _state: &Self::FlowState,\n         _terminator: &'mir mir::Terminator<'tcx>,\n@@ -76,29 +67,38 @@ pub trait ResultsVisitor<'mir, 'tcx> {\n     /// terminator applied to `state`.\n     ///\n     /// The `call_return_effect` (if one exists) will *not* be applied to `state`.\n-    fn visit_terminator_exit(\n+    fn visit_terminator_after_primary_effect(\n         &mut self,\n         _state: &Self::FlowState,\n         _terminator: &'mir mir::Terminator<'tcx>,\n         _location: Location,\n     ) {\n     }\n+\n+    fn visit_block_end(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _block_data: &'mir mir::BasicBlockData<'tcx>,\n+        _block: BasicBlock,\n+    ) {\n+    }\n }\n \n /// Things that can be visited by a `ResultsVisitor`.\n ///\n /// This trait exists so that we can visit the results of multiple dataflow analyses simultaneously.\n /// DO NOT IMPLEMENT MANUALLY. Instead, use the `impl_visitable` macro below.\n pub trait ResultsVisitable<'tcx> {\n+    type Direction: Direction;\n     type FlowState;\n \n     /// Creates an empty `FlowState` to hold the transient state for these dataflow results.\n     ///\n-    /// The value of the newly created `FlowState` will be overwritten by `reset_to_block_start`\n+    /// The value of the newly created `FlowState` will be overwritten by `reset_to_block_entry`\n     /// before it can be observed by a `ResultsVisitor`.\n     fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState;\n \n-    fn reset_to_block_start(&self, state: &mut Self::FlowState, block: BasicBlock);\n+    fn reset_to_block_entry(&self, state: &mut Self::FlowState, block: BasicBlock);\n \n     fn reconstruct_before_statement_effect(\n         &self,\n@@ -135,11 +135,13 @@ where\n {\n     type FlowState = BitSet<A::Idx>;\n \n+    type Direction = A::Direction;\n+\n     fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n         BitSet::new_empty(self.analysis.bits_per_block(body))\n     }\n \n-    fn reset_to_block_start(&self, state: &mut Self::FlowState, block: BasicBlock) {\n+    fn reset_to_block_entry(&self, state: &mut Self::FlowState, block: BasicBlock) {\n         state.overwrite(&self.entry_set_for_block(block));\n     }\n \n@@ -204,10 +206,11 @@ macro_rules! impl_visitable {\n     ( $(\n         $T:ident { $( $field:ident : $A:ident ),* $(,)? }\n     )* ) => { $(\n-        impl<'tcx, $($A),*> ResultsVisitable<'tcx> for $T<$( Results<'tcx, $A> ),*>\n+        impl<'tcx, $($A),*, D: Direction> ResultsVisitable<'tcx> for $T<$( Results<'tcx, $A> ),*>\n         where\n-            $( $A: Analysis<'tcx>, )*\n+            $( $A: Analysis<'tcx, Direction = D>, )*\n         {\n+            type Direction = D;\n             type FlowState = $T<$( BitSet<$A::Idx> ),*>;\n \n             fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n@@ -216,12 +219,12 @@ macro_rules! impl_visitable {\n                 }\n             }\n \n-            fn reset_to_block_start(\n+            fn reset_to_block_entry(\n                 &self,\n                 state: &mut Self::FlowState,\n                 block: BasicBlock,\n             ) {\n-                $( state.$field.overwrite(&self.$field.entry_sets[block]); )*\n+                $( state.$field.overwrite(&self.$field.entry_set_for_block(block)); )*\n             }\n \n             fn reconstruct_before_statement_effect("}, {"sha": "4c784c3f1a1281db9089970313c3a60cf45cc2c8", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -250,7 +250,7 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n \n     fn yield_resume_effect(\n         &self,\n-        trans: &mut BitSet<Self::Idx>,\n+        trans: &mut impl GenKill<Self::Idx>,\n         _resume_block: BasicBlock,\n         resume_place: mir::Place<'tcx>,\n     ) {\n@@ -283,7 +283,7 @@ where\n     fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n         if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n             let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n-            borrowed_locals.seek_before(loc);\n+            borrowed_locals.seek_before_primary_effect(loc);\n             if !borrowed_locals.contains(*local) {\n                 self.trans.kill(*local);\n             }"}, {"sha": "41b7821707c9676dff42d6179c6691296342d200", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -4,8 +4,9 @@ use rustc_span::symbol::{sym, Symbol};\n \n pub(crate) use self::drop_flag_effects::*;\n pub use self::framework::{\n-    visit_results, Analysis, AnalysisDomain, BorrowckFlowState, BorrowckResults, BottomValue,\n-    Engine, GenKill, GenKillAnalysis, Results, ResultsCursor, ResultsRefCursor, ResultsVisitor,\n+    visit_results, Analysis, AnalysisDomain, Backward, BorrowckFlowState, BorrowckResults,\n+    BottomValue, Engine, Forward, GenKill, GenKillAnalysis, Results, ResultsCursor,\n+    ResultsRefCursor, ResultsVisitor,\n };\n pub use self::impls::{\n     borrows::Borrows, DefinitelyInitializedPlaces, EverInitializedPlaces, MaybeBorrowedLocals,"}, {"sha": "09f8588cee287bad9cd3431e8a0a928b2704e900", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -9,8 +9,9 @@ Rust MIR: a lowered representation of Rust.\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(const_if_match)]\n #![feature(const_fn)]\n+#![feature(const_if_match)]\n+#![feature(const_loop)]\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n@@ -22,6 +23,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n #![feature(associated_type_bounds)]\n+#![feature(associated_type_defaults)]\n #![feature(range_is_empty)]\n #![feature(stmt_expr_attributes)]\n #![feature(trait_alias)]"}, {"sha": "24dc54294b73758caea149b86658672cb3b4f876", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -61,7 +61,7 @@ impl Qualifs<'mir, 'tcx> {\n                 .into_results_cursor(&body)\n         });\n \n-        indirectly_mutable.seek_before(location);\n+        indirectly_mutable.seek_before_primary_effect(location);\n         indirectly_mutable.get().contains(local)\n     }\n \n@@ -88,7 +88,7 @@ impl Qualifs<'mir, 'tcx> {\n                 .into_results_cursor(&body)\n         });\n \n-        needs_drop.seek_before(location);\n+        needs_drop.seek_before_primary_effect(location);\n         needs_drop.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n@@ -115,7 +115,7 @@ impl Qualifs<'mir, 'tcx> {\n                 .into_results_cursor(&body)\n         });\n \n-        has_mut_interior.seek_before(location);\n+        has_mut_interior.seek_before_primary_effect(location);\n         has_mut_interior.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n "}, {"sha": "a1becf062eea6e32d89157be33fb85fd52ee73ab", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -101,7 +101,7 @@ fn find_dead_unwinds<'tcx>(\n             }\n         };\n \n-        flow_inits.seek_before(body.terminator_loc(bb));\n+        flow_inits.seek_before_primary_effect(body.terminator_loc(bb));\n         debug!(\n             \"find_dead_unwinds @ {:?}: path({:?})={:?}; init_data={:?}\",\n             bb,\n@@ -131,8 +131,8 @@ struct InitializationData<'mir, 'tcx> {\n \n impl InitializationData<'_, '_> {\n     fn seek_before(&mut self, loc: Location) {\n-        self.inits.seek_before(loc);\n-        self.uninits.seek_before(loc);\n+        self.inits.seek_before_primary_effect(loc);\n+        self.uninits.seek_before_primary_effect(loc);\n     }\n \n     fn maybe_live_dead(&self, path: MovePathIndex) -> (bool, bool) {"}, {"sha": "a95c5bce5b12846780af0336813bbe056c89ba46", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -490,21 +490,16 @@ fn locals_live_across_suspend_points(\n                 // If a borrow is converted to a raw reference, we must also assume that it lives\n                 // forever. Note that the final liveness is still bounded by the storage liveness\n                 // of the local, which happens using the `intersect` operation below.\n-                borrowed_locals_cursor.seek_before(loc);\n+                borrowed_locals_cursor.seek_before_primary_effect(loc);\n                 liveness.outs[block].union(borrowed_locals_cursor.get());\n             }\n \n-            storage_live.seek_before(loc);\n-            let mut storage_liveness = storage_live.get().clone();\n-\n-            // Later passes handle the generator's `self` argument separately.\n-            storage_liveness.remove(SELF_ARG);\n-\n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n-            storage_liveness_map[block] = Some(storage_liveness);\n+            storage_live.seek_before_primary_effect(loc);\n+            storage_liveness_map[block] = Some(storage_live.get().clone());\n \n-            requires_storage_cursor.seek_before(loc);\n+            requires_storage_cursor.seek_before_primary_effect(loc);\n             let storage_required = requires_storage_cursor.get().clone();\n \n             // Locals live are live at this point only if they are used across"}, {"sha": "1beecb42c0b5760d105996fd7afcd84640d1b8f8", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68d710d525ce4ef56f1de4ba339e7c7b39ddd77/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=c68d710d525ce4ef56f1de4ba339e7c7b39ddd77", "patch": "@@ -126,7 +126,7 @@ pub fn sanity_check_via_rustc_peek<'tcx, A>(\n                 mir::Rvalue::Use(mir::Operand::Move(place) | mir::Operand::Copy(place)),\n             ) => {\n                 let loc = Location { block: bb, statement_index };\n-                cursor.seek_before(loc);\n+                cursor.seek_before_primary_effect(loc);\n                 let state = cursor.get();\n                 results.analysis.peek_at(tcx, *place, state, call);\n             }"}]}