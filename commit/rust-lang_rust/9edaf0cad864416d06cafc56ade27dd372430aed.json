{"sha": "9edaf0cad864416d06cafc56ade27dd372430aed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZGFmMGNhZDg2NDQxNmQwNmNhZmM1NmFkZTI3ZGQzNzI0MzBhZWQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-03T16:43:28Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-03T16:43:28Z"}, "message": "extract_function is `const` aware", "tree": {"sha": "d244d380915415b06932d3c47db97b2312ff4a20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d244d380915415b06932d3c47db97b2312ff4a20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9edaf0cad864416d06cafc56ade27dd372430aed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9edaf0cad864416d06cafc56ade27dd372430aed", "html_url": "https://github.com/rust-lang/rust/commit/9edaf0cad864416d06cafc56ade27dd372430aed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9edaf0cad864416d06cafc56ade27dd372430aed/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e62ce6f61a602fb51f0bacb592ff50202fd89151", "url": "https://api.github.com/repos/rust-lang/rust/commits/e62ce6f61a602fb51f0bacb592ff50202fd89151", "html_url": "https://github.com/rust-lang/rust/commit/e62ce6f61a602fb51f0bacb592ff50202fd89151"}], "stats": {"total": 229, "additions": 154, "deletions": 75}, "files": [{"sha": "e6cac754fe0f409d2906b9cfcd4ce94b31f95f01", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 154, "deletions": 75, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/9edaf0cad864416d06cafc56ade27dd372430aed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9edaf0cad864416d06cafc56ade27dd372430aed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=9edaf0cad864416d06cafc56ade27dd372430aed", "patch": "@@ -71,35 +71,9 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n     let body = extraction_target(&node, range)?;\n-    let container_expr = body.parent()?.ancestors().find_map(|it| {\n-        // double Option as we want to short circuit\n-        let res = match_ast! {\n-            match it {\n-                ast::ClosureExpr(closure) => closure.body(),\n-                ast::EffectExpr(effect) => effect.block_expr().map(ast::Expr::BlockExpr),\n-                ast::Fn(fn_) => fn_.body().map(ast::Expr::BlockExpr),\n-                ast::Static(statik) => statik.body(),\n-                ast::ConstArg(ca) => ca.expr(),\n-                ast::Const(konst) => konst.body(),\n-                ast::ConstParam(cp) => cp.default_val(),\n-                ast::ConstBlockPat(cbp) => cbp.block_expr().map(ast::Expr::BlockExpr),\n-                ast::Variant(__) => None,\n-                ast::Meta(__) => None,\n-                _ => return None,\n-            }\n-        };\n-        Some(res)\n-    })??;\n-    let container_tail = match container_expr {\n-        ast::Expr::BlockExpr(block) => block.tail_expr(),\n-        expr => Some(expr),\n-    };\n-    let in_tail =\n-        container_tail.zip(body.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n-            container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n-        });\n+    let mods = body.analyze_container()?;\n \n-    let (locals_used, has_await, self_param) = body.analyze(&ctx.sema);\n+    let (locals_used, self_param) = body.analyze(&ctx.sema);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n     let insert_after = node_to_insert_after(&body, anchor)?;\n@@ -125,10 +99,6 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n             let params = body.extracted_function_params(ctx, locals_used.iter().copied());\n \n-            let insert_comma = body\n-                .parent()\n-                .and_then(ast::MatchArm::cast)\n-                .map_or(false, |it| it.comma_token().is_none());\n             let fun = Function {\n                 name: \"fun_name\".to_string(),\n                 self_param,\n@@ -137,18 +107,15 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 ret_ty,\n                 body,\n                 outliving_locals,\n+                mods,\n             };\n \n             let new_indent = IndentLevel::from_node(&insert_after);\n             let old_indent = fun.body.indent_level();\n \n-            builder.replace(target_range, make_call(ctx, &fun, old_indent, has_await));\n-            if insert_comma {\n-                builder.insert(target_range.end(), \",\");\n-            }\n+            builder.replace(target_range, make_call(ctx, &fun, old_indent));\n \n-            let fn_def =\n-                format_function(ctx, module, &fun, old_indent, new_indent, has_await, in_tail);\n+            let fn_def = format_function(ctx, module, &fun, old_indent, new_indent);\n             let insert_offset = insert_after.text_range().end();\n             match ctx.config.snippet_cap {\n                 Some(cap) => builder.insert_snippet(cap, insert_offset, fn_def),\n@@ -210,6 +177,7 @@ struct Function {\n     ret_ty: RetType,\n     body: FunctionBody,\n     outliving_locals: Vec<OutlivedLocal>,\n+    mods: Modifiers,\n }\n \n #[derive(Debug)]\n@@ -248,6 +216,13 @@ enum Anchor {\n #[derive(Debug)]\n struct ControlFlow {\n     kind: Option<FlowKind>,\n+    is_async: bool,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct Modifiers {\n+    is_const: bool,\n+    is_in_tail: bool,\n }\n \n /// Control flow that is exported from extracted function\n@@ -605,13 +580,11 @@ impl FunctionBody {\n     fn analyze(\n         &self,\n         sema: &Semantics<RootDatabase>,\n-    ) -> (FxIndexSet<Local>, bool, Option<ast::SelfParam>) {\n+    ) -> (FxIndexSet<Local>, Option<ast::SelfParam>) {\n         // FIXME: currently usages inside macros are not found\n-        let mut has_await = false;\n         let mut self_param = None;\n         let mut res = FxIndexSet::default();\n         self.walk_expr(&mut |expr| {\n-            has_await |= matches!(expr, ast::Expr::AwaitExpr(_));\n             let name_ref = match expr {\n                 ast::Expr::PathExpr(path_expr) => {\n                     path_expr.path().and_then(|it| it.as_single_name_ref())\n@@ -644,7 +617,60 @@ impl FunctionBody {\n                 }\n             }\n         });\n-        (res, has_await, self_param)\n+        (res, self_param)\n+    }\n+\n+    fn analyze_container(&self) -> Option<Modifiers> {\n+        let mut is_const = false;\n+        let container_expr = self.parent()?.ancestors().find_map(|it| {\n+            // double Option as we want to short circuit\n+            let res = match_ast! {\n+                match it {\n+                    ast::ClosureExpr(closure) => closure.body(),\n+                    ast::EffectExpr(effect) => {\n+                        is_const = effect.const_token().is_some();\n+                        effect.block_expr().map(ast::Expr::BlockExpr)\n+                    },\n+                    ast::Fn(fn_) => {\n+                        is_const = fn_.const_token().is_some();\n+                        fn_.body().map(ast::Expr::BlockExpr)\n+                    },\n+                    ast::Static(statik) => {\n+                        is_const = true;\n+                        statik.body()\n+                    },\n+                    ast::ConstArg(ca) => {\n+                        is_const = true;\n+                        ca.expr()\n+                    },\n+                    ast::Const(konst) => {\n+                        is_const = true;\n+                        konst.body()\n+                    },\n+                    ast::ConstParam(cp) => {\n+                        is_const = true;\n+                        cp.default_val()\n+                    },\n+                    ast::ConstBlockPat(cbp) => {\n+                        is_const = true;\n+                        cbp.block_expr().map(ast::Expr::BlockExpr)\n+                    },\n+                    ast::Variant(__) => None,\n+                    ast::Meta(__) => None,\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        })??;\n+        let container_tail = match container_expr {\n+            ast::Expr::BlockExpr(block) => block.tail_expr(),\n+            expr => Some(expr),\n+        };\n+        let is_in_tail =\n+            container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n+                container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n+            });\n+        Some(Modifiers { is_in_tail, is_const })\n     }\n \n     fn return_ty(&self, ctx: &AssistContext) -> Option<RetType> {\n@@ -673,6 +699,7 @@ impl FunctionBody {\n         let mut try_expr = None;\n         let mut break_expr = None;\n         let mut continue_expr = None;\n+        let mut is_async = false;\n \n         let mut loop_depth = 0;\n \n@@ -703,6 +730,7 @@ impl FunctionBody {\n                 ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n                     continue_expr = Some(it);\n                 }\n+                ast::Expr::AwaitExpr(_) => is_async = true,\n                 _ => {}\n             }\n             false\n@@ -746,7 +774,7 @@ impl FunctionBody {\n             (None, None, None, None) => None,\n         };\n \n-        Some(ControlFlow { kind })\n+        Some(ControlFlow { kind, is_async })\n     }\n     /// find variables that should be extracted as params\n     ///\n@@ -1031,12 +1059,7 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n-fn make_call(\n-    ctx: &AssistContext,\n-    fun: &Function,\n-    indent: IndentLevel,\n-    body_contains_await: bool,\n-) -> String {\n+fn make_call(ctx: &AssistContext, fun: &Function, indent: IndentLevel) -> String {\n     let ret_ty = fun.return_type(ctx);\n \n     let args = fun.params.iter().map(|param| param.to_arg(ctx));\n@@ -1053,6 +1076,8 @@ fn make_call(\n \n     let expr = handler.make_call_expr(call_expr).indent(indent);\n \n+    let mut_modifier = |var: &OutlivedLocal| if var.mut_usage_outside_body { \"mut \" } else { \"\" };\n+\n     let mut buf = String::new();\n     match fun.outliving_locals.as_slice() {\n         [] => {}\n@@ -1068,18 +1093,18 @@ fn make_call(\n             buf.push_str(\") = \");\n         }\n     }\n-    fn mut_modifier(var: &OutlivedLocal) -> &'static str {\n-        if var.mut_usage_outside_body {\n-            \"mut \"\n-        } else {\n-            \"\"\n-        }\n-    }\n     format_to!(buf, \"{}\", expr);\n-    if body_contains_await {\n+    if fun.control_flow.is_async {\n         buf.push_str(\".await\");\n     }\n-    if fun.ret_ty.is_unit() && (!fun.outliving_locals.is_empty() || !expr.is_block_like()) {\n+    let insert_comma = fun\n+        .body\n+        .parent()\n+        .and_then(ast::MatchArm::cast)\n+        .map_or(false, |it| it.comma_token().is_none());\n+    if insert_comma {\n+        buf.push(',');\n+    } else if fun.ret_ty.is_unit() && (!fun.outliving_locals.is_empty() || !expr.is_block_like()) {\n         buf.push(';');\n     }\n     buf\n@@ -1209,17 +1234,32 @@ fn format_function(\n     fun: &Function,\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n-    body_contains_await: bool,\n-    in_tail: bool,\n ) -> String {\n     let mut fn_def = String::new();\n     let params = fun.make_param_list(ctx, module);\n-    let ret_ty = fun.make_ret_ty(ctx, module, in_tail);\n-    let body = make_body(ctx, old_indent, new_indent, fun, in_tail);\n-    let async_kw = if body_contains_await { \"async \" } else { \"\" };\n+    let ret_ty = fun.make_ret_ty(ctx, module);\n+    let body = make_body(ctx, old_indent, new_indent, fun);\n+    let const_kw = if fun.mods.is_const { \"const \" } else { \"\" };\n+    let async_kw = if fun.control_flow.is_async { \"async \" } else { \"\" };\n     match ctx.config.snippet_cap {\n-        Some(_) => format_to!(fn_def, \"\\n\\n{}{}fn $0{}{}\", new_indent, async_kw, fun.name, params),\n-        None => format_to!(fn_def, \"\\n\\n{}{}fn {}{}\", new_indent, async_kw, fun.name, params),\n+        Some(_) => format_to!(\n+            fn_def,\n+            \"\\n\\n{}{}{}fn $0{}{}\",\n+            new_indent,\n+            const_kw,\n+            async_kw,\n+            fun.name,\n+            params\n+        ),\n+        None => format_to!(\n+            fn_def,\n+            \"\\n\\n{}{}{}fn {}{}\",\n+            new_indent,\n+            const_kw,\n+            async_kw,\n+            fun.name,\n+            params\n+        ),\n     }\n     if let Some(ret_ty) = ret_ty {\n         format_to!(fn_def, \" {}\", ret_ty);\n@@ -1236,15 +1276,13 @@ impl Function {\n         make::param_list(self_param, params)\n     }\n \n-    fn make_ret_ty(\n-        &self,\n-        ctx: &AssistContext,\n-        module: hir::Module,\n-        in_tail: bool,\n-    ) -> Option<ast::RetType> {\n+    fn make_ret_ty(&self, ctx: &AssistContext, module: hir::Module) -> Option<ast::RetType> {\n         let fun_ty = self.return_type(ctx);\n-        let handler =\n-            if in_tail { FlowHandler::None } else { FlowHandler::from_ret_ty(self, &fun_ty) };\n+        let handler = if self.mods.is_in_tail {\n+            FlowHandler::None\n+        } else {\n+            FlowHandler::from_ret_ty(self, &fun_ty)\n+        };\n         let ret_ty = match &handler {\n             FlowHandler::None => {\n                 if matches!(fun_ty, FunType::Unit) {\n@@ -1312,10 +1350,13 @@ fn make_body(\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n     fun: &Function,\n-    in_tail: bool,\n ) -> ast::BlockExpr {\n     let ret_ty = fun.return_type(ctx);\n-    let handler = if in_tail { FlowHandler::None } else { FlowHandler::from_ret_ty(fun, &ret_ty) };\n+    let handler = if fun.mods.is_in_tail {\n+        FlowHandler::None\n+    } else {\n+        FlowHandler::from_ret_ty(fun, &ret_ty)\n+    };\n     let block = match &fun.body {\n         FunctionBody::Expr(expr) => {\n             let expr = rewrite_body_segment(ctx, &fun.params, &handler, expr.syntax());\n@@ -3929,6 +3970,44 @@ fn $0fun_name() -> Result<(), i64> {\n     Result::<i32, i64>::Ok(0)?;\n     Ok(())\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_knows_const() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+const fn foo() {\n+    $0()$0\n+}\n+\"#,\n+            r#\"\n+const fn foo() {\n+    fun_name();\n+}\n+\n+const fn $0fun_name() {\n+    ()\n+}\n+\"#,\n+        );\n+        check_assist(\n+            extract_function,\n+            r#\"\n+const FOO: () = {\n+    $0()$0\n+};\n+\"#,\n+            r#\"\n+const FOO: () = {\n+    fun_name();\n+};\n+\n+const fn $0fun_name() {\n+    ()\n+}\n \"#,\n         );\n     }"}]}