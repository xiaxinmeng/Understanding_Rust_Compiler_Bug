{"sha": "ff58efb2b26e395f2887dad2f904aee26da3dc13", "node_id": "C_kwDOAAsO6NoAKGZmNThlZmIyYjI2ZTM5NWYyODg3ZGFkMmY5MDRhZWUyNmRhM2RjMTM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-04T04:13:31Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-04T04:13:31Z"}, "message": "Better detect when a field can be moved from in `while_let_on_iterator`", "tree": {"sha": "9d76ddcf68ed75e9afb3537b47436a30c2232562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d76ddcf68ed75e9afb3537b47436a30c2232562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff58efb2b26e395f2887dad2f904aee26da3dc13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff58efb2b26e395f2887dad2f904aee26da3dc13", "html_url": "https://github.com/rust-lang/rust/commit/ff58efb2b26e395f2887dad2f904aee26da3dc13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff58efb2b26e395f2887dad2f904aee26da3dc13/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ea77847fee93e51957e51a4480ef31a04602a7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea77847fee93e51957e51a4480ef31a04602a7a", "html_url": "https://github.com/rust-lang/rust/commit/3ea77847fee93e51957e51a4480ef31a04602a7a"}], "stats": {"total": 111, "additions": 100, "deletions": 11}, "files": [{"sha": "942d6ca6b4a3afa06d22c8a029d8d6bfd014dbed", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ff58efb2b26e395f2887dad2f904aee26da3dc13/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff58efb2b26e395f2887dad2f904aee26da3dc13/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=ff58efb2b26e395f2887dad2f904aee26da3dc13", "patch": "@@ -8,12 +8,13 @@ use clippy_utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_middle::ty::adjustment::Adjust;\n+use rustc_span::{symbol::sym, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n+    let (scrutinee_expr, iter_expr_struct, iter_expr, some_pat, loop_expr) = if_chain! {\n         if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n         if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n@@ -27,7 +28,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // get the loop containing the match expression\n         if !uses_iter(cx, &iter_expr_struct, if_then);\n         then {\n-            (let_expr, iter_expr_struct, some_pat, expr)\n+            (let_expr, iter_expr_struct, iter_expr, some_pat, expr)\n         } else {\n             return;\n         }\n@@ -47,7 +48,11 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     // If the iterator is a field or the iterator is accessed after the loop is complete it needs to be\n     // borrowed mutably. TODO: If the struct can be partially moved from and the struct isn't used\n     // afterwards a mutable borrow of a field isn't necessary.\n-    let by_ref = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n+    let by_ref = if cx.typeck_results().expr_ty(iter_expr).ref_mutability() == Some(Mutability::Mut)\n+        || !iter_expr_struct.can_move\n+        || !iter_expr_struct.fields.is_empty()\n+        || needs_mutable_borrow(cx, &iter_expr_struct, loop_expr)\n+    {\n         \".by_ref()\"\n     } else {\n         \"\"\n@@ -67,26 +72,36 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n \n #[derive(Debug)]\n struct IterExpr {\n-    /// The span of the whole expression, not just the path and fields stored here.\n-    span: Span,\n     /// The fields used, in order of child to parent.\n     fields: Vec<Symbol>,\n     /// The path being used.\n     path: Res,\n+    /// Whether or not the iterator can be moved.\n+    can_move: bool,\n }\n \n /// Parses any expression to find out which field of which variable is used. Will return `None` if\n /// the expression might have side effects.\n fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n-    let span = e.span;\n     let mut fields = Vec::new();\n+    let mut can_move = true;\n     loop {\n+        if cx\n+            .typeck_results()\n+            .expr_adjustments(e)\n+            .iter()\n+            .any(|a| matches!(a.kind, Adjust::Deref(Some(..))))\n+        {\n+            // Custom deref impls need to borrow the whole value as it's captured by reference\n+            can_move = false;\n+            fields.clear();\n+        }\n         match e.kind {\n             ExprKind::Path(ref path) => {\n                 break Some(IterExpr {\n-                    span,\n                     fields,\n                     path: cx.qpath_res(path, e.hir_id),\n+                    can_move,\n                 });\n             },\n             ExprKind::Field(base, name) => {\n@@ -99,10 +114,12 @@ fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExp\n             // Shouldn't have side effects, but there's no way to trace which field is used. So forget which fields have\n             // already been seen.\n             ExprKind::Index(base, idx) if !idx.can_have_side_effects() => {\n+                can_move = false;\n                 fields.clear();\n                 e = base;\n             },\n             ExprKind::Unary(UnOp::Deref, base) => {\n+                can_move = false;\n                 fields.clear();\n                 e = base;\n             },"}, {"sha": "cb8892a3f009bdb99bbbc5c2ba6d4b3e4e02558e", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff58efb2b26e395f2887dad2f904aee26da3dc13/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ff58efb2b26e395f2887dad2f904aee26da3dc13/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=ff58efb2b26e395f2887dad2f904aee26da3dc13", "patch": "@@ -372,6 +372,36 @@ fn exact_match_with_single_field() {\n     }\n }\n \n+fn custom_deref() {\n+    struct S1<T> {\n+        x: T,\n+    }\n+    struct S2<T>(S1<T>);\n+    impl<T> core::ops::Deref for S2<T> {\n+        type Target = S1<T>;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<T> core::ops::DerefMut for S2<T> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            &mut self.0\n+        }\n+    }\n+\n+    let mut s = S2(S1 { x: 0..10 });\n+    for x in s.x.by_ref() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn issue_8113() {\n+    let mut x = [0..10];\n+    for x in x[0].by_ref() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     for _ in it {"}, {"sha": "d91571844959e1439fbc743d300fd037812c68f9", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff58efb2b26e395f2887dad2f904aee26da3dc13/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff58efb2b26e395f2887dad2f904aee26da3dc13/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=ff58efb2b26e395f2887dad2f904aee26da3dc13", "patch": "@@ -372,6 +372,36 @@ fn exact_match_with_single_field() {\n     }\n }\n \n+fn custom_deref() {\n+    struct S1<T> {\n+        x: T,\n+    }\n+    struct S2<T>(S1<T>);\n+    impl<T> core::ops::Deref for S2<T> {\n+        type Target = S1<T>;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<T> core::ops::DerefMut for S2<T> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            &mut self.0\n+        }\n+    }\n+\n+    let mut s = S2(S1 { x: 0..10 });\n+    while let Some(x) = s.x.next() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn issue_8113() {\n+    let mut x = [0..10];\n+    while let Some(x) = x[0].next() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     while let Some(..) = it.next() {"}, {"sha": "fb2b0f2467c0d115924aa232f40e8d6b6706d3ef", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff58efb2b26e395f2887dad2f904aee26da3dc13/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff58efb2b26e395f2887dad2f904aee26da3dc13/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=ff58efb2b26e395f2887dad2f904aee26da3dc13", "patch": "@@ -123,10 +123,22 @@ LL |     while let Some(x) = it.0.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:377:5\n+  --> $DIR/while_let_on_iterator.rs:393:5\n+   |\n+LL |     while let Some(x) = s.x.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in s.x.by_ref()`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:400:5\n+   |\n+LL |     while let Some(x) = x[0].next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in x[0].by_ref()`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:407:5\n    |\n LL |     while let Some(..) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 23 previous errors\n "}]}