{"sha": "569596573a2f90d52c7f7610d8c7c637dc587f0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2OTU5NjU3M2EyZjkwZDUyYzdmNzYxMGQ4YzdjNjM3ZGM1ODdmMGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-28T18:27:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-05T09:36:02Z"}, "message": "Compute a ty::method for methods that appear in impls as well", "tree": {"sha": "c717329b162919aafda417fbf672405fe5806737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c717329b162919aafda417fbf672405fe5806737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/569596573a2f90d52c7f7610d8c7c637dc587f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/569596573a2f90d52c7f7610d8c7c637dc587f0a", "html_url": "https://github.com/rust-lang/rust/commit/569596573a2f90d52c7f7610d8c7c637dc587f0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/569596573a2f90d52c7f7610d8c7c637dc587f0a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "007abe935209ab35d85e1b7fa0bfc88460340560", "url": "https://api.github.com/repos/rust-lang/rust/commits/007abe935209ab35d85e1b7fa0bfc88460340560", "html_url": "https://github.com/rust-lang/rust/commit/007abe935209ab35d85e1b7fa0bfc88460340560"}], "stats": {"total": 168, "additions": 89, "deletions": 79}, "files": [{"sha": "598539609e9ebb7930aa8b8abef3e1aa5567df15", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/569596573a2f90d52c7f7610d8c7c637dc587f0a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/569596573a2f90d52c7f7610d8c7c637dc587f0a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=569596573a2f90d52c7f7610d8c7c637dc587f0a", "patch": "@@ -714,18 +714,19 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                   tcx: ty::ctxt) -> ty::method\n {\n     let method_doc = lookup_item(id, cdata.data);\n+    let def_id = item_def_id(method_doc, cdata);\n+    let name = item_name(intr, method_doc);\n     let bounds = item_ty_param_bounds(method_doc, tcx, cdata,\n                                       tag_item_method_tps);\n-    let name = item_name(intr, method_doc);\n-    let def_id = item_def_id(method_doc, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n+    let vis = item_visibility(method_doc);\n     let self_ty = get_self_ty(method_doc);\n     ty::method {\n         ident: name,\n         tps: bounds,\n         fty: fty,\n         self_ty: self_ty,\n-        vis: ast::public,\n+        vis: vis,\n         def_id: def_id\n     }\n }"}, {"sha": "2e3008a0cdc88d60184015ef255eac1da8e362f7", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/569596573a2f90d52c7f7610d8c7c637dc587f0a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/569596573a2f90d52c7f7610d8c7c637dc587f0a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=569596573a2f90d52c7f7610d8c7c637dc587f0a", "patch": "@@ -562,21 +562,36 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n+fn encode_method_ty_fields(ecx: @EncodeContext,\n+                           ebml_w: writer::Encoder,\n+                           method_ty: &ty::method)\n+{\n+    encode_def_id(ebml_w, method_ty.def_id);\n+    encode_name(ecx, ebml_w, method_ty.ident);\n+    encode_ty_type_param_bounds(ebml_w, ecx, method_ty.tps,\n+                                tag_item_method_tps);\n+    encode_method_fty(ecx, ebml_w, &method_ty.fty);\n+    encode_visibility(ebml_w, method_ty.vis);\n+    encode_self_type(ebml_w, method_ty.self_ty);\n+}\n+\n fn encode_info_for_method(ecx: @EncodeContext,\n                           ebml_w: writer::Encoder,\n                           impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n                           parent_id: node_id,\n                           m: @method,\n-                          parent_visibility: ast::visibility,\n                           owner_generics: &ast::Generics,\n                           method_generics: &ast::Generics) {\n     debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n            *ecx.tcx.sess.str_of(m.ident),\n            owner_generics.ty_params.len(),\n            method_generics.ty_params.len());\n     ebml_w.start_tag(tag_items_data_item);\n-    encode_def_id(ebml_w, local_def(m.id));\n+\n+    let method_def_id = local_def(m.id);\n+    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n+    encode_method_ty_fields(ecx, ebml_w, method_ty);\n \n     match m.self_ty.node {\n         ast::sty_static => {\n@@ -592,16 +607,7 @@ fn encode_info_for_method(ecx: @EncodeContext,\n     encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n \n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n-    encode_name(ecx, ebml_w, m.ident);\n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n-    encode_self_type(ebml_w, m.self_ty.node);\n-\n-    // Combine parent visibility and this visibility.\n-    let visibility = match m.vis {\n-        ast::inherited => parent_visibility,\n-        vis => vis,\n-    };\n-    encode_visibility(ebml_w, visibility);\n \n     if len > 0u || should_inline {\n         (ecx.encode_inlined_item)(\n@@ -610,6 +616,7 @@ fn encode_info_for_method(ecx: @EncodeContext,\n     } else {\n         encode_symbol(ecx, ebml_w, m.id);\n     }\n+\n     ebml_w.end_tag();\n }\n \n@@ -863,17 +870,6 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         let mut impl_path = vec::append(~[], path);\n         impl_path += ~[ast_map::path_name(item.ident)];\n \n-        // If there is a trait reference, treat the methods as always public.\n-        // This is to work around some incorrect behavior in privacy checking:\n-        // when the method belongs to a trait, it should acquire the privacy\n-        // from the trait, not the impl. Forcing the visibility to be public\n-        // makes things sorta work.\n-        let parent_visibility = if opt_trait.is_some() {\n-            ast::public\n-        } else {\n-            item.vis\n-        };\n-\n         for methods.each |m| {\n             index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx,\n@@ -882,7 +878,6 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                    should_inline(m.attrs),\n                                    item.id,\n                                    *m,\n-                                   parent_visibility,\n                                    generics,\n                                    &m.generics);\n         }\n@@ -909,11 +904,6 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n-        //\n-        // Note: for the moment, the data structures here are *slightly*\n-        // different from those expected by `encode_info_for_method()`,\n-        // but I do plan to refactor this later in this patch to avoid the\n-        // duplication.\n         for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n             assert!(method_def_id.crate == ast::local_crate);\n \n@@ -923,9 +913,13 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n \n             ebml_w.start_tag(tag_items_data_item);\n \n-            encode_def_id(ebml_w, method_def_id);\n+            encode_method_ty_fields(ecx, ebml_w, method_ty);\n+\n             encode_parent_item(ebml_w, local_def(item.id));\n-            encode_name(ecx, ebml_w, method_ty.ident);\n+\n+            let mut trait_path = vec::append(~[], path);\n+            trait_path.push(ast_map::path_name(item.ident));\n+            encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n \n             match method_ty.self_ty {\n                 sty_static => {\n@@ -946,15 +940,6 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 }\n             }\n \n-            encode_ty_type_param_bounds(ebml_w, ecx, method_ty.tps,\n-                                        tag_item_method_tps);\n-            encode_method_fty(ecx, ebml_w, &method_ty.fty);\n-            encode_visibility(ebml_w, method_ty.vis);\n-            encode_self_type(ebml_w, method_ty.self_ty);\n-            let mut trait_path = vec::append(~[], path);\n-            trait_path.push(ast_map::path_name(item.ident));\n-            encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n-\n             match ms[i] {\n                 required(_) => {\n                     encode_method_sort(ebml_w, 'r');"}, {"sha": "3ac3766e89da4f2dcb47cfe387903660ea6acf5f", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/569596573a2f90d52c7f7610d8c7c637dc587f0a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/569596573a2f90d52c7f7610d8c7c637dc587f0a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=569596573a2f90d52c7f7610d8c7c637dc587f0a", "patch": "@@ -315,7 +315,6 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                 ty: ty});\n     }\n \n-\n     fn ty_method_of_trait_method(self: &CrateCtxt,\n                                  trait_rp: Option<ty::region_variance>,\n                                  trait_generics: &ast::Generics,\n@@ -336,8 +335,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                         AbiSet::Rust(),\n                                         &m_generics.lifetimes,\n                                         m_decl),\n-            // assume public, because this is only invoked on trait methods\n             self_ty: m_self_ty.node,\n+            // assume public, because this is only invoked on trait methods\n             vis: ast::public,\n             def_id: local_def(*m_id)\n         }\n@@ -599,7 +598,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n }\n \n pub struct ConvertedMethod {\n-    mty: ty::method,\n+    mty: @ty::method,\n     id: ast::node_id,\n     span: span,\n     body_id: ast::node_id\n@@ -609,13 +608,15 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                        ms: &[@ast::method],\n                        rp: Option<ty::region_variance>,\n                        rcvr_bounds: @~[ty::param_bounds],\n-                       rcvr_generics: &ast::Generics)\n-                    -> ~[ConvertedMethod] {\n-\n+                       rcvr_generics: &ast::Generics,\n+                       rcvr_visibility: ast::visibility)\n+                    -> ~[ConvertedMethod]\n+{\n     let tcx = ccx.tcx;\n-    do vec::map(ms) |m| {\n+    return vec::map(ms, |m| {\n         let bounds = ty_param_bounds(ccx, &m.generics);\n-        let mty = ty_of_method(ccx, *m, rp, rcvr_generics, &m.generics);\n+        let mty = @ty_of_method(ccx, *m, rp, rcvr_generics,\n+                                rcvr_visibility, &m.generics);\n         let fty = ty::mk_bare_fn(tcx, copy mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n@@ -628,8 +629,34 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                 ty: fty\n             });\n         write_ty_to_tcx(tcx, m.id, fty);\n+        tcx.methods.insert(mty.def_id, mty);\n         ConvertedMethod {mty: mty, id: m.id,\n                          span: m.span, body_id: m.body.node.id}\n+    });\n+\n+    fn ty_of_method(ccx: &CrateCtxt,\n+                    m: @ast::method,\n+                    rp: Option<ty::region_variance>,\n+                    rcvr_generics: &ast::Generics,\n+                    rcvr_visibility: ast::visibility,\n+                    method_generics: &ast::Generics) -> ty::method\n+    {\n+        let rscope = MethodRscope::new(m.self_ty.node,\n+                                       rp,\n+                                       rcvr_generics);\n+        ty::method {\n+            ident: m.ident,\n+            tps: ty_param_bounds(ccx, &m.generics),\n+            fty: astconv::ty_of_bare_fn(ccx,\n+                                        &rscope,\n+                                        m.purity,\n+                                        ast::RustAbi,\n+                                        &method_generics.lifetimes,\n+                                        &m.decl),\n+            self_ty: m.self_ty.node,\n+            vis: m.vis.inherit_from(rcvr_visibility),\n+            def_id: local_def(m.id)\n+        }\n     }\n }\n \n@@ -665,7 +692,7 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n                                generics,\n                                rp);\n       }\n-      ast::item_impl(ref generics, trait_ref, selfty, ref ms) => {\n+      ast::item_impl(ref generics, opt_trait_ref, selfty, ref ms) => {\n         let i_bounds = ty_param_bounds(ccx, generics);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n@@ -677,9 +704,20 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n                             region_param: rp,\n                             ty: selfty});\n \n-        // XXX: Bad copy of `ms` below.\n-        let cms = convert_methods(ccx, *ms, rp, i_bounds, generics);\n-        for trait_ref.each |t| {\n+        // If there is a trait reference, treat the methods as always public.\n+        // This is to work around some incorrect behavior in privacy checking:\n+        // when the method belongs to a trait, it should acquire the privacy\n+        // from the trait, not the impl. Forcing the visibility to be public\n+        // makes things sorta work.\n+        let parent_visibility = if opt_trait_ref.is_some() {\n+            ast::public\n+        } else {\n+            it.vis\n+        };\n+\n+        let cms = convert_methods(ccx, *ms, rp, i_bounds, generics,\n+                                  parent_visibility);\n+        for opt_trait_ref.each |t| {\n             check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n         }\n       }\n@@ -694,7 +732,8 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n         let (_, provided_methods) =\n             split_trait_methods(*trait_methods);\n         let (bounds, _) = mk_substs(ccx, generics, rp);\n-        let _ = convert_methods(ccx, provided_methods, rp, bounds, generics);\n+        let _ = convert_methods(ccx, provided_methods, rp, bounds, generics,\n+                                it.vis);\n       }\n       ast::item_struct(struct_def, ref generics) => {\n         ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n@@ -794,30 +833,6 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: @ast::foreign_item) {\n     ccx.tcx.tcache.insert(local_def(i.id), tpt);\n }\n \n-pub fn ty_of_method(ccx: &CrateCtxt,\n-                    m: @ast::method,\n-                    rp: Option<ty::region_variance>,\n-                    rcvr_generics: &ast::Generics,\n-                    method_generics: &ast::Generics)\n-                 -> ty::method {\n-    let rscope = MethodRscope::new(m.self_ty.node,\n-                                   rp,\n-                                   rcvr_generics);\n-    ty::method {\n-        ident: m.ident,\n-        tps: ty_param_bounds(ccx, &m.generics),\n-        fty: astconv::ty_of_bare_fn(ccx,\n-                                    &rscope,\n-                                    m.purity,\n-                                    AbiSet::Rust(),\n-                                    &method_generics.lifetimes,\n-                                    &m.decl),\n-        self_ty: m.self_ty.node,\n-        vis: m.vis,\n-        def_id: local_def(m.id)\n-    }\n-}\n-\n /*\n   Instantiates the path for the given trait reference, assuming that\n   it's bound to a valid trait type. Returns the def_id for the defining"}, {"sha": "4a0e58b09c8a8f71c19b2018b0c050bc8fecfeb0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/569596573a2f90d52c7f7610d8c7c637dc587f0a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/569596573a2f90d52c7f7610d8c7c637dc587f0a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=569596573a2f90d52c7f7610d8c7c637dc587f0a", "patch": "@@ -1186,6 +1186,15 @@ pub struct trait_ref {\n #[deriving(Eq)]\n pub enum visibility { public, private, inherited }\n \n+impl visibility {\n+    fn inherit_from(&self, parent_visibility: visibility) -> visibility {\n+        match self {\n+            &inherited => parent_visibility,\n+            &public | &private => *self\n+        }\n+    }\n+}\n+\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]"}]}