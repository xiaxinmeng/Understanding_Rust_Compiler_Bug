{"sha": "62f0fc51126795848fff540e9776ee331753344d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZjBmYzUxMTI2Nzk1ODQ4ZmZmNTQwZTk3NzZlZTMzMTc1MzM0NGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-24T16:08:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-24T19:12:50Z"}, "message": "port the relate-types code from NLL type-check into a type-op\n\nAdd regression tests for #55219 and #55241\n\nAlso another test where a duplicate-like error appears to have been\nsuppressed; I'm not 100% sure why this output changes, though I could\nimagine that some duplicate suppression is enabled by this PR.", "tree": {"sha": "26c14b71735b6ead1b31fedd0badaeb79ff38d00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26c14b71735b6ead1b31fedd0badaeb79ff38d00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62f0fc51126795848fff540e9776ee331753344d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62f0fc51126795848fff540e9776ee331753344d", "html_url": "https://github.com/rust-lang/rust/commit/62f0fc51126795848fff540e9776ee331753344d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62f0fc51126795848fff540e9776ee331753344d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c8887ccbf7104e98ead7539f3cfbd42332b5e4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8887ccbf7104e98ead7539f3cfbd42332b5e4d", "html_url": "https://github.com/rust-lang/rust/commit/7c8887ccbf7104e98ead7539f3cfbd42332b5e4d"}], "stats": {"total": 372, "additions": 244, "deletions": 128}, "files": [{"sha": "0e4c94aaaf3942e31755f00f6eb8d13b90e23491", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fc51126795848fff540e9776ee331753344d/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fc51126795848fff540e9776ee331753344d/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=62f0fc51126795848fff540e9776ee331753344d", "patch": "@@ -142,6 +142,28 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace(expected, actual).eq(&expected, &actual)\n     }\n \n+    pub fn relate<T>(\n+        self,\n+        expected: T,\n+        variance: ty::Variance,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        match variance {\n+            ty::Variance::Covariant => self.sub(expected, actual),\n+            ty::Variance::Invariant => self.eq(expected, actual),\n+            ty::Variance::Contravariant => self.sup(expected, actual),\n+\n+            // We could make this make sense but it's not readily\n+            // exposed and I don't feel like dealing with it. Note\n+            // that bivariance in general does a bit more than just\n+            // *nothing*, it checks that the types are the same\n+            // \"modulo variance\" basically.\n+            ty::Variance::Bivariant => panic!(\"Bivariant given to `relate()`\"),\n+        }\n+    }\n+\n     /// Compute the least-upper-bound, or mutual supertype, of two\n     /// values. The order of the arguments doesn't matter, but since\n     /// this can result in an error (e.g., if asked to compute LUB of"}, {"sha": "b3955b8f864e55f96cc0c51619372c03e1084a4f", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fc51126795848fff540e9776ee331753344d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fc51126795848fff540e9776ee331753344d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=62f0fc51126795848fff540e9776ee331753344d", "patch": "@@ -9,24 +9,27 @@\n // except according to those terms.\n \n use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n-use mir::UserTypeAnnotation;\n use traits::query::Fallible;\n+use hir::def_id::DefId;\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use ty::subst::UserSubsts;\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct AscribeUserType<'tcx> {\n     pub mir_ty: Ty<'tcx>,\n     pub variance: ty::Variance,\n-    pub user_ty: UserTypeAnnotation<'tcx>,\n+    pub def_id: DefId,\n+    pub user_substs: UserSubsts<'tcx>,\n }\n \n impl<'tcx> AscribeUserType<'tcx> {\n     pub fn new(\n         mir_ty: Ty<'tcx>,\n         variance: ty::Variance,\n-        user_ty: UserTypeAnnotation<'tcx>,\n+        def_id: DefId,\n+        user_substs: UserSubsts<'tcx>,\n     ) -> Self {\n-        AscribeUserType { mir_ty, variance, user_ty }\n+        AscribeUserType { mir_ty, variance, def_id, user_substs }\n     }\n }\n \n@@ -56,19 +59,19 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for AscribeUserType<'tcx>\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for AscribeUserType<'tcx> {\n-        mir_ty, variance, user_ty\n+        mir_ty, variance, def_id, user_substs\n     }\n }\n \n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for AscribeUserType<'a> {\n         type Lifted = AscribeUserType<'tcx>;\n-        mir_ty, variance, user_ty\n+        mir_ty, variance, def_id, user_substs\n     }\n }\n \n impl_stable_hash_for! {\n     struct AscribeUserType<'tcx> {\n-        mir_ty, variance, user_ty\n+        mir_ty, variance, def_id, user_substs\n     }\n }"}, {"sha": "bbbe02fda6a84dd145035e0e6331b5117d3b100a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 15, "deletions": 99, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fc51126795848fff540e9776ee331753344d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fc51126795848fff540e9776ee331753344d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=62f0fc51126795848fff540e9776ee331753344d", "patch": "@@ -42,7 +42,7 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, Substs, UnpackedKind, UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use std::rc::Rc;\n use std::{fmt, iter};\n@@ -975,127 +975,43 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        let tcx = self.tcx();\n-\n         debug!(\n-            \"relate_type_and_user_type(a={:?}, v={:?}, b={:?}, locations={:?})\",\n-            a, v, user_ty, locations\n+            \"relate_type_and_user_type(a={:?}, v={:?}, user_ty={:?}, locations={:?})\",\n+            a, v, user_ty, locations,\n         );\n \n-        // The `TypeRelating` code assumes that \"unresolved inference\n-        // variables\" appear in the \"a\" side, so flip `Contravariant`\n-        // ambient variance to get the right relationship.\n-        let v1 = ty::Contravariant.xform(v);\n-\n         match user_ty {\n             UserTypeAnnotation::Ty(canonical_ty) => {\n                 let (ty, _) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n \n-                self.relate_types(ty, v1, a, locations, category)?;\n+                // The `TypeRelating` code assumes that \"unresolved inference\n+                // variables\" appear in the \"a\" side, so flip `Contravariant`\n+                // ambient variance to get the right relationship.\n+                let v1 = ty::Contravariant.xform(v);\n \n-                self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+                self.relate_types(ty, v1, a, locations, category)?;\n             }\n             UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n                 let (\n-                    UserSubsts {\n-                        substs,\n-                        user_self_ty,\n-                    },\n+                    user_substs,\n                     _,\n                 ) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n \n-                let ty = self.tcx().type_of(def_id);\n-                let ty = ty.subst(tcx, substs);\n-                debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n-                let ty = self.normalize(ty, locations);\n-\n-                self.relate_types(ty, v1, a, locations, category)?;\n-\n-                if let Some(UserSelfTy {\n-                    impl_def_id,\n-                    self_ty,\n-                }) = user_self_ty\n-                {\n-                    let impl_self_ty = tcx.type_of(impl_def_id);\n-                    let impl_self_ty = impl_self_ty.subst(tcx, &substs);\n-                    let impl_self_ty = self.normalize(impl_self_ty, locations);\n-\n-                    // There may be type variables in `substs` and hence\n-                    // in `impl_self_ty`, but they should all have been\n-                    // resolved to some fixed value during the first call\n-                    // to `relate`, above. Therefore, if we use\n-                    // `resolve_type_vars_if_possible` we should get to\n-                    // something without type variables. This is important\n-                    // because the `b` type in `relate_with_variance`\n-                    // below is not permitted to have inference variables.\n-                    let impl_self_ty = self.infcx.resolve_type_vars_if_possible(&impl_self_ty);\n-                    assert!(!impl_self_ty.has_infer_types());\n-\n-                    self.eq_types(self_ty, impl_self_ty, locations, category)?;\n-\n-                    self.prove_predicate(\n-                        ty::Predicate::WellFormed(impl_self_ty),\n-                        locations,\n-                        category,\n-                    );\n-                }\n-\n-                // Prove the predicates coming along with `def_id`.\n-                //\n-                // Also, normalize the `instantiated_predicates`\n-                // because otherwise we wind up with duplicate \"type\n-                // outlives\" error messages.\n-                let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-                let instantiated_predicates = self.fold_to_region_vid(instantiated_predicates);\n-                self.normalize_and_prove_instantiated_predicates(\n-                    instantiated_predicates,\n+                self.fully_perform_op(\n                     locations,\n-                );\n-\n-                // In addition to proving the predicates, we have to\n-                // prove that `ty` is well-formed -- this is because\n-                // the WF of `ty` is predicated on the substs being\n-                // well-formed, and we haven't proven *that*. We don't\n-                // want to prove the WF of types from  `substs` directly because they\n-                // haven't been normalized.\n-                //\n-                // FIXME(nmatsakis): Well, perhaps we should normalize\n-                // them?  This would only be relevant if some input\n-                // type were ill-formed but did not appear in `ty`,\n-                // which...could happen with normalization...\n-                self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+                    category,\n+                    self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n+                        a, v, def_id, user_substs,\n+                    )),\n+                )?;\n             }\n         }\n \n         Ok(())\n     }\n \n-    /// Replace all free regions in `value` with their NLL `RegionVid`\n-    /// equivalents; if not in NLL, does nothing. This is never\n-    /// particularly necessary -- we'll do it lazilly as we process\n-    /// the value anyway -- but in some specific cases it is useful to\n-    /// normalize so we can suppress duplicate error messages.\n-    fn fold_to_region_vid<T>(&self, value: T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if let Some(borrowck_context) = &self.borrowck_context {\n-            self.tcx().fold_regions(&value, &mut false, |r, _debruijn| {\n-                if r.has_free_regions() {\n-                    self.tcx().mk_region(ty::RegionKind::ReVar(\n-                        borrowck_context.universal_regions.to_region_vid(r),\n-                    ))\n-                } else {\n-                    r\n-                }\n-            })\n-        } else {\n-            value\n-        }\n-    }\n-\n     fn eq_opaque_type_and_type(\n         &mut self,\n         revealed_ty: Ty<'tcx>,"}, {"sha": "cf274a9c8510576d51570c8c0feba0805600834e", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 147, "deletions": 5, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fc51126795848fff540e9776ee331753344d/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fc51126795848fff540e9776ee331753344d/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=62f0fc51126795848fff540e9776ee331753344d", "patch": "@@ -8,20 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::infer::at::ToTrace;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::infer::InferCtxt;\n+use rustc::hir::def_id::DefId;\n use rustc::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc::traits::query::type_op::eq::Eq;\n use rustc::traits::query::type_op::normalize::Normalize;\n use rustc::traits::query::type_op::prove_predicate::ProvePredicate;\n use rustc::traits::query::type_op::subtype::Subtype;\n use rustc::traits::query::{Fallible, NoSolution};\n-use rustc::traits::{FulfillmentContext, Normalized, Obligation, ObligationCause, TraitEngine,\n-                    TraitEngineExt};\n+use rustc::traits::{\n+    FulfillmentContext, Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt,\n+};\n use rustc::ty::query::Providers;\n-use rustc::ty::{FnSig, Lift, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::subst::{Kind, Subst, UserSelfTy, UserSubsts};\n+use rustc::ty::{\n+    FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n+};\n use rustc_data_structures::sync::Lrc;\n use std::fmt;\n+use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n \n crate fn provide(p: &mut Providers) {\n     *p = Providers {\n@@ -43,12 +51,146 @@ fn type_op_ascribe_user_type<'tcx>(\n ) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, ()>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n-            let (param_env, AscribeUserType { mir_ty, variance, user_ty }) = key.into_parts();\n-            drop((infcx, fulfill_cx, param_env, mir_ty, variance, user_ty));\n+            let (\n+                param_env,\n+                AscribeUserType {\n+                    mir_ty,\n+                    variance,\n+                    def_id,\n+                    user_substs,\n+                },\n+            ) = key.into_parts();\n+\n+            debug!(\n+                \"type_op_ascribe_user_type(\\\n+                 mir_ty={:?}, variance={:?}, def_id={:?}, user_substs={:?}\\\n+                 )\",\n+                mir_ty, variance, def_id, user_substs,\n+            );\n+\n+            let mut cx = AscribeUserTypeCx {\n+                infcx,\n+                param_env,\n+                fulfill_cx,\n+            };\n+            cx.relate_mir_and_user_ty(mir_ty, variance, def_id, user_substs)?;\n+\n             Ok(())\n         })\n }\n \n+struct AscribeUserTypeCx<'me, 'gcx: 'tcx, 'tcx: 'me> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    fulfill_cx: &'me mut FulfillmentContext<'tcx>,\n+}\n+\n+impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n+    fn normalize<T>(&mut self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx\n+            .partially_normalize_associated_types_in(\n+                DUMMY_SP,\n+                ast::CRATE_NODE_ID,\n+                self.param_env,\n+                &value,\n+            )\n+            .into_value_registering_obligations(self.infcx, self.fulfill_cx)\n+    }\n+\n+    fn relate<T>(&mut self, a: T, variance: Variance, b: T) -> Result<(), NoSolution>\n+    where\n+        T: ToTrace<'tcx>,\n+    {\n+        Ok(self.infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+           .relate(a, variance, b)?\n+           .into_value_registering_obligations(self.infcx, self.fulfill_cx))\n+    }\n+\n+    fn prove_predicate(&mut self, predicate: Predicate<'tcx>) {\n+        self.fulfill_cx.register_predicate_obligation(\n+            self.infcx,\n+            Obligation::new(ObligationCause::dummy(), self.param_env, predicate),\n+        );\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn subst<T>(&self, value: T, substs: &[Kind<'tcx>]) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        value.subst(self.tcx(), substs)\n+    }\n+\n+    fn relate_mir_and_user_ty(\n+        &mut self,\n+        mir_ty: Ty<'tcx>,\n+        variance: Variance,\n+        def_id: DefId,\n+        user_substs: UserSubsts<'tcx>,\n+    ) -> Result<(), NoSolution> {\n+        let UserSubsts {\n+            substs,\n+            user_self_ty,\n+        } = user_substs;\n+\n+        let ty = self.tcx().type_of(def_id);\n+        let ty = self.subst(ty, substs);\n+        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n+        let ty = self.normalize(ty);\n+\n+        self.relate(mir_ty, variance, ty)?;\n+\n+        if let Some(UserSelfTy {\n+            impl_def_id,\n+            self_ty,\n+        }) = user_self_ty\n+        {\n+            let impl_self_ty = self.tcx().type_of(impl_def_id);\n+            let impl_self_ty = self.subst(impl_self_ty, &substs);\n+            let impl_self_ty = self.normalize(impl_self_ty);\n+\n+            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n+\n+            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n+        }\n+\n+        // Prove the predicates coming along with `def_id`.\n+        //\n+        // Also, normalize the `instantiated_predicates`\n+        // because otherwise we wind up with duplicate \"type\n+        // outlives\" error messages.\n+        let instantiated_predicates = self.tcx()\n+            .predicates_of(def_id)\n+            .instantiate(self.tcx(), substs);\n+        for instantiated_predicate in instantiated_predicates.predicates {\n+            let instantiated_predicate = self.normalize(instantiated_predicate);\n+            self.prove_predicate(instantiated_predicate);\n+        }\n+\n+        // In addition to proving the predicates, we have to\n+        // prove that `ty` is well-formed -- this is because\n+        // the WF of `ty` is predicated on the substs being\n+        // well-formed, and we haven't proven *that*. We don't\n+        // want to prove the WF of types from  `substs` directly because they\n+        // haven't been normalized.\n+        //\n+        // FIXME(nmatsakis): Well, perhaps we should normalize\n+        // them?  This would only be relevant if some input\n+        // type were ill-formed but did not appear in `ty`,\n+        // which...could happen with normalization...\n+        self.prove_predicate(Predicate::WellFormed(ty));\n+\n+        Ok(())\n+    }\n+}\n+\n fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,"}, {"sha": "7daa5a59b997746e63246a42d52923c38917c828", "filename": "src/test/ui/nll/user-annotations/issue-55219.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fc51126795848fff540e9776ee331753344d/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55219.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fc51126795848fff540e9776ee331753344d/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55219.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55219.rs?ref=62f0fc51126795848fff540e9776ee331753344d", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #55219:\n+//\n+// The `Self::HASH_LEN` here expands to a \"self-type\" where `T` is not\n+// known. This unbound inference variable was causing an ICE.\n+//\n+// run-pass\n+\n+#![feature(nll)]\n+\n+pub struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    const HASH_LEN: usize = 20;\n+\n+    fn stuff() {\n+        let _ = Self::HASH_LEN;\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "e5600803df85676e5361fc653ffff0a54023618e", "filename": "src/test/ui/nll/user-annotations/issue-55241.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fc51126795848fff540e9776ee331753344d/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fc51126795848fff540e9776ee331753344d/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs?ref=62f0fc51126795848fff540e9776ee331753344d", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for #55241:\n+//\n+// The reference to `C::HASHED_NULL_NODE` resulted in a type like `<C\n+// as NodeCodec<_>>::Out`; normalizing this type requires knowing the\n+// value of `_`; solving that requires having normalized, so we can\n+// test against `C: NodeCodec<H>` in the environment.\n+//\n+// run-pass\n+\n+#![feature(nll)]\n+\n+pub trait Hasher {\n+    type Out: Eq;\n+}\n+\n+pub trait NodeCodec<H: Hasher> {\n+    const HASHED_NULL_NODE: H::Out;\n+}\n+\n+pub trait Trie<H: Hasher, C: NodeCodec<H>> {\n+    /// Return the root of the trie.\n+    fn root(&self) -> &H::Out;\n+\n+    /// Is the trie empty?\n+    fn is_empty(&self) -> bool { *self.root() == C::HASHED_NULL_NODE }\n+}\n+\n+fn main() { }"}, {"sha": "39f193c55f77aab8e43e336dfd95c196c2f96569", "filename": "src/test/ui/regions/regions-free-region-ordering-caller1.nll.stderr", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fc51126795848fff540e9776ee331753344d/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fc51126795848fff540e9776ee331753344d/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr?ref=62f0fc51126795848fff540e9776ee331753344d", "patch": "@@ -12,21 +12,6 @@ LL |     let z: &'a & usize = &(&y);\n LL | }\n    | - temporary value is freed at the end of this statement\n \n-error[E0597]: `y` does not live long enough\n-  --> $DIR/regions-free-region-ordering-caller1.rs:19:27\n-   |\n-LL | fn call1<'a>(x: &'a usize) {\n-   |          -- lifetime `'a` defined here\n-...\n-LL |     let z: &'a & usize = &(&y);\n-   |            -----------    ^^^^ borrowed value does not live long enough\n-   |            |\n-   |            type annotation requires that `y` is borrowed for `'a`\n-...\n-LL | }\n-   | - `y` dropped here while still borrowed\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0597, E0716.\n-For more information about an error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0716`."}]}