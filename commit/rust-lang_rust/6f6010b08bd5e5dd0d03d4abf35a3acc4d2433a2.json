{"sha": "6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "node_id": "C_kwDOAAsO6NoAKDZmNjAxMGIwOGJkNWU1ZGQwZDAzZDRhYmYzNWEzYWNjNGQyNDMzYTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-25T09:33:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-25T09:33:57Z"}, "message": "Auto merge of #102254 - matthiaskrgr:rollup-gitu6li, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #102016 (implied_bounds: deal with inference vars)\n - #102161 (Resolve async fn signature even without body (e.g., in trait))\n - #102216 (rustdoc: Stabilize --diagnostic-width)\n - #102240 (rustdoc: remove unused CSS `#main-content > .line-numbers`)\n - #102242 (rustdoc: remove unused CSS `.summary`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "336160a858e310de9df5845078d9cfec9e266f12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/336160a858e310de9df5845078d9cfec9e266f12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "html_url": "https://github.com/rust-lang/rust/commit/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e9c93df464b7ada3fc7a1c8ccddd9dcb24ee0a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9c93df464b7ada3fc7a1c8ccddd9dcb24ee0a0", "html_url": "https://github.com/rust-lang/rust/commit/8e9c93df464b7ada3fc7a1c8ccddd9dcb24ee0a0"}, {"sha": "c6870ccc5ce454aef260fe63ef76d8b9eab86ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6870ccc5ce454aef260fe63ef76d8b9eab86ac0", "html_url": "https://github.com/rust-lang/rust/commit/c6870ccc5ce454aef260fe63ef76d8b9eab86ac0"}], "stats": {"total": 267, "additions": 187, "deletions": 80}, "files": [{"sha": "9922b156ebf96d0c5765f6d192a4e0be058c580a", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -53,6 +53,7 @@ pub struct OutlivesEnvironment<'tcx> {\n }\n \n /// Builder of OutlivesEnvironment.\n+#[derive(Debug)]\n struct OutlivesEnvironmentBuilder<'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     region_relation: TransitiveRelationBuilder<Region<'tcx>>,\n@@ -109,6 +110,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n \n impl<'a, 'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     #[inline]\n+    #[instrument(level = \"debug\")]\n     fn build(self) -> OutlivesEnvironment<'tcx> {\n         OutlivesEnvironment {\n             param_env: self.param_env,"}, {"sha": "558db003867d29e8d42e526943a9f6f8b1dcd9d6", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -805,7 +805,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             sig.decl.has_self(),\n                             sig.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n                             &sig.decl.output,\n-                        )\n+                        );\n+\n+                        this.record_lifetime_params_for_async(\n+                            fn_id,\n+                            sig.header.asyncness.opt_return_id(),\n+                        );\n                     },\n                 );\n                 return;\n@@ -847,41 +852,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             },\n                         );\n \n-                        // Construct the list of in-scope lifetime parameters for async lowering.\n-                        // We include all lifetime parameters, either named or \"Fresh\".\n-                        // The order of those parameters does not matter, as long as it is\n-                        // deterministic.\n-                        if let Some((async_node_id, _)) = async_node_id {\n-                            let mut extra_lifetime_params = this\n-                                .r\n-                                .extra_lifetime_params_map\n-                                .get(&fn_id)\n-                                .cloned()\n-                                .unwrap_or_default();\n-                            for rib in this.lifetime_ribs.iter().rev() {\n-                                extra_lifetime_params.extend(\n-                                    rib.bindings\n-                                        .iter()\n-                                        .map(|(&ident, &(node_id, res))| (ident, node_id, res)),\n-                                );\n-                                match rib.kind {\n-                                    LifetimeRibKind::Item => break,\n-                                    LifetimeRibKind::AnonymousCreateParameter {\n-                                        binder, ..\n-                                    } => {\n-                                        if let Some(earlier_fresh) =\n-                                            this.r.extra_lifetime_params_map.get(&binder)\n-                                        {\n-                                            extra_lifetime_params.extend(earlier_fresh);\n-                                        }\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-                            this.r\n-                                .extra_lifetime_params_map\n-                                .insert(async_node_id, extra_lifetime_params);\n-                        }\n+                        this.record_lifetime_params_for_async(fn_id, async_node_id);\n \n                         if let Some(body) = body {\n                             // Ignore errors in function bodies if this is rustdoc\n@@ -3926,6 +3897,36 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             Some((ident.name, ns)),\n         )\n     }\n+\n+    /// Construct the list of in-scope lifetime parameters for async lowering.\n+    /// We include all lifetime parameters, either named or \"Fresh\".\n+    /// The order of those parameters does not matter, as long as it is\n+    /// deterministic.\n+    fn record_lifetime_params_for_async(\n+        &mut self,\n+        fn_id: NodeId,\n+        async_node_id: Option<(NodeId, Span)>,\n+    ) {\n+        if let Some((async_node_id, _)) = async_node_id {\n+            let mut extra_lifetime_params =\n+                self.r.extra_lifetime_params_map.get(&fn_id).cloned().unwrap_or_default();\n+            for rib in self.lifetime_ribs.iter().rev() {\n+                extra_lifetime_params.extend(\n+                    rib.bindings.iter().map(|(&ident, &(node_id, res))| (ident, node_id, res)),\n+                );\n+                match rib.kind {\n+                    LifetimeRibKind::Item => break,\n+                    LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n+                        if let Some(earlier_fresh) = self.r.extra_lifetime_params_map.get(&binder) {\n+                            extra_lifetime_params.extend(earlier_fresh);\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            self.r.extra_lifetime_params_map.insert(async_node_id, extra_lifetime_params);\n+        }\n+    }\n }\n \n struct LifetimeCountVisitor<'a, 'b> {"}, {"sha": "3008dfcadde9e3c7eccd56081bd06a34b7f36ee1", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'cx, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'cx, 'tcx> {\n     ///   Note that this may cause outlives obligations to be injected\n     ///   into the inference context with this body-id.\n     /// - `ty`, the type that we are supposed to assume is WF.\n-    #[instrument(level = \"debug\", skip(self, param_env, body_id))]\n+    #[instrument(level = \"debug\", skip(self, param_env, body_id), ret)]\n     fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -71,6 +71,7 @@ impl<'a, 'cx, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'cx, 'tcx> {\n         let TypeOpOutput { output, constraints, .. } = result;\n \n         if let Some(constraints) = constraints {\n+            debug!(?constraints);\n             // Instantiation may have produced new inference variables and constraints on those\n             // variables. Process these constraints.\n             let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(self.tcx);"}, {"sha": "691b79f10533dd813579d7a9afa72c76b647ce00", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -49,7 +49,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n     let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n     let mut wf_args = vec![ty.into()];\n \n-    let mut implied_bounds = vec![];\n+    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n+        vec![];\n \n     let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n \n@@ -65,41 +66,28 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n+        //\n+        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n+        // bounds can be backward incompatible, e.g. #101951 was caused by\n+        // us not dealing with inference vars in `TypeOutlives` predicates.\n         let obligations = wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n             .unwrap_or_default();\n \n-        // N.B., all of these predicates *ought* to be easily proven\n-        // true. In fact, their correctness is (mostly) implied by\n-        // other parts of the program. However, in #42552, we had\n-        // an annoying scenario where:\n-        //\n-        // - Some `T::Foo` gets normalized, resulting in a\n-        //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-        //   (not sure why it couldn't immediately get\n-        //   solved). This result of `_1` got cached.\n-        // - These obligations were dropped on the floor here,\n-        //   rather than being registered.\n-        // - Then later we would get a request to normalize\n-        //   `T::Foo` which would result in `_1` being used from\n-        //   the cache, but hence without the `T: Trait<Foo=_1>`\n-        //   constraint. As a result, `_1` never gets resolved,\n-        //   and we get an ICE (in dropck).\n-        //\n-        // Therefore, we register any predicates involving\n-        // inference variables. We restrict ourselves to those\n-        // involving inference variables both for efficiency and\n-        // to avoids duplicate errors that otherwise show up.\n+        // While these predicates should all be implied by other parts of\n+        // the program, they are still relevant as they may constrain\n+        // inference variables, which is necessary to add the correct\n+        // implied bounds in some cases, mostly when dealing with projections.\n         fulfill_cx.register_predicate_obligations(\n             infcx,\n             obligations.iter().filter(|o| o.predicate.has_infer_types_or_consts()).cloned(),\n         );\n \n         // From the full set of obligations, just filter down to the\n         // region relationships.\n-        implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+        outlives_bounds.extend(obligations.into_iter().filter_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate.kind().no_bound_vars() {\n-                None => vec![],\n+                None => None,\n                 Some(pred) => match pred {\n                     ty::PredicateKind::Trait(..)\n                     | ty::PredicateKind::Subtype(..)\n@@ -109,21 +97,18 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => vec![],\n+                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                     ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);\n-                        vec![]\n+                        None\n                     }\n \n                     ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n-                        vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n+                        Some(ty::OutlivesPredicate(r_a.into(), r_b))\n                     }\n \n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        let ty_a = infcx.resolve_vars_if_possible(ty_a);\n-                        let mut components = smallvec![];\n-                        push_outlives_components(tcx, ty_a, &mut components);\n-                        implied_bounds_from_components(r_b, components)\n+                        Some(ty::OutlivesPredicate(ty_a.into(), r_b))\n                     }\n                 },\n             }\n@@ -133,9 +118,27 @@ fn compute_implied_outlives_bounds<'tcx>(\n     // Ensure that those obligations that we had to solve\n     // get solved *here*.\n     match fulfill_cx.select_all_or_error(infcx).as_slice() {\n-        [] => Ok(implied_bounds),\n-        _ => Err(NoSolution),\n+        [] => (),\n+        _ => return Err(NoSolution),\n     }\n+\n+    // We lazily compute the outlives components as\n+    // `select_all_or_error` constrains inference variables.\n+    let implied_bounds = outlives_bounds\n+        .into_iter()\n+        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n+            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n+            ty::GenericArgKind::Type(ty_a) => {\n+                let ty_a = infcx.resolve_vars_if_possible(ty_a);\n+                let mut components = smallvec![];\n+                push_outlives_components(tcx, ty_a, &mut components);\n+                implied_bounds_from_components(r_b, components)\n+            }\n+            ty::GenericArgKind::Const(_) => unreachable!(),\n+        })\n+        .collect();\n+\n+    Ok(implied_bounds)\n }\n \n /// When we have an implied bound that `T: 'a`, we can further break"}, {"sha": "ae98a8f6209debdb2321e7ab594ee5955db6705c", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -140,6 +140,7 @@ pub(crate) fn compare_impl_method<'tcx>(\n ///\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n+#[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &AssocItem,"}, {"sha": "c4da1e46009554632cc1f50576df8d58d2b80b82", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -1130,10 +1130,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tfont-size: 1rem;\n }\n \n-.summary {\n-\tpadding-right: 0px;\n-}\n-\n pre.rust .question-mark {\n \tfont-weight: bold;\n }\n@@ -1917,10 +1913,6 @@ in storage.js plus the media query with (min-width: 701px)\n \t\tborder-bottom: 1px solid;\n \t}\n \n-\t#main-content > .line-numbers {\n-\t\tmargin-top: 0;\n-\t}\n-\n \t.notable-traits .notable-traits-tooltiptext {\n \t\tleft: 0;\n \t\ttop: 100%;"}, {"sha": "23ad0c30f21ed752e3c36efb9271460ba6a98a83", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -461,7 +461,7 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"human|json|short\",\n             )\n         }),\n-        unstable(\"diagnostic-width\", |o| {\n+        stable(\"diagnostic-width\", |o| {\n             o.optopt(\n                 \"\",\n                 \"diagnostic-width\","}, {"sha": "290d9db775b73dcdca8f153ba264e90b468c0abf", "filename": "src/test/rustdoc-ui/diagnostic-width.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zunstable-options --diagnostic-width=10\n+// compile-flags: --diagnostic-width=10\n #![deny(rustdoc::bare_urls)]\n \n /// This is a long line that contains a http://link.com"}, {"sha": "f61b34ed99e00b56cad0c4ff3432fbe38bdbc3bf", "filename": "src/test/ui/async-await/in-trait/issue-102138.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fissue-102138.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fissue-102138.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fissue-102138.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -0,0 +1,46 @@\n+// check-pass\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+\n+async fn yield_now() {}\n+\n+trait AsyncIterator {\n+    type Item;\n+    async fn next(&mut self) -> Option<Self::Item>;\n+}\n+\n+struct YieldingRange {\n+    counter: u32,\n+    stop: u32,\n+}\n+\n+impl AsyncIterator for YieldingRange {\n+    type Item = u32;\n+\n+    async fn next(&mut self) -> Option<Self::Item> {\n+        if self.counter == self.stop {\n+            None\n+        } else {\n+            let c = self.counter;\n+            self.counter += 1;\n+            yield_now().await;\n+            Some(c)\n+        }\n+    }\n+}\n+\n+async fn async_main() {\n+    let mut x = YieldingRange { counter: 0, stop: 10 };\n+\n+    while let Some(v) = x.next().await {\n+        println!(\"Hi: {v}\");\n+    }\n+}\n+\n+fn main() {\n+    let _ = async_main();\n+}"}, {"sha": "108fef8a15fb313bf9c698e84e43b85ee0aab48b", "filename": "src/test/ui/implied-bounds/issue-101951.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-101951.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-101951.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-101951.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -0,0 +1,50 @@\n+// Taken directly from that issue.\n+//\n+// This test detected that we didn't correctly resolve\n+// inference variables when computing implied bounds.\n+//\n+// check-pass\n+pub trait BuilderFn<'a> {\n+    type Output;\n+}\n+\n+impl<'a, F, Out> BuilderFn<'a> for F\n+where\n+    F: FnOnce(&'a mut ()) -> Out,\n+{\n+    type Output = Out;\n+}\n+\n+pub trait ConstructionFirm {\n+    type Builder: for<'a> BuilderFn<'a>;\n+}\n+\n+pub trait Campus<T>\n+where\n+    T: ConstructionFirm,\n+{\n+    fn add_building(\n+        &mut self,\n+        building: &mut <<T as ConstructionFirm>::Builder as BuilderFn<'_>>::Output,\n+    );\n+}\n+\n+struct ArchitectsInc {}\n+\n+impl ConstructionFirm for ArchitectsInc {\n+    type Builder = fn(&mut ()) -> PrettyCondo<'_>;\n+}\n+\n+struct PrettyCondo<'a> {\n+    _marker: &'a mut (),\n+}\n+\n+struct CondoEstate {}\n+\n+impl Campus<ArchitectsInc> for CondoEstate {\n+    fn add_building(&mut self, _building: &mut PrettyCondo<'_>) {\n+        todo!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fba4ffa1c6ed2fa7310abec52a133f3c7956b35d", "filename": "src/test/ui/resolve/name-collision-in-trait-fn-sig.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Ftest%2Fui%2Fresolve%2Fname-collision-in-trait-fn-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2/src%2Ftest%2Fui%2Fresolve%2Fname-collision-in-trait-fn-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fname-collision-in-trait-fn-sig.rs?ref=6f6010b08bd5e5dd0d03d4abf35a3acc4d2433a2", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// This is currently stable behavior, which was almost accidentally made an\n+// error in #102161 since there is no test exercising it. I am not sure if\n+// this _should_ be the desired behavior, but at least we should know if it\n+// changes.\n+\n+fn main() {}\n+\n+trait Foo {\n+    fn fn_with_type_named_same_as_local_in_param(b: i32, b: i32);\n+}"}]}