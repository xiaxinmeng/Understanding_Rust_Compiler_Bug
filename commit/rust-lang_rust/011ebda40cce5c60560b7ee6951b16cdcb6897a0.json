{"sha": "011ebda40cce5c60560b7ee6951b16cdcb6897a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMWViZGE0MGNjZTVjNjA1NjBiN2VlNjk1MWIxNmNkY2I2ODk3YTA=", "commit": {"author": {"name": "Jonathan A. Kollasch", "email": "jakllsch@kollasch.net", "date": "2016-12-03T16:55:50Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-12-30T02:30:01Z"}, "message": "Add cabi_sparc64", "tree": {"sha": "0f1872b445bcd6d053e3e584b8ae7f191e195431", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f1872b445bcd6d053e3e584b8ae7f191e195431"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/011ebda40cce5c60560b7ee6951b16cdcb6897a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/011ebda40cce5c60560b7ee6951b16cdcb6897a0", "html_url": "https://github.com/rust-lang/rust/commit/011ebda40cce5c60560b7ee6951b16cdcb6897a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/011ebda40cce5c60560b7ee6951b16cdcb6897a0/comments", "author": {"login": "jakllsch", "id": 2145119, "node_id": "MDQ6VXNlcjIxNDUxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2145119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakllsch", "html_url": "https://github.com/jakllsch", "followers_url": "https://api.github.com/users/jakllsch/followers", "following_url": "https://api.github.com/users/jakllsch/following{/other_user}", "gists_url": "https://api.github.com/users/jakllsch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakllsch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakllsch/subscriptions", "organizations_url": "https://api.github.com/users/jakllsch/orgs", "repos_url": "https://api.github.com/users/jakllsch/repos", "events_url": "https://api.github.com/users/jakllsch/events{/privacy}", "received_events_url": "https://api.github.com/users/jakllsch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "982849535d42a675ba85ad2c07db229e2604fe5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/982849535d42a675ba85ad2c07db229e2604fe5a", "html_url": "https://github.com/rust-lang/rust/commit/982849535d42a675ba85ad2c07db229e2604fe5a"}], "stats": {"total": 188, "additions": 188, "deletions": 0}, "files": [{"sha": "40589a989a53d2dd4c38b15bf10c5be063a181b3", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/011ebda40cce5c60560b7ee6951b16cdcb6897a0/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/011ebda40cce5c60560b7ee6951b16cdcb6897a0/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=011ebda40cce5c60560b7ee6951b16cdcb6897a0", "patch": "@@ -25,6 +25,7 @@ use cabi_mips64;\n use cabi_asmjs;\n use cabi_msp430;\n use cabi_sparc;\n+use cabi_sparc64;\n use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use type_::Type;\n use type_of;\n@@ -608,6 +609,7 @@ impl FnType {\n             \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n             \"msp430\" => cabi_msp430::compute_abi_info(ccx, self),\n             \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n+            \"sparc64\" => cabi_sparc64::compute_abi_info(ccx, self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n "}, {"sha": "e675cca33d1be9576a0b5e009fb39a29f76137b0", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/011ebda40cce5c60560b7ee6951b16cdcb6897a0/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/011ebda40cce5c60560b7ee6951b16cdcb6897a0/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=011ebda40cce5c60560b7ee6951b16cdcb6897a0", "patch": "@@ -0,0 +1,185 @@\n+// Copyright 2014-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: This needs an audit for correctness and completeness.\n+\n+use llvm::{Integer, Pointer, Float, Double, Struct, Vector, Array};\n+use abi::{self, FnType, ArgType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_size(ty: Type) -> usize {\n+    if ty.kind() == Vector {\n+        bug!(\"ty_size: unhandled type\")\n+    } else {\n+        abi::ty_size(ty, 8)\n+    }\n+}\n+\n+fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n+    fn check_array(ty: Type) -> Option<(Type, u64)> {\n+        let len = ty.array_length() as u64;\n+        if len == 0 {\n+            return None\n+        }\n+        let elt = ty.element_type();\n+\n+        // if our element is an HFA/HVA, so are we; multiply members by our len\n+        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n+    }\n+\n+    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n+        let str_tys = ty.field_types();\n+        if str_tys.len() == 0 {\n+            return None\n+        }\n+\n+        let mut prev_base_ty = None;\n+        let mut members = 0;\n+        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n+            match (prev_base_ty, opt_homog_agg) {\n+                // field isn't itself an HFA, so we aren't either\n+                (_, None) => return None,\n+\n+                // first field - store its type and number of members\n+                (None, Some((field_ty, field_members))) => {\n+                    prev_base_ty = Some(field_ty);\n+                    members = field_members;\n+                },\n+\n+                // 2nd or later field - give up if it's a different type; otherwise incr. members\n+                (Some(prev_ty), Some((field_ty, field_members))) => {\n+                    if prev_ty != field_ty {\n+                        return None;\n+                    }\n+                    members += field_members;\n+                }\n+            }\n+        }\n+\n+        // Because of previous checks, we know prev_base_ty is Some(...) because\n+        //   1. str_tys has at least one element; and\n+        //   2. prev_base_ty was filled in (or we would've returned early)\n+        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n+\n+        // Ensure there is no padding.\n+        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n+            Some((base_ty, members))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    let homog_agg = match ty.kind() {\n+        Float  => Some((ty, 1)),\n+        Double => Some((ty, 1)),\n+        Array  => check_array(ty),\n+        Struct => check_struct(ty),\n+        _ => None\n+    };\n+\n+    // Ensure we have at most eight uniquely addressable members\n+    homog_agg.and_then(|(base_ty, members)| {\n+        if members > 0 && members <= 8 {\n+            Some((base_ty, members))\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(64);\n+        return;\n+    }\n+\n+    // don't return aggregates in registers\n+    ret.make_indirect(ccx);\n+\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n+        ret.cast = Some(Type::array(&base_ty, members));\n+        return;\n+    }\n+    let size = ty_size(ret.ty);\n+    if size <= 16 {\n+        let llty = if size <= 1 {\n+            Type::i8(ccx)\n+        } else if size <= 2 {\n+            Type::i16(ccx)\n+        } else if size <= 4 {\n+            Type::i32(ccx)\n+        } else if size <= 8 {\n+            Type::i64(ccx)\n+        } else {\n+            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+        };\n+        ret.cast = Some(llty);\n+        return;\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if is_reg_ty(arg.ty) {\n+        arg.extend_integer_width_to(64);\n+        return;\n+    }\n+\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n+        arg.cast = Some(Type::array(&base_ty, members));\n+        return;\n+    }\n+\n+    arg.cast = Some(struct_ty(ccx, arg.ty));\n+}\n+\n+fn is_reg_ty(ty: Type) -> bool {\n+    match ty.kind() {\n+        Integer\n+        | Pointer\n+        | Float\n+        | Double => true,\n+        _ => false\n+    }\n+}\n+\n+fn coerce_to_long(ccx: &CrateContext, size: usize) -> Vec<Type> {\n+    let long_ty = Type::i64(ccx);\n+    let mut args = Vec::new();\n+\n+    let mut n = size / 64;\n+    while n > 0 {\n+        args.push(long_ty);\n+        n -= 1;\n+    }\n+\n+    let r = size % 64;\n+    if r > 0 {\n+        args.push(Type::ix(ccx, r as u64));\n+    }\n+\n+    args\n+}\n+\n+fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n+    let size = ty_size(ty) * 8;\n+    Type::struct_(ccx, &coerce_to_long(ccx, size), false)\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        classify_arg_ty(ccx, arg);\n+    }\n+}"}, {"sha": "e02b595bf88493b746348e642a1c19e2cade1234", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/011ebda40cce5c60560b7ee6951b16cdcb6897a0/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/011ebda40cce5c60560b7ee6951b16cdcb6897a0/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=011ebda40cce5c60560b7ee6951b16cdcb6897a0", "patch": "@@ -107,6 +107,7 @@ mod cabi_powerpc;\n mod cabi_powerpc64;\n mod cabi_s390x;\n mod cabi_sparc;\n+mod cabi_sparc64;\n mod cabi_x86;\n mod cabi_x86_64;\n mod cabi_x86_win64;"}]}