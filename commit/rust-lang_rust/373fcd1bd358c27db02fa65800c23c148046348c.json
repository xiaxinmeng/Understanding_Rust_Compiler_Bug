{"sha": "373fcd1bd358c27db02fa65800c23c148046348c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3M2ZjZDFiZDM1OGMyN2RiMDJmYTY1ODAwYzIzYzE0ODA0NjM0OGM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-19T04:59:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-19T04:59:59Z"}, "message": "Rollup merge of #37117 - pnkfelix:may-dangle-attr, r=nikomatsakis\n\n`#[may_dangle]` attribute\n\n`#[may_dangle]` attribute\n\nSecond step of #34761. Last big hurdle before we can work in earnest towards Allocator integration (#32838)\n\nNote: I am not clear if this is *also* a syntax-breaking change that needs to be part of a breaking-batch.", "tree": {"sha": "a393e27f916457a59d759606037c59a594b09dcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a393e27f916457a59d759606037c59a594b09dcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/373fcd1bd358c27db02fa65800c23c148046348c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/373fcd1bd358c27db02fa65800c23c148046348c", "html_url": "https://github.com/rust-lang/rust/commit/373fcd1bd358c27db02fa65800c23c148046348c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/373fcd1bd358c27db02fa65800c23c148046348c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e3a72d256d862904703e429499356bfea5cf5e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e3a72d256d862904703e429499356bfea5cf5e8", "html_url": "https://github.com/rust-lang/rust/commit/6e3a72d256d862904703e429499356bfea5cf5e8"}, {"sha": "10a58ac49b7529e39fc2ad823204853f3538d90b", "url": "https://api.github.com/repos/rust-lang/rust/commits/10a58ac49b7529e39fc2ad823204853f3538d90b", "html_url": "https://github.com/rust-lang/rust/commit/10a58ac49b7529e39fc2ad823204853f3538d90b"}], "stats": {"total": 1134, "additions": 1098, "deletions": 36}, "files": [{"sha": "80340f9a9255b1b5f79d32ab756a4250004df0cd", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -401,6 +401,7 @@ impl<'a> LoweringContext<'a> {\n             bounds: self.lower_bounds(&tp.bounds),\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n             span: tp.span,\n+            pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n \n@@ -420,6 +421,7 @@ impl<'a> LoweringContext<'a> {\n         hir::LifetimeDef {\n             lifetime: self.lower_lifetime(&l.lifetime),\n             bounds: self.lower_lifetimes(&l.bounds),\n+            pure_wrt_drop: l.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n "}, {"sha": "6e81c3e700ed2ab47a8350f7a5560602080252d9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -95,6 +95,7 @@ impl fmt::Debug for Lifetime {\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n     pub bounds: HirVec<Lifetime>,\n+    pub pure_wrt_drop: bool,\n }\n \n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n@@ -290,6 +291,7 @@ pub struct TyParam {\n     pub bounds: TyParamBounds,\n     pub default: Option<P<Ty>>,\n     pub span: Span,\n+    pub pure_wrt_drop: bool,\n }\n \n /// Represents lifetimes and type parameters attached to a declaration\n@@ -328,6 +330,36 @@ impl Generics {\n     }\n }\n \n+pub enum UnsafeGeneric {\n+    Region(LifetimeDef, &'static str),\n+    Type(TyParam, &'static str),\n+}\n+\n+impl UnsafeGeneric {\n+    pub fn attr_name(&self) -> &'static str {\n+        match *self {\n+            UnsafeGeneric::Region(_, s) => s,\n+            UnsafeGeneric::Type(_, s) => s,\n+        }\n+    }\n+}\n+\n+impl Generics {\n+    pub fn carries_unsafe_attr(&self) -> Option<UnsafeGeneric> {\n+        for r in &self.lifetimes {\n+            if r.pure_wrt_drop {\n+                return Some(UnsafeGeneric::Region(r.clone(), \"may_dangle\"));\n+            }\n+        }\n+        for t in &self.ty_params {\n+            if t.pure_wrt_drop {\n+                return Some(UnsafeGeneric::Type(t.clone(), \"may_dangle\"));\n+            }\n+        }\n+        return None;\n+    }\n+}\n+\n /// A `where` clause in a definition\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {"}, {"sha": "be6594320244d263811c6c9a8696226ef4da6bbe", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -1231,16 +1231,17 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                          lifetime: hir::Lifetime,\n                          region_names: &HashSet<ast::Name>)\n                          -> hir::HirVec<hir::TyParam> {\n-        ty_params.iter().map(|ty_param| {\n-            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds.clone(),\n+        ty_params.into_iter().map(|ty_param| {\n+            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds,\n                                                       lifetime,\n                                                       region_names);\n             hir::TyParam {\n                 name: ty_param.name,\n                 id: ty_param.id,\n                 bounds: bounds,\n-                default: ty_param.default.clone(),\n+                default: ty_param.default,\n                 span: ty_param.span,\n+                pure_wrt_drop: ty_param.pure_wrt_drop,\n             }\n         }).collect()\n     }\n@@ -1299,8 +1300,11 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                         -> hir::Generics {\n         let mut lifetimes = Vec::new();\n         for lt in add {\n-            lifetimes.push(hir::LifetimeDef { lifetime: *lt,\n-                                              bounds: hir::HirVec::new() });\n+            lifetimes.push(hir::LifetimeDef {\n+                lifetime: *lt,\n+                bounds: hir::HirVec::new(),\n+                pure_wrt_drop: false,\n+            });\n         }\n         for lt in &generics.lifetimes {\n             if keep.contains(&lt.lifetime.name) ||"}, {"sha": "03d0e1e41be2e49033e68f0f666e81fb024a1fc3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -680,6 +680,11 @@ pub struct TypeParameterDef<'tcx> {\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n     pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n+\n+    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n+    /// on generic parameter `T`, asserts data behind the parameter\n+    /// `T` won't be accessed during the parent type's `Drop` impl.\n+    pub pure_wrt_drop: bool,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n@@ -688,6 +693,11 @@ pub struct RegionParameterDef<'tcx> {\n     pub def_id: DefId,\n     pub index: u32,\n     pub bounds: Vec<&'tcx ty::Region>,\n+\n+    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n+    /// on generic parameter `'a`, asserts data of lifetime `'a`\n+    /// won't be accessed during the parent type's `Drop` impl.\n+    pub pure_wrt_drop: bool,\n }\n \n impl<'tcx> RegionParameterDef<'tcx> {\n@@ -732,6 +742,14 @@ impl<'tcx> Generics<'tcx> {\n     pub fn count(&self) -> usize {\n         self.parent_count() + self.own_count()\n     }\n+\n+    pub fn region_param(&self, param: &EarlyBoundRegion) -> &RegionParameterDef<'tcx> {\n+        &self.regions[param.index as usize - self.has_self as usize]\n+    }\n+\n+    pub fn type_param(&self, param: &ParamTy) -> &TypeParameterDef<'tcx> {\n+        &self.types[param.idx as usize - self.has_self as usize - self.regions.len()]\n+    }\n }\n \n /// Bounds on generics."}, {"sha": "49683c634692c324f7497d449e04cb15d54461da", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -716,6 +716,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             default: self.default.fold_with(folder),\n             default_def_id: self.default_def_id,\n             object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n+            pure_wrt_drop: self.pure_wrt_drop,\n         }\n     }\n \n@@ -754,6 +755,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n             def_id: self.def_id,\n             index: self.index,\n             bounds: self.bounds.fold_with(folder),\n+            pure_wrt_drop: self.pure_wrt_drop,\n         }\n     }\n "}, {"sha": "5e2b49bac1b2fb6619a843cbc2038d4369ad65b7", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 157, "deletions": 18, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -71,7 +71,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n-    self_type_did: DefId) -> Result<(), ()>\n+    self_type_did: DefId)\n+    -> Result<(), ()>\n {\n     let tcx = ccx.tcx;\n     let drop_impl_node_id = tcx.map.as_local_node_id(drop_impl_did).unwrap();\n@@ -123,7 +124,9 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n-    self_to_impl_substs: &Substs<'tcx>) -> Result<(), ()> {\n+    self_to_impl_substs: &Substs<'tcx>)\n+    -> Result<(), ()>\n+{\n \n     // Here is an example, analogous to that from\n     // `compare_impl_method`.\n@@ -350,7 +353,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n     cx: &mut DropckContext<'a, 'b, 'gcx, 'tcx>,\n     context: TypeContext,\n     ty: Ty<'tcx>,\n-    depth: usize) -> Result<(), Error<'tcx>>\n+    depth: usize)\n+    -> Result<(), Error<'tcx>>\n {\n     let tcx = cx.rcx.tcx;\n     // Issue #22443: Watch out for overflow. While we are careful to\n@@ -402,16 +406,27 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n     // unbounded type parameter `T`, we must resume the recursive\n     // analysis on `T` (since it would be ignored by\n     // type_must_outlive).\n-    if has_dtor_of_interest(tcx, ty) {\n-        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}ty: {} - is a dtorck type!\",\n-               (0..depth).map(|_| ' ').collect::<String>(),\n-               ty);\n-\n-        cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                 ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n-\n-        return Ok(());\n+    let dropck_kind = has_dtor_of_interest(tcx, ty);\n+    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+            ty: {:?} dropck_kind: {:?}\", ty, dropck_kind);\n+    match dropck_kind {\n+        DropckKind::NoBorrowedDataAccessedInMyDtor => {\n+            // The maximally blind attribute.\n+        }\n+        DropckKind::BorrowedDataMustStrictlyOutliveSelf => {\n+            cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n+                                     ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n+            return Ok(());\n+        }\n+        DropckKind::RevisedSelf(revised_ty) => {\n+            cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n+                                     revised_ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n+            // Do not return early from this case; we want\n+            // to recursively process the internal structure of Self\n+            // (because even though the Drop for Self has been asserted\n+            //  safe, the types instantiated for the generics of Self\n+            //  may themselves carry dropck constraints.)\n+        }\n     }\n \n     debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n@@ -492,16 +507,140 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum DropckKind<'tcx> {\n+    /// The \"safe\" kind; i.e. conservatively assume any borrow\n+    /// accessed by dtor, and therefore such data must strictly\n+    /// outlive self.\n+    ///\n+    /// Equivalent to RevisedTy with no change to the self type.\n+    BorrowedDataMustStrictlyOutliveSelf,\n+\n+    /// The nearly completely-unsafe kind.\n+    ///\n+    /// Equivalent to RevisedSelf with *all* parameters remapped to ()\n+    /// (maybe...?)\n+    NoBorrowedDataAccessedInMyDtor,\n+\n+    /// Assume all borrowed data access by dtor occurs as if Self has the\n+    /// type carried by this variant. In practice this means that some\n+    /// of the type parameters are remapped to `()` (and some lifetime\n+    /// parameters remapped to `'static`), because the developer has asserted\n+    /// that the destructor will not access their contents.\n+    RevisedSelf(Ty<'tcx>),\n+}\n+\n+/// Returns the classification of what kind of check should be applied\n+/// to `ty`, which may include a revised type where some of the type\n+/// parameters are re-mapped to `()` to reflect the destructor's\n+/// \"purity\" with respect to their actual contents.\n fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        ty: Ty<'tcx>) -> bool {\n+                                        ty: Ty<'tcx>)\n+                                        -> DropckKind<'tcx> {\n     match ty.sty {\n-        ty::TyAdt(def, _) => {\n-            def.is_dtorck(tcx)\n+        ty::TyAdt(adt_def, substs) => {\n+            if !adt_def.is_dtorck(tcx) {\n+                return DropckKind::NoBorrowedDataAccessedInMyDtor;\n+            }\n+\n+            // Find the `impl<..> Drop for _` to inspect any\n+            // attributes attached to the impl's generics.\n+            let dtor_method = adt_def.destructor()\n+                .expect(\"dtorck type without destructor impossible\");\n+            let method = tcx.impl_or_trait_item(dtor_method);\n+            let impl_id: DefId = method.container().id();\n+            let revised_ty = revise_self_ty(tcx, adt_def, impl_id, substs);\n+            return DropckKind::RevisedSelf(revised_ty);\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n-            true\n+            return DropckKind::BorrowedDataMustStrictlyOutliveSelf;\n         },\n-        _ => false\n+        _ => {\n+            return DropckKind::NoBorrowedDataAccessedInMyDtor;\n+        }\n     }\n }\n+\n+// Constructs new Ty just like the type defined by `adt_def` coupled\n+// with `substs`, except each type and lifetime parameter marked as\n+// `#[may_dangle]` in the Drop impl (identified by `impl_id`) is\n+// respectively mapped to `()` or `'static`.\n+//\n+// For example: If the `adt_def` maps to:\n+//\n+//   enum Foo<'a, X, Y> { ... }\n+//\n+// and the `impl_id` maps to:\n+//\n+//   impl<#[may_dangle] 'a, X, #[may_dangle] Y> Drop for Foo<'a, X, Y> { ... }\n+//\n+// then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n+fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  adt_def: ty::AdtDef<'tcx>,\n+                                  impl_id: DefId,\n+                                  substs: &Substs<'tcx>)\n+                                  -> Ty<'tcx> {\n+    // Get generics for `impl Drop` to query for `#[may_dangle]` attr.\n+    let impl_bindings = tcx.lookup_generics(impl_id);\n+\n+    // Get Substs attached to Self on `impl Drop`; process in parallel\n+    // with `substs`, replacing dangling entries as appropriate.\n+    let self_substs = {\n+        let impl_self_ty: Ty<'tcx> = tcx.lookup_item_type(impl_id).ty;\n+        if let ty::TyAdt(self_adt_def, self_substs) = impl_self_ty.sty {\n+            assert_eq!(adt_def, self_adt_def);\n+            self_substs\n+        } else {\n+            bug!(\"Self in `impl Drop for _` must be an Adt.\");\n+        }\n+    };\n+\n+    // Walk `substs` + `self_substs`, build new substs appropriate for\n+    // `adt_def`; each non-dangling param reuses entry from `substs`.\n+    //\n+    // Note: The manner we map from a right-hand side (i.e. Region or\n+    // Ty) for a given `def` to generic parameter associated with that\n+    // right-hand side is tightly coupled to `Drop` impl constraints.\n+    //\n+    // E.g. we know such a Ty must be `TyParam`, because a destructor\n+    // for `struct Foo<X>` is defined via `impl<Y> Drop for Foo<Y>`,\n+    // and never by (for example) `impl<Z> Drop for Foo<Vec<Z>>`.\n+    let substs = Substs::for_item(\n+        tcx,\n+        adt_def.did,\n+        |def, _| {\n+            let r_orig = substs.region_for_def(def);\n+            let impl_self_orig = self_substs.region_for_def(def);\n+            let r = if let ty::Region::ReEarlyBound(ref ebr) = *impl_self_orig {\n+                if impl_bindings.region_param(ebr).pure_wrt_drop {\n+                    tcx.mk_region(ty::ReStatic)\n+                } else {\n+                    r_orig\n+                }\n+            } else {\n+                bug!(\"substs for an impl must map regions to ReEarlyBound\");\n+            };\n+            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} to {:?}\",\n+                   def, r_orig, r);\n+            r\n+        },\n+        |def, _| {\n+            let t_orig = substs.type_for_def(def);\n+            let impl_self_orig = self_substs.type_for_def(def);\n+            let t = if let ty::TypeVariants::TyParam(ref pt) = impl_self_orig.sty {\n+                if impl_bindings.type_param(pt).pure_wrt_drop {\n+                    tcx.mk_nil()\n+                } else {\n+                    t_orig\n+                }\n+            } else {\n+                bug!(\"substs for an impl must map types to TyParam\");\n+            };\n+            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} {:?} to {:?} {:?}\",\n+                   def, t_orig, t_orig.sty, t, t.sty);\n+            t\n+        });\n+\n+    return tcx.mk_adt(adt_def, &substs);\n+}"}, {"sha": "cca6c884306725c1342e72df83ca5df3b75e4363", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -13,7 +13,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::hir::intravisit;\n-use rustc::hir;\n+use rustc::hir::{self, Unsafety};\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut orphan = UnsafetyChecker { tcx: tcx };\n@@ -27,6 +27,7 @@ struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     fn check_unsafety_coherence(&mut self,\n                                 item: &'v hir::Item,\n+                                impl_generics: Option<&hir::Generics>,\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n         match self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id)) {\n@@ -47,33 +48,44 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n \n             Some(trait_ref) => {\n                 let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n-                match (trait_def.unsafety, unsafety, polarity) {\n-                    (hir::Unsafety::Unsafe, hir::Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n+                let unsafe_attr = impl_generics.and_then(|g| g.carries_unsafe_attr());\n+                match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n+                    (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0198,\n                                   \"negative implementations are not unsafe\");\n                     }\n \n-                    (hir::Unsafety::Normal, hir::Unsafety::Unsafe, _) => {\n+                    (Unsafety::Normal, None, Unsafety::Unsafe, _) => {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0199,\n                                   \"implementing the trait `{}` is not unsafe\",\n                                   trait_ref);\n                     }\n \n-                    (hir::Unsafety::Unsafe, hir::Unsafety::Normal, hir::ImplPolarity::Positive) => {\n+                    (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0200,\n                                   \"the trait `{}` requires an `unsafe impl` declaration\",\n                                   trait_ref);\n                     }\n \n-                    (hir::Unsafety::Unsafe, hir::Unsafety::Normal, hir::ImplPolarity::Negative) |\n-                    (hir::Unsafety::Unsafe, hir::Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n-                    (hir::Unsafety::Normal, hir::Unsafety::Normal, _) => {\n+                    (Unsafety::Normal, Some(g), Unsafety::Normal, hir::ImplPolarity::Positive) =>\n+                    {\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0569,\n+                                  \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n+                                  g.attr_name());\n+                    }\n+\n+                    (_, _, Unsafety::Normal, hir::ImplPolarity::Negative) |\n+                    (Unsafety::Unsafe, _, Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n+                    (Unsafety::Normal, Some(_), Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n+                    (Unsafety::Normal, None, Unsafety::Normal, _) => {\n                         // OK\n                     }\n                 }\n@@ -86,10 +98,10 @@ impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemDefaultImpl(unsafety, _) => {\n-                self.check_unsafety_coherence(item, unsafety, hir::ImplPolarity::Positive);\n+                self.check_unsafety_coherence(item, None, unsafety, hir::ImplPolarity::Positive);\n             }\n-            hir::ItemImpl(unsafety, polarity, ..) => {\n-                self.check_unsafety_coherence(item, unsafety, polarity);\n+            hir::ItemImpl(unsafety, polarity, ref generics, ..) => {\n+                self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n             }\n             _ => {}\n         }"}, {"sha": "6e47f4ed8c6be5377805af332ded522cef221672", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -1482,6 +1482,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             default_def_id: tcx.map.local_def_id(parent),\n                             default: None,\n                             object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+                            pure_wrt_drop: false,\n                         };\n                         tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n                         opt_self = Some(def);\n@@ -1526,7 +1527,8 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 def_id: tcx.map.local_def_id(l.lifetime.id),\n                 bounds: l.bounds.iter().map(|l| {\n                     ast_region_to_region(tcx, l)\n-                }).collect()\n+                }).collect(),\n+                pure_wrt_drop: l.pure_wrt_drop,\n             }\n         }).collect::<Vec<_>>();\n \n@@ -1926,6 +1928,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n+        pure_wrt_drop: param.pure_wrt_drop,\n     };\n \n     if def.name == keywords::SelfType.name() {"}, {"sha": "16f915c0011cb1dd28f02501bfa52a89deff4fbf", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -2819,6 +2819,26 @@ not a distinct static type. Likewise, it's not legal to attempt to\n behavior for specific enum variants.\n \"##,\n \n+E0569: r##\"\n+If an impl has a generic parameter with the `#[may_dangle]` attribute, then\n+that impl must be declared as an `unsafe impl. For example:\n+\n+```compile_fail,E0569\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+struct Foo<X>(X);\n+impl<#[may_dangle] X> Drop for Foo<X> {\n+    fn drop(&mut self) { }\n+}\n+```\n+\n+In this example, we are asserting that the destructor for `Foo` will not\n+access any data of type `X`, and require this assertion to be true for\n+overall safety in our program. The compiler does not currently attempt to\n+verify this assertion; therefore we must tag this `impl` as unsafe.\n+\"##,\n+\n E0318: r##\"\n Default impls for a trait must be located in the same crate where the trait was\n defined. For more information see the [opt-in builtin traits RFC](https://github"}, {"sha": "9e5dfdc30c887d95e1650cfa1d045d67abe3e17e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -167,6 +167,9 @@ declare_features! (\n     // RFC 1238\n     (active, dropck_parametricity, \"1.3.0\", Some(28498)),\n \n+    // Allows using the may_dangle attribute; RFC 1327\n+    (active, dropck_eyepatch, \"1.10.0\", Some(34761)),\n+\n     // Allows the use of custom attributes; RFC 572\n     (active, custom_attribute, \"1.0.0\", Some(29642)),\n \n@@ -616,6 +619,11 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n            \"unsafe_destructor_blind_to_params has unstable semantics \\\n             and may be removed in the future\",\n            cfg_fn!(dropck_parametricity))),\n+    (\"may_dangle\",\n+     Normal,\n+     Gated(\"dropck_eyepatch\",\n+           \"may_dangle has unstable semantics and may be removed in the future\",\n+           cfg_fn!(dropck_eyepatch))),\n     (\"unwind\", Whitelisted, Gated(\"unwind_attributes\", \"#[unwind] is experimental\",\n                                   cfg_fn!(unwind_attributes))),\n "}, {"sha": "3a0f9cd8ec48aab0d6135311ef451ac2feede0c3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -1361,6 +1361,7 @@ impl<'a> State<'a> {\n                 if comma {\n                     try!(self.word_space(\",\"))\n                 }\n+                try!(self.print_outer_attributes_inline(&lifetime_def.attrs));\n                 try!(self.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds));\n                 comma = true;\n             }\n@@ -2803,6 +2804,7 @@ impl<'a> State<'a> {\n         try!(self.commasep(Inconsistent, &ints[..], |s, &idx| {\n             if idx < generics.lifetimes.len() {\n                 let lifetime_def = &generics.lifetimes[idx];\n+                try!(s.print_outer_attributes_inline(&lifetime_def.attrs));\n                 s.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)\n             } else {\n                 let idx = idx - generics.lifetimes.len();\n@@ -2816,6 +2818,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> io::Result<()> {\n+        try!(self.print_outer_attributes_inline(&param.attrs));\n         try!(self.print_ident(param.ident));\n         try!(self.print_bounds(\":\", &param.bounds));\n         match param.default {"}, {"sha": "892989cc6a080132c0dbdbc64e2f32c4f1ec6f9f", "filename": "src/test/compile-fail/E0198.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fcompile-fail%2FE0198.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fcompile-fail%2FE0198.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0198.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+unsafe impl !Clone for Foo { } //~ ERROR negative implementations are not unsafe [E0198]\n+\n+fn main() {\n+}"}, {"sha": "1a5cd1941a9d12f5576f3ca616addc59feecd064", "filename": "src/test/compile-fail/E0199.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fcompile-fail%2FE0199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fcompile-fail%2FE0199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0199.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -12,7 +12,8 @@\n \n struct Foo;\n \n-unsafe impl !Clone for Foo { } //~ ERROR E0199\n+trait Bar { }\n+unsafe impl Bar for Foo { } //~ ERROR implementing the trait `Bar` is not unsafe [E0199]\n \n fn main() {\n }"}, {"sha": "23f8ead0ca9dc497b37ceddaa5d1f6ccf3314611", "filename": "src/test/compile-fail/feature-gate-may-dangle.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that `may_dangle` is rejected if `dropck_eyepatch` feature gate is absent.\n+\n+#![feature(generic_param_attrs)]\n+\n+struct Pt<A>(A);\n+impl<#[may_dangle] A> Drop for Pt<A> {\n+    //~^ ERROR may_dangle has unstable semantics and may be removed in the future\n+    //~| HELP add #![feature(dropck_eyepatch)] to the crate attributes to enable\n+    fn drop(&mut self) { }\n+}"}, {"sha": "1266e589b127e54b62928fade13422c992ada1dd", "filename": "src/test/run-pass/auxiliary/dropck_eyepatch_extern_crate.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself,\n+// and that this attributes effects are preserved when importing\n+// the type from another crate.\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::cell::RefCell;\n+\n+pub trait Foo { fn foo(&self, _: &str); }\n+\n+pub struct Dt<A: Foo>(pub &'static str, pub A);\n+pub struct Dr<'a, B:'a+Foo>(pub &'static str, pub &'a B);\n+pub struct Pt<A,B: Foo>(pub &'static str, pub A, pub B);\n+pub struct Pr<'a, 'b, B:'a+'b+Foo>(pub &'static str, pub &'a B, pub &'b B);\n+pub struct St<A: Foo>(pub &'static str, pub A);\n+pub struct Sr<'a, B:'a+Foo>(pub &'static str, pub &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] A, B: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+impl Foo for RefCell<String> {\n+    fn foo(&self, s: &str) {\n+        let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+        *self.borrow_mut() = s2;\n+    }\n+}\n+\n+impl<'a, T:Foo> Foo for &'a T {\n+    fn foo(&self, s: &str) {\n+        (*self).foo(s);\n+    }\n+}"}, {"sha": "20f069f77ea1574648aaa5daed1b232eef465e4f", "filename": "src/test/run-pass/dropck-eyepatch-extern-crate.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:dropck_eyepatch_extern_crate.rs\n+\n+extern crate dropck_eyepatch_extern_crate as other;\n+\n+use other::{Dt,Dr,Pt,Pr,St,Sr};\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}, {"sha": "bbf8bb8c352389f2c246b5ea44b3c0f7c5930645", "filename": "src/test/run-pass/dropck-eyepatch-reorder.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to test uses of `#[may_dangle]` attribute\n+// where the formal declaration order (in the impl generics) does not\n+// match the actual usage order (in the type instantiation).\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+trait Foo { fn foo(&self, _: &str); }\n+\n+struct Dt<A: Foo>(&'static str, A);\n+struct Dr<'a, B:'a+Foo>(&'static str, &'a B);\n+struct Pt<A: Foo, B: Foo>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+Foo>(&'static str, &'a B, &'b B);\n+struct St<A: Foo>(&'static str, A);\n+struct Sr<'a, B:'a+Foo>(&'static str, &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<B: Foo, #[may_dangle] A: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<'b, #[may_dangle] 'a, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    impl Foo for RefCell<String> {\n+        fn foo(&self, s: &str) {\n+            let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+            *self.borrow_mut() = s2;\n+        }\n+    }\n+\n+    impl<'a, T:Foo> Foo for &'a T {\n+        fn foo(&self, s: &str) {\n+            (*self).foo(s);\n+        }\n+    }\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}, {"sha": "4a09ba05dff5eec3af108c0cbc21d759d4655f34", "filename": "src/test/run-pass/dropck-eyepatch.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself.\n+//\n+// Here we test that a model use of `#[may_dangle]` will compile and run.\n+//\n+// The illustration is made concrete by comparison with two variations\n+// on the type with `#[may_dangle]`:\n+//\n+//   1. an analogous type that does not implement `Drop` (and thus\n+//      should exhibit maximal flexibility with respect to dropck), and\n+//\n+//   2. an analogous type that does not use `#[may_dangle]` (and thus\n+//      should exhibit the standard limitations imposed by dropck.\n+//\n+// The types in this file follow a pattern, {D,P,S}{t,r}, where:\n+//\n+// - D means \"I implement Drop\"\n+//\n+// - P means \"I implement Drop but guarantee my (first) parameter is\n+//     pure, i.e. not accessed from the destructor\"; no other parameters\n+//     are pure.\n+//\n+// - S means \"I do not implement Drop\"\n+//\n+// - t suffix is used when the first generic is a type\n+//\n+// - r suffix is used when the first generic is a lifetime.\n+\n+trait Foo { fn foo(&self, _: &str); }\n+\n+struct Dt<A: Foo>(&'static str, A);\n+struct Dr<'a, B:'a+Foo>(&'static str, &'a B);\n+struct Pt<A,B: Foo>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+Foo>(&'static str, &'a B, &'b B);\n+struct St<A: Foo>(&'static str, A);\n+struct Sr<'a, B:'a+Foo>(&'static str, &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] A, B: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    impl Foo for RefCell<String> {\n+        fn foo(&self, s: &str) {\n+            let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+            *self.borrow_mut() = s2;\n+        }\n+    }\n+\n+    impl<'a, T:Foo> Foo for &'a T {\n+        fn foo(&self, s: &str) {\n+            (*self).foo(s);\n+        }\n+    }\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}, {"sha": "1b00d88dcb3dfd78d9fba23aab85499ff10d220b", "filename": "src/test/ui/dropck/auxiliary/dropck_eyepatch_extern_crate.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// This is a support file for ../dropck-eyepatch-extern-crate.rs\n+//\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself,\n+// and that this attribute's effects are preserved when importing\n+// the type from another crate.\n+//\n+// See also ../dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::fmt;\n+\n+pub struct Dt<A: fmt::Debug>(pub &'static str, pub A);\n+pub struct Dr<'a, B:'a+fmt::Debug>(pub &'static str, pub &'a B);\n+pub struct Pt<A,B: fmt::Debug>(pub &'static str, pub A, pub B);\n+pub struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(pub &'static str, pub &'a B, pub &'b B);\n+pub struct St<A: fmt::Debug>(pub &'static str, pub A);\n+pub struct Sr<'a, B:'a+fmt::Debug>(pub &'static str, pub &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}"}, {"sha": "5e200dbdbfa0195a23874498eb97cdb017495b1a", "filename": "src/test/ui/dropck/dropck-eyepatch-extern-crate.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:dropck_eyepatch_extern_crate.rs\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself,\n+// and that this attribute's effects are preserved when importing\n+// the type from another crate.\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+extern crate dropck_eyepatch_extern_crate as other;\n+\n+use other::{Dt,Dr,Pt,Pr,St,Sr};\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "5d2096e8b07a45126670f4a4c55793a0dbc32769", "filename": "src/test/ui/dropck/dropck-eyepatch-extern-crate.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.stderr?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,46 @@\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-extern-crate.rs:39:20\n+   |\n+39 |     dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+55 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-extern-crate.rs:40:20\n+   |\n+40 |     dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+55 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-extern-crate.rs:47:29\n+   |\n+47 |     pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+55 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-extern-crate.rs:48:29\n+   |\n+48 |     pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+55 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "f92c8703dc9273b9ddb3055db23b98aab705ae43", "filename": "src/test/ui/dropck/dropck-eyepatch-implies-unsafe-impl.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// This test ensures that a use of `#[may_dangle]` is rejected if\n+// it is not attached to an `unsafe impl`.\n+\n+use std::fmt;\n+\n+struct Dt<A: fmt::Debug>(&'static str, A);\n+struct Dr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+struct Pt<A,B: fmt::Debug>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(&'static str, &'a B, &'b B);\n+struct St<A: fmt::Debug>(&'static str, A);\n+struct Sr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+    //~^ ERROR requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    //~^ ERROR requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+\n+fn main() {\n+}"}, {"sha": "c53cf020a9bc52d75110c3753fb72b591938505e", "filename": "src/test/ui/dropck/dropck-eyepatch-implies-unsafe-impl.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,14 @@\n+error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+  --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:32:1\n+   |\n+32 | impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+   | ^\n+\n+error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+  --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:38:1\n+   |\n+38 | impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+   | ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "68b0ff3b5f096f76672d3f57e439a56732f73cbc", "filename": "src/test/ui/dropck/dropck-eyepatch-reorder.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to test uses of `#[may_dangle]` attribute\n+// where the formal declaration order (in the impl generics) does not\n+// match the actual usage order (in the type instantiation).\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::fmt;\n+\n+struct Dt<A: fmt::Debug>(&'static str, A);\n+struct Dr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+struct Pt<A: fmt::Debug, B: fmt::Debug>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(&'static str, &'a B, &'b B);\n+struct St<A: fmt::Debug>(&'static str, A);\n+struct Sr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<B: fmt::Debug, #[may_dangle] A: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<'b, #[may_dangle] 'a, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "33b18f6f02e0f180b479b90364ace3f903088259", "filename": "src/test/ui/dropck/dropck-eyepatch-reorder.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.stderr?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,46 @@\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-reorder.rs:57:20\n+   |\n+57 |     dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+73 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-reorder.rs:58:20\n+   |\n+58 |     dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+73 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-reorder.rs:65:29\n+   |\n+65 |     pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+73 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-reorder.rs:66:29\n+   |\n+66 |     pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+73 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "e442fade1973025d25f2d82ce9085e5b41dcf978", "filename": "src/test/ui/dropck/dropck-eyepatch.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.rs?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself.\n+//\n+// Here we test that only the expected errors are issued.\n+//\n+// The illustration is made concrete by comparison with two variations\n+// on the type with `#[may_dangle]`:\n+//\n+//   1. an analogous type that does not implement `Drop` (and thus\n+//      should exhibit maximal flexibility with respect to dropck), and\n+//\n+//   2. an analogous type that does not use `#[may_dangle]` (and thus\n+//      should exhibit the standard limitations imposed by dropck.\n+//\n+// The types in this file follow a pattern, {D,P,S}{t,r}, where:\n+//\n+// - D means \"I implement Drop\"\n+//\n+// - P means \"I implement Drop but guarantee my (first) parameter is\n+//     pure, i.e. not accessed from the destructor\"; no other parameters\n+//     are pure.\n+//\n+// - S means \"I do not implement Drop\"\n+//\n+// - t suffix is used when the first generic is a type\n+//\n+// - r suffix is used when the first generic is a lifetime.\n+\n+use std::fmt;\n+\n+struct Dt<A: fmt::Debug>(&'static str, A);\n+struct Dr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+struct Pt<A,B: fmt::Debug>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(&'static str, &'a B, &'b B);\n+struct St<A: fmt::Debug>(&'static str, A);\n+struct Sr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "75e612ca9c8f181ae860aac9e45d5e7d6065b644", "filename": "src/test/ui/dropck/dropck-eyepatch.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/373fcd1bd358c27db02fa65800c23c148046348c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.stderr?ref=373fcd1bd358c27db02fa65800c23c148046348c", "patch": "@@ -0,0 +1,46 @@\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch.rs:80:20\n+   |\n+80 |     dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+96 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch.rs:81:20\n+   |\n+81 |     dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+96 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch.rs:88:29\n+   |\n+88 |     pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+96 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch.rs:89:29\n+   |\n+89 |     pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+96 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: aborting due to 4 previous errors\n+"}]}