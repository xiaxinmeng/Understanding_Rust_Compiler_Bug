{"sha": "35bab923c8e5a1e8291735e7630539002eb80d7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YmFiOTIzYzhlNWExZTgyOTE3MzVlNzYzMDUzOTAwMmViODBkN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-20T07:39:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-20T07:39:24Z"}, "message": "Auto merge of #85486 - RalfJung:rollup-4ibcxuu, r=RalfJung\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #84717 (impl FromStr for proc_macro::Literal)\n - #85169 (Add method-toggle to <details> for methods)\n - #85287 (Expose `Concurrent` (private type in public i'face))\n - #85315 (adding time complexity for partition_in_place iter method)\n - #85439 (Add diagnostic item to `CStr`)\n - #85464 (Fix UB in documented example for `ptr::swap`)\n - #85470 (Fix invalid CSS rules for a:hover)\n - #85472 (CTFE Machine: do not expose Allocation)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3301a8b56e8463061d4fb62580b1d28e6d9c7cbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3301a8b56e8463061d4fb62580b1d28e6d9c7cbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35bab923c8e5a1e8291735e7630539002eb80d7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35bab923c8e5a1e8291735e7630539002eb80d7b", "html_url": "https://github.com/rust-lang/rust/commit/35bab923c8e5a1e8291735e7630539002eb80d7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35bab923c8e5a1e8291735e7630539002eb80d7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ab0f37087b61b2ea51f364498cddc20ecff74fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab0f37087b61b2ea51f364498cddc20ecff74fa", "html_url": "https://github.com/rust-lang/rust/commit/5ab0f37087b61b2ea51f364498cddc20ecff74fa"}, {"sha": "9fa15ff0fce1e72853a0997e9a8a9a8e90a22f20", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa15ff0fce1e72853a0997e9a8a9a8e90a22f20", "html_url": "https://github.com/rust-lang/rust/commit/9fa15ff0fce1e72853a0997e9a8a9a8e90a22f20"}], "stats": {"total": 227, "additions": 179, "deletions": 48}, "files": [{"sha": "92315c4d4f6c7f02e5221c2805706fe8ba12d8b6", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -1,9 +1,7 @@\n use crate::base::{ExtCtxt, ResolverExpand};\n \n use rustc_ast as ast;\n-use rustc_ast::token;\n-use rustc_ast::token::Nonterminal;\n-use rustc_ast::token::NtIdent;\n+use rustc_ast::token::{self, Nonterminal, NtIdent, TokenKind};\n use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens};\n use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n@@ -541,6 +539,33 @@ impl server::Ident for Rustc<'_> {\n }\n \n impl server::Literal for Rustc<'_> {\n+    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n+        let override_span = None;\n+        let stream = parse_stream_from_source_str(\n+            FileName::proc_macro_source_code(s),\n+            s.to_owned(),\n+            self.sess,\n+            override_span,\n+        );\n+        if stream.len() != 1 {\n+            return Err(());\n+        }\n+        let tree = stream.into_trees().next().unwrap();\n+        let token = match tree {\n+            tokenstream::TokenTree::Token(token) => token,\n+            tokenstream::TokenTree::Delimited { .. } => return Err(()),\n+        };\n+        let span_data = token.span.data();\n+        if (span_data.hi.0 - span_data.lo.0) as usize != s.len() {\n+            // There is a comment or whitespace adjacent to the literal.\n+            return Err(());\n+        }\n+        let lit = match token.kind {\n+            TokenKind::Literal(lit) => lit,\n+            _ => return Err(()),\n+        };\n+        Ok(Literal { lit, span: self.call_site })\n+    }\n     fn debug_kind(&mut self, literal: &Self::Literal) -> String {\n         format!(\"{:?}\", literal.lit.kind)\n     }"}, {"sha": "e7d7c38cc8ffd2af4d0d105fce3ab29f3d5e0f14", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -313,7 +313,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     #[inline(always)]\n     fn memory_read(\n         _memory_extra: &Self::MemoryExtra,\n-        _alloc: &Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _alloc_extra: &Self::AllocExtra,\n         _ptr: Pointer<Self::PointerTag>,\n         _size: Size,\n     ) -> InterpResult<'tcx> {\n@@ -324,7 +324,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     #[inline(always)]\n     fn memory_written(\n         _memory_extra: &mut Self::MemoryExtra,\n-        _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _alloc_extra: &mut Self::AllocExtra,\n         _ptr: Pointer<Self::PointerTag>,\n         _size: Size,\n     ) -> InterpResult<'tcx> {\n@@ -335,8 +335,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     #[inline(always)]\n     fn memory_deallocated(\n         _memory_extra: &mut Self::MemoryExtra,\n-        _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _alloc_extra: &mut Self::AllocExtra,\n         _ptr: Pointer<Self::PointerTag>,\n+        _size: Size,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }"}, {"sha": "7fb7c51b0b5bc85231cc719b5eed4f661fb02ccc", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -343,10 +343,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n \n         // Let the machine take some extra action\n-        M::memory_deallocated(&mut self.extra, &mut alloc, ptr)?;\n+        let size = alloc.size();\n+        M::memory_deallocated(&mut self.extra, &mut alloc.extra, ptr, size)?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n-        let old = self.dead_alloc_map.insert(ptr.alloc_id, (alloc.size(), alloc.align));\n+        let old = self.dead_alloc_map.insert(ptr.alloc_id, (size, alloc.align));\n         if old.is_some() {\n             bug!(\"Nothing can be deallocated twice\");\n         }\n@@ -591,7 +592,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             },\n         )?;\n         if let Some((ptr, alloc)) = ptr_and_alloc {\n-            M::memory_read(&self.extra, alloc, ptr, size)?;\n+            M::memory_read(&self.extra, &alloc.extra, ptr, size)?;\n             let range = alloc_range(ptr.offset, size);\n             Ok(Some(AllocRef { alloc, range, tcx: self.tcx, alloc_id: ptr.alloc_id }))\n         } else {\n@@ -660,7 +661,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n             let (alloc, extra) = self.get_raw_mut(ptr.alloc_id)?;\n-            M::memory_written(extra, alloc, ptr, size)?;\n+            M::memory_written(extra, &mut alloc.extra, ptr, size)?;\n             let range = alloc_range(ptr.offset, size);\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id: ptr.alloc_id }))\n         } else {\n@@ -1029,7 +1030,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(src_ptr) => src_ptr,\n         };\n         let src_alloc = self.get_raw(src.alloc_id)?;\n-        M::memory_read(&self.extra, src_alloc, src, size)?;\n+        M::memory_read(&self.extra, &src_alloc.extra, src, size)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n         let dest = match dest {\n@@ -1058,7 +1059,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // Destination alloc preparations and access hooks.\n         let (dest_alloc, extra) = self.get_raw_mut(dest.alloc_id)?;\n-        M::memory_written(extra, dest_alloc, dest, size * num_copies)?;\n+        M::memory_written(extra, &mut dest_alloc.extra, dest, size * num_copies)?;\n         let dest_bytes = dest_alloc\n             .get_bytes_mut_ptr(&tcx, alloc_range(dest.offset, size * num_copies))\n             .as_mut_ptr();"}, {"sha": "46ef308cbf27c5fa90e8465316ad36e7b7e23de4", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -132,6 +132,7 @@ symbols! {\n         Borrow,\n         Break,\n         C,\n+        CStr,\n         CString,\n         Center,\n         Clone,"}, {"sha": "c2e280ff07d1990a64b2d4255060a5b36255adea", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -1849,6 +1849,12 @@ pub trait Iterator {\n     ///\n     /// The relative order of partitioned items is not maintained.\n     ///\n+    /// # Current implementation\n+    /// Current algorithms tries finding the first element for which the predicate evaluates\n+    /// to false, and the last element for which it evaluates to true and repeatedly swaps them.\n+    ///\n+    /// Time Complexity: *O*(*N*)\n+    ///\n     /// See also [`is_partitioned()`] and [`partition()`].\n     ///\n     /// [`is_partitioned()`]: Iterator::is_partitioned"}, {"sha": "214d7c8bc15600d5d582776056bc9b6530fcf7b0", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -342,10 +342,12 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n /// ```\n /// use std::ptr;\n ///\n-/// let mut array = [0, 1, 2, 3];\n+/// let mut array: [i32; 4] = [0, 1, 2, 3];\n+///\n+/// let array_ptr: *mut i32 = array.as_mut_ptr();\n ///\n-/// let x = array[0..].as_mut_ptr() as *mut [u32; 3]; // this is `array[0..3]`\n-/// let y = array[1..].as_mut_ptr() as *mut [u32; 3]; // this is `array[1..4]`\n+/// let x = array_ptr as *mut [i32; 3]; // this is `array[0..3]`\n+/// let y = unsafe { array_ptr.add(1) } as *mut [i32; 3]; // this is `array[1..4]`\n ///\n /// unsafe {\n ///     ptr::swap(x, y);"}, {"sha": "a2953b68564a89bcddb92552e527f0241fa9f18b", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -107,6 +107,7 @@ macro_rules! with_api {\n             Literal {\n                 fn drop($self: $S::Literal);\n                 fn clone($self: &$S::Literal) -> $S::Literal;\n+                fn from_str(s: &str) -> Result<$S::Literal, ()>;\n                 fn debug_kind($self: &$S::Literal) -> String;\n                 fn symbol($self: &$S::Literal) -> String;\n                 fn suffix($self: &$S::Literal) -> Option<String>;\n@@ -315,6 +316,19 @@ impl<T: Unmark> Unmark for Option<T> {\n     }\n }\n \n+impl<T: Mark, E: Mark> Mark for Result<T, E> {\n+    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        unmarked.map(T::mark).map_err(E::mark)\n+    }\n+}\n+impl<T: Unmark, E: Unmark> Unmark for Result<T, E> {\n+    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.map(T::unmark).map_err(E::unmark)\n+    }\n+}\n+\n macro_rules! mark_noop {\n     ($($ty:ty),* $(,)?) => {\n         $("}, {"sha": "281999fe71588d37876bb90582095ffb37c57b76", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -91,6 +91,12 @@ pub struct LexError {\n     _inner: (),\n }\n \n+impl LexError {\n+    fn new() -> Self {\n+        LexError { _inner: () }\n+    }\n+}\n+\n #[stable(feature = \"proc_macro_lexerror_impls\", since = \"1.44.0\")]\n impl fmt::Display for LexError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -1171,6 +1177,28 @@ impl Literal {\n     }\n }\n \n+/// Parse a single literal from its stringified representation.\n+///\n+/// In order to parse successfully, the input string must not contain anything\n+/// but the literal token. Specifically, it must not contain whitespace or\n+/// comments in addition to the literal.\n+///\n+/// The resulting literal token will have a `Span::call_site()` span.\n+///\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We\n+/// reserve the right to change these errors into `LexError`s later.\n+#[stable(feature = \"proc_macro_literal_parse\", since = \"1.54.0\")]\n+impl FromStr for Literal {\n+    type Err = LexError;\n+\n+    fn from_str(src: &str) -> Result<Self, LexError> {\n+        match bridge::client::Literal::from_str(src) {\n+            Ok(literal) => Ok(Literal(literal)),\n+            Err(()) => Err(LexError::new()),\n+        }\n+    }\n+}\n+\n // N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]"}, {"sha": "302f12af6a0fe8cbc6cbdaa6e5f738ce668c8acf", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -185,6 +185,7 @@ pub struct CString {\n ///\n /// [`&str`]: prim@str\n #[derive(Hash)]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n // `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies"}, {"sha": "bda5ed888d7e1dc091328e77a16b213cdc99d1ac", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -49,7 +49,7 @@ pub mod test {\n         cli::{parse_opts, TestOpts},\n         filter_tests,\n         helpers::metrics::{Metric, MetricMap},\n-        options::{Options, RunIgnored, RunStrategy, ShouldPanic},\n+        options::{Concurrent, Options, RunIgnored, RunStrategy, ShouldPanic},\n         run_test, test_main, test_main_static,\n         test_result::{TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk},\n         time::{TestExecTime, TestTimeOptions},"}, {"sha": "318e1b44f86830f427b2a5fe1e2ae56a1f988beb", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -1352,8 +1352,11 @@ fn render_impl(\n         }\n         let w = if short_documented && trait_.is_some() { interesting } else { boring };\n \n-        if !doc_buffer.is_empty() {\n-            w.write_str(\"<details class=\\\"rustdoc-toggle\\\" open><summary>\");\n+        let toggled = !doc_buffer.is_empty();\n+        if toggled {\n+            let method_toggle_class =\n+                if item_type == ItemType::Method { \" method-toggle\" } else { \"\" };\n+            write!(w, \"<details class=\\\"rustdoc-toggle{}\\\" open><summary>\", method_toggle_class);\n         }\n         match *item.kind {\n             clean::MethodItem(..) | clean::TyMethodItem(_) => {\n@@ -1453,7 +1456,7 @@ fn render_impl(\n         }\n \n         w.push_buffer(info_buffer);\n-        if !doc_buffer.is_empty() {\n+        if toggled {\n             w.write_str(\"</summary>\");\n             w.push_buffer(doc_buffer);\n             w.push_str(\"</details>\");"}, {"sha": "8204949267250fd09fb10ae732176196835f1be2", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -924,24 +924,16 @@ function hideThemeButtonState() {\n             });\n         }\n \n-        if (hideMethodDocs) {\n-            onEachLazy(document.getElementsByClassName(\"method\"), function(e) {\n-                var toggle = e.parentNode;\n-                if (toggle) {\n-                    toggle = toggle.parentNode;\n-                }\n-                if (toggle && toggle.tagName === \"DETAILS\") {\n-                    toggle.open = false;\n-                }\n-            });\n-        }\n-\n         onEachLazy(document.getElementsByTagName(\"details\"), function (e) {\n             var showLargeItem = !hideLargeItemContents && hasClass(e, \"type-contents-toggle\");\n             var showImplementor = !hideImplementors && hasClass(e, \"implementors-toggle\");\n             if (showLargeItem || showImplementor) {\n                 e.open = true;\n             }\n+            if (hideMethodDocs && hasClass(e, \"method-toggle\")) {\n+                e.open = false;\n+            }\n+\n         });\n \n         var currentType = document.getElementsByClassName(\"type-decl\")[0];"}, {"sha": "e59909ffdf05e46bf0b3c1262675eca78ed28575", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -151,17 +151,14 @@ pre, .rustdoc.source .example-wrap {\n \tcolor: #c5c5c5;\n }\n \n-.content a:hover {\n+.search-results a:hover {\n \tbackground-color: #777;\n }\n \n-.content a:focus {\n+.search-results a:focus {\n \tcolor: #000 !important;\n \tbackground-color: #c6afb3;\n }\n-.content a:focus {\n-\tcolor: #000 !important;\n-}\n .search-results a {\n \tcolor: #0096cf;\n }"}, {"sha": "a2bcb43f44e6fa8a7c1dea4de905d609142c4a34", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -109,11 +109,11 @@ pre, .rustdoc.source .example-wrap {\n \tcolor: #ddd;\n }\n \n-.content a:hover {\n+.search-results a:hover {\n \tbackground-color: #777;\n }\n \n-.content a:focus {\n+.search-results a:focus {\n \tcolor: #eee !important;\n \tbackground-color: #616161;\n }"}, {"sha": "2ad3551d900ead6fce2c885f225378c5884ac7e9", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -109,11 +109,11 @@ pre, .rustdoc.source .example-wrap {\n \tcolor: #4E4C4C;\n }\n \n-.content a:hover {\n+.search-results a:hover {\n \tbackground-color: #ddd;\n }\n \n-.content a:focus {\n+.search-results a:focus {\n \tcolor: #000 !important;\n \tbackground-color: #ccc;\n }"}, {"sha": "5784a6e5d94db3793f909d4619183e1563c26b6b", "filename": "src/test/ui/proc-macro/auxiliary/api/cmp.rs", "status": "renamed", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fcmp.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -1,8 +1,10 @@\n-#![feature(proc_macro_span)]\n+use proc_macro::{LineColumn, Punct, Spacing};\n \n-use proc_macro::{LineColumn, Punct};\n+pub fn test() {\n+    test_line_column_ord();\n+    test_punct_eq();\n+}\n \n-#[test]\n fn test_line_column_ord() {\n     let line0_column0 = LineColumn { line: 0, column: 0 };\n     let line0_column1 = LineColumn { line: 0, column: 1 };\n@@ -11,10 +13,9 @@ fn test_line_column_ord() {\n     assert!(line0_column1 < line1_column0);\n }\n \n-#[test]\n fn test_punct_eq() {\n-    // Good enough if it typechecks, since proc_macro::Punct can't exist in a test.\n-    fn _check(punct: Punct) {\n-        let _ = punct == ':';\n-    }\n+    let colon_alone = Punct::new(':', Spacing::Alone);\n+    assert_eq!(colon_alone, ':');\n+    let colon_joint = Punct::new(':', Spacing::Joint);\n+    assert_eq!(colon_joint, ':');\n }", "previous_filename": "library/proc_macro/tests/test.rs"}, {"sha": "739c25132e77b6561dad11deb64d17bf1f93c392", "filename": "src/test/ui/proc-macro/auxiliary/api/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fmod.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -0,0 +1,24 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![crate_name = \"proc_macro_api_tests\"]\n+#![feature(proc_macro_span)]\n+#![deny(dead_code)] // catch if a test function is never called\n+\n+extern crate proc_macro;\n+\n+mod cmp;\n+mod parse;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn run(input: TokenStream) -> TokenStream {\n+    assert!(input.is_empty());\n+\n+    cmp::test();\n+    parse::test();\n+\n+    TokenStream::new()\n+}"}, {"sha": "4105236b7f2d35c85ab5b697b765de7478f00d16", "filename": "src/test/ui/proc-macro/auxiliary/api/parse.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -0,0 +1,23 @@\n+use proc_macro::Literal;\n+\n+pub fn test() {\n+    test_parse_literal();\n+}\n+\n+fn test_parse_literal() {\n+    assert_eq!(\"1\".parse::<Literal>().unwrap().to_string(), \"1\");\n+    assert_eq!(\"1.0\".parse::<Literal>().unwrap().to_string(), \"1.0\");\n+    assert_eq!(\"'a'\".parse::<Literal>().unwrap().to_string(), \"'a'\");\n+    assert_eq!(\"\\\"\\n\\\"\".parse::<Literal>().unwrap().to_string(), \"\\\"\\n\\\"\");\n+    assert_eq!(\"b\\\"\\\"\".parse::<Literal>().unwrap().to_string(), \"b\\\"\\\"\");\n+    assert_eq!(\"r##\\\"\\\"##\".parse::<Literal>().unwrap().to_string(), \"r##\\\"\\\"##\");\n+    assert_eq!(\"10ulong\".parse::<Literal>().unwrap().to_string(), \"10ulong\");\n+\n+    assert!(\"0 1\".parse::<Literal>().is_err());\n+    assert!(\"'a\".parse::<Literal>().is_err());\n+    assert!(\" 0\".parse::<Literal>().is_err());\n+    assert!(\"0 \".parse::<Literal>().is_err());\n+    assert!(\"/* comment */0\".parse::<Literal>().is_err());\n+    assert!(\"0/* comment */\".parse::<Literal>().is_err());\n+    assert!(\"0// comment\".parse::<Literal>().is_err());\n+}"}, {"sha": "c96aa73175f2cf6ff94f71249791c5a707b96e0f", "filename": "src/test/ui/proc-macro/test.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Ftest%2Fui%2Fproc-macro%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bab923c8e5a1e8291735e7630539002eb80d7b/src%2Ftest%2Fui%2Fproc-macro%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Ftest.rs?ref=35bab923c8e5a1e8291735e7630539002eb80d7b", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+// aux-build:api/mod.rs\n+\n+//! This is for everything that *would* be a #[test] inside of libproc_macro,\n+//! except for the fact that proc_macro objects are not capable of existing\n+//! inside of an ordinary Rust test execution, only inside a macro.\n+\n+extern crate proc_macro_api_tests;\n+\n+proc_macro_api_tests::run!();\n+\n+fn main() {}"}]}