{"sha": "1ceb104851c2c3054f680d89f9d9333b5e5110be", "node_id": "C_kwDOAAsO6NoAKDFjZWIxMDQ4NTFjMmMzMDU0ZjY4MGQ4OWY5ZDkzMzNiNWU1MTEwYmU", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-02-17T14:16:52Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-02-21T18:28:22Z"}, "message": "On ARM, use relocation_model to detect whether r9 should be reserved\n\nThe previous approach of checking for the reserve-r9 target feature\ndidn't actually work because LLVM only sets this feature very late when\ninitializing the per-function subtarget.", "tree": {"sha": "b96079ae2fde93b57120ab42e2cfb2fb9221e76c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b96079ae2fde93b57120ab42e2cfb2fb9221e76c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ceb104851c2c3054f680d89f9d9333b5e5110be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ceb104851c2c3054f680d89f9d9333b5e5110be", "html_url": "https://github.com/rust-lang/rust/commit/1ceb104851c2c3054f680d89f9d9333b5e5110be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ceb104851c2c3054f680d89f9d9333b5e5110be/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e8a7663b45790310adac4f62a88df08821261f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8a7663b45790310adac4f62a88df08821261f1", "html_url": "https://github.com/rust-lang/rust/commit/2e8a7663b45790310adac4f62a88df08821261f1"}], "stats": {"total": 114, "additions": 67, "deletions": 47}, "files": [{"sha": "d7c27059aaea2b3b922e6307827c9f3ab81aa5c2", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -66,6 +66,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n                 match asm::InlineAsmClobberAbi::parse(\n                     asm_arch,\n+                    self.sess.relocation_model(),\n                     &self.sess.target_features,\n                     &self.sess.target,\n                     *abi_name,\n@@ -134,6 +135,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(\n                                 asm_arch,\n+                                sess.relocation_model(),\n                                 &sess.target_features,\n                                 &sess.target,\n                                 is_clobber,"}, {"sha": "10c2f06faf3ee6f18e6e07700d730cc9d24bf0c2", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -182,7 +182,12 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n     fn allocate_registers(&mut self) {\n         let sess = self.tcx.sess;\n-        let map = allocatable_registers(self.arch, &sess.target_features, &sess.target);\n+        let map = allocatable_registers(\n+            self.arch,\n+            sess.relocation_model(),\n+            &sess.target_features,\n+            &sess.target,\n+        );\n         let mut allocated = FxHashMap::<_, (bool, bool)>::default();\n         let mut regs = vec![None; self.operands.len()];\n \n@@ -315,6 +320,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for saving clobbered registers\n         let abi_clobber = InlineAsmClobberAbi::parse(\n             self.arch,\n+            self.tcx.sess.relocation_model(),\n             &self.tcx.sess.target_features,\n             &self.tcx.sess.target,\n             sym::C,"}, {"sha": "77166c89735e43b9f77c7facf88b24144398452f", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -36,7 +36,6 @@ const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     // #[target_feature].\n     (\"thumb-mode\", Some(sym::arm_target_feature)),\n     (\"thumb2\", Some(sym::arm_target_feature)),\n-    (\"reserve-r9\", Some(sym::arm_target_feature)),\n ];\n \n const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &["}, {"sha": "6767593bbc51a8ce455cd8daec8e5d5cbb57db0e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -1122,7 +1122,6 @@ symbols! {\n         repr_packed,\n         repr_simd,\n         repr_transparent,\n-        reserved_r9: \"reserved-r9\",\n         residual,\n         result,\n         rhs,"}, {"sha": "b4a1b5e91430cf771477be250dcaa220d8409fd2", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{Target, RelocModel};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -75,6 +75,7 @@ impl AArch64InlineAsmRegClass {\n \n pub fn reserved_x18(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,"}, {"sha": "88f2d3f80d2c38d352d19fdcb7b2a18c99d1b122", "filename": "compiler/rustc_target/src/asm/arm.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n@@ -67,11 +67,12 @@ fn frame_pointer_is_r7(target_features: &FxHashSet<Symbol>, target: &Target) ->\n \n fn frame_pointer_r11(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    not_thumb1(arch, target_features, target, is_clobber)?;\n+    not_thumb1(arch, reloc_model, target_features, target, is_clobber)?;\n \n     if !frame_pointer_is_r7(target_features, target) {\n         Err(\"the frame pointer (r11) cannot be used as an operand for inline asm\")\n@@ -82,6 +83,7 @@ fn frame_pointer_r11(\n \n fn frame_pointer_r7(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,\n@@ -95,6 +97,7 @@ fn frame_pointer_r7(\n \n fn not_thumb1(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     is_clobber: bool,\n@@ -111,18 +114,18 @@ fn not_thumb1(\n \n fn reserved_r9(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    not_thumb1(arch, target_features, target, is_clobber)?;\n+    not_thumb1(arch, reloc_model, target_features, target, is_clobber)?;\n \n-    // We detect this using the reserved-r9 feature instead of using the target\n-    // because the relocation model can be changed with compiler options.\n-    if target_features.contains(&sym::reserved_r9) {\n-        Err(\"the RWPI static base register (r9) cannot be used as an operand for inline asm\")\n-    } else {\n-        Ok(())\n+    match reloc_model {\n+        RelocModel::Rwpi | RelocModel::RopiRwpi => {\n+            Err(\"the RWPI static base register (r9) cannot be used as an operand for inline asm\")\n+        }\n+        _ => Ok(()),\n     }\n }\n "}, {"sha": "1bf4747a970508c3f89e2faf9495d1acbea7d9d1", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -1,5 +1,5 @@\n-use crate::abi::Size;\n use crate::spec::Target;\n+use crate::{abi::Size, spec::RelocModel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -81,6 +81,7 @@ macro_rules! def_regs {\n \n             pub fn parse(\n                 _arch: super::InlineAsmArch,\n+                _reloc_model: crate::spec::RelocModel,\n                 _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n                 _target: &crate::spec::Target,\n                 _is_clobber: bool,\n@@ -89,7 +90,7 @@ macro_rules! def_regs {\n                 match name {\n                     $(\n                         $($alias)|* | $reg_name => {\n-                            $($filter(_arch, _target_features, _target, _is_clobber)?;)?\n+                            $($filter(_arch, _reloc_model, _target_features, _target, _is_clobber)?;)?\n                             Ok(Self::$reg)\n                         }\n                     )*\n@@ -103,6 +104,7 @@ macro_rules! def_regs {\n \n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n+            _reloc_model: crate::spec::RelocModel,\n             _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n             _target: &crate::spec::Target,\n             _map: &mut rustc_data_structures::fx::FxHashMap<\n@@ -113,7 +115,7 @@ macro_rules! def_regs {\n             #[allow(unused_imports)]\n             use super::{InlineAsmReg, InlineAsmRegClass};\n             $(\n-                if $($filter(_arch, _target_features, _target, false).is_ok() &&)? true {\n+                if $($filter(_arch, _reloc_model, _target_features, _target, false).is_ok() &&)? true {\n                     if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n                         set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                     }\n@@ -297,6 +299,7 @@ impl InlineAsmReg {\n \n     pub fn parse(\n         arch: InlineAsmArch,\n+        reloc_model: RelocModel,\n         target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         is_clobber: bool,\n@@ -307,75 +310,75 @@ impl InlineAsmReg {\n         let name = name.as_str();\n         Ok(match arch {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+                Self::X86(X86InlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?)\n             }\n             InlineAsmArch::Arm => {\n-                Self::Arm(ArmInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+                Self::Arm(ArmInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?)\n             }\n             InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmReg::parse(\n                 arch,\n-                target_features,\n+                reloc_model,target_features,\n                 target,\n                 is_clobber,\n                 name,\n             )?),\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => Self::RiscV(\n-                RiscVInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?,\n+                RiscVInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?,\n             ),\n             InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmReg::parse(\n                 arch,\n-                target_features,\n+                reloc_model,target_features,\n                 target,\n                 is_clobber,\n                 name,\n             )?),\n             InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => Self::PowerPC(\n-                PowerPCInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?,\n+                PowerPCInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?,\n             ),\n             InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmReg::parse(\n                 arch,\n-                target_features,\n+                reloc_model,target_features,\n                 target,\n                 is_clobber,\n                 name,\n             )?),\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => Self::Mips(MipsInlineAsmReg::parse(\n                 arch,\n-                target_features,\n+                reloc_model,target_features,\n                 target,\n                 is_clobber,\n                 name,\n             )?),\n             InlineAsmArch::S390x => Self::S390x(S390xInlineAsmReg::parse(\n                 arch,\n-                target_features,\n+                reloc_model,target_features,\n                 target,\n                 is_clobber,\n                 name,\n             )?),\n             InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmReg::parse(\n                 arch,\n-                target_features,\n+                reloc_model,target_features,\n                 target,\n                 is_clobber,\n                 name,\n             )?),\n             InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => Self::Wasm(WasmInlineAsmReg::parse(\n                 arch,\n-                target_features,\n+                reloc_model,target_features,\n                 target,\n                 is_clobber,\n                 name,\n             )?),\n             InlineAsmArch::Bpf => {\n-                Self::Bpf(BpfInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+                Self::Bpf(BpfInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?)\n             }\n             InlineAsmArch::Avr => {\n-                Self::Avr(AvrInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+                Self::Avr(AvrInlineAsmReg::parse(arch, reloc_model,target_features, target, is_clobber, name)?)\n             }\n             InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(\n                 arch,\n-                target_features,\n+                reloc_model,target_features,\n                 target,\n                 is_clobber,\n                 name,\n@@ -749,78 +752,79 @@ impl fmt::Display for InlineAsmType {\n // falling back to an external assembler.\n pub fn allocatable_registers(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &crate::spec::Target,\n ) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n     match arch {\n         InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n             let mut map = x86::regclass_map();\n-            x86::fill_reg_map(arch, target_features, target, &mut map);\n+            x86::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Arm => {\n             let mut map = arm::regclass_map();\n-            arm::fill_reg_map(arch, target_features, target, &mut map);\n+            arm::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::AArch64 => {\n             let mut map = aarch64::regclass_map();\n-            aarch64::fill_reg_map(arch, target_features, target, &mut map);\n+            aarch64::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n             let mut map = riscv::regclass_map();\n-            riscv::fill_reg_map(arch, target_features, target, &mut map);\n+            riscv::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Nvptx64 => {\n             let mut map = nvptx::regclass_map();\n-            nvptx::fill_reg_map(arch, target_features, target, &mut map);\n+            nvptx::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n             let mut map = powerpc::regclass_map();\n-            powerpc::fill_reg_map(arch, target_features, target, &mut map);\n+            powerpc::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Hexagon => {\n             let mut map = hexagon::regclass_map();\n-            hexagon::fill_reg_map(arch, target_features, target, &mut map);\n+            hexagon::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n             let mut map = mips::regclass_map();\n-            mips::fill_reg_map(arch, target_features, target, &mut map);\n+            mips::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::S390x => {\n             let mut map = s390x::regclass_map();\n-            s390x::fill_reg_map(arch, target_features, target, &mut map);\n+            s390x::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::SpirV => {\n             let mut map = spirv::regclass_map();\n-            spirv::fill_reg_map(arch, target_features, target, &mut map);\n+            spirv::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n             let mut map = wasm::regclass_map();\n-            wasm::fill_reg_map(arch, target_features, target, &mut map);\n+            wasm::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Bpf => {\n             let mut map = bpf::regclass_map();\n-            bpf::fill_reg_map(arch, target_features, target, &mut map);\n+            bpf::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Avr => {\n             let mut map = avr::regclass_map();\n-            avr::fill_reg_map(arch, target_features, target, &mut map);\n+            avr::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Msp430 => {\n             let mut map = msp430::regclass_map();\n-            msp430::fill_reg_map(arch, target_features, target, &mut map);\n+            msp430::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n     }\n@@ -853,6 +857,7 @@ impl InlineAsmClobberAbi {\n     /// clobber ABIs for the target.\n     pub fn parse(\n         arch: InlineAsmArch,\n+        reloc_model: RelocModel,\n         target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         name: Symbol,\n@@ -878,7 +883,7 @@ impl InlineAsmClobberAbi {\n             },\n             InlineAsmArch::AArch64 => match name {\n                 \"C\" | \"system\" | \"efiapi\" => {\n-                    Ok(if aarch64::reserved_x18(arch, target_features, target, true).is_err() {\n+                    Ok(if aarch64::reserved_x18(arch, reloc_model, target_features, target, true).is_err() {\n                         InlineAsmClobberAbi::AArch64NoX18\n                     } else {\n                         InlineAsmClobberAbi::AArch64"}, {"sha": "65ce69cb5c0cdf6db0429818762f65720582ae1f", "filename": "compiler/rustc_target/src/asm/riscv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{Target, RelocModel};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n@@ -54,6 +54,7 @@ impl RiscVInlineAsmRegClass {\n \n fn not_e(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,"}, {"sha": "ac6f39f1c955920ccb12113949a2864364655e16", "filename": "compiler/rustc_target/src/asm/x86.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ceb104851c2c3054f680d89f9d9333b5e5110be/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs?ref=1ceb104851c2c3054f680d89f9d9333b5e5110be", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{Target, RelocModel};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -139,6 +139,7 @@ impl X86InlineAsmRegClass {\n \n fn x86_64_only(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -152,6 +153,7 @@ fn x86_64_only(\n \n fn high_byte(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -164,6 +166,7 @@ fn high_byte(\n \n fn rbx_reserved(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -179,6 +182,7 @@ fn rbx_reserved(\n \n fn esi_reserved(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,"}]}