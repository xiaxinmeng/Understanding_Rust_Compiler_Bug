{"sha": "1181f45813428f77c0be077c2d06c28646266280", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExODFmNDU4MTM0MjhmNzdjMGJlMDc3YzJkMDZjMjg2NDYyNjYyODA=", "commit": {"author": {"name": "Maik Klein", "email": "maikklein@googlemail.com", "date": "2017-10-25T15:04:24Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-18T15:08:48Z"}, "message": "Rename TransItem to MonoItem", "tree": {"sha": "c09b9ae61faa38e828613b97eb2679320fbaeb26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c09b9ae61faa38e828613b97eb2679320fbaeb26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1181f45813428f77c0be077c2d06c28646266280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1181f45813428f77c0be077c2d06c28646266280", "html_url": "https://github.com/rust-lang/rust/commit/1181f45813428f77c0be077c2d06c28646266280", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1181f45813428f77c0be077c2d06c28646266280/comments", "author": {"login": "MaikKlein", "id": 1994306, "node_id": "MDQ6VXNlcjE5OTQzMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1994306?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MaikKlein", "html_url": "https://github.com/MaikKlein", "followers_url": "https://api.github.com/users/MaikKlein/followers", "following_url": "https://api.github.com/users/MaikKlein/following{/other_user}", "gists_url": "https://api.github.com/users/MaikKlein/gists{/gist_id}", "starred_url": "https://api.github.com/users/MaikKlein/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MaikKlein/subscriptions", "organizations_url": "https://api.github.com/users/MaikKlein/orgs", "repos_url": "https://api.github.com/users/MaikKlein/repos", "events_url": "https://api.github.com/users/MaikKlein/events{/privacy}", "received_events_url": "https://api.github.com/users/MaikKlein/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e579b067db3eb0ad44826f1767197de34378f89d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e579b067db3eb0ad44826f1767197de34378f89d", "html_url": "https://github.com/rust-lang/rust/commit/e579b067db3eb0ad44826f1767197de34378f89d"}], "stats": {"total": 227, "additions": 116, "deletions": 111}, "files": [{"sha": "5f74f088237837dba1d576a80e4a4692adba4c30", "filename": "src/librustc/middle/trans.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -17,24 +17,24 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n-pub enum TransItem<'tcx> {\n+pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n     Static(NodeId),\n     GlobalAsm(NodeId),\n }\n \n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for TransItem<'tcx> {\n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for MonoItem<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                            hcx: &mut StableHashingContext<'tcx>,\n                                            hasher: &mut StableHasher<W>) {\n         ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            TransItem::Fn(ref instance) => {\n+            MonoItem::Fn(ref instance) => {\n                 instance.hash_stable(hcx, hasher);\n             }\n-            TransItem::Static(node_id)    |\n-            TransItem::GlobalAsm(node_id) => {\n+            MonoItem::Static(node_id)    |\n+            MonoItem::GlobalAsm(node_id) => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                     node_id.hash_stable(hcx, hasher);\n                 })\n@@ -49,7 +49,7 @@ pub struct CodegenUnit<'tcx> {\n     /// contain something unique to this crate (e.g., a module path)\n     /// as well as the crate name and disambiguator.\n     name: InternedString,\n-    items: FxHashMap<TransItem<'tcx>, (Linkage, Visibility)>,\n+    items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -110,12 +110,12 @@ impl<'tcx> CodegenUnit<'tcx> {\n         self.name = name;\n     }\n \n-    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, (Linkage, Visibility)> {\n+    pub fn items(&self) -> &FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)> {\n         &self.items\n     }\n \n     pub fn items_mut(&mut self)\n-        -> &mut FxHashMap<TransItem<'tcx>, (Linkage, Visibility)>\n+        -> &mut FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>\n     {\n         &mut self.items\n     }"}, {"sha": "76494df97d10ad7164a0d4f82147e45f05311cfb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -2471,6 +2471,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn is_sized(self, ty: Ty<'tcx>) -> bool {\n+        ty.is_sized(self, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+    }\n+}\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,"}, {"sha": "89ffd0e5ec4be8c4f4f5b0102d51d7b780a3b694", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -195,7 +195,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n-use rustc::middle::trans::TransItem;\n+use rustc::middle::trans::MonoItem;\n use rustc::traits;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n@@ -226,8 +226,8 @@ pub struct InliningMap<'tcx> {\n     // accessed by it.\n     // The two numbers in the tuple are the start (inclusive) and\n     // end index (exclusive) within the `targets` vecs.\n-    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n-    targets: Vec<TransItem<'tcx>>,\n+    index: FxHashMap<MonoItem<'tcx>, (usize, usize)>,\n+    targets: Vec<MonoItem<'tcx>>,\n \n     // Contains one bit per translation item in the `targets` field. That bit\n     // is true if that translation item needs to be inlined into every CGU.\n@@ -245,9 +245,9 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n \n     fn record_accesses<I>(&mut self,\n-                          source: TransItem<'tcx>,\n+                          source: MonoItem<'tcx>,\n                           new_targets: I)\n-        where I: Iterator<Item=(TransItem<'tcx>, bool)> + ExactSizeIterator\n+        where I: Iterator<Item=(MonoItem<'tcx>, bool)> + ExactSizeIterator\n     {\n         assert!(!self.index.contains_key(&source));\n \n@@ -271,8 +271,8 @@ impl<'tcx> InliningMap<'tcx> {\n \n     // Internally iterate over all items referenced by `source` which will be\n     // made available for inlining.\n-    pub fn with_inlining_candidates<F>(&self, source: TransItem<'tcx>, mut f: F)\n-        where F: FnMut(TransItem<'tcx>)\n+    pub fn with_inlining_candidates<F>(&self, source: MonoItem<'tcx>, mut f: F)\n+        where F: FnMut(MonoItem<'tcx>)\n     {\n         if let Some(&(start_index, end_index)) = self.index.get(&source) {\n             for (i, candidate) in self.targets[start_index .. end_index]\n@@ -287,7 +287,7 @@ impl<'tcx> InliningMap<'tcx> {\n \n     // Internally iterate over all items and the things each accesses.\n     pub fn iter_accesses<F>(&self, mut f: F)\n-        where F: FnMut(TransItem<'tcx>, &[TransItem<'tcx>])\n+        where F: FnMut(MonoItem<'tcx>, &[MonoItem<'tcx>])\n     {\n         for (&accessor, &(start_index, end_index)) in &self.index {\n             f(accessor, &self.targets[start_index .. end_index])\n@@ -297,7 +297,7 @@ impl<'tcx> InliningMap<'tcx> {\n \n pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n-                                                 -> (FxHashSet<TransItem<'tcx>>,\n+                                                 -> (FxHashSet<MonoItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     let roots = collect_roots(tcx, mode);\n \n@@ -321,7 +321,7 @@ pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // start monomorphizing from.\n fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            mode: TransItemCollectionMode)\n-                           -> Vec<TransItem<'tcx>> {\n+                           -> Vec<MonoItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n@@ -350,8 +350,8 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n // Collect all monomorphized translation items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   starting_point: TransItem<'tcx>,\n-                                   visited: &mut FxHashSet<TransItem<'tcx>>,\n+                                   starting_point: MonoItem<'tcx>,\n+                                   visited: &mut FxHashSet<MonoItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n                                    inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n@@ -364,7 +364,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let recursion_depth_reset;\n \n     match starting_point {\n-        TransItem::Static(node_id) => {\n+        MonoItem::Static(node_id) => {\n             let def_id = tcx.hir.local_def_id(node_id);\n             let instance = Instance::mono(tcx, def_id);\n \n@@ -378,7 +378,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             collect_neighbours(tcx, instance, true, &mut neighbors);\n         }\n-        TransItem::Fn(instance) => {\n+        MonoItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n             debug_assert!(should_trans_locally(tcx, &instance));\n \n@@ -390,7 +390,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             collect_neighbours(tcx, instance, false, &mut neighbors);\n         }\n-        TransItem::GlobalAsm(..) => {\n+        MonoItem::GlobalAsm(..) => {\n             recursion_depth_reset = None;\n         }\n     }\n@@ -409,10 +409,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             caller: TransItem<'tcx>,\n-                             callees: &[TransItem<'tcx>],\n+                             caller: MonoItem<'tcx>,\n+                             callees: &[MonoItem<'tcx>],\n                              inlining_map: &mut InliningMap<'tcx>) {\n-    let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n+    let is_inlining_candidate = |trans_item: &MonoItem<'tcx>| {\n         trans_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n \n@@ -495,7 +495,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MirNeighborCollector<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n-    output: &'a mut Vec<TransItem<'tcx>>,\n+    output: &'a mut Vec<MonoItem<'tcx>>,\n     param_substs: &'tcx Substs<'tcx>,\n     const_context: bool,\n }\n@@ -647,7 +647,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         let instance = Instance::mono(tcx, static_.def_id);\n         if should_trans_locally(tcx, &instance) {\n             let node_id = tcx.hir.as_local_node_id(static_.def_id).unwrap();\n-            self.output.push(TransItem::Static(node_id));\n+            self.output.push(MonoItem::Static(node_id));\n         }\n \n         self.super_static(static_, context, location);\n@@ -657,7 +657,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             ty: Ty<'tcx>,\n                             is_direct_call: bool,\n-                            output: &mut Vec<TransItem<'tcx>>)\n+                            output: &mut Vec<MonoItem<'tcx>>)\n {\n     let instance = monomorphize::resolve_drop_in_place(tcx, ty);\n     visit_instance_use(tcx, instance, is_direct_call, output);\n@@ -666,7 +666,7 @@ fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           is_direct_call: bool,\n-                          output: &mut Vec<TransItem<'tcx>>)\n+                          output: &mut Vec<MonoItem<'tcx>>)\n {\n     if let ty::TyFnDef(def_id, substs) = ty.sty {\n         let instance = ty::Instance::resolve(tcx,\n@@ -680,7 +680,7 @@ fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: ty::Instance<'tcx>,\n                                 is_direct_call: bool,\n-                                output: &mut Vec<TransItem<'tcx>>)\n+                                output: &mut Vec<MonoItem<'tcx>>)\n {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n     if !should_trans_locally(tcx, &instance) {\n@@ -838,17 +838,17 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> TransItem<'tcx> {\n+fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> MonoItem<'tcx> {\n     debug!(\"create_fn_trans_item(instance={})\", instance);\n-    TransItem::Fn(instance)\n+    MonoItem::Fn(instance)\n }\n \n /// Creates a `TransItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                    trait_ty: Ty<'tcx>,\n                                                    impl_ty: Ty<'tcx>,\n-                                                   output: &mut Vec<TransItem<'tcx>>) {\n+                                                   output: &mut Vec<MonoItem<'tcx>>) {\n     assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_regions() &&\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n \n@@ -881,7 +881,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mode: TransItemCollectionMode,\n-    output: &'b mut Vec<TransItem<'tcx>>,\n+    output: &'b mut Vec<MonoItem<'tcx>>,\n     entry_fn: Option<DefId>,\n }\n \n@@ -925,13 +925,13 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 debug!(\"RootCollector: ItemGlobalAsm({})\",\n                        def_id_to_string(self.tcx,\n                                         self.tcx.hir.local_def_id(item.id)));\n-                self.output.push(TransItem::GlobalAsm(item.id));\n+                self.output.push(MonoItem::GlobalAsm(item.id));\n             }\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n                        def_id_to_string(self.tcx,\n                                         self.tcx.hir.local_def_id(item.id)));\n-                self.output.push(TransItem::Static(item.id));\n+                self.output.push(MonoItem::Static(item.id));\n             }\n             hir::ItemConst(..) => {\n                 // const items only generate translation items if they are\n@@ -946,7 +946,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                            def_id_to_string(tcx, def_id));\n \n                     let instance = Instance::mono(tcx, def_id);\n-                    self.output.push(TransItem::Fn(instance));\n+                    self.output.push(MonoItem::Fn(instance));\n                 }\n             }\n         }\n@@ -968,7 +968,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                            def_id_to_string(tcx, def_id));\n \n                     let instance = Instance::mono(tcx, def_id);\n-                    self.output.push(TransItem::Fn(instance));\n+                    self.output.push(MonoItem::Fn(instance));\n                 }\n             }\n             _ => { /* Nothing to do here */ }\n@@ -999,7 +999,7 @@ fn item_has_type_parameters<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n \n fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   item: &'tcx hir::Item,\n-                                                  output: &mut Vec<TransItem<'tcx>>) {\n+                                                  output: &mut Vec<MonoItem<'tcx>>) {\n     match item.node {\n         hir::ItemImpl(_,\n                       _,\n@@ -1053,7 +1053,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: Instance<'tcx>,\n                                 const_context: bool,\n-                                output: &mut Vec<TransItem<'tcx>>)\n+                                output: &mut Vec<MonoItem<'tcx>>)\n {\n     let mir = tcx.instance_mir(instance.def);\n "}, {"sha": "a37a64203532899a8b2006f55b0d537ad194be90", "filename": "src/librustc_mir/monomorphize/mono_item.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_mir%2Fmonomorphize%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_mir%2Fmonomorphize%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmono_item.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -28,7 +28,7 @@ use syntax::attr::{self, InlineAttr};\n use std::fmt::{self, Write};\n use std::iter;\n \n-pub use rustc::middle::trans::TransItem;\n+pub use rustc::middle::trans::MonoItem;\n \n pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n     use rustc::middle::trans::Linkage::*;\n@@ -83,7 +83,7 @@ pub enum InstantiationMode {\n }\n \n pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n-    fn as_trans_item(&self) -> &TransItem<'tcx>;\n+    fn as_trans_item(&self) -> &MonoItem<'tcx>;\n \n     fn instantiation_mode(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -94,7 +94,7 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n             });\n \n         match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => {\n+            MonoItem::Fn(ref instance) => {\n                 // If this function isn't inlined or otherwise has explicit\n                 // linkage, then we'll be creating a globally shared version.\n                 if self.explicit_linkage(tcx).is_some() ||\n@@ -123,20 +123,20 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n                     }\n                 }\n             }\n-            TransItem::Static(..) => {\n+            MonoItem::Static(..) => {\n                 InstantiationMode::GloballyShared { may_conflict: false }\n             }\n-            TransItem::GlobalAsm(..) => {\n+            MonoItem::GlobalAsm(..) => {\n                 InstantiationMode::GloballyShared { may_conflict: false }\n             }\n         }\n     }\n \n     fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n         let def_id = match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => instance.def_id(),\n-            TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n-            TransItem::GlobalAsm(..) => return None,\n+            MonoItem::Fn(ref instance) => instance.def_id(),\n+            MonoItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n+            MonoItem::GlobalAsm(..) => return None,\n         };\n \n         let attributes = tcx.get_attrs(def_id);\n@@ -184,10 +184,10 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n     fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n-            TransItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n+            MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n+            MonoItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n             // global asm never has predicates\n-            TransItem::GlobalAsm(..) => return true\n+            MonoItem::GlobalAsm(..) => return true\n         };\n \n         let predicates = tcx.predicates_of(def_id).predicates.subst(tcx, substs);\n@@ -198,15 +198,15 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n         let hir_map = &tcx.hir;\n \n         return match *self.as_trans_item() {\n-            TransItem::Fn(instance) => {\n+            MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance)\n             },\n-            TransItem::Static(node_id) => {\n+            MonoItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n                 let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n                 to_string_internal(tcx, \"static \", instance)\n             },\n-            TransItem::GlobalAsm(..) => {\n+            MonoItem::GlobalAsm(..) => {\n                 \"global_asm\".to_string()\n             }\n         };\n@@ -224,8 +224,8 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n     }\n }\n \n-impl<'a, 'tcx> TransItemExt<'a, 'tcx> for TransItem<'tcx> {\n-    fn as_trans_item(&self) -> &TransItem<'tcx> {\n+impl<'a, 'tcx> TransItemExt<'a, 'tcx> for MonoItem<'tcx> {\n+    fn as_trans_item(&self) -> &MonoItem<'tcx> {\n         self\n     }\n }"}, {"sha": "2cf90ba881696431cb61d40f340aebe49b377b1b", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -101,7 +101,7 @@ use monomorphize::Instance;\n use trans_item::{BaseTransItemExt, InstantiationMode};\n \n use rustc::middle::weak_lang_items;\n-use rustc::middle::trans::TransItem;\n+use rustc::middle::trans::MonoItem;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -211,7 +211,7 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // codegen units) then this symbol may become an exported (but hidden\n         // visibility) symbol. This means that multiple crates may do the same\n         // and we want to be sure to avoid any symbol conflicts here.\n-        match TransItem::Fn(instance).instantiation_mode(tcx) {\n+        match MonoItem::Fn(instance).instantiation_mode(tcx) {\n             InstantiationMode::GloballyShared { may_conflict: true } => {\n                 avoid_cross_crate_conflicts = true;\n             }"}, {"sha": "6f7a0a095d5755c87a0c9264f281476d1597d1bc", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -67,7 +67,7 @@ use monomorphize::Instance;\n use partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n use symbol_names_test;\n use time_graph;\n-use trans_item::{TransItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n+use trans_item::{MonoItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n@@ -530,7 +530,7 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n     let instance = Instance::mono(ccx.tcx(), main_def_id);\n \n-    if !ccx.codegen_unit().contains_item(&TransItem::Fn(instance)) {\n+    if !ccx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n@@ -943,7 +943,7 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n #[inline(never)] // give this a place in the profiler\n fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n-    where I: Iterator<Item=&'a TransItem<'tcx>>\n+    where I: Iterator<Item=&'a MonoItem<'tcx>>\n {\n     let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n         (trans_item, trans_item.symbol_name(tcx))\n@@ -1042,7 +1042,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n \n     let translation_items: DefIdSet = items.iter().filter_map(|trans_item| {\n         match *trans_item {\n-            TransItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n             _ => None,\n         }\n     }).collect();"}, {"sha": "5ec4185c042f29ad728576147c1e633171e5e7d9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::map as hir_map;\n use rustc::middle::const_val::ConstEvalErr;\n use debuginfo;\n use base;\n-use trans_item::{TransItem, TransItemExt};\n+use trans_item::{MonoItem, TransItemExt};\n use common::{self, CrateContext, val_ty};\n use declare;\n use monomorphize::Instance;\n@@ -118,11 +118,11 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = TransItem::Static(id).symbol_name(ccx.tcx());\n+                let sym = MonoItem::Static(id).symbol_name(ccx.tcx());\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n-                                                         .contains_key(&TransItem::Static(id));\n+                                                         .contains_key(&MonoItem::Static(id));\n                 assert!(!defined_in_current_codegen_unit);\n \n                 if declare::get_declared_value(ccx, &sym[..]).is_some() {"}, {"sha": "593c503fbfc52ad76be07dbf2ca427accd04b143", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -114,7 +114,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use std::collections::hash_map::Entry;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use trans_item::{TransItem, BaseTransItemExt, TransItemExt, InstantiationMode};\n+use trans_item::{MonoItem, BaseTransItemExt, TransItemExt, InstantiationMode};\n \n pub use rustc::middle::trans::CodegenUnit;\n \n@@ -129,7 +129,7 @@ pub enum PartitioningStrategy {\n pub trait CodegenUnitExt<'tcx> {\n     fn as_codegen_unit(&self) -> &CodegenUnit<'tcx>;\n \n-    fn contains_item(&self, item: &TransItem<'tcx>) -> bool {\n+    fn contains_item(&self, item: &MonoItem<'tcx>) -> bool {\n         self.items().contains_key(item)\n     }\n \n@@ -139,7 +139,7 @@ pub trait CodegenUnitExt<'tcx> {\n         &self.as_codegen_unit().name()\n     }\n \n-    fn items(&self) -> &FxHashMap<TransItem<'tcx>, (Linkage, Visibility)> {\n+    fn items(&self) -> &FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)> {\n         &self.as_codegen_unit().items()\n     }\n \n@@ -149,17 +149,17 @@ pub trait CodegenUnitExt<'tcx> {\n \n     fn items_in_deterministic_order<'a>(&self,\n                                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                        -> Vec<(TransItem<'tcx>,\n-                                               (Linkage, Visibility))> {\n+                                        -> Vec<(MonoItem<'tcx>,\n+                                                (Linkage, Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n         pub struct ItemSortKey(Option<NodeId>, ty::SymbolName);\n \n         fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   item: TransItem<'tcx>) -> ItemSortKey {\n+                                   item: MonoItem<'tcx>) -> ItemSortKey {\n             ItemSortKey(match item {\n-                TransItem::Fn(ref instance) => {\n+                MonoItem::Fn(ref instance) => {\n                     match instance.def {\n                         // We only want to take NodeIds of user-defined\n                         // instances into account. The others don't matter for\n@@ -178,8 +178,8 @@ pub trait CodegenUnitExt<'tcx> {\n                         }\n                     }\n                 }\n-                TransItem::Static(node_id) |\n-                TransItem::GlobalAsm(node_id) => {\n+                MonoItem::Static(node_id) |\n+                MonoItem::GlobalAsm(node_id) => {\n                     Some(node_id)\n                 }\n             }, item.symbol_name(tcx))\n@@ -207,7 +207,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               strategy: PartitioningStrategy,\n                               inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n-    where I: Iterator<Item = TransItem<'tcx>>\n+    where I: Iterator<Item = MonoItem<'tcx>>\n {\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n@@ -254,8 +254,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct PreInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<TransItem<'tcx>>,\n-    internalization_candidates: FxHashSet<TransItem<'tcx>>,\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n /// For symbol internalization, we need to know whether a symbol/trans-item is\n@@ -269,14 +269,14 @@ enum TransItemPlacement {\n \n struct PostInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n-    trans_item_placements: FxHashMap<TransItem<'tcx>, TransItemPlacement>,\n-    internalization_candidates: FxHashSet<TransItem<'tcx>>,\n+    trans_item_placements: FxHashMap<MonoItem<'tcx>, TransItemPlacement>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trans_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n-    where I: Iterator<Item = TransItem<'tcx>>\n+    where I: Iterator<Item = MonoItem<'tcx>>\n {\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n@@ -309,7 +309,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Some(explicit_linkage) => (explicit_linkage, Visibility::Default),\n             None => {\n                 match trans_item {\n-                    TransItem::Fn(ref instance) => {\n+                    MonoItem::Fn(ref instance) => {\n                         let visibility = match instance.def {\n                             InstanceDef::Item(def_id) => {\n                                 if def_id.is_local() {\n@@ -333,8 +333,8 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         };\n                         (Linkage::External, visibility)\n                     }\n-                    TransItem::Static(node_id) |\n-                    TransItem::GlobalAsm(node_id) => {\n+                    MonoItem::Static(node_id) |\n+                    MonoItem::GlobalAsm(node_id) => {\n                         let def_id = tcx.hir.local_def_id(node_id);\n                         let visibility = if tcx.is_exported_symbol(def_id) {\n                             Visibility::Default\n@@ -469,9 +469,9 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n         internalization_candidates,\n     };\n \n-    fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n+    fn follow_inlining<'tcx>(trans_item: MonoItem<'tcx>,\n                              inlining_map: &InliningMap<'tcx>,\n-                             visited: &mut FxHashSet<TransItem<'tcx>>) {\n+                             visited: &mut FxHashSet<MonoItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }\n@@ -501,7 +501,7 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Build a map from every translation item to all the translation items that\n     // reference it.\n-    let mut accessor_map: FxHashMap<TransItem<'tcx>, Vec<TransItem<'tcx>>> = FxHashMap();\n+    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = FxHashMap();\n     inlining_map.iter_accesses(|accessor, accessees| {\n         for accessee in accessees {\n             accessor_map.entry(*accessee)\n@@ -548,10 +548,10 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 trans_item: TransItem<'tcx>)\n+                                                 trans_item: MonoItem<'tcx>)\n                                                  -> Option<DefId> {\n     match trans_item {\n-        TransItem::Fn(instance) => {\n+        MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n                 ty::InstanceDef::Item(def_id) => def_id,\n                 ty::InstanceDef::FnPtrShim(..) |\n@@ -583,8 +583,8 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             Some(def_id)\n         }\n-        TransItem::Static(node_id) |\n-        TransItem::GlobalAsm(node_id) => Some(tcx.hir.local_def_id(node_id)),\n+        MonoItem::Static(node_id) |\n+        MonoItem::GlobalAsm(node_id) => Some(tcx.hir.local_def_id(node_id)),\n     }\n }\n "}, {"sha": "33927cd4a1ddcb9528a9065056f44a20b0cec7e2", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1181f45813428f77c0be077c2d06c28646266280/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=1181f45813428f77c0be077c2d06c28646266280", "patch": "@@ -34,7 +34,7 @@ use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n use std::fmt;\n \n-pub use rustc::middle::trans::TransItem;\n+pub use rustc::middle::trans::MonoItem;\n \n pub use rustc_mir::monomorphize::mono_item::*;\n pub use rustc_mir::monomorphize::mono_item::TransItemExt as BaseTransItemExt;\n@@ -47,7 +47,7 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n                ccx.codegen_unit().name());\n \n         match *self.as_trans_item() {\n-            TransItem::Static(node_id) => {\n+            MonoItem::Static(node_id) => {\n                 let tcx = ccx.tcx();\n                 let item = tcx.hir.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, _) = item.node {\n@@ -61,15 +61,15 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n                 }\n             }\n-            TransItem::GlobalAsm(node_id) => {\n+            MonoItem::GlobalAsm(node_id) => {\n                 let item = ccx.tcx().hir.expect_item(node_id);\n                 if let hir::ItemGlobalAsm(ref ga) = item.node {\n                     asm::trans_global_asm(ccx, ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n                 }\n             }\n-            TransItem::Fn(instance) => {\n+            MonoItem::Fn(instance) => {\n                 base::trans_instance(&ccx, instance);\n             }\n         }\n@@ -94,13 +94,13 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n         debug!(\"symbol {}\", &symbol_name);\n \n         match *self.as_trans_item() {\n-            TransItem::Static(node_id) => {\n+            MonoItem::Static(node_id) => {\n                 predefine_static(ccx, node_id, linkage, visibility, &symbol_name);\n             }\n-            TransItem::Fn(instance) => {\n+            MonoItem::Fn(instance) => {\n                 predefine_fn(ccx, instance, linkage, visibility, &symbol_name);\n             }\n-            TransItem::GlobalAsm(..) => {}\n+            MonoItem::GlobalAsm(..) => {}\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n@@ -111,12 +111,12 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n \n     fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n         match *self.as_trans_item() {\n-            TransItem::Fn(instance) => tcx.symbol_name(instance),\n-            TransItem::Static(node_id) => {\n+            MonoItem::Fn(instance) => tcx.symbol_name(instance),\n+            MonoItem::Static(node_id) => {\n                 let def_id = tcx.hir.local_def_id(node_id);\n                 tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n-            TransItem::GlobalAsm(node_id) => {\n+            MonoItem::GlobalAsm(node_id) => {\n                 let def_id = tcx.hir.local_def_id(node_id);\n                 ty::SymbolName {\n                     name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_str()\n@@ -127,44 +127,44 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n \n     fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n         match *self.as_trans_item() {\n-            TransItem::Fn(Instance { def, .. }) => {\n+            MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir.as_local_node_id(def.def_id())\n             }\n-            TransItem::Static(node_id) |\n-            TransItem::GlobalAsm(node_id) => {\n+            MonoItem::Static(node_id) |\n+            MonoItem::GlobalAsm(node_id) => {\n                 Some(node_id)\n             }\n         }.map(|node_id| tcx.hir.span(node_id))\n     }\n \n     fn is_generic_fn(&self) -> bool {\n         match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => {\n+            MonoItem::Fn(ref instance) => {\n                 instance.substs.types().next().is_some()\n             }\n-            TransItem::Static(..) |\n-            TransItem::GlobalAsm(..) => false,\n+            MonoItem::Static(..) |\n+            MonoItem::GlobalAsm(..) => false,\n         }\n     }\n \n     fn to_raw_string(&self) -> String {\n         match *self.as_trans_item() {\n-            TransItem::Fn(instance) => {\n+            MonoItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n                          instance.def,\n                          instance.substs.as_ptr() as usize)\n             }\n-            TransItem::Static(id) => {\n+            MonoItem::Static(id) => {\n                 format!(\"Static({:?})\", id)\n             }\n-            TransItem::GlobalAsm(id) => {\n+            MonoItem::GlobalAsm(id) => {\n                 format!(\"GlobalAsm({:?})\", id)\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> TransItemExt<'a, 'tcx> for TransItem<'tcx> {}\n+impl<'a, 'tcx> TransItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n \n fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               node_id: ast::NodeId,"}]}