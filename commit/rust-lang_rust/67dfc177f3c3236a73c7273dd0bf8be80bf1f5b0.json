{"sha": "67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZGZjMTc3ZjNjMzIzNmE3M2M3MjczZGQwYmY4YmU4MGJmMWY1YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T10:46:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T10:46:14Z"}, "message": "Auto merge of #25323 - eddyb:coherent-coherence, r=pnkfelix\n\nThe loop to load all the known impls from external crates seems to have been used because `ty::populate_implementations_for_trait_if_necessary` wasn't doing its job, and solely relying on it resulted in loading only impls in the same crate as the trait.\r\n\r\nCoherence for `librustc` was reduced from 18.310s to 0.610s, from stage1 to stage2.\r\nInterestingly, type checking also went from 46.232s to 42.003s, though that could be noise or unrelated improvements.\r\n\r\nOn a smaller scale, `fn main() {}` now spends 0.003s in coherence instead of 0.368s, which fixes #22068.\r\nIt also peaks at only 1.2MB, instead of 16MB of heap usage.", "tree": {"sha": "ac754b272723e7865906ccfc41eef81d5a9291c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac754b272723e7865906ccfc41eef81d5a9291c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "html_url": "https://github.com/rust-lang/rust/commit/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feac9f1c7b17903ef14ff46bc24c2baa45f3b15f", "url": "https://api.github.com/repos/rust-lang/rust/commits/feac9f1c7b17903ef14ff46bc24c2baa45f3b15f", "html_url": "https://github.com/rust-lang/rust/commit/feac9f1c7b17903ef14ff46bc24c2baa45f3b15f"}, {"sha": "75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f", "html_url": "https://github.com/rust-lang/rust/commit/75cd8f94e1f6319f92f837f9ef6884fafca8fb6f"}], "stats": {"total": 392, "additions": 148, "deletions": 244}, "files": [{"sha": "b6202084296bb400b87ca669632d9040694354c4", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -189,6 +189,7 @@ pub const tag_item_impl_vtables: usize = 0x7e;\n \n pub const tag_impls: usize = 0x109; // top-level only\n pub const tag_impls_impl: usize = 0x7f;\n+pub const tag_impls_impl_trait_def_id: usize = 0x8d;\n \n pub const tag_items_data_item_inherent_impl: usize = 0x80;\n pub const tag_items_data_item_extension_impl: usize = 0x81;"}, {"sha": "6caefec48783afe89549aa4a922642995039ab91", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -304,31 +304,23 @@ pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n     decoder::get_native_libraries(&*cdata)\n }\n \n-pub fn each_impl<F>(cstore: &cstore::CStore,\n-                    crate_num: ast::CrateNum,\n-                    callback: F) where\n-    F: FnMut(ast::DefId),\n-{\n-    let cdata = cstore.get_crate_data(crate_num);\n-    decoder::each_impl(&*cdata, callback)\n-}\n-\n-pub fn each_implementation_for_type<F>(cstore: &cstore::CStore,\n-                                       def_id: ast::DefId,\n-                                       callback: F) where\n+pub fn each_inherent_implementation_for_type<F>(cstore: &cstore::CStore,\n+                                                def_id: ast::DefId,\n+                                                callback: F) where\n     F: FnMut(ast::DefId),\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_implementation_for_type(&*cdata, def_id.node, callback)\n+    decoder::each_inherent_implementation_for_type(&*cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n                                         def_id: ast::DefId,\n-                                        callback: F) where\n+                                        mut callback: F) where\n     F: FnMut(ast::DefId),\n {\n-    let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_implementation_for_trait(&*cdata, def_id.node, callback)\n+    cstore.iter_crate_data(|_, cdata| {\n+        decoder::each_implementation_for_trait(cdata, def_id, &mut callback)\n+    })\n }\n \n /// If the given def ID describes an item belonging to a trait (either a"}, {"sha": "382dc437bdc4829c0b3effe1b22cd5a2cfae6513", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 85, "deletions": 78, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -21,7 +21,8 @@ use metadata::common::*;\n use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n-use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n+use metadata::encoder::def_to_u64;\n+use metadata::tydecode::{parse_ty_data, parse_region_data,\n                          parse_type_param_def_data, parse_bare_fn_ty_data,\n                          parse_trait_ref_data, parse_predicate_data};\n use middle::def;\n@@ -190,29 +191,32 @@ fn item_symbol(item: rbml::Doc) -> String {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n }\n \n-fn item_parent_item(d: rbml::Doc) -> Option<ast::DefId> {\n+fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n+    let id = reader::doc_as_u64(d);\n+    let def_id = ast::DefId { krate: (id >> 32) as u32, node: id as u32 };\n+    translate_def_id(cdata, def_id)\n+}\n+\n+fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<ast::DefId> {\n     let mut ret = None;\n     reader::tagged_docs(d, tag_items_data_parent_item, |did| {\n-        ret = Some(reader::with_doc_data(did, parse_def_id));\n+        ret = Some(translated_def_id(cdata, did));\n         false\n     });\n     ret\n }\n \n-fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n-                                        d: rbml::Doc) -> ast::DefId {\n-    let trait_did = item_parent_item(d).expect(\"item without parent\");\n-    ast::DefId { krate: cnum, node: trait_did.node }\n+fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n+    translated_def_id(cdata, reader::get_doc(d, tag_items_data_parent_item))\n }\n \n fn item_def_id(d: rbml::Doc, cdata: Cmd) -> ast::DefId {\n-    let tagdoc = reader::get_doc(d, tag_def_id);\n-    return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+    translated_def_id(cdata, reader::get_doc(d, tag_def_id))\n }\n \n fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n-        translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n+        translated_def_id(cdata, doc)\n     })\n }\n \n@@ -261,14 +265,12 @@ fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n }\n \n fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n-    let mut ids: Vec<ast::DefId> = Vec::new();\n-    let v = tag_items_data_item_variant;\n-    reader::tagged_docs(item, v, |p| {\n-        let ext = reader::with_doc_data(p, parse_def_id);\n-        ids.push(ast::DefId { krate: cdata.cnum, node: ext.node });\n+    let mut ids = vec![];\n+    reader::tagged_docs(item, tag_items_data_item_variant, |p| {\n+        ids.push(translated_def_id(cdata, p));\n         true\n     });\n-    return ids;\n+    ids\n }\n \n fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n@@ -303,8 +305,7 @@ fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     }\n }\n \n-fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n-    -> DefLike {\n+fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: ast::DefId) -> DefLike {\n     let fam = item_family(item);\n     match fam {\n         Constant  => {\n@@ -314,11 +315,9 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n                 // See the comment for methods below.\n                 let provenance = if reader::maybe_get_doc(\n                       item, tag_item_trait_parent_sort).is_some() {\n-                    def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n-                                                                        item))\n+                    def::FromTrait(item_require_parent_item(cdata, item))\n                 } else {\n-                    def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n-                                                                       item))\n+                    def::FromImpl(item_require_parent_item(cdata, item))\n                 };\n                 DlDef(def::DefAssociatedConst(did, provenance))\n             } else {\n@@ -339,17 +338,15 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             // a trait_parent_sort.\n             let provenance = if reader::maybe_get_doc(\n                   item, tag_item_trait_parent_sort).is_some() {\n-                def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n-                                                                    item))\n+                def::FromTrait(item_require_parent_item(cdata, item))\n             } else {\n-                def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n-                                                                   item))\n+                def::FromImpl(item_require_parent_item(cdata, item))\n             };\n             DlDef(def::DefMethod(did, provenance))\n         }\n         Type => {\n             if item_sort(item) == Some('t') {\n-                let trait_did = item_reqd_and_translated_parent_item(cnum, item);\n+                let trait_did = item_require_parent_item(cdata, item);\n                 DlDef(def::DefAssociatedTy(trait_did, did))\n             } else {\n                 DlDef(def::DefTy(did, false))\n@@ -358,11 +355,11 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n         Mod => DlDef(def::DefMod(did)),\n         ForeignMod => DlDef(def::DefForeignMod(did)),\n         StructVariant => {\n-            let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n+            let enum_did = item_require_parent_item(cdata, item);\n             DlDef(def::DefVariant(enum_did, did, true))\n         }\n         TupleVariant => {\n-            let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n+            let enum_did = item_require_parent_item(cdata, item);\n             DlDef(def::DefVariant(enum_did, did, false))\n         }\n         Trait => DlDef(def::DefTrait(did)),\n@@ -560,9 +557,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n {\n     // Iterate over all children.\n     let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n-        let child_def_id = reader::with_doc_data(child_info_doc,\n-                                                 parse_def_id);\n-        let child_def_id = translate_def_id(cdata, child_def_id);\n+        let child_def_id = translated_def_id(cdata, child_info_doc);\n \n         // This item may be in yet another crate if it was the child of a\n         // reexport.\n@@ -584,9 +579,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n                 let child_name = item_name(&*intr, child_item_doc);\n-                let def_like = item_to_def_like(child_item_doc,\n-                                                child_def_id,\n-                                                cdata.cnum);\n+                let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n                 let visibility = item_visibility(child_item_doc);\n                 callback(def_like, child_name, visibility);\n \n@@ -615,9 +608,8 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n                         let static_method_name = item_name(&*intr, impl_method_doc);\n-                        let static_method_def_like = item_to_def_like(impl_method_doc,\n-                                                                      impl_item_def_id,\n-                                                                      cdata.cnum);\n+                        let static_method_def_like = item_to_def_like(cdata, impl_method_doc,\n+                                                                      impl_item_def_id);\n                         callback(static_method_def_like,\n                                  static_method_name,\n                                  item_visibility(impl_method_doc));\n@@ -633,9 +625,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n     let _ = each_reexport(item_doc, |reexport_doc| {\n         let def_id_doc = reader::get_doc(reexport_doc,\n                                          tag_items_data_item_reexport_def_id);\n-        let child_def_id = reader::with_doc_data(def_id_doc,\n-                                                 parse_def_id);\n-        let child_def_id = translate_def_id(cdata, child_def_id);\n+        let child_def_id = translated_def_id(cdata, def_id_doc);\n \n         let name_doc = reader::get_doc(reexport_doc,\n                                        tag_items_data_item_reexport_name);\n@@ -657,9 +647,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         // Get the item.\n         if let Some(child_item_doc) = maybe_find_item(child_def_id.node, other_crates_items) {\n             // Hand off the item to the callback.\n-            let def_like = item_to_def_like(child_item_doc,\n-                                            child_def_id,\n-                                            child_def_id.krate);\n+            let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n             // a public re-export.\n             callback(def_like, token::intern(name), ast::Public);\n@@ -733,9 +721,8 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::FoundAst::Found(ii),\n         Err(path) => {\n-            match item_parent_item(item_doc) {\n+            match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n-                    let did = translate_def_id(cdata, did);\n                     let parent_item = lookup_item(did.node, cdata.data());\n                     match decode_inlined_item(cdata, tcx, path, parent_item) {\n                         Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n@@ -759,7 +746,7 @@ pub fn get_enum_variant_defs(intr: &IdentInterner,\n         let item = find_item(did.node, items);\n         let name = item_name(intr, item);\n         let visibility = item_visibility(item);\n-        match item_to_def_like(item, *did, cdata.cnum) {\n+        match item_to_def_like(cdata, item, *did) {\n             DlDef(def @ def::DefVariant(..)) => (def, name, visibility),\n             _ => unreachable!()\n         }\n@@ -889,8 +876,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n \n     let def_id = item_def_id(method_doc, cdata);\n \n-    let container_id = item_reqd_and_translated_parent_item(cdata.cnum,\n-                                                            method_doc);\n+    let container_id = item_require_parent_item(cdata, method_doc);\n     let container_doc = lookup_item(container_id.node, cdata.data());\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n@@ -1094,7 +1080,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n     let item = lookup_item(node_id, cdata.data());\n     let mut ret = None;\n     reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor, |_| {\n-        ret = Some(item_reqd_and_translated_parent_item(cdata.cnum, item));\n+        ret = Some(item_require_parent_item(cdata, item));\n         false\n     });\n     ret\n@@ -1144,7 +1130,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n             let name = item_name(&*intr, an_item);\n             let did = item_def_id(an_item, cdata);\n             let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n-            let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+            let origin_id =  translated_def_id(cdata, tagdoc);\n             result.push(ty::field_ty {\n                 name: name,\n                 id: did,\n@@ -1158,7 +1144,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n         let did = item_def_id(an_item, cdata);\n         let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n         let f = item_family(an_item);\n-        let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+        let origin_id =  translated_def_id(cdata, tagdoc);\n         result.push(ty::field_ty {\n             name: special_idents::unnamed_field.name,\n             id: did,\n@@ -1342,55 +1328,77 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n     }\n }\n \n-pub fn each_impl<F>(cdata: Cmd, mut callback: F) where\n-    F: FnMut(ast::DefId),\n-{\n-    let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n-    let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n-        callback(item_def_id(impl_doc, cdata));\n-        true\n-    });\n+// Translate a DefId from the current compilation environment to a DefId\n+// for an external crate.\n+fn reverse_translate_def_id(cdata: Cmd, did: ast::DefId) -> Option<ast::DefId> {\n+    if did.krate == cdata.cnum {\n+        return Some(ast::DefId { krate: ast::LOCAL_CRATE, node: did.node });\n+    }\n+\n+    for (&local, &global) in &cdata.cnum_map {\n+        if global == did.krate {\n+            return Some(ast::DefId { krate: local, node: did.node });\n+        }\n+    }\n+\n+    None\n }\n \n-pub fn each_implementation_for_type<F>(cdata: Cmd,\n-                                       id: ast::NodeId,\n-                                       mut callback: F)\n+pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n+                                                id: ast::NodeId,\n+                                                mut callback: F)\n     where F: FnMut(ast::DefId),\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc,\n                         tag_items_data_item_inherent_impl,\n                         |impl_doc| {\n-        let implementation_def_id = item_def_id(impl_doc, cdata);\n-        callback(implementation_def_id);\n+        if reader::maybe_get_doc(impl_doc, tag_item_trait_ref).is_none() {\n+            callback(item_def_id(impl_doc, cdata));\n+        }\n         true\n     });\n }\n \n pub fn each_implementation_for_trait<F>(cdata: Cmd,\n-                                        id: ast::NodeId,\n+                                        def_id: ast::DefId,\n                                         mut callback: F) where\n     F: FnMut(ast::DefId),\n {\n-    let item_doc = lookup_item(id, cdata.data());\n+    if cdata.cnum == def_id.krate {\n+        let item_doc = lookup_item(def_id.node, cdata.data());\n+        let _ = reader::tagged_docs(item_doc,\n+                                    tag_items_data_item_extension_impl,\n+                                    |impl_doc| {\n+            callback(item_def_id(impl_doc, cdata));\n+            true\n+        });\n+        return;\n+    }\n \n-    let _ = reader::tagged_docs(item_doc,\n-                                tag_items_data_item_extension_impl,\n-                                |impl_doc| {\n-        let implementation_def_id = item_def_id(impl_doc, cdata);\n-        callback(implementation_def_id);\n-        true\n-    });\n+    // Do a reverse lookup beforehand to avoid touching the crate_num\n+    // hash map in the loop below.\n+    if let Some(crate_local_did) = reverse_translate_def_id(cdata, def_id) {\n+        let def_id_u64 = def_to_u64(crate_local_did);\n+\n+        let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n+        let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n+            let impl_trait = reader::get_doc(impl_doc, tag_impls_impl_trait_def_id);\n+            if reader::doc_as_u64(impl_trait) == def_id_u64 {\n+                callback(item_def_id(impl_doc, cdata));\n+            }\n+            true\n+        });\n+    }\n }\n \n pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n                          -> Option<ast::DefId> {\n     let item_doc = lookup_item(id, cdata.data());\n-    let parent_item_id = match item_parent_item(item_doc) {\n+    let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n         Some(item_id) => item_id,\n     };\n-    let parent_item_id = translate_def_id(cdata, parent_item_id);\n     let parent_item_doc = lookup_item(parent_item_id.node, cdata.data());\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n@@ -1538,8 +1546,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let name = item_name(&*token::get_ident_interner(), ident_str_doc);\n         let def_id_doc = reader::get_doc(rp_doc,\n                                          tag_region_param_def_def_id);\n-        let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-        let def_id = translate_def_id(cdata, def_id);\n+        let def_id = translated_def_id(cdata, def_id_doc);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n         let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as usize);"}, {"sha": "afc71f83975c221abe05ba7bbc15b9b38925e78e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -91,8 +91,8 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Name) {\n     rbml_w.wr_tagged_str(tag_item_impl_type_basename, &token::get_name(name));\n }\n \n-pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id));\n+fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n+    rbml_w.wr_tagged_u64(tag_def_id, def_to_u64(id));\n }\n \n #[derive(Clone)]\n@@ -122,6 +122,10 @@ fn encode_family(rbml_w: &mut Encoder, c: char) {\n     rbml_w.wr_tagged_u8(tag_items_data_item_family, c as u8);\n }\n \n+pub fn def_to_u64(did: DefId) -> u64 {\n+    (did.krate as u64) << 32 | (did.node as u64)\n+}\n+\n pub fn def_to_string(did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.node)\n }\n@@ -153,9 +157,9 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n }\n \n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n-    let s = def_to_string(vid);\n-    rbml_w.wr_tagged_str(tag_items_data_item_variant, &s[..]);\n-    rbml_w.wr_tagged_str(tag_mod_child, &s[..]);\n+    let id = def_to_u64(vid);\n+    rbml_w.wr_tagged_u64(tag_items_data_item_variant, id);\n+    rbml_w.wr_tagged_u64(tag_mod_child, id);\n }\n \n pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -260,7 +264,7 @@ fn encode_disr_val(_: &EncodeContext,\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_items_data_parent_item, &def_to_string(id));\n+    rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n@@ -275,7 +279,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n         }\n         encode_struct_field_family(rbml_w, f.vis);\n         encode_def_id(rbml_w, f.id);\n-        rbml_w.wr_tagged_str(tag_item_field_origin, &def_to_string(origin));\n+        rbml_w.wr_tagged_u64(tag_item_field_origin, def_to_u64(origin));\n         rbml_w.end_tag();\n     }\n }\n@@ -358,8 +362,8 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n-    rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n-                         &def_to_string(method_def_id));\n+    rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n+                         def_to_u64(method_def_id));\n     rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n                          &format!(\"{}::{}\", exp.name,\n                                             token::get_name(method_name)));\n@@ -495,8 +499,8 @@ fn encode_reexports(ecx: &EncodeContext,\n                        exp.def_id.node,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n-                rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n-                                     &def_to_string(exp.def_id));\n+                rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n+                                     def_to_u64(exp.def_id));\n                 rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n                                      exp.name.as_str());\n                 rbml_w.end_tag();\n@@ -526,12 +530,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode info about all the module children.\n     for item in &md.items {\n-        rbml_w.wr_tagged_str(tag_mod_child,\n-                             &def_to_string(local_def(item.id)));\n+        rbml_w.wr_tagged_u64(tag_mod_child,\n+                             def_to_u64(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(auxiliary_node_id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(auxiliary_node_id)));\n             true\n         });\n \n@@ -541,8 +545,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    token::get_ident(ident),\n                    did, ecx.tcx.map.node_to_string(did));\n \n-            rbml_w.wr_tagged_str(tag_mod_impl,\n-                                 &def_to_string(local_def(did)));\n+            rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(local_def(did)));\n         }\n     }\n \n@@ -619,8 +622,7 @@ fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     if let Some(source) = source_opt {\n-        rbml_w.wr_tagged_str(tag_item_method_provided_source,\n-                             &def_to_string(source));\n+        rbml_w.wr_tagged_u64(tag_item_method_provided_source, def_to_u64(source));\n     }\n }\n \n@@ -725,8 +727,8 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         encode_name(rbml_w, param.name);\n         rbml_w.end_tag();\n \n-        rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             &def_to_string(param.def_id));\n+        rbml_w.wr_tagged_u64(tag_region_param_def_def_id,\n+                             def_to_u64(param.def_id));\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -1089,8 +1091,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(foreign_item.id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(foreign_item.id)));\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1335,8 +1337,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n \n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(method_def_id.def_id()));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(method_def_id.def_id()));\n         }\n         encode_path(rbml_w, path.clone());\n \n@@ -1893,6 +1895,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n                     def_id.krate != ast::LOCAL_CRATE {\n                 self.rbml_w.start_tag(tag_impls_impl);\n                 encode_def_id(self.rbml_w, local_def(item.id));\n+                self.rbml_w.wr_tagged_u64(tag_impls_impl_trait_def_id, def_to_u64(def_id));\n                 self.rbml_w.end_tag();\n             }\n         }\n@@ -1932,12 +1935,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n-        rbml_w.wr_tagged_str(tag_mod_child,\n-                             &def_to_string(local_def(item.id)));\n+        rbml_w.wr_tagged_u64(tag_mod_child,\n+                             def_to_u64(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(auxiliary_node_id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(auxiliary_node_id)));\n             true\n         });\n     }"}, {"sha": "e445b6bb300e3ef1f689234d8cbc05962170c5a9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 36, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -2564,9 +2564,11 @@ impl<'tcx> TraitDef<'tcx> {\n                        tcx: &ctxt<'tcx>,\n                        impl_def_id: DefId,\n                        impl_trait_ref: TraitRef<'tcx>) {\n+        debug!(\"TraitDef::record_impl for {}, from {}\",\n+               self.repr(tcx), impl_trait_ref.repr(tcx));\n+\n         // We don't want to borrow_mut after we already populated all impls,\n         // so check if an impl is present with an immutable borrow first.\n-\n         if let Some(sty) = fast_reject::simplify_type(tcx,\n                                                       impl_trait_ref.self_ty(), false) {\n             if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n@@ -6336,10 +6338,10 @@ pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt,\n     tcx.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n }\n \n-/// Populates the type context with all the implementations for the given type\n-/// if necessary.\n-pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n-                                                      type_id: ast::DefId) {\n+/// Populates the type context with all the inherent implementations for\n+/// the given type if necessary.\n+pub fn populate_inherent_implementations_for_type_if_necessary(tcx: &ctxt,\n+                                                               type_id: ast::DefId) {\n     if type_id.krate == LOCAL_CRATE {\n         return\n     }\n@@ -6348,37 +6350,15 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         return\n     }\n \n-    debug!(\"populate_implementations_for_type_if_necessary: searching for {:?}\", type_id);\n+    debug!(\"populate_inherent_implementations_for_type_if_necessary: searching for {:?}\", type_id);\n \n     let mut inherent_impls = Vec::new();\n-    csearch::each_implementation_for_type(&tcx.sess.cstore, type_id, |impl_def_id| {\n-        let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n-\n-        // Record the implementation, if needed\n-        if let Some(trait_ref) = csearch::get_impl_trait(tcx, impl_def_id) {\n-            let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n-            trait_def.record_impl(tcx, impl_def_id, trait_ref);\n-        } else {\n-            inherent_impls.push(impl_def_id);\n-        }\n-\n-        // For any methods that use a default implementation, add them to\n-        // the map. This is a bit unfortunate.\n-        for impl_item_def_id in &impl_items {\n-            let method_def_id = impl_item_def_id.def_id();\n-            match impl_or_trait_item(tcx, method_def_id) {\n-                MethodTraitItem(method) => {\n-                    if let Some(source) = method.provided_source {\n-                        tcx.provided_method_sources\n-                           .borrow_mut()\n-                           .insert(method_def_id, source);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n+    csearch::each_inherent_implementation_for_type(&tcx.sess.cstore, type_id, |impl_def_id| {\n+        // Record the implementation.\n+        inherent_impls.push(impl_def_id);\n \n         // Store the implementation info.\n+        let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n         tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n     });\n \n@@ -6388,18 +6368,18 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n /// Populates the type context with all the implementations for the given\n /// trait if necessary.\n-pub fn populate_implementations_for_trait_if_necessary(\n-        tcx: &ctxt,\n-        trait_id: ast::DefId) {\n+pub fn populate_implementations_for_trait_if_necessary(tcx: &ctxt, trait_id: ast::DefId) {\n     if trait_id.krate == LOCAL_CRATE {\n         return\n     }\n \n     let def = lookup_trait_def(tcx, trait_id);\n     if def.flags.get().intersects(TraitFlags::IMPLS_VALID) {\n-        return\n+        return;\n     }\n \n+    debug!(\"populate_implementations_for_trait_if_necessary: searching for {}\", def.repr(tcx));\n+\n     if csearch::is_defaulted_trait(&tcx.sess.cstore, trait_id) {\n         record_trait_has_default_impl(tcx, trait_id);\n     }"}, {"sha": "6171df218bb60a468ecec9570881f0c9a7a105d2", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -371,7 +371,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: ast::DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n-        ty::populate_implementations_for_type_if_necessary(self.tcx(), def_id);\n+        ty::populate_inherent_implementations_for_type_if_necessary(self.tcx(), def_id);\n \n         if let Some(impl_infos) = self.tcx().inherent_impls.borrow().get(&def_id) {\n             for &impl_def_id in &***impl_infos {"}, {"sha": "4dc1596b1ff7c5d13cbabd4595984ebe9566bfd7", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -16,13 +16,10 @@\n // mappings. That mapping code resides here.\n \n \n-use metadata::csearch::{each_impl, get_impl_trait};\n-use metadata::csearch;\n use middle::subst::{self, Subst};\n use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n-use middle::ty::{MethodTraitItemId, TypeTraitItemId};\n-use middle::ty::{ParameterEnvironment, lookup_item_type};\n+use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -33,7 +30,6 @@ use middle::ty;\n use CrateCtxt;\n use middle::infer::InferCtxt;\n use middle::infer::new_infer_ctxt;\n-use std::collections::HashSet;\n use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n@@ -130,11 +126,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                       Rc::new((*v.borrow()).clone()));\n         }\n \n-        // Bring in external crates. It's fine for this to happen after the\n-        // coherence checks, because we ensure by construction that no errors\n-        // can happen at link time.\n-        self.add_external_crates();\n-\n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since\n         // the coherence tables contain the trait -> type mappings.\n@@ -267,11 +258,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n-    fn get_self_type_for_implementation(&self, impl_did: DefId)\n-                                        -> TypeScheme<'tcx> {\n-        self.crate_context.tcx.tcache.borrow().get(&impl_did).unwrap().clone()\n-    }\n-\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n@@ -313,66 +299,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         }\n     }\n \n-    // External crate handling\n-\n-    fn add_external_impl(&self,\n-                         impls_seen: &mut HashSet<DefId>,\n-                         impl_def_id: DefId) {\n-        let tcx = self.crate_context.tcx;\n-        let impl_items = csearch::get_impl_items(&tcx.sess.cstore,\n-                                                 impl_def_id);\n-\n-        // Make sure we don't visit the same implementation multiple times.\n-        if !impls_seen.insert(impl_def_id) {\n-            // Skip this one.\n-            return\n-        }\n-        // Good. Continue.\n-\n-        let _ = lookup_item_type(tcx, impl_def_id);\n-        let associated_traits = get_impl_trait(tcx, impl_def_id);\n-\n-        // Do a sanity check.\n-        assert!(associated_traits.is_some());\n-\n-        // Record all the trait items.\n-        if let Some(trait_ref) = associated_traits {\n-            self.add_trait_impl(trait_ref, impl_def_id);\n-        }\n-\n-        // For any methods that use a default implementation, add them to\n-        // the map. This is a bit unfortunate.\n-        for item_def_id in &impl_items {\n-            let impl_item = ty::impl_or_trait_item(tcx, item_def_id.def_id());\n-            match impl_item {\n-                ty::MethodTraitItem(ref method) => {\n-                    if let Some(source) = method.provided_source {\n-                        tcx.provided_method_sources\n-                           .borrow_mut()\n-                           .insert(item_def_id.def_id(), source);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-    }\n-\n-    // Adds implementations and traits from external crates to the coherence\n-    // info.\n-    fn add_external_crates(&self) {\n-        let mut impls_seen = HashSet::new();\n-\n-        let crate_store = &self.crate_context.tcx.sess.cstore;\n-        crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n-            each_impl(crate_store, crate_number, |def_id| {\n-                assert_eq!(crate_number, def_id.krate);\n-                self.add_external_impl(&mut impls_seen, def_id)\n-            })\n-        })\n-    }\n-\n     //\n     // Destructors\n     //\n@@ -395,7 +321,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n             let method_def_id = items[0];\n \n-            let self_type = self.get_self_type_for_implementation(impl_did);\n+            let self_type = ty::lookup_item_type(tcx, impl_did);\n             match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n@@ -451,7 +377,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 return\n             }\n \n-            let self_type = self.get_self_type_for_implementation(impl_did);\n+            let self_type = ty::lookup_item_type(tcx, impl_did);\n             debug!(\"check_implementations_of_copy: self_type={} (bound)\",\n                    self_type.repr(tcx));\n "}, {"sha": "e9c69c84630ef2efc8f9eca5551c6ae9a8f4213d", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -48,14 +48,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         // check_for_overlapping_impls_of_trait() check, since that\n         // check can populate this table further with impls from other\n         // crates.\n-        let trait_defs : Vec<&ty::TraitDef> = {\n-            let d = self.tcx.trait_defs.borrow();\n-            d.values().map(|&v|v).collect()\n-        };\n+        let trait_defs: Vec<_> = self.tcx.trait_defs.borrow().values().cloned().collect();\n \n         for trait_def in trait_defs {\n-            // FIXME -- it seems like this method actually pushes\n-            // duplicate impls onto the list\n             ty::populate_implementations_for_trait_if_necessary(\n                 self.tcx,\n                 trait_def.trait_ref.def_id);"}, {"sha": "3ce8835b1a8de76744d561010ce4a5794d7e007e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "patch": "@@ -221,7 +221,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n \n pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n                    did: ast::DefId) -> Vec<clean::Item> {\n-    ty::populate_implementations_for_type_if_necessary(tcx, did);\n+    ty::populate_inherent_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n \n     match tcx.inherent_impls.borrow().get(&did) {"}]}