{"sha": "28efc234f49f6c8718465108a16f1db8b0113cfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZWZjMjM0ZjQ5ZjZjODcxODQ2NTEwOGExNmYxZGI4YjAxMTNjZmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-23T00:24:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-23T06:09:15Z"}, "message": "libcore: Fix obsolete syntax in extfmt", "tree": {"sha": "00ef74ef43ae6a9fb191c04b5c392e20f34c7b4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00ef74ef43ae6a9fb191c04b5c392e20f34c7b4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28efc234f49f6c8718465108a16f1db8b0113cfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28efc234f49f6c8718465108a16f1db8b0113cfb", "html_url": "https://github.com/rust-lang/rust/commit/28efc234f49f6c8718465108a16f1db8b0113cfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28efc234f49f6c8718465108a16f1db8b0113cfb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2fde83ce4488877d086c9720f5057d3dcefdfde", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2fde83ce4488877d086c9720f5057d3dcefdfde", "html_url": "https://github.com/rust-lang/rust/commit/e2fde83ce4488877d086c9720f5057d3dcefdfde"}], "stats": {"total": 105, "additions": 49, "deletions": 56}, "files": [{"sha": "bb11905894ee56c851e1264b3013728c0106d7e7", "filename": "doc/rust.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/28efc234f49f6c8718465108a16f1db8b0113cfb/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/28efc234f49f6c8718465108a16f1db8b0113cfb/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=28efc234f49f6c8718465108a16f1db8b0113cfb", "patch": "@@ -206,7 +206,7 @@ The keywords are the following strings:\n ~~~~~~~~ {.keyword}\n as\n break\n-const copy\n+copy\n do drop\n else enum extern\n false fn for\n@@ -1099,7 +1099,7 @@ const_item : \"const\" ident ':' type '=' expr ';' ;\n \n A *constant* is a named value stored in read-only memory in a crate.\n The value bound to a constant is evaluated at compile time.\n-Constants are declared with the `const` keyword.\n+Constants are declared with the `static` keyword.\n A constant item must have an expression giving its definition.\n The definition expression of a constant is limited to expression forms that can be evaluated at compile time.\n \n@@ -1108,18 +1108,18 @@ The derived types are borrowed pointers, static arrays, tuples, and structs.\n Borrowed pointers must be have the `'static` lifetime.\n \n ~~~~\n-const bit1: uint = 1 << 0;\n-const bit2: uint = 1 << 1;\n+static bit1: uint = 1 << 0;\n+static bit2: uint = 1 << 1;\n \n-const bits: [uint * 2] = [bit1, bit2];\n-const string: &'static str = \"bitstring\";\n+static bits: [uint, ..2] = [bit1, bit2];\n+static string: &'static str = \"bitstring\";\n \n struct BitsNStrings {\n-    mybits: [uint *2],\n+    mybits: [uint, ..2],\n     mystring: &'self str\n }\n \n-const bits_n_strings: BitsNStrings<'static> = BitsNStrings {\n+static bits_n_strings: BitsNStrings<'static> = BitsNStrings {\n     mybits: bits,\n     mystring: string\n };\n@@ -1206,10 +1206,10 @@ For example:\n \n ~~~~\n trait Num {\n-    static fn from_int(n: int) -> Self;\n+    fn from_int(n: int) -> Self;\n }\n impl Num for float {\n-    static fn from_int(n: int) -> float { n as float }\n+    fn from_int(n: int) -> float { n as float }\n }\n let x: float = Num::from_int(42);\n ~~~~"}, {"sha": "bf895708905f6676a4d6925e8d4d7e56a9667a27", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28efc234f49f6c8718465108a16f1db8b0113cfb/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/28efc234f49f6c8718465108a16f1db8b0113cfb/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=28efc234f49f6c8718465108a16f1db8b0113cfb", "patch": "@@ -394,7 +394,7 @@ copying.\n #     Circle(Point, float),   // origin, radius\n #     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# const tau: float = 6.28f;\n+# static tau: float = 6.28f;\n fn compute_area(shape: &Shape) -> float {\n     match *shape {\n         Circle(_, radius) => 0.5 * tau * radius * radius,"}, {"sha": "b55574fd80679f848e0b18b4a5be0e50bb76ee6a", "filename": "doc/tutorial.md", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/28efc234f49f6c8718465108a16f1db8b0113cfb/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/28efc234f49f6c8718465108a16f1db8b0113cfb/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=28efc234f49f6c8718465108a16f1db8b0113cfb", "patch": "@@ -237,7 +237,7 @@ can specify a variable's type by following it with a colon, then the type\n name. Constants, on the other hand, always require a type annotation.\n \n ~~~~\n-const monster_factor: float = 57.8;\n+static monster_factor: float = 57.8;\n let monster_size = monster_factor * 10.0;\n let monster_size: int = 50;\n ~~~~\n@@ -916,7 +916,7 @@ use core::libc::types::os::arch::c95::size_t;\n struct Blob { priv ptr: *c_void }\n \n impl Blob {\n-    static fn new() -> Blob {\n+    fn new() -> Blob {\n         unsafe { Blob{ptr: calloc(1, int::bytes as size_t)} }\n     }\n }\n@@ -1222,7 +1222,7 @@ pointers to vectors are also called 'slices'.\n #     Black, BlizzardBlue, Blue\n # }\n // A fixed-size stack vector\n-let stack_crayons: [Crayon * 3] = [Almond, AntiqueBrass, Apricot];\n+let stack_crayons: [Crayon, ..3] = [Almond, AntiqueBrass, Apricot];\n \n // A borrowed pointer to stack-allocated vector\n let stack_crayons: &[Crayon] = &[Aquamarine, Asparagus, AtomicTangerine];\n@@ -1264,7 +1264,7 @@ Square brackets denote indexing into a vector:\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n # fn draw_scene(c: Crayon) { }\n-let crayons: [Crayon * 3] = [BananaMania, Beaver, Bittersweet];\n+let crayons: [Crayon, ..3] = [BananaMania, Beaver, Bittersweet];\n match crayons[0] {\n     Bittersweet => draw_scene(crayons[0]),\n     _ => ()\n@@ -1274,7 +1274,7 @@ match crayons[0] {\n A vector can be destructured using pattern matching:\n \n ~~~~\n-let numbers: [int * 3] = [1, 2, 3];\n+let numbers: [int, ..3] = [1, 2, 3];\n let score = match numbers {\n     [] => 0,\n     [a] => a * 10,\n@@ -1768,32 +1768,25 @@ s.draw_borrowed();\n (&@~s).draw_borrowed();\n ~~~\n \n-Implementations may also define _static_ methods,\n-which don't have an explicit `self` argument.\n-The `static` keyword distinguishes static methods from methods that have a `self`:\n+Implementations may also define standalone (sometimes called \"static\")\n+methods. The absence of a `self` paramater distinguishes such methods.\n+These methods are the preferred way to define constructor functions.\n \n ~~~~ {.xfail-test}\n impl Circle {\n     fn area(&self) -> float { ... }\n-    static fn new(area: float) -> Circle { ... }\n+    fn new(area: float) -> Circle { ... }\n }\n ~~~~\n \n-> ***Note***: In the future the `static` keyword will be removed and static methods\n-> will be distinguished solely by the presence or absence of the `self` argument.\n-> In the current langugage instance methods may also be declared without an explicit\n-> `self` argument, in which case `self` is an implicit reference.\n-> That form of method is deprecated.\n-\n-Constructors are one common application for static methods, as in `new` above.\n-To call a static method, you have to prefix it with the type name and a double colon:\n+To call such a method, just prefix it with the type name and a double colon:\n \n ~~~~\n # use core::float::consts::pi;\n # use core::float::sqrt;\n struct Circle { radius: float }\n impl Circle {\n-    static fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n+    fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n }\n let c = Circle::new(42.5);\n ~~~~\n@@ -2055,22 +2048,23 @@ second parameter of type `self`.\n In contrast, in the `impl`, `equals` takes a second parameter of\n type `int`, only using `self` as the name of the receiver.\n \n-Traits can also define static methods which are called by prefixing\n-the method name with the trait name.\n-The compiler will use type inference to decide which implementation to call.\n+Just as in type implementations, traits can define standalone (static)\n+methods.  These methods are called by prefixing the method name with the trait\n+name and a double colon.  The compiler uses type inference to decide which\n+implementation to use.\n \n ~~~~\n-trait Shape { static fn new(area: float) -> Self; }\n+trait Shape { fn new(area: float) -> Self; }\n # use core::float::consts::pi;\n # use core::float::sqrt;\n struct Circle { radius: float }\n struct Square { length: float }\n \n impl Shape for Circle {\n-    static fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n+    fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n }\n impl Shape for Square {\n-    static fn new(area: float) -> Square { Square { length: sqrt(area) } }\n+    fn new(area: float) -> Square { Square { length: sqrt(area) } }\n }\n \n let area = 42.5;\n@@ -2312,7 +2306,7 @@ them. The `pub` keyword modifies an item's visibility, making it\n visible outside its containing module. An expression with `::`, like\n `farm::chicken`, can name an item outside of its containing\n module. Items, such as those declared with `fn`, `struct`, `enum`,\n-`type`, or `const`, are module-private by default.\n+`type`, or `static`, are module-private by default.\n \n Visibility restrictions in Rust exist only at module boundaries. This\n is quite different from most object-oriented languages that also"}, {"sha": "62dee541849f7ce5a214887b4714cef55a1df06e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28efc234f49f6c8718465108a16f1db8b0113cfb/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28efc234f49f6c8718465108a16f1db8b0113cfb/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=28efc234f49f6c8718465108a16f1db8b0113cfb", "patch": "@@ -81,7 +81,7 @@ fn run_rfail_test(config: config, props: TestProps, testfile: &Path) {\n     };\n \n     // The value our Makefile configures valgrind to return on failure\n-    const valgrind_err: int = 100;\n+    static valgrind_err: int = 100;\n     if ProcRes.status == valgrind_err {\n         fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", ProcRes);\n     }\n@@ -92,7 +92,7 @@ fn run_rfail_test(config: config, props: TestProps, testfile: &Path) {\n \n fn check_correct_failure_status(ProcRes: ProcRes) {\n     // The value the rust runtime returns on failure\n-    const rust_err: int = 101;\n+    static rust_err: int = 101;\n     if ProcRes.status != rust_err {\n         fatal_ProcRes(\n             fmt!(\"failure produced the wrong error code: %d\","}, {"sha": "6773a015c6a363f3b841024d6732c58cf5ee40b7", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/28efc234f49f6c8718465108a16f1db8b0113cfb/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28efc234f49f6c8718465108a16f1db8b0113cfb/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=28efc234f49f6c8718465108a16f1db8b0113cfb", "patch": "@@ -483,12 +483,12 @@ pub mod rt {\n     use vec;\n     use option::{Some, None, Option};\n \n-    pub const flag_none : u32 = 0u32;\n-    pub const flag_left_justify   : u32 = 0b00000000000001u32;\n-    pub const flag_left_zero_pad  : u32 = 0b00000000000010u32;\n-    pub const flag_space_for_sign : u32 = 0b00000000000100u32;\n-    pub const flag_sign_always    : u32 = 0b00000000001000u32;\n-    pub const flag_alternate      : u32 = 0b00000000010000u32;\n+    pub static flag_none : u32 = 0u32;\n+    pub static flag_left_justify   : u32 = 0b00000000000001u32;\n+    pub static flag_left_zero_pad  : u32 = 0b00000000000010u32;\n+    pub static flag_space_for_sign : u32 = 0b00000000000100u32;\n+    pub static flag_sign_always    : u32 = 0b00000000001000u32;\n+    pub static flag_alternate      : u32 = 0b00000000010000u32;\n \n     pub enum Count { CountIs(uint), CountImplied, }\n \n@@ -501,7 +501,7 @@ pub mod rt {\n         ty: Ty,\n     }\n \n-    pub pure fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n+    pub fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n         let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = uint_to_str_prec(int::abs(i) as uint, radix, prec);\n@@ -517,7 +517,7 @@ pub mod rt {\n         } else { Some('-') };\n         unsafe { pad(cv, s, head, PadSigned, buf) };\n     }\n-    pub pure fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n+    pub fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n@@ -529,16 +529,16 @@ pub mod rt {\n             };\n         unsafe { pad(cv, rs, None, PadUnsigned, buf) };\n     }\n-    pub pure fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n+    pub fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n         let s = if b { \"true\" } else { \"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         conv_str(cv, s, buf);\n     }\n-    pub pure fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n+    pub fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n         unsafe { pad(cv, \"\", Some(c), PadNozero, buf) };\n     }\n-    pub pure fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n+    pub fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -551,7 +551,7 @@ pub mod rt {\n         };\n         unsafe { pad(cv, unpadded, None, PadNozero, buf) };\n     }\n-    pub pure fn conv_float(cv: Conv, f: float, buf: &mut ~str) {\n+    pub fn conv_float(cv: Conv, f: float, buf: &mut ~str) {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str_digits, 6u)\n@@ -568,16 +568,15 @@ pub mod rt {\n         } else { None };\n         unsafe { pad(cv, s, head, PadFloat, buf) };\n     }\n-    pub pure fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n+    pub fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n         let s = sys::log_str(v);\n         conv_str(cv, s, buf);\n     }\n \n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n-                                 prec: uint) -> ~str {\n+    pub fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n@@ -590,7 +589,7 @@ pub mod rt {\n                 } else { s }\n             };\n     }\n-    pub pure fn get_int_precision(cv: Conv) -> uint {\n+    pub fn get_int_precision(cv: Conv) -> uint {\n         return match cv.precision {\n               CountIs(c) => c as uint,\n               CountImplied => 1u\n@@ -637,7 +636,7 @@ pub mod rt {\n           PadFloat    => (true, true),\n           PadUnsigned => (true, false)\n         };\n-        pure fn have_precision(cv: Conv) -> bool {\n+        fn have_precision(cv: Conv) -> bool {\n             return match cv.precision { CountImplied => false, _ => true };\n         }\n         let zero_padding = {\n@@ -672,7 +671,7 @@ pub mod rt {\n         buf.push_str(s);\n     }\n     #[inline(always)]\n-    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n+    pub fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0\n     }\n }"}]}