{"sha": "6030d6f500e42bde012a391666b68363d8479d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMzBkNmY1MDBlNDJiZGUwMTJhMzkxNjY2YjY4MzYzZDg0NzlkMjE=", "commit": {"author": {"name": "Marco Groppo", "email": "marco.groppo@gmail.com", "date": "2019-03-26T19:26:16Z"}, "committer": {"name": "Marco Groppo", "email": "marco.groppo@gmail.com", "date": "2019-03-26T19:26:16Z"}, "message": "Merge branch 'master' of github.com:rust-analyzer/rust-analyzer into flip-binexpr", "tree": {"sha": "42c799a75b1803afe1838818de86cebe9674c38a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42c799a75b1803afe1838818de86cebe9674c38a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6030d6f500e42bde012a391666b68363d8479d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6030d6f500e42bde012a391666b68363d8479d21", "html_url": "https://github.com/rust-lang/rust/commit/6030d6f500e42bde012a391666b68363d8479d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6030d6f500e42bde012a391666b68363d8479d21/comments", "author": {"login": "marcogroppo", "id": 2735511, "node_id": "MDQ6VXNlcjI3MzU1MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2735511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcogroppo", "html_url": "https://github.com/marcogroppo", "followers_url": "https://api.github.com/users/marcogroppo/followers", "following_url": "https://api.github.com/users/marcogroppo/following{/other_user}", "gists_url": "https://api.github.com/users/marcogroppo/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcogroppo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcogroppo/subscriptions", "organizations_url": "https://api.github.com/users/marcogroppo/orgs", "repos_url": "https://api.github.com/users/marcogroppo/repos", "events_url": "https://api.github.com/users/marcogroppo/events{/privacy}", "received_events_url": "https://api.github.com/users/marcogroppo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcogroppo", "id": 2735511, "node_id": "MDQ6VXNlcjI3MzU1MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2735511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcogroppo", "html_url": "https://github.com/marcogroppo", "followers_url": "https://api.github.com/users/marcogroppo/followers", "following_url": "https://api.github.com/users/marcogroppo/following{/other_user}", "gists_url": "https://api.github.com/users/marcogroppo/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcogroppo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcogroppo/subscriptions", "organizations_url": "https://api.github.com/users/marcogroppo/orgs", "repos_url": "https://api.github.com/users/marcogroppo/repos", "events_url": "https://api.github.com/users/marcogroppo/events{/privacy}", "received_events_url": "https://api.github.com/users/marcogroppo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12b5d4f795f69f7fa07051cdec7a1347d3aa7924", "url": "https://api.github.com/repos/rust-lang/rust/commits/12b5d4f795f69f7fa07051cdec7a1347d3aa7924", "html_url": "https://github.com/rust-lang/rust/commit/12b5d4f795f69f7fa07051cdec7a1347d3aa7924"}, {"sha": "1011e37f3a260b0565f88c84d3c49fac1ec7b879", "url": "https://api.github.com/repos/rust-lang/rust/commits/1011e37f3a260b0565f88c84d3c49fac1ec7b879", "html_url": "https://github.com/rust-lang/rust/commit/1011e37f3a260b0565f88c84d3c49fac1ec7b879"}], "stats": {"total": 1834, "additions": 1017, "deletions": 817}, "files": [{"sha": "00f2338c9e03e308506000de1e60075e5fd7b934", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -913,7 +913,7 @@ dependencies = [\n  \"ra_hir 0.1.0\",\n  \"ra_project_model 0.1.0\",\n  \"ra_syntax 0.1.0\",\n- \"ra_vfs 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_vfs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n@@ -1021,7 +1021,7 @@ dependencies = [\n  \"ra_project_model 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"ra_vfs 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_vfs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1103,7 +1103,7 @@ dependencies = [\n \n [[package]]\n name = \"ra_vfs\"\n-version = \"0.2.0\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1943,7 +1943,7 @@ dependencies = [\n \"checksum proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24f5844db2f839e97e3021980975f6ebf8691d9b9b2ca67ed3feb38dc3edb52c\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdd8e04bd9c52e0342b406469d494fcb033be4bdbe5c606016defbb1681411e1\"\n-\"checksum ra_vfs 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb1839e4e003d865b58b8b6c231aae6c463dfcd01bfbbddffbdb7662a7b5a627\"\n+\"checksum ra_vfs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d75d08da053ec832676686c72dfe509fdd1e807191a50ac79087466ffefccb1c\"\n \"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca\"\n \"checksum rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef\"\n \"checksum rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b\""}, {"sha": "8df99124672693d12c48467d580ebbb4eceafc4b", "filename": "README.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -51,6 +51,12 @@ We are on the rust-lang Zulip!\n \n https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frls-2.2E0\n \n+## Quick Links\n+\n+* Work List: https://paper.dropbox.com/doc/RLS-2.0-work-list--AZ3BgHKKCtqszbsi3gi6sjchAQ-42vbnxzuKq2lKwW0mkn8Y\n+* API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide_api/index.html\n+* CI: https://travis-ci.org/rust-analyzer/rust-analyzer\n+\n ## License\n \n Rust analyzer is primarily distributed under the terms of both the MIT"}, {"sha": "624c25c4d6f3cbafbff772e49c0a8d49438abcfa", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -13,10 +13,11 @@ use crate::{\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::GenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n-    ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n+    ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeAliasId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n     diagnostics::DiagnosticSink,\n+    traits::{TraitItem, TraitData},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -649,6 +650,18 @@ impl Trait {\n     pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n         db.generic_params((*self).into())\n     }\n+\n+    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n+        self.trait_data(db).name().clone()\n+    }\n+\n+    pub fn items(self, db: &impl DefDatabase) -> Vec<TraitItem> {\n+        self.trait_data(db).items().to_vec()\n+    }\n+\n+    pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n+        db.trait_data(self)\n+    }\n }\n \n impl Docs for Trait {\n@@ -659,7 +672,7 @@ impl Docs for Trait {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAlias {\n-    pub(crate) id: TypeId,\n+    pub(crate) id: TypeAliasId,\n }\n \n impl TypeAlias {"}, {"sha": "0edb8ade5b39a1209c35c02ed7f4b32da78f4902", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -1,27 +1,26 @@\n use ra_db::FileId;\n-use ra_syntax::{ast, TreeArc, AstNode};\n+use ra_syntax::{ast, TreeArc};\n \n use crate::{\n-    Module, ModuleSource, Name,\n+    Module, ModuleSource, Name, AstId,\n     nameres::{CrateModuleId, ImportId},\n     HirDatabase, DefDatabase,\n-    HirFileId, SourceItemId,\n+    HirFileId,\n };\n \n impl ModuleSource {\n     pub(crate) fn new(\n         db: &impl DefDatabase,\n         file_id: Option<FileId>,\n-        decl_id: Option<SourceItemId>,\n+        decl_id: Option<AstId<ast::Module>>,\n     ) -> ModuleSource {\n         match (file_id, decl_id) {\n             (Some(file_id), _) => {\n                 let source_file = db.parse(file_id);\n                 ModuleSource::SourceFile(source_file)\n             }\n             (None, Some(item_id)) => {\n-                let module = db.file_item(item_id);\n-                let module = ast::Module::cast(&*module).unwrap();\n+                let module = item_id.to_node(db);\n                 assert!(module.item_list().is_some(), \"expected inline module\");\n                 ModuleSource::Module(module.to_owned())\n             }\n@@ -55,7 +54,7 @@ impl Module {\n         let decl_id = def_map[self.module_id].declaration;\n         let file_id = def_map[self.module_id].definition;\n         let module_source = ModuleSource::new(db, file_id, decl_id);\n-        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id);\n+        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n         (file_id, module_source)\n     }\n \n@@ -65,9 +64,8 @@ impl Module {\n     ) -> Option<(HirFileId, TreeArc<ast::Module>)> {\n         let def_map = db.crate_def_map(self.krate);\n         let decl = def_map[self.module_id].declaration?;\n-        let syntax_node = db.file_item(decl);\n-        let ast = ast::Module::cast(&syntax_node).unwrap().to_owned();\n-        Some((decl.file_id, ast))\n+        let ast = decl.to_node(db);\n+        Some((decl.file_id(), ast))\n     }\n \n     pub(crate) fn import_source_impl(\n@@ -76,7 +74,7 @@ impl Module {\n         import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n         let (file_id, source) = self.definition_source(db);\n-        let (_, source_map) = db.raw_items_with_source_map(file_id.original_file(db));\n+        let (_, source_map) = db.raw_items_with_source_map(file_id);\n         source_map.get(&source, import)\n     }\n "}, {"sha": "1470058480af8d950d6e139003fa93fb4ace5bd6", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -1,10 +1,10 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceDatabase, salsa, FileId};\n+use ra_db::{SourceDatabase, salsa};\n \n use crate::{\n-    HirFileId, SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n+    HirFileId, MacroDefId, AstIdMap, ErasedFileAstId, Crate, Module, HirInterner,\n     Function, FnSignature, ExprScopes, TypeAlias,\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n@@ -14,11 +14,15 @@ use crate::{\n     impl_block::{ModuleImplBlocks, ImplSourceMap},\n     generics::{GenericParams, GenericDef},\n     type_ref::TypeRef,\n+    traits::TraitData, Trait, ty::TraitRef\n };\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n-    #[salsa::invoke(HirFileId::hir_parse)]\n+    #[salsa::invoke(crate::ids::macro_def_query)]\n+    fn macro_def(&self, macro_id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n+\n+    #[salsa::invoke(HirFileId::hir_parse_query)]\n     fn hir_parse(&self, file_id: HirFileId) -> TreeArc<SourceFile>;\n \n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n@@ -27,17 +31,23 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::adt::EnumData::enum_data_query)]\n     fn enum_data(&self, e: Enum) -> Arc<EnumData>;\n \n-    #[salsa::invoke(crate::ids::SourceFileItems::file_items_query)]\n-    fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;\n+    #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n+    fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n+\n+    #[salsa::invoke(crate::source_id::AstIdMap::ast_id_map_query)]\n+    fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n-    #[salsa::invoke(crate::ids::SourceFileItems::file_item_query)]\n-    fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n+    #[salsa::invoke(crate::source_id::AstIdMap::file_item_query)]\n+    fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> TreeArc<SyntaxNode>;\n \n     #[salsa::invoke(RawItems::raw_items_query)]\n-    fn raw_items(&self, file_id: FileId) -> Arc<RawItems>;\n+    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n \n     #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n-    fn raw_items_with_source_map(&self, file_id: FileId) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n+    fn raw_items_with_source_map(\n+        &self,\n+        file_id: HirFileId,\n+    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n \n     #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n     fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n@@ -98,6 +108,9 @@ pub trait HirDatabase: DefDatabase {\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n+\n+    #[salsa::invoke(crate::ty::method_resolution::implements)]\n+    fn implements(&self, trait_ref: TraitRef) -> bool;\n }\n \n #[test]"}, {"sha": "eb9939df790f57b05fda1413fbe52bb453c611c8", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 45, "deletions": 152, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -1,16 +1,15 @@\n use std::{\n-    marker::PhantomData,\n     hash::{Hash, Hasher},\n     sync::Arc,\n };\n \n use ra_db::{LocationInterner, FileId};\n-use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, SyntaxNodePtr, ast};\n-use ra_arena::{Arena, RawId, ArenaId, impl_arena_id};\n+use ra_syntax::{TreeArc, SourceFile, AstNode, ast};\n+use ra_arena::{RawId, ArenaId, impl_arena_id};\n+use mbe::MacroRules;\n \n use crate::{\n-    Module,\n-    DefDatabase,\n+    Module, DefDatabase, AstId, FileAstId,\n };\n \n #[derive(Debug, Default)]\n@@ -22,7 +21,7 @@ pub struct HirInterner {\n     consts: LocationInterner<ItemLoc<ast::ConstDef>, ConstId>,\n     statics: LocationInterner<ItemLoc<ast::StaticDef>, StaticId>,\n     traits: LocationInterner<ItemLoc<ast::TraitDef>, TraitId>,\n-    types: LocationInterner<ItemLoc<ast::TypeAliasDef>, TypeId>,\n+    types: LocationInterner<ItemLoc<ast::TypeAliasDef>, TypeAliasId>,\n }\n \n impl HirInterner {\n@@ -68,7 +67,7 @@ impl HirFileId {\n             HirFileIdRepr::File(file_id) => file_id,\n             HirFileIdRepr::Macro(macro_call_id) => {\n                 let loc = macro_call_id.loc(db);\n-                loc.source_item_id.file_id.original_file(db)\n+                loc.ast_id.file_id().original_file(db)\n             }\n         }\n     }\n@@ -83,7 +82,10 @@ impl HirFileId {\n         }\n     }\n \n-    pub(crate) fn hir_parse(db: &impl DefDatabase, file_id: HirFileId) -> TreeArc<SourceFile> {\n+    pub(crate) fn hir_parse_query(\n+        db: &impl DefDatabase,\n+        file_id: HirFileId,\n+    ) -> TreeArc<SourceFile> {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.parse(file_id),\n             HirFileIdRepr::Macro(macro_call_id) => {\n@@ -96,14 +98,10 @@ impl HirFileId {\n \n fn parse_macro(db: &impl DefDatabase, macro_call_id: MacroCallId) -> Option<TreeArc<SourceFile>> {\n     let loc = macro_call_id.loc(db);\n-    let syntax = db.file_item(loc.source_item_id);\n-    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n+    let macro_call = loc.ast_id.to_node(db);\n     let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n \n-    let def_map = db.crate_def_map(loc.module.krate);\n-    let (krate, macro_id) = def_map.resolve_macro(macro_call_id)?;\n-    let def_map = db.crate_def_map(krate);\n-    let macro_rules = &def_map[macro_id];\n+    let macro_rules = db.macro_def(loc.def)?;\n     let tt = macro_rules.expand(&macro_arg).ok()?;\n     Some(mbe::token_tree_to_ast_item_list(&tt))\n }\n@@ -126,6 +124,17 @@ impl From<MacroCallId> for HirFileId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n+\n+pub(crate) fn macro_def_query(db: &impl DefDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n+    let macro_call = id.0.to_node(db);\n+    let arg = macro_call.token_tree()?;\n+    let (tt, _) = mbe::ast_to_token_tree(arg)?;\n+    let rules = MacroRules::parse(&tt).ok()?;\n+    Some(Arc::new(rules))\n+}\n+\n /// `MacroCallId` identifies a particular macro invocation, like\n /// `println!(\"Hello, {}\", world)`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -134,8 +143,8 @@ impl_arena_id!(MacroCallId);\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n-    pub(crate) module: Module,\n-    pub(crate) source_item_id: SourceItemId,\n+    pub(crate) def: MacroDefId,\n+    pub(crate) ast_id: AstId<ast::MacroCall>,\n }\n \n impl MacroCallId {\n@@ -145,7 +154,6 @@ impl MacroCallId {\n }\n \n impl MacroCallLoc {\n-    #[allow(unused)]\n     pub(crate) fn id(&self, db: &impl AsRef<HirInterner>) -> MacroCallId {\n         db.as_ref().macros.loc2id(&self)\n     }\n@@ -154,26 +162,25 @@ impl MacroCallLoc {\n #[derive(Debug)]\n pub struct ItemLoc<N: AstNode> {\n     pub(crate) module: Module,\n-    raw: SourceItemId,\n-    _ty: PhantomData<N>,\n+    ast_id: AstId<N>,\n }\n \n impl<N: AstNode> PartialEq for ItemLoc<N> {\n     fn eq(&self, other: &Self) -> bool {\n-        self.module == other.module && self.raw == other.raw\n+        self.module == other.module && self.ast_id == other.ast_id\n     }\n }\n impl<N: AstNode> Eq for ItemLoc<N> {}\n impl<N: AstNode> Hash for ItemLoc<N> {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n         self.module.hash(hasher);\n-        self.raw.hash(hasher);\n+        self.ast_id.hash(hasher);\n     }\n }\n \n impl<N: AstNode> Clone for ItemLoc<N> {\n     fn clone(&self) -> ItemLoc<N> {\n-        ItemLoc { module: self.module, raw: self.raw, _ty: PhantomData }\n+        ItemLoc { module: self.module, ast_id: self.ast_id }\n     }\n }\n \n@@ -200,26 +207,19 @@ impl<'a, DB: DefDatabase> LocationCtx<&'a DB> {\n pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<N>, Self>;\n     fn from_ast(ctx: LocationCtx<&impl DefDatabase>, ast: &N) -> Self {\n-        let items = ctx.db.file_items(ctx.file_id);\n-        let item_id = items.id_of(ctx.file_id, ast.syntax());\n-        Self::from_source_item_id_unchecked(ctx, item_id)\n+        let items = ctx.db.ast_id_map(ctx.file_id);\n+        let item_id = items.ast_id(ast);\n+        Self::from_ast_id(ctx, item_id)\n     }\n-    fn from_source_item_id_unchecked(\n-        ctx: LocationCtx<&impl DefDatabase>,\n-        item_id: SourceFileItemId,\n-    ) -> Self {\n-        let raw = SourceItemId { file_id: ctx.file_id, item_id };\n-        let loc = ItemLoc { module: ctx.module, raw, _ty: PhantomData };\n-\n+    fn from_ast_id(ctx: LocationCtx<&impl DefDatabase>, ast_id: FileAstId<N>) -> Self {\n+        let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n         Self::interner(ctx.db.as_ref()).loc2id(&loc)\n     }\n     fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<N>) {\n         let int = Self::interner(db.as_ref());\n         let loc = int.id2loc(self);\n-        let syntax = db.file_item(loc.raw);\n-        let ast =\n-            N::cast(&syntax).unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", loc.raw)).to_owned();\n-        (loc.raw.file_id, ast)\n+        let ast = loc.ast_id.to_node(db);\n+        (loc.ast_id.file_id(), ast)\n     }\n     fn module(self, db: &impl DefDatabase) -> Module {\n         let int = Self::interner(db.as_ref());\n@@ -229,7 +229,7 @@ pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct FunctionId(RawId);\n+pub(crate) struct FunctionId(RawId);\n impl_arena_id!(FunctionId);\n impl AstItemDef<ast::FnDef> for FunctionId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::FnDef>, Self> {\n@@ -238,7 +238,7 @@ impl AstItemDef<ast::FnDef> for FunctionId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StructId(RawId);\n+pub(crate) struct StructId(RawId);\n impl_arena_id!(StructId);\n impl AstItemDef<ast::StructDef> for StructId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::StructDef>, Self> {\n@@ -247,7 +247,7 @@ impl AstItemDef<ast::StructDef> for StructId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct EnumId(RawId);\n+pub(crate) struct EnumId(RawId);\n impl_arena_id!(EnumId);\n impl AstItemDef<ast::EnumDef> for EnumId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::EnumDef>, Self> {\n@@ -256,7 +256,7 @@ impl AstItemDef<ast::EnumDef> for EnumId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ConstId(RawId);\n+pub(crate) struct ConstId(RawId);\n impl_arena_id!(ConstId);\n impl AstItemDef<ast::ConstDef> for ConstId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::ConstDef>, Self> {\n@@ -265,7 +265,7 @@ impl AstItemDef<ast::ConstDef> for ConstId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StaticId(RawId);\n+pub(crate) struct StaticId(RawId);\n impl_arena_id!(StaticId);\n impl AstItemDef<ast::StaticDef> for StaticId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::StaticDef>, Self> {\n@@ -274,7 +274,7 @@ impl AstItemDef<ast::StaticDef> for StaticId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TraitId(RawId);\n+pub(crate) struct TraitId(RawId);\n impl_arena_id!(TraitId);\n impl AstItemDef<ast::TraitDef> for TraitId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::TraitDef>, Self> {\n@@ -283,117 +283,10 @@ impl AstItemDef<ast::TraitDef> for TraitId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeId(RawId);\n-impl_arena_id!(TypeId);\n-impl AstItemDef<ast::TypeAliasDef> for TypeId {\n+pub(crate) struct TypeAliasId(RawId);\n+impl_arena_id!(TypeAliasId);\n+impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::TypeAliasDef>, Self> {\n         &interner.types\n     }\n }\n-\n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct SourceFileItemId(RawId);\n-impl_arena_id!(SourceFileItemId);\n-\n-impl SourceFileItemId {\n-    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n-        SourceItemId { file_id, item_id: self }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SourceItemId {\n-    pub(crate) file_id: HirFileId,\n-    pub(crate) item_id: SourceFileItemId,\n-}\n-\n-/// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct SourceFileItems {\n-    file_id: HirFileId,\n-    arena: Arena<SourceFileItemId, SyntaxNodePtr>,\n-}\n-\n-impl SourceFileItems {\n-    pub(crate) fn file_items_query(\n-        db: &impl DefDatabase,\n-        file_id: HirFileId,\n-    ) -> Arc<SourceFileItems> {\n-        let source_file = db.hir_parse(file_id);\n-        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n-    }\n-\n-    pub(crate) fn file_item_query(\n-        db: &impl DefDatabase,\n-        source_item_id: SourceItemId,\n-    ) -> TreeArc<SyntaxNode> {\n-        let source_file = db.hir_parse(source_item_id.file_id);\n-        db.file_items(source_item_id.file_id)[source_item_id.item_id]\n-            .to_node(&source_file)\n-            .to_owned()\n-    }\n-\n-    pub(crate) fn from_source_file(\n-        source_file: &SourceFile,\n-        file_id: HirFileId,\n-    ) -> SourceFileItems {\n-        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n-        // By walking the tree in bread-first order we make sure that parents\n-        // get lower ids then children. That is, adding a new child does not\n-        // change parent's id. This means that, say, adding a new function to a\n-        // trait does not change ids of top-level items, which helps caching.\n-        bfs(source_file.syntax(), |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                res.alloc(module_item.syntax());\n-            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                res.alloc(macro_call.syntax());\n-            }\n-        });\n-        res\n-    }\n-\n-    fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n-        self.arena.alloc(SyntaxNodePtr::new(item))\n-    }\n-    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n-        assert_eq!(\n-            self.file_id, file_id,\n-            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.file_id, file_id\n-        );\n-        self.id_of_unchecked(item)\n-    }\n-    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n-        let ptr = SyntaxNodePtr::new(item);\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {\n-            return id;\n-        }\n-        panic!(\n-            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n-            item,\n-            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-        );\n-    }\n-}\n-\n-impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNodePtr;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n-        &self.arena[idx]\n-    }\n-}\n-\n-/// Walks the subtree in bfs order, calling `f` for each node.\n-fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n-    let mut curr_layer = vec![node];\n-    let mut next_layer = vec![];\n-    while !curr_layer.is_empty() {\n-        curr_layer.drain(..).for_each(|node| {\n-            next_layer.extend(node.children());\n-            f(node);\n-        });\n-        std::mem::swap(&mut curr_layer, &mut next_layer);\n-    }\n-}"}, {"sha": "7c603bbd3e77a1ad70e14701ce7719fe8547c49e", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -23,10 +23,12 @@ pub mod mock;\n mod path;\n pub mod source_binder;\n \n+mod source_id;\n mod ids;\n mod name;\n mod nameres;\n mod adt;\n+mod traits;\n mod type_alias;\n mod type_ref;\n mod ty;\n@@ -46,13 +48,14 @@ mod marks;\n use crate::{\n     db::{HirDatabase, DefDatabase},\n     name::{AsName, KnownName},\n-    ids::{SourceItemId, SourceFileItems},\n+    source_id::{FileAstId, AstId},\n };\n \n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n-    ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n+    source_id::{AstIdMap, ErasedFileAstId},\n+    ids::{HirFileId, MacroDefId, MacroCallId, MacroCallLoc, HirInterner},\n     nameres::{PerNs, Namespace},\n     ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},"}, {"sha": "67b9d698605e581a54b3f8465f06f5d793b417d3", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -59,13 +59,15 @@ use rustc_hash::FxHashMap;\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n+use ra_syntax::ast;\n \n use crate::{\n     ModuleDef, Name, Crate, Module,\n-    DefDatabase, Path, PathKind, HirFileId,\n-    ids::{SourceItemId, SourceFileItemId, MacroCallId},\n+    DefDatabase, Path, PathKind, HirFileId, Trait,\n+    ids::MacroDefId,\n     diagnostics::DiagnosticSink,\n     nameres::diagnostics::DefDiagnostic,\n+    AstId,\n };\n \n pub(crate) use self::raw::{RawItems, ImportId, ImportSourceMap};\n@@ -84,9 +86,7 @@ pub struct CrateDefMap {\n     extern_prelude: FxHashMap<Name, ModuleDef>,\n     root: CrateModuleId,\n     modules: Arena<CrateModuleId, ModuleData>,\n-    macros: Arena<CrateMacroId, mbe::MacroRules>,\n-    public_macros: FxHashMap<Name, CrateMacroId>,\n-    macro_resolutions: FxHashMap<MacroCallId, (Crate, CrateMacroId)>,\n+    public_macros: FxHashMap<Name, MacroDefId>,\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n@@ -97,18 +97,6 @@ impl std::ops::Index<CrateModuleId> for CrateDefMap {\n     }\n }\n \n-impl std::ops::Index<CrateMacroId> for CrateDefMap {\n-    type Output = mbe::MacroRules;\n-    fn index(&self, id: CrateMacroId) -> &mbe::MacroRules {\n-        &self.macros[id]\n-    }\n-}\n-\n-/// An ID of a macro, **local** to a specific crate\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub(crate) struct CrateMacroId(RawId);\n-impl_arena_id!(CrateMacroId);\n-\n /// An ID of a module, **local** to a specific crate\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub(crate) struct CrateModuleId(RawId);\n@@ -120,7 +108,7 @@ pub(crate) struct ModuleData {\n     pub(crate) children: FxHashMap<Name, CrateModuleId>,\n     pub(crate) scope: ModuleScope,\n     /// None for root\n-    pub(crate) declaration: Option<SourceItemId>,\n+    pub(crate) declaration: Option<AstId<ast::Module>>,\n     /// None for inline modules.\n     ///\n     /// Note that non-inline modules, by definition, live inside non-macro file.\n@@ -139,6 +127,12 @@ impl ModuleScope {\n     pub fn get(&self, name: &Name) -> Option<&Resolution> {\n         self.items.get(name)\n     }\n+    pub fn traits<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n+        self.items.values().filter_map(|r| match r.def.take_types() {\n+            Some(ModuleDef::Trait(t)) => Some(t),\n+            _ => None,\n+        })\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Default)]\n@@ -196,9 +190,7 @@ impl CrateDefMap {\n                 prelude: None,\n                 root,\n                 modules,\n-                macros: Arena::default(),\n                 public_macros: FxHashMap::default(),\n-                macro_resolutions: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };\n@@ -232,19 +224,11 @@ impl CrateDefMap {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n     }\n \n-    pub(crate) fn resolve_macro(\n-        &self,\n-        macro_call_id: MacroCallId,\n-    ) -> Option<(Crate, CrateMacroId)> {\n-        self.macro_resolutions.get(&macro_call_id).map(|&it| it)\n-    }\n-\n     pub(crate) fn find_module_by_source(\n         &self,\n         file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n+        decl_id: Option<AstId<ast::Module>>,\n     ) -> Option<CrateModuleId> {\n-        let decl_id = decl_id.map(|it| it.with_file_id(file_id));\n         let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n             if decl_id.is_some() {\n                 module_data.declaration == decl_id\n@@ -447,10 +431,10 @@ impl CrateDefMap {\n \n mod diagnostics {\n     use relative_path::RelativePathBuf;\n-    use ra_syntax::{AstPtr, AstNode, ast};\n+    use ra_syntax::{AstPtr, ast};\n \n     use crate::{\n-        SourceItemId, DefDatabase,\n+        AstId, DefDatabase,\n         nameres::CrateModuleId,\n         diagnostics::{DiagnosticSink, UnresolvedModule},\n };\n@@ -459,7 +443,7 @@ mod diagnostics {\n     pub(super) enum DefDiagnostic {\n         UnresolvedModule {\n             module: CrateModuleId,\n-            declaration: SourceItemId,\n+            declaration: AstId<ast::Module>,\n             candidate: RelativePathBuf,\n         },\n     }\n@@ -476,16 +460,14 @@ mod diagnostics {\n                     if *module != target_module {\n                         return;\n                     }\n-                    let syntax = db.file_item(*declaration);\n-                    let decl = ast::Module::cast(&syntax).unwrap();\n+                    let decl = declaration.to_node(db);\n                     sink.push(UnresolvedModule {\n-                        file: declaration.file_id,\n+                        file: declaration.file_id(),\n                         decl: AstPtr::new(&decl),\n                         candidate: candidate.clone(),\n                     })\n                 }\n             }\n         }\n     }\n-\n }"}, {"sha": "39cadc94aab3101bcdafaeb9383ff2a5869cbbdb", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 50, "deletions": 90, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -3,18 +3,20 @@ use rustc_hash::FxHashMap;\n use relative_path::RelativePathBuf;\n use test_utils::tested_by;\n use ra_db::FileId;\n+use ra_syntax::ast;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path, Crate,\n+    DefDatabase, HirFileId, Name, Path,\n     KnownName,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n-        CrateDefMap, CrateModuleId, ModuleData, CrateMacroId,\n+        CrateDefMap, CrateModuleId, ModuleData,\n         diagnostics::DefDiagnostic,\n         raw,\n     },\n-    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n+    ids::{AstItemDef, LocationCtx, MacroCallLoc, MacroCallId, MacroDefId},\n+    AstId,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -51,8 +53,8 @@ struct DefCollector<DB> {\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, MacroCallId, Path, tt::Subtree)>,\n-    global_macro_scope: FxHashMap<Name, CrateMacroId>,\n+    unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n+    global_macro_scope: FxHashMap<Name, MacroDefId>,\n }\n \n impl<'a, DB> DefCollector<&'a DB>\n@@ -62,7 +64,7 @@ where\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n         let file_id = crate_graph.crate_root(self.def_map.krate.crate_id());\n-        let raw_items = self.db.raw_items(file_id);\n+        let raw_items = self.db.raw_items(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].definition = Some(file_id);\n         ModCollector {\n@@ -93,14 +95,11 @@ where\n         }\n     }\n \n-    fn define_macro(&mut self, name: Name, tt: &tt::Subtree, export: bool) {\n-        if let Ok(rules) = mbe::MacroRules::parse(tt) {\n-            let macro_id = self.def_map.macros.alloc(rules);\n-            if export {\n-                self.def_map.public_macros.insert(name.clone(), macro_id);\n-            }\n-            self.global_macro_scope.insert(name, macro_id);\n+    fn define_macro(&mut self, name: Name, macro_id: MacroDefId, export: bool) {\n+        if export {\n+            self.def_map.public_macros.insert(name.clone(), macro_id);\n         }\n+        self.global_macro_scope.insert(name, macro_id);\n     }\n \n     fn resolve_imports(&mut self) -> ReachedFixedPoint {\n@@ -296,7 +295,7 @@ where\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, call_id, path, tt)| {\n+        macros.retain(|(module_id, ast_id, path)| {\n             if path.segments.len() != 2 {\n                 return true;\n             }\n@@ -312,47 +311,23 @@ where\n             res = ReachedFixedPoint::No;\n             let def_map = self.db.crate_def_map(krate);\n             if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n-                resolved.push((*module_id, *call_id, (krate, macro_id), tt.clone()));\n+                let call_id = MacroCallLoc { def: macro_id, ast_id: *ast_id }.id(self.db);\n+                resolved.push((*module_id, call_id));\n             }\n             false\n         });\n \n-        for (module_id, macro_call_id, macro_def_id, arg) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id, arg);\n+        for (module_id, macro_call_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id);\n         }\n         res\n     }\n \n-    fn collect_macro_expansion(\n-        &mut self,\n-        module_id: CrateModuleId,\n-        macro_call_id: MacroCallId,\n-        macro_def_id: (Crate, CrateMacroId),\n-        macro_arg: tt::Subtree,\n-    ) {\n-        let (macro_krate, macro_id) = macro_def_id;\n-        let dm;\n-        let rules = if macro_krate == self.def_map.krate {\n-            &self.def_map[macro_id]\n-        } else {\n-            dm = self.db.crate_def_map(macro_krate);\n-            &dm[macro_id]\n-        };\n-        if let Ok(expansion) = rules.expand(&macro_arg) {\n-            self.def_map.macro_resolutions.insert(macro_call_id, macro_def_id);\n-            // XXX: this **does not** go through a database, because we can't\n-            // identify macro_call without adding the whole state of name resolution\n-            // as a parameter to the query.\n-            //\n-            // So, we run the queries \"manually\" and we must ensure that\n-            // `db.hir_parse(macro_call_id)` returns the same source_file.\n-            let file_id: HirFileId = macro_call_id.into();\n-            let source_file = mbe::token_tree_to_ast_item_list(&expansion);\n-\n-            let raw_items = raw::RawItems::from_source_file(&source_file, file_id);\n-            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(raw_items.items())\n-        }\n+    fn collect_macro_expansion(&mut self, module_id: CrateModuleId, macro_call_id: MacroCallId) {\n+        let file_id: HirFileId = macro_call_id.into();\n+        let raw_items = self.db.raw_items(file_id);\n+        ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n+            .collect(raw_items.items())\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -390,12 +365,9 @@ where\n     fn collect_module(&mut self, module: &raw::ModuleData) {\n         match module {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, items, source_item_id } => {\n-                let module_id = self.push_child_module(\n-                    name.clone(),\n-                    source_item_id.with_file_id(self.file_id),\n-                    None,\n-                );\n+            raw::ModuleData::Definition { name, items, ast_id } => {\n+                let module_id =\n+                    self.push_child_module(name.clone(), ast_id.with_file_id(self.file_id), None);\n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n                     module_id,\n@@ -405,14 +377,13 @@ where\n                 .collect(&*items);\n             }\n             // out of line module, resovle, parse and recurse\n-            raw::ModuleData::Declaration { name, source_item_id } => {\n-                let source_item_id = source_item_id.with_file_id(self.file_id);\n+            raw::ModuleData::Declaration { name, ast_id } => {\n+                let ast_id = ast_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n                 match resolve_submodule(self.def_collector.db, self.file_id, name, is_root) {\n                     Ok(file_id) => {\n-                        let module_id =\n-                            self.push_child_module(name.clone(), source_item_id, Some(file_id));\n-                        let raw_items = self.def_collector.db.raw_items(file_id);\n+                        let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n+                        let raw_items = self.def_collector.db.raw_items(file_id.into());\n                         ModCollector {\n                             def_collector: &mut *self.def_collector,\n                             module_id,\n@@ -424,7 +395,7 @@ where\n                     Err(candidate) => self.def_collector.def_map.diagnostics.push(\n                         DefDiagnostic::UnresolvedModule {\n                             module: self.module_id,\n-                            declaration: source_item_id,\n+                            declaration: ast_id,\n                             candidate,\n                         },\n                     ),\n@@ -436,7 +407,7 @@ where\n     fn push_child_module(\n         &mut self,\n         name: Name,\n-        declaration: SourceItemId,\n+        declaration: AstId<ast::Module>,\n         definition: Option<FileId>,\n     ) -> CrateModuleId {\n         let modules = &mut self.def_collector.def_map.modules;\n@@ -458,23 +429,24 @@ where\n     fn define_def(&mut self, def: &raw::DefData) {\n         let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id.into());\n-        macro_rules! id {\n-            () => {\n-                AstItemDef::from_source_item_id_unchecked(ctx, def.source_item_id)\n+\n+        macro_rules! def {\n+            ($kind:ident, $ast_id:ident) => {\n+                $kind { id: AstItemDef::from_ast_id(ctx, $ast_id) }.into()\n             };\n         }\n         let name = def.name.clone();\n         let def: PerNs<ModuleDef> = match def.kind {\n-            raw::DefKind::Function => PerNs::values(Function { id: id!() }.into()),\n-            raw::DefKind::Struct => {\n-                let s = Struct { id: id!() }.into();\n+            raw::DefKind::Function(ast_id) => PerNs::values(def!(Function, ast_id)),\n+            raw::DefKind::Struct(ast_id) => {\n+                let s = def!(Struct, ast_id);\n                 PerNs::both(s, s)\n             }\n-            raw::DefKind::Enum => PerNs::types(Enum { id: id!() }.into()),\n-            raw::DefKind::Const => PerNs::values(Const { id: id!() }.into()),\n-            raw::DefKind::Static => PerNs::values(Static { id: id!() }.into()),\n-            raw::DefKind::Trait => PerNs::types(Trait { id: id!() }.into()),\n-            raw::DefKind::TypeAlias => PerNs::types(TypeAlias { id: id!() }.into()),\n+            raw::DefKind::Enum(ast_id) => PerNs::types(def!(Enum, ast_id)),\n+            raw::DefKind::Const(ast_id) => PerNs::values(def!(Const, ast_id)),\n+            raw::DefKind::Static(ast_id) => PerNs::values(def!(Static, ast_id)),\n+            raw::DefKind::Trait(ast_id) => PerNs::types(def!(Trait, ast_id)),\n+            raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n         };\n         let resolution = Resolution { def, import: None };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)])\n@@ -484,39 +456,27 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                self.def_collector.define_macro(name.clone(), &mac.arg, mac.export)\n+                let macro_id = MacroDefId(mac.ast_id.with_file_id(self.file_id));\n+                self.def_collector.define_macro(name.clone(), macro_id, mac.export)\n             }\n             return;\n         }\n \n-        let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n-        let macro_call_id = MacroCallLoc {\n-            module: Module { krate: self.def_collector.def_map.krate, module_id: self.module_id },\n-            source_item_id,\n-        }\n-        .id(self.def_collector.db);\n+        let ast_id = mac.ast_id.with_file_id(self.file_id);\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n         if let Some(&macro_id) =\n             mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n         {\n-            self.def_collector.collect_macro_expansion(\n-                self.module_id,\n-                macro_call_id,\n-                (self.def_collector.def_map.krate, macro_id),\n-                mac.arg.clone(),\n-            );\n+            let macro_call_id = MacroCallLoc { def: macro_id, ast_id }.id(self.def_collector.db);\n+\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id);\n             return;\n         }\n \n         // Case 3: path to a macro from another crate, expand during name resolution\n-        self.def_collector.unexpanded_macros.push((\n-            self.module_id,\n-            macro_call_id,\n-            mac.path.clone(),\n-            mac.arg.clone(),\n-        ))\n+        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, mac.path.clone()))\n     }\n }\n "}, {"sha": "0936229acf4082eb90cffade53fb3612bd800654", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 70, "deletions": 73, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -4,7 +4,6 @@ use std::{\n };\n \n use test_utils::tested_by;\n-use ra_db::FileId;\n use ra_arena::{Arena, impl_arena_id, RawId, map::ArenaMap};\n use ra_syntax::{\n     AstNode, SourceFile, AstPtr, TreeArc,\n@@ -13,9 +12,13 @@ use ra_syntax::{\n \n use crate::{\n     DefDatabase, Name, AsName, Path, HirFileId, ModuleSource,\n-    ids::{SourceFileItemId, SourceFileItems},\n+    AstIdMap, FileAstId,\n };\n \n+/// `RawItems` is a set of top-level items in a file (except for impls).\n+///\n+/// It is the input to name resolution algorithm. `RawItems` are not invalidated\n+/// on most edits.\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct RawItems {\n     modules: Arena<Module, ModuleData>,\n@@ -32,11 +35,11 @@ pub struct ImportSourceMap {\n }\n \n impl ImportSourceMap {\n-    pub(crate) fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n+    fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n         self.map.insert(import, AstPtr::new(segment))\n     }\n \n-    pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n+    pub(crate) fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n         let file = match source {\n             ModuleSource::SourceFile(file) => &*file,\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n@@ -47,40 +50,27 @@ impl ImportSourceMap {\n }\n \n impl RawItems {\n-    pub(crate) fn raw_items_query(db: &impl DefDatabase, file_id: FileId) -> Arc<RawItems> {\n+    pub(crate) fn raw_items_query(db: &impl DefDatabase, file_id: HirFileId) -> Arc<RawItems> {\n         db.raw_items_with_source_map(file_id).0\n     }\n \n     pub(crate) fn raw_items_with_source_map_query(\n         db: &impl DefDatabase,\n-        file_id: FileId,\n+        file_id: HirFileId,\n     ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n-            source_file_items: db.file_items(file_id.into()),\n+            source_ast_id_map: db.ast_id_map(file_id.into()),\n             source_map: ImportSourceMap::default(),\n         };\n-        let source_file = db.parse(file_id);\n+        let source_file = db.hir_parse(file_id);\n         collector.process_module(None, &*source_file);\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n     }\n \n-    pub(crate) fn items(&self) -> &[RawItem] {\n+    pub(super) fn items(&self) -> &[RawItem] {\n         &self.items\n     }\n-\n-    // We can't use queries during name resolution for fear of cycles, so this\n-    // is a query-less variant of the above function.\n-    pub(crate) fn from_source_file(source_file: &SourceFile, file_id: HirFileId) -> RawItems {\n-        let source_file_items = SourceFileItems::from_source_file(source_file, file_id);\n-        let mut collector = RawItemsCollector {\n-            raw_items: RawItems::default(),\n-            source_file_items: Arc::new(source_file_items),\n-            source_map: ImportSourceMap::default(),\n-        };\n-        collector.process_module(None, &*source_file);\n-        collector.raw_items\n-    }\n }\n \n impl Index<Module> for RawItems {\n@@ -112,21 +102,21 @@ impl Index<Macro> for RawItems {\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(crate) enum RawItem {\n+pub(super) enum RawItem {\n     Module(Module),\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Module(RawId);\n+pub(super) struct Module(RawId);\n impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) enum ModuleData {\n-    Declaration { name: Name, source_item_id: SourceFileItemId },\n-    Definition { name: Name, source_item_id: SourceFileItemId, items: Vec<RawItem> },\n+pub(super) enum ModuleData {\n+    Declaration { name: Name, ast_id: FileAstId<ast::Module> },\n+    Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -135,51 +125,49 @@ impl_arena_id!(ImportId);\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n-    pub(crate) path: Path,\n-    pub(crate) alias: Option<Name>,\n-    pub(crate) is_glob: bool,\n-    pub(crate) is_prelude: bool,\n-    pub(crate) is_extern_crate: bool,\n+    pub(super) path: Path,\n+    pub(super) alias: Option<Name>,\n+    pub(super) is_glob: bool,\n+    pub(super) is_prelude: bool,\n+    pub(super) is_extern_crate: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Def(RawId);\n+pub(super) struct Def(RawId);\n impl_arena_id!(Def);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct DefData {\n-    pub(crate) source_item_id: SourceFileItemId,\n-    pub(crate) name: Name,\n-    pub(crate) kind: DefKind,\n+pub(super) struct DefData {\n+    pub(super) name: Name,\n+    pub(super) kind: DefKind,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(crate) enum DefKind {\n-    Function,\n-    Struct,\n-    Enum,\n-    Const,\n-    Static,\n-    Trait,\n-    TypeAlias,\n+pub(super) enum DefKind {\n+    Function(FileAstId<ast::FnDef>),\n+    Struct(FileAstId<ast::StructDef>),\n+    Enum(FileAstId<ast::EnumDef>),\n+    Const(FileAstId<ast::ConstDef>),\n+    Static(FileAstId<ast::StaticDef>),\n+    Trait(FileAstId<ast::TraitDef>),\n+    TypeAlias(FileAstId<ast::TypeAliasDef>),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Macro(RawId);\n+pub(super) struct Macro(RawId);\n impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct MacroData {\n-    pub(crate) source_item_id: SourceFileItemId,\n-    pub(crate) path: Path,\n-    pub(crate) name: Option<Name>,\n-    pub(crate) arg: tt::Subtree,\n-    pub(crate) export: bool,\n+pub(super) struct MacroData {\n+    pub(super) ast_id: FileAstId<ast::MacroCall>,\n+    pub(super) path: Path,\n+    pub(super) name: Option<Name>,\n+    pub(super) export: bool,\n }\n \n struct RawItemsCollector {\n     raw_items: RawItems,\n-    source_file_items: Arc<SourceFileItems>,\n+    source_ast_id_map: Arc<AstIdMap>,\n     source_map: ImportSourceMap,\n }\n \n@@ -211,18 +199,31 @@ impl RawItemsCollector {\n                 // impls don't participate in name resolution\n                 return;\n             }\n-            ast::ModuleItemKind::StructDef(it) => (DefKind::Struct, it.name()),\n-            ast::ModuleItemKind::EnumDef(it) => (DefKind::Enum, it.name()),\n-            ast::ModuleItemKind::FnDef(it) => (DefKind::Function, it.name()),\n-            ast::ModuleItemKind::TraitDef(it) => (DefKind::Trait, it.name()),\n-            ast::ModuleItemKind::TypeAliasDef(it) => (DefKind::TypeAlias, it.name()),\n-            ast::ModuleItemKind::ConstDef(it) => (DefKind::Const, it.name()),\n-            ast::ModuleItemKind::StaticDef(it) => (DefKind::Static, it.name()),\n+            ast::ModuleItemKind::StructDef(it) => {\n+                (DefKind::Struct(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::EnumDef(it) => {\n+                (DefKind::Enum(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::FnDef(it) => {\n+                (DefKind::Function(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::TraitDef(it) => {\n+                (DefKind::Trait(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::TypeAliasDef(it) => {\n+                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::ConstDef(it) => {\n+                (DefKind::Const(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::StaticDef(it) => {\n+                (DefKind::Static(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n         };\n         if let Some(name) = name {\n             let name = name.as_name();\n-            let source_item_id = self.source_file_items.id_of_unchecked(item.syntax());\n-            let def = self.raw_items.defs.alloc(DefData { name, kind, source_item_id });\n+            let def = self.raw_items.defs.alloc(DefData { name, kind });\n             self.push_item(current_module, RawItem::Def(def))\n         }\n     }\n@@ -232,18 +233,17 @@ impl RawItemsCollector {\n             Some(it) => it.as_name(),\n             None => return,\n         };\n-        let source_item_id = self.source_file_items.id_of_unchecked(module.syntax());\n+        let ast_id = self.source_ast_id_map.ast_id(module);\n         if module.has_semi() {\n-            let item =\n-                self.raw_items.modules.alloc(ModuleData::Declaration { name, source_item_id });\n+            let item = self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id });\n             self.push_item(current_module, RawItem::Module(item));\n             return;\n         }\n \n         if let Some(item_list) = module.item_list() {\n             let item = self.raw_items.modules.alloc(ModuleData::Definition {\n                 name,\n-                source_item_id,\n+                ast_id,\n                 items: Vec::new(),\n             });\n             self.process_module(Some(item), item_list);\n@@ -291,18 +291,15 @@ impl RawItemsCollector {\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: &ast::MacroCall) {\n-        let (path, arg) = match (\n-            m.path().and_then(Path::from_ast),\n-            m.token_tree().and_then(mbe::ast_to_token_tree),\n-        ) {\n-            (Some(path), Some((token_tree, _token_map))) => (path, token_tree),\n+        let path = match m.path().and_then(Path::from_ast) {\n+            Some(it) => it,\n             _ => return,\n         };\n \n         let name = m.name().map(|it| it.as_name());\n-        let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n         let export = m.has_atom_attr(\"macro_export\");\n-        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, arg, name, export });\n+        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n         self.push_item(current_module, RawItem::Macro(m));\n     }\n "}, {"sha": "001f76ac30655de056b9842df24c8eae39261e40", "filename": "crates/ra_hir/src/nameres/tests/incremental.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -90,34 +90,44 @@ fn adding_inner_items_should_not_invalidate_def_map() {\n     );\n }\n \n-// It would be awesome to make this work, but it's unclear how\n #[test]\n-#[ignore]\n-fn typing_inside_a_function_inside_a_macro_should_not_invalidate_def_map() {\n-    check_def_map_is_not_recomputed(\n+fn typing_inside_a_macro_should_not_invalidate_def_map() {\n+    let (mut db, pos) = MockDatabase::with_position(\n         \"\n         //- /lib.rs\n+        macro_rules! m {\n+            ($ident:ident) => {\n+                fn f() {\n+                    $ident + $ident;\n+                };\n+            }\n+        }\n         mod foo;\n \n-        use crate::foo::bar::Baz;\n-\n         //- /foo/mod.rs\n         pub mod bar;\n \n         //- /foo/bar.rs\n         <|>\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 1 + 1 }\n-            }\n-        }\n-        \",\n-        \"\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 92 }\n-            }\n-        }\n+        m!(X);\n         \",\n     );\n+    {\n+        let events = db.log_executed(|| {\n+            let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n+            let decls = module.declarations(&db);\n+            assert_eq!(decls.len(), 1);\n+        });\n+        assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+    }\n+    db.set_file_text(pos.file_id, Arc::new(\"m!(Y);\".to_string()));\n+\n+    {\n+        let events = db.log_executed(|| {\n+            let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n+            let decls = module.declarations(&db);\n+            assert_eq!(decls.len(), 1);\n+        });\n+        assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+    }\n }"}, {"sha": "2609585b1f1e98607e30edaa4fdd3589e9ed4050", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     generics::GenericParams,\n     expr::{scope::{ExprScopes, ScopeId}, PatId, Body},\n     impl_block::ImplBlock,\n-    path::Path,\n+    path::Path, Trait\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -175,6 +175,21 @@ impl Resolver {\n         names\n     }\n \n+    pub(crate) fn traits_in_scope<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n+        // FIXME prelude\n+        self.scopes\n+            .iter()\n+            .rev()\n+            .flat_map(|scope| {\n+                match scope {\n+                    Scope::ModuleScope(m) => Some(m.crate_def_map[m.module_id].scope.traits()),\n+                    _ => None,\n+                }\n+                .into_iter()\n+            })\n+            .flatten()\n+    }\n+\n     fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),"}, {"sha": "9dae4c3d1de4d5684a3b6c9ce57581c36a099eec", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -15,8 +15,8 @@ use ra_syntax::{\n use crate::{\n     HirDatabase, Function, Struct, Enum,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n-    ids::{LocationCtx, SourceFileItemId},\n-    expr\n+    ids::LocationCtx,\n+    expr, AstId\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -54,8 +54,8 @@ fn module_from_inline(\n ) -> Option<Module> {\n     assert!(!module.has_semi());\n     let file_id = file_id.into();\n-    let file_items = db.file_items(file_id);\n-    let item_id = file_items.id_of(file_id, module.syntax());\n+    let ast_id_map = db.ast_id_map(file_id);\n+    let item_id = ast_id_map.ast_id(module).with_file_id(file_id);\n     module_from_source(db, file_id, Some(item_id))\n }\n \n@@ -75,7 +75,7 @@ pub fn module_from_child_node(\n fn module_from_source(\n     db: &impl HirDatabase,\n     file_id: HirFileId,\n-    decl_id: Option<SourceFileItemId>,\n+    decl_id: Option<AstId<ast::Module>>,\n ) -> Option<Module> {\n     let source_root_id = db.file_source_root(file_id.as_original_file());\n     db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map("}, {"sha": "0a8fb6d3285ad68d998664812a51f457df0fc9a2", "filename": "crates/ra_hir/src/source_id.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -0,0 +1,150 @@\n+use std::{marker::PhantomData, sync::Arc, hash::{Hash, Hasher}};\n+\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_syntax::{SyntaxNodePtr, TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n+\n+use crate::{HirFileId, DefDatabase};\n+\n+/// `AstId` points to an AST node in any file.\n+///\n+/// It is stable across reparses, and can be used as salsa key/value.\n+#[derive(Debug)]\n+pub(crate) struct AstId<N: AstNode> {\n+    file_id: HirFileId,\n+    file_ast_id: FileAstId<N>,\n+}\n+\n+impl<N: AstNode> Clone for AstId<N> {\n+    fn clone(&self) -> AstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for AstId<N> {}\n+\n+impl<N: AstNode> PartialEq for AstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n+    }\n+}\n+impl<N: AstNode> Eq for AstId<N> {}\n+impl<N: AstNode> Hash for AstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self.file_id, self.file_ast_id).hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> AstId<N> {\n+    pub(crate) fn file_id(&self) -> HirFileId {\n+        self.file_id\n+    }\n+\n+    pub(crate) fn to_node(&self, db: &impl DefDatabase) -> TreeArc<N> {\n+        let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.raw);\n+        N::cast(&syntax_node).unwrap().to_owned()\n+    }\n+}\n+\n+/// `AstId` points to an AST node in a specific file.\n+#[derive(Debug)]\n+pub(crate) struct FileAstId<N: AstNode> {\n+    raw: ErasedFileAstId,\n+    _ty: PhantomData<N>,\n+}\n+\n+impl<N: AstNode> Clone for FileAstId<N> {\n+    fn clone(&self) -> FileAstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for FileAstId<N> {}\n+\n+impl<N: AstNode> PartialEq for FileAstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.raw == other.raw\n+    }\n+}\n+impl<N: AstNode> Eq for FileAstId<N> {}\n+impl<N: AstNode> Hash for FileAstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.raw.hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> FileAstId<N> {\n+    pub(crate) fn with_file_id(self, file_id: HirFileId) -> AstId<N> {\n+        AstId { file_id, file_ast_id: self }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ErasedFileAstId(RawId);\n+impl_arena_id!(ErasedFileAstId);\n+\n+/// Maps items' `SyntaxNode`s to `ErasedFileAstId`s and back.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct AstIdMap {\n+    arena: Arena<ErasedFileAstId, SyntaxNodePtr>,\n+}\n+\n+impl AstIdMap {\n+    pub(crate) fn ast_id_map_query(db: &impl DefDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n+        let source_file = db.hir_parse(file_id);\n+        Arc::new(AstIdMap::from_source_file(&source_file))\n+    }\n+\n+    pub(crate) fn file_item_query(\n+        db: &impl DefDatabase,\n+        file_id: HirFileId,\n+        ast_id: ErasedFileAstId,\n+    ) -> TreeArc<SyntaxNode> {\n+        let source_file = db.hir_parse(file_id);\n+        db.ast_id_map(file_id).arena[ast_id].to_node(&source_file).to_owned()\n+    }\n+\n+    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n+        let ptr = SyntaxNodePtr::new(item.syntax());\n+        let raw = match self.arena.iter().find(|(_id, i)| **i == ptr) {\n+            Some((it, _)) => it,\n+            None => panic!(\n+                \"Can't find {:?} in AstIdMap:\\n{:?}\",\n+                item.syntax(),\n+                self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+            ),\n+        };\n+\n+        FileAstId { raw, _ty: PhantomData }\n+    }\n+\n+    fn from_source_file(source_file: &SourceFile) -> AstIdMap {\n+        let mut res = AstIdMap { arena: Arena::default() };\n+        // By walking the tree in bread-first order we make sure that parents\n+        // get lower ids then children. That is, adding a new child does not\n+        // change parent's id. This means that, say, adding a new function to a\n+        // trait does not change ids of top-level items, which helps caching.\n+        bfs(source_file.syntax(), |it| {\n+            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+                res.alloc(module_item.syntax());\n+            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n+                res.alloc(macro_call.syntax());\n+            }\n+        });\n+        res\n+    }\n+\n+    fn alloc(&mut self, item: &SyntaxNode) -> ErasedFileAstId {\n+        self.arena.alloc(SyntaxNodePtr::new(item))\n+    }\n+}\n+\n+/// Walks the subtree in bfs order, calling `f` for each node.\n+fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n+    let mut curr_layer = vec![node];\n+    let mut next_layer = vec![];\n+    while !curr_layer.is_empty() {\n+        curr_layer.drain(..).for_each(|node| {\n+            next_layer.extend(node.children());\n+            f(node);\n+        });\n+        std::mem::swap(&mut curr_layer, &mut next_layer);\n+    }\n+}"}, {"sha": "725bdd5cb3b3efc3311effe1be3f5993a5db359e", "filename": "crates/ra_hir/src/traits.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -0,0 +1,52 @@\n+//! HIR for trait definitions.\n+\n+use std::sync::Arc;\n+\n+use ra_syntax::ast::{self, NameOwner};\n+\n+use crate::{Function, Const, TypeAlias, Name, DefDatabase, Trait, ids::LocationCtx, name::AsName};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    name: Option<Name>,\n+    items: Vec<TraitItem>,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &impl DefDatabase, tr: Trait) -> Arc<TraitData> {\n+        let (file_id, node) = tr.source(db);\n+        let name = node.name().map(|n| n.as_name());\n+        let module = tr.module(db);\n+        let ctx = LocationCtx::new(db, module, file_id);\n+        let items = if let Some(item_list) = node.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node.kind() {\n+                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(it) }.into(),\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TraitData { name, items })\n+    }\n+\n+    pub(crate) fn name(&self) -> &Option<Name> {\n+        &self.name\n+    }\n+\n+    pub(crate) fn items(&self) -> &[TraitItem] {\n+        &self.items\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum TraitItem {\n+    Function(Function),\n+    Const(Const),\n+    TypeAlias(TypeAlias),\n+    // Existential\n+}\n+impl_froms!(TraitItem: Function, Const, TypeAlias);"}, {"sha": "d42c61e9d345757bae3789428c88add9f6b84d79", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -14,7 +14,7 @@ pub(crate) mod display;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase};\n+use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait};\n \n pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field, callable_item_sig};\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n@@ -91,7 +91,7 @@ pub enum TypeCtor {\n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n /// type like `bool`, a struct, tuple, function pointer, reference or\n /// several other things.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ApplicationTy {\n     pub ctor: TypeCtor,\n     pub parameters: Substs,\n@@ -103,7 +103,7 @@ pub struct ApplicationTy {\n /// the same thing (but in a different way).\n ///\n /// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Ty {\n     /// A nominal type with (maybe 0) type parameters. This might be a primitive\n     /// type like `bool`, a struct, tuple, function pointer, reference or\n@@ -132,7 +132,7 @@ pub enum Ty {\n }\n \n /// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs(Arc<[Ty]>);\n \n impl Substs {\n@@ -169,6 +169,21 @@ impl Substs {\n     }\n }\n \n+/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n+/// Name to be bikeshedded: TraitBound? TraitImplements?\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TraitRef {\n+    /// FIXME name?\n+    trait_: Trait,\n+    substs: Substs,\n+}\n+\n+impl TraitRef {\n+    pub fn self_ty(&self) -> &Ty {\n+        &self.substs.0[0]\n+    }\n+}\n+\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "5731153216a4f801108e742828bc786f0d26ee8e", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -821,7 +821,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n-                let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n+                let resolved =\n+                    receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n                 let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n                     Some((ty, func)) => {\n                         self.write_method_resolution(tgt_expr, func);"}, {"sha": "3ac8dc46b0d747ebb5232f1a5cab6b2f3b9af88e", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -8,12 +8,12 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     HirDatabase, Module, Crate, Name, Function, Trait,\n-    ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     ty::{Ty, TypeCtor},\n-    nameres::CrateModuleId,\n+    nameres::CrateModuleId, resolve::Resolver, traits::TraitItem\n \n };\n+use super::{ TraitRef, Substs};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -38,7 +38,7 @@ pub struct CrateImplBlocks {\n     /// To make sense of the CrateModuleIds, we need the source root.\n     krate: Crate,\n     impls: FxHashMap<TyFingerprint, Vec<(CrateModuleId, ImplId)>>,\n-    impls_by_trait: FxHashMap<TraitId, Vec<(CrateModuleId, ImplId)>>,\n+    impls_by_trait: FxHashMap<Trait, Vec<(CrateModuleId, ImplId)>>,\n }\n \n impl CrateImplBlocks {\n@@ -56,8 +56,7 @@ impl CrateImplBlocks {\n         &'a self,\n         tr: &Trait,\n     ) -> impl Iterator<Item = ImplBlock> + 'a {\n-        let id = tr.id;\n-        self.impls_by_trait.get(&id).into_iter().flat_map(|i| i.iter()).map(\n+        self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n                 let module = Module { krate: self.krate, module_id: *module_id };\n                 ImplBlock::from_id(module, *impl_id)\n@@ -73,18 +72,18 @@ impl CrateImplBlocks {\n \n             let target_ty = impl_block.target_ty(db);\n \n-            if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                self.impls\n-                    .entry(target_ty_fp)\n-                    .or_insert_with(Vec::new)\n-                    .push((module.module_id, impl_id));\n-            }\n-\n             if let Some(tr) = impl_block.target_trait(db) {\n                 self.impls_by_trait\n-                    .entry(tr.id)\n+                    .entry(tr)\n                     .or_insert_with(Vec::new)\n                     .push((module.module_id, impl_id));\n+            } else {\n+                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n+                    self.impls\n+                        .entry(target_ty_fp)\n+                        .or_insert_with(Vec::new)\n+                        .push((module.module_id, impl_id));\n+                }\n             }\n         }\n \n@@ -109,6 +108,20 @@ impl CrateImplBlocks {\n     }\n }\n \n+/// Rudimentary check whether an impl exists for a given type and trait; this\n+/// will actually be done by chalk.\n+pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n+    // FIXME use all trait impls in the whole crate graph\n+    let krate = trait_ref.trait_.module(db).krate(db);\n+    let krate = match krate {\n+        Some(krate) => krate,\n+        None => return false,\n+    };\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n+    impl_blocks.any(|impl_block| &impl_block.target_ty(db) == trait_ref.self_ty())\n+}\n+\n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -120,20 +133,64 @@ fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n }\n \n impl Ty {\n-    // FIXME: cache this as a query?\n-    // - if so, what signature? (TyFingerprint, Name)?\n-    // - or maybe cache all names and def_ids of methods per fingerprint?\n     /// Look up the method with the given name, returning the actual autoderefed\n     /// receiver type (but without autoref applied yet).\n-    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<(Ty, Function)> {\n-        self.iterate_methods(db, |ty, f| {\n+    pub fn lookup_method(\n+        self,\n+        db: &impl HirDatabase,\n+        name: &Name,\n+        resolver: &Resolver,\n+    ) -> Option<(Ty, Function)> {\n+        // FIXME: trait methods should be used before autoderefs\n+        let inherent_method = self.clone().iterate_methods(db, |ty, f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n                 Some((ty.clone(), f))\n             } else {\n                 None\n             }\n-        })\n+        });\n+        inherent_method.or_else(|| self.lookup_trait_method(db, name, resolver))\n+    }\n+\n+    fn lookup_trait_method(\n+        self,\n+        db: &impl HirDatabase,\n+        name: &Name,\n+        resolver: &Resolver,\n+    ) -> Option<(Ty, Function)> {\n+        let mut candidates = Vec::new();\n+        for t in resolver.traits_in_scope() {\n+            let data = t.trait_data(db);\n+            for item in data.items() {\n+                match item {\n+                    &TraitItem::Function(m) => {\n+                        let sig = m.signature(db);\n+                        if sig.name() == name && sig.has_self_param() {\n+                            candidates.push((t, m));\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        // FIXME:\n+        //  - we might not actually be able to determine fully that the type\n+        //    implements the trait here; it's enough if we (well, Chalk) determine\n+        //    that it's possible.\n+        //  - when the trait method is picked, we need to register an\n+        //    'obligation' somewhere so that we later check that it's really\n+        //    implemented\n+        //  - both points go for additional requirements from where clauses as\n+        //    well (in fact, the 'implements' condition could just be considered a\n+        //    'where Self: Trait' clause)\n+        candidates.retain(|(t, _m)| {\n+            let trait_ref = TraitRef { trait_: *t, substs: Substs::single(self.clone()) };\n+            db.implements(trait_ref)\n+        });\n+        // FIXME if there's multiple candidates here, that's an ambiguity error\n+        let (_chosen_trait, chosen_method) = candidates.first()?;\n+        Some((self.clone(), *chosen_method))\n     }\n \n     // This would be nicer if it just returned an iterator, but that runs into"}, {"sha": "655f3c52237611b2897e2f0895fa1f80d90d8b3d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -1272,8 +1272,8 @@ fn test() {\n [241; 252) 'Struct::FOO': u32\n [262; 263) 'y': u32\n [266; 275) 'Enum::BAR': u32\n-[285; 286) 'z': u32\n-[289; 302) 'TraitTest::ID': u32\"###\n+[285; 286) 'z': {unknown}\n+[289; 302) 'TraitTest::ID': {unknown}\"###\n     );\n }\n \n@@ -1918,9 +1918,9 @@ fn test() {\n [110; 114) 'self': &{unknown}\n [170; 228) '{     ...i128 }': ()\n [176; 178) 'S1': S1\n-[176; 187) 'S1.method()': {unknown}\n+[176; 187) 'S1.method()': u32\n [203; 205) 'S2': S2\n-[203; 214) 'S2.method()': {unknown}\"###\n+[203; 214) 'S2.method()': i128\"###\n     );\n }\n \n@@ -1964,10 +1964,10 @@ mod bar_test {\n [169; 173) 'self': &{unknown}\n [300; 337) '{     ...     }': ()\n [310; 311) 'S': S\n-[310; 320) 'S.method()': {unknown}\n+[310; 320) 'S.method()': u32\n [416; 454) '{     ...     }': ()\n [426; 427) 'S': S\n-[426; 436) 'S.method()': {unknown}\"###\n+[426; 436) 'S.method()': i128\"###\n     );\n }\n "}, {"sha": "a4a086931bc0c4ff6897f0320cd8cf54fdb3a7b3", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -220,8 +220,8 @@ impl RootDatabase {\n         self.query(ra_db::ParseQuery).sweep(sweep);\n \n         self.query(hir::db::HirParseQuery).sweep(sweep);\n-        self.query(hir::db::FileItemsQuery).sweep(sweep);\n-        self.query(hir::db::FileItemQuery).sweep(sweep);\n+        self.query(hir::db::AstIdMapQuery).sweep(sweep);\n+        self.query(hir::db::AstIdToNodeQuery).sweep(sweep);\n \n         self.query(hir::db::RawItemsWithSourceMapQuery).sweep(sweep);\n         self.query(hir::db::BodyWithSourceMapQuery).sweep(sweep);"}, {"sha": "27788c984623891c35d9639836daa391ef64c00c", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -28,7 +28,11 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n \n #[cfg(test)]\n mod tests {\n-    use crate::mock_analysis::analysis_and_position;\n+    use crate::{\n+        AnalysisChange, CrateGraph,\n+        mock_analysis::{analysis_and_position, MockAnalysis},\n+        Edition::Edition2018,\n+};\n \n     #[test]\n     fn test_resolve_parent_module() {\n@@ -59,4 +63,28 @@ mod tests {\n         let nav = analysis.parent_module(pos).unwrap().pop().unwrap();\n         nav.assert_match(\"baz MODULE FileId(1) [32; 44)\");\n     }\n+\n+    #[test]\n+    fn test_resolve_crate_root() {\n+        let mock = MockAnalysis::with_files(\n+            \"\n+        //- /bar.rs\n+        mod foo;\n+        //- /foo.rs\n+        // empty <|>\n+    \",\n+        );\n+        let root_file = mock.id_of(\"/bar.rs\");\n+        let mod_file = mock.id_of(\"/foo.rs\");\n+        let mut host = mock.analysis_host();\n+        assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n+\n+        let mut crate_graph = CrateGraph::default();\n+        let crate_id = crate_graph.add_crate_root(root_file, Edition2018);\n+        let mut change = AnalysisChange::new();\n+        change.set_crate_graph(crate_graph);\n+        host.apply_change(change);\n+\n+        assert_eq!(host.analysis().crate_for(mod_file).unwrap(), vec![crate_id]);\n+    }\n }"}, {"sha": "20bbf11a3867794ea7dc44855ff2841062415432", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -216,9 +216,55 @@ mod tests {\n     use crate::{\n         mock_analysis::single_file_with_position,\n         mock_analysis::analysis_and_position,\n-        FileId\n+        FileId, ReferenceSearchResult\n };\n \n+    #[test]\n+    fn test_find_all_refs_for_local() {\n+        let code = r#\"\n+    fn main() {\n+        let mut i = 1;\n+        let j = 1;\n+        i = i<|> + j;\n+\n+        {\n+            i = 0;\n+        }\n+\n+        i = 5;\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 5);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_param_inside() {\n+        let code = r#\"\n+    fn foo(i : u32) -> u32 {\n+        i<|>\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_fn_param() {\n+        let code = r#\"\n+    fn foo(i<|> : u32) -> u32 {\n+        i\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n+        let (analysis, position) = single_file_with_position(text);\n+        analysis.find_all_refs(position).unwrap().unwrap()\n+    }\n+\n     #[test]\n     fn test_rename_for_local() {\n         test_rename("}, {"sha": "0eadc4e71980aa189297762a9495f92cfccc223b", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -270,3 +270,61 @@ fn to_file_symbol(node: &SyntaxNode, file_id: FileId) -> Option<FileSymbol> {\n         container_name: None,\n     })\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_syntax::SmolStr;\n+    use crate::{\n+        navigation_target::NavigationTarget,\n+        mock_analysis::single_file,\n+        Query,\n+};\n+\n+    #[test]\n+    fn test_world_symbols_with_no_container() {\n+        let code = r#\"\n+    enum FooInner { }\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert!(s.container_name().is_none());\n+    }\n+\n+    #[test]\n+    fn test_world_symbols_include_container_name() {\n+        let code = r#\"\n+fn foo() {\n+    enum FooInner { }\n+}\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n+\n+        let code = r#\"\n+mod foo {\n+    struct FooInner;\n+}\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n+    }\n+\n+    fn get_symbols_matching(text: &str, query: &str) -> Vec<NavigationTarget> {\n+        let (analysis, _) = single_file(text);\n+        analysis.symbol_search(Query::new(query.into())).unwrap()\n+    }\n+}"}, {"sha": "276f8a8c8acd5207c9683dc5b6f5a4356851f96e", "filename": "crates/ra_ide_api/src/syntax_tree.rs", "status": "modified", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -85,3 +85,260 @@ fn syntax_tree_for_token<T: AstToken>(node: &T, text_range: TextRange) -> Option\n \r\n     None\r\n }\r\n+\r\n+#[cfg(test)]\r\n+mod tests {\r\n+    use crate::mock_analysis::{single_file, single_file_with_range};\r\n+\r\n+    #[test]\r\n+    fn test_syntax_tree_without_range() {\r\n+        // Basic syntax\r\n+        let (analysis, file_id) = single_file(r#\"fn foo() {}\"#);\r\n+        let syn = analysis.syntax_tree(file_id, None);\r\n+\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 11)\r\n+  FN_DEF@[0; 11)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 6)\r\n+      IDENT@[3; 6) \"foo\"\r\n+    PARAM_LIST@[6; 8)\r\n+      L_PAREN@[6; 7)\r\n+      R_PAREN@[7; 8)\r\n+    WHITESPACE@[8; 9)\r\n+    BLOCK@[9; 11)\r\n+      L_CURLY@[9; 10)\r\n+      R_CURLY@[10; 11)\r\n+    \"#\r\n+            .trim()\r\n+        );\r\n+\r\n+        let (analysis, file_id) = single_file(\r\n+            r#\"\r\n+fn test() {\r\n+    assert!(\"\r\n+    fn foo() {\r\n+    }\r\n+    \", \"\");\r\n+}\"#\r\n+            .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(file_id, None);\r\n+\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 60)\r\n+  FN_DEF@[0; 60)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 7)\r\n+      IDENT@[3; 7) \"test\"\r\n+    PARAM_LIST@[7; 9)\r\n+      L_PAREN@[7; 8)\r\n+      R_PAREN@[8; 9)\r\n+    WHITESPACE@[9; 10)\r\n+    BLOCK@[10; 60)\r\n+      L_CURLY@[10; 11)\r\n+      WHITESPACE@[11; 16)\r\n+      EXPR_STMT@[16; 58)\r\n+        MACRO_CALL@[16; 57)\r\n+          PATH@[16; 22)\r\n+            PATH_SEGMENT@[16; 22)\r\n+              NAME_REF@[16; 22)\r\n+                IDENT@[16; 22) \"assert\"\r\n+          EXCL@[22; 23)\r\n+          TOKEN_TREE@[23; 57)\r\n+            L_PAREN@[23; 24)\r\n+            STRING@[24; 52)\r\n+            COMMA@[52; 53)\r\n+            WHITESPACE@[53; 54)\r\n+            STRING@[54; 56)\r\n+            R_PAREN@[56; 57)\r\n+        SEMI@[57; 58)\r\n+      WHITESPACE@[58; 59)\r\n+      R_CURLY@[59; 60)\r\n+    \"#\r\n+            .trim()\r\n+        );\r\n+    }\r\n+\r\n+    #[test]\r\n+    fn test_syntax_tree_with_range() {\r\n+        let (analysis, range) = single_file_with_range(r#\"<|>fn foo() {}<|>\"#.trim());\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+FN_DEF@[0; 11)\r\n+  FN_KW@[0; 2)\r\n+  WHITESPACE@[2; 3)\r\n+  NAME@[3; 6)\r\n+    IDENT@[3; 6) \"foo\"\r\n+  PARAM_LIST@[6; 8)\r\n+    L_PAREN@[6; 7)\r\n+    R_PAREN@[7; 8)\r\n+  WHITESPACE@[8; 9)\r\n+  BLOCK@[9; 11)\r\n+    L_CURLY@[9; 10)\r\n+    R_CURLY@[10; 11)\r\n+    \"#\r\n+            .trim()\r\n+        );\r\n+\r\n+        let (analysis, range) = single_file_with_range(\r\n+            r#\"fn test() {\r\n+    <|>assert!(\"\r\n+    fn foo() {\r\n+    }\r\n+    \", \"\");<|>\r\n+}\"#\r\n+            .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+EXPR_STMT@[16; 58)\r\n+  MACRO_CALL@[16; 57)\r\n+    PATH@[16; 22)\r\n+      PATH_SEGMENT@[16; 22)\r\n+        NAME_REF@[16; 22)\r\n+          IDENT@[16; 22) \"assert\"\r\n+    EXCL@[22; 23)\r\n+    TOKEN_TREE@[23; 57)\r\n+      L_PAREN@[23; 24)\r\n+      STRING@[24; 52)\r\n+      COMMA@[52; 53)\r\n+      WHITESPACE@[53; 54)\r\n+      STRING@[54; 56)\r\n+      R_PAREN@[56; 57)\r\n+  SEMI@[57; 58)\r\n+    \"#\r\n+            .trim()\r\n+        );\r\n+    }\r\n+\r\n+    #[test]\r\n+    fn test_syntax_tree_inside_string() {\r\n+        let (analysis, range) = single_file_with_range(\r\n+            r#\"fn test() {\r\n+    assert!(\"\r\n+<|>fn foo() {\r\n+}<|>\r\n+fn bar() {\r\n+}\r\n+    \", \"\");\r\n+}\"#\r\n+            .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 12)\r\n+  FN_DEF@[0; 12)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 6)\r\n+      IDENT@[3; 6) \"foo\"\r\n+    PARAM_LIST@[6; 8)\r\n+      L_PAREN@[6; 7)\r\n+      R_PAREN@[7; 8)\r\n+    WHITESPACE@[8; 9)\r\n+    BLOCK@[9; 12)\r\n+      L_CURLY@[9; 10)\r\n+      WHITESPACE@[10; 11)\r\n+      R_CURLY@[11; 12)\r\n+\"#\r\n+            .trim()\r\n+        );\r\n+\r\n+        // With a raw string\r\n+        let (analysis, range) = single_file_with_range(\r\n+            r###\"fn test() {\r\n+    assert!(r#\"\r\n+<|>fn foo() {\r\n+}<|>\r\n+fn bar() {\r\n+}\r\n+    \"#, \"\");\r\n+}\"###\r\n+                .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 12)\r\n+  FN_DEF@[0; 12)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 6)\r\n+      IDENT@[3; 6) \"foo\"\r\n+    PARAM_LIST@[6; 8)\r\n+      L_PAREN@[6; 7)\r\n+      R_PAREN@[7; 8)\r\n+    WHITESPACE@[8; 9)\r\n+    BLOCK@[9; 12)\r\n+      L_CURLY@[9; 10)\r\n+      WHITESPACE@[10; 11)\r\n+      R_CURLY@[11; 12)\r\n+\"#\r\n+            .trim()\r\n+        );\r\n+\r\n+        // With a raw string\r\n+        let (analysis, range) = single_file_with_range(\r\n+            r###\"fn test() {\r\n+    assert!(r<|>#\"\r\n+fn foo() {\r\n+}\r\n+fn bar() {\r\n+}\"<|>#, \"\");\r\n+}\"###\r\n+                .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 25)\r\n+  FN_DEF@[0; 12)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 6)\r\n+      IDENT@[3; 6) \"foo\"\r\n+    PARAM_LIST@[6; 8)\r\n+      L_PAREN@[6; 7)\r\n+      R_PAREN@[7; 8)\r\n+    WHITESPACE@[8; 9)\r\n+    BLOCK@[9; 12)\r\n+      L_CURLY@[9; 10)\r\n+      WHITESPACE@[10; 11)\r\n+      R_CURLY@[11; 12)\r\n+  WHITESPACE@[12; 13)\r\n+  FN_DEF@[13; 25)\r\n+    FN_KW@[13; 15)\r\n+    WHITESPACE@[15; 16)\r\n+    NAME@[16; 19)\r\n+      IDENT@[16; 19) \"bar\"\r\n+    PARAM_LIST@[19; 21)\r\n+      L_PAREN@[19; 20)\r\n+      R_PAREN@[20; 21)\r\n+    WHITESPACE@[21; 22)\r\n+    BLOCK@[22; 25)\r\n+      L_CURLY@[22; 23)\r\n+      WHITESPACE@[23; 24)\r\n+      R_CURLY@[24; 25)\r\n+\r\n+\"#\r\n+            .trim()\r\n+        );\r\n+    }\r\n+}\r"}, {"sha": "d4ff21c09ccab9fc79b72152f75b94952835d9e9", "filename": "crates/ra_ide_api/tests/test/main.rs", "status": "removed", "additions": 0, "deletions": 376, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/12b5d4f795f69f7fa07051cdec7a1347d3aa7924/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b5d4f795f69f7fa07051cdec7a1347d3aa7924/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs?ref=12b5d4f795f69f7fa07051cdec7a1347d3aa7924", "patch": "@@ -1,376 +0,0 @@\n-use ra_ide_api::{\n-    mock_analysis::{single_file, single_file_with_position, single_file_with_range, MockAnalysis},\n-    AnalysisChange, CrateGraph, Edition::Edition2018, Query, NavigationTarget,\n-    ReferenceSearchResult,\n-};\n-use ra_syntax::SmolStr;\n-\n-#[test]\n-fn test_resolve_crate_root() {\n-    let mock = MockAnalysis::with_files(\n-        \"\n-        //- /bar.rs\n-        mod foo;\n-        //- /foo.rs\n-        // empty <|>\n-    \",\n-    );\n-    let root_file = mock.id_of(\"/bar.rs\");\n-    let mod_file = mock.id_of(\"/foo.rs\");\n-    let mut host = mock.analysis_host();\n-    assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n-\n-    let mut crate_graph = CrateGraph::default();\n-    let crate_id = crate_graph.add_crate_root(root_file, Edition2018);\n-    let mut change = AnalysisChange::new();\n-    change.set_crate_graph(crate_graph);\n-    host.apply_change(change);\n-\n-    assert_eq!(host.analysis().crate_for(mod_file).unwrap(), vec![crate_id]);\n-}\n-\n-fn get_all_refs(text: &str) -> ReferenceSearchResult {\n-    let (analysis, position) = single_file_with_position(text);\n-    analysis.find_all_refs(position).unwrap().unwrap()\n-}\n-\n-fn get_symbols_matching(text: &str, query: &str) -> Vec<NavigationTarget> {\n-    let (analysis, _) = single_file(text);\n-    analysis.symbol_search(Query::new(query.into())).unwrap()\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_local() {\n-    let code = r#\"\n-    fn main() {\n-        let mut i = 1;\n-        let j = 1;\n-        i = i<|> + j;\n-\n-        {\n-            i = 0;\n-        }\n-\n-        i = 5;\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 5);\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_param_inside() {\n-    let code = r#\"\n-    fn foo(i : u32) -> u32 {\n-        i<|>\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 2);\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_fn_param() {\n-    let code = r#\"\n-    fn foo(i<|> : u32) -> u32 {\n-        i\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 2);\n-}\n-\n-#[test]\n-fn test_world_symbols_with_no_container() {\n-    let code = r#\"\n-    enum FooInner { }\n-    \"#;\n-\n-    let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-    let s = symbols.pop().unwrap();\n-\n-    assert_eq!(s.name(), \"FooInner\");\n-    assert!(s.container_name().is_none());\n-}\n-\n-#[test]\n-fn test_world_symbols_include_container_name() {\n-    let code = r#\"\n-fn foo() {\n-    enum FooInner { }\n-}\n-    \"#;\n-\n-    let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-    let s = symbols.pop().unwrap();\n-\n-    assert_eq!(s.name(), \"FooInner\");\n-    assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n-\n-    let code = r#\"\n-mod foo {\n-    struct FooInner;\n-}\n-    \"#;\n-\n-    let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-    let s = symbols.pop().unwrap();\n-\n-    assert_eq!(s.name(), \"FooInner\");\n-    assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n-}\n-\n-#[test]\n-fn test_syntax_tree_without_range() {\n-    // Basic syntax\n-    let (analysis, file_id) = single_file(r#\"fn foo() {}\"#);\n-    let syn = analysis.syntax_tree(file_id, None);\n-\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 11)\n-  FN_DEF@[0; 11)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 6)\n-      IDENT@[3; 6) \"foo\"\n-    PARAM_LIST@[6; 8)\n-      L_PAREN@[6; 7)\n-      R_PAREN@[7; 8)\n-    WHITESPACE@[8; 9)\n-    BLOCK@[9; 11)\n-      L_CURLY@[9; 10)\n-      R_CURLY@[10; 11)\n-    \"#\n-        .trim()\n-    );\n-\n-    let (analysis, file_id) = single_file(\n-        r#\"\n-fn test() {\n-    assert!(\"\n-    fn foo() {\n-    }\n-    \", \"\");\n-}\"#\n-        .trim(),\n-    );\n-    let syn = analysis.syntax_tree(file_id, None);\n-\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 60)\n-  FN_DEF@[0; 60)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 7)\n-      IDENT@[3; 7) \"test\"\n-    PARAM_LIST@[7; 9)\n-      L_PAREN@[7; 8)\n-      R_PAREN@[8; 9)\n-    WHITESPACE@[9; 10)\n-    BLOCK@[10; 60)\n-      L_CURLY@[10; 11)\n-      WHITESPACE@[11; 16)\n-      EXPR_STMT@[16; 58)\n-        MACRO_CALL@[16; 57)\n-          PATH@[16; 22)\n-            PATH_SEGMENT@[16; 22)\n-              NAME_REF@[16; 22)\n-                IDENT@[16; 22) \"assert\"\n-          EXCL@[22; 23)\n-          TOKEN_TREE@[23; 57)\n-            L_PAREN@[23; 24)\n-            STRING@[24; 52)\n-            COMMA@[52; 53)\n-            WHITESPACE@[53; 54)\n-            STRING@[54; 56)\n-            R_PAREN@[56; 57)\n-        SEMI@[57; 58)\n-      WHITESPACE@[58; 59)\n-      R_CURLY@[59; 60)\n-    \"#\n-        .trim()\n-    );\n-}\n-\n-#[test]\n-fn test_syntax_tree_with_range() {\n-    let (analysis, range) = single_file_with_range(r#\"<|>fn foo() {}<|>\"#.trim());\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-FN_DEF@[0; 11)\n-  FN_KW@[0; 2)\n-  WHITESPACE@[2; 3)\n-  NAME@[3; 6)\n-    IDENT@[3; 6) \"foo\"\n-  PARAM_LIST@[6; 8)\n-    L_PAREN@[6; 7)\n-    R_PAREN@[7; 8)\n-  WHITESPACE@[8; 9)\n-  BLOCK@[9; 11)\n-    L_CURLY@[9; 10)\n-    R_CURLY@[10; 11)\n-    \"#\n-        .trim()\n-    );\n-\n-    let (analysis, range) = single_file_with_range(\n-        r#\"fn test() {\n-    <|>assert!(\"\n-    fn foo() {\n-    }\n-    \", \"\");<|>\n-}\"#\n-        .trim(),\n-    );\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-EXPR_STMT@[16; 58)\n-  MACRO_CALL@[16; 57)\n-    PATH@[16; 22)\n-      PATH_SEGMENT@[16; 22)\n-        NAME_REF@[16; 22)\n-          IDENT@[16; 22) \"assert\"\n-    EXCL@[22; 23)\n-    TOKEN_TREE@[23; 57)\n-      L_PAREN@[23; 24)\n-      STRING@[24; 52)\n-      COMMA@[52; 53)\n-      WHITESPACE@[53; 54)\n-      STRING@[54; 56)\n-      R_PAREN@[56; 57)\n-  SEMI@[57; 58)\n-    \"#\n-        .trim()\n-    );\n-}\n-\n-#[test]\n-fn test_syntax_tree_inside_string() {\n-    let (analysis, range) = single_file_with_range(\n-        r#\"fn test() {\n-    assert!(\"\n-<|>fn foo() {\n-}<|>\n-fn bar() {\n-}\n-    \", \"\");\n-}\"#\n-        .trim(),\n-    );\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 12)\n-  FN_DEF@[0; 12)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 6)\n-      IDENT@[3; 6) \"foo\"\n-    PARAM_LIST@[6; 8)\n-      L_PAREN@[6; 7)\n-      R_PAREN@[7; 8)\n-    WHITESPACE@[8; 9)\n-    BLOCK@[9; 12)\n-      L_CURLY@[9; 10)\n-      WHITESPACE@[10; 11)\n-      R_CURLY@[11; 12)\n-\"#\n-        .trim()\n-    );\n-\n-    // With a raw string\n-    let (analysis, range) = single_file_with_range(\n-        r###\"fn test() {\n-    assert!(r#\"\n-<|>fn foo() {\n-}<|>\n-fn bar() {\n-}\n-    \"#, \"\");\n-}\"###\n-            .trim(),\n-    );\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 12)\n-  FN_DEF@[0; 12)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 6)\n-      IDENT@[3; 6) \"foo\"\n-    PARAM_LIST@[6; 8)\n-      L_PAREN@[6; 7)\n-      R_PAREN@[7; 8)\n-    WHITESPACE@[8; 9)\n-    BLOCK@[9; 12)\n-      L_CURLY@[9; 10)\n-      WHITESPACE@[10; 11)\n-      R_CURLY@[11; 12)\n-\"#\n-        .trim()\n-    );\n-\n-    // With a raw string\n-    let (analysis, range) = single_file_with_range(\n-        r###\"fn test() {\n-    assert!(r<|>#\"\n-fn foo() {\n-}\n-fn bar() {\n-}\"<|>#, \"\");\n-}\"###\n-            .trim(),\n-    );\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 25)\n-  FN_DEF@[0; 12)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 6)\n-      IDENT@[3; 6) \"foo\"\n-    PARAM_LIST@[6; 8)\n-      L_PAREN@[6; 7)\n-      R_PAREN@[7; 8)\n-    WHITESPACE@[8; 9)\n-    BLOCK@[9; 12)\n-      L_CURLY@[9; 10)\n-      WHITESPACE@[10; 11)\n-      R_CURLY@[11; 12)\n-  WHITESPACE@[12; 13)\n-  FN_DEF@[13; 25)\n-    FN_KW@[13; 15)\n-    WHITESPACE@[15; 16)\n-    NAME@[16; 19)\n-      IDENT@[16; 19) \"bar\"\n-    PARAM_LIST@[19; 21)\n-      L_PAREN@[19; 20)\n-      R_PAREN@[20; 21)\n-    WHITESPACE@[21; 22)\n-    BLOCK@[22; 25)\n-      L_CURLY@[22; 23)\n-      WHITESPACE@[23; 24)\n-      R_CURLY@[24; 25)\n-\n-\"#\n-        .trim()\n-    );\n-}"}, {"sha": "47a37e4d19c7475baac8bc99790cb5e79f5fe1a7", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -4061,7 +4061,11 @@ impl ast::NameOwner for TraitDef {}\n impl ast::AttrsOwner for TraitDef {}\n impl ast::DocCommentsOwner for TraitDef {}\n impl ast::TypeParamsOwner for TraitDef {}\n-impl TraitDef {}\n+impl TraitDef {\n+    pub fn item_list(&self) -> Option<&ItemList> {\n+        super::child_opt(self)\n+    }\n+}\n \n // TrueKw\n #[derive(Debug, PartialEq, Eq, Hash)]"}, {"sha": "ad6d74162b94b6f871896d96955d8f306162c2d5", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -292,7 +292,10 @@ Grammar(\n         ], options: [[\"variant_list\", \"EnumVariantList\"]] ),\n         \"EnumVariantList\": ( collections: [[\"variants\", \"EnumVariant\"]] ),\n         \"EnumVariant\": ( traits: [\"NameOwner\", \"DocCommentsOwner\", \"AttrsOwner\"], options: [\"Expr\"] ),\n-        \"TraitDef\": ( traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\", \"TypeParamsOwner\"] ),\n+        \"TraitDef\": (\n+            traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\", \"TypeParamsOwner\"],\n+            options: [\"ItemList\"]\n+        ),\n         \"Module\": (\n             traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\" ],\n             options: [ \"ItemList\" ]"}, {"sha": "7173d88e924eab87cfeafa273228516450c3fe5c", "filename": "docs/user/features.md", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6030d6f500e42bde012a391666b68363d8479d21/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/6030d6f500e42bde012a391666b68363d8479d21/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=6030d6f500e42bde012a391666b68363d8479d21", "patch": "@@ -210,7 +210,7 @@ fn main() {\n }\n ```\n \n--- Fill struct fields\n+- Fill struct fields\n \n ```rust\n // before:\n@@ -270,7 +270,22 @@ fn foo() {\n }\n ```\n \n--- Remove `dbg!`\n+- Inline local variable:\n+\n+```rust\n+// before:\n+fn foo() {\n+    let a<|> = 1 + 1;\n+    let b = a * 10;\n+}\n+\n+// after:\n+fn foo() {\n+    let b = (1 + 1) * 10;\n+}\n+```\n+\n+- Remove `dbg!`\n \n ```rust\n // before:"}]}