{"sha": "d7e2f3aee5508538c5de14211ab5b31362e1164a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZTJmM2FlZTU1MDg1MzhjNWRlMTQyMTFhYjViMzEzNjJlMTE2NGE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-30T08:08:18Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-30T13:05:17Z"}, "message": "refactor and fix this-expression-has-type note", "tree": {"sha": "dbeaede2fe24403f162f8c6486e6fa5672a4f32f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbeaede2fe24403f162f8c6486e6fa5672a4f32f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7e2f3aee5508538c5de14211ab5b31362e1164a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e2f3aee5508538c5de14211ab5b31362e1164a", "html_url": "https://github.com/rust-lang/rust/commit/d7e2f3aee5508538c5de14211ab5b31362e1164a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7e2f3aee5508538c5de14211ab5b31362e1164a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f35840f77cbb496dc35645331318f4b52c9a5b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f35840f77cbb496dc35645331318f4b52c9a5b2a", "html_url": "https://github.com/rust-lang/rust/commit/f35840f77cbb496dc35645331318f4b52c9a5b2a"}], "stats": {"total": 239, "additions": 135, "deletions": 104}, "files": [{"sha": "5c561a87b0547b8caf45fa16b47afe7ab0e5cb32", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -582,6 +582,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         match cause.code {\n             ObligationCauseCode::Pattern { span, ty } => {\n+                let ty = self.resolve_vars_if_possible(&ty);\n                 if ty.is_suggestable() {\n                     // don't show type `_`\n                     err.span_label(span, format!(\"this expression has type `{}`\", ty));"}, {"sha": "a3ef41f0de5b59d9f306a41047a8d13919ce9df5", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 91, "deletions": 82, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -30,16 +30,48 @@ pointers. If you encounter this error you should try to avoid dereferencing the\n You can read more about trait objects in the Trait Objects section of the Reference: \\\n https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n+/// Information about the expected type at the top level of type checking a pattern.\n+///\n+/// **NOTE:** This is only for use by diagnostics. Do NOT use for type checking logic!\n+#[derive(Copy, Clone)]\n+struct TopInfo<'tcx> {\n+    /// The `expected` type at the top level of type checking a pattern.\n+    expected: Ty<'tcx>,\n+    /// The span giving rise to the `expected` type, if one could be provided.\n+    ///\n+    /// This is the span of the scrutinee as in:\n+    ///\n+    /// - `match scrutinee { ... }`\n+    /// - `let _ = scrutinee;`\n+    ///\n+    /// This is used to point to add context in type errors.\n+    /// In the following example, `span` corresponds to the `a + b` expression:\n+    ///\n+    /// ```text\n+    /// error[E0308]: mismatched types\n+    ///  --> src/main.rs:L:C\n+    ///   |\n+    /// L |    let temp: usize = match a + b {\n+    ///   |                            ----- this expression has type `usize`\n+    /// L |         Ok(num) => num,\n+    ///   |         ^^^^^^^ expected `usize`, found enum `std::result::Result`\n+    ///   |\n+    ///   = note: expected type `usize`\n+    ///              found type `std::result::Result<_, _>`\n+    /// ```\n+    span: Option<Span>,\n+}\n+\n impl<'tcx> FnCtxt<'_, 'tcx> {\n     fn demand_eqtype_pat_diag(\n         &self,\n         cause_span: Span,\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n-        match_expr_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        let cause = if let Some(span) = match_expr_span {\n-            self.cause(cause_span, Pattern { span, ty: expected })\n+        let cause = if let Some(span) = ti.span {\n+            self.cause(cause_span, Pattern { span, ty: ti.expected })\n         } else {\n             self.misc(cause_span)\n         };\n@@ -51,41 +83,33 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         cause_span: Span,\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n-        match_expr_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) {\n-        self.demand_eqtype_pat_diag(cause_span, expected, actual, match_expr_span)\n-            .map(|mut err| err.emit());\n+        self.demand_eqtype_pat_diag(cause_span, expected, actual, ti).map(|mut err| err.emit());\n     }\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Type check the given top level pattern against the `expected` type.\n+    ///\n+    /// If a `Some(span)` is provided, then the `span` represents the scrutinee's span.\n+    /// The scrutinee is found in e.g. `match scrutinee { ... }` and `let pat = scrutinee;`.\n     pub fn check_pat_top(&self, pat: &'tcx Pat<'tcx>, expected: Ty<'tcx>, span: Option<Span>) {\n         let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n-        self.check_pat(pat, expected, def_bm, span);\n+        self.check_pat(pat, expected, def_bm, TopInfo { expected, span });\n     }\n \n-    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n-    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n-    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n+    /// Type check the given `pat` against the `expected` type\n+    /// with the provided `def_bm` (default binding mode).\n     ///\n-    /// ```text\n-    /// error[E0308]: mismatched types\n-    ///  --> src/main.rs:5:9\n-    ///   |\n-    /// 4 |    let temp: usize = match a + b {\n-    ///   |                            ----- this expression has type `usize`\n-    /// 5 |         Ok(num) => num,\n-    ///   |         ^^^^^^^ expected `usize`, found enum `std::result::Result`\n-    ///   |\n-    ///   = note: expected type `usize`\n-    ///              found type `std::result::Result<_, _>`\n-    /// ```\n+    /// Outside of this module, `check_pat_top` should always be used.\n+    /// Conversely, inside this module, `check_pat_top` should never be used.\n     fn check_pat(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n@@ -98,48 +122,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ty = match pat.kind {\n             PatKind::Wild => expected,\n-            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, discrim_span),\n+            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, ti),\n             PatKind::Range(begin, end, _) => {\n-                match self.check_pat_range(pat.span, begin, end, expected, discrim_span) {\n+                match self.check_pat_range(pat.span, begin, end, expected, ti) {\n                     None => return,\n                     Some(ty) => ty,\n                 }\n             }\n             PatKind::Binding(ba, var_id, _, sub) => {\n-                self.check_pat_ident(pat, ba, var_id, sub, expected, def_bm, discrim_span)\n+                self.check_pat_ident(pat, ba, var_id, sub, expected, def_bm, ti)\n+            }\n+            PatKind::TupleStruct(ref qpath, subpats, ddpos) => {\n+                self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n             }\n-            PatKind::TupleStruct(ref qpath, subpats, ddpos) => self.check_pat_tuple_struct(\n-                pat,\n-                qpath,\n-                subpats,\n-                ddpos,\n-                expected,\n-                def_bm,\n-                discrim_span,\n-            ),\n             PatKind::Path(ref qpath) => {\n                 self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n             }\n             PatKind::Struct(ref qpath, fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n             }\n             PatKind::Or(pats) => {\n                 for pat in pats {\n-                    self.check_pat(pat, expected, def_bm, discrim_span);\n+                    self.check_pat(pat, expected, def_bm, ti);\n                 }\n                 expected\n             }\n             PatKind::Tuple(elements, ddpos) => {\n-                self.check_pat_tuple(pat.span, elements, ddpos, expected, def_bm, discrim_span)\n-            }\n-            PatKind::Box(inner) => {\n-                self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n+                self.check_pat_tuple(pat.span, elements, ddpos, expected, def_bm, ti)\n             }\n+            PatKind::Box(inner) => self.check_pat_box(pat.span, inner, expected, def_bm, ti),\n             PatKind::Ref(inner, mutbl) => {\n-                self.check_pat_ref(pat, inner, mutbl, expected, def_bm, discrim_span)\n+                self.check_pat_ref(pat, inner, mutbl, expected, def_bm, ti)\n             }\n             PatKind::Slice(before, slice, after) => {\n-                self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, discrim_span)\n+                self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, ti)\n             }\n         };\n \n@@ -316,7 +332,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         lt: &hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // We've already computed the type above (when checking for a non-ref pat),\n         // so avoid computing it again.\n@@ -350,7 +366,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // then that's equivalent to there existing a LUB.\n         if let Some(mut err) = self.demand_suptype_diag(span, expected, pat_ty) {\n             err.emit_unless(\n-                discrim_span\n+                ti.span\n                     .filter(|&s| {\n                         // In the case of `if`- and `while`-expressions we've already checked\n                         // that `scrutinee: bool`. We know that the pattern is `true`,\n@@ -370,7 +386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs: &'tcx hir::Expr<'tcx>,\n         rhs: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         let lhs_ty = self.check_expr(lhs);\n         let rhs_ty = self.check_expr(rhs);\n@@ -391,7 +407,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n         let demand_eqtype = |x_span, y_span, x_ty, y_ty| {\n-            self.demand_eqtype_pat_diag(x_span, expected, x_ty, discrim_span).map(|mut err| {\n+            self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti).map(|mut err| {\n                 self.endpoint_has_type(&mut err, y_span, y_ty);\n                 err.emit();\n             });\n@@ -465,7 +481,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         sub: Option<&'tcx Pat<'tcx>>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Determine the binding mode...\n         let bm = match ba {\n@@ -495,17 +511,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected\n             }\n         };\n-        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, discrim_span);\n+        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, ti);\n \n         // If there are multiple arms, make sure they all agree on\n         // what the type of the binding `x` ought to be.\n         if var_id != pat.hir_id {\n             let vt = self.local_ty(pat.span, var_id).decl_ty;\n-            self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n+            self.demand_eqtype_pat(pat.span, vt, local_ty, ti);\n         }\n \n         if let Some(p) = sub {\n-            self.check_pat(&p, expected, def_bm, discrim_span);\n+            self.check_pat(&p, expected, def_bm, ti);\n         }\n \n         local_ty\n@@ -584,33 +600,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n         {\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n+                self.check_pat(&field.pat, self.tcx.types.err, def_bm, ti);\n             }\n             return self.tcx.types.err;\n         };\n \n         // Type-check the path.\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, ti);\n \n         // Type-check subpatterns.\n-        if self.check_struct_pat_fields(\n-            pat_ty,\n-            pat.hir_id,\n-            pat.span,\n-            variant,\n-            fields,\n-            etc,\n-            def_bm,\n-            discrim_span,\n-        ) {\n+        if self\n+            .check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm, ti)\n+        {\n             pat_ty\n         } else {\n             self.tcx.types.err\n@@ -660,12 +669,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        match_arm_pat_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n+                self.check_pat(&pat, tcx.types.err, def_bm, ti);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -726,7 +735,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n \n         // Type-check the tuple struct pattern against the expected type.\n-        let diag = self.demand_eqtype_pat_diag(pat.span, expected, pat_ty, match_arm_pat_span);\n+        let diag = self.demand_eqtype_pat_diag(pat.span, expected, pat_ty, ti);\n         let had_err = diag.is_some();\n         diag.map(|mut err| err.emit());\n \n@@ -740,7 +749,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat(&subpat, field_ty, def_bm, match_arm_pat_span);\n+                self.check_pat(&subpat, field_ty, def_bm, ti);\n \n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n@@ -844,7 +853,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let mut expected_len = elements.len();\n@@ -871,12 +880,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // further errors being emitted when using the bindings. #50333\n             let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &tcx.types.err, def_bm, discrim_span);\n+                self.check_pat(elem, &tcx.types.err, def_bm, ti);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n             for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, discrim_span);\n+                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, ti);\n             }\n             pat_ty\n         }\n@@ -891,7 +900,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> bool {\n         let tcx = self.tcx;\n \n@@ -941,7 +950,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat(&field.pat, field_ty, def_bm, discrim_span);\n+            self.check_pat(&field.pat, field_ty, def_bm, ti);\n         }\n \n         let mut unmentioned_fields = variant\n@@ -1118,7 +1127,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         inner: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, &inner) {\n@@ -1129,12 +1138,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 span: inner.span,\n             });\n             let box_ty = tcx.mk_box(inner_ty);\n-            self.demand_eqtype_pat(span, expected, box_ty, discrim_span);\n+            self.demand_eqtype_pat(span, expected, box_ty, ti);\n             (box_ty, inner_ty)\n         } else {\n             (tcx.types.err, tcx.types.err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        self.check_pat(&inner, inner_ty, def_bm, ti);\n         box_ty\n     }\n \n@@ -1145,7 +1154,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mutbl: hir::Mutability,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n@@ -1180,7 +1189,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             (tcx.types.err, tcx.types.err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        self.check_pat(&inner, inner_ty, def_bm, ti);\n         rptr_ty\n     }\n \n@@ -1209,7 +1218,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         after: &'tcx [&'tcx Pat<'tcx>],\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let err = self.tcx.types.err;\n         let expected = self.structurally_resolved_type(span, expected);\n@@ -1234,15 +1243,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Type check all the patterns before `slice`.\n         for elt in before {\n-            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&elt, inner_ty, def_bm, ti);\n         }\n         // Type check the `slice`, if present, against its expected type.\n         if let Some(slice) = slice {\n-            self.check_pat(&slice, slice_ty, def_bm, discrim_span);\n+            self.check_pat(&slice, slice_ty, def_bm, ti);\n         }\n         // Type check the elements after `slice`, if present.\n         for elt in after {\n-            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&elt, inner_ty, def_bm, ti);\n         }\n         expected\n     }"}, {"sha": "c78166f411d2855d8c3fb287720631bc7b7fe71c", "filename": "src/test/ui/destructure-trait-ref.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -44,7 +44,9 @@ error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:42:13\n    |\n LL |     let box box x = box 1isize as Box<dyn T>;\n-   |             ^^^^^ expected trait `T`, found struct `std::boxed::Box`\n+   |             ^^^^^   ------------------------ this expression has type `std::boxed::Box<dyn T>`\n+   |             |\n+   |             expected trait `T`, found struct `std::boxed::Box`\n    |\n    = note: expected trait object `dyn T`\n                     found struct `std::boxed::Box<_>`"}, {"sha": "76ae7241ff2771959a918eccf81ac291061ea71b", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -8,7 +8,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:13\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [_, 99.., _] => {},\n    |             ^^ expected struct `std::ops::Range`, found integer\n    |"}, {"sha": "5c96f8041feb26cf84ac88905d3518225d3e173e", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -14,7 +14,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:13\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [_, 99..] => {},\n    |             ^^ expected struct `std::ops::Range`, found integer\n    |"}, {"sha": "17e10324db18187df60dbbd0010c941f59070a18", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -8,7 +8,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:12\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |            ^ expected struct `std::ops::Range`, found integer\n    |\n@@ -19,7 +19,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:15\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |               ^^  --- this is of type `{integer}`\n    |               |\n@@ -32,7 +32,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:19\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |               --  ^^^ expected struct `std::ops::Range`, found integer\n    |               |"}, {"sha": "b3f0907b81d2595406b87aa7f099a2e02c35be0a", "filename": "src/test/ui/issues/issue-15896.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-15896.rs:11:11\n    |\n LL |     let u = match e {\n-   |                   - this expression has type `main::R`\n+   |                   - this expression has type `main::E`\n LL |         E::B(\n LL |           Tau{t: x},\n    |           ^^^^^^^^^ expected enum `main::R`, found struct `main::Tau`"}, {"sha": "6878600b0298338535d7e1dd7216e62e5be0a670", "filename": "src/test/ui/issues/issue-16338.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-16338.rs:7:9\n    |\n LL |     let Slice { data: data, len: len } = \"foo\";\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ----- this expression has type `str`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ----- this expression has type `&str`\n    |         |\n    |         expected `str`, found struct `Slice`\n    |"}, {"sha": "2306fb352738f80ef17a57d06ce6e1f8522f1e4c", "filename": "src/test/ui/mismatched_types/E0409.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -9,6 +9,8 @@ LL |         (0, ref y) | (y, 0) => {}\n error[E0308]: mismatched types\n   --> $DIR/E0409.rs:5:23\n    |\n+LL |     match x {\n+   |           - this expression has type `({integer}, {integer})`\n LL |         (0, ref y) | (y, 0) => {}\n    |                       ^ expected `&{integer}`, found integer\n "}, {"sha": "948c91370d0d41496df712a5588f239ab8457917", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -94,7 +94,9 @@ error[E0308]: mismatched types\n   --> $DIR/already-bound-name.rs:33:31\n    |\n LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n-   |                               ^ expected integer, found enum `E`\n+   |                               ^                    ------- this expression has type `E<E<{integer}>>`\n+   |                               |\n+   |                               expected integer, found enum `E`\n    |\n    = note: expected type `{integer}`\n               found type `E<{integer}>`"}, {"sha": "80d914b8d236cfefd7dd1ff12295e50220fc2b72", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -60,7 +60,9 @@ error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:13:25\n    |\n LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n-   |                         ^^^^^^^^^ types differ in mutability\n+   |                         ^^^^^^^^^                          ------ this expression has type `std::result::Result<&u8, &mut u8>`\n+   |                         |\n+   |                         types differ in mutability\n    |\n    = note: expected type `&&u8`\n               found type `&mut &mut u8`\n@@ -69,7 +71,9 @@ error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:16:31\n    |\n LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n-   |                               ^^^^^^^^^ types differ in mutability\n+   |                               ^^^^^^^^^            ----------- this expression has type `std::result::Result<({integer}, &{integer}), (_, _)>`\n+   |                               |\n+   |                               types differ in mutability\n    |\n    = note: expected type `&{integer}`\n               found type `&mut _`"}, {"sha": "bc288e06250751d914801818d0240c36253341cb", "filename": "src/test/ui/or-patterns/or-pattern-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/or-pattern-mismatch.rs:3:68\n    |\n LL | fn main() { match Blah::A(1, 1, 2) { Blah::A(_, x, y) | Blah::B(x, y) => { } } }\n-   |                                                                    ^ expected `usize`, found `isize`\n+   |                   ---------------- this expression has type `Blah` ^ expected `usize`, found `isize`\n \n error: aborting due to previous error\n "}, {"sha": "3fed64c191a8a2de52c518513935c66e64aa1cd6", "filename": "src/test/ui/parser/recover-range-pats.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -425,8 +425,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:23:16\n    |\n LL |     if let X.. .0 = 0 {}\n-   |            -   ^^ expected integer, found floating-point number\n-   |            |\n+   |            -   ^^   - this expression has type `u8`\n+   |            |   |\n+   |            |   expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n@@ -457,8 +458,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:36:16\n    |\n LL |     if let X..=.0 = 0 {}\n-   |            -   ^^ expected integer, found floating-point number\n-   |            |\n+   |            -   ^^   - this expression has type `u8`\n+   |            |   |\n+   |            |   expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n@@ -489,8 +491,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:52:17\n    |\n LL |     if let X... .0 = 0 {}\n-   |            -    ^^ expected integer, found floating-point number\n-   |            |\n+   |            -    ^^   - this expression has type `u8`\n+   |            |    |\n+   |            |    expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns"}, {"sha": "d57a8a0dbc1813ef299b788abad195e00215ac4c", "filename": "src/test/ui/pattern/pat-struct-field-expr-has-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/pat-struct-field-expr-has-type.rs:7:16\n    |\n LL |     match (S { f: 42 }) {\n-   |           ------------- this expression has type `u8`\n+   |           ------------- this expression has type `S`\n LL |         S { f: Ok(_) } => {}\n    |                ^^^^^ expected `u8`, found enum `std::result::Result`\n    |"}, {"sha": "15425da69bcc48595ddf2221f181ae5aa6c4d812", "filename": "src/test/ui/pattern/pattern-tyvar.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/pattern-tyvar.rs:5:18\n    |\n LL |     match t {\n-   |           - this expression has type `std::option::Option<std::vec::Vec<isize>>`\n+   |           - this expression has type `Bar`\n LL |       Bar::T1(_, Some::<isize>(x)) => {\n    |                  ^^^^^^^^^^^^^^^^ expected struct `std::vec::Vec`, found `isize`\n    |"}, {"sha": "61d1001ce9154f154e0665d3b26b9c3a653a7ecd", "filename": "src/test/ui/resolve/resolve-inconsistent-binding-mode.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -23,18 +23,24 @@ LL |       Opts::A(ref mut i) | Opts::B(ref i) => {}\n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:7:32\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n    |                                ^ expected `&isize`, found `isize`\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:16:32\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n    |                                ^ expected `&isize`, found `isize`\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:25:36\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref mut i) | Opts::B(ref i) => {}\n    |                                    ^^^^^ types differ in mutability\n    |"}, {"sha": "5c87f7c684f3b0695c6c4b63f76e80a8cc2ae398", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -86,6 +86,8 @@ LL |         (CONST1, _) | (_, Const2) => ()\n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-names.rs:19:19\n    |\n+LL |     match x {\n+   |           - this expression has type `(E, E)`\n LL |         (A, B) | (ref B, c) | (c, A) => ()\n    |                   ^^^^^ expected enum `E`, found `&E`\n "}, {"sha": "7170adca60dc345b4c6516512a59d687ed7e3340", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7e2f3aee5508538c5de14211ab5b31362e1164a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=d7e2f3aee5508538c5de14211ab5b31362e1164a", "patch": "@@ -697,7 +697,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:86:12\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `bool`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n    |            |\n    |            expected `bool`, found struct `std::ops::Range`\n    |\n@@ -885,7 +885,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:150:15\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `bool`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n    |               |\n    |               expected `bool`, found struct `std::ops::Range`\n    |"}]}