{"sha": "5de9f47e49200f1e9e367144d184446ddde9105b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZTlmNDdlNDkyMDBmMWU5ZTM2NzE0NGQxODQ0NDZkZGRlOTEwNWI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-31T00:59:09Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-01T03:50:26Z"}, "message": "rustc: unbox closures used in function arguments", "tree": {"sha": "a7a1d53a8ca89dd97404329c0c3a3abcfc2b3069", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7a1d53a8ca89dd97404329c0c3a3abcfc2b3069"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5de9f47e49200f1e9e367144d184446ddde9105b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5de9f47e49200f1e9e367144d184446ddde9105b", "html_url": "https://github.com/rust-lang/rust/commit/5de9f47e49200f1e9e367144d184446ddde9105b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5de9f47e49200f1e9e367144d184446ddde9105b/comments", "author": null, "committer": null, "parents": [{"sha": "70ce68eed4f81ff90cf3710e3fdb7b04de71a388", "url": "https://api.github.com/repos/rust-lang/rust/commits/70ce68eed4f81ff90cf3710e3fdb7b04de71a388", "html_url": "https://github.com/rust-lang/rust/commit/70ce68eed4f81ff90cf3710e3fdb7b04de71a388"}], "stats": {"total": 112, "additions": 59, "deletions": 53}, "files": [{"sha": "580b3a93d73974dbf82691424bff0b0ea4e3c387", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5de9f47e49200f1e9e367144d184446ddde9105b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de9f47e49200f1e9e367144d184446ddde9105b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5de9f47e49200f1e9e367144d184446ddde9105b", "patch": "@@ -1122,11 +1122,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         })\n     }\n \n-    // FIXME(#19596) unbox `op`\n-    pub fn cat_pattern(&self,\n-                       cmt: cmt<'tcx>,\n-                       pat: &ast::Pat,\n-                       op: |&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat|)\n+    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) where\n+        F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+    {\n+        self.cat_pattern_(cmt, pat, &mut op)\n+    }\n+\n+    // FIXME(#19596) This is a workaround, but there should be a better way to do this\n+    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F) where\n+        F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1177,7 +1181,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                pat.id, pprust::pat_to_string(pat),\n                cmt.repr(self.tcx()));\n \n-        op(self, cmt.clone(), pat);\n+        (*op)(self, cmt.clone(), pat);\n \n         let def_map = self.tcx().def_map.borrow();\n         let opt_def = def_map.get(&pat.id);\n@@ -1214,7 +1218,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z));\n+                        self.cat_pattern_(subcmt, &**subpat, op);\n                     }\n                 }\n                 Some(&def::DefStruct(..)) => {\n@@ -1224,13 +1228,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern(cmt_field, &**subpat,\n-                                         |x,y,z| op(x,y,z));\n+                        self.cat_pattern_(cmt_field, &**subpat, op);\n                     }\n                 }\n                 Some(&def::DefConst(..)) => {\n                     for subpat in subpats.iter() {\n-                        self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z));\n+                        self.cat_pattern_(cmt.clone(), &**subpat, op);\n                     }\n                 }\n                 _ => {\n@@ -1242,7 +1245,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatIdent(_, _, Some(ref subpat)) => {\n-              self.cat_pattern(cmt, &**subpat, op);\n+              self.cat_pattern_(cmt, &**subpat, op);\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -1254,7 +1257,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             for fp in field_pats.iter() {\n                 let field_ty = self.pat_ty(&*fp.node.pat); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n-                self.cat_pattern(cmt_field, &*fp.node.pat, |x,y,z| op(x,y,z));\n+                self.cat_pattern_(cmt_field, &*fp.node.pat, op);\n             }\n           }\n \n@@ -1266,29 +1269,28 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z));\n+                self.cat_pattern_(subcmt, &**subpat, op);\n             }\n           }\n \n           ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n             // @p1, ~p1, ref p1\n             let subcmt = self.cat_deref(pat, cmt, 0, false);\n-            self.cat_pattern(subcmt, &**subpat, op);\n+            self.cat_pattern_(subcmt, &**subpat, op);\n           }\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n               for before_pat in before.iter() {\n-                  self.cat_pattern(elt_cmt.clone(), &**before_pat,\n-                                   |x,y,z| op(x,y,z));\n+                  self.cat_pattern_(elt_cmt.clone(), &**before_pat, op);\n               }\n               for slice_pat in slice.iter() {\n                   let slice_ty = self.pat_ty(&**slice_pat);\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  self.cat_pattern(slice_cmt, &**slice_pat, |x,y,z| op(x,y,z));\n+                  self.cat_pattern_(slice_cmt, &**slice_pat, op);\n               }\n               for after_pat in after.iter() {\n-                  self.cat_pattern(elt_cmt.clone(), &**after_pat, |x,y,z| op(x,y,z));\n+                  self.cat_pattern_(elt_cmt.clone(), &**after_pat, op);\n               }\n           }\n "}, {"sha": "ba52266e52d1801cb96007fed6824b2f8ffffc1a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5de9f47e49200f1e9e367144d184446ddde9105b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de9f47e49200f1e9e367144d184446ddde9105b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5de9f47e49200f1e9e367144d184446ddde9105b", "patch": "@@ -2812,49 +2812,53 @@ pub fn walk_ty<'tcx, F>(ty: Ty<'tcx>, mut f: F) where\n     maybe_walk_ty(ty, |ty| { f(ty); true });\n }\n \n-// FIXME(#19596) unbox `f`\n-pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n-    if !f(ty) {\n-        return;\n-    }\n-    match ty.sty {\n-        ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n-        ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n-        ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n-            maybe_walk_ty(tm.ty, f);\n+pub fn maybe_walk_ty<'tcx, F>(ty: Ty<'tcx>, mut f: F) where F: FnMut(Ty<'tcx>) -> bool {\n+    // FIXME(#19596) This is a workaround, but there should be a better way to do this\n+    fn maybe_walk_ty_<'tcx, F>(ty: Ty<'tcx>, f: &mut F) where F: FnMut(Ty<'tcx>) -> bool {\n+        if !(*f)(ty) {\n+            return;\n         }\n-        ty_trait(box TyTrait { ref principal, .. }) => {\n-            for subty in principal.0.substs.types.iter() {\n-                maybe_walk_ty(*subty, |x| f(x));\n+        match ty.sty {\n+            ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n+            ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty_(ty, f),\n+            ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n+                maybe_walk_ty_(tm.ty, f);\n+            }\n+            ty_trait(box TyTrait { ref principal, .. }) => {\n+                for subty in principal.0.substs.types.iter() {\n+                    maybe_walk_ty_(*subty, f);\n+                }\n             }\n-        }\n-        ty_projection(ProjectionTy { ref trait_ref, .. }) => {\n-            for subty in trait_ref.substs.types.iter() {\n-                maybe_walk_ty(*subty, |x| f(x));\n+            ty_projection(ProjectionTy { ref trait_ref, .. }) => {\n+                for subty in trait_ref.substs.types.iter() {\n+                    maybe_walk_ty_(*subty, f);\n+                }\n             }\n-        }\n-        ty_enum(_, ref substs) |\n-        ty_struct(_, ref substs) |\n-        ty_unboxed_closure(_, _, ref substs) => {\n-            for subty in substs.types.iter() {\n-                maybe_walk_ty(*subty, |x| f(x));\n+            ty_enum(_, ref substs) |\n+            ty_struct(_, ref substs) |\n+            ty_unboxed_closure(_, _, ref substs) => {\n+                for subty in substs.types.iter() {\n+                    maybe_walk_ty_(*subty, f);\n+                }\n             }\n-        }\n-        ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n-        ty_bare_fn(_, ref ft) => {\n-            for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            if let ty::FnConverging(output) = ft.sig.0.output {\n-                maybe_walk_ty(output, f);\n+            ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty_(*tt, f); } }\n+            ty_bare_fn(_, ref ft) => {\n+                for a in ft.sig.0.inputs.iter() { maybe_walk_ty_(*a, f); }\n+                if let ty::FnConverging(output) = ft.sig.0.output {\n+                    maybe_walk_ty_(output, f);\n+                }\n             }\n-        }\n-        ty_closure(ref ft) => {\n-            for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            if let ty::FnConverging(output) = ft.sig.0.output {\n-                maybe_walk_ty(output, f);\n+            ty_closure(ref ft) => {\n+                for a in ft.sig.0.inputs.iter() { maybe_walk_ty_(*a, f); }\n+                if let ty::FnConverging(output) = ft.sig.0.output {\n+                    maybe_walk_ty_(output, f);\n+                }\n             }\n         }\n     }\n+\n+    maybe_walk_ty_(ty, &mut f);\n }\n \n // Folds types from the bottom up."}]}