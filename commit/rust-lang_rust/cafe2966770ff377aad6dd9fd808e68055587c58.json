{"sha": "cafe2966770ff377aad6dd9fd808e68055587c58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZmUyOTY2NzcwZmYzNzdhYWQ2ZGQ5ZmQ4MDhlNjgwNTU1ODdjNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-09T10:51:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-09T10:51:49Z"}, "message": "auto merge of #19249 : barosl/rust/json-type-safety, r=alexcrichton\n\nThis pull request tries to improve type safety of `serialize::json::Encoder`.\r\n\r\nLooking at #18319, I decided to test some JSON implementations in other languages. The results are as follows:\r\n\r\n* Encoding to JSON\r\n\r\n| Language | 111111111111111111 | 1.0 |\r\n| --- | --- | --- |\r\n| JavaScript\u2122 | \"111111111111111100\" | \"1\" |\r\n| Python | \"111111111111111111\" | **\"1.0\"** |\r\n| Go | \"111111111111111111\" | \"1\" |\r\n| Haskell | \"111111111111111111\" | \"1\" |\r\n| Rust | **\"111111111111111104\"** | \"1\" |\r\n\r\n* Decoding from JSON\r\n\r\n| Language | \"1\" | \"1.0\" | \"1.6\" |\r\n| --- | --- | --- | --- |\r\n| JavaScript\u2122 | 1 (Number) | 1 (Number) | 1.6 (Number) |\r\n| Python | 1 (int) | 1.0 (float) | 1.6 (float) |\r\n| Go | **1 (float64)** | 1 (float64) | 1.6 (float64) |\r\n| Go (expecting `int`) | 1 (int) | **error** | error |\r\n| Haskell (with `:: Int`) | 1 (Int) | 1 (Int) | **2 (Int)** |\r\n| Haskell (with `:: Double`) | 1.0 (Double) | 1.0 (Double) | 1.6 (Double) |\r\n| Rust (with `::<int>`) | 1 (int) | 1 (Int) | **1 (Int)** |\r\n| Rust (with `::<f64>`) | 1 (f64) | 1 (f64) | 1.6 (f64) |\r\n\r\n* The tests on Haskell were done using the [json](http://hackage.haskell.org/package/json) package.\r\n* The error message printed by Go was: `cannot unmarshal number 1.0 into Go value of type int`\r\n\r\nAs you see, there is no uniform behavior. Every implementation follows its own principle. So I think it is reasonable to find a desirable set of behaviors for Rust.\r\n\r\nFirstly, every implementation except the one for JavaScript is capable of handling `i64` values. It is even practical, because [Twitter API uses an i64 number to represent a tweet ID](https://dev.twitter.com/overview/api/twitter-ids-json-and-snowflake), although it is recommended to use the string version of the ID.\r\n\r\nSecondly, looking into the Go's behavior, implicit type conversion is not allowed in their decoder. If the user expects an integer value to follow, decoding a float value will raise an error. This behavior is desirable in Rust, because we are pleased to follow the principles of strong typing.\r\n\r\nThirdly, Python's JSON module forces a decimal point to be printed even if the fractional part does not exist. This eases the distinction of a float value from an integer value in JSON, because by the spec there is only one type to represent numbers, `Number`.\r\n\r\nSo, I suggest the following three breaking changes:\r\n\r\n1. Remove float preprocessing in serialize::json::Encoder\r\n\r\n `serialize::json::Encoder` currently uses `f64` to emit any integral type. This is possibly due to the behavior of JavaScript, which uses `f64` to represent any numeric value.\r\n\r\n This leads to a problem that only the integers in the range of [-2^53+1, 2^53-1] can be encoded. Therefore, `i64` and `u64` cannot be used reliably in the current implementation.\r\n\r\n [RFC 7159](http://tools.ietf.org/html/rfc7159) suggests that good interoperability can be achieved if the range is respected by implementations. However, it also says that implementations are allowed to set the range of number accepted. And it seems that the JSON encoders outside of the JavaScript world usually make use of `i64` values.\r\n\r\n This commit removes the float preprocessing done in the `emit_*` methods. It also increases performance, because transforming `f64` into String costs more than that of an integral type.\r\n\r\n Fixes #18319\r\n\r\n2. Do not coerce to integer when decoding a float value\r\n\r\n When an integral value is expected by the user but a fractional value is found, the current implementation uses `std::num::cast()` to coerce to an integer type, losing the fractional part. This behavior is not desirable because the number loses precision without notice.\r\n\r\n This commit makes it raise `ExpectedError` when such a situation arises.\r\n\r\n3. Always use a decimal point when emitting a float value\r\n\r\n JSON doesn't distinguish between integer and float. They are just numbers. Also, in the current implementation, a fractional number without the fractional part is encoded without a decimal point.\r\n\r\n Thereforce, when the value is decoded, it is first rendered as `Json`, either `I64` or `U64`. This reduces type safety, because while the original intention was to cast the value to float, it can also be casted to integer.\r\n\r\n As a workaround of this problem, this commit makes the encoder always emit a decimal point even if it is not necessary. If the fractional part of a float number is zero, \".0\" is padded to the end of the result.", "tree": {"sha": "564c1cafc953fe7629d3d0dcbc10322d0885b196", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/564c1cafc953fe7629d3d0dcbc10322d0885b196"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cafe2966770ff377aad6dd9fd808e68055587c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cafe2966770ff377aad6dd9fd808e68055587c58", "html_url": "https://github.com/rust-lang/rust/commit/cafe2966770ff377aad6dd9fd808e68055587c58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cafe2966770ff377aad6dd9fd808e68055587c58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c56e59c722ac5de216ec70f0d1834963ae197ddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c56e59c722ac5de216ec70f0d1834963ae197ddb", "html_url": "https://github.com/rust-lang/rust/commit/c56e59c722ac5de216ec70f0d1834963ae197ddb"}, {"sha": "7176dd1c9039d7d10c0ceb694b929d094cc299e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7176dd1c9039d7d10c0ceb694b929d094cc299e3", "html_url": "https://github.com/rust-lang/rust/commit/7176dd1c9039d7d10c0ceb694b929d094cc299e3"}], "stats": {"total": 338, "additions": 169, "deletions": 169}, "files": [{"sha": "d28bd1b9df040bd912fc3c84739d549b9e8d060c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 169, "deletions": 169, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/cafe2966770ff377aad6dd9fd808e68055587c58/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafe2966770ff377aad6dd9fd808e68055587c58/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=cafe2966770ff377aad6dd9fd808e68055587c58", "patch": "@@ -91,7 +91,7 @@\n //! fn main() {\n //!     let object = TestStruct {\n //!         data_int: 1,\n-//!         data_str: \"toto\".to_string(),\n+//!         data_str: \"homura\".to_string(),\n //!         data_vector: vec![2,3,4,5],\n //!     };\n //!\n@@ -178,7 +178,7 @@\n //!     // Serialize using `ToJson`\n //!     let input_data = TestStruct {\n //!         data_int: 1,\n-//!         data_str: \"toto\".to_string(),\n+//!         data_str: \"madoka\".to_string(),\n //!         data_vector: vec![2,3,4,5],\n //!     };\n //!     let json_obj: Json = input_data.to_json();\n@@ -390,7 +390,8 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n         FPNaN | FPInfinite => string::String::from_str(\"null\"),\n-        _ => f64::to_str_digits(v, 6u)\n+        _ if v.fract() != 0f64 => f64::to_str_digits(v, 6u),\n+        _ => f64::to_str_digits(v, 6u) + \".0\",\n     }\n }\n \n@@ -423,17 +424,17 @@ impl<'a> Encoder<'a> {\n impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult  { self.emit_f64(v as f64) }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult  { self.emit_f64(v as f64) }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n@@ -446,7 +447,9 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n         write!(self.writer, \"{}\", fmt_number_or_null(v))\n     }\n-    fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n+        self.emit_f64(v as f64)\n+    }\n \n     fn emit_char(&mut self, v: char) -> EncodeResult {\n         escape_char(self.writer, v)\n@@ -455,7 +458,9 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         escape_str(self.writer, v)\n     }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum(&mut self,\n+                 _name: &str,\n+                 f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         f(self)\n     }\n \n@@ -624,17 +629,17 @@ impl<'a> PrettyEncoder<'a> {\n impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n@@ -666,7 +671,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n-                         _: uint,\n+                         _id: uint,\n                          cnt: uint,\n                          f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if cnt == 0 {\n@@ -1946,7 +1951,7 @@ macro_rules! expect(\n     ($e:expr, Null) => ({\n         match $e {\n             Json::Null => Ok(()),\n-            other => Err(ExpectedError(\"Null\".to_string(),\n+            other => Err(ExpectedError(\"Null\".into_string(),\n                                        format!(\"{}\", other)))\n         }\n     });\n@@ -1965,33 +1970,22 @@ macro_rules! read_primitive {\n     ($name:ident, $ty:ty) => {\n         fn $name(&mut self) -> DecodeResult<$ty> {\n             match self.pop() {\n-                Json::I64(f) => {\n-                    match num::cast(f) {\n-                        Some(f) => Ok(f),\n-                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                    }\n-                }\n-                Json::U64(f) => {\n-                    match num::cast(f) {\n-                        Some(f) => Ok(f),\n-                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                    }\n-                }\n-                Json::F64(f) => {\n-                    match num::cast(f) {\n-                        Some(f) => Ok(f),\n-                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                    }\n-                }\n-                Json::String(s) => {\n-                    // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n-                    // is going to have a string here, as per JSON spec.\n-                    match std::str::from_str(s.as_slice()) {\n-                        Some(f) => Ok(f),\n-                        None => Err(ExpectedError(\"Number\".to_string(), s)),\n-                    }\n+                Json::I64(f) => match num::cast(f) {\n+                    Some(f) => Ok(f),\n+                    None => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", f))),\n                 },\n-                value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n+                Json::U64(f) => match num::cast(f) {\n+                    Some(f) => Ok(f),\n+                    None => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", f))),\n+                },\n+                Json::F64(f) => Err(ExpectedError(\"Integer\".into_string(), format!(\"{}\", f))),\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // is going to have a string here, as per JSON spec.\n+                Json::String(s) => match std::str::from_str(s.as_slice()) {\n+                    Some(f) => Ok(f),\n+                    None => Err(ExpectedError(\"Number\".into_string(), s)),\n+                },\n+                value => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", value))),\n             }\n         }\n     }\n@@ -2027,11 +2021,11 @@ impl ::Decoder<DecoderError> for Decoder {\n                 // is going to have a string here, as per JSON spec.\n                 match std::str::from_str(s.as_slice()) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), s)),\n+                    None => Err(ExpectedError(\"Number\".into_string(), s)),\n                 }\n             },\n             Json::Null => Ok(f64::NAN),\n-            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n+            value => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", value)))\n         }\n     }\n \n@@ -2050,7 +2044,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".into_string(), format!(\"{}\", s)))\n     }\n \n     fn read_str(&mut self) -> DecodeResult<string::String> {\n@@ -2073,32 +2067,32 @@ impl ::Decoder<DecoderError> for Decoder {\n         let name = match self.pop() {\n             Json::String(s) => s,\n             Json::Object(mut o) => {\n-                let n = match o.remove(&\"variant\".to_string()) {\n+                let n = match o.remove(&\"variant\".into_string()) {\n                     Some(Json::String(s)) => s,\n                     Some(val) => {\n-                        return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"String\".into_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"variant\".to_string()))\n+                        return Err(MissingFieldError(\"variant\".into_string()))\n                     }\n                 };\n-                match o.remove(&\"fields\".to_string()) {\n+                match o.remove(&\"fields\".into_string()) {\n                     Some(Json::Array(l)) => {\n                         for field in l.into_iter().rev() {\n                             self.stack.push(field);\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"Array\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"Array\".into_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"fields\".to_string()))\n+                        return Err(MissingFieldError(\"fields\".into_string()))\n                     }\n                 }\n                 n\n             }\n             json => {\n-                return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n+                return Err(ExpectedError(\"String or Object\".into_string(), format!(\"{}\", json)))\n             }\n         };\n         let idx = match names.iter()\n@@ -2447,9 +2441,9 @@ mod tests {\n     #[test]\n     fn test_decode_option_malformed() {\n         check_err::<OptionData>(\"{ \\\"opt\\\": [] }\",\n-                                ExpectedError(\"Number\".to_string(), \"[]\".to_string()));\n+                                ExpectedError(\"Number\".into_string(), \"[]\".into_string()));\n         check_err::<OptionData>(\"{ \\\"opt\\\": false }\",\n-                                ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n+                                ExpectedError(\"Number\".into_string(), \"false\".into_string()));\n     }\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n@@ -2490,72 +2484,75 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert_eq!(Null.to_string().into_string(), \"null\");\n-        assert_eq!(Null.to_pretty_str().into_string(), \"null\");\n+        assert_eq!(Null.to_string(), \"null\");\n+        assert_eq!(Null.to_pretty_str(), \"null\");\n     }\n \n     #[test]\n     fn test_write_i64() {\n-        assert_eq!(U64(0).to_string().into_string(), \"0\");\n-        assert_eq!(U64(0).to_pretty_str().into_string(), \"0\");\n+        assert_eq!(U64(0).to_string(), \"0\");\n+        assert_eq!(U64(0).to_pretty_str(), \"0\");\n \n-        assert_eq!(U64(1234).to_string().into_string(), \"1234\");\n-        assert_eq!(U64(1234).to_pretty_str().into_string(), \"1234\");\n+        assert_eq!(U64(1234).to_string(), \"1234\");\n+        assert_eq!(U64(1234).to_pretty_str(), \"1234\");\n \n-        assert_eq!(I64(-5678).to_string().into_string(), \"-5678\");\n-        assert_eq!(I64(-5678).to_pretty_str().into_string(), \"-5678\");\n+        assert_eq!(I64(-5678).to_string(), \"-5678\");\n+        assert_eq!(I64(-5678).to_pretty_str(), \"-5678\");\n+\n+        assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n+        assert_eq!(U64(7650007200025252000).to_pretty_str(), \"7650007200025252000\");\n     }\n \n     #[test]\n     fn test_write_f64() {\n-        assert_eq!(F64(3.0).to_string().into_string(), \"3\");\n-        assert_eq!(F64(3.0).to_pretty_str().into_string(), \"3\");\n+        assert_eq!(F64(3.0).to_string(), \"3.0\");\n+        assert_eq!(F64(3.0).to_pretty_str(), \"3.0\");\n \n-        assert_eq!(F64(3.1).to_string().into_string(), \"3.1\");\n-        assert_eq!(F64(3.1).to_pretty_str().into_string(), \"3.1\");\n+        assert_eq!(F64(3.1).to_string(), \"3.1\");\n+        assert_eq!(F64(3.1).to_pretty_str(), \"3.1\");\n \n-        assert_eq!(F64(-1.5).to_string().into_string(), \"-1.5\");\n-        assert_eq!(F64(-1.5).to_pretty_str().into_string(), \"-1.5\");\n+        assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n+        assert_eq!(F64(-1.5).to_pretty_str(), \"-1.5\");\n \n-        assert_eq!(F64(0.5).to_string().into_string(), \"0.5\");\n-        assert_eq!(F64(0.5).to_pretty_str().into_string(), \"0.5\");\n+        assert_eq!(F64(0.5).to_string(), \"0.5\");\n+        assert_eq!(F64(0.5).to_pretty_str(), \"0.5\");\n \n-        assert_eq!(F64(f64::NAN).to_string().into_string(), \"null\");\n-        assert_eq!(F64(f64::NAN).to_pretty_str().into_string(), \"null\");\n+        assert_eq!(F64(f64::NAN).to_string(), \"null\");\n+        assert_eq!(F64(f64::NAN).to_pretty_str(), \"null\");\n \n-        assert_eq!(F64(f64::INFINITY).to_string().into_string(), \"null\");\n-        assert_eq!(F64(f64::INFINITY).to_pretty_str().into_string(), \"null\");\n+        assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n+        assert_eq!(F64(f64::INFINITY).to_pretty_str(), \"null\");\n \n-        assert_eq!(F64(f64::NEG_INFINITY).to_string().into_string(), \"null\");\n-        assert_eq!(F64(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\");\n+        assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n+        assert_eq!(F64(f64::NEG_INFINITY).to_pretty_str(), \"null\");\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(\"\".to_string()).to_string().into_string(), \"\\\"\\\"\");\n-        assert_eq!(String(\"\".to_string()).to_pretty_str().into_string(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".into_string()).to_string(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".into_string()).to_pretty_str(), \"\\\"\\\"\");\n \n-        assert_eq!(String(\"foo\".to_string()).to_string().into_string(), \"\\\"foo\\\"\");\n-        assert_eq!(String(\"foo\".to_string()).to_pretty_str().into_string(), \"\\\"foo\\\"\");\n+        assert_eq!(String(\"homura\".into_string()).to_string(), \"\\\"homura\\\"\");\n+        assert_eq!(String(\"madoka\".into_string()).to_pretty_str(), \"\\\"madoka\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_string().into_string(), \"true\");\n-        assert_eq!(Boolean(true).to_pretty_str().into_string(), \"true\");\n+        assert_eq!(Boolean(true).to_string(), \"true\");\n+        assert_eq!(Boolean(true).to_pretty_str(), \"true\");\n \n-        assert_eq!(Boolean(false).to_string().into_string(), \"false\");\n-        assert_eq!(Boolean(false).to_pretty_str().into_string(), \"false\");\n+        assert_eq!(Boolean(false).to_string(), \"false\");\n+        assert_eq!(Boolean(false).to_pretty_str(), \"false\");\n     }\n \n     #[test]\n     fn test_write_array() {\n-        assert_eq!(Array(vec![]).to_string().into_string(), \"[]\");\n-        assert_eq!(Array(vec![]).to_pretty_str().into_string(), \"[]\");\n+        assert_eq!(Array(vec![]).to_string(), \"[]\");\n+        assert_eq!(Array(vec![]).to_pretty_str(), \"[]\");\n \n-        assert_eq!(Array(vec![Boolean(true)]).to_string().into_string(), \"[true]\");\n+        assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n         assert_eq!(\n-            Array(vec![Boolean(true)]).to_pretty_str().into_string(),\n+            Array(vec![Boolean(true)]).to_pretty_str(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n@@ -2565,12 +2562,12 @@ mod tests {\n         let long_test_array = Array(vec![\n             Boolean(false),\n             Null,\n-            Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n+            Array(vec![String(\"foo\\nbar\".into_string()), F64(3.5)])]);\n \n-        assert_eq!(long_test_array.to_string().into_string(),\n+        assert_eq!(long_test_array.to_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n         assert_eq!(\n-            long_test_array.to_pretty_str().into_string(),\n+            long_test_array.to_pretty_str(),\n             \"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -2585,32 +2582,32 @@ mod tests {\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(mk_object(&[]).to_string().into_string(), \"{}\");\n-        assert_eq!(mk_object(&[]).to_pretty_str().into_string(), \"{}\");\n+        assert_eq!(mk_object(&[]).to_string(), \"{}\");\n+        assert_eq!(mk_object(&[]).to_pretty_str(), \"{}\");\n \n         assert_eq!(\n             mk_object(&[\n-                (\"a\".to_string(), Boolean(true))\n-            ]).to_string().into_string(),\n+                (\"a\".into_string(), Boolean(true))\n+            ]).to_string(),\n             \"{\\\"a\\\":true}\"\n         );\n         assert_eq!(\n-            mk_object(&[(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n+            mk_object(&[(\"a\".into_string(), Boolean(true))]).to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n             }\"\n         );\n \n         let complex_obj = mk_object(&[\n-                (\"b\".to_string(), Array(vec![\n-                    mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                    mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n+                (\"b\".into_string(), Array(vec![\n+                    mk_object(&[(\"c\".into_string(), String(\"\\x0c\\r\".into_string()))]),\n+                    mk_object(&[(\"d\".into_string(), String(\"\".into_string()))])\n                 ]))\n             ]);\n \n         assert_eq!(\n-            complex_obj.to_string().into_string(),\n+            complex_obj.to_string(),\n             \"{\\\n                 \\\"b\\\":[\\\n                     {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n@@ -2619,7 +2616,7 @@ mod tests {\n             }\"\n         );\n         assert_eq!(\n-            complex_obj.to_pretty_str().into_string(),\n+            complex_obj.to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"b\\\": [\\n    \\\n@@ -2634,10 +2631,10 @@ mod tests {\n         );\n \n         let a = mk_object(&[\n-            (\"a\".to_string(), Boolean(true)),\n-            (\"b\".to_string(), Array(vec![\n-                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n+            (\"a\".into_string(), Boolean(true)),\n+            (\"b\".into_string(), Array(vec![\n+                mk_object(&[(\"c\".into_string(), String(\"\\x0c\\r\".into_string()))]),\n+                mk_object(&[(\"d\".into_string(), String(\"\".into_string()))])\n             ]))\n         ]);\n \n@@ -2674,7 +2671,7 @@ mod tests {\n             \"\\\"Dog\\\"\"\n         );\n \n-        let animal = Frog(\"Henry\".to_string(), 349);\n+        let animal = Frog(\"Henry\".into_string(), 349);\n         assert_eq!(\n             with_str_writer(|writer| {\n                 let mut encoder = Encoder::new(writer);\n@@ -2699,14 +2696,14 @@ mod tests {\n \n     #[test]\n     fn test_write_some() {\n-        let value = Some(\"jodhpurs\".to_string());\n+        let value = Some(\"jodhpurs\".into_string());\n         let s = with_str_writer(|writer| {\n             let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"\\\"jodhpurs\\\"\");\n \n-        let value = Some(\"jodhpurs\".to_string());\n+        let value = Some(\"jodhpurs\".into_string());\n         let s = with_str_writer(|writer| {\n             let mut encoder = PrettyEncoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n@@ -2831,23 +2828,26 @@ mod tests {\n \n         let v: i64 = super::decode(\"9223372036854775807\").unwrap();\n         assert_eq!(v, i64::MAX);\n+\n+        let res: DecodeResult<i64> = super::decode(\"765.25252\");\n+        assert_eq!(res, Err(ExpectedError(\"Integer\".into_string(), \"765.25252\".into_string())));\n     }\n \n     #[test]\n     fn test_read_str() {\n         assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n         assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n \n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".into_string())));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".into_string())));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".into_string())));\n     }\n \n     #[test]\n@@ -2913,7 +2913,7 @@ mod tests {\n         assert_eq!(t, (1u, 2, 3))\n \n         let t: (uint, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n-        assert_eq!(t, (1u, \"two\".to_string()));\n+        assert_eq!(t, (1u, \"two\".into_string()));\n     }\n \n     #[test]\n@@ -2943,22 +2943,22 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object(&[(\"a\".to_string(), U64(3))]));\n+                  mk_object(&[(\"a\".into_string(), U64(3))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".to_string(), Null),\n-                      (\"b\".to_string(), Boolean(true))]));\n+                      (\"a\".into_string(), Null),\n+                      (\"b\".into_string(), Boolean(true))]));\n         assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".to_string(), Null),\n-                      (\"b\".to_string(), Boolean(true))]));\n+                      (\"a\".into_string(), Null),\n+                      (\"b\".into_string(), Boolean(true))]));\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), Array(vec![Boolean(true)]))\n+                      (\"a\".into_string(), F64(1.0)),\n+                      (\"b\".into_string(), Array(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n                       \"{\\\n@@ -2970,12 +2970,12 @@ mod tests {\n                           ]\\\n                       }\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), Array(vec![\n+                      (\"a\".into_string(), F64(1.0)),\n+                      (\"b\".into_string(), Array(vec![\n                           Boolean(true),\n-                          String(\"foo\\nbar\".to_string()),\n+                          String(\"foo\\nbar\".into_string()),\n                           mk_object(&[\n-                              (\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))\n+                              (\"c\".into_string(), mk_object(&[(\"d\".into_string(), Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -2994,7 +2994,7 @@ mod tests {\n             v,\n             Outer {\n                 inner: vec![\n-                    Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n+                    Inner { a: (), b: 2, c: vec![\"abc\".into_string(), \"xyz\".into_string()] }\n                 ]\n             }\n         );\n@@ -3020,7 +3020,7 @@ mod tests {\n         assert_eq!(value, None);\n \n         let value: Option<string::String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n-        assert_eq!(value, Some(\"jodhpurs\".to_string()));\n+        assert_eq!(value, Some(\"jodhpurs\".into_string()));\n     }\n \n     #[test]\n@@ -3030,7 +3030,7 @@ mod tests {\n \n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n         let value: Animal = super::decode(s).unwrap();\n-        assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n+        assert_eq!(value, Frog(\"Henry\".into_string(), 349));\n     }\n \n     #[test]\n@@ -3039,8 +3039,8 @@ mod tests {\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut map: TreeMap<string::String, Animal> = super::decode(s).unwrap();\n \n-        assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n-        assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n+        assert_eq!(map.remove(&\"a\".into_string()), Some(Dog));\n+        assert_eq!(map.remove(&\"b\".into_string()), Some(Frog(\"Henry\".into_string(), 349)));\n     }\n \n     #[test]\n@@ -3080,30 +3080,30 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n+        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".into_string(), \"[]\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Number\".to_string(), \"true\".to_string()));\n+                                  ExpectedError(\"Number\".into_string(), \"true\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()));\n+                                  ExpectedError(\"Boolean\".into_string(), \"[]\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n+                                  ExpectedError(\"String\".into_string(), \"{}\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n+                                  ExpectedError(\"Array\".into_string(), \"null\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(\"w\".to_string()));\n+                                  MissingFieldError(\"w\".into_string()));\n     }\n     #[test]\n     fn test_decode_errors_enum() {\n         check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(\"variant\".to_string()));\n+                                MissingFieldError(\"variant\".into_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(\"String\".to_string(), \"1\".to_string()));\n+                                ExpectedError(\"String\".into_string(), \"1\".into_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(\"fields\".to_string()));\n+                                MissingFieldError(\"fields\".into_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n+                                ExpectedError(\"Array\".into_string(), \"null\".into_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(\"C\".to_string()));\n+                                UnknownVariantError(\"C\".into_string()));\n     }\n \n     #[test]\n@@ -3388,7 +3388,7 @@ mod tests {\n         };\n         let mut decoder = Decoder::new(json_obj);\n         let result: Result<HashMap<uint, bool>, DecoderError> = Decodable::decode(&mut decoder);\n-        assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n+        assert_eq!(result, Err(ExpectedError(\"Number\".into_string(), \"a\".into_string())));\n     }\n \n     fn assert_stream_equal(src: &str,\n@@ -3415,7 +3415,7 @@ mod tests {\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n             vec![\n                 (ObjectStart,             vec![]),\n-                  (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n+                  (StringValue(\"bar\".into_string()),   vec![Key(\"foo\")]),\n                   (ArrayStart,            vec![Key(\"array\")]),\n                     (U64Value(0),         vec![Key(\"array\"), Index(0)]),\n                     (U64Value(1),         vec![Key(\"array\"), Index(1)]),\n@@ -3506,7 +3506,7 @@ mod tests {\n                   (F64Value(1.0),               vec![Key(\"a\")]),\n                   (ArrayStart,                  vec![Key(\"b\")]),\n                     (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n+                    (StringValue(\"foo\\nbar\".into_string()),  vec![Key(\"b\"), Index(1)]),\n                     (ObjectStart,               vec![Key(\"b\"), Index(2)]),\n                       (ObjectStart,             vec![Key(\"b\"), Index(2), Key(\"c\")]),\n                         (NullValue,             vec![Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n@@ -3639,7 +3639,7 @@ mod tests {\n         assert!(stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n \n-        stack.push_key(\"foo\".to_string());\n+        stack.push_key(\"foo\".into_string());\n \n         assert!(stack.len() == 2);\n         assert!(stack.is_equal_to(&[Index(1), Key(\"foo\")]));\n@@ -3651,7 +3651,7 @@ mod tests {\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));\n \n-        stack.push_key(\"bar\".to_string());\n+        stack.push_key(\"bar\".into_string());\n \n         assert!(stack.len() == 3);\n         assert!(stack.is_equal_to(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n@@ -3688,8 +3688,8 @@ mod tests {\n         let array3 = Array(vec!(U64(1), U64(2), U64(3)));\n         let object = {\n             let mut tree_map = TreeMap::new();\n-            tree_map.insert(\"a\".to_string(), U64(1));\n-            tree_map.insert(\"b\".to_string(), U64(2));\n+            tree_map.insert(\"a\".into_string(), U64(1));\n+            tree_map.insert(\"b\".into_string(), U64(2));\n             Object(tree_map)\n         };\n \n@@ -3721,12 +3721,12 @@ mod tests {\n         assert_eq!((vec![1u, 2]).to_json(), array2);\n         assert_eq!(vec!(1u, 2, 3).to_json(), array3);\n         let mut tree_map = TreeMap::new();\n-        tree_map.insert(\"a\".to_string(), 1u);\n-        tree_map.insert(\"b\".to_string(), 2);\n+        tree_map.insert(\"a\".into_string(), 1u);\n+        tree_map.insert(\"b\".into_string(), 2);\n         assert_eq!(tree_map.to_json(), object);\n         let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".to_string(), 1u);\n-        hash_map.insert(\"b\".to_string(), 2);\n+        hash_map.insert(\"a\".into_string(), 1u);\n+        hash_map.insert(\"b\".into_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n         assert_eq!(Some(15i).to_json(), I64(15));\n         assert_eq!(Some(15u).to_json(), U64(15));\n@@ -3769,7 +3769,7 @@ mod tests {\n     }\n \n     fn big_json() -> string::String {\n-        let mut src = \"[\\n\".to_string();\n+        let mut src = \"[\\n\".into_string();\n         for _ in range(0i, 500) {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n                             [1,2,3]},\"#);"}]}