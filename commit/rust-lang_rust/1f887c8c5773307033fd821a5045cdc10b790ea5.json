{"sha": "1f887c8c5773307033fd821a5045cdc10b790ea5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmODg3YzhjNTc3MzMwNzAzM2ZkODIxYTUwNDVjZGMxMGI3OTBlYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-02T08:11:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-02T08:11:19Z"}, "message": "auto merge of #20412 : nikomatsakis/rust/assoc-types, r=aturon\n\nThese changes fix various problems encountered getting japaric's `at-iter` branch to work. This branch converts the `Iterator` trait to use an associated type.", "tree": {"sha": "ae60dd6f85a97200359bc0f697623f9287acaa36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae60dd6f85a97200359bc0f697623f9287acaa36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f887c8c5773307033fd821a5045cdc10b790ea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f887c8c5773307033fd821a5045cdc10b790ea5", "html_url": "https://github.com/rust-lang/rust/commit/1f887c8c5773307033fd821a5045cdc10b790ea5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f887c8c5773307033fd821a5045cdc10b790ea5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee3c5957eaaf577bff895ce819447f7e40558a28", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee3c5957eaaf577bff895ce819447f7e40558a28", "html_url": "https://github.com/rust-lang/rust/commit/ee3c5957eaaf577bff895ce819447f7e40558a28"}, {"sha": "345e38cc0582d2ad00c05e9307bfddef19c84e64", "url": "https://api.github.com/repos/rust-lang/rust/commits/345e38cc0582d2ad00c05e9307bfddef19c84e64", "html_url": "https://github.com/rust-lang/rust/commit/345e38cc0582d2ad00c05e9307bfddef19c84e64"}], "stats": {"total": 545, "additions": 381, "deletions": 164}, "files": [{"sha": "d36c85342ce32be7b9c463119f9b91ed3d84c7e1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -1229,7 +1229,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             // inferred by regionbk\n             let upvar_id = ty::UpvarId { var_id: id_var,\n                                          closure_expr_id: closure_expr.id };\n-            let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n+            let upvar_borrow = self.typer.upvar_borrow(upvar_id).unwrap();\n \n             self.delegate.borrow(closure_expr.id,\n                                  closure_expr.span,"}, {"sha": "0c3438abb2b479873048863ad2a15a506da6f311", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -111,7 +111,9 @@ use self::VarKind::*;\n \n use middle::def::*;\n use middle::mem_categorization::Typer;\n-use middle::{pat_util, ty};\n+use middle::pat_util;\n+use middle::ty;\n+use middle::ty::UnboxedClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n \n@@ -1515,16 +1517,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::FnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n-            ty::ty_unboxed_closure(closure_def_id, _, _) =>\n-                self.ir.tcx.unboxed_closures()\n-                    .borrow()\n-                    .get(&closure_def_id)\n-                    .unwrap()\n-                    .closure_type\n-                    .sig\n-                    .0\n-                    .output,\n-            _ => ty::ty_fn_ret(fn_ty)\n+            ty::ty_unboxed_closure(closure_def_id, _, substs) =>\n+                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.0.output,\n+            _ =>\n+                ty::ty_fn_ret(fn_ty),\n         }\n     }\n "}, {"sha": "70942a950e324b3a7621b850c840d15f5245e559", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -74,7 +74,7 @@ pub use self::categorization::*;\n use middle::def;\n use middle::region;\n use middle::ty::{mod, Ty};\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{NodeMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n@@ -280,7 +280,7 @@ impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n /// In the borrow checker, in contrast, type checking is complete and we\n /// know that no errors have occurred, so we simply consult the tcx and we\n /// can be sure that only `Ok` results will occur.\n-pub trait Typer<'tcx> {\n+pub trait Typer<'tcx> : ty::UnboxedClosureTyper<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx>;\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx>;\n@@ -290,11 +290,9 @@ pub trait Typer<'tcx> {\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow>;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause;\n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>>;\n }\n \n impl MutabilityCategory {\n@@ -622,8 +620,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                       self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, false)\n                   }\n                   ty::ty_unboxed_closure(closure_id, _, _) => {\n-                      let unboxed_closures = self.typer.unboxed_closures().borrow();\n-                      let kind = (*unboxed_closures)[closure_id].kind;\n+                      let kind = self.typer.unboxed_closure_kind(closure_id);\n                       let mode = self.typer.capture_mode(fn_node_id);\n                       self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, true)\n                   }\n@@ -800,7 +797,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 }\n \n                 // Look up upvar borrow so we can get its region\n-                let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n+                let upvar_borrow = self.typer.upvar_borrow(upvar_id).unwrap();\n                 let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n \n                 Rc::new(cmt_ {"}, {"sha": "2dbb15b215ed0a7ed124bb8f4f8055fcabb63ab8", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -110,7 +110,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn normalize_projection_type<'a>(&mut self,\n                                          infcx: &InferCtxt<'a,'tcx>,\n                                          param_env: &ty::ParameterEnvironment<'tcx>,\n-                                         typer: &Typer<'tcx>,\n+                                         typer: &ty::UnboxedClosureTyper<'tcx>,\n                                          projection_ty: ty::ProjectionTy<'tcx>,\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n@@ -187,7 +187,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn select_all_or_error<'a>(&mut self,\n                                    infcx: &InferCtxt<'a,'tcx>,\n                                    param_env: &ty::ParameterEnvironment<'tcx>,\n-                                   typer: &Typer<'tcx>)\n+                                   typer: &ty::UnboxedClosureTyper<'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         try!(self.select_where_possible(infcx, param_env, typer));\n@@ -213,7 +213,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn select_new_obligations<'a>(&mut self,\n                                       infcx: &InferCtxt<'a,'tcx>,\n                                       param_env: &ty::ParameterEnvironment<'tcx>,\n-                                      typer: &Typer<'tcx>)\n+                                      typer: &ty::UnboxedClosureTyper<'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, param_env, typer);\n@@ -223,7 +223,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn select_where_possible<'a>(&mut self,\n                                      infcx: &InferCtxt<'a,'tcx>,\n                                      param_env: &ty::ParameterEnvironment<'tcx>,\n-                                     typer: &Typer<'tcx>)\n+                                     typer: &ty::UnboxedClosureTyper<'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, param_env, typer);"}, {"sha": "c84f31bf6c3bcad624c7c94a5f1aa1a58dab54b0", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -102,7 +102,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n \n /// Compute result of projecting an associated type and unify it with\n /// `obligation.predicate.ty` (if we can).\n-pub fn project_and_unify_type<'cx,'tcx>(\n+fn project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n@@ -135,9 +135,19 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n                                -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n {\n-    let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, 0);\n+    normalize_with_depth(selcx, cause, 0, value)\n+}\n+\n+pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n+                                          cause: ObligationCause<'tcx>,\n+                                          depth: uint,\n+                                          value: &T)\n+                                          -> Normalized<'tcx, T>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+{\n+    let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n     let result = normalizer.fold(value);\n     Normalized {\n         value: result,\n@@ -278,9 +288,10 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            debug!(\"normalize_projection_type: projected_ty={} depth={}\",\n+            debug!(\"normalize_projection_type: projected_ty={} depth={} obligations={}\",\n                    projected_ty.repr(selcx.tcx()),\n-                   depth);\n+                   depth,\n+                   obligations.repr(selcx.tcx()));\n \n             if ty::type_has_projection(projected_ty) {\n                 let tcx = selcx.tcx();\n@@ -644,3 +655,20 @@ impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Normalized<'tcx, T> {\n+        Normalized {\n+            value: self.value.fold_with(folder),\n+            obligations: self.obligations.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Normalized<'tcx, T> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"Normalized({},{})\",\n+                self.value.repr(tcx),\n+                self.obligations.repr(tcx))\n+    }\n+}"}, {"sha": "f9dced088f8c124b7d2ba2daa71576e4ee2cdb82", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -18,6 +18,7 @@ use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n use super::{DerivedObligationCause};\n+use super::{project};\n use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n@@ -29,7 +30,7 @@ use super::{util};\n \n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n-use middle::subst::{Subst, Substs, VecPerParamSpace};\n+use middle::subst::{Subst, Substs, TypeSpace, VecPerParamSpace};\n use middle::ty::{mod, AsPredicate, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n@@ -44,7 +45,7 @@ use util::ppaux::Repr;\n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     param_env: &'cx ty::ParameterEnvironment<'tcx>,\n-    typer: &'cx (Typer<'tcx>+'cx),\n+    closure_typer: &'cx (ty::UnboxedClosureTyper<'tcx>+'cx),\n \n     /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n@@ -177,25 +178,25 @@ enum EvaluationResult<'tcx> {\n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n                param_env: &'cx ty::ParameterEnvironment<'tcx>,\n-               typer: &'cx Typer<'tcx>)\n+               closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             param_env: param_env,\n-            typer: typer,\n+            closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n                       param_env: &'cx ty::ParameterEnvironment<'tcx>,\n-                      typer: &'cx Typer<'tcx>)\n+                      closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             param_env: param_env,\n-            typer: typer,\n+            closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: true,\n         }\n@@ -918,15 +919,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                kind,\n                obligation.repr(self.tcx()));\n \n-        let closure_kind = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n-            Some(closure) => closure.kind,\n-            None => {\n-                self.tcx().sess.span_bug(\n-                    obligation.cause.span,\n-                    format!(\"No entry for unboxed closure: {}\",\n-                            closure_def_id.repr(self.tcx()))[]);\n-            }\n-        };\n+        let closure_kind = self.closure_typer.unboxed_closure_kind(closure_def_id);\n \n         debug!(\"closure_kind = {}\", closure_kind);\n \n@@ -1398,32 +1391,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return Ok(ParameterBuiltin);\n                 }\n \n-                match self.tcx().freevars.borrow().get(&def_id.node) {\n-                    None => {\n-                        // No upvars.\n-                        Ok(If(Vec::new()))\n+                match self.closure_typer.unboxed_closure_upvars(def_id, substs) {\n+                    Some(upvars) => {\n+                        Ok(If(upvars.iter().map(|c| c.ty).collect()))\n                     }\n-\n-                    Some(freevars) => {\n-                        let tys: Vec<Ty> =\n-                            freevars\n-                            .iter()\n-                            .map(|freevar| {\n-                                let freevar_def_id = freevar.def.def_id();\n-                                self.typer.node_ty(freevar_def_id.node).subst(self.tcx(), substs)\n-                            })\n-                            .collect();\n-                        Ok(If(tys))\n+                    None => {\n+                        Ok(AmbiguousBuiltin)\n                     }\n                 }\n             }\n \n             ty::ty_struct(def_id, substs) => {\n                 let types: Vec<Ty> =\n-                    ty::struct_fields(self.tcx(), def_id, substs)\n-                    .iter()\n-                    .map(|f| f.mt.ty)\n-                    .collect();\n+                    ty::struct_fields(self.tcx(), def_id, substs).iter()\n+                                                                 .map(|f| f.mt.ty)\n+                                                                 .collect();\n                 nominal(self, bound, def_id, types)\n             }\n \n@@ -1798,27 +1780,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n-            Some(closure) => closure.closure_type.clone(),\n-            None => {\n-                self.tcx().sess.span_bug(\n-                    obligation.cause.span,\n-                    format!(\"No entry for unboxed closure: {}\",\n-                            closure_def_id.repr(self.tcx()))[]);\n-            }\n-        };\n+        let closure_type = self.closure_typer.unboxed_closure_type(closure_def_id, substs);\n+\n+        debug!(\"confirm_unboxed_closure_candidate: closure_def_id={} closure_type={}\",\n+               closure_def_id.repr(self.tcx()),\n+               closure_type.repr(self.tcx()));\n \n         let closure_sig = &closure_type.sig;\n         let arguments_tuple = closure_sig.0.inputs[0];\n-        let substs =\n+        let trait_substs =\n             Substs::new_trait(\n-                vec![arguments_tuple.subst(self.tcx(), substs),\n-                     closure_sig.0.output.unwrap().subst(self.tcx(), substs)],\n+                vec![arguments_tuple, closure_sig.0.output.unwrap()],\n                 vec![],\n                 obligation.self_ty());\n         let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n             def_id: obligation.predicate.def_id(),\n-            substs: self.tcx().mk_substs(substs),\n+            substs: self.tcx().mk_substs(trait_substs),\n         }));\n \n         debug!(\"confirm_unboxed_closure_candidate(closure_def_id={}, trait_ref={})\",\n@@ -2100,7 +2077,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn impl_predicates(&self,\n+    fn impl_predicates(&mut self,\n                        cause: ObligationCause<'tcx>,\n                        recursion_depth: uint,\n                        impl_def_id: ast::DefId,\n@@ -2111,8 +2088,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n         let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n-        let bounds = self.infcx().plug_leaks(skol_map, snapshot, &bounds);\n-        util::predicates_for_generics(self.tcx(), cause, recursion_depth, &bounds)\n+        let normalized_bounds =\n+            project::normalize_with_depth(self, cause.clone(), recursion_depth, &bounds);\n+        let normalized_bounds =\n+            self.infcx().plug_leaks(skol_map, snapshot, &normalized_bounds);\n+        let mut impl_obligations =\n+            util::predicates_for_generics(self.tcx(),\n+                                          cause,\n+                                          recursion_depth,\n+                                          &normalized_bounds.value);\n+        for obligation in normalized_bounds.obligations.into_iter() {\n+            impl_obligations.push(TypeSpace, obligation);\n+        }\n+        impl_obligations\n     }\n \n     fn fn_family_trait_kind(&self,"}, {"sha": "7bc5d3d070894a263179be6cd01a5f6142bebfb9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 137, "deletions": 32, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -2267,6 +2267,23 @@ impl UnboxedClosureKind {\n     }\n }\n \n+pub trait UnboxedClosureTyper<'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind;\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>;\n+\n+    // Returns `None` if the upvar types cannot yet be definitively determined.\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<UnboxedClosureUpvar<'tcx>>>;\n+}\n+\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n            interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>)\n@@ -3353,7 +3370,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_unboxed_closure(did, r, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n-                let upvars = unboxed_closure_upvars(cx, did, substs);\n+                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache))\n                     | borrowed_contents(*r, MutMutable)\n@@ -3633,7 +3650,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             }\n \n             ty_unboxed_closure(did, _, substs) => {\n-                let upvars = unboxed_closure_upvars(cx, did, substs);\n+                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n                 upvars.iter().any(|f| type_requires(cx, seen, r_ty, f.ty))\n             }\n \n@@ -3725,7 +3742,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n             ty_unboxed_closure(did, _, substs) => {\n-                let upvars = unboxed_closure_upvars(cx, did, substs);\n+                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n                 find_nonrepresentable(cx, sp, seen, upvars.iter().map(|f| f.ty))\n             }\n             _ => Representable,\n@@ -5656,46 +5673,75 @@ pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     }).collect()\n }\n \n-#[deriving(Copy)]\n+#[deriving(Copy, Clone)]\n pub struct UnboxedClosureUpvar<'tcx> {\n     pub def: def::Def,\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n }\n \n // Returns a list of `UnboxedClosureUpvar`s for each upvar.\n-pub fn unboxed_closure_upvars<'tcx>(tcx: &ctxt<'tcx>, closure_id: ast::DefId, substs: &Substs<'tcx>)\n-                                    -> Vec<UnboxedClosureUpvar<'tcx>> {\n+pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n+                                    closure_id: ast::DefId,\n+                                    substs: &Substs<'tcx>)\n+                                    -> Option<Vec<UnboxedClosureUpvar<'tcx>>>\n+{\n     // Presently an unboxed closure type cannot \"escape\" out of a\n     // function, so we will only encounter ones that originated in the\n     // local crate or were inlined into it along with some function.\n     // This may change if abstract return types of some sort are\n     // implemented.\n     assert!(closure_id.krate == ast::LOCAL_CRATE);\n+    let tcx = typer.tcx();\n     let capture_mode = tcx.capture_modes.borrow()[closure_id.node].clone();\n     match tcx.freevars.borrow().get(&closure_id.node) {\n-        None => vec![],\n+        None => Some(vec![]),\n         Some(ref freevars) => {\n-            freevars.iter().map(|freevar| {\n-                let freevar_def_id = freevar.def.def_id();\n-                let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n-                let mut freevar_ty = freevar_ty.subst(tcx, substs);\n-                if capture_mode == ast::CaptureByRef {\n-                    let borrow = tcx.upvar_borrow_map.borrow()[ty::UpvarId {\n-                        var_id: freevar_def_id.node,\n-                        closure_expr_id: closure_id.node\n-                    }].clone();\n-                    freevar_ty = mk_rptr(tcx, tcx.mk_region(borrow.region), ty::mt {\n-                        ty: freevar_ty,\n-                        mutbl: borrow.kind.to_mutbl_lossy()\n-                    });\n-                }\n-                UnboxedClosureUpvar {\n-                    def: freevar.def,\n-                    span: freevar.span,\n-                    ty: freevar_ty\n-                }\n-            }).collect()\n+            freevars.iter()\n+                    .map(|freevar| {\n+                        let freevar_def_id = freevar.def.def_id();\n+                        let freevar_ty = typer.node_ty(freevar_def_id.node);\n+                        let freevar_ty = freevar_ty.subst(tcx, substs);\n+\n+                        match capture_mode {\n+                            ast::CaptureByValue => {\n+                                Some(UnboxedClosureUpvar { def: freevar.def,\n+                                                           span: freevar.span,\n+                                                           ty: freevar_ty })\n+                            }\n+\n+                            ast::CaptureByRef => {\n+                                let upvar_id = ty::UpvarId {\n+                                    var_id: freevar_def_id.node,\n+                                    closure_expr_id: closure_id.node\n+                                };\n+\n+                                // FIXME\n+                                let freevar_ref_ty = match typer.upvar_borrow(upvar_id) {\n+                                    Some(borrow) => {\n+                                        mk_rptr(tcx,\n+                                                tcx.mk_region(borrow.region),\n+                                                ty::mt {\n+                                                    ty: freevar_ty,\n+                                                    mutbl: borrow.kind.to_mutbl_lossy(),\n+                                                })\n+                                    }\n+                                    None => {\n+                                        // FIXME(#16640) we should really return None here;\n+                                        // but that requires better inference integration,\n+                                        // for now gin up something.\n+                                        freevar_ty\n+                                    }\n+                                };\n+                                Some(UnboxedClosureUpvar {\n+                                    def: freevar.def,\n+                                    span: freevar.span,\n+                                    ty: freevar_ref_ty,\n+                                })\n+                            }\n+                        }\n+                    })\n+                    .collect()\n         }\n     }\n }\n@@ -6509,21 +6555,42 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n         self.region_maps.temporary_scope(rvalue_id)\n     }\n \n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.upvar_borrow_map.borrow()[upvar_id].clone()\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+        Some(self.upvar_borrow_map.borrow()[upvar_id].clone())\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n         self.capture_modes.borrow()[closure_expr_id].clone()\n     }\n+}\n \n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<UnboxedClosure<'tcx>>> {\n-        &self.unboxed_closures\n+impl<'tcx> UnboxedClosureTyper<'tcx> for ty::ctxt<'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.unboxed_closures.borrow()[def_id].kind\n+    }\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        self.unboxed_closures.borrow()[def_id].closure_type.subst(self, substs)\n+    }\n+\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<UnboxedClosureUpvar<'tcx>>>\n+    {\n+        unboxed_closure_upvars(self, def_id, substs)\n     }\n }\n \n+\n /// The category of explicit self.\n #[deriving(Clone, Copy, Eq, PartialEq, Show)]\n pub enum ExplicitSelfCategory {\n@@ -7040,12 +7107,30 @@ pub trait HasProjectionTypes {\n     fn has_projection_types(&self) -> bool;\n }\n \n+impl<'tcx,T:HasProjectionTypes> HasProjectionTypes for Vec<T> {\n+    fn has_projection_types(&self) -> bool {\n+        self.iter().any(|p| p.has_projection_types())\n+    }\n+}\n+\n impl<'tcx,T:HasProjectionTypes> HasProjectionTypes for VecPerParamSpace<T> {\n     fn has_projection_types(&self) -> bool {\n         self.iter().any(|p| p.has_projection_types())\n     }\n }\n \n+impl<'tcx> HasProjectionTypes for ClosureTy<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.sig.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for UnboxedClosureUpvar<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.ty.has_projection_types()\n+    }\n+}\n+\n impl<'tcx> HasProjectionTypes for ty::GenericBounds<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.predicates.has_projection_types()\n@@ -7245,3 +7330,23 @@ impl ReferencesError for Region\n         false\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"ClosureTy({},{},{},{},{},{})\",\n+                self.unsafety,\n+                self.onceness,\n+                self.store,\n+                self.bounds.repr(tcx),\n+                self.sig.repr(tcx),\n+                self.abi)\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for UnboxedClosureUpvar<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"UnboxedClosureUpvar({},{})\",\n+                self.def.repr(tcx),\n+                self.ty.repr(tcx))\n+    }\n+}"}, {"sha": "83d2f6fb0e6d58909000c0c6171ea414a8f648f9", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -532,6 +532,16 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::UnboxedClosureUpvar<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnboxedClosureUpvar<'tcx> {\n+        ty::UnboxedClosureUpvar {\n+            def: self.def,\n+            span: self.span,\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //"}, {"sha": "24a3bb42c90f76836d714badc38c6065ca248766", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -168,7 +168,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, substs) => {\n-            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n+            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, upvar_types[], false, t), false)\n         }"}, {"sha": "18155d756807ce037df7de78ad12e53b12f08836", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -43,7 +43,7 @@ use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::subst;\n use middle::weak_lang_items;\n use middle::subst::{Subst, Substs};\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, UnboxedClosureTyper};\n use session::config::{mod, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n@@ -257,12 +257,12 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n }\n \n pub fn self_type_for_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     closure_id: ast::DefId,\n-                                     fn_ty: Ty<'tcx>)\n-                                     -> Ty<'tcx> {\n-    let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-    let unboxed_closure = &(*unboxed_closures)[closure_id];\n-    match unboxed_closure.kind {\n+                                               closure_id: ast::DefId,\n+                                               fn_ty: Ty<'tcx>)\n+                                               -> Ty<'tcx>\n+{\n+    let unboxed_closure_kind = ccx.tcx().unboxed_closure_kind(closure_id);\n+    match unboxed_closure_kind {\n         ty::FnUnboxedClosureKind => {\n             ty::mk_imm_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n@@ -291,13 +291,15 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, Some(Type::i8p(ccx)))\n         }\n         ty::ty_unboxed_closure(closure_did, _, substs) => {\n-            let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-            let unboxed_closure = &(*unboxed_closures)[closure_did];\n-            let function_type = unboxed_closure.closure_type.clone();\n+            let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n+            let function_type = typer.unboxed_closure_type(closure_did, substs);\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n-            (function_type.sig.0.inputs.iter().map(|t| t.subst(ccx.tcx(), substs)).collect(),\n-             function_type.sig.0.output.subst(ccx.tcx(), substs),\n+            debug!(\"decl_rust_fn: function_type={} self_type={}\",\n+                   function_type.repr(ccx.tcx()),\n+                   self_type.repr(ccx.tcx()));\n+            (function_type.sig.0.inputs,\n+             function_type.sig.0.output,\n              RustCall,\n              Some(llenvironment_type))\n         }\n@@ -729,7 +731,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n       }\n       ty::ty_unboxed_closure(def_id, _, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n+          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs).unwrap();\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);\n@@ -2436,11 +2438,9 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n         ty::ty_bare_fn(_, ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _, substs) => {\n-            let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-            let ref function_type = (*unboxed_closures)[closure_did]\n-                                                    .closure_type;\n-\n-            (function_type.sig.subst(ccx.tcx(), substs), RustCall, true)\n+            let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n+            let function_type = typer.unboxed_closure_type(closure_did, substs);\n+            (function_type.sig, RustCall, true)\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };"}, {"sha": "93a5b54fde3e5286b946a6930f96e2bbfb8404dd", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -22,11 +22,11 @@ use trans::common::*;\n use trans::datum::{Datum, DatumBlock, Expr, Lvalue, rvalue_scratch_datum};\n use trans::debuginfo;\n use trans::expr;\n-use trans::monomorphize::MonoId;\n+use trans::monomorphize::{mod, MonoId};\n use trans::type_of::*;\n use trans::type_::Type;\n-use middle::ty::{mod, Ty};\n-use middle::subst::{Subst, Substs};\n+use middle::ty::{mod, Ty, UnboxedClosureTyper};\n+use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n use util::ppaux::Repr;\n use util::ppaux::ty_to_string;\n@@ -464,7 +464,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n     }\n \n     let function_type = ty::node_id_to_type(bcx.tcx(), closure_id.node);\n-    let function_type = function_type.subst(bcx.tcx(), substs);\n+    let function_type = monomorphize::apply_param_substs(bcx.tcx(), substs, &function_type);\n \n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n@@ -511,7 +511,8 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                              body: &ast::Block,\n                              id: ast::NodeId,\n                              dest: expr::Dest)\n-                             -> Block<'blk, 'tcx> {\n+                             -> Block<'blk, 'tcx>\n+{\n     let _icx = push_ctxt(\"closure::trans_unboxed_closure\");\n \n     debug!(\"trans_unboxed_closure()\");\n@@ -522,9 +523,13 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n         closure_id,\n         bcx.fcx.param_substs).unwrap();\n \n-    let function_type = (*bcx.tcx().unboxed_closures.borrow())[closure_id]\n-                                                              .closure_type\n-                                                              .clone();\n+    // Get the type of this closure. Use the current `param_substs` as\n+    // the closure substitutions. This makes sense because the closure\n+    // takes the same set of type arguments as the enclosing fn, and\n+    // this function (`trans_unboxed_closure`) is invoked at the point\n+    // of the closure expression.\n+    let typer = NormalizingUnboxedClosureTyper::new(bcx.tcx());\n+    let function_type = typer.unboxed_closure_type(closure_id, bcx.fcx.param_substs);\n     let function_type = ty::mk_closure(bcx.tcx(), function_type);\n \n     let freevars: Vec<ty::Freevar> ="}, {"sha": "aa8822408806365fc4fa34b1269544be2257267d", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 76, "deletions": 10, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -39,7 +39,7 @@ use middle::ty::{mod, HasProjectionTypes, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use util::ppaux::Repr;\n-use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n+use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n@@ -617,13 +617,8 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx().region_maps.temporary_scope(rvalue_id)\n     }\n \n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n-        &self.tcx().unboxed_closures\n-    }\n-\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.tcx().upvar_borrow_map.borrow()[upvar_id].clone()\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+        Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n@@ -632,6 +627,34 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n }\n \n+impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_kind(def_id)\n+    }\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_type(def_id, substs)\n+    }\n+\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_upvars(def_id, substs)\n+    }\n+}\n+\n pub struct Result<'blk, 'tcx: 'blk> {\n     pub bcx: Block<'blk, 'tcx>,\n     pub val: ValueRef\n@@ -924,7 +947,8 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n+    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, &typer);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {\n@@ -968,6 +992,47 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n+pub struct NormalizingUnboxedClosureTyper<'a,'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>\n+}\n+\n+impl<'a,'tcx> NormalizingUnboxedClosureTyper<'a,'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n+        NormalizingUnboxedClosureTyper { tcx: tcx }\n+    }\n+}\n+\n+impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'a,'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.tcx.unboxed_closure_kind(def_id)\n+    }\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        // the substitutions in `substs` are already monomorphized,\n+        // but we still must normalize associated types\n+        let closure_ty = self.tcx.unboxed_closure_type(def_id, substs);\n+        monomorphize::normalize_associated_type(self.tcx, &closure_ty)\n+    }\n+\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        // the substitutions in `substs` are already monomorphized,\n+        // but we still must normalize associated types\n+        let result = ty::unboxed_closure_upvars(self.tcx, def_id, substs);\n+        monomorphize::normalize_associated_type(self.tcx, &result)\n+    }\n+}\n+\n pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n                                        infcx: &infer::InferCtxt<'a,'tcx>,\n                                        param_env: &ty::ParameterEnvironment<'tcx>,\n@@ -982,7 +1047,8 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n-    match fulfill_cx.select_all_or_error(infcx, param_env, infcx.tcx) {\n+    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n+    match fulfill_cx.select_all_or_error(infcx, param_env, &typer) {\n         Ok(()) => { }\n         Err(errors) => {\n             if errors.iter().all(|e| e.is_overflow()) {"}, {"sha": "c651255226b5adc080a2ed5c6cf0ad410a2ab005", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -194,13 +194,13 @@ use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::*;\n use metadata::csearch;\n-use middle::subst::{mod, Subst, Substs};\n+use middle::subst::{mod, Substs};\n use trans::{mod, adt, machine, type_of};\n use trans::common::*;\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, UnboxedClosureTyper};\n use middle::pat_util;\n use session::config::{mod, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n@@ -470,9 +470,9 @@ impl<'tcx> TypeMap<'tcx> {\n                                                         closure_ty.clone(),\n                                                         &mut unique_type_id);\n             },\n-            ty::ty_unboxed_closure(ref def_id, _, substs) => {\n-                let closure_ty = cx.tcx().unboxed_closures.borrow()\n-                                   .get(def_id).unwrap().closure_type.subst(cx.tcx(), substs);\n+            ty::ty_unboxed_closure(def_id, _, substs) => {\n+                let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n+                let closure_ty = typer.unboxed_closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n@@ -3020,9 +3020,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, unique_type_id, &closurety.sig, usage_site_span)\n         }\n-        ty::ty_unboxed_closure(ref def_id, _, substs) => {\n-            let sig = cx.tcx().unboxed_closures.borrow()\n-                        .get(def_id).unwrap().closure_type.sig.subst(cx.tcx(), substs);\n+        ty::ty_unboxed_closure(def_id, _, substs) => {\n+            let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n+            let sig = typer.unboxed_closure_type(def_id, substs).sig;\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n         ty::ty_struct(def_id, substs) => {"}, {"sha": "7c8ba08d987504964fe497fea513a123ca0a296a", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -323,7 +323,8 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     let param_env = ty::empty_parameter_environment();\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n+    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, &typer);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } =\n         traits::normalize(&mut selcx, cause, value);"}, {"sha": "5e9843d0e00bfe7b86268a7880878adadb79e589", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::infer::InferCtxt;\n-use middle::mem_categorization as mc;\n use middle::traits::{mod, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n use middle::ty::{mod, HasProjectionTypes};\n@@ -20,7 +19,7 @@ use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 param_env: &ty::ParameterEnvironment<'tcx>,\n-                                                typer: &(mc::Typer<'tcx>+'a),\n+                                                typer: &(ty::UnboxedClosureTyper<'tcx>+'a),\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n                                                 body_id: ast::NodeId,"}, {"sha": "d4e025a38131e8b90eac5cd621d0b037400eeb74", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f887c8c5773307033fd821a5045cdc10b790ea5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1f887c8c5773307033fd821a5045cdc10b790ea5", "patch": "@@ -319,15 +319,37 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n         self.tcx().temporary_scope(rvalue_id)\n     }\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.inh.upvar_borrow_map.borrow()[upvar_id].clone()\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+        self.inh.upvar_borrow_map.borrow().get(&upvar_id).cloned()\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n-    fn unboxed_closures(&self) -> &RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n-        &self.inh.unboxed_closures\n+}\n+\n+impl<'a, 'tcx> ty::UnboxedClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.inh.unboxed_closures.borrow()[def_id].kind\n+    }\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        self.inh.unboxed_closures.borrow()[def_id].closure_type.subst(self.tcx(), substs)\n+    }\n+\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        ty::unboxed_closure_upvars(self, def_id, substs)\n     }\n }\n \n@@ -352,7 +374,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     }\n \n     fn normalize_associated_types_in<T>(&self,\n-                                        typer: &mc::Typer<'tcx>,\n+                                        typer: &ty::UnboxedClosureTyper<'tcx>,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n                                         value: &T)"}]}