{"sha": "70e77162621c7cde2435224cf1decdee088be27e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZTc3MTYyNjIxYzdjZGUyNDM1MjI0Y2YxZGVjZGVlMDg4YmUyN2U=", "commit": {"author": {"name": "Ingvar Stepanyan", "email": "me@rreverser.com", "date": "2018-01-29T10:15:18Z"}, "committer": {"name": "Ingvar Stepanyan", "email": "me@rreverser.com", "date": "2018-02-04T11:54:03Z"}, "message": "Comments WIP", "tree": {"sha": "00ece44489edff7f38a87c306c0beaec196fe42c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00ece44489edff7f38a87c306c0beaec196fe42c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70e77162621c7cde2435224cf1decdee088be27e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70e77162621c7cde2435224cf1decdee088be27e", "html_url": "https://github.com/rust-lang/rust/commit/70e77162621c7cde2435224cf1decdee088be27e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70e77162621c7cde2435224cf1decdee088be27e/comments", "author": {"login": "RReverser", "id": 557590, "node_id": "MDQ6VXNlcjU1NzU5MA==", "avatar_url": "https://avatars.githubusercontent.com/u/557590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RReverser", "html_url": "https://github.com/RReverser", "followers_url": "https://api.github.com/users/RReverser/followers", "following_url": "https://api.github.com/users/RReverser/following{/other_user}", "gists_url": "https://api.github.com/users/RReverser/gists{/gist_id}", "starred_url": "https://api.github.com/users/RReverser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RReverser/subscriptions", "organizations_url": "https://api.github.com/users/RReverser/orgs", "repos_url": "https://api.github.com/users/RReverser/repos", "events_url": "https://api.github.com/users/RReverser/events{/privacy}", "received_events_url": "https://api.github.com/users/RReverser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RReverser", "id": 557590, "node_id": "MDQ6VXNlcjU1NzU5MA==", "avatar_url": "https://avatars.githubusercontent.com/u/557590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RReverser", "html_url": "https://github.com/RReverser", "followers_url": "https://api.github.com/users/RReverser/followers", "following_url": "https://api.github.com/users/RReverser/following{/other_user}", "gists_url": "https://api.github.com/users/RReverser/gists{/gist_id}", "starred_url": "https://api.github.com/users/RReverser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RReverser/subscriptions", "organizations_url": "https://api.github.com/users/RReverser/orgs", "repos_url": "https://api.github.com/users/RReverser/repos", "events_url": "https://api.github.com/users/RReverser/events{/privacy}", "received_events_url": "https://api.github.com/users/RReverser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41c393c7516d4c1d5d8ad29fa177b43fb620b211", "url": "https://api.github.com/repos/rust-lang/rust/commits/41c393c7516d4c1d5d8ad29fa177b43fb620b211", "html_url": "https://github.com/rust-lang/rust/commit/41c393c7516d4c1d5d8ad29fa177b43fb620b211"}], "stats": {"total": 208, "additions": 124, "deletions": 84}, "files": [{"sha": "1c9ca3057f017976c5ff7dfaf90b80f6bdae480a", "filename": "src/macros.rs", "status": "modified", "additions": 118, "deletions": 83, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/70e77162621c7cde2435224cf1decdee088be27e/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e77162621c7cde2435224cf1decdee088be27e/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=70e77162621c7cde2435224cf1decdee088be27e", "patch": "@@ -33,6 +33,7 @@ use syntax::util::ThinVec;\n use codemap::SpanUtils;\n use comment::{contains_comment, remove_trailing_white_spaces, FindUncommented};\n use expr::{rewrite_array, rewrite_call_inner};\n+use lists::{itemize_list, write_list, DefinitiveListTactic, ListFormatting, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use utils::{format_visibility, mk_sp};\n@@ -283,6 +284,7 @@ pub fn rewrite_macro(\n \n pub fn rewrite_macro_def(\n     context: &RewriteContext,\n+    shape: Shape,\n     indent: Indent,\n     def: &ast::MacroDef,\n     ident: ast::Ident,\n@@ -317,101 +319,132 @@ pub fn rewrite_macro_def(\n \n     let mac_indent_str = mac_indent.to_string(context.config);\n \n-    for branch in parsed_def.branches {\n-        // Only attempt to format function-like macros.\n-        if branch.args_paren_kind != DelimToken::Paren {\n-            // FIXME(#1539): implement for non-sugared macros.\n-            return snippet;\n-        }\n+    let branch_items = itemize_list(\n+        context.codemap,\n+        parsed_def.branches.iter(),\n+        \"\",\n+        \"\",\n+        |branch| branch.args_span.lo(),\n+        |branch| branch.body.hi(),\n+        |branch| {\n+            let mut result = String::new();\n+\n+            // Only attempt to format function-like macros.\n+            if branch.args_paren_kind != DelimToken::Paren {\n+                // FIXME(#1539): implement for non-sugared macros.\n+                return None;\n+            }\n \n-        let args = format_macro_args(branch.args)?;\n+            let args = format_macro_args(branch.args.clone())?;\n \n-        if multi_branch_style {\n-            result += \"\\n\";\n-            result += &mac_indent_str;\n-            result += &args;\n-            result += \" =>\";\n-        } else {\n-            result += &args;\n-        }\n+            if multi_branch_style {\n+                result += \"\\n\";\n+                result += &mac_indent_str;\n+                result += &args;\n+                result += \" =>\";\n+            } else {\n+                result += &args;\n+            }\n \n-        // The macro body is the most interesting part. It might end up as various\n-        // AST nodes, but also has special variables (e.g, `$foo`) which can't be\n-        // parsed as regular Rust code (and note that these can be escaped using\n-        // `$$`). We'll try and format like an AST node, but we'll substitute\n-        // variables for new names with the same length first.\n+            // The macro body is the most interesting part. It might end up as various\n+            // AST nodes, but also has special variables (e.g, `$foo`) which can't be\n+            // parsed as regular Rust code (and note that these can be escaped using\n+            // `$$`). We'll try and format like an AST node, but we'll substitute\n+            // variables for new names with the same length first.\n \n-        let old_body = context.snippet(branch.body).trim();\n-        let (body_str, substs) = match replace_names(old_body) {\n-            Some(result) => result,\n-            None => return snippet,\n-        };\n+            let old_body = context.snippet(branch.body).trim();\n+            let (body_str, substs) = match replace_names(old_body) {\n+                Some(result) => result,\n+                None => return snippet,\n+            };\n \n-        let mut config = context.config.clone();\n-        config.set().hide_parse_errors(true);\n+            let mut config = context.config.clone();\n+            config.set().hide_parse_errors(true);\n \n-        result += \" {\";\n+            result += \" {\";\n \n-        let has_block_body = old_body.starts_with(\"{\");\n+            let has_block_body = old_body.starts_with('{');\n \n-        let body_indent = if has_block_body {\n-            mac_indent\n-        } else {\n-            // We'll hack the indent below, take this into account when formatting,\n-            let body_indent = mac_indent.block_indent(&config);\n-            let new_width = config.max_width() - body_indent.width();\n-            config.set().max_width(new_width);\n-            body_indent\n-        };\n+            let body_indent = if has_block_body {\n+                mac_indent\n+            } else {\n+                // We'll hack the indent below, take this into account when formatting,\n+                let body_indent = mac_indent.block_indent(&config);\n+                let new_width = config.max_width() - body_indent.width();\n+                config.set().max_width(new_width);\n+                body_indent\n+            };\n \n-        // First try to format as items, then as statements.\n-        let new_body = match ::format_snippet(&body_str, &config) {\n-            Some(new_body) => new_body,\n-            None => match ::format_code_block(&body_str, &config) {\n+            // First try to format as items, then as statements.\n+            let new_body = match ::format_snippet(&body_str, &config) {\n                 Some(new_body) => new_body,\n-                None => return snippet,\n-            },\n-        };\n+                None => match ::format_code_block(&body_str, &config) {\n+                    Some(new_body) => new_body,\n+                    None => return None,\n+                },\n+            };\n \n-        // Indent the body since it is in a block.\n-        let indent_str = body_indent.to_string(&config);\n-        let mut new_body = new_body\n-            .trim_right()\n-            .lines()\n-            .fold(String::new(), |mut s, l| {\n-                if !l.is_empty() {\n-                    s += &indent_str;\n+            // Indent the body since it is in a block.\n+            let indent_str = body_indent.to_string(&config);\n+            let mut new_body = new_body\n+                .trim_right()\n+                .lines()\n+                .fold(String::new(), |mut s, l| {\n+                    if !l.is_empty() {\n+                        s += &indent_str;\n+                    }\n+                    s + l + \"\\n\"\n+                });\n+\n+            // Undo our replacement of macro variables.\n+            // FIXME: this could be *much* more efficient.\n+            for (old, new) in &substs {\n+                if old_body.find(new).is_some() {\n+                    debug!(\n+                        \"rewrite_macro_def: bailing matching variable: `{}` in `{}`\",\n+                        new, ident\n+                    );\n+                    return None;\n                 }\n-                s + l + \"\\n\"\n-            });\n-\n-        // Undo our replacement of macro variables.\n-        // FIXME: this could be *much* more efficient.\n-        for (old, new) in &substs {\n-            if old_body.find(new).is_some() {\n-                debug!(\n-                    \"rewrite_macro_def: bailing matching variable: `{}` in `{}`\",\n-                    new, ident\n-                );\n-                return snippet;\n+                new_body = new_body.replace(new, old);\n             }\n-            new_body = new_body.replace(new, old);\n-        }\n \n-        if has_block_body {\n-            result += new_body.trim();\n-        } else if !new_body.is_empty() {\n+            if has_block_body {\n+                result += new_body.trim();\n+            } else if !new_body.is_empty() {\n+                result += \"\\n\";\n+                result += &new_body;\n+                result += &mac_indent_str;\n+            }\n+\n+            result += \"}\";\n+            if def.legacy {\n+                result += \";\";\n+            }\n             result += \"\\n\";\n-            result += &new_body;\n-            result += &mac_indent_str;\n-        }\n+            Some(result)\n+        },\n+        span.lo(),\n+        span.hi(),\n+        false\n+    ).collect::<Vec<_>>();\n+\n+    let arm_shape = shape\n+        .block_indent(context.config.tab_spaces())\n+        .with_max_width(context.config);\n+\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        separator: \"\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape: arm_shape,\n+        ends_with_newline: false,\n+        preserve_newline: true,\n+        config: context.config,\n+    };\n \n-        result += \"}\";\n-        if def.legacy {\n-            result += \";\";\n-        }\n-        result += \"\\n\";\n-    }\n+    result += write_list(&branch_items, &fmt)?.as_str();\n \n     if multi_branch_style {\n         result += &indent.to_string(context.config);\n@@ -759,9 +792,9 @@ impl MacroParser {\n     // `(` ... `)` `=>` `{` ... `}`\n     fn parse_branch(&mut self) -> Option<MacroBranch> {\n         let tok = self.toks.next()?;\n-        let args_paren_kind = match tok {\n+        let (args_span, args_paren_kind) = match tok {\n             TokenTree::Token(..) => return None,\n-            TokenTree::Delimited(_, ref d) => d.delim,\n+            TokenTree::Delimited(sp, ref d) => (sp, d.delim),\n         };\n         let args = tok.joint().into();\n         match self.toks.next()? {\n@@ -779,8 +812,9 @@ impl MacroParser {\n             self.toks.next();\n         }\n         Some(MacroBranch {\n-            args,\n             args_paren_kind,\n+            args_span,\n+            args,\n             body,\n         })\n     }\n@@ -794,8 +828,9 @@ struct Macro {\n // FIXME: it would be more efficient to use references to the token streams\n // rather than clone them, if we can make the borrowing work out.\n struct MacroBranch {\n-    args: ThinTokenStream,\n     args_paren_kind: DelimToken,\n+    args_span: Span,\n+    args: ThinTokenStream,\n     body: Span,\n }\n "}, {"sha": "398fc57ce472eb12b9e1f57f10cc8b41d3988a49", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70e77162621c7cde2435224cf1decdee088be27e/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e77162621c7cde2435224cf1decdee088be27e/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=70e77162621c7cde2435224cf1decdee088be27e", "patch": "@@ -451,6 +451,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ast::ItemKind::MacroDef(ref def) => {\n                 let rewrite = rewrite_macro_def(\n                     &self.get_context(),\n+                    self.shape(),\n                     self.block_indent,\n                     def,\n                     item.ident,"}, {"sha": "39de86b9bf6b1cfcefecd61bea487435ffcff100", "filename": "tests/source/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70e77162621c7cde2435224cf1decdee088be27e/tests%2Fsource%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e77162621c7cde2435224cf1decdee088be27e/tests%2Fsource%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacro_rules.rs?ref=70e77162621c7cde2435224cf1decdee088be27e", "patch": "@@ -1,4 +1,5 @@\n macro_rules! m {\n+\t// a\n \t($expr :expr,  $( $func : ident    ) *   ) => {\n \t\t{\n \t\tlet    x =    $expr;\n@@ -8,8 +9,11 @@ macro_rules! m {\n \t}\n \t};\n \n-   \t()           => {  };\n+\t\t\t\t/* b */\n \n+   \t()           => {/* c */};\n+\n+// d\n ( $item:ident  ) =>      {\n \tmod macro_item    {  struct $item ; }\n };"}]}