{"sha": "e838059d66296a3874e85685637aac10c888b240", "node_id": "C_kwDOAAsO6NoAKGU4MzgwNTlkNjYyOTZhMzg3NGU4NTY4NTYzN2FhYzEwYzg4OGIyNDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-01T22:34:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-01T22:34:38Z"}, "message": "Auto merge of #97632 - JohnTitor:rollup-d2ucrjw, r=JohnTitor\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #95594 (Additional `*mut [T]` methods)\n - #97130 (rustdoc: avoid including impl blocks with filled-in generics)\n - #97166 (Move conditions out of recover/report functions.)\n - #97605 (Mention filename in suggestion when it differs from primary span)\n - #97613 (rustdoc: Improve calculation of \"Impls on Foreign Types\")\n - #97626 (rename PointerAddress \u2192 PointerExposeAddress)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "53e66d0a172ea9f439f1759218f965759ebdc537", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53e66d0a172ea9f439f1759218f965759ebdc537"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e838059d66296a3874e85685637aac10c888b240", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e838059d66296a3874e85685637aac10c888b240", "html_url": "https://github.com/rust-lang/rust/commit/e838059d66296a3874e85685637aac10c888b240", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e838059d66296a3874e85685637aac10c888b240/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12cd71f4d3ea6df9c2093781d55134cd9651d754", "url": "https://api.github.com/repos/rust-lang/rust/commits/12cd71f4d3ea6df9c2093781d55134cd9651d754", "html_url": "https://github.com/rust-lang/rust/commit/12cd71f4d3ea6df9c2093781d55134cd9651d754"}, {"sha": "b78c118b09dbc34d142532973800e3ee896a2771", "url": "https://api.github.com/repos/rust-lang/rust/commits/b78c118b09dbc34d142532973800e3ee896a2771", "html_url": "https://github.com/rust-lang/rust/commit/b78c118b09dbc34d142532973800e3ee896a2771"}], "stats": {"total": 375, "additions": 293, "deletions": 82}, "files": [{"sha": "abf77acb8c7adeddaf49d2df92c5f86d13365cb1", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -2147,7 +2147,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         }\n                     }\n \n-                    CastKind::PointerAddress => {\n+                    CastKind::PointerExposeAddress => {\n                         let ty_from = op.ty(body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(*ty);"}, {"sha": "58bec183c94aa52aee6d0fb3d063ef3790cad4f8", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -607,7 +607,11 @@ fn codegen_stmt<'tcx>(\n                     let operand = codegen_operand(fx, operand);\n                     lval.write_cvalue(fx, operand.cast_pointer_to(to_layout));\n                 }\n-                Rvalue::Cast(CastKind::Misc | CastKind::PointerAddress, ref operand, to_ty) => {\n+                Rvalue::Cast(\n+                    CastKind::Misc | CastKind::PointerExposeAddress,\n+                    ref operand,\n+                    to_ty,\n+                ) => {\n                     let operand = codegen_operand(fx, operand);\n                     let from_ty = operand.layout().ty;\n                     let to_ty = fx.monomorphize(to_ty);"}, {"sha": "6ff8d4aa4421694587df6627ac786e8161acfd9a", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let cast = bx.cx().layout_of(self.monomorphize(mir_cast_ty));\n \n                 let val = match *kind {\n-                    mir::CastKind::PointerAddress => {\n+                    mir::CastKind::PointerExposeAddress => {\n                         assert!(bx.cx().is_backend_immediate(cast));\n                         let llptr = operand.immediate();\n                         let llcast_ty = bx.cx().immediate_backend_type(cast);"}, {"sha": "520ae409e6b9fa08f1191fa05ba28f41e3ee49c8", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -31,9 +31,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.unsize_into(src, cast_ty, dest)?;\n             }\n \n-            PointerAddress => {\n+            PointerExposeAddress => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.pointer_address_cast(&src, cast_ty)?;\n+                let res = self.pointer_expose_address_cast(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n@@ -184,7 +184,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n     }\n \n-    pub fn pointer_address_cast(\n+    pub fn pointer_expose_address_cast(\n         &mut self,\n         src: &ImmTy<'tcx, M::PointerTag>,\n         cast_ty: Ty<'tcx>,"}, {"sha": "c07680515f4e7125f87555bb1aac46ef1fc76ee4", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -542,7 +542,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 // in the type of any local, which also excludes casts).\n             }\n \n-            Rvalue::Cast(CastKind::PointerAddress, _, _) => {\n+            Rvalue::Cast(CastKind::PointerExposeAddress, _, _) => {\n                 self.check_op(ops::RawPtrToIntCast);\n             }\n "}, {"sha": "cf5d7b6c70a30f09c0d9f57a60806a6d58f5e789", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -502,7 +502,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             Rvalue::ThreadLocalRef(_) => return Err(Unpromotable),\n \n             // ptr-to-int casts are not possible in consts and thus not promotable\n-            Rvalue::Cast(CastKind::PointerAddress, _, _) => return Err(Unpromotable),\n+            Rvalue::Cast(CastKind::PointerExposeAddress, _, _) => return Err(Unpromotable),\n \n             // int-to-ptr casts are fine, they just use the integer value at pointer type.\n             Rvalue::Cast(_, operand, _) => {"}, {"sha": "e9e7065ec03cc744b90b8bda4a96c903926b8ec2", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -1715,6 +1715,7 @@ impl EmitterWriter {\n \n     fn emit_suggestion_default(\n         &mut self,\n+        span: &MultiSpan,\n         suggestion: &CodeSuggestion,\n         args: &FluentArgs<'_>,\n         level: &Level,\n@@ -1766,6 +1767,30 @@ impl EmitterWriter {\n                 None,\n             }\n \n+            if let Some(span) = span.primary_span() {\n+                // Compare the primary span of the diagnostic with the span of the suggestion\n+                // being emitted.  If they belong to the same file, we don't *need* to show the\n+                // file name, saving in verbosity, but if it *isn't* we do need it, otherwise we're\n+                // telling users to make a change but not clarifying *where*.\n+                let loc = sm.lookup_char_pos(parts[0].span.lo());\n+                if loc.file.name != sm.span_to_filename(span) && loc.file.name.is_real() {\n+                    buffer.puts(row_num - 1, 0, \"--> \", Style::LineNumber);\n+                    buffer.append(\n+                        row_num - 1,\n+                        &format!(\n+                            \"{}:{}:{}\",\n+                            sm.filename_for_diagnostics(&loc.file.name),\n+                            sm.doctest_offset_line(&loc.file.name, loc.line),\n+                            loc.col.0 + 1,\n+                        ),\n+                        Style::LineAndColumn,\n+                    );\n+                    for _ in 0..max_line_num_len {\n+                        buffer.prepend(row_num - 1, \" \", Style::NoStyle);\n+                    }\n+                    row_num += 1;\n+                }\n+            }\n             let show_code_change = if has_deletion && !is_multiline {\n                 DisplaySuggestion::Diff\n             } else if (parts.len() != 1 || parts[0].snippet.trim() != complete.trim())\n@@ -1787,7 +1812,7 @@ impl EmitterWriter {\n             assert!(!file_lines.lines.is_empty() || parts[0].span.is_dummy());\n \n             let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n-            draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n+            draw_col_separator_no_space(&mut buffer, row_num - 1, max_line_num_len + 1);\n             let mut lines = complete.lines();\n             if lines.clone().next().is_none() {\n                 // Account for a suggestion to completely remove a line(s) with whitespace (#94192).\n@@ -2046,9 +2071,13 @@ impl EmitterWriter {\n                             ) {\n                                 panic!(\"failed to emit error: {}\", e);\n                             }\n-                        } else if let Err(e) =\n-                            self.emit_suggestion_default(sugg, args, &Level::Help, max_line_num_len)\n-                        {\n+                        } else if let Err(e) = self.emit_suggestion_default(\n+                            span,\n+                            sugg,\n+                            args,\n+                            &Level::Help,\n+                            max_line_num_len,\n+                        ) {\n                             panic!(\"failed to emit error: {}\", e);\n                         };\n                     }"}, {"sha": "d9cdca8bcb5d72f31d9209c71cd589854d7de5f9", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -2607,16 +2607,17 @@ static_assert_size!(Rvalue<'_>, 40);\n impl<'tcx> Rvalue<'tcx> {\n     #[inline]\n     pub fn is_pointer_int_cast(&self) -> bool {\n-        matches!(self, Rvalue::Cast(CastKind::PointerAddress, _, _))\n+        matches!(self, Rvalue::Cast(CastKind::PointerExposeAddress, _, _))\n     }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum CastKind {\n     Misc,\n-    /// A pointer to address cast. A cast between a pointer and an integer type,\n-    /// or between a function pointer and an integer type.\n-    PointerAddress,\n+    /// An exposing pointer to address cast. A cast between a pointer and an integer type, or\n+    /// between a function pointer and an integer type.\n+    /// See the docs on `expose_addr` for more details.\n+    PointerExposeAddress,\n     Pointer(PointerCast),\n }\n "}, {"sha": "7d08b20631e477c3a58d25dc57924bea4b3ba371", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let cast_ty = CastTy::from_ty(expr.ty);\n                 let cast_kind = match (from_ty, cast_ty) {\n                     (Some(CastTy::Ptr(_) | CastTy::FnPtr), Some(CastTy::Int(_))) => {\n-                        CastKind::PointerAddress\n+                        CastKind::PointerExposeAddress\n                     }\n                     (_, _) => CastKind::Misc,\n                 };"}, {"sha": "ee8e41620019a744af79cc90f15901de929bbd04", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -1,8 +1,7 @@\n use super::pat::Expected;\n-use super::ty::{AllowPlus, RecoverQuestionMark};\n use super::{\n-    BlockMode, CommaRecoveryMode, Parser, PathStyle, RecoverColon, RecoverComma, Restrictions,\n-    SemiColonMode, SeqSep, TokenExpectType, TokenType,\n+    BlockMode, CommaRecoveryMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep,\n+    TokenExpectType, TokenType,\n };\n \n use crate::lexer::UnmatchedBrace;\n@@ -1233,26 +1232,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn maybe_report_ambiguous_plus(\n-        &mut self,\n-        allow_plus: AllowPlus,\n-        impl_dyn_multi: bool,\n-        ty: &Ty,\n-    ) {\n-        if matches!(allow_plus, AllowPlus::No) && impl_dyn_multi {\n+    pub(super) fn maybe_report_ambiguous_plus(&mut self, impl_dyn_multi: bool, ty: &Ty) {\n+        if impl_dyn_multi {\n             self.sess.emit_err(AmbiguousPlus { sum_ty: pprust::ty_to_string(&ty), span: ty.span });\n         }\n     }\n \n     /// Swift lets users write `Ty?` to mean `Option<Ty>`. Parse the construct and recover from it.\n-    pub(super) fn maybe_recover_from_question_mark(\n-        &mut self,\n-        ty: P<Ty>,\n-        recover_question_mark: RecoverQuestionMark,\n-    ) -> P<Ty> {\n-        if let RecoverQuestionMark::No = recover_question_mark {\n-            return ty;\n-        }\n+    pub(super) fn maybe_recover_from_question_mark(&mut self, ty: P<Ty>) -> P<Ty> {\n         if self.token == token::Question {\n             self.bump();\n             self.struct_span_err(self.prev_token.span, \"invalid `?` in type\")\n@@ -1272,13 +1259,9 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn maybe_recover_from_bad_type_plus(\n-        &mut self,\n-        allow_plus: AllowPlus,\n-        ty: &Ty,\n-    ) -> PResult<'a, ()> {\n+    pub(super) fn maybe_recover_from_bad_type_plus(&mut self, ty: &Ty) -> PResult<'a, ()> {\n         // Do not add `+` to expected tokens.\n-        if matches!(allow_plus, AllowPlus::No) || !self.token.is_like_plus() {\n+        if !self.token.is_like_plus() {\n             return Ok(());\n         }\n \n@@ -1444,10 +1427,9 @@ impl<'a> Parser<'a> {\n     pub(super) fn maybe_recover_from_bad_qpath<T: RecoverQPath>(\n         &mut self,\n         base: P<T>,\n-        allow_recovery: bool,\n     ) -> PResult<'a, P<T>> {\n         // Do not add `::` to expected tokens.\n-        if allow_recovery && self.token == token::ModSep {\n+        if self.token == token::ModSep {\n             if let Some(ty) = base.to_ty() {\n                 return self.maybe_recover_from_bad_qpath_stage_2(ty.span, ty);\n             }\n@@ -1593,7 +1575,7 @@ impl<'a> Parser<'a> {\n             _ => ExprKind::Await(expr),\n         };\n         let expr = self.mk_expr(lo.to(sp), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     fn recover_await_macro(&mut self) -> PResult<'a, (Span, P<Expr>, bool)> {\n@@ -2457,10 +2439,9 @@ impl<'a> Parser<'a> {\n     pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n         &mut self,\n         mut first_pat: P<Pat>,\n-        ra: RecoverColon,\n         expected: Expected,\n     ) -> P<Pat> {\n-        if RecoverColon::Yes != ra || token::Colon != self.token.kind {\n+        if token::Colon != self.token.kind {\n             return first_pat;\n         }\n         if !matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n@@ -2594,10 +2575,9 @@ impl<'a> Parser<'a> {\n     pub(crate) fn maybe_recover_unexpected_comma(\n         &mut self,\n         lo: Span,\n-        rc: RecoverComma,\n         rt: CommaRecoveryMode,\n     ) -> PResult<'a, ()> {\n-        if rc == RecoverComma::No || self.token != token::Comma {\n+        if self.token != token::Comma {\n             return Ok(());\n         }\n "}, {"sha": "63c7decbb2fe65103185ef93646d8883de14792b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -1417,7 +1417,7 @@ impl<'a> Parser<'a> {\n         match self.parse_opt_lit() {\n             Some(literal) => {\n                 let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal), attrs);\n-                self.maybe_recover_from_bad_qpath(expr, true)\n+                self.maybe_recover_from_bad_qpath(expr)\n             }\n             None => self.try_macro_suggestion(),\n         }\n@@ -1444,7 +1444,7 @@ impl<'a> Parser<'a> {\n             ExprKind::Tup(es)\n         };\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     fn parse_array_or_repeat_expr(\n@@ -1481,7 +1481,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     fn parse_path_start_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n@@ -1519,7 +1519,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let expr = self.mk_expr(lo.to(hi), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n@@ -1604,7 +1604,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"do\" \"yeet\" expr?`.\n@@ -1619,7 +1619,7 @@ impl<'a> Parser<'a> {\n         let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::yeet_expr, span);\n         let expr = self.mk_expr(span, kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"break\" (('label (:? expr)?) | expr?)` with `\"break\"` token already eaten.\n@@ -1679,7 +1679,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n         let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Break(label, kind), attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"yield\" expr?`.\n@@ -1689,7 +1689,7 @@ impl<'a> Parser<'a> {\n         let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::generators, span);\n         let expr = self.mk_expr(span, kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Returns a string literal if the next token is a string literal."}, {"sha": "2ad3f3ec19d572a4b80d4426e07eeac487b918a2", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -100,8 +100,10 @@ impl<'a> Parser<'a> {\n         };\n \n         // Parse the first pattern (`p_0`).\n-        let first_pat = self.parse_pat_no_top_alt(expected)?;\n-        self.maybe_recover_unexpected_comma(first_pat.span, rc, rt)?;\n+        let mut first_pat = self.parse_pat_no_top_alt(expected)?;\n+        if rc == RecoverComma::Yes {\n+            self.maybe_recover_unexpected_comma(first_pat.span, rt)?;\n+        }\n \n         // If the next token is not a `|`,\n         // this is not an or-pattern and we should exit here.\n@@ -111,7 +113,9 @@ impl<'a> Parser<'a> {\n             // This complicated procedure is done purely for diagnostics UX.\n \n             // Check if the user wrote `foo:bar` instead of `foo::bar`.\n-            let first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, ra, expected);\n+            if ra == RecoverColon::Yes {\n+                first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, expected);\n+            }\n \n             if let Some(leading_vert_span) = leading_vert_span {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n@@ -139,7 +143,9 @@ impl<'a> Parser<'a> {\n                 err.span_label(lo, WHILE_PARSING_OR_MSG);\n                 err\n             })?;\n-            self.maybe_recover_unexpected_comma(pat.span, rc, rt)?;\n+            if rc == RecoverComma::Yes {\n+                self.maybe_recover_unexpected_comma(pat.span, rt)?;\n+            }\n             pats.push(pat);\n         }\n         let or_pattern_span = lo.to(self.prev_token.span);\n@@ -408,7 +414,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let pat = self.mk_pat(lo.to(self.prev_token.span), pat);\n-        let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n+        let pat = self.maybe_recover_from_bad_qpath(pat)?;\n         let pat = self.recover_intersection_pat(pat)?;\n \n         if !allow_range_pat {"}, {"sha": "7907ec44e98e9682554c741a9b3152c4e08a68d4", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -180,7 +180,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Since none of the above applied, this is an expression statement macro.\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n-            let e = self.maybe_recover_from_bad_qpath(e, true)?;\n+            let e = self.maybe_recover_from_bad_qpath(e)?;\n             let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n             StmtKind::Expr(e)"}, {"sha": "dee025cfd3c8a5659a617a403a0f977394e41ccb", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -312,13 +312,18 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = lo.to(self.prev_token.span);\n-        let ty = self.mk_ty(span, kind);\n+        let mut ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n-        self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);\n-        self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n-        let ty = self.maybe_recover_from_question_mark(ty, recover_question_mark);\n-        self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n+        if matches!(allow_plus, AllowPlus::Yes) {\n+            self.maybe_recover_from_bad_type_plus(&ty)?;\n+        } else {\n+            self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty);\n+        }\n+        if let RecoverQuestionMark::Yes = recover_question_mark {\n+            ty = self.maybe_recover_from_question_mark(ty);\n+        }\n+        if allow_qpath_recovery { self.maybe_recover_from_bad_qpath(ty) } else { Ok(ty) }\n     }\n \n     /// Parses either:"}, {"sha": "1fbf592c2325b4285e6daa9baab07b584dfd019c", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -1622,6 +1622,122 @@ impl<T> *mut [T] {\n         metadata(self)\n     }\n \n+    /// Returns `true` if the raw slice has a length of 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_len)]\n+    ///\n+    /// let mut a = [1, 2, 3];\n+    /// let ptr = &mut a as *mut [_];\n+    /// assert!(!ptr.is_empty());\n+    /// ```\n+    #[inline(always)]\n+    #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n+    #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n+    pub const fn is_empty(self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    /// Divides one mutable raw slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `mid` must be [in-bounds] of the underlying [allocated object].\n+    /// Which means `self` must be dereferenceable and span a single allocation\n+    /// that is at least `mid * size_of::<T>()` bytes long. Not upholding these\n+    /// requirements is *[undefined behavior]* even if the resulting pointers are not used.\n+    ///\n+    /// Since `len` being in-bounds it is not a safety invariant of `*mut [T]` the\n+    /// safety requirements of this method are the same as for [`split_at_mut_unchecked`].\n+    /// The explicit bounds check is only as useful as `len` is correct.\n+    ///\n+    /// [`split_at_mut_unchecked`]: #method.split_at_mut_unchecked\n+    /// [in-bounds]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(raw_slice_split)]\n+    /// #![feature(slice_ptr_get)]\n+    ///\n+    /// let mut v = [1, 0, 3, 0, 5, 6];\n+    /// let ptr = &mut v as *mut [_];\n+    /// unsafe {\n+    ///     let (left, right) = ptr.split_at_mut(2);\n+    ///     assert_eq!(&*left, [1, 0]);\n+    ///     assert_eq!(&*right, [3, 0, 5, 6]);\n+    /// }\n+    /// ```\n+    #[inline(always)]\n+    #[track_caller]\n+    #[unstable(feature = \"raw_slice_split\", issue = \"95595\")]\n+    pub unsafe fn split_at_mut(self, mid: usize) -> (*mut [T], *mut [T]) {\n+        assert!(mid <= self.len());\n+        // SAFETY: The assert above is only a safety-net as long as `self.len()` is correct\n+        // The actual safety requirements of this function are the same as for `split_at_mut_unchecked`\n+        unsafe { self.split_at_mut_unchecked(mid) }\n+    }\n+\n+    /// Divides one mutable raw slice into two at an index, without doing bounds checking.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Safety\n+    ///\n+    /// `mid` must be [in-bounds] of the underlying [allocated object].\n+    /// Which means `self` must be dereferenceable and span a single allocation\n+    /// that is at least `mid * size_of::<T>()` bytes long. Not upholding these\n+    /// requirements is *[undefined behavior]* even if the resulting pointers are not used.\n+    ///\n+    /// [in-bounds]: #method.add\n+    /// [out-of-bounds index]: #method.add\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(raw_slice_split)]\n+    ///\n+    /// let mut v = [1, 0, 3, 0, 5, 6];\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// unsafe {\n+    ///     let ptr = &mut v as *mut [_];\n+    ///     let (left, right) = ptr.split_at_mut_unchecked(2);\n+    ///     assert_eq!(&*left, [1, 0]);\n+    ///     assert_eq!(&*right, [3, 0, 5, 6]);\n+    ///     (&mut *left)[1] = 2;\n+    ///     (&mut *right)[1] = 4;\n+    /// }\n+    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    #[inline(always)]\n+    #[unstable(feature = \"raw_slice_split\", issue = \"95595\")]\n+    pub unsafe fn split_at_mut_unchecked(self, mid: usize) -> (*mut [T], *mut [T]) {\n+        let len = self.len();\n+        let ptr = self.as_mut_ptr();\n+\n+        // SAFETY: Caller must pass a valid pointer and an index that is in-bounds.\n+        let tail = unsafe { ptr.add(mid) };\n+        (\n+            crate::ptr::slice_from_raw_parts_mut(ptr, mid),\n+            crate::ptr::slice_from_raw_parts_mut(tail, len - mid),\n+        )\n+    }\n+\n     /// Returns a raw pointer to the slice's buffer.\n     ///\n     /// This is equivalent to casting `self` to `*mut T`, but more type-safe.\n@@ -1645,9 +1761,10 @@ impl<T> *mut [T] {\n     /// Returns a raw pointer to an element or subslice, without doing bounds\n     /// checking.\n     ///\n-    /// Calling this method with an out-of-bounds index or when `self` is not dereferenceable\n+    /// Calling this method with an [out-of-bounds index] or when `self` is not dereferenceable\n     /// is *[undefined behavior]* even if the resulting pointer is not used.\n     ///\n+    /// [out-of-bounds index]: #method.add\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples"}, {"sha": "9f26ccc74d1822d1f8d1ee2926054f8a4525480f", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::def_id::DefId;\n pub(crate) use renderer::{run_format, FormatRenderer};\n \n use crate::clean::{self, ItemId};\n+use cache::Cache;\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n@@ -60,4 +61,28 @@ impl Impl {\n             }\n         }\n     }\n+\n+    // Returns true if this is an implementation on a \"local\" type, meaning:\n+    // the type is in the current crate, or the type and the trait are both\n+    // re-exported by the current crate.\n+    pub(crate) fn is_on_local_type(&self, cache: &Cache) -> bool {\n+        let for_type = &self.inner_impl().for_;\n+        if let Some(for_type_did) = for_type.def_id(cache) {\n+            // The \"for\" type is local if it's in the paths for the current crate.\n+            if cache.paths.contains_key(&for_type_did) {\n+                return true;\n+            }\n+            if let Some(trait_did) = self.trait_did() {\n+                // The \"for\" type and the trait are from the same crate. That could\n+                // be different from the current crate, for instance when both were\n+                // re-exported from some other crate. But they are local with respect to\n+                // each other.\n+                if for_type_did.krate == trait_did.krate {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        };\n+        true\n+    }\n }"}, {"sha": "0b801a20995d3c9d985b31b6e7a95b807e2352bc", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -2285,9 +2285,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n         let mut res = implementors\n             .iter()\n-            .filter(|i| {\n-                i.inner_impl().for_.def_id(cache).map_or(false, |d| !cache.paths.contains_key(&d))\n-            })\n+            .filter(|i| !i.is_on_local_type(cache))\n             .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n             .collect::<Vec<_>>();\n "}, {"sha": "8683e6dfcd99e410cdcb82f342d1b8dd0aaffa7a", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -822,9 +822,8 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             }\n         }\n \n-        let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl().for_.def_id(cache).map_or(true, |d| cache.paths.contains_key(&d))\n-        });\n+        let (local, foreign) =\n+            implementors.iter().partition::<Vec<_>, _>(|i| i.is_on_local_type(cache));\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             local.iter().partition(|i| i.inner_impl().kind.is_auto());"}, {"sha": "6ea33d763b185d580bccdc3d5afbab4b92e3bb66", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -9,7 +9,7 @@ use crate::visit::DocVisitor;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::DefIdTree;\n+use rustc_middle::ty::{self, DefIdTree};\n use rustc_span::symbol::sym;\n \n pub(crate) const COLLECT_TRAIT_IMPLS: Pass = Pass {\n@@ -81,8 +81,35 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n             // Do not calculate blanket impl list for docs that are not going to be rendered.\n             // While the `impl` blocks themselves are only in `libcore`, the module with `doc`\n             // attached is directly included in `libstd` as well.\n+            let tcx = cx.tcx;\n             if did.is_local() {\n-                for def_id in prim.impls(cx.tcx) {\n+                for def_id in prim.impls(tcx).filter(|def_id| {\n+                    // Avoid including impl blocks with filled-in generics.\n+                    // https://github.com/rust-lang/rust/issues/94937\n+                    //\n+                    // FIXME(notriddle): https://github.com/rust-lang/rust/issues/97129\n+                    //\n+                    // This tactic of using inherent impl blocks for getting\n+                    // auto traits and blanket impls is a hack. What we really\n+                    // want is to check if `[T]` impls `Send`, which has\n+                    // nothing to do with the inherent impl.\n+                    //\n+                    // Rustdoc currently uses these `impl` block as a source of\n+                    // the `Ty`, as well as the `ParamEnv`, `SubstsRef`, and\n+                    // `Generics`. To avoid relying on the `impl` block, these\n+                    // things would need to be created from wholecloth, in a\n+                    // form that is valid for use in type inference.\n+                    let ty = tcx.type_of(def_id);\n+                    match ty.kind() {\n+                        ty::Slice(ty)\n+                        | ty::Ref(_, ty, _)\n+                        | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n+                            matches!(ty.kind(), ty::Param(..))\n+                        }\n+                        ty::Tuple(tys) => tys.iter().all(|ty| matches!(ty.kind(), ty::Param(..))),\n+                        _ => true,\n+                    }\n+                }) {\n                     let impls = get_auto_trait_and_blanket_impls(cx, def_id);\n                     new_items_external.extend(impls.filter(|i| cx.inlined.insert(i.item_id)));\n                 }"}, {"sha": "84d72202d527eee6c1ba526700dbed6ae51b0293", "filename": "src/test/mir-opt/const_prop/const_prop_fails_gracefully.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -21,7 +21,7 @@\n                                            // + span: $DIR/const_prop_fails_gracefully.rs:7:13: 7:16\n                                            // + literal: Const { ty: &i32, val: Unevaluated(FOO, [], None) }\n           _2 = &raw const (*_3);           // scope 0 at $DIR/const_prop_fails_gracefully.rs:7:13: 7:16\n-          _1 = move _2 as usize (PointerAddress); // scope 0 at $DIR/const_prop_fails_gracefully.rs:7:13: 7:39\n+          _1 = move _2 as usize (PointerExposeAddress); // scope 0 at $DIR/const_prop_fails_gracefully.rs:7:13: 7:39\n           StorageDead(_2);                 // scope 0 at $DIR/const_prop_fails_gracefully.rs:7:38: 7:39\n           StorageDead(_3);                 // scope 0 at $DIR/const_prop_fails_gracefully.rs:7:39: 7:40\n           StorageLive(_4);                 // scope 1 at $DIR/const_prop_fails_gracefully.rs:8:5: 8:12"}, {"sha": "04724b13ca64ce3c9a7067727753da0f669a7403", "filename": "src/test/mir-opt/const_prop/reify_fn_ptr.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.main.ConstProp.diff?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -17,7 +17,7 @@\n                                            // mir::Constant\n                                            // + span: $DIR/reify_fn_ptr.rs:4:13: 4:17\n                                            // + literal: Const { ty: fn() {main}, val: Value(Scalar(<ZST>)) }\n-          _2 = move _3 as usize (PointerAddress); // scope 0 at $DIR/reify_fn_ptr.rs:4:13: 4:26\n+          _2 = move _3 as usize (PointerExposeAddress); // scope 0 at $DIR/reify_fn_ptr.rs:4:13: 4:26\n           StorageDead(_3);                 // scope 0 at $DIR/reify_fn_ptr.rs:4:25: 4:26\n           _1 = move _2 as *const fn() (Misc); // scope 0 at $DIR/reify_fn_ptr.rs:4:13: 4:41\n           StorageDead(_2);                 // scope 0 at $DIR/reify_fn_ptr.rs:4:40: 4:41"}, {"sha": "2331f63ecdd42199d276193d4dad10fe0f930f07", "filename": "src/test/mir-opt/dead-store-elimination/provenance_soundness.pointer_to_int.DeadStoreElimination.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.pointer_to_int.DeadStoreElimination.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.pointer_to_int.DeadStoreElimination.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.pointer_to_int.DeadStoreElimination.diff?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -19,12 +19,12 @@\n           StorageLive(_2);                 // scope 0 at $DIR/provenance_soundness.rs:8:9: 8:11\n           StorageLive(_3);                 // scope 0 at $DIR/provenance_soundness.rs:8:14: 8:15\n           _3 = _1;                         // scope 0 at $DIR/provenance_soundness.rs:8:14: 8:15\n-          _2 = move _3 as usize (PointerAddress); // scope 0 at $DIR/provenance_soundness.rs:8:14: 8:24\n+          _2 = move _3 as usize (PointerExposeAddress); // scope 0 at $DIR/provenance_soundness.rs:8:14: 8:24\n           StorageDead(_3);                 // scope 0 at $DIR/provenance_soundness.rs:8:23: 8:24\n           StorageLive(_4);                 // scope 1 at $DIR/provenance_soundness.rs:9:9: 9:11\n           StorageLive(_5);                 // scope 1 at $DIR/provenance_soundness.rs:9:14: 9:15\n           _5 = _1;                         // scope 1 at $DIR/provenance_soundness.rs:9:14: 9:15\n-          _4 = move _5 as isize (PointerAddress); // scope 1 at $DIR/provenance_soundness.rs:9:14: 9:24\n+          _4 = move _5 as isize (PointerExposeAddress); // scope 1 at $DIR/provenance_soundness.rs:9:14: 9:24\n           StorageDead(_5);                 // scope 1 at $DIR/provenance_soundness.rs:9:23: 9:24\n           _0 = const ();                   // scope 0 at $DIR/provenance_soundness.rs:7:32: 10:2\n           StorageDead(_4);                 // scope 1 at $DIR/provenance_soundness.rs:10:1: 10:2"}, {"sha": "a8cb16ec34cc01cffb3803c64fab6d144d6dd2e7", "filename": "src/test/rustdoc/issue-75588.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Frustdoc%2Fissue-75588.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Frustdoc%2Fissue-75588.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-75588.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -13,5 +13,5 @@ extern crate real_gimli;\n // @!has foo/trait.Deref.html '//*[@id=\"impl-Deref-for-EndianSlice\"]//h3[@class=\"code-header in-band\"]' 'impl Deref for EndianSlice'\n pub use realcore::Deref;\n \n-// @has foo/trait.Join.html '//*[@id=\"impl-Join-for-Foo\"]//h3[@class=\"code-header in-band\"]' 'impl Join for Foo'\n+// @has foo/trait.Join.html '//*[@id=\"impl-Join\"]//h3[@class=\"code-header in-band\"]' 'impl Join for Foo'\n pub use realcore::Join;"}, {"sha": "b3f511bc1f153fc423b713ea2866bccc7cc4d65f", "filename": "src/test/rustdoc/primitive-slice-auto-trait.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Frustdoc%2Fprimitive-slice-auto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Frustdoc%2Fprimitive-slice-auto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-slice-auto-trait.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: --crate-type lib --edition 2018\n+\n+#![crate_name = \"foo\"]\n+#![feature(rustdoc_internals)]\n+\n+// @has foo/primitive.slice.html '//a[@class=\"primitive\"]' 'slice'\n+// @has - '//span[@class=\"in-band\"]' 'Primitive Type slice'\n+// @has - '//section[@id=\"main-content\"]//div[@class=\"docblock\"]//p' 'this is a test!'\n+// @has - '//h2[@id=\"synthetic-implementations\"]' 'Auto Trait Implementations'\n+// @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'impl<T> Send for [T] where T: Send'\n+// @has - '//div[@id=\"synthetic-implementations-list\"]//h3' 'impl<T> Sync for [T] where T: Sync'\n+#[doc(primitive = \"slice\")]\n+/// this is a test!\n+mod slice_prim {}"}, {"sha": "2eb3fd56783147fd58047c9f214dadb9ae12fe54", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -5,6 +5,7 @@ LL | impl Bar for Baz { }\n    |      ^^^ type aliases cannot be used as traits\n    |\n help: you might have meant to use `#![feature(trait_alias)]` instead of a `type` alias\n+  --> $DIR/two_files_data.rs:5:1\n    |\n LL | trait Bar = dyn Foo;\n    |"}, {"sha": "7390a007742fcce629a9c166f1c6a79596c7570e", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-94287.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-94287.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-94287.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-94287.stderr?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -6,6 +6,7 @@ LL |     If<{ FRAC <= 32 }>: True,\n    |\n    = note: the crate this constant originates from uses `#![feature(generic_const_exprs)]`\n help: consider enabling this feature\n+  --> $DIR/issue-94287.rs:1:1\n    |\n LL | #![feature(generic_const_exprs)]\n    |"}, {"sha": "570bbac2b21f649d6d1df5ae37c123e786a2ba93", "filename": "src/test/ui/editions/edition-keywords-2015-2018-expansion.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -6,6 +6,7 @@ LL |     produces_async! {}\n    |\n    = note: this error originates in the macro `produces_async` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: escape `async` to use it as an identifier\n+  --> $DIR/auxiliary/edition-kw-macro-2018.rs:7:19\n    |\n LL |     () => (pub fn r#async() {})\n    |                   ++"}, {"sha": "69f275746bdc44be3db5b5552e5cd8e2c0759317", "filename": "src/test/ui/editions/edition-keywords-2018-2018-expansion.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -6,6 +6,7 @@ LL |     produces_async! {}\n    |\n    = note: this error originates in the macro `produces_async` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: escape `async` to use it as an identifier\n+  --> $DIR/auxiliary/edition-kw-macro-2018.rs:7:19\n    |\n LL |     () => (pub fn r#async() {})\n    |                   ++"}, {"sha": "c6e6ea1e096af76068f6be6627d27cd95e66cd24", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -9,6 +9,7 @@ LL |     assert_eq!(a, 0);\n    |\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: you might have forgotten to call this function\n+  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n LL |                 if !(*left_val() == *right_val) {\n    |                               ++"}, {"sha": "0af58bc61f49ea88416d71682d3c51229927efe8", "filename": "src/test/ui/methods/method-on-ambiguous-numeric-type.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Fmethods%2Fmethod-on-ambiguous-numeric-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftest%2Fui%2Fmethods%2Fmethod-on-ambiguous-numeric-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-on-ambiguous-numeric-type.stderr?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -46,6 +46,7 @@ LL |     bar.pow(2);\n    |         ^^^\n    |\n help: you must specify a type for this binding, like `i32`\n+  --> $DIR/auxiliary/macro-in-other-crate.rs:3:29\n    |\n LL |     ($ident:ident) => { let $ident: i32 = 42; }\n    |                             ~~~~~~~~~~~"}, {"sha": "b1c82ac76e8eb149880e19d56f361cb0714113fe", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e838059d66296a3874e85685637aac10c888b240/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e838059d66296a3874e85685637aac10c888b240/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=e838059d66296a3874e85685637aac10c888b240", "patch": "@@ -125,7 +125,7 @@ fn check_rvalue<'tcx>(\n         Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n             check_place(tcx, *place, span, body)\n         },\n-        Rvalue::Cast(CastKind::PointerAddress, _, _) => {\n+        Rvalue::Cast(CastKind::PointerExposeAddress, _, _) => {\n             Err((span, \"casting pointers to ints is unstable in const fn\".into()))\n         },\n         Rvalue::Cast(CastKind::Misc, operand, _) => {"}]}