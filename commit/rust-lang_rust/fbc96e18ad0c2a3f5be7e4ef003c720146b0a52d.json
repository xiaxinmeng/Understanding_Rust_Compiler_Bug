{"sha": "fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzk2ZTE4YWQwYzJhM2Y1YmU3ZTRlZjAwM2M3MjAxNDZiMGE1MmQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-06T08:04:30Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-08T03:41:55Z"}, "message": "Persistent macro scopes.", "tree": {"sha": "ec813e09f1f0d22b0f51898a637768ff8c80fc39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec813e09f1f0d22b0f51898a637768ff8c80fc39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d", "html_url": "https://github.com/rust-lang/rust/commit/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a23bdd27695bb5a3bcef34aac9ef7d2ffc952928", "url": "https://api.github.com/repos/rust-lang/rust/commits/a23bdd27695bb5a3bcef34aac9ef7d2ffc952928", "html_url": "https://github.com/rust-lang/rust/commit/a23bdd27695bb5a3bcef34aac9ef7d2ffc952928"}], "stats": {"total": 266, "additions": 167, "deletions": 99}, "files": [{"sha": "c1c582320549d053ee7ec8b3b495b885b363acc5", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d", "patch": "@@ -13,7 +13,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use macros;\n+use macros::{InvocationData, LegacyImports, LegacyScope};\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use {Module, ModuleS, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n@@ -84,7 +84,7 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, legacy_imports: &mut LegacyImports) {\n         let parent = self.current_module;\n         let name = item.ident.name;\n         let sp = item.span;\n@@ -200,16 +200,9 @@ impl<'b> Resolver<'b> {\n                         LoadedMacroKind::Def(mut def) => {\n                             let name = def.ident.name;\n                             if def.use_locally {\n-                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                                let shadowing =\n-                                    self.resolve_macro_name(Mark::root(), name, false).is_some();\n-                                self.invocations[&Mark::root()].module.get().macros.borrow_mut()\n-                                    .insert(name, macros::NameBinding {\n-                                        ext: Rc::new(ext),\n-                                        expansion: expansion,\n-                                        shadowing: shadowing,\n-                                        span: loaded_macro.import_site,\n-                                    });\n+                                let ext =\n+                                    Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n+                                legacy_imports.insert(name, (ext, loaded_macro.import_site));\n                                 self.macro_names.insert(name);\n                             }\n                             if def.export {\n@@ -250,7 +243,6 @@ impl<'b> Resolver<'b> {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n-                    macros_escape: self.contains_macro_use(&item.attrs),\n                     ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n@@ -520,45 +512,62 @@ impl<'b> Resolver<'b> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n     pub resolver: &'a mut Resolver<'b>,\n-    pub expansion: Mark,\n+    pub legacy_scope: LegacyScope<'b>,\n+    pub legacy_imports: LegacyImports,\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n-    fn visit_invoc(&mut self, id: ast::NodeId) {\n-        let mark = Mark::from_placeholder_id(id);\n-        self.resolver.invocations[&mark].module.set(self.resolver.current_module);\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n+        let invocation = self.resolver.invocations[&Mark::from_placeholder_id(id)];\n+        invocation.module.set(self.resolver.current_module);\n+        invocation.legacy_scope.set(self.legacy_scope);\n+        invocation\n     }\n }\n \n macro_rules! method {\n     ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n         fn $visit(&mut self, node: &$ty) {\n-            match node.node {\n-                $invoc(..) => self.visit_invoc(node.id),\n-                _ => visit::$walk(self, node),\n+            if let $invoc(..) = node.node {\n+                self.visit_invoc(node.id);\n+            } else {\n+                visit::$walk(self, node);\n             }\n         }\n     }\n }\n \n impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n-    method!(visit_stmt:      ast::Stmt,     ast::StmtKind::Mac,       walk_stmt);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n     method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &Item) {\n-        match item.node {\n+        let macro_use = match item.node {\n             ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n-            ItemKind::Mac(..) => return self.visit_invoc(item.id),\n-            _ => {}\n-        }\n+            ItemKind::Mac(..) => {\n+                return self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+            }\n+            ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n+            _ => false,\n+        };\n \n-        let parent = self.resolver.current_module;\n-        self.resolver.build_reduced_graph_for_item(item, self.expansion);\n+        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n+        self.resolver.build_reduced_graph_for_item(item, &mut self.legacy_imports);\n         visit::walk_item(self, item);\n         self.resolver.current_module = parent;\n+        if !macro_use {\n+            self.legacy_scope = legacy_scope;\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n+        if let ast::StmtKind::Mac(..) = stmt.node {\n+            self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n+        } else {\n+            visit::walk_stmt(self, stmt);\n+        }\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n@@ -567,18 +576,20 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n-        let parent = self.resolver.current_module;\n+        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n         self.resolver.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n         self.resolver.current_module = parent;\n+        self.legacy_scope = legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &TraitItem) {\n         let parent = self.resolver.current_module;\n         let def_id = parent.def_id().unwrap();\n \n         if let TraitItemKind::Macro(_) = item.node {\n-            return self.visit_invoc(item.id);\n+            self.visit_invoc(item.id);\n+            return\n         }\n \n         // Add the item to the trait info."}, {"sha": "219c2abff2c3f6aede9c8e66080ae07408f991ce", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d", "patch": "@@ -57,6 +57,7 @@ use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -77,7 +78,7 @@ use std::mem::replace;\n use std::rc::Rc;\n \n use resolve_imports::{ImportDirective, NameResolution};\n-use macros::InvocationData;\n+use macros::{InvocationData, LegacyBinding};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -792,9 +793,6 @@ pub struct ModuleS<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n-\n-    macros: RefCell<FnvHashMap<Name, macros::NameBinding>>,\n-    macros_escape: bool,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n@@ -812,8 +810,6 @@ impl<'a> ModuleS<'a> {\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(true),\n-            macros: RefCell::new(FnvHashMap()),\n-            macros_escape: false,\n         }\n     }\n \n@@ -1087,6 +1083,7 @@ pub struct Resolver<'a> {\n     pub derive_modes: FnvHashMap<Name, Rc<MultiItemModifier>>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n+    builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FnvHashMap<Mark, &'a InvocationData<'a>>,\n@@ -1099,6 +1096,7 @@ pub struct ResolverArenas<'a> {\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n     invocation_data: arena::TypedArena<InvocationData<'a>>,\n+    legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -1126,6 +1124,9 @@ impl<'a> ResolverArenas<'a> {\n                              -> &'a InvocationData<'a> {\n         self.invocation_data.alloc(expansion_data)\n     }\n+    fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n+        self.legacy_bindings.alloc(binding)\n+    }\n }\n \n impl<'a> ty::NodeIdTree for Resolver<'a> {\n@@ -1273,6 +1274,7 @@ impl<'a> Resolver<'a> {\n             derive_modes: FnvHashMap(),\n             crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n+            builtin_macros: FnvHashMap(),\n             invocations: invocations,\n         }\n     }\n@@ -1285,6 +1287,7 @@ impl<'a> Resolver<'a> {\n             import_directives: arena::TypedArena::new(),\n             name_resolutions: arena::TypedArena::new(),\n             invocation_data: arena::TypedArena::new(),\n+            legacy_bindings: arena::TypedArena::new(),\n         }\n     }\n "}, {"sha": "31b0180f6f12240e60fa8fea103297f7a4fe070a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 118, "deletions": 64, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fbc96e18ad0c2a3f5be7e4ef003c720146b0a52d", "patch": "@@ -12,48 +12,66 @@ use {Module, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::map::{self, DefCollector};\n+use rustc::util::nodemap::FnvHashMap;\n use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-// FIXME(jseyfried) Merge with `::NameBinding`.\n-pub struct NameBinding {\n-    pub ext: Rc<SyntaxExtension>,\n-    pub expansion: Mark,\n-    pub shadowing: bool,\n-    pub span: Span,\n-}\n+use syntax_pos::Span;\n \n #[derive(Clone)]\n pub struct InvocationData<'a> {\n-    backtrace: SyntaxContext,\n     pub module: Cell<Module<'a>>,\n     def_index: DefIndex,\n     // True if this expansion is in a `const_integer` position, for example `[u32; m!()]`.\n     // c.f. `DefCollector::visit_ast_const_integer`.\n     const_integer: bool,\n+    // The scope in which the invocation path is resolved.\n+    pub legacy_scope: Cell<LegacyScope<'a>>,\n+    // The smallest scope that includes this invocation's expansion,\n+    // or `Empty` if this invocation has not been expanded yet.\n+    pub expansion: Cell<LegacyScope<'a>>,\n }\n \n impl<'a> InvocationData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n         InvocationData {\n-            backtrace: SyntaxContext::empty(),\n             module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n             const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n         }\n     }\n }\n \n+#[derive(Copy, Clone)]\n+pub enum LegacyScope<'a> {\n+    Empty,\n+    Invocation(&'a InvocationData<'a>), // The scope of the invocation, not including its expansion\n+    Expansion(&'a InvocationData<'a>), // The scope of the invocation, including its expansion\n+    Binding(&'a LegacyBinding<'a>),\n+}\n+\n+pub struct LegacyBinding<'a> {\n+    parent: LegacyScope<'a>,\n+    kind: LegacyBindingKind,\n+}\n+\n+pub enum LegacyBindingKind {\n+    MacroRules(ast::Name, Rc<SyntaxExtension>, Span),\n+    MacroUse(LegacyImports),\n+}\n+\n+pub type LegacyImports = FnvHashMap<ast::Name, (Rc<SyntaxExtension>, Span)>;\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -63,18 +81,36 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let mark = Mark::fresh();\n         let module = self.module_map[&id];\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n-            backtrace: SyntaxContext::empty(),\n             module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n             const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n         }));\n         mark\n     }\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n-        self.collect_def_ids(mark, expansion);\n-        self.current_module = self.invocations[&mark].module.get();\n-        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: self, expansion: mark });\n+        let invocation = self.invocations[&mark];\n+        self.collect_def_ids(invocation, expansion);\n+\n+        self.current_module = invocation.module.get();\n+        let mut visitor = BuildReducedGraphVisitor {\n+            resolver: self,\n+            legacy_scope: LegacyScope::Invocation(invocation),\n+            legacy_imports: FnvHashMap(),\n+        };\n+        expansion.visit_with(&mut visitor);\n+        invocation.expansion.set(visitor.legacy_scope);\n+\n+        if !visitor.legacy_imports.is_empty() {\n+            invocation.legacy_scope.set({\n+                LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+                    parent: invocation.legacy_scope.get(),\n+                    kind: LegacyBindingKind::MacroUse(visitor.legacy_imports),\n+                }))\n+            });\n+        }\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n@@ -83,17 +119,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n         if def.use_locally {\n             let invocation = self.invocations[&scope];\n-            let mut module = invocation.module.get();\n-            while module.macros_escape {\n-                module = module.parent.unwrap();\n-            }\n-            let binding = NameBinding {\n-                ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-                expansion: invocation.backtrace.data().prev_ctxt.data().outer_mark,\n-                shadowing: self.resolve_macro_name(scope, def.ident.name, false).is_some(),\n-                span: def.span,\n-            };\n-            module.macros.borrow_mut().insert(def.ident.name, binding);\n+            let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n+            let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent: invocation.legacy_scope.get(),\n+                kind: LegacyBindingKind::MacroRules(def.ident.name, ext, def.span),\n+            });\n+            invocation.legacy_scope.set(LegacyScope::Binding(binding));\n             self.macro_names.insert(def.ident.name);\n         }\n         if def.export {\n@@ -106,12 +137,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n-        self.graph_root.macros.borrow_mut().insert(ident.name, NameBinding {\n-            ext: ext,\n-            expansion: Mark::root(),\n-            shadowing: false,\n-            span: DUMMY_SP,\n-        });\n+        self.builtin_macros.insert(ident.name, ext);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n@@ -121,8 +147,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n-            match self.invocations[&Mark::root()].module.get().macros.borrow().get(&name) {\n-                Some(binding) => match *binding.ext {\n+            match self.builtin_macros.get(&name) {\n+                Some(ext) => match **ext {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -149,6 +175,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n         };\n \n+        let scope = self.invocations[&scope].legacy_scope.get();\n         self.resolve_macro_name(scope, name, true).or_else(|| {\n             let mut err =\n                 self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n@@ -164,37 +191,63 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn resolve_macro_name(&mut self, scope: Mark, name: ast::Name, record_used: bool)\n-                              -> Option<Rc<SyntaxExtension>> {\n-        let invocation = self.invocations[&scope];\n-        let mut module = invocation.module.get();\n+    fn resolve_macro_name(&mut self,\n+                          mut scope: LegacyScope<'a>,\n+                          name: ast::Name,\n+                          record_used: bool)\n+                          -> Option<Rc<SyntaxExtension>> {\n+        let check_shadowing = |this: &mut Self, relative_depth, scope, span| {\n+            if record_used && relative_depth > 0 &&\n+               this.resolve_macro_name(scope, name, false).is_some() &&\n+               this.macro_shadowing_errors.insert(span) {\n+                let msg = format!(\"`{}` is already in scope\", name);\n+                this.session.struct_span_err(span, &msg)\n+                    .note(\"macro-expanded `macro_rules!`s and `#[macro_use]`s \\\n+                           may not shadow existing macros (see RFC 1560)\")\n+                    .emit();\n+            }\n+        };\n+\n+        let mut relative_depth: u32 = 0;\n         loop {\n-            if let Some(binding) = module.macros.borrow().get(&name) {\n-                let mut backtrace = invocation.backtrace.data();\n-                while binding.expansion != backtrace.outer_mark {\n-                    if backtrace.outer_mark != Mark::root() {\n-                        backtrace = backtrace.prev_ctxt.data();\n-                        continue\n+            scope = match scope {\n+                LegacyScope::Empty => break,\n+                LegacyScope::Expansion(invocation) => {\n+                    if let LegacyScope::Empty = invocation.expansion.get() {\n+                        invocation.legacy_scope.get()\n+                    } else {\n+                        relative_depth += 1;\n+                        invocation.expansion.get()\n                     }\n-\n-                    if record_used && binding.shadowing &&\n-                       self.macro_shadowing_errors.insert(binding.span) {\n-                        let msg = format!(\"`{}` is already in scope\", name);\n-                        self.session.struct_span_err(binding.span, &msg)\n-                            .note(\"macro-expanded `macro_rules!`s and `#[macro_use]`s \\\n-                                   may not shadow existing macros (see RFC 1560)\")\n-                            .emit();\n+                }\n+                LegacyScope::Invocation(invocation) => {\n+                    let new_relative_depth = relative_depth.saturating_sub(1);\n+                    let mut scope = invocation.legacy_scope.get();\n+                    if let LegacyScope::Binding(binding) = scope {\n+                        match binding.kind {\n+                            LegacyBindingKind::MacroUse(ref imports) => {\n+                                if let Some(&(ref ext, span)) = imports.get(&name) {\n+                                    check_shadowing(self, relative_depth, binding.parent, span);\n+                                    return Some(ext.clone());\n+                                }\n+                            },\n+                            LegacyBindingKind::MacroRules(name_, ref ext, span) => {\n+                                if name_ == name {\n+                                    check_shadowing(self, new_relative_depth, binding.parent, span);\n+                                    return Some(ext.clone());\n+                                }\n+                            }\n+                        }\n+                        scope = binding.parent\n                     }\n-                    break\n+                    relative_depth = new_relative_depth;\n+                    scope\n                 }\n-                return Some(binding.ext.clone());\n-            }\n-            match module.parent {\n-                Some(parent) => module = parent,\n-                None => break,\n-            }\n+                _ => unreachable!(),\n+            };\n         }\n-        None\n+\n+        self.builtin_macros.get(&name).cloned()\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n@@ -207,17 +260,18 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn collect_def_ids(&mut self, mark: Mark, expansion: &Expansion) {\n+    fn collect_def_ids(&mut self, invocation: &'a InvocationData<'a>, expansion: &Expansion) {\n         let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n-        let InvocationData { def_index, const_integer, backtrace, .. } = invocations[&mark].clone();\n+        let InvocationData { def_index, const_integer, .. } = *invocation;\n \n         let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n             invocations.entry(invoc.mark).or_insert_with(|| {\n                 arenas.alloc_invocation_data(InvocationData {\n-                    backtrace: backtrace.apply_mark(invoc.mark),\n                     def_index: invoc.def_index,\n                     const_integer: invoc.const_integer,\n                     module: Cell::new(graph_root),\n+                    expansion: Cell::new(LegacyScope::Empty),\n+                    legacy_scope: Cell::new(LegacyScope::Empty),\n                 })\n             });\n         };"}]}