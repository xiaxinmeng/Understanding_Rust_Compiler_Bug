{"sha": "0817b1d3ed26898e7d9ed71f6a2218d912ea6de5", "node_id": "C_kwDOAAsO6NoAKDA4MTdiMWQzZWQyNjg5OGU3ZDllZDcxZjZhMjIxOGQ5MTJlYTZkZTU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-06T23:55:26Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-27T17:56:56Z"}, "message": "Don't deduce a signature that makes a closure cyclic", "tree": {"sha": "1eda03d9c6e80bb47ba06a9b3c712e5186f49888", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1eda03d9c6e80bb47ba06a9b3c712e5186f49888"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5", "html_url": "https://github.com/rust-lang/rust/commit/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b38a6d373cb254697411147c0e49cd2e84864258", "url": "https://api.github.com/repos/rust-lang/rust/commits/b38a6d373cb254697411147c0e49cd2e84864258", "html_url": "https://github.com/rust-lang/rust/commit/b38a6d373cb254697411147c0e49cd2e84864258"}], "stats": {"total": 145, "additions": 122, "deletions": 23}, "files": [{"sha": "8167e7e070ce766a9692880d534db513c7ca2787", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=0817b1d3ed26898e7d9ed71f6a2218d912ea6de5", "patch": "@@ -13,14 +13,15 @@ use rustc_infer::infer::{InferOk, InferResult};\n use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TypeSuperVisitable, TypeVisitor};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use std::cmp;\n use std::iter;\n+use std::ops::ControlFlow;\n \n /// What signature do we *expect* the closure to have from context?\n #[derive(Debug, Clone, TypeFoldable, TypeVisitable)]\n@@ -54,7 +55,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // closure sooner rather than later, so first examine the expected\n         // type, and see if can glean a closure kind from there.\n         let (expected_sig, expected_kind) = match expected.to_option(self) {\n-            Some(ty) => self.deduce_expectations_from_expected_type(ty),\n+            Some(ty) => self.deduce_closure_signature(ty),\n             None => (None, None),\n         };\n         let body = self.tcx.hir().body(closure.body);\n@@ -162,13 +163,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Given the expected type, figures out what it can about this closure we\n     /// are about to type check:\n     #[instrument(skip(self), level = \"debug\")]\n-    fn deduce_expectations_from_expected_type(\n+    fn deduce_closure_signature(\n         &self,\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => self\n-                .deduce_signature_from_predicates(\n+                .deduce_closure_signature_from_predicates(\n+                    expected_ty,\n                     self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n                 ),\n             ty::Dynamic(ref object_type, ..) => {\n@@ -181,7 +183,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .and_then(|did| self.tcx.fn_trait_kind_from_def_id(did));\n                 (sig, kind)\n             }\n-            ty::Infer(ty::TyVar(vid)) => self.deduce_signature_from_predicates(\n+            ty::Infer(ty::TyVar(vid)) => self.deduce_closure_signature_from_predicates(\n+                self.tcx.mk_ty_var(self.root_var(vid)),\n                 self.obligations_for_self_ty(vid).map(|obl| (obl.predicate, obl.cause.span)),\n             ),\n             ty::FnPtr(sig) => {\n@@ -192,8 +195,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn deduce_signature_from_predicates(\n+    fn deduce_closure_signature_from_predicates(\n         &self,\n+        expected_ty: Ty<'tcx>,\n         predicates: impl DoubleEndedIterator<Item = (ty::Predicate<'tcx>, Span)>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let mut expected_sig = None;\n@@ -214,13 +218,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if expected_sig.is_none()\n                 && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n-                expected_sig = self.normalize(\n+                let inferred_sig = self.normalize(\n                     obligation.cause.span,\n                     self.deduce_sig_from_projection(\n                     Some(obligation.cause.span),\n                         bound_predicate.rebind(proj_predicate),\n                     ),\n                 );\n+                // Make sure that we didn't infer a signature that mentions itself.\n+                // This can happen when we elaborate certain supertrait bounds that\n+                // mention projections containing the `Self` type. See \n+                struct MentionsTy<'tcx> {\n+                    expected_ty: Ty<'tcx>,\n+                }\n+                impl<'tcx> TypeVisitor<'tcx> for MentionsTy<'tcx> {\n+                    type BreakTy = ();\n+\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                        if t == self.expected_ty {\n+                            ControlFlow::BREAK\n+                        } else {\n+                            t.super_visit_with(self)\n+                        }\n+                    }\n+                }\n+                if inferred_sig.visit_with(&mut MentionsTy { expected_ty }).is_continue() {\n+                    expected_sig = inferred_sig;\n+                }\n             }\n \n             // Even if we can't infer the full signature, we may be able to"}, {"sha": "dbb06b2ef7a7a345861b9f040faa759a517f5f45", "filename": "src/test/ui/closures/supertrait-hint-cycle.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle.rs?ref=0817b1d3ed26898e7d9ed71f6a2218d912ea6de5", "patch": "@@ -0,0 +1,65 @@\n+// edition:2021\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+#![feature(closure_lifetime_binder)]\n+\n+use std::future::Future;\n+\n+trait AsyncFn<I, R>: FnMut(I) -> Self::Fut {\n+    type Fut: Future<Output = R>;\n+}\n+\n+impl<F, I, R, Fut> AsyncFn<I, R> for F\n+where\n+    Fut: Future<Output = R>,\n+    F: FnMut(I) -> Fut,\n+{\n+    type Fut = Fut;\n+}\n+\n+async fn call<C, R, F>(mut ctx: C, mut f: F) -> Result<R, ()>\n+where\n+    F: for<'a> AsyncFn<&'a mut C, Result<R, ()>>,\n+{\n+    loop {\n+        match f(&mut ctx).await {\n+            Ok(val) => return Ok(val),\n+            Err(_) => continue,\n+        }\n+    }\n+}\n+\n+trait Cap<'a> {}\n+impl<T> Cap<'_> for T {}\n+\n+fn works(ctx: &mut usize) {\n+    let mut inner = 0;\n+\n+    type Ret<'a, 'b: 'a> = impl Future<Output = Result<usize, ()>> + 'a + Cap<'b>;\n+\n+    let callback = for<'a, 'b> |c: &'a mut &'b mut usize| -> Ret<'a, 'b> {\n+        inner += 1;\n+        async move {\n+            let _c = c;\n+            Ok(1usize)\n+        }\n+    };\n+    call(ctx, callback);\n+}\n+\n+fn doesnt_work_but_should(ctx: &mut usize) {\n+    let mut inner = 0;\n+\n+    type Ret<'a, 'b: 'a> = impl Future<Output = Result<usize, ()>> + 'a + Cap<'b>;\n+\n+    call(ctx, for<'a, 'b> |c: &'a mut &'b mut usize| -> Ret<'a, 'b> {\n+        inner += 1;\n+        async move {\n+            let _c = c;\n+            Ok(1usize)\n+        }\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "938c9d9f18ca3e1460e4fe06c4e177f6291494ec", "filename": "src/test/ui/issues/issue-25439.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/src%2Ftest%2Fui%2Fissues%2Fissue-25439.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/src%2Ftest%2Fui%2Fissues%2Fissue-25439.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25439.stderr?ref=0817b1d3ed26898e7d9ed71f6a2218d912ea6de5", "patch": "@@ -1,14 +1,19 @@\n-error[E0644]: closure/generator type that references itself\n-  --> $DIR/issue-25439.rs:8:9\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/issue-25439.rs:8:5\n    |\n LL |     fix(|_, x| x);\n-   |         ^^^^^^^^ cyclic type of infinite size\n+   |     ^^^ ------ found signature defined here\n+   |     |\n+   |     expected due to this\n    |\n-   = note: closures cannot capture themselves or take themselves as argument;\n-           this error may be the result of a recent compiler bug-fix,\n-           see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\n-           for more information\n+   = note: expected closure signature `for<'a> fn(Helper<'a, [closure@$DIR/issue-25439.rs:8:9: 8:15]>, i32) -> _`\n+              found closure signature `fn(_, _) -> _`\n+note: required by a bound in `fix`\n+  --> $DIR/issue-25439.rs:3:33\n+   |\n+LL | fn fix<F>(f: F) -> i32 where F: Fn(Helper<F>, i32) -> i32 {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `fix`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0644`.\n+For more information about this error, try `rustc --explain E0631`."}, {"sha": "cfea13c1127cdd45ddad9480860558b70350c968", "filename": "src/test/ui/unboxed-closures/unboxed-closure-no-cyclic-sig.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-no-cyclic-sig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0817b1d3ed26898e7d9ed71f6a2218d912ea6de5/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-no-cyclic-sig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-no-cyclic-sig.stderr?ref=0817b1d3ed26898e7d9ed71f6a2218d912ea6de5", "patch": "@@ -1,14 +1,19 @@\n-error[E0644]: closure/generator type that references itself\n-  --> $DIR/unboxed-closure-no-cyclic-sig.rs:8:7\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/unboxed-closure-no-cyclic-sig.rs:8:5\n    |\n LL |     g(|_| {  });\n-   |       ^^^^^^^^ cyclic type of infinite size\n+   |     ^ --- found signature defined here\n+   |     |\n+   |     expected due to this\n    |\n-   = note: closures cannot capture themselves or take themselves as argument;\n-           this error may be the result of a recent compiler bug-fix,\n-           see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\n-           for more information\n+   = note: expected closure signature `fn(Option<[closure@$DIR/unboxed-closure-no-cyclic-sig.rs:8:7: 8:10]>) -> _`\n+              found closure signature `fn(_) -> _`\n+note: required by a bound in `g`\n+  --> $DIR/unboxed-closure-no-cyclic-sig.rs:5:24\n+   |\n+LL | fn g<F>(_: F) where F: FnOnce(Option<F>) {}\n+   |                        ^^^^^^^^^^^^^^^^^ required by this bound in `g`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0644`.\n+For more information about this error, try `rustc --explain E0631`."}]}