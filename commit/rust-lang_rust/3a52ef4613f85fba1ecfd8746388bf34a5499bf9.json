{"sha": "3a52ef4613f85fba1ecfd8746388bf34a5499bf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNTJlZjQ2MTNmODVmYmExZWNmZDg3NDYzODhiZjM0YTU0OTliZjk=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-08-19T00:42:11Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-08-28T16:12:54Z"}, "message": "stabilize core::option\n\nPer API meeting\n\n  https://github.com/rust-lang/meeting-minutes/blob/master/Meeting-API-review-2014-08-13.md\n\nMost of the module is marked as stable or unstable; most of the unstable\nitems are awaiting resolution of conventions issues.\n\nHowever, a few methods have been deprecated, either due to lack of use\nor redundancy:\n\n* `take_unwrap`, `get_ref` and `get_mut_ref` (redundant, and we prefer\n  for this functionality to go through an explicit .unwrap)\n* `filtered` and `while`\n* `mutate` and `mutate_or_set`\n* `collect`: this functionality is being moved to a new `FromIterator`\n  impl.\n\nDue to deprecations, this is a:\n\n[breaking-change]", "tree": {"sha": "aa4def00b9f35afaba332be34fc288864de96259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa4def00b9f35afaba332be34fc288864de96259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a52ef4613f85fba1ecfd8746388bf34a5499bf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a52ef4613f85fba1ecfd8746388bf34a5499bf9", "html_url": "https://github.com/rust-lang/rust/commit/3a52ef4613f85fba1ecfd8746388bf34a5499bf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a52ef4613f85fba1ecfd8746388bf34a5499bf9/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d3bd7720c50e3ada4bac77331d43926493be4fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3bd7720c50e3ada4bac77331d43926493be4fe", "html_url": "https://github.com/rust-lang/rust/commit/0d3bd7720c50e3ada4bac77331d43926493be4fe"}], "stats": {"total": 147, "additions": 104, "deletions": 43}, "files": [{"sha": "dbcd943dae6d468c802bc1b1a40a5659950e9c0f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 104, "deletions": 43, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3a52ef4613f85fba1ecfd8746388bf34a5499bf9/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a52ef4613f85fba1ecfd8746388bf34a5499bf9/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=3a52ef4613f85fba1ecfd8746388bf34a5499bf9", "patch": "@@ -141,6 +141,8 @@\n //! }\n //! ```\n \n+#![stable]\n+\n use cmp::{PartialEq, Eq, Ord};\n use default::Default;\n use slice::Slice;\n@@ -155,6 +157,7 @@ use slice;\n \n /// The `Option` type.\n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n+#[stable]\n pub enum Option<T> {\n     /// No value\n     None,\n@@ -173,6 +176,7 @@ impl<T> Option<T> {\n \n     /// Returns `true` if the option is a `Some` value\n     #[inline]\n+    #[stable]\n     pub fn is_some(&self) -> bool {\n         match *self {\n             Some(_) => true,\n@@ -182,6 +186,7 @@ impl<T> Option<T> {\n \n     /// Returns `true` if the option is a `None` value\n     #[inline]\n+    #[stable]\n     pub fn is_none(&self) -> bool {\n         !self.is_some()\n     }\n@@ -207,18 +212,21 @@ impl<T> Option<T> {\n     /// println!(\"still can print num_as_str: {}\", num_as_str);\n     /// ```\n     #[inline]\n+    #[stable]\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n         match *self { Some(ref x) => Some(x), None => None }\n     }\n \n     /// Convert from `Option<T>` to `Option<&mut T>`\n     #[inline]\n+    #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self { Some(ref mut x) => Some(x), None => None }\n     }\n \n     /// Convert from `Option<T>` to `&mut [T]` (without copying)\n     #[inline]\n+    #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n             Some(ref mut x) => {\n@@ -243,6 +251,7 @@ impl<T> Option<T> {\n     /// Fails if the value is a `None` with a custom failure message provided by\n     /// `msg`.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n@@ -262,6 +271,7 @@ impl<T> Option<T> {\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n@@ -271,6 +281,7 @@ impl<T> Option<T> {\n \n     /// Returns the contained value or a default.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n@@ -280,6 +291,7 @@ impl<T> Option<T> {\n \n     /// Returns the contained value or computes it from a closure.\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_else(self, f: || -> T) -> T {\n         match self {\n             Some(x) => x,\n@@ -303,27 +315,42 @@ impl<T> Option<T> {\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn map<U>(self, f: |T| -> U) -> Option<U> {\n         match self { Some(x) => Some(f(x)), None => None }\n     }\n \n     /// Applies a function to the contained value or returns a default.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_or<U>(self, def: U, f: |T| -> U) -> U {\n         match self { None => def, Some(t) => f(t) }\n     }\n \n+    /// Applies a function to the contained value or computes a default.\n+    #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n+    pub fn map_or_else<U>(self, def: || -> U, f: |T| -> U) -> U {\n+        match self { None => def(), Some(t) => f(t) }\n+    }\n+\n+    /// Deprecated.\n+    ///\n     /// Applies a function to the contained value or does nothing.\n     /// Returns true if the contained value was mutated.\n+    #[deprecated = \"removed due to lack of use\"]\n     pub fn mutate(&mut self, f: |T| -> T) -> bool {\n         if self.is_some() {\n             *self = Some(f(self.take_unwrap()));\n             true\n         } else { false }\n     }\n \n+    /// Deprecated.\n+    ///\n     /// Applies a function to the contained value or sets it to a default.\n     /// Returns true if the contained value was mutated, or false if set to the default.\n+    #[deprecated = \"removed due to lack of use\"]\n     pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {\n         if self.is_some() {\n             *self = Some(f(self.take_unwrap()));\n@@ -340,18 +367,21 @@ impl<T> Option<T> {\n \n     /// Returns an iterator over the possibly contained value.\n     #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter<'r>(&'r self) -> Item<&'r T> {\n         Item{opt: self.as_ref()}\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n     #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n     pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n         Item{opt: self.as_mut()}\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n     #[inline]\n+    #[unstable = \"waiting for iterator conventions\"]\n     pub fn move_iter(self) -> Item<T> {\n         Item{opt: self}\n     }\n@@ -362,6 +392,7 @@ impl<T> Option<T> {\n \n     /// Returns `None` if the option is `None`, otherwise returns `optb`.\n     #[inline]\n+    #[stable]\n     pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n         match self {\n             Some(_) => optb,\n@@ -372,6 +403,7 @@ impl<T> Option<T> {\n     /// Returns `None` if the option is `None`, otherwise calls `f` with the\n     /// wrapped value and returns the result.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n@@ -381,6 +413,7 @@ impl<T> Option<T> {\n \n     /// Returns the option if it contains a value, otherwise returns `optb`.\n     #[inline]\n+    #[stable]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -391,6 +424,7 @@ impl<T> Option<T> {\n     /// Returns the option if it contains a value, otherwise calls `f` and\n     /// returns the result.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -404,21 +438,28 @@ impl<T> Option<T> {\n \n     /// Takes the value out of the option, leaving a `None` in its place.\n     #[inline]\n+    #[stable]\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n \n+    /// Deprecated.\n+    ///\n     /// Filters an optional value using a given function.\n     #[inline(always)]\n+    #[deprecated = \"removed due to lack of use\"]\n     pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n         match self {\n             Some(x) => if f(&x) { Some(x) } else { None },\n             None => None\n         }\n     }\n \n+    /// Deprecated.\n+    ///\n     /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n+    #[deprecated = \"removed due to lack of use\"]\n     pub fn while_some(self, f: |v: T| -> Option<T>) {\n         let mut opt = self;\n         loop {\n@@ -433,20 +474,25 @@ impl<T> Option<T> {\n     // Common special cases\n     /////////////////////////////////////////////////////////////////////////\n \n+    /// Deprecated: use `take().unwrap()` instead.\n+    ///\n     /// The option dance. Moves a value out of an option type and returns it,\n     /// replacing the original with `None`.\n     ///\n     /// # Failure\n     ///\n     /// Fails if the value equals `None`.\n     #[inline]\n+    #[deprecated = \"use take().unwrap() instead\"]\n     pub fn take_unwrap(&mut self) -> T {\n         match self.take() {\n             Some(x) => x,\n             None => fail!(\"called `Option::take_unwrap()` on a `None` value\")\n         }\n     }\n \n+    /// Deprecated: use `as_ref().unwrap()` instead.\n+    ///\n     /// Gets an immutable reference to the value inside an option.\n     ///\n     /// # Failure\n@@ -460,13 +506,16 @@ impl<T> Option<T> {\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     #[inline]\n+    #[deprecated = \"use .as_ref().unwrap() instead\"]\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Some(ref x) => x,\n             None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n         }\n     }\n \n+    /// Deprecated: use `as_mut().unwrap()` instead.\n+    ///\n     /// Gets a mutable reference to the value inside an option.\n     ///\n     /// # Failure\n@@ -480,6 +529,7 @@ impl<T> Option<T> {\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     #[inline]\n+    #[deprecated = \"use .as_mut().unwrap() instead\"]\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n             Some(ref mut x) => x,\n@@ -512,6 +562,7 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0i, bad_year);\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -527,6 +578,7 @@ impl<T: Default> Option<T> {\n impl<T> Slice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n+    #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Some(ref x) => slice::ref_slice(x),\n@@ -552,6 +604,7 @@ impl<T> Default for Option<T> {\n /// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n /// methods on `Option`.\n #[deriving(Clone)]\n+#[unstable = \"waiting for iterator conventions\"]\n pub struct Item<A> {\n     opt: Option<A>\n }\n@@ -584,54 +637,62 @@ impl<A> ExactSize<A> for Item<A> {}\n // Free functions\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Takes each element in the `Iterator`: if it is `None`, no further\n-/// elements are taken, and the `None` is returned. Should no `None` occur, a\n-/// vector containing the values of each `Option` is returned.\n-///\n-/// Here is an example which increments every integer in a vector,\n-/// checking for overflow:\n-///\n-/// ```rust\n-/// use std::option;\n-/// use std::uint;\n-///\n-/// let v = vec!(1u, 2u);\n-/// let res: Option<Vec<uint>> = option::collect(v.iter().map(|x: &uint|\n-///     if *x == uint::MAX { None }\n-///     else { Some(x + 1) }\n-/// ));\n-/// assert!(res == Some(vec!(2u, 3u)));\n-/// ```\n+/// Deprecated: use `Iterator::collect` instead.\n #[inline]\n-pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> {\n-    // FIXME(#11084): This could be replaced with Iterator::scan when this\n-    // performance bug is closed.\n-\n-    struct Adapter<Iter> {\n-        iter: Iter,\n-        found_none: bool,\n-    }\n-\n-    impl<T, Iter: Iterator<Option<T>>> Iterator<T> for Adapter<Iter> {\n-        #[inline]\n-        fn next(&mut self) -> Option<T> {\n-            match self.iter.next() {\n-                Some(Some(value)) => Some(value),\n-                Some(None) => {\n-                    self.found_none = true;\n-                    None\n+#[deprecated = \"use Iterator::collect instead\"]\n+pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(mut iter: Iter) -> Option<V> {\n+    iter.collect()\n+}\n+\n+impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n+    /// Takes each element in the `Iterator`: if it is `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur, a\n+    /// container with the values of each `Option` is returned.\n+    ///\n+    /// Here is an example which increments every integer in a vector,\n+    /// checking for overflow:\n+    ///\n+    /// ```rust\n+    /// use std::uint;\n+    ///\n+    /// let v = vec!(1u, 2u);\n+    /// let res: Option<Vec<uint>> = v.iter().map(|x: &uint|\n+    ///     if *x == uint::MAX { None }\n+    ///     else { Some(x + 1) }\n+    /// ).collect();\n+    /// assert!(res == Some(vec!(2u, 3u)));\n+    /// ```\n+    #[inline]\n+    fn from_iter<I: Iterator<Option<A>>>(iter: I) -> Option<V> {\n+        // FIXME(#11084): This could be replaced with Iterator::scan when this\n+        // performance bug is closed.\n+\n+        struct Adapter<Iter> {\n+            iter: Iter,\n+            found_none: bool,\n+        }\n+\n+        impl<T, Iter: Iterator<Option<T>>> Iterator<T> for Adapter<Iter> {\n+            #[inline]\n+            fn next(&mut self) -> Option<T> {\n+                match self.iter.next() {\n+                    Some(Some(value)) => Some(value),\n+                    Some(None) => {\n+                        self.found_none = true;\n+                        None\n+                    }\n+                    None => None,\n                 }\n-                None => None,\n             }\n         }\n-    }\n \n-    let mut adapter = Adapter { iter: iter, found_none: false };\n-    let v: V = FromIterator::from_iter(adapter.by_ref());\n+        let mut adapter = Adapter { iter: iter, found_none: false };\n+        let v: V = FromIterator::from_iter(adapter.by_ref());\n \n-    if adapter.found_none {\n-        None\n-    } else {\n-        Some(v)\n+        if adapter.found_none {\n+            None\n+        } else {\n+            Some(v)\n+        }\n     }\n }"}]}