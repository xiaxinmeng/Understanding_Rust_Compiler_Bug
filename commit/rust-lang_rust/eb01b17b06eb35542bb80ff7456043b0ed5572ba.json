{"sha": "eb01b17b06eb35542bb80ff7456043b0ed5572ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMDFiMTdiMDZlYjM1NTQyYmI4MGZmNzQ1NjA0M2IwZWQ1NTcyYmE=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-09T15:14:15Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-16T13:23:15Z"}, "message": "Complete the removal of ty_nil, ast::LitNil, ast::TyBot and ast::TyUniq\n\n[breaking-change]\n\nThis will break any uses of macros that assumed () being a valid literal.", "tree": {"sha": "75ee1c7184f8f3ea00966c91186c844ca268b3c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75ee1c7184f8f3ea00966c91186c844ca268b3c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb01b17b06eb35542bb80ff7456043b0ed5572ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb01b17b06eb35542bb80ff7456043b0ed5572ba", "html_url": "https://github.com/rust-lang/rust/commit/eb01b17b06eb35542bb80ff7456043b0ed5572ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb01b17b06eb35542bb80ff7456043b0ed5572ba/comments", "author": null, "committer": null, "parents": [{"sha": "08d6774f39743b69c199d79a5c64dbcef58c03d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/08d6774f39743b69c199d79a5c64dbcef58c03d3", "html_url": "https://github.com/rust-lang/rust/commit/08d6774f39743b69c199d79a5c64dbcef58c03d3"}], "stats": {"total": 757, "additions": 350, "deletions": 407}, "files": [{"sha": "1792599783b2cacfcab0bce2ef2ecea112c9e584", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -66,7 +66,6 @@ register_diagnostics!(\n     E0055,\n     E0056,\n     E0057,\n-    E0058,\n     E0059,\n     E0060,\n     E0061,"}, {"sha": "83194efc554b7143796141b25157cf79f468bb7c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -447,7 +447,9 @@ impl LintPass for ImproperCTypes {\n             for input in decl.inputs.iter() {\n                 check_ty(cx, &*input.ty);\n             }\n-            check_ty(cx, &*decl.output)\n+            if let ast::Return(ref ret_ty) = decl.output {\n+                check_ty(cx, &**ret_ty);\n+            }\n         }\n \n         match it.node {\n@@ -735,6 +737,7 @@ impl LintPass for UnusedResults {\n         let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n         match ty::get(t).sty {\n+            ty::ty_tup(ref tys) if tys.is_empty() => return,\n             ty::ty_bool => return,\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) => {"}, {"sha": "3968e6b653429c30c66be9e806dc518d514c1219", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_eval::{compare_const_vals, const_bool, const_float, const_nil, const_val};\n+use middle::const_eval::{compare_const_vals, const_bool, const_float, const_val};\n use middle::const_eval::{const_expr_to_pat, eval_const_expr, lookup_const_by_id};\n use middle::def::*;\n use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n@@ -332,7 +332,6 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n fn const_val_to_expr(value: &const_val) -> P<Expr> {\n     let node = match value {\n         &const_bool(b) => LitBool(b),\n-        &const_nil => LitNil,\n         _ => unreachable!()\n     };\n     P(Expr {\n@@ -402,7 +401,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match ty::get(left_ty).sty {\n-        ty::ty_tup(ref tys) if !tys.is_empty() => PatTup(pats.collect()),\n+        ty::ty_tup(_) => PatTup(pats.collect()),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n@@ -497,9 +496,6 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n         ty::ty_bool =>\n             [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n \n-        ty::ty_tup(ref tys) if tys.is_empty() =>\n-            vec!(ConstantValue(const_nil)),\n-\n         ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),"}, {"sha": "1fd5b81f49924e1307bf04572007c129a85222e8", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -311,8 +311,7 @@ pub enum const_val {\n     const_uint(u64),\n     const_str(InternedString),\n     const_binary(Rc<Vec<u8> >),\n-    const_bool(bool),\n-    const_nil\n+    const_bool(bool)\n }\n \n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n@@ -589,7 +588,6 @@ pub fn lit_to_const(lit: &Lit) -> const_val {\n         LitFloatUnsuffixed(ref n) => {\n             const_float(from_str::<f64>(n.get()).unwrap() as f64)\n         }\n-        LitNil => const_nil,\n         LitBool(b) => const_bool(b)\n     }\n }\n@@ -605,7 +603,6 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n         (&const_str(ref a), &const_str(ref b)) => compare_vals(a, b),\n         (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n         (&const_binary(ref a), &const_binary(ref b)) => compare_vals(a, b),\n-        (&const_nil, &const_nil) => compare_vals((), ()),\n         _ => None\n     }\n }"}, {"sha": "2cfaf8438ae1b776ef86c8a8c2e545a43598c957", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -4285,7 +4285,9 @@ impl<'a> Resolver<'a> {\n                                     _ => {}\n                                 }\n \n-                                this.resolve_type(&*ty_m.decl.output);\n+                                if let ast::Return(ref ret_ty) = ty_m.decl.output {\n+                                    this.resolve_type(&**ret_ty);\n+                                }\n                             });\n                           }\n                           ast::ProvidedMethod(ref m) => {\n@@ -4467,7 +4469,9 @@ impl<'a> Resolver<'a> {\n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    this.resolve_type(&*declaration.output);\n+                    if let ast::Return(ref ret_ty) = declaration.output {\n+                        this.resolve_type(&**ret_ty);\n+                    }\n                 }\n             }\n "}, {"sha": "367fe2845dd14a1cab1266ed1ac4623d16c951fc", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -383,7 +383,11 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for arg in method.pe_fn_decl().inputs.iter() {\n             self.visit_ty(&*arg.ty);\n         }\n-        self.visit_ty(&*method.pe_fn_decl().output);\n+\n+        if let ast::Return(ref ret_ty) = method.pe_fn_decl().output {\n+            self.visit_ty(&**ret_ty);\n+        }\n+\n         // walk the fn body\n         self.nest(method.id, |v| v.visit_block(&*method.pe_body()));\n \n@@ -491,7 +495,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for arg in decl.inputs.iter() {\n             self.visit_ty(&*arg.ty);\n         }\n-        self.visit_ty(&*decl.output);\n+\n+        if let ast::Return(ref ret_ty) = decl.output {\n+            self.visit_ty(&**ret_ty);\n+        }\n \n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n@@ -1136,7 +1143,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 for arg in method_type.decl.inputs.iter() {\n                     self.visit_ty(&*arg.ty);\n                 }\n-                self.visit_ty(&*method_type.decl.output);\n+\n+                if let ast::Return(ref ret_ty) = method_type.decl.output {\n+                    self.visit_ty(&**ret_ty);\n+                }\n \n                 self.process_generic_params(&method_type.generics,\n                                             method_type.span,\n@@ -1352,7 +1362,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 for arg in decl.inputs.iter() {\n                     self.visit_ty(&*arg.ty);\n                 }\n-                self.visit_ty(&*decl.output);\n+\n+                if let ast::Return(ref ret_ty) = decl.output {\n+                    self.visit_ty(&**ret_ty);\n+                }\n \n                 // walk the body\n                 self.nest(ex.id, |v| v.visit_block(&**body));"}, {"sha": "330959d687155c3eef301833cb067032eff24a9d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -81,7 +81,6 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n             }\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n-        ast::LitNil => C_nil(cx),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(ref data) => C_binary_slice(cx, data.as_slice()),\n     }"}, {"sha": "42da0573460be72b41580df43366902aeab9bd1b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -718,7 +718,9 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     macro_rules! ifn (\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx, $name, Type::func([], &$ret), ty::mk_nil(ccx.tcx()));\n+                let f = base::decl_cdecl_fn(\n+                    ccx, $name, Type::func([], &$ret),\n+                    ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }"}, {"sha": "f11ca1eec5a2696f17f352817493b8ab5eba7be9", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -1374,10 +1374,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         let mut signature = Vec::with_capacity(fn_decl.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n-        match fn_decl.output.node {\n-            ast::TyNil => {\n-                signature.push(ptr::null_mut());\n-            }\n+        match fn_decl.output {\n+            ast::Return(ref ret_ty) if ret_ty.node == ast::TyTup(vec![]) =>\n+                signature.push(ptr::null_mut()),\n             _ => {\n                 assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n \n@@ -1738,6 +1737,8 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n     debug!(\"basic_type_metadata: {}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n+        ty::ty_tup(ref elements) if elements.is_empty() =>\n+            (\"()\".to_string(), DW_ATE_unsigned),\n         ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n         ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n@@ -2888,6 +2889,9 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_float(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n+        ty::ty_tup(ref elements) if elements.is_empty() => {\n+            MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n+        }\n         ty::ty_enum(def_id, _) => {\n             prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n         }\n@@ -3669,7 +3673,7 @@ fn compute_debuginfo_type_name(cx: &CrateContext,\n fn push_debuginfo_type_name(cx: &CrateContext,\n                             t: ty::t,\n                             qualified: bool,\n-                            output:&mut String) {\n+                            output: &mut String) {\n     match ty::get(t).sty {\n         ty::ty_bool              => output.push_str(\"bool\"),\n         ty::ty_char              => output.push_str(\"char\"),\n@@ -3697,8 +3701,10 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 push_debuginfo_type_name(cx, component_type, true, output);\n                 output.push_str(\", \");\n             }\n-            output.pop();\n-            output.pop();\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n             output.push(')');\n         },\n         ty::ty_uniq(inner_type) => {"}, {"sha": "97160e7a6d16c2be42fa74d664a09440ffba1418", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 47, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -2131,6 +2131,7 @@ pub fn type_is_scalar(ty: t) -> bool {\n       ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) |\n       ty_bare_fn(..) | ty_ptr(_) => true,\n+      ty_tup(ref tys) if tys.is_empty() => true,\n       _ => false\n     }\n }\n@@ -3777,6 +3778,7 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n         ty_uint(_) | ty_float(_) | ty_str => {\n             ::util::ppaux::ty_to_string(cx, t)\n         }\n+        ty_tup(ref tys) if tys.is_empty() => ::util::ppaux::ty_to_string(cx, t),\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n         ty_uniq(_) => \"box\".to_string(),\n@@ -4771,54 +4773,42 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n // Returns the repeat count for a repeating vector expression.\n pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n-      Ok(ref const_val) => match *const_val {\n-        const_eval::const_int(count) => if count < 0 {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found negative integer\");\n-            0\n-        } else {\n-            count as uint\n-        },\n-        const_eval::const_uint(count) => count as uint,\n-        const_eval::const_float(count) => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found float\");\n-            count as uint\n-        }\n-        const_eval::const_str(_) => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found string\");\n-            0\n-        }\n-        const_eval::const_bool(_) => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found boolean\");\n-            0\n-        }\n-        const_eval::const_binary(_) => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found binary array\");\n-            0\n-        }\n-        const_eval::const_nil => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found ()\");\n-            0\n-        }\n-      },\n-      Err(..) => {\n-        tcx.sess.span_err(count_expr.span,\n-                          \"expected constant integer for repeat count, \\\n-                           found variable\");\n-        0\n-      }\n+        Ok(val) => {\n+            let found = match val {\n+                const_eval::const_uint(count) => return count as uint,\n+                const_eval::const_int(count) if count >= 0 => return count as uint,\n+                const_eval::const_int(_) =>\n+                    \"negative integer\",\n+                const_eval::const_float(_) =>\n+                    \"float\",\n+                const_eval::const_str(_) =>\n+                    \"string\",\n+                const_eval::const_bool(_) =>\n+                    \"boolean\",\n+                const_eval::const_binary(_) =>\n+                    \"binary array\"\n+            };\n+            tcx.sess.span_err(count_expr.span, format!(\n+                \"expected positive integer for repeat count, found {}\",\n+                found).as_slice());\n+        }\n+        Err(_) => {\n+            let found = match count_expr.node {\n+                ast::ExprPath(ast::Path {\n+                    global: false,\n+                    ref segments,\n+                    ..\n+                }) if segments.len() == 1 =>\n+                    \"variable\",\n+                _ =>\n+                    \"non-constant expression\"\n+            };\n+            tcx.sess.span_err(count_expr.span, format!(\n+                \"expected constant integer for repeat count, found {}\",\n+                found).as_slice());\n+        }\n     }\n+    0\n }\n \n // Iterate over a type parameter's bounded traits and any supertraits"}, {"sha": "8df4d59a292bf7ab1cebeb5dda0a619719feaabe", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 54, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -385,7 +385,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n         let inputs = data.inputs.iter()\n                                 .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n                                 .collect();\n-        let input_ty = ty::mk_tup_or_nil(this.tcx(), inputs);\n+        let input_ty = ty::mk_tup(this.tcx(), inputs);\n \n         let output = match data.output {\n             Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n@@ -652,12 +652,6 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n }\n \n-#[deriving(Show)]\n-enum PointerTy {\n-    RPtr(ty::Region),\n-    Uniq\n-}\n-\n // Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n // If a_seq_ty is a str or a vec, make it a str/vec.\n // Also handle first-class trait types.\n@@ -666,14 +660,14 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         rscope: &RS,\n         a_seq_mutbl: ast::Mutability,\n         a_seq_ty: &ast::Ty,\n-        ptr_ty: PointerTy,\n+        region: ty::Region,\n         constr: |ty::t| -> ty::t)\n         -> ty::t\n {\n     let tcx = this.tcx();\n \n-    debug!(\"mk_pointer(ptr_ty={}, a_seq_ty={})\",\n-           ptr_ty,\n+    debug!(\"mk_pointer(region={}, a_seq_ty={})\",\n+           region,\n            a_seq_ty.repr(tcx));\n \n     match a_seq_ty.node {\n@@ -688,14 +682,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             match tcx.def_map.borrow().get(&id) {\n                 Some(&def::DefPrimTy(ast::TyStr)) => {\n                     check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                    match ptr_ty {\n-                        Uniq => {\n-                            return constr(ty::mk_str(tcx));\n-                        }\n-                        RPtr(r) => {\n-                            return ty::mk_str_slice(tcx, r, a_seq_mutbl);\n-                        }\n-                    }\n+                    return ty::mk_str_slice(tcx, region, a_seq_mutbl);\n                 }\n                 Some(&def::DefTrait(trait_def_id)) => {\n                     let result = ast_path_to_trait_ref(this,\n@@ -716,14 +703,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     let tr = ty::mk_trait(tcx,\n                                           result,\n                                           existential_bounds);\n-                    return match ptr_ty {\n-                        Uniq => {\n-                            return ty::mk_uniq(tcx, tr);\n-                        }\n-                        RPtr(r) => {\n-                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: a_seq_mutbl, ty: tr});\n-                        }\n-                    };\n+                    return ty::mk_rptr(tcx, region, ty::mt{mutbl: a_seq_mutbl, ty: tr});\n                 }\n                 _ => {}\n             }\n@@ -824,12 +804,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n     let typ = ast_ty_to_builtin_ty(this, rscope, ast_ty).unwrap_or_else(|| {\n         match ast_ty.node {\n-            ast::TyNil => ty::mk_nil(this.tcx()),\n-            ast::TyBot => unreachable!(),\n-            ast::TyUniq(ref ty) => {\n-                mk_pointer(this, rscope, ast::MutImmutable, &**ty, Uniq,\n-                           |ty| ty::mk_uniq(tcx, ty))\n-            }\n             ast::TyVec(ref ty) => {\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n@@ -842,7 +816,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt.mutbl, &*mt.ty, RPtr(r),\n+                mk_pointer(this, rscope, mt.mutbl, &*mt.ty, r,\n                            |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n             }\n             ast::TyTup(ref fields) => {\n@@ -1208,22 +1182,24 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                                                                    .filter(|&(_, l)| l != 0)\n                                                                    .collect();\n \n-    let output_ty = match decl.output.node {\n-        ast::TyBot => ty::FnDiverging,\n-        ast::TyInfer => ty::FnConverging(this.ty_infer(decl.output.span)),\n-        _ => ty::FnConverging(match implied_output_region {\n-            Some(implied_output_region) => {\n-                let rb = SpecificRscope::new(implied_output_region);\n-                ast_ty_to_ty(this, &rb, &*decl.output)\n-            }\n-            None => {\n-                // All regions must be explicitly specified in the output\n-                // if the lifetime elision rules do not apply. This saves\n-                // the user from potentially-confusing errors.\n-                let rb = UnelidableRscope::new(param_lifetimes);\n-                ast_ty_to_ty(this, &rb, &*decl.output)\n-            }\n-        })\n+    let output_ty = match decl.output {\n+        ast::Return(ref output) if output.node == ast::TyInfer =>\n+            ty::FnConverging(this.ty_infer(output.span)),\n+        ast::Return(ref output) =>\n+            ty::FnConverging(match implied_output_region {\n+                Some(implied_output_region) => {\n+                    let rb = SpecificRscope::new(implied_output_region);\n+                    ast_ty_to_ty(this, &rb, &**output)\n+                }\n+                None => {\n+                    // All regions must be explicitly specified in the output\n+                    // if the lifetime elision rules do not apply. This saves\n+                    // the user from potentially-confusing errors.\n+                    let rb = UnelidableRscope::new(param_lifetimes);\n+                    ast_ty_to_ty(this, &rb, &**output)\n+                }\n+            }),\n+        ast::NoReturn(_) => ty::FnDiverging\n     };\n \n     (ty::BareFnTy {\n@@ -1346,11 +1322,14 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n \n-    let output_ty = match decl.output.node {\n-        ast::TyBot => ty::FnDiverging,\n-        ast::TyInfer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n-        ast::TyInfer => ty::FnConverging(this.ty_infer(decl.output.span)),\n-        _ => ty::FnConverging(ast_ty_to_ty(this, &rb, &*decl.output))\n+    let output_ty = match decl.output {\n+        ast::Return(ref output) if output.node == ast::TyInfer && expected_ret_ty.is_some() =>\n+            expected_ret_ty.unwrap(),\n+        ast::Return(ref output) if output.node == ast::TyInfer =>\n+            ty::FnConverging(this.ty_infer(output.span)),\n+        ast::Return(ref output) =>\n+            ty::FnConverging(ast_ty_to_ty(this, &rb, &**output)),\n+        ast::NoReturn(_) => ty::FnDiverging\n     };\n \n     ty::ClosureTy {"}, {"sha": "37fb368b54b4a300bbd79918c4901c8c2833289d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -556,7 +556,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         .collect();\n \n     if let ty::FnConverging(ret_ty) = ret_ty {\n-        fcx.require_type_is_sized(ret_ty, decl.output.span, traits::ReturnType);\n+        fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n         fn_sig_tys.push(ret_ty);\n     }\n \n@@ -2854,7 +2854,6 @@ fn check_lit(fcx: &FnCtxt,\n             opt_ty.unwrap_or_else(\n                 || ty::mk_float_var(tcx, fcx.infcx().next_float_var_id()))\n         }\n-        ast::LitNil => ty::mk_nil(tcx),\n         ast::LitBool(_) => ty::mk_bool()\n     }\n }\n@@ -5486,7 +5485,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n \n         let tuple_ty =\n-            ty::mk_tup_or_nil(fcx.tcx(), input_tys);\n+            ty::mk_tup(fcx.tcx(), input_tys);\n \n         if type_count >= 1 {\n             substs.types.push(space, tuple_ty);"}, {"sha": "eed574a1a1d7d297378038c85851be635efaa421", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -2096,9 +2096,11 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                         .map(|a| ty_of_arg(ccx, &rb, a, None))\n                         .collect();\n \n-    let output = match decl.output.node {\n-        ast::TyBot => ty::FnDiverging,\n-        _ => ty::FnConverging(ast_ty_to_ty(ccx, &rb, &*decl.output))\n+    let output = match decl.output {\n+        ast::Return(ref ty) =>\n+            ty::FnConverging(ast_ty_to_ty(ccx, &rb, &**ty)),\n+        ast::NoReturn(_) =>\n+            ty::FnDiverging\n     };\n \n     let t_fn = ty::mk_bare_fn("}, {"sha": "078a2c10bcb3514b8adb7c87c8046b32f1bd3c21", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -539,9 +539,11 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n                .map(|(a, b)| this.tys(*a, *b))\n                .collect::<Result<_, _>>()\n                .map(|ts| ty::mk_tup(tcx, ts))\n-        } else {\n+        } else if as_.len() != 0 && bs.len() != 0 {\n             Err(ty::terr_tuple_size(\n                 expected_found(this, as_.len(), bs.len())))\n+        } else {\n+            Err(ty::terr_sorts(expected_found(this, a, b)))\n         }\n       }\n "}, {"sha": "e12019a15302ceb545ab543b5cc9faa340d352e1", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -973,8 +973,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                                    &anon_nums, &region_names);\n             inputs = self.rebuild_args_ty(inputs.as_slice(), lifetime,\n                                           &anon_nums, &region_names);\n-            output = self.rebuild_arg_ty_or_output(&*output, lifetime,\n-                                                   &anon_nums, &region_names);\n+            output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n                                                &region_names);\n         }\n@@ -989,7 +988,6 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let new_fn_decl = ast::FnDecl {\n             inputs: inputs,\n             output: output,\n-            cf: self.fn_decl.cf,\n             variadic: self.fn_decl.variadic\n         };\n         (new_fn_decl, expl_self_opt, generics)\n@@ -1206,6 +1204,18 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         new_inputs\n     }\n \n+    fn rebuild_output(&self, ty: &ast::FunctionRetTy,\n+                      lifetime: ast::Lifetime,\n+                      anon_nums: &HashSet<uint>,\n+                      region_names: &HashSet<ast::Name>) -> ast::FunctionRetTy {\n+        match *ty {\n+            ast::Return(ref ret_ty) => ast::Return(\n+                self.rebuild_arg_ty_or_output(&**ret_ty, lifetime, anon_nums, region_names)\n+            ),\n+            ast::NoReturn(span) => ast::NoReturn(span)\n+        }\n+    }\n+\n     fn rebuild_arg_ty_or_output(&self,\n                                 ty: &ast::Ty,\n                                 lifetime: ast::Lifetime,\n@@ -1301,7 +1311,6 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n                 ast::TyVec(ref ty) |\n-                ast::TyUniq(ref ty) |\n                 ast::TyFixedLengthVec(ref ty, _) => {\n                     ty_queue.push(&**ty);\n                 }\n@@ -1338,7 +1347,6 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         })\n                     }\n                     ast::TyVec(ty) => ast::TyVec(build_to(ty, to)),\n-                    ast::TyUniq(ty) => ast::TyUniq(build_to(ty, to)),\n                     ast::TyFixedLengthVec(ty, e) => {\n                         ast::TyFixedLengthVec(build_to(ty, to), e)\n                     }"}, {"sha": "a608fba80e3098666b712aaa05e3e7497162bc63", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -710,8 +710,7 @@ impl Clean<Item> for ast::Method {\n             inputs: Arguments {\n                 values: inputs.iter().map(|x| x.clean(cx)).collect(),\n             },\n-            output: (self.pe_fn_decl().output.clean(cx)),\n-            cf: self.pe_fn_decl().cf.clean(cx),\n+            output: self.pe_fn_decl().output.clean(cx),\n             attrs: Vec::new()\n         };\n         Item {\n@@ -749,8 +748,7 @@ impl Clean<Item> for ast::TypeMethod {\n             inputs: Arguments {\n                 values: inputs.iter().map(|x| x.clean(cx)).collect(),\n             },\n-            output: (self.decl.output.clean(cx)),\n-            cf: self.decl.cf.clean(cx),\n+            output: self.decl.output.clean(cx),\n             attrs: Vec::new()\n         };\n         Item {\n@@ -840,8 +838,7 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct FnDecl {\n     pub inputs: Arguments,\n-    pub output: Type,\n-    pub cf: RetStyle,\n+    pub output: FunctionRetTy,\n     pub attrs: Vec<Attribute>,\n }\n \n@@ -857,7 +854,6 @@ impl Clean<FnDecl> for ast::FnDecl {\n                 values: self.inputs.clean(cx),\n             },\n             output: self.output.clean(cx),\n-            cf: self.cf.clean(cx),\n             attrs: Vec::new()\n         }\n     }\n@@ -884,8 +880,7 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n             let _ = names.next();\n         }\n         FnDecl {\n-            output: sig.output.clean(cx),\n-            cf: Return,\n+            output: Return(sig.output.clean(cx)),\n             attrs: Vec::new(),\n             inputs: Arguments {\n                 values: sig.inputs.iter().map(|t| {\n@@ -918,16 +913,16 @@ impl Clean<Argument> for ast::Arg {\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n-pub enum RetStyle {\n-    NoReturn,\n-    Return\n+pub enum FunctionRetTy {\n+    Return(Type),\n+    NoReturn\n }\n \n-impl Clean<RetStyle> for ast::RetStyle {\n-    fn clean(&self, _: &DocContext) -> RetStyle {\n+impl Clean<FunctionRetTy> for ast::FunctionRetTy {\n+    fn clean(&self, cx: &DocContext) -> FunctionRetTy {\n         match *self {\n-            ast::Return => Return,\n-            ast::NoReturn => NoReturn\n+            ast::Return(ref typ) => Return(typ.clean(cx)),\n+            ast::NoReturn(_) => NoReturn\n         }\n     }\n }\n@@ -1124,7 +1119,6 @@ pub enum PrimitiveType {\n     F32, F64,\n     Char,\n     Bool,\n-    Unit,\n     Str,\n     Slice,\n     PrimitiveTuple,\n@@ -1156,7 +1150,6 @@ impl PrimitiveType {\n             \"u32\" => Some(U32),\n             \"u64\" => Some(U64),\n             \"bool\" => Some(Bool),\n-            \"unit\" => Some(Unit),\n             \"char\" => Some(Char),\n             \"str\" => Some(Str),\n             \"f32\" => Some(F32),\n@@ -1205,17 +1198,13 @@ impl PrimitiveType {\n             Str => \"str\",\n             Bool => \"bool\",\n             Char => \"char\",\n-            Unit => \"()\",\n             Slice => \"slice\",\n             PrimitiveTuple => \"tuple\",\n         }\n     }\n \n     pub fn to_url_str(&self) -> &'static str {\n-        match *self {\n-            Unit => \"unit\",\n-            other => other.to_string(),\n-        }\n+        self.to_string()\n     }\n \n     /// Creates a rustdoc-specific node id for primitive types.\n@@ -1230,12 +1219,10 @@ impl Clean<Type> for ast::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use syntax::ast::*;\n         match self.node {\n-            TyNil => Primitive(Unit),\n             TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyRptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n-            TyUniq(ref ty) => Unique(box ty.clean(cx)),\n             TyVec(ref ty) => Vector(box ty.clean(cx)),\n             TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n                                                            e.span.to_src(cx)),\n@@ -1247,7 +1234,6 @@ impl Clean<Type> for ast::Ty {\n             TyProc(ref c) => Proc(box c.clean(cx)),\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyParen(ref ty) => ty.clean(cx),\n-            TyBot => Bottom,\n             ref x => panic!(\"Unimplemented type {}\", x),\n         }\n     }\n@@ -1256,7 +1242,6 @@ impl Clean<Type> for ast::Ty {\n impl Clean<Type> for ty::t {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match ty::get(*self).sty {\n-            ty::ty_nil => Primitive(Unit),\n             ty::ty_bool => Primitive(Bool),\n             ty::ty_char => Primitive(Char),\n             ty::ty_int(ast::TyI) => Primitive(Int),\n@@ -1342,7 +1327,7 @@ impl Clean<Type> for ty::t {\n                 }\n             }\n \n-            ty::ty_unboxed_closure(..) => Primitive(Unit), // FIXME(pcwalton)\n+            ty::ty_unboxed_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => panic!(\"ty_infer\"),\n             ty::ty_open(..) => panic!(\"ty_open\"),\n@@ -2041,7 +2026,6 @@ fn lit_to_string(lit: &ast::Lit) -> String {\n         ast::LitFloat(ref f, _t) => f.get().to_string(),\n         ast::LitFloatUnsuffixed(ref f) => f.get().to_string(),\n         ast::LitBool(b) => b.to_string(),\n-        ast::LitNil => \"\".to_string(),\n     }\n }\n "}, {"sha": "a7f33151547564a342927aa4edcdabe386af0208", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -393,10 +393,7 @@ impl fmt::Show for clean::Type {\n                            format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n                        },\n                        args = decl.decl.inputs,\n-                       arrow = match decl.decl.output {\n-                           clean::Primitive(clean::Unit) => \"\".to_string(),\n-                           _ => format!(\" -&gt; {}\", decl.decl.output),\n-                       },\n+                       arrow = decl.decl.output,\n                        bounds = {\n                            let mut ret = String::new();\n                            for bound in decl.bounds.iter() {\n@@ -435,10 +432,7 @@ impl fmt::Show for clean::Type {\n                                \": {}\",\n                                m.collect::<Vec<String>>().connect(\" + \"))\n                        },\n-                       arrow = match decl.decl.output {\n-                           clean::Primitive(clean::Unit) => \"\".to_string(),\n-                           _ => format!(\" -&gt; {}\", decl.decl.output)\n-                       })\n+                       arrow = decl.decl.output)\n             }\n             clean::BareFunction(ref decl) => {\n                 write!(f, \"{}{}fn{}{}\",\n@@ -514,14 +508,19 @@ impl fmt::Show for clean::Arguments {\n     }\n }\n \n+impl fmt::Show for clean::FunctionRetTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n+            clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n+            clean::NoReturn => write!(f, \" -&gt; !\")\n+        }\n+    }\n+}\n+\n impl fmt::Show for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({args}){arrow}\",\n-               args = self.inputs,\n-               arrow = match self.output {\n-                   clean::Primitive(clean::Unit) => \"\".to_string(),\n-                   _ => format!(\" -&gt; {}\", self.output),\n-               })\n+        write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n     }\n }\n \n@@ -551,12 +550,7 @@ impl<'a> fmt::Show for Method<'a> {\n             }\n             args.push_str(format!(\"{}\", input.type_).as_slice());\n         }\n-        write!(f, \"({args}){arrow}\",\n-               args = args,\n-               arrow = match d.output {\n-                   clean::Primitive(clean::Unit) => \"\".to_string(),\n-                   _ => format!(\" -&gt; {}\", d.output),\n-               })\n+        write!(f, \"({args}){arrow}\", args = args, arrow = d.output)\n     }\n }\n "}, {"sha": "0e1921a07734b4a960f87fba96c72618859d102e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -893,7 +893,6 @@ pub enum Lit_ {\n     LitInt(u64, LitIntType),\n     LitFloat(InternedString, FloatTy),\n     LitFloatUnsuffixed(InternedString),\n-    LitNil,\n     LitBool(bool),\n }\n \n@@ -1086,12 +1085,6 @@ pub struct BareFnTy {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n /// The different kinds of types recognized by the compiler\n pub enum Ty_ {\n-    /// The unit type (`()`)\n-    TyNil,\n-    /// The bottom type (`!`)\n-    TyBot,\n-    TyUniq(P<Ty>),\n-    /// An array (`[T]`)\n     TyVec(P<Ty>),\n     /// A fixed length array (`[T, ..n]`)\n     TyFixedLengthVec(P<Ty>, P<Expr>),\n@@ -1175,8 +1168,7 @@ impl Arg {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n-    pub output: P<Ty>,\n-    pub cf: RetStyle,\n+    pub output: FunctionRetTy,\n     pub variadic: bool\n }\n \n@@ -1198,12 +1190,21 @@ impl fmt::Show for FnStyle {\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub enum RetStyle {\n+pub enum FunctionRetTy {\n     /// Functions with return type ! that always\n     /// raise an error or exit (i.e. never return to the caller)\n-    NoReturn,\n+    NoReturn(Span),\n     /// Everything else\n-    Return,\n+    Return(P<Ty>),\n+}\n+\n+impl FunctionRetTy {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            NoReturn(span) => span,\n+            Return(ref ty) => ty.span\n+        }\n+    }\n }\n \n /// Represents the kind of 'self' associated with a method"}, {"sha": "0c7a3cf4a6ce3f4b2efe92e62c07058073ca9f63", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -248,7 +248,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprLit(P(codemap::respan(sp, ast::LitNil))),\n+            node: ast::ExprLit(P(codemap::respan(sp, ast::LitBool(false)))),\n             span: sp,\n         })\n     }"}, {"sha": "ffc42b6703384667e032ed6efe1400e74eb46f9a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -54,11 +54,9 @@ pub trait AstBuilder {\n     fn ty_ptr(&self, span: Span,\n               ty: P<ast::Ty>,\n               mutbl: ast::Mutability) -> P<ast::Ty>;\n-    fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty>;\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n-    fn ty_nil(&self) -> P<ast::Ty>;\n \n     fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n@@ -377,9 +375,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty(span,\n                 ast::TyPtr(self.ty_mt(ty, mutbl)))\n     }\n-    fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        self.ty(span, ast::TyUniq(ty))\n-    }\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n         self.ty_path(\n@@ -406,14 +401,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty(span, ast::TyInfer)\n     }\n \n-    fn ty_nil(&self) -> P<ast::Ty> {\n-        P(ast::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::TyNil,\n-            span: DUMMY_SP,\n-        })\n-    }\n-\n     fn typaram(&self,\n                span: Span,\n                id: ast::Ident,\n@@ -809,8 +796,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat(span, pat)\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        let pat = ast::PatTup(pats);\n-        self.pat(span, pat)\n+        self.pat(span, ast::PatTup(pats))\n     }\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n@@ -931,11 +917,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     // FIXME unused self\n-    fn fn_decl(&self, inputs: Vec<ast::Arg> , output: P<ast::Ty>) -> P<ast::FnDecl> {\n+    fn fn_decl(&self, inputs: Vec<ast::Arg>, output: P<ast::Ty>) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs: inputs,\n-            output: output,\n-            cf: ast::Return,\n+            output: ast::Return(output),\n             variadic: false\n         })\n     }"}, {"sha": "e2867c2fbabfa9fb67d2531727120940fb6e5365", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -46,7 +46,6 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Minus)) => {\n                         accumulator.push_str(format!(\"-{}\", i).as_slice());\n                     }\n-                    ast::LitNil => {}\n                     ast::LitBool(b) => {\n                         accumulator.push_str(format!(\"{}\", b).as_slice());\n                     }"}, {"sha": "62f3b5d01b41a2053da0a00e03364025571de532", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -88,7 +88,7 @@\n //! }\n //! ```\n \n-use ast::{MetaItem, Item, Expr, ExprRet, MutMutable, LitNil};\n+use ast::{MetaItem, Item, Expr, ExprRet, MutMutable};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -186,7 +186,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             if stmts.is_empty() {\n                 let ret_ok = cx.expr(trait_span,\n                                      ExprRet(Some(cx.expr_ok(trait_span,\n-                                                             cx.expr_lit(trait_span, LitNil)))));\n+                                                             cx.expr_tuple(trait_span, vec![])))));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n \n@@ -231,7 +231,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             if stmts.len() == 0 {\n                 let ret_ok = cx.expr(trait_span,\n                                      ExprRet(Some(cx.expr_ok(trait_span,\n-                                                             cx.expr_lit(trait_span, LitNil)))));\n+                                                             cx.expr_tuple(trait_span, vec![])))));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n "}, {"sha": "4be299994fd2110d5f7aacf1f63f7363fdac49bc", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -922,7 +922,7 @@ impl<'a> MethodDef<'a> {\n                 }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n-                let single_pat = cx.pat(sp, ast::PatTup(subpats));\n+                let single_pat = cx.pat_tuple(sp, subpats);\n \n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case"}, {"sha": "8b46769d633f3c05c745418cdf38ae5f7e8f6eed", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -152,14 +152,9 @@ impl<'a> Ty<'a> {\n                 cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n             }\n             Tuple(ref fields) => {\n-                let ty = if fields.is_empty() {\n-                    ast::TyNil\n-                } else {\n-                    ast::TyTup(fields.iter()\n-                                     .map(|f| f.to_ty(cx, span, self_ty, self_generics))\n-                                     .collect())\n-                };\n-\n+                let ty = ast::TyTup(fields.iter()\n+                    .map(|f| f.to_ty(cx, span, self_ty, self_generics))\n+                    .collect());\n                 cx.ty(span, ty)\n             }\n         }"}, {"sha": "fa69495fa42aae0b2dca2e89e0be529114b76da5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -159,7 +159,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             // `_ => [<elseopt> | ()]`\n             let else_arm = {\n                 let pat_under = fld.cx.pat_wild(span);\n-                let else_expr = elseopt.unwrap_or_else(|| fld.cx.expr_lit(span, ast::LitNil));\n+                let else_expr = elseopt.unwrap_or_else(|| fld.cx.expr_tuple(span, vec![]));\n                 fld.cx.arm(span, vec![pat_under], else_expr)\n             };\n "}, {"sha": "a816b4796304646a1a653564185a8cdd8d4913e4", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -654,7 +654,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         //\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n-        let pat = self.ecx.pat(self.fmtsp, ast::PatTup(pats));\n+        let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n         let arm = self.ecx.arm(self.fmtsp, vec!(pat), body);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n         self.ecx.expr_match(self.fmtsp, head, vec!(arm))"}, {"sha": "56d912824374d7ae025fab3c1e42ea375d732755", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -391,8 +391,7 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     t.map(|Ty {id, node, span}| Ty {\n         id: fld.new_id(id),\n         node: match node {\n-            TyNil | TyBot | TyInfer => node,\n-            TyUniq(ty) => TyUniq(fld.fold_ty(ty)),\n+            TyInfer => node,\n             TyVec(ty) => TyVec(fld.fold_ty(ty)),\n             TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n             TyRptr(region, mt) => {\n@@ -706,10 +705,12 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n }\n \n pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n-    decl.map(|FnDecl {inputs, output, cf, variadic}| FnDecl {\n+    decl.map(|FnDecl {inputs, output, variadic}| FnDecl {\n         inputs: inputs.move_map(|x| fld.fold_arg(x)),\n-        output: fld.fold_ty(output),\n-        cf: cf,\n+        output: match output {\n+            Return(ty) => Return(fld.fold_ty(ty)),\n+            NoReturn(span) => NoReturn(span)\n+        },\n         variadic: variadic\n     })\n }\n@@ -1146,10 +1147,12 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n         attrs: attrs.move_map(|x| folder.fold_attribute(x)),\n         node: match node {\n             ForeignItemFn(fdec, generics) => {\n-                ForeignItemFn(fdec.map(|FnDecl {inputs, output, cf, variadic}| FnDecl {\n+                ForeignItemFn(fdec.map(|FnDecl {inputs, output, variadic}| FnDecl {\n                     inputs: inputs.move_map(|a| folder.fold_arg(a)),\n-                    output: folder.fold_ty(output),\n-                    cf: cf,\n+                    output: match output {\n+                        Return(ty) => Return(folder.fold_ty(ty)),\n+                        NoReturn(span) => NoReturn(span)\n+                    },\n                     variadic: variadic\n                 }), folder.fold_generics(generics))\n             }"}, {"sha": "fa10cb90f83a934be1f1bda24acb3cab646a0743", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -24,7 +24,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n+#![feature(if_let, macro_rules, globs, default_type_params, phase, slicing_syntax)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n \n extern crate arena;"}, {"sha": "2810db4eaddd8ee493793b05dab0aaacb45bb343", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -1037,10 +1037,9 @@ mod test {\n                                     }),\n                                         id: ast::DUMMY_NODE_ID\n                                     }),\n-                                output: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                  node: ast::TyNil,\n-                                                  span:sp(15,15)}), // not sure\n-                                cf: ast::Return,\n+                                output: ast::Return(P(ast::Ty{id: ast::DUMMY_NODE_ID,\n+                                                  node: ast::TyTup(vec![]),\n+                                                  span:sp(15,15)})), // not sure\n                                 variadic: false\n                             }),\n                                     ast::NormalFn,"}, {"sha": "1b2ab3c235d5f59bdb17fdf697f1b9c09bde5fc9", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -17,8 +17,8 @@ Obsolete syntax that becomes too hard to parse can be\n removed.\n */\n \n-use ast::{Expr, ExprLit, LitNil};\n-use codemap::{Span, respan};\n+use ast::{Expr, ExprTup};\n+use codemap::Span;\n use parse::parser;\n use parse::token;\n use ptr::P;\n@@ -96,7 +96,7 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// a placeholder expression\n     fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> P<Expr> {\n         self.obsolete(sp, kind);\n-        self.mk_expr(sp.lo, sp.hi, ExprLit(P(respan(sp, LitNil))))\n+        self.mk_expr(sp.lo, sp.hi, ExprTup(vec![]))\n     }\n \n     fn report(&mut self,"}, {"sha": "4f487a10e9867c97baea0641faae98d028438abd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 60, "deletions": 96, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -30,32 +30,32 @@ use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n use ast::{Once, Many};\n use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n-use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n+use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n use ast::{Ident, NormalFn, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n-use ast::{LitNil, LitStr, LitInt, Local, LocalLet};\n+use ast::{LitStr, LitInt, Local, LocalLet};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchNormal};\n use ast::{Method, MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n use ast::{PolyTraitRef};\n use ast::{QPath, RequiredMethod};\n-use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n+use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n-use ast::{TupleVariantKind, Ty, Ty_, TyBot};\n+use ast::{TupleVariantKind, Ty, Ty_};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n-use ast::{TyRptr, TyTup, TyU32, TyUniq, TyVec, UnUniq};\n+use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n+use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n@@ -1066,11 +1066,10 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Fn);\n         let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let (inputs, variadic) = self.parse_fn_args(false, true);\n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let ret_ty = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n             output: ret_ty,\n-            cf: ret_style,\n             variadic: variadic\n         });\n         TyBareFn(P(BareFnTy {\n@@ -1100,11 +1099,10 @@ impl<'a> Parser<'a> {\n         let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let (inputs, variadic) = self.parse_fn_args(false, false);\n         let bounds = self.parse_colon_then_ty_param_bounds();\n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let ret_ty = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n             output: ret_ty,\n-            cf: ret_style,\n             variadic: variadic\n         });\n         TyProc(P(ClosureTy {\n@@ -1200,11 +1198,10 @@ impl<'a> Parser<'a> {\n \n         let bounds = self.parse_colon_then_ty_param_bounds();\n \n-        let (return_style, output) = self.parse_ret_ty();\n+        let output = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n             output: output,\n-            cf: return_style,\n             variadic: false\n         });\n \n@@ -1384,31 +1381,20 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&mut self) -> (RetStyle, P<Ty>) {\n-        return if self.eat(&token::RArrow) {\n-            let lo = self.span.lo;\n+    pub fn parse_ret_ty(&mut self) -> FunctionRetTy {\n+        if self.eat(&token::RArrow) {\n             if self.eat(&token::Not) {\n-                (\n-                    NoReturn,\n-                    P(Ty {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: TyBot,\n-                        span: mk_sp(lo, self.last_span.hi)\n-                    })\n-                )\n+                NoReturn(self.span)\n             } else {\n-                (Return, self.parse_ty(true))\n+                Return(self.parse_ty(true))\n             }\n         } else {\n             let pos = self.span.lo;\n-            (\n-                Return,\n-                P(Ty {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: TyNil,\n-                    span: mk_sp(pos, pos),\n-                })\n-            )\n+            Return(P(Ty {\n+                id: ast::DUMMY_NODE_ID,\n+                node: TyTup(vec![]),\n+                span: mk_sp(pos, pos),\n+            }))\n         }\n     }\n \n@@ -1423,34 +1409,29 @@ impl<'a> Parser<'a> {\n \n         let t = if self.token == token::OpenDelim(token::Paren) {\n             self.bump();\n-            if self.token == token::CloseDelim(token::Paren) {\n-                self.bump();\n-                TyNil\n-            } else {\n-                // (t) is a parenthesized ty\n-                // (t,) is the type of a tuple with only one field,\n-                // of type t\n-                let mut ts = vec!(self.parse_ty(true));\n-                let mut one_tuple = false;\n-                while self.token == token::Comma {\n-                    self.bump();\n-                    if self.token != token::CloseDelim(token::Paren) {\n-                        ts.push(self.parse_ty(true));\n-                    }\n-                    else {\n-                        one_tuple = true;\n-                    }\n-                }\n \n-                if ts.len() == 1 && !one_tuple {\n-                    self.expect(&token::CloseDelim(token::Paren));\n-                    TyParen(ts.into_iter().nth(0).unwrap())\n+            // (t) is a parenthesized ty\n+            // (t,) is the type of a tuple with only one field,\n+            // of type t\n+            let mut ts = vec![];\n+            let mut last_comma = false;\n+            while self.token != token::CloseDelim(token::Paren) {\n+                ts.push(self.parse_ty(true));\n+                if self.token == token::Comma {\n+                    last_comma = true;\n+                    self.bump();\n                 } else {\n-                    let t = TyTup(ts);\n-                    self.expect(&token::CloseDelim(token::Paren));\n-                    t\n+                    last_comma = false;\n+                    break;\n                 }\n             }\n+\n+            self.expect(&token::CloseDelim(token::Paren));\n+            if ts.len() == 1 && !last_comma {\n+                TyParen(ts.into_iter().nth(0).unwrap())\n+            } else {\n+                TyTup(ts)\n+            }\n         } else if self.token == token::Tilde {\n             // OWNED POINTER\n             self.bump();\n@@ -1459,7 +1440,7 @@ impl<'a> Parser<'a> {\n                 token::OpenDelim(token::Bracket) => self.obsolete(last_span, ObsoleteOwnedVector),\n                 _ => self.obsolete(last_span, ObsoleteOwnedType)\n             }\n-            TyUniq(self.parse_ty(false))\n+            TyTup(vec![self.parse_ty(false)])\n         } else if self.token == token::BinOp(token::Star) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n@@ -1662,10 +1643,6 @@ impl<'a> Parser<'a> {\n                 LitBinary(parse::binary_lit(i.as_str())),\n             token::LitBinaryRaw(i, _) =>\n                 LitBinary(Rc::new(i.as_str().as_bytes().iter().map(|&x| x).collect())),\n-            token::OpenDelim(token::Paren) => {\n-                self.expect(&token::CloseDelim(token::Paren));\n-                LitNil\n-            },\n             _ => { self.unexpected_last(tok); }\n         }\n     }\n@@ -2126,33 +2103,29 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::OpenDelim(token::Paren) => {\n                 self.bump();\n+\n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n+                let mut es = vec![];\n                 let mut trailing_comma = false;\n-                if self.token == token::CloseDelim(token::Paren) {\n-                    hi = self.span.hi;\n-                    self.bump();\n-                    let lit = P(spanned(lo, hi, LitNil));\n-                    return self.mk_expr(lo, hi, ExprLit(lit));\n-                }\n-                let mut es = vec!(self.parse_expr());\n-                self.commit_expr(&**es.last().unwrap(), &[],\n-                                 &[token::Comma, token::CloseDelim(token::Paren)]);\n-                while self.token == token::Comma {\n-                    self.bump();\n-                    if self.token != token::CloseDelim(token::Paren) {\n-                        es.push(self.parse_expr());\n-                        self.commit_expr(&**es.last().unwrap(), &[],\n-                                         &[token::Comma, token::CloseDelim(token::Paren)]);\n-                    } else {\n+                while self.token != token::CloseDelim(token::Paren) {\n+                    es.push(self.parse_expr());\n+                    self.commit_expr(&**es.last().unwrap(), &[],\n+                                     &[token::Comma, token::CloseDelim(token::Paren)]);\n+                    if self.token == token::Comma {\n                         trailing_comma = true;\n+\n+                        self.bump();\n+                    } else {\n+                        trailing_comma = false;\n+                        break;\n                     }\n                 }\n-                hi = self.span.hi;\n-                self.commit_expr_expecting(&**es.last().unwrap(), token::CloseDelim(token::Paren));\n+                self.bump();\n \n+                hi = self.span.hi;\n                 return if es.len() == 1 && !trailing_comma {\n-                   self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()))\n+                    self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()))\n                 } else {\n                     self.mk_expr(lo, hi, ExprTup(es))\n                 }\n@@ -3293,13 +3266,8 @@ impl<'a> Parser<'a> {\n             // parse (pat,pat,pat,...) as tuple\n             self.bump();\n             if self.token == token::CloseDelim(token::Paren) {\n-                hi = self.span.hi;\n                 self.bump();\n-                let lit = P(codemap::Spanned {\n-                    node: LitNil,\n-                    span: mk_sp(lo, hi)});\n-                let expr = self.mk_expr(lo, hi, ExprLit(lit));\n-                pat = PatLit(expr);\n+                pat = PatTup(vec![]);\n             } else {\n                 let mut fields = vec!(self.parse_pat());\n                 if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n@@ -4137,12 +4105,11 @@ impl<'a> Parser<'a> {\n     pub fn parse_fn_decl(&mut self, allow_variadic: bool) -> P<FnDecl> {\n \n         let (args, variadic) = self.parse_fn_args(true, allow_variadic);\n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let ret_ty = self.parse_ret_ty();\n \n         P(FnDecl {\n             inputs: args,\n             output: ret_ty,\n-            cf: ret_style,\n             variadic: variadic\n         })\n     }\n@@ -4337,12 +4304,11 @@ impl<'a> Parser<'a> {\n \n         let hi = self.span.hi;\n \n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let ret_ty = self.parse_ret_ty();\n \n         let fn_decl = P(FnDecl {\n             inputs: fn_inputs,\n             output: ret_ty,\n-            cf: ret_style,\n             variadic: false\n         });\n \n@@ -4368,10 +4334,10 @@ impl<'a> Parser<'a> {\n                 (optional_unboxed_closure_kind, args)\n             }\n         };\n-        let (style, output) = if self.token == token::RArrow {\n+        let output = if self.token == token::RArrow {\n             self.parse_ret_ty()\n         } else {\n-            (Return, P(Ty {\n+            Return(P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: TyInfer,\n                 span: self.span,\n@@ -4381,7 +4347,6 @@ impl<'a> Parser<'a> {\n         (P(FnDecl {\n             inputs: inputs_captures,\n             output: output,\n-            cf: style,\n             variadic: false\n         }), optional_unboxed_closure_kind)\n     }\n@@ -4394,10 +4359,10 @@ impl<'a> Parser<'a> {\n                                      seq_sep_trailing_allowed(token::Comma),\n                                      |p| p.parse_fn_block_arg());\n \n-        let (style, output) = if self.token == token::RArrow {\n+        let output = if self.token == token::RArrow {\n             self.parse_ret_ty()\n         } else {\n-            (Return, P(Ty {\n+            Return(P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: TyInfer,\n                 span: self.span,\n@@ -4407,7 +4372,6 @@ impl<'a> Parser<'a> {\n         P(FnDecl {\n             inputs: inputs,\n             output: output,\n-            cf: style,\n             variadic: false\n         })\n     }"}, {"sha": "7025555ab4006483c8abc397fbdc974a464a5fcc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 55, "deletions": 47, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -645,12 +645,6 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ty.span.lo));\n         try!(self.ibox(0u));\n         match ty.node {\n-            ast::TyNil => try!(word(&mut self.s, \"()\")),\n-            ast::TyBot => try!(word(&mut self.s, \"!\")),\n-            ast::TyUniq(ref ty) => {\n-                try!(word(&mut self.s, \"~\"));\n-                try!(self.print_type(&**ty));\n-            }\n             ast::TyVec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&**ty));\n@@ -2307,15 +2301,7 @@ impl<'a> State<'a> {\n         }\n         try!(self.pclose());\n \n-        try!(self.maybe_print_comment(decl.output.span.lo));\n-        match decl.output.node {\n-            ast::TyNil => Ok(()),\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.word_space(\"->\"));\n-                self.print_type(&*decl.output)\n-            }\n-        }\n+        self.print_fn_output(decl)\n     }\n \n     pub fn print_fn_block_args(\n@@ -2333,16 +2319,24 @@ impl<'a> State<'a> {\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n \n-        match decl.output.node {\n-            ast::TyInfer => {}\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.word_space(\"->\"));\n-                try!(self.print_type(&*decl.output));\n+        if let ast::Return(ref ty) = decl.output {\n+            if ty.node == ast::TyInfer {\n+                return self.maybe_print_comment(ty.span.lo);\n             }\n         }\n \n-        self.maybe_print_comment(decl.output.span.lo)\n+        try!(self.space_if_not_bol());\n+        try!(self.word_space(\"->\"));\n+        match decl.output {\n+            ast::Return(ref ty) => {\n+                try!(self.print_type(&**ty));\n+                self.maybe_print_comment(ty.span.lo)\n+            }\n+            ast::NoReturn(span) => {\n+                try!(self.word_nbsp(\"!\"));\n+                self.maybe_print_comment(span.lo)\n+            }\n+        }\n     }\n \n     pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureClause)\n@@ -2359,16 +2353,24 @@ impl<'a> State<'a> {\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \")\"));\n \n-        match decl.output.node {\n-            ast::TyInfer => {}\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.word_space(\"->\"));\n-                try!(self.print_type(&*decl.output));\n+        if let ast::Return(ref ty) = decl.output {\n+            if ty.node == ast::TyInfer {\n+                return self.maybe_print_comment(ty.span.lo);\n             }\n         }\n \n-        self.maybe_print_comment(decl.output.span.lo)\n+        try!(self.space_if_not_bol());\n+        try!(self.word_space(\"->\"));\n+        match decl.output {\n+            ast::Return(ref ty) => {\n+                try!(self.print_type(&**ty));\n+                self.maybe_print_comment(ty.span.lo)\n+            }\n+            ast::NoReturn(span) => {\n+                try!(self.word_nbsp(\"!\"));\n+                self.maybe_print_comment(span.lo)\n+            }\n+        }\n     }\n \n     pub fn print_bounds(&mut self,\n@@ -2627,20 +2629,30 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_output(&mut self, decl: &ast::FnDecl) -> IoResult<()> {\n-        match decl.output.node {\n-            ast::TyNil => Ok(()),\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.ibox(indent_unit));\n-                try!(self.word_space(\"->\"));\n-                if decl.cf == ast::NoReturn {\n-                    try!(self.word_nbsp(\"!\"));\n-                } else {\n-                    try!(self.print_type(&*decl.output));\n+        if let ast::Return(ref ty) = decl.output {\n+            match ty.node {\n+                ast::TyTup(ref tys) if tys.is_empty() => {\n+                    return self.maybe_print_comment(ty.span.lo);\n                 }\n-                self.end()\n+                _ => ()\n             }\n         }\n+\n+        try!(self.space_if_not_bol());\n+        try!(self.ibox(indent_unit));\n+        try!(self.word_space(\"->\"));\n+        match decl.output {\n+            ast::NoReturn(_) =>\n+                try!(self.word_nbsp(\"!\")),\n+            ast::Return(ref ty) =>\n+                try!(self.print_type(&**ty))\n+        }\n+        try!(self.end());\n+\n+        match decl.output {\n+            ast::Return(ref output) => self.maybe_print_comment(output.span.lo),\n+            _ => Ok(())\n+        }\n     }\n \n     pub fn print_ty_fn(&mut self,\n@@ -2700,8 +2712,6 @@ impl<'a> State<'a> {\n \n         try!(self.print_bounds(\":\", bounds));\n \n-        try!(self.maybe_print_comment(decl.output.span.lo));\n-\n         try!(self.print_fn_output(decl));\n \n         match generics {\n@@ -2807,7 +2817,6 @@ impl<'a> State<'a> {\n                          ast_util::float_ty_to_string(t).as_slice()).as_slice())\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n-            ast::LitNil => word(&mut self.s, \"()\"),\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }\n@@ -3003,10 +3012,9 @@ mod test {\n \n         let decl = ast::FnDecl {\n             inputs: Vec::new(),\n-            output: P(ast::Ty {id: 0,\n-                               node: ast::TyNil,\n-                               span: codemap::DUMMY_SP}),\n-            cf: ast::Return,\n+            output: ast::Return(P(ast::Ty {id: 0,\n+                               node: ast::TyTup(vec![]),\n+                               span: codemap::DUMMY_SP})),\n             variadic: false\n         };\n         let generics = ast_util::empty_generics();"}, {"sha": "8b6d752d4848e83154109593479642c62fd87853", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -289,9 +289,12 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match &i.node {\n           &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n-            let no_output = match decl.output.node {\n-                ast::TyNil => true,\n-                _ => false,\n+            let no_output = match decl.output {\n+                ast::Return(ref ret_ty) => match ret_ty.node {\n+                    ast::TyTup(ref tys) if tys.is_empty() => true,\n+                    _ => false,\n+                },\n+                ast::NoReturn(_) => false\n             };\n             if decl.inputs.is_empty()\n                    && no_output\n@@ -325,9 +328,12 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n         match i.node {\n             ast::ItemFn(ref decl, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n-                let no_output = match decl.output.node {\n-                    ast::TyNil => true,\n-                    _ => false\n+                let no_output = match decl.output {\n+                    ast::Return(ref ret_ty) => match ret_ty.node {\n+                        ast::TyTup(ref tys) if tys.is_empty() => true,\n+                        _ => false,\n+                    },\n+                    ast::NoReturn(_) => false\n                 };\n                 let tparm_cnt = generics.ty_params.len();\n                 // NB: inadequate check, but we're running"}, {"sha": "f30a4325eb8c0dd8a3f8965eee702af802ad8121", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01b17b06eb35542bb80ff7456043b0ed5572ba/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=eb01b17b06eb35542bb80ff7456043b0ed5572ba", "patch": "@@ -341,7 +341,7 @@ pub fn skip_ty<'v, V: Visitor<'v>>(_: &mut V, _: &'v Ty) {\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     match typ.node {\n-        TyUniq(ref ty) | TyVec(ref ty) | TyParen(ref ty) => {\n+        TyVec(ref ty) | TyParen(ref ty) => {\n             visitor.visit_ty(&**ty)\n         }\n         TyPtr(ref mutable_type) => {\n@@ -360,23 +360,23 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_ty_param_bounds(visitor, &function_declaration.bounds);\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyProc(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_ty_param_bounds(visitor, &function_declaration.bounds);\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyBareFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyPath(ref path, ref opt_bounds, id) => {\n@@ -403,7 +403,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyTypeof(ref expression) => {\n             visitor.visit_expr(&**expression)\n         }\n-        TyNil | TyBot | TyInfer => {}\n+        TyInfer => {}\n     }\n }\n \n@@ -538,12 +538,18 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n     }\n }\n \n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n+    if let Return(ref output_ty) = *ret_ty {\n+        visitor.visit_ty(&**output_ty)\n+    }\n+}\n+\n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n     for argument in function_declaration.inputs.iter() {\n         visitor.visit_pat(&*argument.pat);\n         visitor.visit_ty(&*argument.ty)\n     }\n-    visitor.visit_ty(&*function_declaration.output)\n+    walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n@@ -601,7 +607,7 @@ pub fn walk_ty_method<'v, V: Visitor<'v>>(visitor: &mut V, method_type: &'v Type\n         visitor.visit_ty(&*argument_type.ty)\n     }\n     visitor.visit_generics(&method_type.generics);\n-    visitor.visit_ty(&*method_type.decl.output);\n+    walk_fn_ret_ty(visitor, &method_type.decl.output);\n     for attr in method_type.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }"}]}