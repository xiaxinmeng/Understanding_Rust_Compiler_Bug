{"sha": "7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNDMyOTFhYzNkNDM4ZjE2NDUzYzJmYmQxY2VjMzI5ZWQyYWE3YWM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-19T05:00:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-19T05:00:03Z"}, "message": "Rollup merge of #37233 - michaelwoerister:blake2-for-ich, r=nikomatsakis\n\nICH: Use 128-bit Blake2b hash instead of 64-bit SipHash for incr. comp. fingerprints\n\nThis PR makes incr. comp. hashes 128 bits wide in order to push collision probability below a threshold that we need to worry about. It also replaces SipHash, which has been mentioned multiple times as not being built for fingerprinting, with the [BLAKE2b hash function](https://blake2.net/), an improved version of the BLAKE sha-3 finalist.\n\nI was worried that using a cryptographic hash function would make ICH computation noticeably slower, but after doing some performance tests, I'm not any more. Most of the time BLAKE2b is actually faster than using two SipHashes (in order to get 128 bits):\n\n```\nSipHash\nlibcore: 0.199 seconds\nlibstd:  0.090 seconds\n\nBLAKE2b\nlibcore: 0.162 seconds\nlibstd:  0.078 seconds\n```\n\nIf someone can prove that something like MetroHash128 provides a comparably low collision probability as BLAKE2, I'm happy to switch. But for now we are at least not taking a performance hit.\n\nI also suggest that we throw out the sha-256 implementation in the compiler and replace it with BLAKE2, since our sha-256 implementation is two to three times slower than the BLAKE2 implementation in this PR (cc @alexcrichton @eddyb @brson)\n\nr? @nikomatsakis (although there's not much incr. comp. specific in here, so feel free to re-assign)", "tree": {"sha": "86a6862ed17e006f5e7b2d8800936b0878e0a897", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86a6862ed17e006f5e7b2d8800936b0878e0a897"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "html_url": "https://github.com/rust-lang/rust/commit/7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ae80c6ac42e571b10398f35c9edd87c1f573ad9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae80c6ac42e571b10398f35c9edd87c1f573ad9", "html_url": "https://github.com/rust-lang/rust/commit/6ae80c6ac42e571b10398f35c9edd87c1f573ad9"}, {"sha": "d07523c716cd384b257baca48046db1264aab7f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d07523c716cd384b257baca48046db1264aab7f6", "html_url": "https://github.com/rust-lang/rust/commit/d07523c716cd384b257baca48046db1264aab7f6"}], "stats": {"total": 498, "additions": 460, "deletions": 38}, "files": [{"sha": "996df2e7fcfcaf3597b510b59ecb82b7e5727ca2", "filename": "src/librustc_data_structures/blake2b.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -0,0 +1,286 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// An implementation of the Blake2b cryptographic hash function.\n+// The implementation closely follows: https://tools.ietf.org/html/rfc7693\n+//\n+// \"BLAKE2 is a cryptographic hash function faster than MD5, SHA-1, SHA-2, and\n+//  SHA-3, yet is at least as secure as the latest standard SHA-3.\"\n+// according to their own website :)\n+//\n+// Indeed this implementation is two to three times as fast as our SHA-256\n+// implementation. If you have the luxury of being able to use crates from\n+// crates.io, you can go there and find still faster implementations.\n+\n+pub struct Blake2bCtx {\n+    b: [u8; 128],\n+    h: [u64; 8],\n+    t: [u64; 2],\n+    c: usize,\n+    outlen: usize,\n+}\n+\n+impl ::std::fmt::Debug for Blake2bCtx {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{:?}\", self.h)\n+    }\n+}\n+\n+#[inline(always)]\n+fn b2b_g(v: &mut [u64; 16],\n+         a: usize,\n+         b: usize,\n+         c: usize,\n+         d: usize,\n+         x: u64,\n+         y: u64)\n+{\n+    v[a] = v[a].wrapping_add(v[b]).wrapping_add(x);\n+    v[d] = (v[d] ^ v[a]).rotate_right(32);\n+    v[c] = v[c].wrapping_add(v[d]);\n+    v[b] = (v[b] ^ v[c]).rotate_right(24);\n+    v[a] = v[a].wrapping_add(v[b]).wrapping_add(y);\n+    v[d] = (v[d] ^ v[a]).rotate_right(16);\n+    v[c] = v[c].wrapping_add(v[d]);\n+    v[b] = (v[b] ^ v[c]).rotate_right(63);\n+}\n+\n+// Initialization vector\n+const BLAKE2B_IV: [u64; 8] = [\n+   0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n+   0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n+   0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n+   0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n+];\n+\n+fn blake2b_compress(ctx: &mut Blake2bCtx, last: bool) {\n+\n+    const SIGMA: [[usize; 16]; 12] = [\n+        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n+        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ],\n+        [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 ],\n+        [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 ],\n+        [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 ],\n+        [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 ],\n+        [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 ],\n+        [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 ],\n+        [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 ],\n+        [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 ],\n+        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n+        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ]\n+    ];\n+\n+    let mut v: [u64; 16] = [\n+        ctx.h[0],\n+        ctx.h[1],\n+        ctx.h[2],\n+        ctx.h[3],\n+        ctx.h[4],\n+        ctx.h[5],\n+        ctx.h[6],\n+        ctx.h[7],\n+\n+        BLAKE2B_IV[0],\n+        BLAKE2B_IV[1],\n+        BLAKE2B_IV[2],\n+        BLAKE2B_IV[3],\n+        BLAKE2B_IV[4],\n+        BLAKE2B_IV[5],\n+        BLAKE2B_IV[6],\n+        BLAKE2B_IV[7],\n+    ];\n+\n+    v[12] ^= ctx.t[0]; // low 64 bits of offset\n+    v[13] ^= ctx.t[1]; // high 64 bits\n+    if last {\n+        v[14] = !v[14];\n+    }\n+\n+    {\n+        // Re-interpret the input buffer in the state as u64s\n+        let m: &mut [u64; 16] = unsafe {\n+            let b: &mut [u8; 128] = &mut ctx.b;\n+            ::std::mem::transmute(b)\n+        };\n+\n+        // It's OK to modify the buffer in place since this is the last time\n+        // this data will be accessed before it's overwritten\n+        if cfg!(target_endian = \"big\") {\n+            for word in &mut m[..] {\n+                *word = word.to_be();\n+            }\n+        }\n+\n+        for i in 0 .. 12 {\n+            b2b_g(&mut v, 0, 4,  8, 12, m[SIGMA[i][ 0]], m[SIGMA[i][ 1]]);\n+            b2b_g(&mut v, 1, 5,  9, 13, m[SIGMA[i][ 2]], m[SIGMA[i][ 3]]);\n+            b2b_g(&mut v, 2, 6, 10, 14, m[SIGMA[i][ 4]], m[SIGMA[i][ 5]]);\n+            b2b_g(&mut v, 3, 7, 11, 15, m[SIGMA[i][ 6]], m[SIGMA[i][ 7]]);\n+            b2b_g(&mut v, 0, 5, 10, 15, m[SIGMA[i][ 8]], m[SIGMA[i][ 9]]);\n+            b2b_g(&mut v, 1, 6, 11, 12, m[SIGMA[i][10]], m[SIGMA[i][11]]);\n+            b2b_g(&mut v, 2, 7,  8, 13, m[SIGMA[i][12]], m[SIGMA[i][13]]);\n+            b2b_g(&mut v, 3, 4,  9, 14, m[SIGMA[i][14]], m[SIGMA[i][15]]);\n+        }\n+    }\n+\n+    for i in 0 .. 8 {\n+        ctx.h[i] ^= v[i] ^ v[i + 8];\n+    }\n+}\n+\n+pub fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n+    assert!(outlen > 0 && outlen <= 64 && key.len() <= 64);\n+\n+    let mut ctx = Blake2bCtx {\n+        b: [0; 128],\n+        h: BLAKE2B_IV,\n+        t: [0; 2],\n+        c: 0,\n+        outlen: outlen,\n+    };\n+\n+    ctx.h[0] ^= 0x01010000 ^ ((key.len() << 8) as u64) ^ (outlen as u64);\n+\n+    if key.len() > 0 {\n+       blake2b_update(&mut ctx, key);\n+       ctx.c = ctx.b.len();\n+    }\n+\n+    ctx\n+}\n+\n+pub fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8])\n+{\n+    let mut bytes_to_copy = data.len();\n+    let mut space_in_buffer = ctx.b.len() - ctx.c;\n+\n+    while bytes_to_copy > space_in_buffer {\n+        checked_mem_copy(data, &mut ctx.b[ctx.c .. ], space_in_buffer);\n+\n+        ctx.t[0] = ctx.t[0].wrapping_add(ctx.b.len() as u64);\n+        if ctx.t[0] < (ctx.b.len() as u64) {\n+            ctx.t[1] += 1;\n+        }\n+        blake2b_compress(ctx, false);\n+        ctx.c = 0;\n+\n+        data = &data[space_in_buffer .. ];\n+        bytes_to_copy -= space_in_buffer;\n+        space_in_buffer = ctx.b.len();\n+    }\n+\n+    if bytes_to_copy > 0 {\n+        checked_mem_copy(data, &mut ctx.b[ctx.c .. ], bytes_to_copy);\n+        ctx.c += bytes_to_copy;\n+    }\n+}\n+\n+pub fn blake2b_final(mut ctx: Blake2bCtx, out: &mut [u8])\n+{\n+    ctx.t[0] = ctx.t[0].wrapping_add(ctx.c as u64);\n+    if ctx.t[0] < ctx.c as u64 {\n+        ctx.t[1] += 1;\n+    }\n+\n+    while ctx.c < 128 {\n+        ctx.b[ctx.c] = 0;\n+        ctx.c += 1;\n+    }\n+\n+    blake2b_compress(&mut ctx, true);\n+\n+    if cfg!(target_endian = \"big\") {\n+        // Make sure that the data is in memory in little endian format, as is\n+        // demanded by BLAKE2\n+        for word in &mut ctx.h {\n+            *word = word.to_le();\n+        }\n+    }\n+\n+    checked_mem_copy(&ctx.h, out, ctx.outlen);\n+}\n+\n+#[inline(always)]\n+fn checked_mem_copy<T1, T2>(from: &[T1], to: &mut [T2], byte_count: usize) {\n+    let from_size = from.len() * ::std::mem::size_of::<T1>();\n+    let to_size = to.len() * ::std::mem::size_of::<T2>();\n+    assert!(from_size >= byte_count);\n+    assert!(to_size >= byte_count);\n+    let from_byte_ptr = from.as_ptr() as * const u8;\n+    let to_byte_ptr = to.as_mut_ptr() as * mut u8;\n+    unsafe {\n+        ::std::ptr::copy_nonoverlapping(from_byte_ptr, to_byte_ptr, byte_count);\n+    }\n+}\n+\n+pub fn blake2b(out: &mut [u8], key: &[u8],  data: &[u8])\n+{\n+    let mut ctx = blake2b_new(out.len(), key);\n+    blake2b_update(&mut ctx, data);\n+    blake2b_final(ctx, out);\n+}\n+\n+#[cfg(test)]\n+fn selftest_seq(out: &mut [u8], seed: u32)\n+{\n+   let mut a: u32 = 0xDEAD4BADu32.wrapping_mul(seed);\n+   let mut b: u32 = 1;\n+\n+   for i in 0 .. out.len() {\n+       let t: u32 = a.wrapping_add(b);\n+       a = b;\n+       b = t;\n+       out[i] = ((t >> 24) & 0xFF) as u8;\n+   }\n+}\n+\n+#[test]\n+fn blake2b_selftest()\n+{\n+    // grand hash of hash results\n+    const BLAKE2B_RES: [u8; 32] = [\n+        0xC2, 0x3A, 0x78, 0x00, 0xD9, 0x81, 0x23, 0xBD,\n+        0x10, 0xF5, 0x06, 0xC6, 0x1E, 0x29, 0xDA, 0x56,\n+        0x03, 0xD7, 0x63, 0xB8, 0xBB, 0xAD, 0x2E, 0x73,\n+        0x7F, 0x5E, 0x76, 0x5A, 0x7B, 0xCC, 0xD4, 0x75\n+    ];\n+\n+    // parameter sets\n+    const B2B_MD_LEN: [usize; 4] = [20, 32, 48, 64];\n+    const B2B_IN_LEN: [usize; 6] = [0, 3, 128, 129, 255, 1024];\n+\n+    let mut data = [0u8; 1024];\n+    let mut md = [0u8; 64];\n+    let mut key = [0u8; 64];\n+\n+    let mut ctx = blake2b_new(32, &[]);\n+\n+    for i in 0 .. 4 {\n+       let outlen = B2B_MD_LEN[i];\n+       for j in 0 .. 6 {\n+            let inlen = B2B_IN_LEN[j];\n+\n+            selftest_seq(&mut data[.. inlen], inlen as u32); // unkeyed hash\n+            blake2b(&mut md[.. outlen], &[], &data[.. inlen]);\n+            blake2b_update(&mut ctx, &md[.. outlen]); // hash the hash\n+\n+            selftest_seq(&mut key[0 .. outlen], outlen as u32); // keyed hash\n+            blake2b(&mut md[.. outlen], &key[.. outlen], &data[.. inlen]);\n+            blake2b_update(&mut ctx, &md[.. outlen]); // hash the hash\n+       }\n+    }\n+\n+    // compute and compare the hash of hashes\n+    blake2b_final(ctx, &mut md[..]);\n+    for i in 0 .. 32 {\n+        assert_eq!(md[i], BLAKE2B_RES[i]);\n+    }\n+}"}, {"sha": "26b9f48ad04dd4041eb879e9b34dfad2098120c5", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -42,6 +42,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n extern crate libc;\n \n pub mod bitslice;\n+pub mod blake2b;\n pub mod bitvec;\n pub mod graph;\n pub mod ivar;"}, {"sha": "d92a8d375e0d3d76d1ec52560c30f38fc40627c4", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -9,38 +9,64 @@\n // except according to those terms.\n \n use std::hash::Hasher;\n-use std::collections::hash_map::DefaultHasher;\n+use std::mem;\n+use rustc_data_structures::blake2b;\n+use ich::Fingerprint;\n \n #[derive(Debug)]\n pub struct IchHasher {\n-    // FIXME: this should use SHA1, not DefaultHasher. DefaultHasher is not\n-    // built to avoid collisions.\n-    state: DefaultHasher,\n+    state: blake2b::Blake2bCtx,\n     bytes_hashed: u64,\n }\n \n impl IchHasher {\n     pub fn new() -> IchHasher {\n         IchHasher {\n-            state: DefaultHasher::new(),\n+            state: blake2b::blake2b_new(mem::size_of::<Fingerprint>(), &[]),\n             bytes_hashed: 0\n         }\n     }\n \n     pub fn bytes_hashed(&self) -> u64 {\n         self.bytes_hashed\n     }\n+\n+    pub fn finish(self) -> Fingerprint {\n+        let mut fingerprint = Fingerprint::zero();\n+        blake2b::blake2b_final(self.state, &mut fingerprint.0);\n+        fingerprint\n+    }\n }\n \n impl Hasher for IchHasher {\n-    #[inline]\n     fn finish(&self) -> u64 {\n-        self.state.finish()\n+        bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n     }\n \n     #[inline]\n     fn write(&mut self, bytes: &[u8]) {\n-        self.state.write(bytes);\n+        blake2b::blake2b_update(&mut self.state, bytes);\n         self.bytes_hashed += bytes.len() as u64;\n     }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i.to_le()) })\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i.to_le()) })\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i.to_le()) })\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        // always hash as u64, so we don't depend on the size of `usize`\n+        self.write_u64(i as u64);\n+    }\n }"}, {"sha": "3b0b37bb01ce31a57f76890506572b0dbd76d715", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -29,7 +29,7 @@\n \n use syntax::ast;\n use std::cell::RefCell;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n@@ -43,21 +43,22 @@ use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n use self::caching_codemap_view::CachingCodemapView;\n use self::hasher::IchHasher;\n+use ich::Fingerprint;\n \n mod def_path_hash;\n mod svh_visitor;\n mod caching_codemap_view;\n-mod hasher;\n+pub mod hasher;\n \n pub struct IncrementalHashesMap {\n-    hashes: FnvHashMap<DepNode<DefId>, u64>,\n+    hashes: FnvHashMap<DepNode<DefId>, Fingerprint>,\n \n     // These are the metadata hashes for the current crate as they were stored\n     // during the last compilation session. They are only loaded if\n     // -Z query-dep-graph was specified and are needed for auto-tests using\n     // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n     // check whether some metadata hash has changed in between two revisions.\n-    pub prev_metadata_hashes: RefCell<FnvHashMap<DefId, u64>>,\n+    pub prev_metadata_hashes: RefCell<FnvHashMap<DefId, Fingerprint>>,\n }\n \n impl IncrementalHashesMap {\n@@ -68,11 +69,12 @@ impl IncrementalHashesMap {\n         }\n     }\n \n-    pub fn insert(&mut self, k: DepNode<DefId>, v: u64) -> Option<u64> {\n+    pub fn insert(&mut self, k: DepNode<DefId>, v: Fingerprint) -> Option<Fingerprint> {\n         self.hashes.insert(k, v)\n     }\n \n-    pub fn iter<'a>(&'a self) -> ::std::collections::hash_map::Iter<'a, DepNode<DefId>, u64> {\n+    pub fn iter<'a>(&'a self)\n+                    -> ::std::collections::hash_map::Iter<'a, DepNode<DefId>, Fingerprint> {\n         self.hashes.iter()\n     }\n \n@@ -82,9 +84,9 @@ impl IncrementalHashesMap {\n }\n \n impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n-    type Output = u64;\n+    type Output = Fingerprint;\n \n-    fn index(&self, index: &'a DepNode<DefId>) -> &u64 {\n+    fn index(&self, index: &'a DepNode<DefId>) -> &Fingerprint {\n         &self.hashes[index]\n     }\n }\n@@ -141,12 +143,13 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n                                                    &mut self.def_path_hashes,\n                                                    &mut self.codemap,\n                                                    self.hash_spans));\n+        let bytes_hashed = state.bytes_hashed();\n         let item_hash = state.finish();\n         self.hashes.insert(DepNode::Hir(def_id), item_hash);\n         debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n \n         let bytes_hashed = self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n-                           state.bytes_hashed();\n+                           bytes_hashed;\n         self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n     }\n "}, {"sha": "005ac3896ce4c19a0ee5edb7271be5946a3d3a17", "filename": "src/librustc_incremental/ich/fingerprint.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n+\n+const FINGERPRINT_LENGTH: usize = 16;\n+\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy)]\n+pub struct Fingerprint(pub [u8; FINGERPRINT_LENGTH]);\n+\n+impl Fingerprint {\n+    #[inline]\n+    pub fn zero() -> Fingerprint {\n+        Fingerprint([0; FINGERPRINT_LENGTH])\n+    }\n+\n+    pub fn from_smaller_hash(hash: u64) -> Fingerprint {\n+        let mut result = Fingerprint::zero();\n+        result.0[0] = (hash >>  0) as u8;\n+        result.0[1] = (hash >>  8) as u8;\n+        result.0[2] = (hash >> 16) as u8;\n+        result.0[3] = (hash >> 24) as u8;\n+        result.0[4] = (hash >> 32) as u8;\n+        result.0[5] = (hash >> 40) as u8;\n+        result.0[6] = (hash >> 48) as u8;\n+        result.0[7] = (hash >> 56) as u8;\n+        result\n+    }\n+\n+    pub fn to_smaller_hash(&self) -> u64 {\n+        ((self.0[0] as u64) <<  0) |\n+        ((self.0[1] as u64) <<  8) |\n+        ((self.0[2] as u64) << 16) |\n+        ((self.0[3] as u64) << 24) |\n+        ((self.0[4] as u64) << 32) |\n+        ((self.0[5] as u64) << 40) |\n+        ((self.0[6] as u64) << 48) |\n+        ((self.0[7] as u64) << 56)\n+    }\n+}\n+\n+impl Encodable for Fingerprint {\n+    #[inline]\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        for &byte in &self.0[..] {\n+            s.emit_u8(byte)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Decodable for Fingerprint {\n+    #[inline]\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Fingerprint, D::Error> {\n+        let mut result = Fingerprint([0u8; FINGERPRINT_LENGTH]);\n+        for byte in &mut result.0[..] {\n+            *byte = d.read_u8()?;\n+        }\n+        Ok(result)\n+    }\n+}\n+\n+impl ::std::fmt::Display for Fingerprint {\n+    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        for i in 0 .. self.0.len() {\n+            if i > 0 {\n+                write!(formatter, \"::\")?;\n+            }\n+\n+            write!(formatter, \"{}\", self.0[i])?;\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "8edd04322d7f65302059a6930597008840dcf702", "filename": "src/librustc_incremental/ich/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fich%2Fmod.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::fingerprint::Fingerprint;\n+\n+mod fingerprint;"}, {"sha": "577e50699bffd5310d0011feb112ea830a84fed9", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -45,6 +45,7 @@ const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n mod assert_dep_graph;\n mod calculate_svh;\n mod persist;\n+pub mod ich;\n \n pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::compute_incremental_hashes_map;"}, {"sha": "734ffe6a94412024405564a6685cc5048ede21da", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -14,6 +14,7 @@ use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n use std::sync::Arc;\n use rustc_data_structures::fnv::FnvHashMap;\n+use ich::Fingerprint;\n \n use super::directory::DefPathIndex;\n \n@@ -60,7 +61,7 @@ pub struct SerializedHash {\n \n     /// the hash as of previous compilation, computed by code in\n     /// `hash` module\n-    pub hash: u64,\n+    pub hash: Fingerprint,\n }\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n@@ -116,5 +117,5 @@ pub struct SerializedMetadataHash {\n     pub def_index: DefIndex,\n \n     /// the hash itself, computed by `calculate_item_hash`\n-    pub hash: u64,\n+    pub hash: Fingerprint,\n }"}, {"sha": "0418148ffc7df6f374e559b26bd654b316092a68", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -51,6 +51,7 @@ use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n+use ich::Fingerprint;\n \n use {ATTR_DIRTY, ATTR_CLEAN, ATTR_DIRTY_METADATA, ATTR_CLEAN_METADATA};\n \n@@ -186,8 +187,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n }\n \n pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  prev_metadata_hashes: &FnvHashMap<DefId, u64>,\n-                                  current_metadata_hashes: &FnvHashMap<DefId, u64>) {\n+                                  prev_metadata_hashes: &FnvHashMap<DefId, Fingerprint>,\n+                                  current_metadata_hashes: &FnvHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return;\n     }\n@@ -204,8 +205,8 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    prev_metadata_hashes: &'m FnvHashMap<DefId, u64>,\n-    current_metadata_hashes: &'m FnvHashMap<DefId, u64>,\n+    prev_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n+    current_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n }\n \n impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {"}, {"sha": "e365cbbd3a9a10b417a4301cf77f96eaab44e1f9", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -18,14 +18,15 @@ use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n \n use IncrementalHashesMap;\n+use ich::Fingerprint;\n use super::data::*;\n use super::fs::*;\n use super::file_format;\n \n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n-    item_metadata_hashes: FnvHashMap<DefId, u64>,\n+    item_metadata_hashes: FnvHashMap<DefId, Fingerprint>,\n     crate_hashes: FnvHashMap<CrateNum, Svh>,\n }\n \n@@ -50,7 +51,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<u64> {\n+    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<Fingerprint> {\n         match *dep_node {\n             DepNode::Krate => {\n                 Some(self.incremental_hashes_map[dep_node])\n@@ -89,7 +90,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    fn metadata_hash(&mut self, def_id: DefId) -> u64 {\n+    fn metadata_hash(&mut self, def_id: DefId) -> Fingerprint {\n         debug!(\"metadata_hash(def_id={:?})\", def_id);\n \n         assert!(!def_id.is_local());\n@@ -102,14 +103,15 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n \n             // check whether we did not find detailed metadata for this\n             // krate; in that case, we just use the krate's overall hash\n-            if let Some(&hash) = self.crate_hashes.get(&def_id.krate) {\n-                debug!(\"metadata_hash: def_id={:?} crate_hash={:?}\", def_id, hash);\n+            if let Some(&svh) = self.crate_hashes.get(&def_id.krate) {\n+                debug!(\"metadata_hash: def_id={:?} crate_hash={:?}\", def_id, svh);\n \n                 // micro-\"optimization\": avoid a cache miss if we ask\n                 // for metadata from this particular def-id again.\n-                self.item_metadata_hashes.insert(def_id, hash.as_u64());\n+                let fingerprint = svh_to_fingerprint(svh);\n+                self.item_metadata_hashes.insert(def_id, fingerprint);\n \n-                return hash.as_u64();\n+                return fingerprint;\n             }\n \n             // otherwise, load the data and repeat.\n@@ -206,3 +208,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         Ok(())\n     }\n }\n+\n+fn svh_to_fingerprint(svh: Svh) -> Fingerprint {\n+    Fingerprint::from_smaller_hash(svh.as_u64())\n+}"}, {"sha": "1f43e79ace3ae67a6df3f2473770689c06d9a88f", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -22,6 +22,7 @@ use std::fs;\n use std::path::{Path};\n \n use IncrementalHashesMap;\n+use ich::Fingerprint;\n use super::data::*;\n use super::directory::*;\n use super::dirty_clean;\n@@ -315,7 +316,7 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n \n fn load_prev_metadata_hashes(tcx: TyCtxt,\n                              retraced: &RetracedDefIdDirectory,\n-                             output: &mut FnvHashMap<DefId, u64>) {\n+                             output: &mut FnvHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return\n     }"}, {"sha": "fe1d627253f286a16c455bae6450be9dfb5cbdfe", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -14,6 +14,7 @@ use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n \n use super::hash::*;\n+use ich::Fingerprint;\n \n /// A data-structure that makes it easy to enumerate the hashable\n /// predecessors of any given dep-node.\n@@ -26,7 +27,7 @@ pub struct Predecessors<'query> {\n \n     // - Keys: some hashable node\n     // - Values: the hash thereof\n-    pub hashes: FnvHashMap<&'query DepNode<DefId>, u64>,\n+    pub hashes: FnvHashMap<&'query DepNode<DefId>, Fingerprint>,\n }\n \n impl<'q> Predecessors<'q> {"}, {"sha": "bc156b0e8913b21a159a1825eb43ecd93858ad82", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -16,20 +16,21 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n-use std::collections::hash_map::DefaultHasher;\n \n use IncrementalHashesMap;\n+use ich::Fingerprint;\n use super::data::*;\n use super::directory::*;\n use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n use super::file_format;\n+use calculate_svh::hasher::IchHasher;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,\n@@ -185,7 +186,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n                               preds: &Predecessors,\n                               builder: &mut DefIdDirectoryBuilder,\n-                              current_metadata_hashes: &mut FnvHashMap<DefId, u64>,\n+                              current_metadata_hashes: &mut FnvHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n     // For each `MetaData(X)` node where `X` is local, accumulate a\n@@ -233,7 +234,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n         // is the det. hash of the def-path. This is convenient\n         // because we can sort this to get a stable ordering across\n         // compilations, even if the def-ids themselves have changed.\n-        let mut hashes: Vec<(DepNode<u64>, u64)> = sources.iter()\n+        let mut hashes: Vec<(DepNode<u64>, Fingerprint)> = sources.iter()\n             .map(|dep_node| {\n                 let hash_dep_node = dep_node.map_def(|&def_id| Some(def_id_hash(def_id))).unwrap();\n                 let hash = preds.hashes[dep_node];\n@@ -242,7 +243,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n             .collect();\n \n         hashes.sort();\n-        let mut state = DefaultHasher::new();\n+        let mut state = IchHasher::new();\n         hashes.hash(&mut state);\n         let hash = state.finish();\n "}, {"sha": "e46bdbb5ccf4ae9399151e621a7caacd548afeca", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7343291ac3d438f16453c2fbd1cec329ed2aa7ac/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=7343291ac3d438f16453c2fbd1cec329ed2aa7ac", "patch": "@@ -130,7 +130,7 @@ pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n                        -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n-        crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate]),\n+        crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate].to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);\n     return r;"}]}