{"sha": "0ea031bcb8c237365b8bf15ae474972570cf15f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYTAzMWJjYjhjMjM3MzY1YjhiZjE1YWU0NzQ5NzI1NzBjZjE1Zjk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-06T02:38:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-08T06:37:03Z"}, "message": "librustc: Remove record patterns from the compiler", "tree": {"sha": "8d022c7d9aaa0cb1f943fe7c3b7acd9750a7c08a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d022c7d9aaa0cb1f943fe7c3b7acd9750a7c08a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ea031bcb8c237365b8bf15ae474972570cf15f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea031bcb8c237365b8bf15ae474972570cf15f9", "html_url": "https://github.com/rust-lang/rust/commit/0ea031bcb8c237365b8bf15ae474972570cf15f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ea031bcb8c237365b8bf15ae474972570cf15f9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "954ae9c975cebb7186dfc1182a68d2559bdef4bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/954ae9c975cebb7186dfc1182a68d2559bdef4bd", "html_url": "https://github.com/rust-lang/rust/commit/954ae9c975cebb7186dfc1182a68d2559bdef4bd"}], "stats": {"total": 105, "additions": 31, "deletions": 74}, "files": [{"sha": "07782c25284e56b497be087ab3f32fdfb87b2d4f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -319,8 +319,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n           _ => Some(single)\n         }\n       }\n-      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) |\n-      pat_region(*) => {\n+      pat_box(_) | pat_uniq(_) | pat_tup(_) | pat_region(*) => {\n         Some(single)\n       }\n       pat_vec(elems, tail) => {\n@@ -547,7 +546,6 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     _ => None\n                 }\n             }\n-            pat_rec(ref flds, _) => fail!(),\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n                 match cx.tcx.def_map.get(&pat_id) {\n@@ -709,9 +707,6 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n         false\n       }\n       pat_lit(_) | pat_range(_, _) => { true }\n-      pat_rec(fields, _) => {\n-        fields.any(|f| is_refutable(cx, f.pat))\n-      }\n       pat_struct(_, fields, _) => {\n         fields.any(|f| is_refutable(cx, f.pat))\n       }"}, {"sha": "18cf02cf66d9c5e4c96f93dea5e6e484da72be6e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -942,7 +942,6 @@ pub impl mem_categorization_ctxt {\n               // nullary variant or identifier: ignore\n           }\n \n-          ast::pat_rec(ref field_pats, _) |\n           ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {"}, {"sha": "075d4673636d413aaedb11f9c62a458b362669d7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -47,7 +47,7 @@ use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n use syntax::ast::{local, local_crate, lt, method, mode, module_ns, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n-use syntax::ast::{path, pat_box, pat_lit, pat_range, pat_rec, pat_struct};\n+use syntax::ast::{path, pat_box, pat_lit, pat_range, pat_struct};\n use syntax::ast::{pat_tup, pat_uniq, pat_wild, prim_ty, private, provided};\n use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n use syntax::ast::{struct_dtor, struct_field, struct_variant_kind, sty_by_ref};"}, {"sha": "d7254ffa66037f3b1784d0ad2004ecf9d3fd4b65", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -459,8 +459,7 @@ pub fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) |\n-          ast::pat_struct(*) => Some(~[]),\n+          ast::pat_wild | ast::pat_tup(_) | ast::pat_struct(*) => Some(~[]),\n           ast::pat_ident(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n@@ -611,7 +610,7 @@ pub fn enter_rec_or_struct(bcx: block,\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match /*bad*/copy p.node {\n-            ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n+            ast::pat_struct(_, fpats, _) => {\n                 let mut pats = ~[];\n                 for vec::each(fields) |fname| {\n                     match fpats.find(|p| p.ident == *fname) {\n@@ -887,7 +886,6 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n         match /*bad*/copy br.pats[col].node {\n-          ast::pat_rec(fs, _) => extend(&mut fields, fs),\n           ast::pat_struct(_, fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n               ty::ty_struct(*) => extend(&mut fields, fs),\n@@ -1766,7 +1764,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 }\n             }\n         }\n-        ast::pat_rec(fields, _) | ast::pat_struct(_, fields, _) => {\n+        ast::pat_struct(_, fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);"}, {"sha": "e39de62cd297c169bb26f6d457fee3c6469d4f8c", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -155,7 +155,7 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n                 Unit(cases[0].discr)\n             } else if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n-                assert cases[0].discr == 0;\n+                fail_unless!(cases[0].discr == 0);\n                 Univariant(mk_struct(cx, cases[0].tys), NonStruct)\n             } else if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n@@ -302,18 +302,18 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n         Unit(the_discr) => {\n-            assert discr == the_discr;\n+            fail_unless!(discr == the_discr);\n         }\n         CEnum(min, max) => {\n-            assert min <= discr && discr <= max;\n+            fail_unless!(min <= discr && discr <= max);\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(_, StructWithDtor) => {\n-            assert discr == 0;\n+            fail_unless!(discr == 0);\n             Store(bcx, C_u8(1), GEPi(bcx, val, [0, 1]))\n         }\n         Univariant(*) => {\n-            assert discr == 0;\n+            fail_unless!(discr == 0);\n         }\n         General(*) => {\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n@@ -328,7 +328,7 @@ pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n         Unit(*) | CEnum(*) => 0,\n-        Univariant(ref st, _dt) => { assert discr == 0; st.fields.len() }\n+        Univariant(ref st, _) => { fail_unless!(discr == 0); st.fields.len() }\n         General(ref cases) => cases[discr as uint].fields.len()\n     }\n }\n@@ -344,7 +344,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n         Univariant(ref st, dt) => {\n-            assert discr == 0;\n+            fail_unless!(discr == 0);\n             let val = match dt {\n                 NonStruct => val,\n                 StructWithDtor | StructWithoutDtor => GEPi(bcx, val, [0, 0])\n@@ -411,12 +411,12 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n             C_struct(~[])\n         }\n         CEnum(min, max) => {\n-            assert vals.len() == 0;\n-            assert min <= discr && discr <= max;\n+            fail_unless!(vals.len() == 0);\n+            fail_unless!(min <= discr && discr <= max);\n             C_int(ccx, discr)\n         }\n         Univariant(ref st, dt) => {\n-            assert discr == 0;\n+            fail_unless!(discr == 0);\n             let s = C_struct(build_const_struct(ccx, st, vals));\n             match dt {\n                 NonStruct => s,\n@@ -452,7 +452,7 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n  */\n fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n     -> ~[ValueRef] {\n-    assert vals.len() == st.fields.len();\n+    fail_unless!(vals.len() == st.fields.len());\n \n     let mut offset = 0;\n     let mut cfields = ~[];\n@@ -468,7 +468,7 @@ fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n             cfields.push(padding(target_offset - offset));\n             offset = target_offset;\n         }\n-        assert !is_undef(vals[i]);\n+        fail_unless!(!is_undef(vals[i]));\n         // If that assert fails, could change it to wrap in a struct?\n         // (See `const_struct_field` for why real fields must not be undef.)\n         cfields.push(vals[i]);"}, {"sha": "ac150d44e3914619f604826dee2d70b0b9ec43ea", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -679,7 +679,7 @@ pub impl Datum {\n                 }\n \n                 let repr = adt::represent_type(ccx, self.ty);\n-                assert adt::is_newtypeish(repr);\n+                fail_unless!(adt::is_newtypeish(repr));\n                 let ty = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n                 return match self.mode {\n                     ByRef => {\n@@ -719,7 +719,7 @@ pub impl Datum {\n                 }\n \n                 let repr = adt::represent_type(ccx, self.ty);\n-                assert adt::is_newtypeish(repr);\n+                fail_unless!(adt::is_newtypeish(repr));\n                 let ty = fields[0].mt.ty;\n                 return match self.mode {\n                     ByRef => {"}, {"sha": "1da4cbe7c91cc2fe6f3e8a929d8c9233d675ca6b", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -414,12 +414,6 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       ast::pat_enum(path, subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n-      ast::pat_rec(fields, etc) => {\n-        tcx.sess.span_fatal\n-            (pat.span,\n-            fmt!(\"mismatched types: expected `%s` but found record\",\n-                 fcx.infcx().ty_to_str(expected)));\n-      }\n       ast::pat_struct(path, fields, etc) => {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);"}, {"sha": "204991d50d3944fd8d7d117a76aef9ad42da0694", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -874,7 +874,6 @@ pub mod guarantor {\n                 }\n             }\n             ast::pat_enum(*) => {}\n-            ast::pat_rec(ref fpats, _) |\n             ast::pat_struct(_, ref fpats, _) => {\n                 for fpats.each |fpat| {\n                     link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);"}, {"sha": "0581f5f96b080d410763e0848a6b5515f7c4c27d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -302,7 +302,6 @@ pub enum pat_ {\n     pat_ident(binding_mode, @path, Option<@pat>),\n     pat_enum(@path, Option<~[@pat]>), /* \"none\" means a * pattern where\n                                        * we don't bind the fields to names */\n-    pat_rec(~[field_pat], bool),\n     pat_struct(@path, ~[field_pat], bool),\n     pat_tup(~[@pat]),\n     pat_box(@pat),"}, {"sha": "686ae3900ff43e4d249f885141cf22ddb3f94419", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -520,7 +520,7 @@ pub fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n-        pat_rec(ref fields, _) | pat_struct(_, ref fields, _) => {\n+        pat_struct(_, ref fields, _) => {\n             for fields.each |f| {\n                 walk_pat(f.pat, it)\n             }"}, {"sha": "ea18598f75cae106111f721d4abaa671bc57c02a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -399,15 +399,6 @@ pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n                 pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n             )\n         }\n-        pat_rec(ref fields, etc) => {\n-            let fs = do fields.map |f| {\n-                ast::field_pat {\n-                    ident: /* FIXME (#2543) */ copy f.ident,\n-                    pat: fld.fold_pat(f.pat),\n-                }\n-            };\n-            pat_rec(fs, etc)\n-        }\n         pat_struct(pth, ref fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n             let fs = do fields.map |f| {"}, {"sha": "4e1b34bb2995a9bd901994de664031fcb58a2696", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -50,6 +50,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteMutVector,\n     ObsoleteTraitImplVisibility,\n     ObsoleteRecordType,\n+    ObsoleteRecordPattern,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -150,6 +151,10 @@ pub impl Parser {\n                 \"structural record type\",\n                 \"use a structure instead\"\n             ),\n+            ObsoleteRecordPattern => (\n+                \"structural record pattern\",\n+                \"use a structure instead\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "2a113c446121ff5cdcf659b09ef8b18f1ac63861", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -40,8 +40,8 @@ use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local, m_const};\n use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mode, module_ns, mt, mul, mutability};\n use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n-use ast::{pat_ident, pat_lit, pat_range, pat_rec, pat_region, pat_struct};\n-use ast::{pat_tup, pat_uniq, pat_wild, path, private};\n+use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct, pat_tup};\n+use ast::{pat_uniq, pat_wild, path, private};\n use ast::{re_self, re_anon, re_named, region, rem, required};\n use ast::{ret_style, return_val, self_ty, shl, shr, stmt, stmt_decl};\n use ast::{stmt_expr, stmt_semi, stmt_mac, struct_def, struct_field};\n@@ -75,7 +75,7 @@ use parse::obsolete::{ObsoleteSyntax, ObsoleteLowerCaseKindBounds};\n use parse::obsolete::{ObsoleteUnsafeBlock, ObsoleteImplSyntax};\n use parse::obsolete::{ObsoleteTraitBoundSeparator, ObsoleteMutOwnedPointer};\n use parse::obsolete::{ObsoleteMutVector, ObsoleteTraitImplVisibility};\n-use parse::obsolete::{ObsoleteRecordType};\n+use parse::obsolete::{ObsoleteRecordType, ObsoleteRecordPattern};\n use parse::prec::{as_prec, token_to_binop};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, special_idents};\n@@ -2192,10 +2192,11 @@ pub impl Parser {\n           }\n           token::LBRACE => {\n             self.bump();\n-            let (fields, etc) = self.parse_pat_fields(refutable);\n+            let (_, _) = self.parse_pat_fields(refutable);\n             hi = self.span.hi;\n             self.bump();\n-            pat = pat_rec(fields, etc);\n+            self.obsolete(*self.span, ObsoleteRecordPattern);\n+            pat = pat_wild;\n           }\n           token::LPAREN => {\n             self.bump();"}, {"sha": "c0ce8ec45aaf7c627565cff600b8ae2152987e62", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -1574,25 +1574,6 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n           }\n         }\n       }\n-      ast::pat_rec(fields, etc) => {\n-        word(s.s, ~\"{\");\n-        fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n-            cbox(s, indent_unit);\n-            print_ident(s, f.ident);\n-            word_space(s, ~\":\");\n-            print_pat(s, f.pat, refutable);\n-            end(s);\n-        }\n-        fn get_span(f: ast::field_pat) -> codemap::span { return f.pat.span; }\n-        commasep_cmnt(s, consistent, fields,\n-                      |s, f| print_field(s, f, refutable),\n-                      get_span);\n-        if etc {\n-            if vec::len(fields) != 0u { word_space(s, ~\",\"); }\n-            word(s.s, ~\"_\");\n-        }\n-        word(s.s, ~\"}\");\n-      }\n       ast::pat_struct(path, fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, ~\"{\");"}, {"sha": "8b277b221491f17eb873004e2dde19682082a2a9", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea031bcb8c237365b8bf15ae474972570cf15f9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0ea031bcb8c237365b8bf15ae474972570cf15f9", "patch": "@@ -263,11 +263,6 @@ pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n                 for children.each |child| { (v.visit_pat)(*child, e, v); }\n             }\n         }\n-        pat_rec(ref fields, _) => {\n-            for fields.each |f| {\n-                (v.visit_pat)(f.pat, e, v)\n-            }\n-        },\n         pat_struct(path, ref fields, _) => {\n             visit_path(path, e, v);\n             for fields.each |f| {"}]}