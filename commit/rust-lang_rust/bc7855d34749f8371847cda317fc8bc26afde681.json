{"sha": "bc7855d34749f8371847cda317fc8bc26afde681", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNzg1NWQzNDc0OWY4MzcxODQ3Y2RhMzE3ZmM4YmMyNmFmZGU2ODE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-23T04:22:48Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-23T04:22:48Z"}, "message": "Idempotent tests and comments in function decls", "tree": {"sha": "7a513c7831b9a706753069b1baec02a7b434ed7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a513c7831b9a706753069b1baec02a7b434ed7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc7855d34749f8371847cda317fc8bc26afde681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7855d34749f8371847cda317fc8bc26afde681", "html_url": "https://github.com/rust-lang/rust/commit/bc7855d34749f8371847cda317fc8bc26afde681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc7855d34749f8371847cda317fc8bc26afde681/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "854b52dbedbfe4944309514e98a7aba4185c2c5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/854b52dbedbfe4944309514e98a7aba4185c2c5c", "html_url": "https://github.com/rust-lang/rust/commit/854b52dbedbfe4944309514e98a7aba4185c2c5c"}], "stats": {"total": 366, "additions": 295, "deletions": 71}, "files": [{"sha": "ce89c2625fc0229d070b1bcdce4b75e89283c346", "filename": "src/changes.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc7855d34749f8371847cda317fc8bc26afde681/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7855d34749f8371847cda317fc8bc26afde681/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=bc7855d34749f8371847cda317fc8bc26afde681", "patch": "@@ -115,15 +115,19 @@ impl<'a> ChangeSet<'a> {\n         }\n     }\n \n-    pub fn write_all_files(&self, mode: WriteMode) -> Result<(), ::std::io::Error> {\n+    pub fn write_all_files(&self, mode: WriteMode) -> Result<(HashMap<String, String>), ::std::io::Error> {\n+        let mut result = HashMap::new();\n         for filename in self.file_map.keys() {\n-            try!(self.write_file(filename, mode));\n+            let one_result = try!(self.write_file(filename, mode));\n+            if let Some(r) = one_result {\n+                result.insert(filename.clone(), r);\n+            }\n         }\n \n-        Ok(())\n+        Ok(result)\n     }\n \n-    pub fn write_file(&self, filename: &str, mode: WriteMode) -> Result<(), ::std::io::Error> {\n+    pub fn write_file(&self, filename: &str, mode: WriteMode) -> Result<Option<String>, ::std::io::Error> {\n         let text = &self.file_map[filename];\n \n         match mode {\n@@ -147,13 +151,16 @@ impl<'a> ChangeSet<'a> {\n                 let mut file = try!(File::create(&filename));\n                 try!(write!(file, \"{}\", text));\n             }\n-            _ => {\n+            WriteMode::Display => {\n                 println!(\"{}:\\n\", filename);\n                 println!(\"{}\", text);\n             }\n+            WriteMode::Return(_) => {\n+                return Ok(Some(text.to_string()));\n+            }\n         }\n \n-        Ok(())\n+        Ok(None)\n     }\n }\n "}, {"sha": "e7f80922e8af2cce971c076a4f7179a5c622be19", "filename": "src/functions.rs", "status": "modified", "additions": 162, "deletions": 52, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/bc7855d34749f8371847cda317fc8bc26afde681/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7855d34749f8371847cda317fc8bc26afde681/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=bc7855d34749f8371847cda317fc8bc26afde681", "patch": "@@ -14,12 +14,11 @@ use utils::make_indent;\n use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n use visitor::FmtVisitor;\n use syntax::{ast, abi};\n-use syntax::codemap::{self, Span};\n+use syntax::codemap::{self, Span, BytePos};\n use syntax::print::pprust;\n use syntax::parse::token;\n \n impl<'a> FmtVisitor<'a> {\n-    // TODO extract methods for args and generics\n     pub fn rewrite_fn(&mut self,\n                       indent: usize,\n                       ident: ast::Ident,\n@@ -28,7 +27,9 @@ impl<'a> FmtVisitor<'a> {\n                       generics: &ast::Generics,\n                       unsafety: &ast::Unsafety,\n                       abi: &abi::Abi,\n-                      vis: ast::Visibility)\n+                      vis: ast::Visibility,\n+                      next_span: Span) // next_span is a nasty hack, its a loose upper\n+                                       // bound on any comments after the where clause.\n         -> String\n     {\n         // FIXME we'll lose any comments in between parts of the function decl, but anyone\n@@ -56,7 +57,10 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&token::get_ident(ident));\n \n         // Generics.\n-        result.push_str(&self.rewrite_generics(generics, indent));\n+        let generics_indent = indent + result.len();\n+        result.push_str(&self.rewrite_generics(generics,\n+                                               generics_indent,\n+                                               span_for_return(&fd.output)));\n \n         let ret_str = self.rewrite_return(&fd.output);\n \n@@ -74,7 +78,7 @@ impl<'a> FmtVisitor<'a> {\n         result.push(')');\n \n         // Where clause.\n-        result.push_str(&self.rewrite_where_clause(where_clause, indent));\n+        result.push_str(&self.rewrite_where_clause(where_clause, indent, next_span));\n \n         // Return type.\n         if ret_str.len() > 0 {\n@@ -98,6 +102,8 @@ impl<'a> FmtVisitor<'a> {\n             result.push_str(&ret_str);\n         }\n \n+        // TODO any comments here?\n+\n         // Prepare for the function body by possibly adding a newline and indent.\n         // FIXME we'll miss anything between the end of the signature and the start\n         // of the body, but we need more spans from the compiler to solve this.\n@@ -157,40 +163,28 @@ impl<'a> FmtVisitor<'a> {\n         // spans for the comment or parens, there is no chance of getting it right.\n         // You also don't get to put a comment on self, unless it is explicit.\n         if args.len() >= min_args {\n-            let mut prev_end = args[min_args-1].ty.span.hi;\n-            for arg in &args[min_args..] {\n-                let cur_start = arg.pat.span.lo;\n-                let snippet = self.snippet(codemap::mk_sp(prev_end, cur_start));\n-                let mut snippet = snippet.trim();\n-                if snippet.starts_with(\",\") {\n-                    snippet = snippet[1..].trim();\n-                } else if snippet.ends_with(\",\") {\n-                    snippet = snippet[..snippet.len()-1].trim();\n-                }\n-                arg_comments.push(snippet.to_string());\n-                prev_end = arg.ty.span.hi;\n-            }\n-            // Get the last commment.\n-            // FIXME If you thought the crap with the commas was ugly, just wait.\n-            // This is awful. We're going to look from the last arg span to the\n-            // start of the return type span, then we drop everything after the\n-            // first closing paren. Obviously, this will break if there is a \n-            // closing paren in the comment.\n-            // The fix is comments in the AST or a span for the closing paren.\n-            let snippet = self.snippet(codemap::mk_sp(prev_end, ret_span.lo));\n-            let snippet = snippet.trim();\n-            let snippet = &snippet[..snippet.find(\")\").unwrap()];\n-            let snippet = snippet.trim();\n-            arg_comments.push(snippet.to_string());\n+            arg_comments = self.make_comments_for_list(arg_comments,\n+                                                       args[min_args-1..].iter(),\n+                                                       \",\",\n+                                                       \")\",\n+                                                       |arg| arg.pat.span.lo,\n+                                                       |arg| arg.ty.span.hi,\n+                                                       ret_span.lo);\n         }\n \n         debug!(\"comments: {:?}\", arg_comments);\n \n+        // If there are // comments, keep them multi-line.\n+        let mut list_tactic = ListTactic::HorizontalVertical;\n+        if arg_comments.iter().any(|c| c.contains(\"//\")) {\n+            list_tactic = ListTactic::Vertical;\n+        }\n+\n         assert_eq!(arg_item_strs.len(), arg_comments.len());\n         let arg_strs: Vec<_> = arg_item_strs.into_iter().zip(arg_comments.into_iter()).collect();\n \n         let fmt = ListFormatting {\n-            tactic: ListTactic::HorizontalVertical,\n+            tactic: list_tactic,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::Never,\n             indent: arg_indent,\n@@ -201,6 +195,51 @@ impl<'a> FmtVisitor<'a> {\n         write_list(&arg_strs, &fmt)\n     }\n \n+    // Gets comments in between items of a list. \n+    fn make_comments_for_list<T, I, F1, F2>(&self,\n+                                            prefix: Vec<String>,\n+                                            mut it: I,\n+                                            separator: &str,\n+                                            terminator: &str,\n+                                            get_lo: F1,\n+                                            get_hi: F2,\n+                                            next_span_start: BytePos)\n+        -> Vec<String>\n+        where I: Iterator<Item=T>,\n+              F1: Fn(&T) -> BytePos,\n+              F2: Fn(&T) -> BytePos\n+    {\n+        let mut result = prefix;\n+\n+        let mut prev_end = get_hi(&it.next().unwrap());\n+        for item in it {\n+            let cur_start = get_lo(&item);\n+            let snippet = self.snippet(codemap::mk_sp(prev_end, cur_start));\n+            let mut snippet = snippet.trim();\n+            if snippet.starts_with(separator) {\n+                snippet = snippet[1..].trim();\n+            } else if snippet.ends_with(separator) {\n+                snippet = snippet[..snippet.len()-1].trim();\n+            }\n+            result.push(snippet.to_string());\n+            prev_end = get_hi(&item);\n+        }\n+        // Get the last commment.\n+        // FIXME If you thought the crap with the commas was ugly, just wait.\n+        // This is awful. We're going to look from the last item span to the\n+        // start of the return type span, then we drop everything after the\n+        // first closing paren. Obviously, this will break if there is a \n+        // closing paren in the comment.\n+        // The fix is comments in the AST or a span for the closing paren.\n+        let snippet = self.snippet(codemap::mk_sp(prev_end, next_span_start));\n+        let snippet = snippet.trim();\n+        let snippet = &snippet[..snippet.find(terminator).unwrap()];\n+        let snippet = snippet.trim();\n+        result.push(snippet.to_string());\n+\n+        result\n+    }\n+\n     fn compute_budgets_for_args(&self,\n                                 result: &mut String,\n                                 indent: usize,\n@@ -260,37 +299,70 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n-    fn rewrite_generics(&self, generics: &ast::Generics, indent: usize) -> String {\n+    fn rewrite_generics(&self, generics: &ast::Generics, indent: usize, ret_span: Span) -> String {\n         // FIXME convert bounds to where clauses where they get too big or if\n         // there is a where clause at all.\n         let mut result = String::new();\n         let lifetimes: &[_] = &generics.lifetimes;\n         let tys: &[_] = &generics.ty_params;\n-        if lifetimes.len() + tys.len() > 0 {\n-            let budget = MAX_WIDTH - indent - result.len() - 2;\n-            // TODO might need to insert a newline if the generics are really long\n-            result.push('<');\n-\n-            let lt_strs = lifetimes.iter().map(|l| self.rewrite_lifetime_def(l));\n-            let ty_strs = tys.iter().map(|ty| self.rewrite_ty_param(ty));\n-            let generics_strs: Vec<_> = lt_strs.chain(ty_strs).map(|s| (s, String::new())).collect();\n-            let fmt = ListFormatting {\n-                tactic: ListTactic::HorizontalVertical,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Never,\n-                indent: indent + result.len() + 1,\n-                h_width: budget,\n-                v_width: budget,\n-            };\n-            result.push_str(&write_list(&generics_strs, &fmt));\n+        if lifetimes.len() + tys.len() == 0 {\n+            return result;\n+        }\n \n-            result.push('>');\n+        let budget = MAX_WIDTH - indent - 2;\n+        // TODO might need to insert a newline if the generics are really long\n+        result.push('<');\n+\n+        // Strings for the generics.\n+        let lt_strs = lifetimes.iter().map(|l| self.rewrite_lifetime_def(l));\n+        let ty_strs = tys.iter().map(|ty| self.rewrite_ty_param(ty));\n+\n+        // Extract comments between generics.\n+        let lt_spans = lifetimes.iter().map(|l| {\n+            let hi = if l.bounds.len() == 0 {\n+                l.lifetime.span.hi\n+            } else {\n+                l.bounds[l.bounds.len() - 1].span.hi\n+            };\n+            codemap::mk_sp(l.lifetime.span.lo, hi)\n+        });\n+        let ty_spans = tys.iter().map(span_for_ty_param);\n+        let comments = self.make_comments_for_list(Vec::new(),\n+                                                   lt_spans.chain(ty_spans),\n+                                                   \",\",\n+                                                   \">\",\n+                                                   |sp| sp.lo,\n+                                                   |sp| sp.hi,\n+                                                   ret_span.lo);\n+\n+        // If there are // comments, keep them multi-line.\n+        let mut list_tactic = ListTactic::HorizontalVertical;\n+        if comments.iter().any(|c| c.contains(\"//\")) {\n+            list_tactic = ListTactic::Vertical;\n         }\n \n+        let generics_strs: Vec<_> = lt_strs.chain(ty_strs).zip(comments.into_iter()).collect();\n+        let fmt = ListFormatting {\n+            tactic: list_tactic,\n+            separator: \",\",\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: indent + 1,\n+            h_width: budget,\n+            v_width: budget,\n+        };\n+        result.push_str(&write_list(&generics_strs, &fmt));\n+\n+        result.push('>');\n+\n         result\n     }\n \n-    fn rewrite_where_clause(&self, where_clause: &ast::WhereClause, indent: usize) -> String {\n+    fn rewrite_where_clause(&self,\n+                            where_clause: &ast::WhereClause,\n+                            indent: usize,\n+                            next_span: Span)\n+        -> String\n+    {\n         let mut result = String::new();\n         if where_clause.predicates.len() == 0 {\n             return result;\n@@ -300,6 +372,21 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&make_indent(indent + 4));\n         result.push_str(\"where \");\n \n+        // TODO uncomment when spans are fixed\n+        //println!(\"{:?} {:?}\", where_clause.predicates.iter().map(|p| self.snippet(span_for_where_pred(p))).collect::<Vec<_>>(), next_span.lo);\n+        // let comments = self.make_comments_for_list(Vec::new(),\n+        //                                            where_clause.predicates.iter(),\n+        //                                            \",\",\n+        //                                            \"{\",\n+        //                                            |pred| span_for_where_pred(pred).lo,\n+        //                                            |pred| span_for_where_pred(pred).hi,\n+        //                                            next_span.lo);\n+        let comments = vec![String::new(); where_clause.predicates.len()];\n+        let where_strs: Vec<_> = where_clause.predicates.iter()\n+                                                        .map(|p| (self.rewrite_pred(p)))\n+                                                        .zip(comments.into_iter())\n+                                                        .collect();\n+\n         let budget = IDEAL_WIDTH + LEEWAY - indent - 10;\n         let fmt = ListFormatting {\n             tactic: ListTactic::Vertical,\n@@ -309,7 +396,6 @@ impl<'a> FmtVisitor<'a> {\n             h_width: budget,\n             v_width: budget,\n         };\n-        let where_strs: Vec<_> = where_clause.predicates.iter().map(|p| (self.rewrite_pred(p), String::new())).collect();\n         result.push_str(&write_list(&where_strs, &fmt));\n \n         result\n@@ -338,3 +424,27 @@ fn span_for_return(ret: &ast::FunctionRetTy) -> Span {\n         ast::FunctionRetTy::Return(ref ty) => ty.span,\n     }\n }\n+\n+fn span_for_ty_param(ty: &ast::TyParam) -> Span {\n+    // Note that ty.span is the span for ty.ident, not the whole item.\n+    let lo = ty.span.lo;\n+    if let Some(ref def) = ty.default {\n+        return codemap::mk_sp(lo, def.span.hi);\n+    }\n+    if ty.bounds.len() == 0 {\n+        return ty.span;\n+    }\n+    let hi = match ty.bounds[ty.bounds.len() - 1] {\n+        ast::TyParamBound::TraitTyParamBound(ref ptr, _) => ptr.span.hi,\n+        ast::TyParamBound::RegionTyParamBound(ref l) => l.span.hi,\n+    };\n+    codemap::mk_sp(lo, hi)\n+}\n+\n+fn span_for_where_pred(pred: &ast::WherePredicate) -> Span {\n+    match *pred {\n+        ast::WherePredicate::BoundPredicate(ref p) => p.span,\n+        ast::WherePredicate::RegionPredicate(ref p) => p.span,\n+        ast::WherePredicate::EqPredicate(ref p) => p.span,\n+    }\n+}"}, {"sha": "fd508a56b2fec92c06c871ef5f034d31d2c1798b", "filename": "src/mod.rs", "status": "modified", "additions": 90, "deletions": 10, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bc7855d34749f8371847cda317fc8bc26afde681/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7855d34749f8371847cda317fc8bc26afde681/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=bc7855d34749f8371847cda317fc8bc26afde681", "patch": "@@ -21,11 +21,10 @@\n \n // TODO priorities\n // Fix fns and methods properly\n-//   dead spans (comments) - in generics\n+//   dead spans (comments) - in where clause (wait for fixed spans, test)\n //\n // Smoke testing till we can use it\n-//   no newline at the end of doc.rs\n-// fmt_skip annotations\n+//   ** no newline at the end of doc.rs\n // take config options from a file\n \n #[macro_use]\n@@ -48,6 +47,7 @@ use syntax::diagnostics;\n use syntax::visit;\n \n use std::path::PathBuf;\n+use std::collections::HashMap;\n \n use changes::ChangeSet;\n use visitor::FmtVisitor;\n@@ -69,14 +69,18 @@ const MIN_STRING: usize = 10;\n const TAB_SPACES: usize = 4;\n const FN_BRACE_STYLE: BraceStyle = BraceStyle::SameLineWhere;\n const FN_RETURN_INDENT: ReturnIndent = ReturnIndent::WithArgs;\n+// When we get scoped annotations, we should have rustfmt::skip.\n+const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";\n \n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+#[derive(Copy, Clone)]\n pub enum WriteMode {\n     Overwrite,\n     // str is the extension of the new file\n     NewFile(&'static str),\n     // Write the output to stdout.\n     Display,\n+    // Return the result as a mapping from filenames to StringBuffers.\n+    Return(&'static Fn(HashMap<String, String>)),\n }\n \n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n@@ -157,6 +161,7 @@ fn fmt_lines(changes: &mut ChangeSet) {\n \n struct RustFmtCalls {\n     input_path: Option<PathBuf>,\n+    write_mode: WriteMode,\n }\n \n impl<'a> CompilerCalls<'a> for RustFmtCalls {\n@@ -202,30 +207,40 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n     }\n \n     fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n+        let write_mode = self.write_mode;\n         let mut control = driver::CompileController::basic();\n         control.after_parse.stop = Compilation::Stop;\n-        control.after_parse.callback = box |state| {\n+        control.after_parse.callback = box move |state| {\n             let krate = state.krate.unwrap();\n             let codemap = state.session.codemap();\n             let mut changes = fmt_ast(krate, codemap);\n             fmt_lines(&mut changes);\n \n             // FIXME(#5) Should be user specified whether to show or replace.\n-            let result = changes.write_all_files(WriteMode::Display);\n+            let result = changes.write_all_files(write_mode);\n \n-            if let Err(msg) = result {\n-                println!(\"Error writing files: {}\", msg);\n+            match result {\n+                Err(msg) => println!(\"Error writing files: {}\", msg),\n+                Ok(result) => {\n+                    if let WriteMode::Return(callback) = write_mode {\n+                        callback(result);\n+                    }\n+                }\n             }\n         };\n \n         control\n     }\n }\n \n+fn run(args: Vec<String>, write_mode: WriteMode) {\n+    let mut call_ctxt = RustFmtCalls { input_path: None, write_mode: write_mode };\n+    rustc_driver::run_compiler(&args, &mut call_ctxt);    \n+}\n+\n fn main() {\n     let args: Vec<_> = std::env::args().collect();\n-    let mut call_ctxt = RustFmtCalls { input_path: None };\n-    rustc_driver::run_compiler(&args, &mut call_ctxt);\n+    run(args, WriteMode::Display);\n     std::env::set_exit_status(0);\n \n     // TODO unit tests\n@@ -262,3 +277,68 @@ fn main() {\n // the right kind.\n \n // Should also make sure comments have the right indent\n+\n+#[cfg(test)]\n+mod test {\n+    use std::collections::HashMap;\n+    use std::fs;\n+    use std::io::Read;\n+    use super::*;\n+    use super::run;\n+\n+    // For now, the only supported regression tests are idempotent tests - the input and\n+    // output must match exactly.\n+    // TODO would be good to check for error messages and fail on them, or at least report.\n+    #[test]\n+    fn idempotent_tests() {\n+        println!(\"Idempotent tests:\");\n+        unsafe { FAILURES = 0; }\n+\n+        // Get all files in the tests/idem directory\n+        let files = fs::read_dir(\"tests/idem\").unwrap();\n+        // For each file, run rustfmt and collect the output\n+        let mut count = 0;\n+        for entry in files {\n+            let path = entry.unwrap().path();\n+            let file_name = path.to_str().unwrap();\n+            println!(\"Testing '{}'...\", file_name);\n+            run(vec![\"rustfmt\".to_string(), file_name.to_string()], WriteMode::Return(HANDLE_RESULT));\n+            count += 1;\n+        }\n+        // And also dogfood ourselves!\n+        println!(\"Testing 'src/mod.rs'...\");\n+        run(vec![\"rustfmt\".to_string(), \"src/mod.rs\".to_string()], WriteMode::Return(HANDLE_RESULT));\n+        count += 1;\n+\n+        // Display results\n+        let fails = unsafe { FAILURES };\n+        println!(\"Ran {} idempotent tests; {} failures.\", count, fails);\n+        assert!(fails == 0, \"{} idempotent tests failed\", fails);\n+    }\n+\n+    // 'global' used by sys_tests and handle_result.\n+    static mut FAILURES: i32 = 0;\n+    // Ick, just needed to get a &'static to handle_result.\n+    static HANDLE_RESULT: &'static Fn(HashMap<String, String>) = &handle_result;\n+\n+    // Compare output to input.\n+    fn handle_result(result: HashMap<String, String>) {\n+        let mut fails = 0;\n+\n+        for file_name in result.keys() {\n+            let mut f = fs::File::open(file_name).unwrap();\n+            let mut text = String::new();\n+            f.read_to_string(&mut text).unwrap();\n+            if result[file_name] != text {\n+                fails += 1;\n+                println!(\"Mismatch in {}.\", file_name);\n+            }\n+        }\n+\n+        if fails > 0 {\n+            unsafe {\n+                FAILURES += 1;\n+            }\n+        }\n+    }\n+}"}, {"sha": "e76d87afe9d54bc0b0e01dc85057ac9bd7facb2a", "filename": "src/visitor.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc7855d34749f8371847cda317fc8bc26afde681/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7855d34749f8371847cda317fc8bc26afde681/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=bc7855d34749f8371847cda317fc8bc26afde681", "patch": "@@ -12,7 +12,7 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, Span, BytePos};\n use syntax::visit;\n \n-use {MAX_WIDTH, TAB_SPACES};\n+use {MAX_WIDTH, TAB_SPACES, SKIP_ANNOTATION};\n use changes::ChangeSet;\n \n pub struct FmtVisitor<'a> {\n@@ -86,7 +86,8 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                              generics,\n                                              unsafety,\n                                              abi,\n-                                             vis);\n+                                             vis,\n+                                             b.span);\n                 self.changes.push_str_span(s, &new_fn);\n             }\n             visit::FkMethod(ident, ref sig, vis) => {\n@@ -97,7 +98,8 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                              &sig.generics,\n                                              &sig.unsafety,\n                                              &sig.abi,\n-                                             vis.unwrap_or(ast::Visibility::Inherited));\n+                                             vis.unwrap_or(ast::Visibility::Inherited),\n+                                             b.span);\n                 self.changes.push_str_span(s, &new_fn);\n             }\n             visit::FkFnBlock(..) => {}\n@@ -108,6 +110,10 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'v ast::Item) {\n+        if item.attrs.iter().any(|a| is_skip(&a.node.value)) {\n+            return;\n+        }\n+\n         match item.node {\n             ast::Item_::ItemUse(ref vp) => {\n                 match vp.node {\n@@ -135,6 +141,20 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n+        if ti.attrs.iter().any(|a| is_skip(&a.node.value)) {\n+            return;\n+        }\n+        visit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+        if ii.attrs.iter().any(|a| is_skip(&a.node.value)) {\n+            return;\n+        }\n+        visit::walk_impl_item(self, ii)\n+    }\n+\n     fn visit_mac(&mut self, mac: &'v ast::Mac) {\n         visit::walk_mac(self, mac)\n     }\n@@ -171,3 +191,10 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n }\n+\n+fn is_skip(meta_item: &ast::MetaItem) -> bool {\n+    match meta_item.node {\n+        ast::MetaItem_::MetaWord(ref s) => *s == SKIP_ANNOTATION,\n+        _ => false,\n+    }\n+}"}]}