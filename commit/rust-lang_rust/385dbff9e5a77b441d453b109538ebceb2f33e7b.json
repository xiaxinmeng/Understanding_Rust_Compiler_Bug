{"sha": "385dbff9e5a77b441d453b109538ebceb2f33e7b", "node_id": "C_kwDOAAsO6NoAKDM4NWRiZmY5ZTVhNzdiNDQxZDQ1M2IxMDk1MzhlYmNlYjJmMzNlN2I", "commit": {"author": {"name": "KaDiWa", "email": "kalle.wachsmuth@gmail.com", "date": "2023-01-27T21:10:10Z"}, "committer": {"name": "KaDiWa", "email": "kalle.wachsmuth@gmail.com", "date": "2023-01-30T14:58:35Z"}, "message": "bootstrap script: slight cleanup", "tree": {"sha": "3094e30b7cf484d9f628aa339ac5e088f545e37e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3094e30b7cf484d9f628aa339ac5e088f545e37e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/385dbff9e5a77b441d453b109538ebceb2f33e7b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEcFQWTVq3UZxSk8EiC1KuORxnTOUFAmPX2xsACgkQC1KuORxn\nTOUa4Q//R7DlgH7b4HMMwhiVpqD5VsWTWeDwRSK3132cp3hCM9N4qsLnjRWKgEUd\nkAAISVp6bIeXXxdM2G2llytvbzQtJH9+Fn54B6w6owKO1PA3A+2Cl1Df8GENj4gk\nDs204yh4TRLIF8EwIAfxobIIWxweNjYeGVkDomgyB/+cZZYMKpoZ/klVOm8zfvB5\nOCTa0iyDjikkWfqft/zyOOa4BFecgQO/bzk7zp/XG9T60wZgaEZ2OtgZ0gUCt1NN\nGXpBymVZNfsYntlPTdQNAxk5IM7LDoMYfk7kuQ2tRAD6Kh9Q+TOGz98bo/txliOk\n9gh4MR2klyPQr2KgkC080xM2MXbchxKnWMP8RDZkude5rbIuMRQK+++tML0q0u+z\nA57v6XqnV/LIaefun/vM5gVQ84mxndZDk64hSZcmrZpwLdSYy4vaOAPhgXM1BsQV\nifww8P7hgKpk0x+Qs9d2J7cyvJQvQ1ONlb2Td4SF7lpIgFoAtWhb2Lnw0eQoCPI9\n0P7gT1i/fXEZk2hzYy/PljB2k7O1SndwjGtkpAG0216oeZOHMNR9zSX7R9+SZskk\nzKXu5vgLh4+4tF3gvgZLNVGT32x2veqLREXEMAsheUloZBASe7487SAzygtLMyQ7\nMXNH62IpFUx2mGzc5lYyw27uvMklI1IxWR9jXhoMffq8xcsUxgY=\n=ovbE\n-----END PGP SIGNATURE-----", "payload": "tree 3094e30b7cf484d9f628aa339ac5e088f545e37e\nparent fba9f33c7c9b6b439aabba2625102c818e1b24ed\nauthor KaDiWa <kalle.wachsmuth@gmail.com> 1674853810 +0100\ncommitter KaDiWa <kalle.wachsmuth@gmail.com> 1675090715 +0100\n\nbootstrap script: slight cleanup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/385dbff9e5a77b441d453b109538ebceb2f33e7b", "html_url": "https://github.com/rust-lang/rust/commit/385dbff9e5a77b441d453b109538ebceb2f33e7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/385dbff9e5a77b441d453b109538ebceb2f33e7b/comments", "author": {"login": "kadiwa4", "id": 25464294, "node_id": "MDQ6VXNlcjI1NDY0Mjk0", "avatar_url": "https://avatars.githubusercontent.com/u/25464294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kadiwa4", "html_url": "https://github.com/kadiwa4", "followers_url": "https://api.github.com/users/kadiwa4/followers", "following_url": "https://api.github.com/users/kadiwa4/following{/other_user}", "gists_url": "https://api.github.com/users/kadiwa4/gists{/gist_id}", "starred_url": "https://api.github.com/users/kadiwa4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kadiwa4/subscriptions", "organizations_url": "https://api.github.com/users/kadiwa4/orgs", "repos_url": "https://api.github.com/users/kadiwa4/repos", "events_url": "https://api.github.com/users/kadiwa4/events{/privacy}", "received_events_url": "https://api.github.com/users/kadiwa4/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kadiwa4", "id": 25464294, "node_id": "MDQ6VXNlcjI1NDY0Mjk0", "avatar_url": "https://avatars.githubusercontent.com/u/25464294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kadiwa4", "html_url": "https://github.com/kadiwa4", "followers_url": "https://api.github.com/users/kadiwa4/followers", "following_url": "https://api.github.com/users/kadiwa4/following{/other_user}", "gists_url": "https://api.github.com/users/kadiwa4/gists{/gist_id}", "starred_url": "https://api.github.com/users/kadiwa4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kadiwa4/subscriptions", "organizations_url": "https://api.github.com/users/kadiwa4/orgs", "repos_url": "https://api.github.com/users/kadiwa4/repos", "events_url": "https://api.github.com/users/kadiwa4/events{/privacy}", "received_events_url": "https://api.github.com/users/kadiwa4/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fba9f33c7c9b6b439aabba2625102c818e1b24ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba9f33c7c9b6b439aabba2625102c818e1b24ed", "html_url": "https://github.com/rust-lang/rust/commit/fba9f33c7c9b6b439aabba2625102c818e1b24ed"}], "stats": {"total": 289, "additions": 147, "deletions": 142}, "files": [{"sha": "9cc7e0c68dd0269f414d86e484a32b80fe1b0906", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 70, "deletions": 86, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/385dbff9e5a77b441d453b109538ebceb2f33e7b/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/385dbff9e5a77b441d453b109538ebceb2f33e7b/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=385dbff9e5a77b441d453b109538ebceb2f33e7b", "patch": "@@ -2,7 +2,6 @@\n import argparse\n import contextlib\n import datetime\n-import distutils.version\n import hashlib\n import json\n import os\n@@ -13,17 +12,17 @@\n import tarfile\n import tempfile\n \n-from time import time, sleep\n+from time import time\n \n-def support_xz():\n-    try:\n-        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n-            temp_path = temp_file.name\n-        with tarfile.open(temp_path, \"w:xz\"):\n-            pass\n-        return True\n-    except tarfile.CompressionError:\n-        return False\n+try:\n+    import lzma\n+except ImportError:\n+    lzma = None\n+\n+if sys.platform == 'win32':\n+    EXE_SUFFIX = \".exe\"\n+else:\n+    EXE_SUFFIX = \"\"\n \n def get(base, url, path, checksums, verbose=False):\n     with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n@@ -61,7 +60,7 @@ def get(base, url, path, checksums, verbose=False):\n \n \n def download(path, url, probably_big, verbose):\n-    for _ in range(0, 4):\n+    for _ in range(4):\n         try:\n             _download(path, url, probably_big, verbose, True)\n             return\n@@ -395,15 +394,15 @@ class RustBuild(object):\n     def __init__(self):\n         self.checksums_sha256 = {}\n         self.stage0_compiler = None\n-        self._download_url = ''\n+        self.download_url = ''\n         self.build = ''\n         self.build_dir = ''\n         self.clean = False\n         self.config_toml = ''\n         self.rust_root = ''\n-        self.use_locked_deps = ''\n-        self.use_vendored_sources = ''\n-        self.verbose = False\n+        self.use_locked_deps = False\n+        self.use_vendored_sources = False\n+        self.verbose = 0\n         self.git_version = None\n         self.nix_deps_dir = None\n \n@@ -426,7 +425,7 @@ def download_toolchain(self):\n                  self.program_out_of_date(self.rustc_stamp(), key)):\n             if os.path.exists(bin_root):\n                 shutil.rmtree(bin_root)\n-            tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n+            tarball_suffix = '.tar.gz' if lzma is None else '.tar.xz'\n             filename = \"rust-std-{}-{}{}\".format(\n                 rustc_channel, self.build, tarball_suffix)\n             pattern = \"rust-std-{}\".format(self.build)\n@@ -437,15 +436,17 @@ def download_toolchain(self):\n             filename = \"cargo-{}-{}{}\".format(rustc_channel, self.build,\n                                             tarball_suffix)\n             self._download_component_helper(filename, \"cargo\", tarball_suffix)\n-            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(bin_root))\n-\n-            self.fix_bin_or_dylib(\"{}/bin/rustc\".format(bin_root))\n-            self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(bin_root))\n-            self.fix_bin_or_dylib(\"{}/libexec/rust-analyzer-proc-macro-srv\".format(bin_root))\n-            lib_dir = \"{}/lib\".format(bin_root)\n-            for lib in os.listdir(lib_dir):\n-                if lib.endswith(\".so\"):\n-                    self.fix_bin_or_dylib(os.path.join(lib_dir, lib))\n+            if self.should_fix_bins_and_dylibs():\n+                self.fix_bin_or_dylib(\"{}/bin/cargo\".format(bin_root))\n+\n+                self.fix_bin_or_dylib(\"{}/bin/rustc\".format(bin_root))\n+                self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(bin_root))\n+                self.fix_bin_or_dylib(\"{}/libexec/rust-analyzer-proc-macro-srv\".format(bin_root))\n+                lib_dir = \"{}/lib\".format(bin_root)\n+                for lib in os.listdir(lib_dir):\n+                    if lib.endswith(\".so\"):\n+                        self.fix_bin_or_dylib(os.path.join(lib_dir, lib))\n+\n             with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(key)\n \n@@ -458,60 +459,64 @@ def _download_component_helper(\n         if not os.path.exists(rustc_cache):\n             os.makedirs(rustc_cache)\n \n-        base = self._download_url\n-        url = \"dist/{}\".format(key)\n         tarball = os.path.join(rustc_cache, filename)\n         if not os.path.exists(tarball):\n             get(\n-                base,\n-                \"{}/{}\".format(url, filename),\n+                self.download_url,\n+                \"dist/{}/{}\".format(key, filename),\n                 tarball,\n                 self.checksums_sha256,\n-                verbose=self.verbose,\n+                verbose=self.verbose != 0,\n             )\n-        unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n-\n-    def fix_bin_or_dylib(self, fname):\n-        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker,\n-        or the RPATH section, to fix the dynamic library search path\n-\n-        This method is only required on NixOS and uses the PatchELF utility to\n-        change the interpreter/RPATH of ELF executables.\n+        unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose != 0)\n \n-        Please see https://nixos.org/patchelf.html for more information\n+    def should_fix_bins_and_dylibs(self):\n+        \"\"\"Whether or not `fix_bin_or_dylib` needs to be run; can only be True\n+        on NixOS.\n         \"\"\"\n         default_encoding = sys.getdefaultencoding()\n         try:\n             ostype = subprocess.check_output(\n                 ['uname', '-s']).strip().decode(default_encoding)\n         except subprocess.CalledProcessError:\n-            return\n+            return False\n         except OSError as reason:\n             if getattr(reason, 'winerror', None) is not None:\n-                return\n+                return False\n             raise reason\n \n         if ostype != \"Linux\":\n-            return\n+            return False\n \n         # If the user has asked binaries to be patched for Nix, then\n-        # don't check for NixOS or `/lib`, just continue to the patching.\n-        if self.get_toml('patch-binaries-for-nix', 'build') != 'true':\n-            # Use `/etc/os-release` instead of `/etc/NIXOS`.\n-            # The latter one does not exist on NixOS when using tmpfs as root.\n-            try:\n-                with open(\"/etc/os-release\", \"r\") as f:\n-                    if not any(l.strip() in [\"ID=nixos\", \"ID='nixos'\", 'ID=\"nixos\"'] for l in f):\n-                        return\n-            except FileNotFoundError:\n-                return\n-            if os.path.exists(\"/lib\"):\n-                return\n+        # don't check for NixOS or `/lib`.\n+        if self.get_toml(\"patch-binaries-for-nix\", \"build\") == \"true\":\n+            return True\n \n-        # At this point we're pretty sure the user is running NixOS or\n-        # using Nix\n-        nix_os_msg = \"info: you seem to be using Nix. Attempting to patch\"\n-        print(nix_os_msg, fname)\n+        # Use `/etc/os-release` instead of `/etc/NIXOS`.\n+        # The latter one does not exist on NixOS when using tmpfs as root.\n+        try:\n+            with open(\"/etc/os-release\", \"r\") as f:\n+                if not any(l.strip() in (\"ID=nixos\", \"ID='nixos'\", 'ID=\"nixos\"') for l in f):\n+                    return False\n+        except FileNotFoundError:\n+            return False\n+        if os.path.exists(\"/lib\"):\n+            return False\n+\n+        print(\"info: You seem to be using Nix.\")\n+        return True\n+\n+    def fix_bin_or_dylib(self, fname):\n+        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+        or the RPATH section, to fix the dynamic library search path\n+\n+        This method is only required on NixOS and uses the PatchELF utility to\n+        change the interpreter/RPATH of ELF executables.\n+\n+        Please see https://nixos.org/patchelf.html for more information\n+        \"\"\"\n+        print(\"attempting to patch\", fname)\n \n         # Only build `.nix-deps` once.\n         nix_deps_dir = self.nix_deps_dir\n@@ -666,8 +671,7 @@ def program_config(self, program):\n         config = self.get_toml(program)\n         if config:\n             return os.path.expanduser(config)\n-        return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n-            program, self.exe_suffix()))\n+        return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(program, EXE_SUFFIX))\n \n     @staticmethod\n     def get_string(line):\n@@ -692,13 +696,6 @@ def get_string(line):\n             return line[start + 1:end]\n         return None\n \n-    @staticmethod\n-    def exe_suffix():\n-        \"\"\"Return a suffix for executables\"\"\"\n-        if sys.platform == 'win32':\n-            return '.exe'\n-        return ''\n-\n     def bootstrap_binary(self):\n         \"\"\"Return the path of the bootstrap binary\n \n@@ -757,7 +754,6 @@ def build_bootstrap(self, color):\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \" -C linker=\" + target_linker\n         env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes\"\n-        env[\"RUSTFLAGS\"] += \" -Wsemicolon_in_expressions_from_macros\"\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n             env[\"RUSTFLAGS\"] += \" -Dwarnings\"\n \n@@ -768,8 +764,7 @@ def build_bootstrap(self, color):\n                 self.cargo()))\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n                 os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n-        for _ in range(0, self.verbose):\n-            args.append(\"--verbose\")\n+        args.extend(\"--verbose\" for _ in range(self.verbose))\n         if self.use_locked_deps:\n             args.append(\"--locked\")\n         if self.use_vendored_sources:\n@@ -783,7 +778,7 @@ def build_bootstrap(self, color):\n             args.append(\"--color=never\")\n \n         # Run this from the source directory so cargo finds .cargo/config\n-        run(args, env=env, verbose=self.verbose, cwd=self.rust_root)\n+        run(args, env=env, verbose=self.verbose != 0, cwd=self.rust_root)\n \n     def build_triple(self):\n         \"\"\"Build triple as in LLVM\n@@ -792,16 +787,7 @@ def build_triple(self):\n         so use `self.build` where possible.\n         \"\"\"\n         config = self.get_toml('build')\n-        if config:\n-            return config\n-        return default_build_triple(self.verbose)\n-\n-    def set_dist_environment(self, url):\n-        \"\"\"Set download URL for normal environment\"\"\"\n-        if 'RUSTUP_DIST_SERVER' in os.environ:\n-            self._download_url = os.environ['RUSTUP_DIST_SERVER']\n-        else:\n-            self._download_url = url\n+        return config or default_build_triple(self.verbose != 0)\n \n     def check_vendored_status(self):\n         \"\"\"Check that vendoring is configured properly\"\"\"\n@@ -891,7 +877,6 @@ def bootstrap(help_triggered):\n         build.verbose = max(build.verbose, int(config_verbose))\n \n     build.use_vendored_sources = build.get_toml('vendor', 'build') == 'true'\n-\n     build.use_locked_deps = build.get_toml('locked-deps', 'build') == 'true'\n \n     build.check_vendored_status()\n@@ -903,8 +888,7 @@ def bootstrap(help_triggered):\n         data = json.load(f)\n     build.checksums_sha256 = data[\"checksums_sha256\"]\n     build.stage0_compiler = Stage0Toolchain(data[\"compiler\"])\n-\n-    build.set_dist_environment(data[\"config\"][\"dist_server\"])\n+    build.download_url = os.getenv(\"RUSTUP_DIST_SERVER\") or data[\"config\"][\"dist_server\"]\n \n     build.build = args.build or build.build_triple()\n \n@@ -932,7 +916,7 @@ def main():\n \n     # x.py help <cmd> ...\n     if len(sys.argv) > 1 and sys.argv[1] == 'help':\n-        sys.argv = [sys.argv[0], '-h'] + sys.argv[2:]\n+        sys.argv[1] = '-h'\n \n     help_triggered = (\n         '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)"}, {"sha": "626e20754bc0c0ee90eec9844aafa3d567bc1b28", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 76, "deletions": 55, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/385dbff9e5a77b441d453b109538ebceb2f33e7b/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385dbff9e5a77b441d453b109538ebceb2f33e7b/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=385dbff9e5a77b441d453b109538ebceb2f33e7b", "patch": "@@ -70,53 +70,62 @@ impl Config {\n         check_run(cmd, self.is_verbose())\n     }\n \n-    /// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n-    /// or the RPATH section, to fix the dynamic library search path\n-    ///\n-    /// This is only required on NixOS and uses the PatchELF utility to\n-    /// change the interpreter/RPATH of ELF executables.\n-    ///\n-    /// Please see https://nixos.org/patchelf.html for more information\n-    fn fix_bin_or_dylib(&self, fname: &Path) {\n-        // FIXME: cache NixOS detection?\n-        match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n-            Err(_) => return,\n-            Ok(output) if !output.status.success() => return,\n-            Ok(output) => {\n-                let mut s = output.stdout;\n-                if s.last() == Some(&b'\\n') {\n-                    s.pop();\n-                }\n-                if s != b\"Linux\" {\n-                    return;\n+    /// Whether or not `fix_bin_or_dylib` needs to be run; can only be true\n+    /// on NixOS\n+    fn should_fix_bins_and_dylibs(&self) -> bool {\n+        static CACHED: OnceCell<bool> = OnceCell::new();\n+\n+        let val = *CACHED.get_or_init(|| {\n+            match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n+                Err(_) => return false,\n+                Ok(output) if !output.status.success() => return false,\n+                Ok(output) => {\n+                    let mut os_name = output.stdout;\n+                    if os_name.last() == Some(&b'\\n') {\n+                        os_name.pop();\n+                    }\n+                    if os_name != b\"Linux\" {\n+                        return false;\n+                    }\n                 }\n             }\n-        }\n \n-        // If the user has asked binaries to be patched for Nix, then\n-        // don't check for NixOS or `/lib`, just continue to the patching.\n-        // NOTE: this intentionally comes after the Linux check:\n-        // - patchelf only works with ELF files, so no need to run it on Mac or Windows\n-        // - On other Unix systems, there is no stable syscall interface, so Nix doesn't manage the global libc.\n-        if !self.patch_binaries_for_nix {\n+            // If the user has asked binaries to be patched for Nix, then\n+            // don't check for NixOS or `/lib`.\n+            // NOTE: this intentionally comes after the Linux check:\n+            // - patchelf only works with ELF files, so no need to run it on Mac or Windows\n+            // - On other Unix systems, there is no stable syscall interface, so Nix doesn't manage the global libc.\n+            if self.patch_binaries_for_nix {\n+                return true;\n+            }\n+\n             // Use `/etc/os-release` instead of `/etc/NIXOS`.\n             // The latter one does not exist on NixOS when using tmpfs as root.\n-            const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n-            let os_release = match File::open(\"/etc/os-release\") {\n-                Err(e) if e.kind() == ErrorKind::NotFound => return,\n+            let is_nixos = match File::open(\"/etc/os-release\") {\n+                Err(e) if e.kind() == ErrorKind::NotFound => false,\n                 Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n-                Ok(f) => f,\n+                Ok(os_release) => BufReader::new(os_release).lines().any(|l| {\n+                    let l = l.expect(\"reading /etc/os-release\");\n+                    matches!(l.trim(), \"ID=nixos\" | \"ID='nixos'\" | \"ID=\\\"nixos\\\"\")\n+                }),\n             };\n-            if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n-                return;\n-            }\n-            if Path::new(\"/lib\").exists() {\n-                return;\n-            }\n+            is_nixos && !Path::new(\"/lib\").exists()\n+        });\n+        if val {\n+            println!(\"info: You seem to be using Nix.\");\n         }\n+        val\n+    }\n \n-        // At this point we're pretty sure the user is running NixOS or using Nix\n-        println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n+    /// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+    /// or the RPATH section, to fix the dynamic library search path\n+    ///\n+    /// This is only required on NixOS and uses the PatchELF utility to\n+    /// change the interpreter/RPATH of ELF executables.\n+    ///\n+    /// Please see https://nixos.org/patchelf.html for more information\n+    fn fix_bin_or_dylib(&self, fname: &Path) {\n+        println!(\"attempting to patch {}\", fname.display());\n \n         // Only build `.nix-deps` once.\n         static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n@@ -328,8 +337,10 @@ impl Config {\n         let filename = format!(\"rustfmt-{version}-{build}.tar.xz\", build = host.triple);\n         self.download_component(DownloadSource::Dist, filename, \"rustfmt-preview\", &date, \"stage0\");\n \n-        self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustfmt\"));\n-        self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"cargo-fmt\"));\n+        if self.should_fix_bins_and_dylibs() {\n+            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustfmt\"));\n+            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"cargo-fmt\"));\n+        }\n \n         self.create(&rustfmt_stamp, &channel);\n         Some(rustfmt_path)\n@@ -358,16 +369,21 @@ impl Config {\n             let filename = format!(\"rust-src-{version}.tar.xz\");\n             self.download_ci_component(filename, \"rust-src\", commit);\n \n-            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n-            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n-            self.fix_bin_or_dylib(&bin_root.join(\"libexec\").join(\"rust-analyzer-proc-macro-srv\"));\n-            let lib_dir = bin_root.join(\"lib\");\n-            for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n-                let lib = t!(lib);\n-                if lib.path().extension() == Some(OsStr::new(\"so\")) {\n-                    self.fix_bin_or_dylib(&lib.path());\n+            if self.should_fix_bins_and_dylibs() {\n+                self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n+                self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n+                self.fix_bin_or_dylib(\n+                    &bin_root.join(\"libexec\").join(\"rust-analyzer-proc-macro-srv\"),\n+                );\n+                let lib_dir = bin_root.join(\"lib\");\n+                for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n+                    let lib = t!(lib);\n+                    if lib.path().extension() == Some(OsStr::new(\"so\")) {\n+                        self.fix_bin_or_dylib(&lib.path());\n+                    }\n                 }\n             }\n+\n             t!(fs::write(rustc_stamp, commit));\n         }\n     }\n@@ -459,8 +475,10 @@ impl Config {\n         let key = format!(\"{}{}\", llvm_sha, self.llvm_assertions);\n         if program_out_of_date(&llvm_stamp, &key) && !self.dry_run() {\n             self.download_ci_llvm(&llvm_sha);\n-            for entry in t!(fs::read_dir(llvm_root.join(\"bin\"))) {\n-                self.fix_bin_or_dylib(&t!(entry).path());\n+            if self.should_fix_bins_and_dylibs() {\n+                for entry in t!(fs::read_dir(llvm_root.join(\"bin\"))) {\n+                    self.fix_bin_or_dylib(&t!(entry).path());\n+                }\n             }\n \n             // Update the timestamp of llvm-config to force rustc_llvm to be\n@@ -475,13 +493,16 @@ impl Config {\n             let llvm_config = llvm_root.join(\"bin\").join(exe(\"llvm-config\", self.build));\n             t!(filetime::set_file_times(&llvm_config, now, now));\n \n-            let llvm_lib = llvm_root.join(\"lib\");\n-            for entry in t!(fs::read_dir(&llvm_lib)) {\n-                let lib = t!(entry).path();\n-                if lib.extension().map_or(false, |ext| ext == \"so\") {\n-                    self.fix_bin_or_dylib(&lib);\n+            if self.should_fix_bins_and_dylibs() {\n+                let llvm_lib = llvm_root.join(\"lib\");\n+                for entry in t!(fs::read_dir(&llvm_lib)) {\n+                    let lib = t!(entry).path();\n+                    if lib.extension().map_or(false, |ext| ext == \"so\") {\n+                        self.fix_bin_or_dylib(&lib);\n+                    }\n                 }\n             }\n+\n             t!(fs::write(llvm_stamp, key));\n         }\n     }"}, {"sha": "b7df39c7bc9e65399d099e42f042df27167b8599", "filename": "x.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385dbff9e5a77b441d453b109538ebceb2f33e7b/x.py", "raw_url": "https://github.com/rust-lang/rust/raw/385dbff9e5a77b441d453b109538ebceb2f33e7b/x.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/x.py?ref=385dbff9e5a77b441d453b109538ebceb2f33e7b", "patch": "@@ -22,7 +22,7 @@\n             pass\n \n rust_dir = os.path.dirname(os.path.abspath(__file__))\n-sys.path.append(os.path.join(rust_dir, \"src\", \"bootstrap\"))\n+sys.path[:0] = [os.path.join(rust_dir, \"src\", \"bootstrap\")]\n \n import bootstrap\n bootstrap.main()"}]}