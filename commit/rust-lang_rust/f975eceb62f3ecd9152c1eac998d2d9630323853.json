{"sha": "f975eceb62f3ecd9152c1eac998d2d9630323853", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NzVlY2ViNjJmM2VjZDkxNTJjMWVhYzk5OGQyZDk2MzAzMjM4NTM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-07T18:52:05Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-11T16:08:23Z"}, "message": "Document some opaque types code", "tree": {"sha": "0c58dc0dcd97b5bbdb713c927339ab4f917171e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c58dc0dcd97b5bbdb713c927339ab4f917171e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f975eceb62f3ecd9152c1eac998d2d9630323853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f975eceb62f3ecd9152c1eac998d2d9630323853", "html_url": "https://github.com/rust-lang/rust/commit/f975eceb62f3ecd9152c1eac998d2d9630323853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f975eceb62f3ecd9152c1eac998d2d9630323853/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e0832faaa45b2b2488885f06073c3f1eda9094d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e0832faaa45b2b2488885f06073c3f1eda9094d", "html_url": "https://github.com/rust-lang/rust/commit/1e0832faaa45b2b2488885f06073c3f1eda9094d"}], "stats": {"total": 209, "additions": 109, "deletions": 100}, "files": [{"sha": "5bbf8703f0b60d1b7ec8b6a9cc1492a0c61e7b7a", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f975eceb62f3ecd9152c1eac998d2d9630323853/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f975eceb62f3ecd9152c1eac998d2d9630323853/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=f975eceb62f3ecd9152c1eac998d2d9630323853", "patch": "@@ -258,8 +258,8 @@ enum Elide {\n     Exact(Region),\n     /// Less or more than one lifetime were found, error on unspecified.\n     Error(Vec<ElisionFailureInfo>),\n-    /// Forbid lifetime elision inside of a larger scope that does. For\n-    /// example, in let position impl trait.\n+    /// Forbid lifetime elision inside of a larger scope where it would be\n+    /// permitted. For example, in let position impl trait.\n     Forbid,\n }\n "}, {"sha": "d53a0ec9ef884ff336a6c2f2199795b79f3e2039", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f975eceb62f3ecd9152c1eac998d2d9630323853/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f975eceb62f3ecd9152c1eac998d2d9630323853/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=f975eceb62f3ecd9152c1eac998d2d9630323853", "patch": "@@ -407,12 +407,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let first_own_region = match opaque_defn.origin {\n             hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n-                // For these opaque types, only the item's own lifetime\n-                // parameters are considered.\n+                // We lower\n+                //\n+                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+                //\n+                // into\n+                //\n+                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+                //\n+                // For these types we onlt iterate over `'l0..lm` below.\n                 tcx.generics_of(def_id).parent_count\n             }\n             // These opaque type inherit all lifetime parameters from their\n-            // parent.\n+            // parent, so we have to check them all.\n             hir::OpaqueTyOrigin::Binding | hir::OpaqueTyOrigin::Misc => 0,\n         };\n "}, {"sha": "f3297ed67434758441bc026443e54aab1384d847", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 86, "deletions": 95, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/f975eceb62f3ecd9152c1eac998d2d9630323853/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f975eceb62f3ecd9152c1eac998d2d9630323853/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f975eceb62f3ecd9152c1eac998d2d9630323853", "patch": "@@ -801,18 +801,14 @@ fn check_where_clauses<'tcx, 'fcx>(\n             traits::Obligation::new(cause, fcx.param_env, pred)\n         });\n \n-    let mut predicates = predicates.instantiate_identity(fcx.tcx);\n+    let predicates = predicates.instantiate_identity(fcx.tcx);\n \n     if let Some((mut return_ty, span)) = return_ty {\n         if return_ty.has_infer_types_or_consts() {\n             fcx.select_obligations_where_possible(false, |_| {});\n             return_ty = fcx.resolve_vars_if_possible(&return_ty);\n         }\n-        let opaque_types = check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n-        for _ in 0..opaque_types.len() {\n-            predicates.spans.push(span);\n-        }\n-        predicates.predicates.extend(opaque_types);\n+        check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n     }\n \n     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n@@ -884,113 +880,109 @@ fn check_opaque_types<'fcx, 'tcx>(\n     fn_def_id: LocalDefId,\n     span: Span,\n     ty: Ty<'tcx>,\n-) -> Vec<ty::Predicate<'tcx>> {\n+) {\n     trace!(\"check_opaque_types(ty={:?})\", ty);\n-    let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = ty.kind {\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n-                // Only check named `impl Trait` types defined in this crate.\n-                if !def_id.is_local() {\n+\n+                let opaque_hir_id = if let Some(local_id) = def_id.as_local() {\n+                    tcx.hir().as_local_hir_id(local_id)\n+                } else {\n+                    // Opaque types from other crates won't have defining uses in this crate.\n                     return ty;\n-                }\n-                let opaque_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+                };\n                 if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) =\n                     tcx.hir().expect_item(opaque_hir_id).kind\n                 {\n-                    // Don't check return position impl trait.\n+                    // No need to check return position impl trait (RPIT)\n+                    // because for type and const parameters they are correct\n+                    // by construction: we convert\n+                    //\n+                    // fn foo<P0..Pn>() -> impl Trait\n+                    //\n+                    // into\n+                    //\n+                    // type Foo<P0...Pn>\n+                    // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+                    //\n+                    // For lifetime parameters we convert\n+                    //\n+                    // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+                    //\n+                    // into\n+                    //\n+                    // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+                    // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+                    //\n+                    // which would error here on all of the `'static` args.\n+                    return ty;\n+                }\n+                if !may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n                     return ty;\n                 }\n-                if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n-                    trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n-                    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-                    for (i, arg) in substs.iter().enumerate() {\n-                        let arg_is_param = match arg.unpack() {\n-                            GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n-\n-                            GenericArgKind::Lifetime(region) => {\n-                                if let ty::ReStatic = region {\n-                                    tcx.sess\n-                                        .struct_span_err(\n-                                            span,\n-                                            \"non-defining opaque type use in defining scope\",\n-                                        )\n-                                        .span_label(\n-                                            tcx.def_span(generics.param_at(i, tcx).def_id),\n-                                            \"cannot use static lifetime; use a bound lifetime \\\n+                trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n+                let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+                for (i, arg) in substs.iter().enumerate() {\n+                    let arg_is_param = match arg.unpack() {\n+                        GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n+\n+                        GenericArgKind::Lifetime(region) => {\n+                            if let ty::ReStatic = region {\n+                                tcx.sess\n+                                    .struct_span_err(\n+                                        span,\n+                                        \"non-defining opaque type use in defining scope\",\n+                                    )\n+                                    .span_label(\n+                                        tcx.def_span(generics.param_at(i, tcx).def_id),\n+                                        \"cannot use static lifetime; use a bound lifetime \\\n                                                  instead or remove the lifetime parameter from the \\\n                                                  opaque type\",\n-                                        )\n-                                        .emit();\n-                                    continue;\n-                                }\n-\n-                                true\n+                                    )\n+                                    .emit();\n+                                continue;\n                             }\n \n-                            GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n-                        };\n-\n-                        if arg_is_param {\n-                            seen_params.entry(arg).or_default().push(i);\n-                        } else {\n-                            // Prevent `fn foo() -> Foo<u32>` from being defining.\n-                            let opaque_param = generics.param_at(i, tcx);\n-                            tcx.sess\n-                                .struct_span_err(\n-                                    span,\n-                                    \"non-defining opaque type use in defining scope\",\n-                                )\n-                                .span_note(\n-                                    tcx.def_span(opaque_param.def_id),\n-                                    &format!(\n-                                        \"used non-generic {} `{}` for generic parameter\",\n-                                        opaque_param.kind.descr(),\n-                                        arg,\n-                                    ),\n-                                )\n-                                .emit();\n-                        }\n-                    } // for (arg, param)\n-\n-                    for (_, indices) in seen_params {\n-                        if indices.len() > 1 {\n-                            let descr = generics.param_at(indices[0], tcx).kind.descr();\n-                            let spans: Vec<_> = indices\n-                                .into_iter()\n-                                .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n-                                .collect();\n-                            tcx.sess\n-                                .struct_span_err(\n-                                    span,\n-                                    \"non-defining opaque type use in defining scope\",\n-                                )\n-                                .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                                .emit();\n+                            true\n                         }\n+\n+                        GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n+                    };\n+\n+                    if arg_is_param {\n+                        seen_params.entry(arg).or_default().push(i);\n+                    } else {\n+                        // Prevent `fn foo() -> Foo<u32>` from being defining.\n+                        let opaque_param = generics.param_at(i, tcx);\n+                        tcx.sess\n+                            .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                            .span_note(\n+                                tcx.def_span(opaque_param.def_id),\n+                                &format!(\n+                                    \"used non-generic {} `{}` for generic parameter\",\n+                                    opaque_param.kind.descr(),\n+                                    arg,\n+                                ),\n+                            )\n+                            .emit();\n                     }\n-                } // if may_define_opaque_type\n-\n-                // Now register the bounds on the parameters of the opaque type\n-                // so the parameters given by the function need to fulfill them.\n-                //\n-                //     type Foo<T: Bar> = impl Baz + 'static;\n-                //     fn foo<U>() -> Foo<U> { .. *}\n-                //\n-                // becomes\n-                //\n-                //     type Foo<T: Bar> = impl Baz + 'static;\n-                //     fn foo<U: Bar>() -> Foo<U> { .. *}\n-                let predicates = tcx.predicates_of(def_id);\n-                trace!(\"check_opaque_types: may define, predicates={:#?}\", predicates,);\n-                for &(pred, _) in predicates.predicates {\n-                    let substituted_pred = pred.subst(fcx.tcx, substs);\n-                    // Avoid duplication of predicates that contain no parameters, for example.\n-                    if !predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n-                        substituted_predicates.push(substituted_pred);\n+                } // for (arg, param)\n+\n+                for (_, indices) in seen_params {\n+                    if indices.len() > 1 {\n+                        let descr = generics.param_at(indices[0], tcx).kind.descr();\n+                        let spans: Vec<_> = indices\n+                            .into_iter()\n+                            .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n+                            .collect();\n+                        tcx.sess\n+                            .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                            .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                            .emit();\n                     }\n                 }\n             } // if let Opaque\n@@ -999,7 +991,6 @@ fn check_opaque_types<'fcx, 'tcx>(\n         lt_op: |lt| lt,\n         ct_op: |ct| ct,\n     });\n-    substituted_predicates\n }\n \n const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, \\"}, {"sha": "549a20531e2994b5d6688ec43938d2b6ce096f4b", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f975eceb62f3ecd9152c1eac998d2d9630323853/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f975eceb62f3ecd9152c1eac998d2d9630323853/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=f975eceb62f3ecd9152c1eac998d2d9630323853", "patch": "@@ -573,6 +573,16 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     }\n }\n \n+/// Retrieve the inferred concrete type for let position impl trait.\n+///\n+/// This is different to other kinds of impl trait because:\n+///\n+/// 1. We know which function contains the defining use (the function that\n+///    contains the let statement)\n+/// 2. We do not currently allow (free) lifetimes in the return type. `let`\n+///    statements in some statically unreachable code are removed from the MIR\n+///    by the time we borrow check, and it's not clear how we should handle\n+///    those.\n fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty<'_> {\n     let scope = tcx.hir().get_defining_scope(tcx.hir().as_local_hir_id(opaque_ty_id));\n     let scope_def_id = tcx.hir().local_def_id(scope);"}]}