{"sha": "7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "node_id": "C_kwDOAAsO6NoAKDdmNmI0MDZmYTFiOTU3NjFiNDA0MWMyMzdlMjBiYjJmNzY4M2QyYTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-27T13:32:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-27T13:32:42Z"}, "message": "Rollup merge of #109582 - scottmcm:local-ref-pending, r=oli-obk\n\nRefactor: Separate `LocalRef` variant for not-evaluated-yet operands\n\nAs I was reading through this, I noticed that almost every place that was using this needed to distinguish between Some vs None in the match arm anyway, so thought that separating the cases at the variant level might be clearer instead.\n\nI like how it ended up; let me know what you think!", "tree": {"sha": "fc6057fc9d739c5facb81c7b75febc4b985a22fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc6057fc9d739c5facb81c7b75febc4b985a22fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkIZr6CRBK7hj4Ov3rIwAACywIAJ1V3d2xd6xHKqKJK1N2oc0W\nq4sYuYTQqEmIj0RW/NdC3R572KEmUoMn/ewgG0WsV/hbdWSxYm3Dik8aANf1bZEb\nZsMYrz0N7bwSe0oaGdN6fU8Btp7Soj7OFlzYPKVjSeYR0DbvmDG+php26Fcp+EvH\nCIT+SQEWRUqix+5pAt4nIY8lVKb61NpnKjKPGvATvvN2Zc77BLyK6jlkq2DUI2vt\ndpxgTkyug27d1SQm/YnHSCYwFlgONrch1W5hXmftcd+Pw94O4UOtyPzshK2L7k6U\ny9rpq7GFMhAqnimL+5odG1qyViEWZ84OF7c25xNEd39OBArJYhr6M4LP3pNQ02U=\n=9dQI\n-----END PGP SIGNATURE-----\n", "payload": "tree fc6057fc9d739c5facb81c7b75febc4b985a22fa\nparent 9c73bf9038295a041aa3801494b161f32efbc9b9\nparent 49798605a0a9186fa6b30d9f219e099287024b8b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679923962 +0200\ncommitter GitHub <noreply@github.com> 1679923962 +0200\n\nRollup merge of #109582 - scottmcm:local-ref-pending, r=oli-obk\n\nRefactor: Separate `LocalRef` variant for not-evaluated-yet operands\n\nAs I was reading through this, I noticed that almost every place that was using this needed to distinguish between Some vs None in the match arm anyway, so thought that separating the cases at the variant level might be clearer instead.\n\nI like how it ended up; let me know what you think!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "html_url": "https://github.com/rust-lang/rust/commit/7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c73bf9038295a041aa3801494b161f32efbc9b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c73bf9038295a041aa3801494b161f32efbc9b9", "html_url": "https://github.com/rust-lang/rust/commit/9c73bf9038295a041aa3801494b161f32efbc9b9"}, {"sha": "49798605a0a9186fa6b30d9f219e099287024b8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/49798605a0a9186fa6b30d9f219e099287024b8b", "html_url": "https://github.com/rust-lang/rust/commit/49798605a0a9186fa6b30d9f219e099287024b8b"}], "stats": {"total": 46, "additions": 26, "deletions": 20}, "files": [{"sha": "2d647f5d7f2eab38cc6127475985814faec8b183", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "patch": "@@ -397,8 +397,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             PassMode::Cast(cast_ty, _) => {\n                 let op = match self.locals[mir::RETURN_PLACE] {\n-                    LocalRef::Operand(Some(op)) => op,\n-                    LocalRef::Operand(None) => bug!(\"use of return before def\"),\n+                    LocalRef::Operand(op) => op,\n+                    LocalRef::PendingOperand => bug!(\"use of return before def\"),\n                     LocalRef::Place(cg_place) => OperandRef {\n                         val: Ref(cg_place.llval, None, cg_place.align),\n                         layout: cg_place.layout,\n@@ -1673,7 +1673,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n-                LocalRef::Operand(None) => {\n+                LocalRef::PendingOperand => {\n                     // Handle temporary places, specifically `Operand` ones, as\n                     // they don't have `alloca`s.\n                     return if fn_ret.is_indirect() {\n@@ -1694,7 +1694,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         ReturnDest::DirectOperand(index)\n                     };\n                 }\n-                LocalRef::Operand(Some(_)) => {\n+                LocalRef::Operand(_) => {\n                     bug!(\"place local already assigned to\");\n                 }\n             }\n@@ -1737,7 +1737,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             IndirectOperand(tmp, index) => {\n                 let op = bx.load_operand(tmp);\n                 tmp.storage_dead(bx);\n-                self.locals[index] = LocalRef::Operand(Some(op));\n+                self.locals[index] = LocalRef::Operand(op);\n                 self.debug_introduce_local(bx, index);\n             }\n             DirectOperand(index) => {\n@@ -1752,7 +1752,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 } else {\n                     OperandRef::from_immediate_or_packed_pair(bx, llval, ret_abi.layout)\n                 };\n-                self.locals[index] = LocalRef::Operand(Some(op));\n+                self.locals[index] = LocalRef::Operand(op);\n                 self.debug_introduce_local(bx, index);\n             }\n         }"}, {"sha": "d15774696a52b10cbb1859af2bce19ddd173c152", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::Place(place) | LocalRef::UnsizedPlace(place) => {\n                     bx.set_var_name(place.llval, name);\n                 }\n-                LocalRef::Operand(Some(operand)) => match operand.val {\n+                LocalRef::Operand(operand) => match operand.val {\n                     OperandValue::Ref(x, ..) | OperandValue::Immediate(x) => {\n                         bx.set_var_name(x, name);\n                     }\n@@ -323,7 +323,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.set_var_name(b, &(name.clone() + \".1\"));\n                     }\n                 },\n-                LocalRef::Operand(None) => {}\n+                LocalRef::PendingOperand => {}\n             }\n         }\n \n@@ -332,9 +332,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         let base = match local_ref {\n-            LocalRef::Operand(None) => return,\n+            LocalRef::PendingOperand => return,\n \n-            LocalRef::Operand(Some(operand)) => {\n+            LocalRef::Operand(operand) => {\n                 // Don't spill operands onto the stack in naked functions.\n                 // See: https://github.com/rust-lang/rust/issues/42779\n                 let attrs = bx.tcx().codegen_fn_attrs(self.instance.def_id());"}, {"sha": "189549953d946a85a67b2cd65c8fe5e635dc7224", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "patch": "@@ -123,7 +123,10 @@ enum LocalRef<'tcx, V> {\n     /// Every time it is initialized, we have to reallocate the place\n     /// and update the fat pointer. That's the reason why it is indirect.\n     UnsizedPlace(PlaceRef<'tcx, V>),\n-    Operand(Option<OperandRef<'tcx, V>>),\n+    /// The backend [`OperandValue`] has already been generated.\n+    Operand(OperandRef<'tcx, V>),\n+    /// Will be a `Self::Operand` once we get to its definition.\n+    PendingOperand,\n }\n \n impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n@@ -135,9 +138,9 @@ impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(Some(OperandRef::new_zst(bx, layout)))\n+            LocalRef::Operand(OperandRef::new_zst(bx, layout))\n         } else {\n-            LocalRef::Operand(None)\n+            LocalRef::PendingOperand\n         }\n     }\n }\n@@ -337,7 +340,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 // We don't have to cast or keep the argument in the alloca.\n                 // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n                 // of putting everything in allocas just so we can use llvm.dbg.declare.\n-                let local = |op| LocalRef::Operand(Some(op));\n+                let local = |op| LocalRef::Operand(op);\n                 match arg.mode {\n                     PassMode::Ignore => {\n                         return local(OperandRef::new_zst(bx, arg.layout));"}, {"sha": "b45e7c834e7212070cb7dc0732fe3c011e614df9", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "patch": "@@ -370,7 +370,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n         match self.locals[place_ref.local] {\n-            LocalRef::Operand(Some(mut o)) => {\n+            LocalRef::Operand(mut o) => {\n                 // Moves out of scalar and scalar pair fields are trivial.\n                 for elem in place_ref.projection.iter() {\n                     match elem {\n@@ -395,7 +395,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                 Some(o)\n             }\n-            LocalRef::Operand(None) => {\n+            LocalRef::PendingOperand => {\n                 bug!(\"use of {:?} before def\", place_ref);\n             }\n             LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {"}, {"sha": "1633cfef19d2bab2c4b94a4ea53cbda95fe7f644", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "patch": "@@ -558,6 +558,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     bug!(\"using operand local {:?} as place\", place_ref);\n                 }\n             }\n+            LocalRef::PendingOperand => {\n+                bug!(\"using still-pending operand local {:?} as place\", place_ref);\n+            }\n         };\n         for elem in place_ref.projection[base..].iter() {\n             cg_base = match *elem {"}, {"sha": "d867d6b0cd48ae8e92fb82df6dc44dd080219887", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "patch": "@@ -545,7 +545,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n         if let Some(index) = place.as_local() {\n-            if let LocalRef::Operand(Some(op)) = self.locals[index] {\n+            if let LocalRef::Operand(op) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.kind() {\n                     let n = n.eval_target_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n                     return bx.cx().const_usize(n);"}, {"sha": "3fd7397ad38651c21ce8f6d93ac6c1ba7abe6955", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6b406fa1b95761b4041c237e20bb2f7683d2a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=7f6b406fa1b95761b4041c237e20bb2f7683d2a7", "patch": "@@ -18,12 +18,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         LocalRef::UnsizedPlace(cg_indirect_dest) => {\n                             self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n-                        LocalRef::Operand(None) => {\n+                        LocalRef::PendingOperand => {\n                             let operand = self.codegen_rvalue_operand(bx, rvalue);\n-                            self.locals[index] = LocalRef::Operand(Some(operand));\n+                            self.locals[index] = LocalRef::Operand(operand);\n                             self.debug_introduce_local(bx, index);\n                         }\n-                        LocalRef::Operand(Some(op)) => {\n+                        LocalRef::Operand(op) => {\n                             if !op.layout.is_zst() {\n                                 span_bug!(\n                                     statement.source_info.span,"}]}