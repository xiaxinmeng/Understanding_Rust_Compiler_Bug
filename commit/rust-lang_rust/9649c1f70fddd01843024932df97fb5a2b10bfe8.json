{"sha": "9649c1f70fddd01843024932df97fb5a2b10bfe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NDljMWY3MGZkZGQwMTg0MzAyNDkzMmRmOTdmYjVhMmIxMGJmZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-15T12:43:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-15T12:43:01Z"}, "message": "Auto merge of #55974 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #55182 (Redox: Update to new changes)\n - #55211 (Add BufWriter::buffer method)\n - #55507 (Add link to std::mem::size_of to size_of intrinsic documentation)\n - #55530 (Speed up String::from_utf16)\n - #55556 (Use `Mmap` to open the rmeta file.)\n - #55622 (NetBSD: link libstd with librt in addition to libpthread)\n - #55750 (Make `NodeId` and `HirLocalId` `newtype_index`)\n - #55778 (Wrap some query results in `Lrc`.)\n - #55781 (More precise spans for temps and their drops)\n - #55785 (Add mem::forget_unsized() for forgetting unsized values)\n - #55852 (Rewrite `...` as `..=` as a `MachineApplicable` 2018 idiom lint)\n - #55865 (Unix RwLock: avoid racy access to write_locked)\n - #55901 (fix various typos in doc comments)\n - #55926 (Change sidebar selector to fix compatibility with docs.rs)\n - #55930 (A handful of hir tweaks)\n - #55932 (core/char: Speed up `to_digit()` for `radix <= 10`)\n - #55956 (add tests for some fixed ICEs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "bc6af666244208eb4354636428ac26731935cbdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc6af666244208eb4354636428ac26731935cbdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9649c1f70fddd01843024932df97fb5a2b10bfe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9649c1f70fddd01843024932df97fb5a2b10bfe8", "html_url": "https://github.com/rust-lang/rust/commit/9649c1f70fddd01843024932df97fb5a2b10bfe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9649c1f70fddd01843024932df97fb5a2b10bfe8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99e3fca27d141e2d100ebaf5d5a4104234ae201a", "url": "https://api.github.com/repos/rust-lang/rust/commits/99e3fca27d141e2d100ebaf5d5a4104234ae201a", "html_url": "https://github.com/rust-lang/rust/commit/99e3fca27d141e2d100ebaf5d5a4104234ae201a"}, {"sha": "d0e08ce88e0926e8e2bc393d3d7982fd767f37b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0e08ce88e0926e8e2bc393d3d7982fd767f37b8", "html_url": "https://github.com/rust-lang/rust/commit/d0e08ce88e0926e8e2bc393d3d7982fd767f37b8"}], "stats": {"total": 1324, "additions": 934, "deletions": 390}, "files": [{"sha": "64e18899c9d0503298b153a0ffd76abeccd6a8dc", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -2278,12 +2278,14 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"serialize 0.0.0\",\n+ \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "f9b455fe796d1bf470bdfb4bf371d3fbc01c9bf5", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -69,7 +69,7 @@ struct LeafNode<K, V> {\n \n     /// This node's index into the parent node's `edges` array.\n     /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n-    /// This is only guaranteed to be initialized when `parent` is nonnull.\n+    /// This is only guaranteed to be initialized when `parent` is non-null.\n     parent_idx: MaybeUninit<u16>,\n \n     /// The number of keys and values this node stores."}, {"sha": "e87bf78561c615fbbaff275f2a07b4e8eb8797c3", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -44,7 +44,7 @@ use boxed::Box;\n /// This enables you to use capacity growing logic catch the overflows in your length\n /// that might occur with zero-sized types.\n ///\n-/// However this means that you need to be careful when roundtripping this type\n+/// However this means that you need to be careful when round-tripping this type\n /// with a `Box<[T]>`: `cap()` won't yield the len. However `with_capacity`,\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of"}, {"sha": "8d009101ce7da2d3865754d6184e87bf8400d976", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -618,7 +618,15 @@ impl String {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n-        decode_utf16(v.iter().cloned()).collect::<Result<_, _>>().map_err(|_| FromUtf16Error(()))\n+        let mut ret = String::with_capacity(v.len());\n+        for c in decode_utf16(v.iter().cloned()) {\n+            if let Ok(c) = c {\n+                ret.push(c);\n+            } else {\n+                return Err(FromUtf16Error(()));\n+            }\n+        }\n+        Ok(ret)\n     }\n \n     /// Decode a UTF-16 encoded slice `v` into a `String`, replacing"}, {"sha": "faf820d871cfa24c57dceeeb20618822cf2f8a13", "filename": "src/libcore/benches/char/methods.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fbenches%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fbenches%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fchar%2Fmethods.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::Bencher;\n+\n+const CHARS: [char; 9] = ['0', 'x', '2', '5', 'A', 'f', '7', '8', '9'];\n+const RADIX: [u32; 5] = [2, 8, 10, 16, 32];\n+\n+#[bench]\n+fn bench_to_digit_radix_2(b: &mut Bencher) {\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(2)).min())\n+}\n+\n+#[bench]\n+fn bench_to_digit_radix_10(b: &mut Bencher) {\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(10)).min())\n+}\n+\n+#[bench]\n+fn bench_to_digit_radix_16(b: &mut Bencher) {\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(16)).min())\n+}\n+\n+#[bench]\n+fn bench_to_digit_radix_36(b: &mut Bencher) {\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(36)).min())\n+}\n+\n+#[bench]\n+fn bench_to_digit_radix_var(b: &mut Bencher) {\n+    b.iter(|| CHARS.iter().cycle()\n+        .zip(RADIX.iter().cycle())\n+        .take(10_000)\n+        .map(|(c, radix)| c.to_digit(*radix)).min())\n+}"}, {"sha": "a656e82cb61e6531bf75cead3c669441f1767ea6", "filename": "src/libcore/benches/char/mod.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fbenches%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fbenches%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fchar%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod methods;"}, {"sha": "d44f1577d56b0a03044e9de7f6085813bbaafe72", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -15,6 +15,7 @@ extern crate core;\n extern crate test;\n \n mod any;\n+mod char;\n mod hash;\n mod iter;\n mod num;"}, {"sha": "d6fcff644acf60d3bba47645cce6ad764c8fd181", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -121,15 +121,24 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_digit(self, radix: u32) -> Option<u32> {\n-        if radix > 36 {\n-            panic!(\"to_digit: radix is too high (maximum 36)\");\n-        }\n-        let val = match self {\n-          '0' ..= '9' => self as u32 - '0' as u32,\n-          'a' ..= 'z' => self as u32 - 'a' as u32 + 10,\n-          'A' ..= 'Z' => self as u32 - 'A' as u32 + 10,\n-          _ => return None,\n+        assert!(radix <= 36, \"to_digit: radix is too high (maximum 36)\");\n+\n+        // the code is split up here to improve execution speed for cases where\n+        // the `radix` is constant and 10 or smaller\n+        let val = if radix <= 10  {\n+            match self {\n+                '0' ..= '9' => self as u32 - '0' as u32,\n+                _ => return None,\n+            }\n+        } else {\n+            match self {\n+                '0'..='9' => self as u32 - '0' as u32,\n+                'a'..='z' => self as u32 - 'a' as u32 + 10,\n+                'A'..='Z' => self as u32 - 'A' as u32 + 10,\n+                _ => return None,\n+            }\n         };\n+\n         if val < radix { Some(val) }\n         else { None }\n     }"}, {"sha": "16f0299c18b9a21f37c0ffec6410503f1c84d2f8", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -672,6 +672,9 @@ extern \"rust-intrinsic\" {\n     ///\n     /// More specifically, this is the offset in bytes between successive\n     /// items of the same type, including alignment padding.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::size_of`](../../std/mem/fn.size_of.html).\n     pub fn size_of<T>() -> usize;\n \n     /// Moves a value to an uninitialized memory location.\n@@ -714,6 +717,10 @@ extern \"rust-intrinsic\" {\n     /// initialize memory previous set to the result of `uninit`.\n     pub fn uninit<T>() -> T;\n \n+    /// Moves a value out of scope without running drop glue.\n+    #[cfg(not(stage0))]\n+    pub fn forget<T: ?Sized>(_: T);\n+\n     /// Reinterprets the bits of a value of one type as another type.\n     ///\n     /// Both types must have the same size. Neither the original, nor the result,"}, {"sha": "a02b5bc87c5e95b7f3364ba4efed7a17a30692c0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -106,6 +106,7 @@\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]\n #![feature(unboxed_closures)]\n+#![feature(unsized_locals)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(doc_alias)]"}, {"sha": "d8eec2bd9a6a2558e9f6c7fc65fd2400fe561913", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -143,6 +143,19 @@ pub fn forget<T>(t: T) {\n     ManuallyDrop::new(t);\n }\n \n+/// Like [`forget`], but also accepts unsized values.\n+///\n+/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n+/// stabilized.\n+///\n+/// [`forget`]: fn.forget.html\n+#[inline]\n+#[cfg(not(stage0))]\n+#[unstable(feature = \"forget_unsized\", issue = \"0\")]\n+pub fn forget_unsized<T: ?Sized>(t: T) {\n+    unsafe { intrinsics::forget(t) }\n+}\n+\n /// Returns the size of a type in bytes.\n ///\n /// More specifically, this is the offset in bytes between successive elements"}, {"sha": "d6c3996971a5816fd351f72f804aefec9d139813", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -445,7 +445,7 @@ impl f32 {\n     /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n     ///\n     /// Rather than trying to preserve signaling-ness cross-platform, this\n-    /// implementation favours preserving the exact bits. This means that\n+    /// implementation favors preserving the exact bits. This means that\n     /// any payloads encoded in NaNs will be preserved even if the result of\n     /// this method is sent over the network from an x86 machine to a MIPS one.\n     ///"}, {"sha": "c0ce7255d62875cdd64e12a469d233aedaddbae2", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -108,7 +108,7 @@ impl Drop for Waker {\n /// is ready to be run.\n ///\n /// This is similar to the `Waker` type, but cannot be sent across threads.\n-/// Task executors can use this type to implement more optimized singlethreaded wakeup\n+/// Task executors can use this type to implement more optimized single-threaded wakeup\n /// behavior.\n #[repr(transparent)]\n #[derive(Clone)]"}, {"sha": "c75ca6465a139704e00295be355b1f067af2f535", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1 +1 @@\n-Subproject commit 1844a772b60771d0124a157019f627d60fea4e73\n+Subproject commit c75ca6465a139704e00295be355b1f067af2f535"}, {"sha": "60b6a8bac41d399c59b21b9847333eb154394970", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -535,7 +535,7 @@ impl TokenTree {\n     }\n }\n \n-/// Prints token treee in a form convenient for debugging.\n+/// Prints token tree in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -730,7 +730,7 @@ impl fmt::Debug for Group {\n \n /// An `Punct` is an single punctuation character like `+`, `-` or `#`.\n ///\n-/// Multicharacter operators like `+=` are represented as two instances of `Punct` with different\n+/// Multi-character operators like `+=` are represented as two instances of `Punct` with different\n /// forms of `Spacing` returned.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Clone)]\n@@ -788,7 +788,7 @@ impl Punct {\n \n     /// Returns the spacing of this punctuation character, indicating whether it's immediately\n     /// followed by another `Punct` in the token stream, so they can potentially be combined into\n-    /// a multicharacter operator (`Joint`), or it's followed by some other token or whitespace\n+    /// a multi-character operator (`Joint`), or it's followed by some other token or whitespace\n     /// (`Alone`) so the operator has certainly ended.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn spacing(&self) -> Spacing {\n@@ -947,7 +947,7 @@ macro_rules! suffixed_int_literals {\n         /// This function will create an integer like `1u32` where the integer\n         /// value specified is the first part of the token and the integral is\n         /// also suffixed at the end.\n-        /// Literals created from negative numbers may not survive rountrips through\n+        /// Literals created from negative numbers may not survive round-trips through\n         /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n         ///\n         /// Literals created through this method have the `Span::call_site()`\n@@ -1047,7 +1047,7 @@ impl Literal {\n \n     /// Creates a new suffixed floating-point literal.\n     ///\n-    /// This consturctor will create a literal like `1.0f32` where the value\n+    /// This constructor will create a literal like `1.0f32` where the value\n     /// specified is the preceding part of the token and `f32` is the suffix of\n     /// the token. This token will always be inferred to be an `f32` in the\n     /// compiler.\n@@ -1096,7 +1096,7 @@ impl Literal {\n \n     /// Creates a new suffixed floating-point literal.\n     ///\n-    /// This consturctor will create a literal like `1.0f64` where the value\n+    /// This constructor will create a literal like `1.0f64` where the value\n     /// specified is the preceding part of the token and `f64` is the suffix of\n     /// the token. This token will always be inferred to be an `f64` in the\n     /// compiler."}, {"sha": "0392d32989697f8b20c8896a277c8911941d5397", "filename": "src/librustc/dep_graph/cgu_reuse_tracker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! Some facilities for tracking how codegen-units are reused during incremental\n-//! compilition. This is used for incremental compiliation tests and debug\n+//! compilation. This is used for incremental compilation tests and debug\n //! output.\n \n use session::Session;"}, {"sha": "3ff2545f78dfa9bbe855d1dc392ac02e01aee531", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -63,7 +63,7 @@\n use mir::interpret::GlobalId;\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n-use hir::{HirId, ItemLocalId};\n+use hir::HirId;\n \n use ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n@@ -790,11 +790,11 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n     fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n         let HirId {\n             owner,\n-            local_id: ItemLocalId(local_id),\n+            local_id,\n         } = *self;\n \n         let def_path_hash = tcx.def_path_hash(DefId::local(owner));\n-        let local_id = Fingerprint::from_smaller_hash(local_id as u64);\n+        let local_id = Fingerprint::from_smaller_hash(local_id.as_u32().into());\n \n         def_path_hash.0.combine(local_id)\n     }"}, {"sha": "e4c434b562ddc96d824d192d6af8fbbcead0eb8e", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -36,7 +36,7 @@ pub enum NonMacroAttrKind {\n     Tool,\n     /// Single-segment custom attribute registered by a derive macro (`#[serde(default)]`).\n     DeriveHelper,\n-    /// Single-segment custom attriubte registered by a legacy plugin (`register_attribute`).\n+    /// Single-segment custom attribute registered by a legacy plugin (`register_attribute`).\n     LegacyPluginHelper,\n     /// Single-segment custom attribute not registered in any way (`#[my_attr]`).\n     Custom,"}, {"sha": "d9963f23a1593c09aeade3ebb3777b1d42b7bf97", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -49,7 +49,6 @@ use hir::map::{self, Map};\n use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n-use std::u32;\n \n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n@@ -1152,8 +1151,8 @@ pub struct IdRange {\n impl IdRange {\n     pub fn max() -> IdRange {\n         IdRange {\n-            min: NodeId::from_u32(u32::MAX),\n-            max: NodeId::from_u32(u32::MIN),\n+            min: NodeId::MAX,\n+            max: NodeId::from_u32(0),\n         }\n     }\n "}, {"sha": "e532b50a28b6b9d339b89423a87fec8942d68ed9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -588,7 +588,7 @@ impl<'a> LoweringContext<'a> {\n             *local_id_counter += 1;\n             hir::HirId {\n                 owner: def_index,\n-                local_id: hir::ItemLocalId(local_id),\n+                local_id: hir::ItemLocalId::from_u32(local_id),\n             }\n         })\n     }\n@@ -616,7 +616,7 @@ impl<'a> LoweringContext<'a> {\n \n             hir::HirId {\n                 owner: def_index,\n-                local_id: hir::ItemLocalId(local_id),\n+                local_id: hir::ItemLocalId::from_u32(local_id),\n             }\n         })\n     }"}, {"sha": "ac4119dc372d34420bad44164effbf42135fdb48", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n         if max != self.hir_ids_seen.len() - 1 {\n             // Collect the missing ItemLocalIds\n             let missing: Vec<_> = (0 .. max as u32 + 1)\n-              .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId(i)))\n+              .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId::from_u32(i)))\n               .collect();\n \n             // Try to map those to something more useful\n@@ -110,7 +110,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n             for local_id in missing {\n                 let hir_id = HirId {\n                     owner: owner_def_index,\n-                    local_id: ItemLocalId(local_id as u32),\n+                    local_id: ItemLocalId::from_u32(local_id),\n                 };\n \n                 trace!(\"missing hir id {:#?}\", hir_id);\n@@ -124,7 +124,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                                        .enumerate()\n                                        .find(|&(_, &entry)| hir_id == entry)\n                                        .expect(\"no node_to_hir_id entry\");\n-                let node_id = NodeId::new(node_id);\n+                let node_id = NodeId::from_usize(node_id);\n                 missing_items.push(format!(\"[local_id: {}, node:{}]\",\n                                            local_id,\n                                            self.hir_map.node_to_string(node_id)));"}, {"sha": "e28193be34a44ccb336fa06ae70e8e7cd4f85279", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -27,7 +27,7 @@ use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n use syntax::source_map::{self, Spanned};\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n-use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n+use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::InlineAttr;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n@@ -37,7 +37,6 @@ use syntax::util::parser::ExprPrecedence;\n use ty::AdtKind;\n use ty::query::Providers;\n \n-use rustc_data_structures::indexed_vec;\n use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync, scope};\n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -58,7 +57,6 @@ macro_rules! hir_vec {\n     ($($x:expr),*) => (\n         $crate::hir::HirVec::from(vec![$($x),*])\n     );\n-    ($($x:expr,)*) => (hir_vec![$($x),*])\n }\n \n pub mod check_attr;\n@@ -121,48 +119,36 @@ impl serialize::UseSpecializedDecodable for HirId {\n     }\n }\n \n-\n-/// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n-/// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n-/// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n-/// the node's position within the owning item in any way, but there is a\n-/// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n-/// integers starting at zero, so a mapping that maps all or most nodes within\n-/// an \"item-like\" to something else can be implement by a `Vec` instead of a\n-/// tree or hash map.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n-         RustcEncodable, RustcDecodable)]\n-pub struct ItemLocalId(pub u32);\n-\n-impl ItemLocalId {\n-    pub fn as_usize(&self) -> usize {\n-        self.0 as usize\n+// hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n+mod item_local_id_inner {\n+    use rustc_data_structures::indexed_vec::Idx;\n+    /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n+    /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+    /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n+    /// the node's position within the owning item in any way, but there is a\n+    /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n+    /// integers starting at zero, so a mapping that maps all or most nodes within\n+    /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n+    /// tree or hash map.\n+    newtype_index! {\n+        pub struct ItemLocalId { .. }\n     }\n }\n \n-impl indexed_vec::Idx for ItemLocalId {\n-    fn new(idx: usize) -> Self {\n-        debug_assert!((idx as u32) as usize == idx);\n-        ItemLocalId(idx as u32)\n-    }\n-\n-    fn index(self) -> usize {\n-        self.0 as usize\n-    }\n-}\n+pub use self::item_local_id_inner::ItemLocalId;\n \n /// The `HirId` corresponding to CRATE_NODE_ID and CRATE_DEF_INDEX\n pub const CRATE_HIR_ID: HirId = HirId {\n     owner: CRATE_DEF_INDEX,\n-    local_id: ItemLocalId(0)\n+    local_id: ItemLocalId::from_u32_const(0)\n };\n \n pub const DUMMY_HIR_ID: HirId = HirId {\n     owner: CRATE_DEF_INDEX,\n     local_id: DUMMY_ITEM_LOCAL_ID,\n };\n \n-pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId(!0);\n+pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n pub struct Label {\n@@ -331,7 +317,7 @@ impl Path {\n \n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"path({})\", print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n+        write!(f, \"path({})\", self)\n     }\n }\n \n@@ -698,8 +684,6 @@ pub struct WhereEqPredicate {\n     pub rhs_ty: P<Ty>,\n }\n \n-pub type CrateConfig = HirVec<P<MetaItem>>;\n-\n /// The top-level data structure that stores the entire contents of\n /// the crate currently being compiled.\n ///\n@@ -1196,8 +1180,8 @@ impl StmtKind {\n \n     pub fn id(&self) -> NodeId {\n         match *self {\n-            StmtKind::Decl(_, id) => id,\n-            StmtKind::Expr(_, id) => id,\n+            StmtKind::Decl(_, id) |\n+            StmtKind::Expr(_, id) |\n             StmtKind::Semi(_, id) => id,\n         }\n     }"}, {"sha": "ae0d78d2958adcae9176283272f4ef7d682c3bee", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -79,7 +79,14 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for CrateNum {\n     }\n }\n \n-impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemLocalId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.as_u32().hash_stable(hcx, hasher);\n+    }\n+}\n \n impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::ItemLocalId {\n@@ -800,7 +807,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n             .iter()\n             .map(|id| {\n                 let (def_path_hash, local_id) = id.id.to_stable_hash_key(hcx);\n-                debug_assert_eq!(local_id, hir::ItemLocalId(0));\n+                debug_assert_eq!(local_id, hir::ItemLocalId::from_u32(0));\n                 def_path_hash.0\n             }).fold(Fingerprint::ZERO, |a, b| {\n                 a.combine_commutative(b)"}, {"sha": "a787eeae663fd5a0d44baebdea866073b4f09a4e", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -10,7 +10,7 @@\n \n //! This module contains the \"canonicalizer\" itself.\n //!\n-//! For an overview of what canonicaliation is and how it fits into\n+//! For an overview of what canonicalization is and how it fits into\n //! rustc, check out the [chapter in the rustc guide][c].\n //!\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html"}, {"sha": "6f3d10268351a5907c8b928d8fa8dda099b51d04", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -556,7 +556,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Given two sets of values for the same set of canonical variables, unify them.\n-    /// The second set is produced lazilly by supplying indices from the first set.\n+    /// The second set is produced lazily by supplying indices from the first set.\n     fn unify_canonical_vars(\n         &self,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "e2110e148de52975006d1d23b6db4e3a1f9787ab", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -11,7 +11,7 @@\n //! This module contains code to substitute new values into a\n //! `Canonical<'tcx, T>`.\n //!\n-//! For an overview of what canonicaliation is and how it fits into\n+//! For an overview of what canonicalization is and how it fits into\n //! rustc, check out the [chapter in the rustc guide][c].\n //!\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html"}, {"sha": "7a92b3084ba9febeda8e4aa283571c11c77bca91", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -20,7 +20,7 @@ use util::common::ErrorReported;\n use infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n-    /// Print the error message for lifetime errors when binding excapes a closure.\n+    /// Print the error message for lifetime errors when binding escapes a closure.\n     ///\n     /// Consider a case where we have\n     ///"}, {"sha": "8172f620c3646b09b6412db1fd37410023e46d9e", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -428,7 +428,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// This routine is only intended to be used when the leak-check has\n     /// passed; currently, it's used in the trait matching code to create\n-    /// a set of nested obligations frmo an impl that matches against\n+    /// a set of nested obligations from an impl that matches against\n     /// something higher-ranked.  More details can be found in\n     /// `librustc/middle/traits/README.md`.\n     ///"}, {"sha": "87e32be1a1759d4867c2e4dc7ea35d2bc20ec935", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1160,10 +1160,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Takes ownership of the list of variable regions. This implies\n-    /// that all the region constriants have already been taken, and\n+    /// that all the region constraints have already been taken, and\n     /// hence that `resolve_regions_and_report_errors` can never be\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n-    /// of the set of region vairables into the NLL region context.\n+    /// of the set of region variables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n         let (var_infos, data) = self.region_constraints\n             .borrow_mut()\n@@ -1478,7 +1478,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Clears the selection, evaluation, and projection caches. This is useful when\n-    /// repeatedly attemping to select an Obligation while changing only\n+    /// repeatedly attempting to select an Obligation while changing only\n     /// its ParamEnv, since FulfillmentContext doesn't use 'probe'\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();"}, {"sha": "5fee04341b676e97c4913aef1609a5b658dfcffc", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -299,8 +299,8 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         let assoc_item = tcx.associated_item(assoc_item_def_id);\n         let trait_def_id = assoc_item.container.assert_trait();\n         let trait_predicates = tcx.predicates_of(trait_def_id).predicates\n-            .into_iter()\n-            .map(|(p, _)| p)\n+            .iter()\n+            .map(|(p, _)| *p)\n             .collect();\n         let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n         let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);"}, {"sha": "bec19ba9099dce782ca07af507ecaaa5c371c858", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -320,7 +320,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// but which have only been unified since `s` started, and\n     /// return the types with which they were unified. So if we had\n     /// a type variable `V0`, then we started the snapshot, then we\n-    /// created a type variable `V1`, unifed `V0` with `T0`, and\n+    /// created a type variable `V1`, unified `V0` with `T0`, and\n     /// unified `V1` with `T1`, this function would return `{T0}`.\n     pub fn types_escaping_snapshot(&mut self, s: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n         let mut new_elem_threshold = u32::MAX;"}, {"sha": "8acbaaa844d74d06f64d4b52cd4c2843fcabd6f8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1020,9 +1020,12 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     }\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n-        run_lints!(self, check_pat, p);\n+        let mut visit_subpats = true;\n+        run_lints!(self, check_pat, p, &mut visit_subpats);\n         self.check_id(p.id);\n-        ast_visit::walk_pat(self, p);\n+        if visit_subpats {\n+            ast_visit::walk_pat(self, p);\n+        }\n     }\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {"}, {"sha": "cfb9f04c4c6d104a869ed5d839a855695660f8ff", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -189,7 +189,7 @@ impl<'a> LintLevelsBuilder<'a> {\n     /// This function will perform a number of tasks:\n     ///\n     /// * It'll validate all lint-related attributes in `attrs`\n-    /// * It'll mark all lint-related attriutes as used\n+    /// * It'll mark all lint-related attributes as used\n     /// * Lint levels will be updated based on the attributes provided\n     /// * Lint attributes are validated, e.g. a #[forbid] can't be switched to\n     ///   #[allow]"}, {"sha": "18922ec5d1739861c19c9de861441162979f2ef5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -341,7 +341,7 @@ pub trait EarlyLintPass: LintPass {\n     fn check_block_post(&mut self, _: &EarlyContext<'_>, _: &ast::Block) { }\n     fn check_stmt(&mut self, _: &EarlyContext<'_>, _: &ast::Stmt) { }\n     fn check_arm(&mut self, _: &EarlyContext<'_>, _: &ast::Arm) { }\n-    fn check_pat(&mut self, _: &EarlyContext<'_>, _: &ast::Pat) { }\n+    fn check_pat(&mut self, _: &EarlyContext<'_>, _: &ast::Pat, _: &mut bool) { }\n     fn check_expr(&mut self, _: &EarlyContext<'_>, _: &ast::Expr) { }\n     fn check_expr_post(&mut self, _: &EarlyContext<'_>, _: &ast::Expr) { }\n     fn check_ty(&mut self, _: &EarlyContext<'_>, _: &ast::Ty) { }"}, {"sha": "ee6d970750adfc0a7a4b96eea37dc0dc6894eb6a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -224,7 +224,7 @@ impl Default for ErrorOutputType {\n \n // Use tree-based collections to cheaply get a deterministic Hash implementation.\n // DO NOT switch BTreeMap out for an unsorted container type! That would break\n-// dependency tracking for commandline arguments.\n+// dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n pub struct OutputTypes(BTreeMap<OutputType, Option<PathBuf>>);\n \n@@ -273,7 +273,7 @@ impl OutputTypes {\n \n // Use tree-based collections to cheaply get a deterministic Hash implementation.\n // DO NOT switch BTreeMap or BTreeSet out for an unsorted container type! That\n-// would break dependency tracking for commandline arguments.\n+// would break dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n pub struct Externs(BTreeMap<String, BTreeSet<Option<String>>>);\n \n@@ -339,7 +339,7 @@ macro_rules! top_level_options {\n     );\n }\n \n-// The top-level commandline options struct\n+// The top-level command-line options struct\n //\n // For each option, one has to specify how it behaves with regard to the\n // dependency tracking system of incremental compilation. This is done via the\n@@ -2377,11 +2377,11 @@ impl fmt::Display for CrateType {\n     }\n }\n \n-/// Commandline arguments passed to the compiler have to be incorporated with\n+/// Command-line arguments passed to the compiler have to be incorporated with\n /// the dependency tracking system for incremental compilation. This module\n /// provides some utilities to make this more convenient.\n ///\n-/// The values of all commandline arguments that are relevant for dependency\n+/// The values of all command-line arguments that are relevant for dependency\n /// tracking are hashed into a single value that determines whether the\n /// incremental compilation cache can be re-used or not. This hashing is done\n /// via the DepTrackingHash trait defined below, since the standard Hash\n@@ -2394,7 +2394,7 @@ impl fmt::Display for CrateType {\n /// impl_dep_tracking_hash_via_hash!() macro that allows to simply reuse the\n /// Hash implementation for DepTrackingHash. It's important though that\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n-/// how the hash should be calculated when adding a new commandline argument.\n+/// how the hash should be calculated when adding a new command-line argument.\n mod dep_tracking {\n     use lint;\n     use middle::cstore;"}, {"sha": "8582900b72c83c5b120a7cf5ee33a374cd174425", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -393,7 +393,7 @@ impl Session {\n \n         match id.as_usize().checked_add(count) {\n             Some(next) => {\n-                self.next_node_id.set(ast::NodeId::new(next));\n+                self.next_node_id.set(ast::NodeId::from_usize(next));\n             }\n             None => bug!(\"Input too large, ran out of node ids!\"),\n         }\n@@ -1160,7 +1160,7 @@ pub fn build_session_(\n         recursion_limit: Once::new(),\n         type_length_limit: Once::new(),\n         const_eval_stack_frame_limit: 100,\n-        next_node_id: OneThread::new(Cell::new(NodeId::new(1))),\n+        next_node_id: OneThread::new(Cell::new(NodeId::from_u32(1))),\n         allocator_kind: Once::new(),\n         injected_panic_runtime: Once::new(),\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),"}, {"sha": "715ce0d7e805bf7f2623fddb64da2d9e7acdb245", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         };\n         predicates\n             .predicates\n-            .into_iter()\n+            .iter()\n             .map(|(predicate, _)| predicate.subst_supertrait(self, &trait_ref))\n             .any(|predicate| {\n                 match predicate {\n@@ -302,9 +302,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return Some(MethodViolationCode::Generic);\n         }\n \n-        if self.predicates_of(method.def_id).predicates.into_iter()\n+        if self.predicates_of(method.def_id).predicates.iter()\n                 // A trait object can't claim to live more than the concrete type,\n                 // so outlives predicates will always hold.\n+                .cloned()\n                 .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n                 .collect::<Vec<_>>()\n                 // Do a shallow visit so that `contains_illegal_self_type_reference`"}, {"sha": "99dc099d57738ec67109b9101268cefc3c886cd1", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -200,7 +200,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n /// trivial for dropck-outlives.\n ///\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n-/// with erased regions), but this funtcion does not.\n+/// with erased regions), but this function does not.\n pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // None of these types have a destructor and hence they do not"}, {"sha": "d3dc1655b0df2e592c9df568de11983c61b3f2eb", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -407,7 +407,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_, '_, '_>, impl_def_id: DefId) -> Option<\n \n     // The predicates will contain default bounds like `T: Sized`. We need to\n     // remove these bounds, and add `T: ?Sized` to any untouched type parameters.\n-    let predicates = tcx.predicates_of(impl_def_id).predicates;\n+    let predicates = &tcx.predicates_of(impl_def_id).predicates;\n     let mut pretty_predicates = Vec::with_capacity(\n         predicates.len() + types_without_default_bounds.len());\n "}, {"sha": "2c7814831450cd34219975c1bef0632c3804c845", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -781,7 +781,7 @@ pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n ///\n /// Note that what I'm calling an \"escaping var\" is often just called a \"free var\". However,\n /// we already use the term \"free var\". It refers to the regions or types that we use to represent\n-/// bound regions or type params on a fn definition while we are typechecking its body.\n+/// bound regions or type params on a fn definition while we are type checking its body.\n ///\n /// To clarify, conceptually there is no particular difference between\n /// an \"escaping\" var and a \"free\" var. However, there is a big\n@@ -857,7 +857,7 @@ struct LateBoundRegionsCollector {\n \n     /// If true, we only want regions that are known to be\n     /// \"constrained\" when you equate this type with another type. In\n-    /// partcular, if you have e.g. `&'a u32` and `&'b u32`, equating\n+    /// particular, if you have e.g. `&'a u32` and `&'b u32`, equating\n     /// them constraints `'a == 'b`.  But if you have `<&'a u32 as\n     /// Trait>::Foo` and `<&'b u32 as Trait>::Foo`, normalizing those\n     /// types may mean that `'a` and `'b` don't appear in the results,"}, {"sha": "79324bd97a3db4b40771af92b25eba97e4293c9a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1287,7 +1287,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n /// Type size \"skeleton\", i.e. the only information determining a type's size.\n /// While this is conservative, (aside from constant sizes, only pointers,\n /// newtypes thereof and null pointer optimized enums are allowed), it is\n-/// enough to statically check common usecases of transmute.\n+/// enough to statically check common use cases of transmute.\n #[derive(Copy, Clone, Debug)]\n pub enum SizeSkeleton<'tcx> {\n     /// Any statically computable Layout."}, {"sha": "96f4b1ef8e32aed3c141e649997fce9140952d5f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -2130,7 +2130,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> GenericPredicates<'gcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Lrc<GenericPredicates<'gcx>> {\n         tcx.predicates_of(self.did)\n     }\n \n@@ -2373,8 +2373,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     def_id: sized_trait,\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();\n-                let predicates = tcx.predicates_of(self.did).predicates;\n-                if predicates.into_iter().any(|(p, _)| p == sized_predicate) {\n+                let predicates = &tcx.predicates_of(self.did).predicates;\n+                if predicates.iter().any(|(p, _)| *p == sized_predicate) {\n                     vec![]\n                 } else {\n                     vec![ty]\n@@ -2400,7 +2400,7 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n \n /// Represents the various closure traits in the Rust language. This\n /// will determine the type of the environment (`self`, in the\n-/// desuaring) argument that the closure expects.\n+/// desugaring) argument that the closure expects.\n ///\n /// You can get the environment type of a closure using\n /// `tcx.closure_env_ty()`."}, {"sha": "89e7f4db502bb73138e73cdc1a23e0733d298dfe", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -127,17 +127,18 @@ define_queries! { <'tcx>\n         /// predicate gets in the way of some checks, which are intended\n         /// to operate over only the actual where-clauses written by the\n         /// user.)\n-        [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+        [] fn predicates_of: PredicatesOfItem(DefId) -> Lrc<ty::GenericPredicates<'tcx>>,\n \n         /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n         /// predicates (where clauses) directly defined on it. This is\n         /// equal to the `explicit_predicates_of` predicates plus the\n         /// `inferred_outlives_of` predicates.\n-        [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId) -> ty::GenericPredicates<'tcx>,\n+        [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId)\n+            -> Lrc<ty::GenericPredicates<'tcx>>,\n \n         /// Returns the predicates written explicit by the user.\n         [] fn explicit_predicates_of: ExplicitPredicatesOfItem(DefId)\n-            -> ty::GenericPredicates<'tcx>,\n+            -> Lrc<ty::GenericPredicates<'tcx>>,\n \n         /// Returns the inferred outlives predicates (e.g., for `struct\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n@@ -149,12 +150,12 @@ define_queries! { <'tcx>\n         /// evaluate them even during type conversion, often before the\n         /// full predicates are available (note that supertraits have\n         /// additional acyclicity requirements).\n-        [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+        [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> Lrc<ty::GenericPredicates<'tcx>>,\n \n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n-            -> ty::GenericPredicates<'tcx>,\n+            -> Lrc<ty::GenericPredicates<'tcx>>,\n \n         [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n         [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,"}, {"sha": "9971a41560335e940ed0e23acf61247611a798ca", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -942,7 +942,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n ///\n /// In the process of working on rust-lang/rust#55238 a mysterious segfault was\n /// stumbled upon. The segfault was never reproduced locally, but it was\n-/// suspected to be releated to the fact that codegen worker threads were\n+/// suspected to be related to the fact that codegen worker threads were\n /// sticking around by the time the main thread was exiting, causing issues.\n ///\n /// This structure is an attempt to fix that issue where the `codegen_aborted`"}, {"sha": "8f79d49b3e2b4c989625e7c58615c4cefec5a286", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -194,7 +194,7 @@ pub fn codegen_intrinsic_call(\n             return;\n         }\n         // Effectively no-ops\n-        \"uninit\" => {\n+        \"uninit\" | \"forget\" => {\n             return;\n         }\n         \"needs_drop\" => {"}, {"sha": "f8593363bb16ab333cfefe775006befd19c3622d", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -79,7 +79,7 @@\n //! - In order to be able to also use symbols from two versions of the same\n //!   crate (which naturally also have the same name), a stronger measure is\n //!   required: The compiler accepts an arbitrary \"disambiguator\" value via the\n-//!   `-C metadata` commandline argument. This disambiguator is then fed into\n+//!   `-C metadata` command-line argument. This disambiguator is then fed into\n //!   the symbol hash of every exported item. Consequently, the symbols in two\n //!   identical crates but with different disambiguators are not in conflict\n //!   with each other. This facility is mainly intended to be used by build"}, {"sha": "64de0c2f565a1d32efadf0973282c5c92b674b48", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -38,7 +38,7 @@ struct SccData<S: Idx> {\n     /// successors can be found.\n     ranges: IndexVec<S, Range<usize>>,\n \n-    /// Contains the succcessors for all the Sccs, concatenated. The\n+    /// Contains the successors for all the Sccs, concatenated. The\n     /// range of indices corresponding to a given SCC is found in its\n     /// SccData.\n     all_successors: Vec<S>,"}, {"sha": "27c2f8b718ab8bebb7f955e36cde1c30f515a52c", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -452,7 +452,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     /// use owning_ref::{OwningRef, Erased};\n     ///\n     /// fn main() {\n-    ///     // NB: Using the concrete types here for explicitnes.\n+    ///     // NB: Using the concrete types here for explicitness.\n     ///     // For less verbose code type aliases like `BoxRef` are provided.\n     ///\n     ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, [i32; 4]>\n@@ -722,7 +722,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// use owning_ref::{OwningRefMut, Erased};\n     ///\n     /// fn main() {\n-    ///     // NB: Using the concrete types here for explicitnes.\n+    ///     // NB: Using the concrete types here for explicitness.\n     ///     // For less verbose code type aliases like `BoxRef` are provided.\n     ///\n     ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, [i32; 4]>"}, {"sha": "29d99a6aef3f2d9c96f02f6bff740fa4bc8576b8", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -15,7 +15,7 @@ use std::mem;\n use std::ops::{RangeBounds, Bound, Index, IndexMut};\n \n /// `SortedMap` is a data structure with similar characteristics as BTreeMap but\n-/// slightly different trade-offs: lookup, inseration, and removal are O(log(N))\n+/// slightly different trade-offs: lookup, insertion, and removal are O(log(N))\n /// and elements can be iterated in order cheaply.\n ///\n /// `SortedMap` can be faster than a `BTreeMap` for small sizes (<50) since it"}, {"sha": "ec3cb95db88f8675777c52f71e0a541e79faf4d7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -643,8 +643,8 @@ impl Compilation {\n     }\n }\n \n-/// A trait for customising the compilation process. Offers a number of hooks for\n-/// executing custom code or customising input.\n+/// A trait for customizing the compilation process. Offers a number of hooks for\n+/// executing custom code or customizing input.\n pub trait CompilerCalls<'a> {\n     /// Hook for a callback early in the process of handling arguments. This will\n     /// be called straight after options have been parsed but before anything"}, {"sha": "c7ba31e33957036a44205256c1864a95c8e9984e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -425,7 +425,7 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust_hir::AnnNode::Item(item) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n-                                        item.id, item.hir_id.local_id.0))\n+                                        item.id, item.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::SubItem(id) => {\n                 s.s.space()?;\n@@ -434,18 +434,18 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust_hir::AnnNode::Block(blk) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"block node_id: {} hir local_id: {}\",\n-                                        blk.id, blk.hir_id.local_id.0))\n+                                        blk.id, blk.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::Expr(expr) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n-                                        expr.id, expr.hir_id.local_id.0))?;\n+                                        expr.id, expr.hir_id.local_id.as_u32()))?;\n                 s.pclose()\n             }\n             pprust_hir::AnnNode::Pat(pat) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"pat node_id: {} hir local_id: {}\",\n-                                        pat.id, pat.hir_id.local_id.0))\n+                                        pat.id, pat.hir_id.local_id.as_u32()))\n             }\n         }\n     }\n@@ -566,7 +566,7 @@ impl FromStr for UserIdentifiedItem {\n     type Err = ();\n     fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n         Ok(s.parse()\n-            .map(ast::NodeId::new)\n+            .map(ast::NodeId::from_u32)\n             .map(ItemViaNode)\n             .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n     }"}, {"sha": "8865c7e438e5e1708f408b6f380e10b22515a940", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -232,20 +232,20 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         // children of 1, etc\n \n         let dscope = region::Scope {\n-            id: hir::ItemLocalId(1),\n+            id: hir::ItemLocalId::from_u32(1),\n             data: region::ScopeData::Destruction,\n         };\n         self.region_scope_tree.record_scope_parent(dscope, None);\n         self.create_region_hierarchy(\n             &RH {\n-                id: hir::ItemLocalId(1),\n+                id: hir::ItemLocalId::from_u32(1),\n                 sub: &[\n                     RH {\n-                        id: hir::ItemLocalId(10),\n+                        id: hir::ItemLocalId::from_u32(10),\n                         sub: &[],\n                     },\n                     RH {\n-                        id: hir::ItemLocalId(11),\n+                        id: hir::ItemLocalId::from_u32(11),\n                         sub: &[],\n                     },\n                 ],\n@@ -400,7 +400,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n         let r = ty::ReScope(region::Scope {\n-            id: hir::ItemLocalId(id),\n+            id: hir::ItemLocalId::from_u32(id),\n             data: region::ScopeData::Node,\n         });\n         self.infcx"}, {"sha": "f76086139ed7e454c95fa0b9e0ef8a07a76de5aa", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -160,7 +160,7 @@ const LABELS_FN_IN_TRAIT: &[&[&str]] = &[\n     EXTRA_TRAIT,\n ];\n \n-/// For generic cases like inline-assemply/mod/etc\n+/// For generic cases like inline-assembly/mod/etc\n const LABELS_HIR_ONLY: &[&[&str]] = &[\n     BASE_HIR,\n ];"}, {"sha": "bef7b364d844780b238a87d8c23980db9ff298a1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -40,13 +40,16 @@ use rustc::util::nodemap::FxHashSet;\n \n use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ast;\n+use syntax::ptr::P;\n+use syntax::ast::Expr;\n use syntax::attr;\n use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n use syntax::feature_gate::{AttributeGate, AttributeType, Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n use syntax::symbol::keywords;\n use syntax::errors::{Applicability, DiagnosticBuilder};\n+use syntax::print::pprust::expr_to_string;\n \n use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -1407,21 +1410,48 @@ impl LintPass for EllipsisInclusiveRangePatterns {\n }\n \n impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n-    fn check_pat(&mut self, cx: &EarlyContext, pat: &ast::Pat) {\n-        use self::ast::{PatKind, RangeEnd, RangeSyntax};\n+    fn check_pat(&mut self, cx: &EarlyContext, pat: &ast::Pat, visit_subpats: &mut bool) {\n+        use self::ast::{PatKind, RangeEnd, RangeSyntax::DotDotDot};\n+\n+        /// If `pat` is a `...` pattern, return the start and end of the range, as well as the span\n+        /// corresponding to the ellipsis.\n+        fn matches_ellipsis_pat(pat: &ast::Pat) -> Option<(&P<Expr>, &P<Expr>, Span)> {\n+            match &pat.node {\n+                PatKind::Range(a, b, Spanned { span, node: RangeEnd::Included(DotDotDot), .. }) => {\n+                    Some((a, b, *span))\n+                }\n+                _ => None,\n+            }\n+        }\n \n-        if let PatKind::Range(\n-            _, _, Spanned { span, node: RangeEnd::Included(RangeSyntax::DotDotDot) }\n-        ) = pat.node {\n+        let (parenthesise, endpoints) = match &pat.node {\n+            PatKind::Ref(subpat, _) => (true, matches_ellipsis_pat(&subpat)),\n+            _ => (false, matches_ellipsis_pat(pat)),\n+        };\n+\n+        if let Some((start, end, join)) = endpoints {\n             let msg = \"`...` range patterns are deprecated\";\n-            let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, span, msg);\n-            err.span_suggestion_short_with_applicability(\n-                span, \"use `..=` for an inclusive range\", \"..=\".to_owned(),\n-                // FIXME: outstanding problem with precedence in ref patterns:\n-                // https://github.com/rust-lang/rust/issues/51043#issuecomment-392252285\n-                Applicability::MaybeIncorrect\n-            );\n-            err.emit()\n+            let suggestion = \"use `..=` for an inclusive range\";\n+            if parenthesise {\n+                *visit_subpats = false;\n+                let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg);\n+                err.span_suggestion_with_applicability(\n+                    pat.span,\n+                    suggestion,\n+                    format!(\"&({}..={})\", expr_to_string(&start), expr_to_string(&end)),\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+            } else {\n+                let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, msg);\n+                err.span_suggestion_short_with_applicability(\n+                    join,\n+                    suggestion,\n+                    \"..=\".to_owned(),\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+            };\n         }\n     }\n }\n@@ -1486,7 +1516,7 @@ declare_lint! {\n     \"detects edition keywords being used as an identifier\"\n }\n \n-/// Checks for uses of edtion keywords used as an identifier\n+/// Checks for uses of edition keywords used as an identifier\n #[derive(Clone)]\n pub struct KeywordIdents;\n "}, {"sha": "7eab7d21002905778c494089850c05c9b957bdf4", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -396,12 +396,12 @@ impl EarlyLintPass for UnusedParens {\n         self.check_unused_parens_expr(cx, &value, msg, followed_by_block);\n     }\n \n-    fn check_pat(&mut self, cx: &EarlyContext, p: &ast::Pat) {\n+    fn check_pat(&mut self, cx: &EarlyContext, p: &ast::Pat, _: &mut bool) {\n         use ast::PatKind::{Paren, Range};\n         // The lint visitor will visit each subpattern of `p`. We do not want to lint any range\n         // pattern no matter where it occurs in the pattern. For something like `&(a..=b)`, there\n         // is a recursive `check_pat` on `a` and `b`, but we will assume that if there are\n-        // unnecessry parens they serve a purpose of readability.\n+        // unnecessary parens they serve a purpose of readability.\n         if let Paren(ref pat) = p.node {\n             match pat.node {\n                 Range(..) => {}"}, {"sha": "276e2a911e6978966bef1d5857fd1b50d55af00c", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -11,12 +11,14 @@ crate-type = [\"dylib\"]\n [dependencies]\n flate2 = \"1.0\"\n log = \"0.4\"\n+memmap = \"0.6\"\n proc_macro = { path = \"../libproc_macro\" }\n rustc = { path = \"../librustc\" }\n-rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_target = { path = \"../librustc_target\" }\n serialize = { path = \"../libserialize\" }\n+stable_deref_trait = \"1.0.0\"\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "e1d9ca5339e6a4201114ff324a10e79346db6e04", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -103,9 +103,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     generics_of => {\n         tcx.alloc_generics(cdata.get_generics(def_id.index, tcx.sess))\n     }\n-    predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n-    predicates_defined_on => { cdata.get_predicates_defined_on(def_id.index, tcx) }\n-    super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n+    predicates_of => { Lrc::new(cdata.get_predicates(def_id.index, tcx)) }\n+    predicates_defined_on => { Lrc::new(cdata.get_predicates_defined_on(def_id.index, tcx)) }\n+    super_predicates_of => { Lrc::new(cdata.get_super_predicates(def_id.index, tcx)) }\n     trait_def => {\n         tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx.sess))\n     }"}, {"sha": "0322c888ad5c96c5e144420b5c9b09b0a0595d45", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -30,6 +30,8 @@\n extern crate libc;\n #[macro_use]\n extern crate log;\n+extern crate memmap;\n+extern crate stable_deref_trait;\n #[macro_use]\n extern crate syntax;\n extern crate syntax_pos;"}, {"sha": "528c96f240dbac252bc2e8a112092da66dd2796c", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -243,12 +243,14 @@ use std::cmp;\n use std::fmt;\n use std::fs;\n use std::io::{self, Read};\n+use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::time::Instant;\n \n use flate2::read::DeflateDecoder;\n \n use rustc_data_structures::owning_ref::OwningRef;\n+\n pub struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n@@ -856,6 +858,19 @@ fn get_metadata_section(target: &Target,\n     return ret;\n }\n \n+/// A trivial wrapper for `Mmap` that implements `StableDeref`.\n+struct StableDerefMmap(memmap::Mmap);\n+\n+impl Deref for StableDerefMmap {\n+    type Target = [u8];\n+\n+    fn deref(&self) -> &[u8] {\n+        self.0.deref()\n+    }\n+}\n+\n+unsafe impl stable_deref_trait::StableDeref for StableDerefMmap {}\n+\n fn get_metadata_section_imp(target: &Target,\n                             flavor: CrateFlavor,\n                             filename: &Path,\n@@ -892,9 +907,14 @@ fn get_metadata_section_imp(target: &Target,\n             }\n         }\n         CrateFlavor::Rmeta => {\n-            let buf = fs::read(filename).map_err(|_|\n-                format!(\"failed to read rmeta metadata: '{}'\", filename.display()))?;\n-            rustc_erase_owner!(OwningRef::new(buf).map_owner_box())\n+            // mmap the file, because only a small fraction of it is read.\n+            let file = std::fs::File::open(filename).map_err(|_|\n+                format!(\"failed to open rmeta metadata: '{}'\", filename.display()))?;\n+            let mmap = unsafe { memmap::Mmap::map(&file) };\n+            let mmap = mmap.map_err(|_|\n+                format!(\"failed to mmap rmeta metadata: '{}'\", filename.display()))?;\n+\n+            rustc_erase_owner!(OwningRef::new(StableDerefMmap(mmap)).map_owner_box())\n         }\n     };\n     let blob = MetadataBlob(raw_bytes);"}, {"sha": "06dfd4bc2cc1fc7ac567e023feac1b2bea0bdca2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -112,7 +112,7 @@ mod relate_tys;\n /// - `liveness` -- results of a liveness computation on the MIR; used to create liveness\n ///   constraints for the regions in the types of variables\n /// - `flow_inits` -- results of a maybe-init dataflow analysis\n-/// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysiss\n+/// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n pub(crate) fn type_check<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,"}, {"sha": "715d6e0c0d1b3685431039b4c0911dd7ee6a13c1", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -262,7 +262,7 @@ struct PlaceComponents<'p, 'tcx: 'p> {\n impl<'p, 'tcx> PlaceComponents<'p, 'tcx> {\n     /// Converts a list of `Place` components into an iterator; this\n     /// iterator yields up a never-ending stream of `Option<&Place>`.\n-    /// These begin with the \"innermst\" place and then with each\n+    /// These begin with the \"innermost\" place and then with each\n     /// projection therefrom. So given a place like `a.b.c` it would\n     /// yield up:\n     ///"}, {"sha": "2ef71617b7cb615fd771ed42284d31f37b4f193e", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         let source_info = this.source_info(span);\n         for stmt in stmts {\n-            let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n+            let Stmt { kind, opt_destruction_scope, span: stmt_span } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result: true });\n@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             let si = (scope, source_info);\n                             this.in_scope(si, LintLevel::Inherited, block, |this| {\n                                 let expr = this.hir.mirror(expr);\n-                                this.stmt_expr(block, expr)\n+                                this.stmt_expr(block, expr, Some(stmt_span))\n                             })\n                         }));\n                 }\n@@ -177,17 +177,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let destination_ty = destination.ty(&this.local_decls, tcx).to_ty(tcx);\n         if let Some(expr) = expr {\n             let tail_result_is_ignored = destination_ty.is_unit() ||\n-                match this.block_context.last() {\n-                    // no context: conservatively assume result is read\n-                    None => false,\n-\n-                    // sub-expression: block result feeds into some computation\n-                    Some(BlockFrame::SubExpr) => false,\n-\n-                    // otherwise: use accumualated is_ignored state.\n-                    Some(BlockFrame::TailExpr { tail_result_is_ignored: ignored }) |\n-                    Some(BlockFrame::Statement { ignores_expr_result: ignored }) => *ignored,\n-                };\n+                this.block_context.currently_ignores_tail_results();\n             this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored });\n \n             unpack!(block = this.into(destination, block, expr));"}, {"sha": "18ce7ae4907085b1d4eb1cd37db59710951dd4a4", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Rvalue::Aggregate(adt, fields))\n             }\n             ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n-                block = unpack!(this.stmt_expr(block, expr));\n+                block = unpack!(this.stmt_expr(block, expr, None));\n                 block.and(this.unit_rvalue())\n             }\n             ExprKind::Yield { value } => {"}, {"sha": "8f50a1e9a21b9093c746cc71d46c308450c14684", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -10,7 +10,7 @@\n \n //! See docs in build/expr/mod.rs\n \n-use build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n+use build::{BlockAnd, BlockAndExtension, Builder};\n use hair::*;\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -68,19 +68,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             debug!(\"creating temp {:?} with block_context: {:?}\", local_decl, this.block_context);\n             // Find out whether this temp is being created within the\n             // tail expression of a block whose result is ignored.\n-            for bf in this.block_context.iter().rev() {\n-                match bf {\n-                    BlockFrame::SubExpr => continue,\n-                    BlockFrame::Statement { .. } => break,\n-                    &BlockFrame::TailExpr { tail_result_is_ignored } => {\n-                        local_decl = local_decl.block_tail(BlockTailInfo {\n-                            tail_result_is_ignored\n-                        });\n-                        break;\n-                    }\n-                }\n+            if let Some(tail_info) = this.block_context.currently_in_block_tail() {\n+                local_decl = local_decl.block_tail(tail_info);\n             }\n-\n             this.local_decls.push(local_decl)\n         };\n         if !expr_ty.is_never() {"}, {"sha": "8eb46a0483917c69551c03351cf2c5ee6c0d10f1", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             | ExprKind::Break { .. }\n             | ExprKind::InlineAsm { .. }\n             | ExprKind::Return { .. } => {\n-                unpack!(block = this.stmt_expr(block, expr));\n+                unpack!(block = this.stmt_expr(block, expr, None));\n                 this.cfg.push_assign_unit(block, source_info, destination);\n                 block.unit()\n             }"}, {"sha": "45235b31539345a4f4e14a73fa55a938524b45b2", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -14,7 +14,18 @@ use hair::*;\n use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n-    pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n+    /// Builds a block of MIR statements to evaluate the HAIR `expr`.\n+    /// If the original expression was an AST statement,\n+    /// (e.g. `some().code(&here());`) then `opt_stmt_span` is the\n+    /// span of that statement (including its semicolon, if any).\n+    /// Diagnostics use this span (which may be larger than that of\n+    /// `expr`) to identify when statement temporaries are dropped.\n+    pub fn stmt_expr(&mut self,\n+                     mut block: BasicBlock,\n+                     expr: Expr<'tcx>,\n+                     opt_stmt_span: Option<StatementSpan>)\n+                     -> BlockAnd<()>\n+    {\n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr.span);\n@@ -29,7 +40,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             } => {\n                 let value = this.hir.mirror(value);\n                 this.in_scope((region_scope, source_info), lint_level, block, |this| {\n-                    this.stmt_expr(block, value)\n+                    this.stmt_expr(block, value, opt_stmt_span)\n                 })\n             }\n             ExprKind::Assign { lhs, rhs } => {\n@@ -190,9 +201,56 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             _ => {\n                 let expr_ty = expr.ty;\n-                let temp = this.temp(expr.ty.clone(), expr_span);\n+\n+                // Issue #54382: When creating temp for the value of\n+                // expression like:\n+                //\n+                // `{ side_effects(); { let l = stuff(); the_value } }`\n+                //\n+                // it is usually better to focus on `the_value` rather\n+                // than the entirety of block(s) surrounding it.\n+                let mut temp_span = expr_span;\n+                let mut temp_in_tail_of_block = false;\n+                if let ExprKind::Block { body } = expr.kind {\n+                    if let Some(tail_expr) = &body.expr {\n+                        let mut expr = tail_expr;\n+                        while let rustc::hir::ExprKind::Block(subblock, _label) = &expr.node {\n+                            if let Some(subtail_expr) = &subblock.expr {\n+                                expr = subtail_expr\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                        temp_span = expr.span;\n+                        temp_in_tail_of_block = true;\n+                    }\n+                }\n+\n+                let temp = {\n+                    let mut local_decl = LocalDecl::new_temp(expr.ty.clone(), temp_span);\n+                    if temp_in_tail_of_block {\n+                        if this.block_context.currently_ignores_tail_results() {\n+                            local_decl = local_decl.block_tail(BlockTailInfo {\n+                                tail_result_is_ignored: true\n+                            });\n+                        }\n+                    }\n+                    let temp = this.local_decls.push(local_decl);\n+                    let place = Place::Local(temp);\n+                    debug!(\"created temp {:?} for expr {:?} in block_context: {:?}\",\n+                           temp, expr, this.block_context);\n+                    place\n+                };\n                 unpack!(block = this.into(&temp, block, expr));\n-                unpack!(block = this.build_drop(block, expr_span, temp, expr_ty));\n+\n+                // Attribute drops of the statement's temps to the\n+                // semicolon at the statement's end.\n+                let drop_point = this.hir.tcx().sess.source_map().end_point(match opt_stmt_span {\n+                    None => expr_span,\n+                    Some(StatementSpan(span)) => span,\n+                });\n+\n+                unpack!(block = this.build_drop(block, drop_point, temp, expr_ty));\n                 block.unit()\n             }\n         }"}, {"sha": "5d9cb014f5821bda850c2b0340545efaa86df840", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -31,7 +31,7 @@ use std::cmp::Ordering;\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n-    /// It is a bug to call this with a simplifyable pattern.\n+    /// It is a bug to call this with a simplifiable pattern.\n     pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n             PatternKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => {"}, {"sha": "a01f8940a948aedebc02717ad1cfa26f216d7ba0", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -336,6 +336,9 @@ impl BlockFrame {\n     }\n  }\n \n+#[derive(Debug)]\n+struct BlockContext(Vec<BlockFrame>);\n+\n struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     hir: Cx<'a, 'gcx, 'tcx>,\n     cfg: CFG<'tcx>,\n@@ -359,7 +362,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// start just throwing new entries onto that vector in order to\n     /// distinguish the context of EXPR1 from the context of EXPR2 in\n     /// `{ STMTS; EXPR1 } + EXPR2`\n-    block_context: Vec<BlockFrame>,\n+    block_context: BlockContext,\n \n     /// The current unsafe block in scope, even if it is hidden by\n     /// a PushUnsafeBlock\n@@ -409,6 +412,55 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n }\n \n+impl BlockContext {\n+    fn new() -> Self { BlockContext(vec![]) }\n+    fn push(&mut self, bf: BlockFrame) { self.0.push(bf); }\n+    fn pop(&mut self) -> Option<BlockFrame> { self.0.pop() }\n+\n+    /// Traverses the frames on the BlockContext, searching for either\n+    /// the first block-tail expression frame with no intervening\n+    /// statement frame.\n+    ///\n+    /// Notably, this skips over `SubExpr` frames; this method is\n+    /// meant to be used in the context of understanding the\n+    /// relationship of a temp (created within some complicated\n+    /// expression) with its containing expression, and whether the\n+    /// value of that *containing expression* (not the temp!) is\n+    /// ignored.\n+    fn currently_in_block_tail(&self) -> Option<BlockTailInfo> {\n+        for bf in self.0.iter().rev() {\n+            match bf {\n+                BlockFrame::SubExpr => continue,\n+                BlockFrame::Statement { .. } => break,\n+                &BlockFrame::TailExpr { tail_result_is_ignored } =>\n+                    return Some(BlockTailInfo { tail_result_is_ignored })\n+            }\n+        }\n+\n+        return None;\n+    }\n+\n+    /// Looks at the topmost frame on the BlockContext and reports\n+    /// whether its one that would discard a block tail result.\n+    ///\n+    /// Unlike `currently_within_ignored_tail_expression`, this does\n+    /// *not* skip over `SubExpr` frames: here, we want to know\n+    /// whether the block result itself is discarded.\n+    fn currently_ignores_tail_results(&self) -> bool {\n+        match self.0.last() {\n+            // no context: conservatively assume result is read\n+            None => false,\n+\n+            // sub-expression: block result feeds into some computation\n+            Some(BlockFrame::SubExpr) => false,\n+\n+            // otherwise: use accumulated is_ignored state.\n+            Some(BlockFrame::TailExpr { tail_result_is_ignored: ignored }) |\n+            Some(BlockFrame::Statement { ignores_expr_result: ignored }) => *ignored,\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n enum LocalsForNode {\n     /// In the usual case, a node-id for an identifier maps to at most\n@@ -764,7 +816,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             fn_span: span,\n             arg_count,\n             scopes: vec![],\n-            block_context: vec![],\n+            block_context: BlockContext::new(),\n             source_scopes: IndexVec::new(),\n             source_scope: OUTERMOST_SOURCE_SCOPE,\n             source_scope_local_data: IndexVec::new(),"}, {"sha": "d56ddcb494406ba666beb0f0c6d7e91539675a68", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -57,6 +57,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     for (index, stmt) in stmts.iter().enumerate() {\n         let hir_id = cx.tcx.hir.node_to_hir_id(stmt.node.id());\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n+        let stmt_span = StatementSpan(cx.tcx.hir.span(stmt.node.id()));\n         match stmt.node {\n             hir::StmtKind::Expr(ref expr, _) |\n             hir::StmtKind::Semi(ref expr, _) => {\n@@ -69,6 +70,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         expr: expr.to_ref(),\n                     },\n                     opt_destruction_scope: opt_dxn_ext,\n+                    span: stmt_span,\n                 })))\n             }\n             hir::StmtKind::Decl(ref decl, _) => {\n@@ -111,6 +113,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 lint_level: cx.lint_level_of(local.id),\n                             },\n                             opt_destruction_scope: opt_dxn_ext,\n+                            span: stmt_span,\n                         })));\n                     }\n                 }"}, {"sha": "3078f10598c0dfff100330ec7ef5c20e4fc5b8e5", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -72,10 +72,14 @@ pub enum StmtRef<'tcx> {\n     Mirror(Box<Stmt<'tcx>>),\n }\n \n+#[derive(Clone, Debug)]\n+pub struct StatementSpan(pub Span);\n+\n #[derive(Clone, Debug)]\n pub struct Stmt<'tcx> {\n     pub kind: StmtKind<'tcx>,\n     pub opt_destruction_scope: Option<region::Scope>,\n+    pub span: StatementSpan,\n }\n \n #[derive(Clone, Debug)]\n@@ -116,7 +120,7 @@ pub enum StmtKind<'tcx> {\n /// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n /// may in turn be another instance of this enum (boxed), or else an\n /// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n-/// shortlived. They are created by `Hair::to_expr`, analyzed and\n+/// short-lived. They are created by `Hair::to_expr`, analyzed and\n /// converted into MIR, and then discarded.\n ///\n /// If you compare `Expr` to the full compiler AST, you will see it is"}, {"sha": "fd869d6c334ab29ede2d078f84b6ed9ac9c0fd7e", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -55,11 +55,11 @@\n /// all the values it covers are already covered by row 2.\n ///\n /// To compute `U`, we must have two other concepts.\n-///     1. `S(c, P)` is a \"specialised matrix\", where `c` is a constructor (like `Some` or\n+///     1. `S(c, P)` is a \"specialized matrix\", where `c` is a constructor (like `Some` or\n ///        `None`). You can think of it as filtering `P` to just the rows whose *first* pattern\n ///        can cover `c` (and expanding OR-patterns into distinct patterns), and then expanding\n ///        the constructor into all of its components.\n-///        The specialisation of a row vector is computed by `specialize`.\n+///        The specialization of a row vector is computed by `specialize`.\n ///\n ///        It is computed as follows. For each row `p_i` of P, we have four cases:\n ///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `S(c, P)` has a corresponding row:\n@@ -1453,7 +1453,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n /// mean creating a separate constructor for every single value in the range, which is clearly\n /// impractical. However, observe that for some ranges of integers, the specialisation will be\n /// identical across all values in that range (i.e. there are equivalence classes of ranges of\n-/// constructors based on their `is_useful_specialised` outcome). These classes are grouped by\n+/// constructors based on their `is_useful_specialized` outcome). These classes are grouped by\n /// the patterns that apply to them (in the matrix `P`). We can split the range whenever the\n /// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n /// change."}, {"sha": "988ff7e75163d78da371f2e90aa55762dd0436c9", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -67,7 +67,7 @@ macro_rules! try_validation {\n     }}\n }\n \n-/// We want to show a nice path to the invalid field for diagnotsics,\n+/// We want to show a nice path to the invalid field for diagnostics,\n /// but avoid string operations in the happy case where no error happens.\n /// So we track a `Vec<PathElem>` where `PathElem` contains all the data we\n /// need to later print something for the user."}, {"sha": "a90cccfa7a7749dd4e87d10a12c4d3c66d2207ab", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     /// While the `ExprUseVisitor` walks, we will identify which\n     /// expressions are borrowed, and insert their ids into this\n     /// table. Actually, we insert the \"borrow-id\", which is normally\n-    /// the id of the expession being borrowed: but in the case of\n+    /// the id of the expression being borrowed: but in the case of\n     /// `ref mut` borrows, the `id` of the pattern is\n     /// inserted. Therefore later we remove that entry from the table\n     /// and transfer it over to the value being matched. This will"}, {"sha": "5a91b50f6bcc9d1bbad31decd56904f167eb57b1", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -663,7 +663,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let mut errors = false;\n         let mut seen_spans = FxHashSet::default();\n         let mut error_vec = Vec::new();\n-        let mut prev_root_id: NodeId = NodeId::new(0);\n+        let mut prev_root_id: NodeId = NodeId::from_u32(0);\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n             let error = self.finalize_import(import);"}, {"sha": "cf1bc04dd4e01dd92b17dd25f2e7f918b7c40dda", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -217,8 +217,9 @@ fn program_clauses_for_trait<'a, 'tcx>(\n \n     let implemented_from_env = Clause::ForAll(ty::Binder::bind(implemented_from_env));\n \n-    let where_clauses = &tcx.predicates_defined_on(def_id).predicates\n-        .into_iter()\n+    let predicates = &tcx.predicates_defined_on(def_id).predicates;\n+    let where_clauses = &predicates\n+        .iter()\n         .map(|(wc, _)| wc.lower())\n         .map(|wc| wc.subst(tcx, bound_vars))\n         .collect::<Vec<_>>();\n@@ -314,8 +315,9 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n \n     // `WC`\n-    let where_clauses = tcx.predicates_of(def_id).predicates\n-        .into_iter()\n+    let predicates = &tcx.predicates_of(def_id).predicates;\n+    let where_clauses = predicates\n+        .iter()\n         .map(|(wc, _)| wc.lower())\n         .map(|wc| wc.subst(tcx, bound_vars));\n \n@@ -352,7 +354,7 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n \n     // `WC`\n     let where_clauses = tcx.predicates_of(def_id).predicates\n-        .into_iter()\n+        .iter()\n         .map(|(wc, _)| wc.lower())\n         .map(|wc| wc.subst(tcx, bound_vars))\n         .collect::<Vec<_>>();"}, {"sha": "d388d75643888ea76908fa8bcdec68f1a672b68b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -24,6 +24,7 @@ use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::wf::object_region_bounds;\n+use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n use std::collections::BTreeSet;\n use std::slice;\n@@ -45,7 +46,7 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n-                                 -> ty::GenericPredicates<'tcx>;\n+                                 -> Lrc<ty::GenericPredicates<'tcx>>;\n \n     /// What lifetime should we use when a lifetime is omitted (and not elided)?\n     fn re_infer(&self, span: Span, _def: Option<&ty::GenericParamDef>)\n@@ -1119,8 +1120,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     {\n         let tcx = self.tcx();\n \n-        let bounds = self.get_type_parameter_bounds(span, ty_param_def_id)\n-            .predicates.into_iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref());\n+        let predicates = &self.get_type_parameter_bounds(span, ty_param_def_id).predicates;\n+        let bounds = predicates.iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref());\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name."}, {"sha": "9aad17626f9a12b89b7e120afc5e6a1047da07a0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -134,6 +134,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"rustc_peek\" => (1, vec![param(0)], param(0)),\n             \"init\" => (1, Vec::new(), param(0)),\n             \"uninit\" => (1, Vec::new(), param(0)),\n+            \"forget\" => (1, vec![param(0)], tcx.mk_unit()),\n             \"transmute\" => (2, vec![ param(0) ], param(1)),\n             \"move_val_init\" => {\n                 (1,"}, {"sha": "0373bf4e7522deeaa0797e50d6a9db1652b6f2b0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1440,7 +1440,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///\n     /// 1. Because the numbers of the region variables would otherwise be fairly unique to this\n     ///    particular method call, it winds up creating fewer types overall, which helps for memory\n-    ///    usage. (Admittedly, this is a rather small effect, though measureable.)\n+    ///    usage. (Admittedly, this is a rather small effect, though measurable.)\n     ///\n     /// 2. It makes it easier to deal with higher-ranked trait bounds, because we can replace any\n     ///    late-bound regions with 'static. Otherwise, if we were going to replace late-bound"}, {"sha": "eed5d909063bd9dd7af8fc32594cf48b73dfc7e7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1869,15 +1869,15 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n-                                 -> ty::GenericPredicates<'tcx>\n+                                 -> Lrc<ty::GenericPredicates<'tcx>>\n     {\n         let tcx = self.tcx;\n         let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let item_id = tcx.hir.ty_param_owner(node_id);\n         let item_def_id = tcx.hir.local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n         let index = generics.param_def_id_to_index[&def_id];\n-        ty::GenericPredicates {\n+        Lrc::new(ty::GenericPredicates {\n             parent: None,\n             predicates: self.param_env.caller_bounds.iter().filter_map(|&predicate| {\n                 match predicate {\n@@ -1890,7 +1890,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => None\n                 }\n             }).collect()\n-        }\n+        })\n     }\n \n     fn re_infer(&self, span: Span, def: Option<&ty::GenericParamDef>)"}, {"sha": "b5addbd18d2a4e20f1e58b2e5c18420905dfdf7b", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -910,8 +910,8 @@ fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n \n     let def_id = fcx.tcx.hir.local_def_id(id);\n     let predicates = fcx.tcx.predicates_of(def_id).predicates\n-        .into_iter()\n-        .map(|(p, _)| p)\n+        .iter()\n+        .map(|(p, _)| *p)\n         .collect();\n     // Check elaborated bounds\n     let implied_obligations = traits::elaborate_predicates(fcx.tcx, predicates);"}, {"sha": "6ef09d96fd1537f161286bd734a498c67ae2db3e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -39,6 +39,7 @@ use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::{ReprOptions, ToPredicate};\n use rustc::util::captures::Captures;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n \n use syntax::ast;\n@@ -178,7 +179,8 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n+    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n+                                 -> Lrc<ty::GenericPredicates<'tcx>> {\n         self.tcx\n             .at(span)\n             .type_param_predicates((self.item_def_id, def_id))\n@@ -243,7 +245,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n fn type_param_predicates<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (item_def_id, def_id): (DefId, DefId),\n-) -> ty::GenericPredicates<'tcx> {\n+) -> Lrc<ty::GenericPredicates<'tcx>> {\n     use rustc::hir::*;\n \n     // In the AST, bounds can derive from two places. Either\n@@ -264,11 +266,11 @@ fn type_param_predicates<'a, 'tcx>(\n         tcx.generics_of(item_def_id).parent\n     };\n \n-    let mut result = parent.map_or(\n-        ty::GenericPredicates {\n+    let mut result = parent.map_or_else(\n+        || Lrc::new(ty::GenericPredicates {\n             parent: None,\n             predicates: vec![],\n-        },\n+        }),\n         |parent| {\n             let icx = ItemCtxt::new(tcx, parent);\n             icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n@@ -298,7 +300,7 @@ fn type_param_predicates<'a, 'tcx>(\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_node_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n-                        result\n+                        Lrc::make_mut(&mut result)\n                             .predicates\n                             .push((identity_trait_ref.to_predicate(), item.span));\n                     }\n@@ -317,7 +319,7 @@ fn type_param_predicates<'a, 'tcx>(\n     };\n \n     let icx = ItemCtxt::new(tcx, item_def_id);\n-    result\n+    Lrc::make_mut(&mut result)\n         .predicates\n         .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty,\n             OnlySelfBounds(true)));\n@@ -685,7 +687,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n fn super_predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_def_id: DefId,\n-) -> ty::GenericPredicates<'tcx> {\n+) -> Lrc<ty::GenericPredicates<'tcx>> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n     let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n \n@@ -729,10 +731,10 @@ fn super_predicates_of<'a, 'tcx>(\n         }\n     }\n \n-    ty::GenericPredicates {\n+    Lrc::new(ty::GenericPredicates {\n         parent: None,\n         predicates: superbounds,\n-    }\n+    })\n }\n \n fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n@@ -1605,27 +1607,23 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n fn predicates_defined_on<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> ty::GenericPredicates<'tcx> {\n-    let explicit = tcx.explicit_predicates_of(def_id);\n-    let span = tcx.def_span(def_id);\n-    let predicates = explicit.predicates.into_iter().chain(\n-        tcx.inferred_outlives_of(def_id).iter().map(|&p| (p, span))\n-    ).collect();\n-\n-    ty::GenericPredicates {\n-        parent: explicit.parent,\n-        predicates: predicates,\n+) -> Lrc<ty::GenericPredicates<'tcx>> {\n+    let mut result = tcx.explicit_predicates_of(def_id);\n+    let inferred_outlives = tcx.inferred_outlives_of(def_id);\n+    if !inferred_outlives.is_empty() {\n+        let span = tcx.def_span(def_id);\n+        Lrc::make_mut(&mut result)\n+            .predicates\n+            .extend(inferred_outlives.iter().map(|&p| (p, span)));\n     }\n+    result\n }\n \n fn predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> ty::GenericPredicates<'tcx> {\n-    let ty::GenericPredicates {\n-        parent,\n-        mut predicates,\n-    } = tcx.predicates_defined_on(def_id);\n+) -> Lrc<ty::GenericPredicates<'tcx>> {\n+    let mut result = tcx.predicates_defined_on(def_id);\n \n     if tcx.is_trait(def_id) {\n         // For traits, add `Self: Trait` predicate. This is\n@@ -1641,16 +1639,17 @@ fn predicates_of<'a, 'tcx>(\n         // used, and adding the predicate into this list ensures\n         // that this is done.\n         let span = tcx.def_span(def_id);\n-        predicates.push((ty::TraitRef::identity(tcx, def_id).to_predicate(), span));\n+        Lrc::make_mut(&mut result)\n+            .predicates\n+            .push((ty::TraitRef::identity(tcx, def_id).to_predicate(), span));\n     }\n-\n-    ty::GenericPredicates { parent, predicates }\n+    result\n }\n \n fn explicit_predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> ty::GenericPredicates<'tcx> {\n+) -> Lrc<ty::GenericPredicates<'tcx>> {\n     use rustc::hir::*;\n     use rustc_data_structures::fx::FxHashSet;\n \n@@ -1761,10 +1760,10 @@ fn explicit_predicates_of<'a, 'tcx>(\n \n                     if impl_trait_fn.is_some() {\n                         // impl Trait\n-                        return ty::GenericPredicates {\n+                        return Lrc::new(ty::GenericPredicates {\n                             parent: None,\n                             predicates: bounds.predicates(tcx, opaque_ty),\n-                        };\n+                        });\n                     } else {\n                         // named existential types\n                         predicates.extend(bounds.predicates(tcx, opaque_ty));\n@@ -1794,7 +1793,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // on a trait we need to add in the supertrait bounds and bounds found on\n     // associated types.\n     if let Some((_trait_ref, _)) = is_trait {\n-        predicates.extend(tcx.super_predicates_of(def_id).predicates);\n+        predicates.extend(tcx.super_predicates_of(def_id).predicates.iter().cloned());\n     }\n \n     // In default impls, we can assume that the self type implements\n@@ -1971,10 +1970,10 @@ fn explicit_predicates_of<'a, 'tcx>(\n         );\n     }\n \n-    ty::GenericPredicates {\n+    Lrc::new(ty::GenericPredicates {\n         parent: generics.parent,\n         predicates,\n-    }\n+    })\n }\n \n pub enum SizedByDefault {"}, {"sha": "9b374cf932fa9ad35352304aa1c5506315dd8b83", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -33,14 +33,14 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n     ) -> &RequiredPredicates<'tcx> {\n         self.map.entry(def_id).or_insert_with(|| {\n             let predicates = if def_id.is_local() {\n-                tcx.explicit_predicates_of(def_id).predicates\n+                tcx.explicit_predicates_of(def_id)\n             } else {\n-                tcx.predicates_of(def_id).predicates\n+                tcx.predicates_of(def_id)\n             };\n             let mut required_predicates = RequiredPredicates::default();\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n-            for (pred, _) in predicates.into_iter() {\n+            for (pred, _) in predicates.predicates.iter() {\n                 match pred {\n                     ty::Predicate::TypeOutlives(predicate) => {\n                         let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();"}, {"sha": "0518d73e1e30f7e26f2c81634d221a9d2a7475d0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1563,7 +1563,7 @@ impl Clean<Generics> for hir::Generics {\n }\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n-                                    &'a ty::GenericPredicates<'tcx>) {\n+                                    &'a Lrc<ty::GenericPredicates<'tcx>>) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         use self::WherePredicate as WP;\n "}, {"sha": "635608d140db48d86ecdb70f3be4753f810401ff", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -156,8 +156,8 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     if child == trait_ {\n         return true\n     }\n-    let predicates = cx.tcx.super_predicates_of(child).predicates;\n-    predicates.iter().filter_map(|(pred, _)| {\n+    let predicates = cx.tcx.super_predicates_of(child);\n+    predicates.predicates.iter().filter_map(|(pred, _)| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n             if pred.skip_binder().trait_ref.self_ty().is_self() {\n                 Some(pred.def_id())"}, {"sha": "f4d05c6dbd65c000e5fe6faa575f26e9ae8721a0", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -187,7 +187,7 @@ pub struct RenderOptions {\n     /// Whether to generate a table of contents on the output file when reading a standalone\n     /// Markdown file.\n     pub markdown_no_toc: bool,\n-    /// Additional CSS files to link in pages generated from standlone Markdown files.\n+    /// Additional CSS files to link in pages generated from standalone Markdown files.\n     pub markdown_css: Vec<String>,\n     /// If present, playground URL to use in the \"Run\" button added to code samples generated from\n     /// standalone Markdown files. If not present, `playground_url` is used."}, {"sha": "b2473dd9b236d311cbf2754b1cc4dd547deb0e87", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -961,7 +961,7 @@ span.since {\n \t\tpadding-top: 0px;\n \t}\n \n-\tbody > .sidebar {\n+\t.rustdoc > .sidebar {\n \t\theight: 45px;\n \t\tmin-height: 40px;\n \t\tmargin: 0;"}, {"sha": "471ba6345e248ed002112873c40bb9bbd54ab384", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -243,7 +243,7 @@ fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx>(\n         if tests.found_tests == 0 {\n             let mut diag = cx.tcx.struct_span_lint_node(\n                 lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n-                NodeId::new(0),\n+                NodeId::from_u32(0),\n                 span_of_attrs(&item.attrs),\n                 \"Missing code example in this documentation\");\n             diag.emit();\n@@ -281,14 +281,14 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n         let current_item = match item.inner {\n             ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n-                    if item_node_id.unwrap() != NodeId::new(0) {\n+                    if item_node_id.unwrap() != NodeId::from_u32(0) {\n                         item.name.clone()\n                     } else {\n                         None\n                     }\n                 } else {\n                     match parent_node.or(self.mod_ids.last().cloned()) {\n-                        Some(parent) if parent != NodeId::new(0) => {\n+                        Some(parent) if parent != NodeId::from_u32(0) => {\n                             //FIXME: can we pull the parent module's name from elsewhere?\n                             Some(self.cx.tcx.hir.name(parent).to_string())\n                         }\n@@ -538,13 +538,13 @@ fn resolution_failure(\n             );\n \n             diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                                NodeId::new(0),\n+                                                NodeId::from_u32(0),\n                                                 sp,\n                                                 &msg);\n             diag.span_label(sp, \"cannot be resolved, ignoring\");\n         } else {\n             diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                                NodeId::new(0),\n+                                                NodeId::from_u32(0),\n                                                 sp,\n                                                 &msg);\n \n@@ -564,7 +564,7 @@ fn resolution_failure(\n         diag\n     } else {\n         cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                     NodeId::new(0),\n+                                     NodeId::from_u32(0),\n                                      sp,\n                                      &msg)\n     };"}, {"sha": "b024574427e714498bcbcf3f19319b8d2d8dee91", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -85,7 +85,7 @@ pub use alloc_crate::alloc::*;\n /// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n /// plus related functions.\n ///\n-/// This type implements the `GlobalAlloc` trait and Rust programs by deafult\n+/// This type implements the `GlobalAlloc` trait and Rust programs by default\n /// work as if they had this definition:\n ///\n /// ```rust"}, {"sha": "9d6e8c4cafdcb22e69a74b3a4decf8c9ef0f19a4", "filename": "src/libstd/build.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -41,8 +41,11 @@ fn main() {\n     } else if target.contains(\"freebsd\") {\n         println!(\"cargo:rustc-link-lib=execinfo\");\n         println!(\"cargo:rustc-link-lib=pthread\");\n+    } else if target.contains(\"netbsd\") {\n+        println!(\"cargo:rustc-link-lib=pthread\");\n+        println!(\"cargo:rustc-link-lib=rt\");\n     } else if target.contains(\"dragonfly\") || target.contains(\"bitrig\") ||\n-              target.contains(\"netbsd\") || target.contains(\"openbsd\") {\n+              target.contains(\"openbsd\") {\n         println!(\"cargo:rustc-link-lib=pthread\");\n     } else if target.contains(\"solaris\") {\n         println!(\"cargo:rustc-link-lib=socket\");"}, {"sha": "bb2f152edc63d8190aa873bf10f573a8e41fa7b5", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1569,7 +1569,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// where the key should go, meaning the keys may become \"lost\" if their\n     /// location does not reflect their state. For instance, if you change a key\n     /// so that the map now contains keys which compare equal, search may start\n-    /// acting eratically, with two keys randomly masking eachother. Implementations\n+    /// acting erratically, with two keys randomly masking each other. Implementations\n     /// are free to assume this doesn't happen (within the limits of memory-safety).\n     #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<K, V, S> {"}, {"sha": "476ee3f71caf042045750dffc0fb7fecf55dc898", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -525,6 +525,25 @@ impl<W: Write> BufWriter<W> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n \n+    /// Returns a reference to the internally buffered data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// # #![feature(bufreader_buffer)]\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // See how many bytes are currently buffered\n+    /// let bytes_buffered = buf_writer.buffer().len();\n+    /// ```\n+    #[unstable(feature = \"bufreader_buffer\", issue = \"45323\")]\n+    pub fn buffer(&self) -> &[u8] {\n+        &self.buf\n+    }\n+\n     /// Unwraps this `BufWriter`, returning the underlying writer.\n     ///\n     /// The buffer is written out before returning the writer.\n@@ -965,31 +984,31 @@ mod tests {\n         let mut buf = [0, 0, 0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(nread.unwrap(), 3);\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf, b);\n+        assert_eq!(buf, [5, 6, 7]);\n+        assert_eq!(reader.buffer(), []);\n \n         let mut buf = [0, 0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(nread.unwrap(), 2);\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(buf, b);\n+        assert_eq!(buf, [0, 1]);\n+        assert_eq!(reader.buffer(), []);\n \n         let mut buf = [0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(nread.unwrap(), 1);\n-        let b: &[_] = &[2];\n-        assert_eq!(buf, b);\n+        assert_eq!(buf, [2]);\n+        assert_eq!(reader.buffer(), [3]);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(nread.unwrap(), 1);\n-        let b: &[_] = &[3, 0, 0];\n-        assert_eq!(buf, b);\n+        assert_eq!(buf, [3, 0, 0]);\n+        assert_eq!(reader.buffer(), []);\n \n         let nread = reader.read(&mut buf);\n         assert_eq!(nread.unwrap(), 1);\n-        let b: &[_] = &[4, 0, 0];\n-        assert_eq!(buf, b);\n+        assert_eq!(buf, [4, 0, 0]);\n+        assert_eq!(reader.buffer(), []);\n \n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n@@ -1078,31 +1097,40 @@ mod tests {\n         let mut writer = BufWriter::with_capacity(2, inner);\n \n         writer.write(&[0, 1]).unwrap();\n+        assert_eq!(writer.buffer(), []);\n         assert_eq!(*writer.get_ref(), [0, 1]);\n \n         writer.write(&[2]).unwrap();\n+        assert_eq!(writer.buffer(), [2]);\n         assert_eq!(*writer.get_ref(), [0, 1]);\n \n         writer.write(&[3]).unwrap();\n+        assert_eq!(writer.buffer(), [2, 3]);\n         assert_eq!(*writer.get_ref(), [0, 1]);\n \n         writer.flush().unwrap();\n+        assert_eq!(writer.buffer(), []);\n         assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n \n         writer.write(&[4]).unwrap();\n         writer.write(&[5]).unwrap();\n+        assert_eq!(writer.buffer(), [4, 5]);\n         assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n \n         writer.write(&[6]).unwrap();\n+        assert_eq!(writer.buffer(), [6]);\n         assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5]);\n \n         writer.write(&[7, 8]).unwrap();\n+        assert_eq!(writer.buffer(), []);\n         assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n \n         writer.write(&[9, 10, 11]).unwrap();\n+        assert_eq!(writer.buffer(), []);\n         assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n \n         writer.flush().unwrap();\n+        assert_eq!(writer.buffer(), []);\n         assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n     }\n "}, {"sha": "13cf3133dcd1246b8b940d4717faa5d79e8ca625", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -615,7 +615,7 @@ mod loop_keyword { }\n //\n /// The keyword used to define structs.\n ///\n-/// Structs in Rust come in three flavours: Structs with named fields, tuple structs, and unit\n+/// Structs in Rust come in three flavors: Structs with named fields, tuple structs, and unit\n /// structs.\n ///\n /// ```rust"}, {"sha": "8685cb73887054aac3ba2904fb24c8a9fc0bda52", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -852,7 +852,7 @@ impl From<[u8; 4]> for IpAddr {\n impl Ipv6Addr {\n     /// Creates a new IPv6 address from eight 16-bit segments.\n     ///\n-    /// The result will represent the IP address a:b:c:d:e:f:g:h.\n+    /// The result will represent the IP address `a:b:c:d:e:f:g:h`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "51481e129df8dd87449aa73b2c21f2e9771bee28", "filename": "src/libstd/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -1122,7 +1122,7 @@ impl From<fs::File> for Stdio {\n     /// let file = File::open(\"foo.txt\").unwrap();\n     ///\n     /// let reverse = Command::new(\"rev\")\n-    ///     .stdin(file)  // Implicit File convertion into a Stdio\n+    ///     .stdin(file)  // Implicit File conversion into a Stdio\n     ///     .output()\n     ///     .expect(\"failed reverse command\");\n     ///\n@@ -1340,7 +1340,7 @@ impl Child {\n     /// Attempts to collect the exit status of the child if it has already\n     /// exited.\n     ///\n-    /// This function will not block the calling thread and will only advisorily\n+    /// This function will not block the calling thread and will only\n     /// check to see if the child process has exited or not. If the child has\n     /// exited then on Unix the process id is reaped. This function is\n     /// guaranteed to repeatedly return a successful exit status so long as the"}, {"sha": "d62b09134bbf1fb20d8dea6cd24d9da7850b76d6", "filename": "src/libstd/sys/redox/fd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -26,7 +26,7 @@ impl FileDesc {\n \n     pub fn raw(&self) -> usize { self.fd }\n \n-    /// Extracts the actual filedescriptor without closing it.\n+    /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> usize {\n         let fd = self.fd;\n         mem::forget(self);"}, {"sha": "3543d8f8fa3312e6ac9b4a4e7bde64882c5a4ca1", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -77,6 +77,29 @@ pub fn cvt(result: Result<usize, syscall::Error>) -> io::Result<usize> {\n     result.map_err(|err| io::Error::from_raw_os_error(err.errno))\n }\n \n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+pub fn cvt_libc<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n /// On Redox, use an illegal instruction to abort\n pub unsafe fn abort_internal() -> ! {\n     ::core::intrinsics::abort();"}, {"sha": "84eb56615b60d8e99a8ea75f984cb253a5a5ab71", "filename": "src/libstd/sys/redox/os.rs", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -12,10 +12,12 @@\n \n #![allow(unused_imports)] // lots of cfg code here\n \n+use libc::{self, c_char};\n+\n use os::unix::prelude::*;\n \n use error::Error as StdError;\n-use ffi::{OsString, OsStr};\n+use ffi::{CStr, CString, OsStr, OsString};\n use fmt;\n use io::{self, Read, Write};\n use iter;\n@@ -27,7 +29,7 @@ use ptr;\n use slice;\n use str;\n use sys_common::mutex::Mutex;\n-use sys::{cvt, fd, syscall};\n+use sys::{cvt, cvt_libc, fd, syscall};\n use vec;\n \n extern {\n@@ -129,6 +131,8 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     Ok(PathBuf::from(path))\n }\n \n+pub static ENV_LOCK: Mutex = Mutex::new();\n+\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n@@ -140,52 +144,83 @@ impl Iterator for Env {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n+pub unsafe fn environ() -> *mut *const *const c_char {\n+    extern { static mut environ: *const *const c_char; }\n+    &mut environ\n+}\n+\n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n-    let mut variables: Vec<(OsString, OsString)> = Vec::new();\n-    if let Ok(mut file) = ::fs::File::open(\"env:\") {\n-        let mut string = String::new();\n-        if file.read_to_string(&mut string).is_ok() {\n-            for line in string.lines() {\n-                let mut parts = line.splitn(2, '=');\n-                if let Some(name) = parts.next() {\n-                    let value = parts.next().unwrap_or(\"\");\n-                    variables.push((OsString::from(name.to_string()),\n-                                    OsString::from(value.to_string())));\n-                }\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        let mut environ = *environ();\n+        if environ == ptr::null() {\n+            panic!(\"os::env() failure getting env string from OS: {}\",\n+                   io::Error::last_os_error());\n+        }\n+        let mut result = Vec::new();\n+        while *environ != ptr::null() {\n+            if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n+                result.push(key_value);\n             }\n+            environ = environ.offset(1);\n+        }\n+        return Env {\n+            iter: result.into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+\n+    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n+        // Strategy (copied from glibc): Variable name and value are separated\n+        // by an ASCII equals sign '='. Since a variable name must not be\n+        // empty, allow variable names starting with an equals sign. Skip all\n+        // malformed lines.\n+        if input.is_empty() {\n+            return None;\n         }\n+        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n+        pos.map(|p| (\n+            OsStringExt::from_vec(input[..p].to_vec()),\n+            OsStringExt::from_vec(input[p+1..].to_vec()),\n+        ))\n     }\n-    Env { iter: variables.into_iter(), _dont_send_or_sync_me: PhantomData }\n }\n \n-pub fn getenv(key: &OsStr) -> io::Result<Option<OsString>> {\n-    if ! key.is_empty() {\n-        if let Ok(mut file) = ::fs::File::open(&(\"env:\".to_owned() + key.to_str().unwrap())) {\n-            let mut string = String::new();\n-            file.read_to_string(&mut string)?;\n-            Ok(Some(OsString::from(string)))\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    // environment variables with a nul byte can't be set, so their value is\n+    // always None as well\n+    let k = CString::new(k.as_bytes())?;\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n+        let ret = if s.is_null() {\n+            None\n         } else {\n-            Ok(None)\n-        }\n-    } else {\n-        Ok(None)\n+            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n+        };\n+        Ok(ret)\n     }\n }\n \n-pub fn setenv(key: &OsStr, value: &OsStr) -> io::Result<()> {\n-    if ! key.is_empty() {\n-        let mut file = ::fs::File::create(&(\"env:\".to_owned() + key.to_str().unwrap()))?;\n-        file.write_all(value.as_bytes())?;\n-        file.set_len(value.len() as u64)?;\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    let k = CString::new(k.as_bytes())?;\n+    let v = CString::new(v.as_bytes())?;\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        cvt_libc(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ())\n     }\n-    Ok(())\n }\n \n-pub fn unsetenv(key: &OsStr) -> io::Result<()> {\n-    ::fs::remove_file(&(\"env:\".to_owned() + key.to_str().unwrap()))?;\n-    Ok(())\n+pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n+    let nbuf = CString::new(n.as_bytes())?;\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        cvt_libc(libc::unsetenv(nbuf.as_ptr())).map(|_| ())\n+    }\n }\n \n pub fn page_size() -> usize {"}, {"sha": "4370c1e05027bd5552cbe1768b19567631d125c7", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -9,15 +9,19 @@\n // except according to those terms.\n \n use env::{split_paths};\n-use ffi::OsStr;\n-use os::unix::ffi::OsStrExt;\n+use ffi::{CStr, OsStr};\n use fmt;\n-use io::{self, Error, ErrorKind};\n-use iter;\n+use fs::File;\n+use io::{self, prelude::*, BufReader, Error, ErrorKind, SeekFrom};\n use libc::{EXIT_SUCCESS, EXIT_FAILURE};\n+use os::unix::ffi::OsStrExt;\n use path::{Path, PathBuf};\n+use ptr;\n+use sys::ext::fs::MetadataExt;\n+use sys::ext::io::AsRawFd;\n use sys::fd::FileDesc;\n-use sys::fs::{File, OpenOptions};\n+use sys::fs::{File as SysFile, OpenOptions};\n+use sys::os::{ENV_LOCK, environ};\n use sys::pipe::{self, AnonPipe};\n use sys::{cvt, syscall};\n use sys_common::process::{CommandEnv, DefaultEnvKey};\n@@ -297,12 +301,6 @@ impl Command {\n             t!(callback());\n         }\n \n-        let args: Vec<[usize; 2]> = iter::once(\n-            [self.program.as_ptr() as usize, self.program.len()]\n-        ).chain(\n-            self.args.iter().map(|arg| [arg.as_ptr() as usize, arg.len()])\n-        ).collect();\n-\n         self.env.apply();\n \n         let program = if self.program.contains(':') || self.program.contains('/') {\n@@ -321,14 +319,93 @@ impl Command {\n             None\n         };\n \n-        if let Some(program) = program {\n-            if let Err(err) = syscall::execve(program.as_os_str().as_bytes(), &args) {\n-                io::Error::from_raw_os_error(err.errno as i32)\n+        let mut file = if let Some(program) = program {\n+            t!(File::open(program.as_os_str()))\n+        } else {\n+            return io::Error::from_raw_os_error(syscall::ENOENT);\n+        };\n+\n+        // Push all the arguments\n+        let mut args: Vec<[usize; 2]> = Vec::with_capacity(1 + self.args.len());\n+\n+        let interpreter = {\n+            let mut reader = BufReader::new(&file);\n+\n+            let mut shebang = [0; 2];\n+            let mut read = 0;\n+            loop {\n+                match t!(reader.read(&mut shebang[read..])) {\n+                    0 => break,\n+                    n => read += n,\n+                }\n+            }\n+\n+            if &shebang == b\"#!\" {\n+                // This is an interpreted script.\n+                // First of all, since we'll be passing another file to\n+                // fexec(), we need to manually check that we have permission\n+                // to execute this file:\n+                let uid = t!(cvt(syscall::getuid()));\n+                let gid = t!(cvt(syscall::getgid()));\n+                let meta = t!(file.metadata());\n+\n+                let mode = if uid == meta.uid() as usize {\n+                    meta.mode() >> 3*2 & 0o7\n+                } else if gid == meta.gid() as usize {\n+                    meta.mode() >> 3*1 & 0o7\n+                } else {\n+                    meta.mode() & 0o7\n+                };\n+                if mode & 1 == 0 {\n+                    return io::Error::from_raw_os_error(syscall::EPERM);\n+                }\n+\n+                // Second of all, we need to actually read which interpreter it wants\n+                let mut interpreter = Vec::new();\n+                t!(reader.read_until(b'\\n', &mut interpreter));\n+                // Pop one trailing newline, if any\n+                if interpreter.ends_with(&[b'\\n']) {\n+                    interpreter.pop().unwrap();\n+                }\n+\n+                // FIXME: Here we could just reassign `file` directly, if it\n+                // wasn't for lexical lifetimes. Remove the whole `let\n+                // interpreter = { ... };` hack once NLL lands.\n+                // NOTE: Although DO REMEMBER to make sure the interpreter path\n+                // still lives long enough to reach fexec.\n+                Some(interpreter)\n             } else {\n-                panic!(\"return from exec without err\");\n+                None\n+            }\n+        };\n+        if let Some(ref interpreter) = interpreter {\n+            let path: &OsStr = OsStr::from_bytes(&interpreter);\n+            file = t!(File::open(path));\n+\n+            args.push([interpreter.as_ptr() as usize, interpreter.len()]);\n+        } else {\n+            t!(file.seek(SeekFrom::Start(0)));\n+        }\n+\n+        args.push([self.program.as_ptr() as usize, self.program.len()]);\n+        args.extend(self.args.iter().map(|arg| [arg.as_ptr() as usize, arg.len()]));\n+\n+        // Push all the variables\n+        let mut vars: Vec<[usize; 2]> = Vec::new();\n+        {\n+            let _guard = ENV_LOCK.lock();\n+            let mut environ = *environ();\n+            while *environ != ptr::null() {\n+                let var = CStr::from_ptr(*environ).to_bytes();\n+                vars.push([var.as_ptr() as usize, var.len()]);\n+                environ = environ.offset(1);\n             }\n+        }\n+\n+        if let Err(err) = syscall::fexec(file.as_raw_fd(), &args, &vars) {\n+            io::Error::from_raw_os_error(err.errno as i32)\n         } else {\n-            io::Error::from_raw_os_error(syscall::ENOENT)\n+            panic!(\"return from exec without err\");\n         }\n     }\n \n@@ -392,7 +469,7 @@ impl Stdio {\n                 let mut opts = OpenOptions::new();\n                 opts.read(readable);\n                 opts.write(!readable);\n-                let fd = File::open(Path::new(\"null:\"), &opts)?;\n+                let fd = SysFile::open(Path::new(\"null:\"), &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n         }\n@@ -405,8 +482,8 @@ impl From<AnonPipe> for Stdio {\n     }\n }\n \n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n+impl From<SysFile> for Stdio {\n+    fn from(file: SysFile) -> Stdio {\n         Stdio::Fd(file.into_fd())\n     }\n }"}, {"sha": "577dde4b4beef5ca69b9916c702a9b5764120422", "filename": "src/libstd/sys/redox/syscall/call.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -45,7 +45,7 @@ pub unsafe fn brk(addr: usize) -> Result<usize> {\n /// # Errors\n ///\n /// * `EACCES` - permission is denied for one of the components of `path`, or `path`\n-/// * `EFAULT` - `path` does not point to the process's addressible memory\n+/// * `EFAULT` - `path` does not point to the process's addressable memory\n /// * `EIO` - an I/O error occurred\n /// * `ENOENT` - `path` does not exit\n /// * `ENOTDIR` - `path` is not a directory\n@@ -82,12 +82,6 @@ pub fn dup2(fd: usize, newfd: usize, buf: &[u8]) -> Result<usize> {\n     unsafe { syscall4(SYS_DUP2, fd, newfd, buf.as_ptr() as usize, buf.len()) }\n }\n \n-/// Replace the current process with a new executable\n-pub fn execve<T: AsRef<[u8]>>(path: T, args: &[[usize; 2]]) -> Result<usize> {\n-    unsafe { syscall4(SYS_EXECVE, path.as_ref().as_ptr() as usize,\n-                      path.as_ref().len(), args.as_ptr() as usize, args.len()) }\n-}\n-\n /// Exit the current process\n pub fn exit(status: usize) -> Result<usize> {\n     unsafe { syscall1(SYS_EXIT, status) }\n@@ -110,9 +104,10 @@ pub fn fcntl(fd: usize, cmd: usize, arg: usize) -> Result<usize> {\n     unsafe { syscall3(SYS_FCNTL, fd, cmd, arg) }\n }\n \n-/// Register a file for event-based I/O\n-pub fn fevent(fd: usize, flags: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_FEVENT, fd, flags) }\n+/// Replace the current process with a new executable\n+pub fn fexec(fd: usize, args: &[[usize; 2]], vars: &[[usize; 2]]) -> Result<usize> {\n+    unsafe { syscall5(SYS_FEXEC, fd, args.as_ptr() as usize, args.len(),\n+                      vars.as_ptr() as usize, vars.len()) }\n }\n \n /// Map a file into memory\n@@ -347,7 +342,7 @@ pub fn waitpid(pid: usize, status: &mut usize, options: usize) -> Result<usize>\n ///\n /// * `EAGAIN` - the file descriptor was opened with `O_NONBLOCK` and writing would block\n /// * `EBADF` - the file descriptor is not valid or is not open for writing\n-/// * `EFAULT` - `buf` does not point to the process's addressible memory\n+/// * `EFAULT` - `buf` does not point to the process's addressable memory\n /// * `EIO` - an I/O error occurred\n /// * `ENOSPC` - the device containing the file descriptor has no room for data\n /// * `EPIPE` - the file descriptor refers to a pipe or socket whose reading end is closed"}, {"sha": "0f1a2c2315973b8e21e49808b9376f5c5aff02df", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -113,4 +113,46 @@ pub const SA_RESTART: usize =   0x10000000;\n pub const SA_NODEFER: usize =   0x40000000;\n pub const SA_RESETHAND: usize = 0x80000000;\n \n-pub const WNOHANG: usize = 1;\n+pub const WNOHANG: usize =    0x01;\n+pub const WUNTRACED: usize =  0x02;\n+pub const WCONTINUED: usize = 0x08;\n+\n+/// True if status indicates the child is stopped.\n+pub fn wifstopped(status: usize) -> bool {\n+    (status & 0xff) == 0x7f\n+}\n+\n+/// If wifstopped(status), the signal that stopped the child.\n+pub fn wstopsig(status: usize) -> usize {\n+    (status >> 8) & 0xff\n+}\n+\n+/// True if status indicates the child continued after a stop.\n+pub fn wifcontinued(status: usize) -> bool {\n+    status == 0xffff\n+}\n+\n+/// True if STATUS indicates termination by a signal.\n+pub fn wifsignaled(status: usize) -> bool {\n+    ((status & 0x7f) + 1) as i8 >= 2\n+}\n+\n+/// If wifsignaled(status), the terminating signal.\n+pub fn wtermsig(status: usize) -> usize {\n+    status & 0x7f\n+}\n+\n+/// True if status indicates normal termination.\n+pub fn wifexited(status: usize) -> bool {\n+    wtermsig(status) == 0\n+}\n+\n+/// If wifexited(status), the exit status.\n+pub fn wexitstatus(status: usize) -> usize {\n+    (status >> 8) & 0xff\n+}\n+\n+/// True if status indicates a core dump was created.\n+pub fn wcoredump(status: usize) -> bool {\n+    (status & 0x80) != 0\n+}"}, {"sha": "1e187565a675c9548c286a07971e4e2254b2c36f", "filename": "src/libstd/sys/redox/syscall/number.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -36,6 +36,7 @@ pub const SYS_FCHMOD: usize =   SYS_CLASS_FILE | 94;\n pub const SYS_FCHOWN: usize =   SYS_CLASS_FILE | 207;\n pub const SYS_FCNTL: usize =    SYS_CLASS_FILE | 55;\n pub const SYS_FEVENT: usize =   SYS_CLASS_FILE | 927;\n+pub const SYS_FEXEC: usize =    SYS_CLASS_FILE | 11;\n pub const SYS_FMAP: usize =     SYS_CLASS_FILE | 90;\n pub const SYS_FUNMAP: usize =   SYS_CLASS_FILE | 91;\n pub const SYS_FPATH: usize =    SYS_CLASS_FILE | SYS_ARG_MSLICE | 928;\n@@ -50,7 +51,6 @@ pub const SYS_BRK: usize =      45;\n pub const SYS_CHDIR: usize =    12;\n pub const SYS_CLOCK_GETTIME: usize = 265;\n pub const SYS_CLONE: usize =    120;\n-pub const SYS_EXECVE: usize =   11;\n pub const SYS_EXIT: usize =     1;\n pub const SYS_FUTEX: usize =    240;\n pub const SYS_GETCWD: usize =   183;"}, {"sha": "5a81d6dfb672e6950ead6d4d5417e839b7ba740e", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -46,7 +46,7 @@ impl FileDesc {\n \n     pub fn raw(&self) -> c_int { self.fd }\n \n-    /// Extracts the actual filedescriptor without closing it.\n+    /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> c_int {\n         let fd = self.fd;\n         mem::forget(self);"}, {"sha": "fcd6f7a27b6e3ff6b917981cb2b99e6998bb9d2c", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -14,7 +14,7 @@ use sync::atomic::{AtomicUsize, Ordering};\n \n pub struct RWLock {\n     inner: UnsafeCell<libc::pthread_rwlock_t>,\n-    write_locked: UnsafeCell<bool>,\n+    write_locked: UnsafeCell<bool>, // guarded by the `inner` RwLock\n     num_readers: AtomicUsize,\n }\n \n@@ -52,13 +52,13 @@ impl RWLock {\n         // allow that because it could lead to aliasing issues.\n         if r == libc::EAGAIN {\n             panic!(\"rwlock maximum reader count exceeded\");\n-        } else if r == libc::EDEADLK || *self.write_locked.get() {\n+        } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n             if r == 0 {\n                 self.raw_unlock();\n             }\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n-            debug_assert_eq!(r, 0);\n+            assert_eq!(r, 0);\n             self.num_readers.fetch_add(1, Ordering::Relaxed);\n         }\n     }"}, {"sha": "8a845efd41362ec66da7bb0210889b03bd1f672c", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -233,7 +233,7 @@ pub use self::local::{LocalKey, AccessError};\n ///\n /// You may want to use [`spawn`] instead of [`thread::spawn`], when you want\n /// to recover from a failure to launch a thread, indeed the free function will\n-/// panick where the `Builder` method will return a [`io::Result`].\n+/// panic where the `Builder` method will return a [`io::Result`].\n ///\n /// # Examples\n ///"}, {"sha": "227017a9073fec63be9c5cba4f7d140c866113c6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -18,7 +18,6 @@ pub use util::parser::ExprPrecedence;\n use ext::hygiene::{Mark, SyntaxContext};\n use print::pprust;\n use ptr::P;\n-use rustc_data_structures::indexed_vec;\n use rustc_data_structures::indexed_vec::Idx;\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert;\n@@ -33,7 +32,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use serialize::{self, Decoder, Encoder};\n use std::fmt;\n-use std::u32;\n \n pub use rustc_target::abi::FloatTy;\n \n@@ -215,71 +213,54 @@ pub struct ParenthesisedArgs {\n     pub output: Option<P<Ty>>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-pub struct NodeId(u32);\n-\n-impl NodeId {\n-    pub fn new(x: usize) -> NodeId {\n-        assert!(x < (u32::MAX as usize));\n-        NodeId(x as u32)\n-    }\n-\n-    pub fn from_u32(x: u32) -> NodeId {\n-        NodeId(x)\n-    }\n-\n-    pub fn as_usize(&self) -> usize {\n-        self.0 as usize\n+// hack to ensure that we don't try to access the private parts of `NodeId` in this module\n+mod node_id_inner {\n+    use rustc_data_structures::indexed_vec::Idx;\n+    newtype_index! {\n+        pub struct NodeId {\n+            ENCODABLE = custom\n+            DEBUG_FORMAT = \"NodeId({})\"\n+        }\n     }\n+}\n \n-    pub fn as_u32(&self) -> u32 {\n-        self.0\n-    }\n+pub use self::node_id_inner::NodeId;\n \n+impl NodeId {\n     pub fn placeholder_from_mark(mark: Mark) -> Self {\n-        NodeId(mark.as_u32())\n+        NodeId::from_u32(mark.as_u32())\n     }\n \n     pub fn placeholder_to_mark(self) -> Mark {\n-        Mark::from_u32(self.0)\n+        Mark::from_u32(self.as_u32())\n     }\n }\n \n impl fmt::Display for NodeId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.0, f)\n+        fmt::Display::fmt(&self.as_u32(), f)\n     }\n }\n \n impl serialize::UseSpecializedEncodable for NodeId {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u32(self.0)\n+        s.emit_u32(self.as_u32())\n     }\n }\n \n impl serialize::UseSpecializedDecodable for NodeId {\n     fn default_decode<D: Decoder>(d: &mut D) -> Result<NodeId, D::Error> {\n-        d.read_u32().map(NodeId)\n-    }\n-}\n-\n-impl indexed_vec::Idx for NodeId {\n-    fn new(idx: usize) -> Self {\n-        NodeId::new(idx)\n-    }\n-\n-    fn index(self) -> usize {\n-        self.as_usize()\n+        d.read_u32().map(NodeId::from_u32)\n     }\n }\n \n /// Node id used to represent the root of the crate.\n-pub const CRATE_NODE_ID: NodeId = NodeId(0);\n+pub const CRATE_NODE_ID: NodeId = NodeId::from_u32_const(0);\n \n /// When parsing and doing expansions, we initially give all AST nodes this AST\n /// node value. Then later, in the renumber pass, we renumber them to have\n /// small, positive ids.\n-pub const DUMMY_NODE_ID: NodeId = NodeId(!0);\n+pub const DUMMY_NODE_ID: NodeId = NodeId::MAX;\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here."}, {"sha": "9bbd59e09be158710092ccd5d7ad8a7b36ba60f7", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -26,6 +26,7 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(str_escape)]\n+#![feature(step_trait)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]\n \n@@ -37,7 +38,7 @@ extern crate serialize;\n #[macro_use] extern crate log;\n pub extern crate rustc_errors as errors;\n extern crate syntax_pos;\n-extern crate rustc_data_structures;\n+#[macro_use] extern crate rustc_data_structures;\n extern crate rustc_target;\n #[macro_use] extern crate scoped_tls;\n #[macro_use]"}, {"sha": "cfdd4340a19fe7712de1ada27fa5f1ff9d910679", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -150,7 +150,7 @@ impl TokenTree {\n         }\n     }\n \n-    /// Modify the `TokenTree`'s span inplace.\n+    /// Modify the `TokenTree`'s span in-place.\n     pub fn set_span(&mut self, span: Span) {\n         match *self {\n             TokenTree::Token(ref mut sp, _) => *sp = span,"}, {"sha": "2f6b306e8f8baa2447dc602e74fbe4336a252e60", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -68,7 +68,7 @@\n //! The `i32`s in `B` and `C0` don't have an identifier, so the\n //! `Option<ident>`s would be `None` for them.\n //!\n-//! In the static cases, the structure is summarised, either into the just\n+//! In the static cases, the structure is summarized, either into the just\n //! spans of the fields or a list of spans and the field idents (for tuple\n //! structs and record structs, respectively), or a list of these, for\n //! enums (one for each variant). For empty struct and empty enum"}, {"sha": "2c5de33232754cf3f97c1f66ee791a0d9e7ce7b4", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -43,7 +43,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n                                     &[],\n                                     Edition::Edition2015,\n                                     // not used...\n-                                    NodeId::new(0));\n+                                    NodeId::from_u32(0));\n     let map = match TokenTree::parse(cx, &mbe_matcher, args.iter().cloned().collect()) {\n         Success(map) => map,\n         Failure(_, tok) => {"}, {"sha": "b980290391d3a4ef362332639e19b11fd948a488", "filename": "src/test/ui/issues/issue-54348.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fissues%2Fissue-54348.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fissues%2Fissue-54348.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54348.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    [1][0u64 as usize];\n+    [1][1.5 as usize]; // ERROR index out of bounds\n+    [1][1u64 as usize]; // ERROR index out of bounds\n+}"}, {"sha": "a9f1b4942584d4ec45a44e4f7da6f9bd38454ce2", "filename": "src/test/ui/issues/issue-54348.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fissues%2Fissue-54348.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fissues%2Fissue-54348.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54348.stderr?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,16 @@\n+error: index out of bounds: the len is 1 but the index is 1\n+  --> $DIR/issue-54348.rs:3:5\n+   |\n+LL |     [1][1.5 as usize]; // ERROR index out of bounds\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: index out of bounds: the len is 1 but the index is 1\n+  --> $DIR/issue-54348.rs:4:5\n+   |\n+LL |     [1][1u64 as usize]; // ERROR index out of bounds\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "8b78749f6529a292213ac018dc230fea47f4569e", "filename": "src/test/ui/issues/issue-55587.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fissues%2Fissue-55587.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fissues%2Fissue-55587.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55587.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,5 @@\n+use std::path::Path;\n+\n+fn main() {\n+    let Path::new(); //~ ERROR expected tuple struct/variant\n+}"}, {"sha": "876fb4391b1bc4a2c2a59b8a0d9f991917eef920", "filename": "src/test/ui/issues/issue-55587.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fissues%2Fissue-55587.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fissues%2Fissue-55587.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55587.stderr?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,9 @@\n+error[E0164]: expected tuple struct/variant, found method `<Path>::new`\n+  --> $DIR/issue-55587.rs:4:9\n+   |\n+LL |     let Path::new(); //~ ERROR expected tuple struct/variant\n+   |         ^^^^^^^^^^^ not a tuple variant or struct\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0164`."}, {"sha": "f0aee8a51f18b65e72547a25c31d0c1fb0e0076e", "filename": "src/test/ui/lint/inclusive-range-pattern-syntax.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.fixed?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -20,4 +20,10 @@ fn main() {\n         //~^ WARN `...` range patterns are deprecated\n         _ => {}\n     }\n+\n+    match &despondency {\n+        &(1..=2) => {}\n+        //~^ WARN `...` range patterns are deprecated\n+        _ => {}\n+    }\n }"}, {"sha": "97bc04faa774b4da8c3932fe3d1262cc02ef8505", "filename": "src/test/ui/lint/inclusive-range-pattern-syntax.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -20,4 +20,10 @@ fn main() {\n         //~^ WARN `...` range patterns are deprecated\n         _ => {}\n     }\n+\n+    match &despondency {\n+        &1...2 => {}\n+        //~^ WARN `...` range patterns are deprecated\n+        _ => {}\n+    }\n }"}, {"sha": "b13afdbc023d46e6394a7f1e492c9bd77e20bf53", "filename": "src/test/ui/lint/inclusive-range-pattern-syntax.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finclusive-range-pattern-syntax.stderr?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -10,3 +10,9 @@ note: lint level defined here\n LL | #![warn(ellipsis_inclusive_range_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+warning: `...` range patterns are deprecated\n+  --> $DIR/inclusive-range-pattern-syntax.rs:25:9\n+   |\n+LL |         &1...2 => {}\n+   |         ^^^^^^ help: use `..=` for an inclusive range: `&(1..=2)`\n+"}, {"sha": "c308562c0cc76a87e8543bd45af0b84a9c215711", "filename": "src/test/ui/nll/issue-54382-use-span-of-tail-of-block.nll.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.nll.stderr?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,20 @@\n+error[E0597]: `_thing1` does not live long enough\n+  --> $DIR/issue-54382-use-span-of-tail-of-block.rs:7:29\n+   |\n+LL |             D(\"other\").next(&_thing1)\n+   |             ----------------^^^^^^^^-\n+   |             |               |\n+   |             |               borrowed value does not live long enough\n+   |             a temporary with access to the borrow is created here ...\n+LL |         }\n+LL |     }\n+   |     - `_thing1` dropped here while still borrowed\n+LL | \n+LL |     ;\n+   |     - ... and the borrow might be used here, when that temporary is dropped and runs the `Drop` code for type `D`\n+   |\n+   = note: The temporary is part of an expression at the end of a block. Consider adding semicolon after the expression so its temporaries are dropped sooner, before the local variables declared by the block are dropped.\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "99eafe0e9d18f2832cf1ef815ffe648ffb88f42d", "filename": "src/test/ui/nll/issue-54382-use-span-of-tail-of-block.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.rs?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,28 @@\n+fn main() {\n+    {\n+        let mut _thing1 = D(Box::new(\"thing1\"));\n+        {\n+            let _thing2 = D(\"thing2\");\n+            side_effects();\n+            D(\"other\").next(&_thing1)\n+        }\n+    }\n+\n+    ;\n+}\n+\n+#[derive(Debug)]\n+struct D<T: std::fmt::Debug>(T);\n+\n+impl<T: std::fmt::Debug>  Drop for D<T> {\n+    fn drop(&mut self) {\n+        println!(\"dropping {:?})\", self);\n+    }\n+}\n+\n+impl<T: std::fmt::Debug> D<T> {\n+    fn next<U: std::fmt::Debug>(&self, _other: U) -> D<U> { D(_other) }\n+    fn end(&self) { }\n+}\n+\n+fn side_effects() { }"}, {"sha": "eeba7d6bb445fa8b68adfc52ffbd500f069ae7cb", "filename": "src/test/ui/nll/issue-54382-use-span-of-tail-of-block.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-54382-use-span-of-tail-of-block.stderr?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `_thing1` does not live long enough\n+  --> $DIR/issue-54382-use-span-of-tail-of-block.rs:7:30\n+   |\n+LL |             D(\"other\").next(&_thing1)\n+   |                              ^^^^^^^ borrowed value does not live long enough\n+LL |         }\n+LL |     }\n+   |     - `_thing1` dropped here while still borrowed\n+LL | \n+LL |     ;\n+   |     - borrowed value needs to live until here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "6fa67a5d4fa30c1295176e729670db0f49e60296", "filename": "src/test/ui/range/range-inclusive-pattern-precedence.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9649c1f70fddd01843024932df97fb5a2b10bfe8/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-inclusive-pattern-precedence.stderr?ref=9649c1f70fddd01843024932df97fb5a2b10bfe8", "patch": "@@ -11,10 +11,10 @@ LL |         box 10..=15 => {}\n    |             ^^^^^^^ help: add parentheses to clarify the precedence: `(10 ..=15)`\n \n warning: `...` range patterns are deprecated\n-  --> $DIR/range-inclusive-pattern-precedence.rs:24:11\n+  --> $DIR/range-inclusive-pattern-precedence.rs:24:9\n    |\n LL |         &0...9 => {}\n-   |           ^^^ help: use `..=` for an inclusive range\n+   |         ^^^^^^ help: use `..=` for an inclusive range: `&(0..=9)`\n    |\n note: lint level defined here\n   --> $DIR/range-inclusive-pattern-precedence.rs:19:9"}]}