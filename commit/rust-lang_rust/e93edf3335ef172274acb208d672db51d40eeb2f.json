{"sha": "e93edf3335ef172274acb208d672db51d40eeb2f", "node_id": "C_kwDOAAsO6NoAKGU5M2VkZjMzMzVlZjE3MjI3NGFjYjIwOGQ2NzJkYjUxZDQwZWViMmY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-20T17:45:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-20T17:45:11Z"}, "message": "Rollup merge of #100129 - RalfJung:miri-test-libstd, r=thomcc\n\nadd miri-test-libstd support to libstd\n\n- The first commit mirrors what we already have in liballoc.\n- The second commit adds some regression tests that only really make sense to be run in Miri, since they rely on Miri's extra checks to detect anything.\n- The third commit makes the MPSC tests work in reasonable time in Miri by reducing iteration counts.\n- The fourth commit silences some warnings due to code being disabled with `cfg(miri)`", "tree": {"sha": "b7c7cff9421c7a75c92d32e3bfaa1bb0b27eb8c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7c7cff9421c7a75c92d32e3bfaa1bb0b27eb8c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e93edf3335ef172274acb208d672db51d40eeb2f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjAR2nCRBK7hj4Ov3rIwAAuFoIAKBN4u14JRDrfyp5swr/O8vh\n19zDymoZasd3Lqo+egrxgwrY014N2JJQPu3Me4FakLa5+KvouibiWla1TqO4yinC\nONRCGfT/K0wleKa7yokkKMohJVEdbR8rcnGJkTVQaTFyXikZisGZfBh/sBs2TyID\nKom12dKcpPbk6bTCAcRvxkcf/iGxMQM9aQpFSey0ZWKaGhFI44NaUM5v/u+el9EL\nZvfs4237kqyz5dlSLkgz/1Cs30GVag/7PFG7FPVowj64CnjtrWGmXJfk8lhLsowM\nyBZH7XW1L3DfrxZjVFmKHmM7ga6EsLcrL8YrQzaELNPbYtMtaJdc8+7Qmc+qDHs=\n=vEqY\n-----END PGP SIGNATURE-----\n", "payload": "tree b7c7cff9421c7a75c92d32e3bfaa1bb0b27eb8c1\nparent 8828af4d88f69a3fce63e7ea6420f3363127802c\nparent fbcdf2a383f6b17f80d8c285af3fa9739aaf223c\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661017511 +0200\ncommitter GitHub <noreply@github.com> 1661017511 +0200\n\nRollup merge of #100129 - RalfJung:miri-test-libstd, r=thomcc\n\nadd miri-test-libstd support to libstd\n\n- The first commit mirrors what we already have in liballoc.\n- The second commit adds some regression tests that only really make sense to be run in Miri, since they rely on Miri's extra checks to detect anything.\n- The third commit makes the MPSC tests work in reasonable time in Miri by reducing iteration counts.\n- The fourth commit silences some warnings due to code being disabled with `cfg(miri)`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e93edf3335ef172274acb208d672db51d40eeb2f", "html_url": "https://github.com/rust-lang/rust/commit/e93edf3335ef172274acb208d672db51d40eeb2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e93edf3335ef172274acb208d672db51d40eeb2f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8828af4d88f69a3fce63e7ea6420f3363127802c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8828af4d88f69a3fce63e7ea6420f3363127802c", "html_url": "https://github.com/rust-lang/rust/commit/8828af4d88f69a3fce63e7ea6420f3363127802c"}, {"sha": "fbcdf2a383f6b17f80d8c285af3fa9739aaf223c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbcdf2a383f6b17f80d8c285af3fa9739aaf223c", "html_url": "https://github.com/rust-lang/rust/commit/fbcdf2a383f6b17f80d8c285af3fa9739aaf223c"}], "stats": {"total": 142, "additions": 105, "deletions": 37}, "files": [{"sha": "aea84ac90c1bcce92275e1b0b8a9d717ed8ed579", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -56,10 +56,6 @@\n //! [`Rc`]: rc\n //! [`RefCell`]: core::cell\n \n-// To run liballoc tests without x.py without ending up with two copies of liballoc, Miri needs to be\n-// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n-// rustc itself never sets the feature, so this line has no affect there.\n-#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n #![allow(unused_attributes)]\n #![stable(feature = \"alloc\", since = \"1.36.0\")]\n #![doc(\n@@ -77,6 +73,10 @@\n ))]\n #![no_std]\n #![needs_allocator]\n+// To run liballoc tests without x.py without ending up with two copies of liballoc, Miri needs to be\n+// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n+// rustc itself never sets the feature, so this line has no affect there.\n+#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n //\n // Lints:\n #![deny(unsafe_op_in_unsafe_fn)]"}, {"sha": "0fae8953aa2c771532d10f90c79b795eb2ef1450", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -618,3 +618,22 @@ fn test_arc_cyclic_two_refs() {\n     assert_eq!(Arc::strong_count(&two_refs), 3);\n     assert_eq!(Arc::weak_count(&two_refs), 2);\n }\n+\n+/// Test for Arc::drop bug (https://github.com/rust-lang/rust/issues/55005)\n+#[test]\n+#[cfg(miri)] // relies on Stacked Borrows in Miri\n+fn arc_drop_dereferenceable_race() {\n+    // The bug seems to take up to 700 iterations to reproduce with most seeds (tested 0-9).\n+    for _ in 0..750 {\n+        let arc_1 = Arc::new(());\n+        let arc_2 = arc_1.clone();\n+        let thread = thread::spawn(|| drop(arc_2));\n+        // Spin a bit; makes the race more likely to appear\n+        let mut i = 0;\n+        while i < 256 {\n+            i += 1;\n+        }\n+        drop(arc_1);\n+        thread.join().unwrap();\n+    }\n+}"}, {"sha": "cb3032719fa64287bd56c757513bb8a0b0f64922", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -268,53 +268,56 @@ fn test_lots_of_insertions() {\n \n     // Try this a few times to make sure we never screw up the hashmap's\n     // internal state.\n-    for _ in 0..10 {\n+    let loops = if cfg!(miri) { 2 } else { 10 };\n+    for _ in 0..loops {\n         assert!(m.is_empty());\n \n-        for i in 1..1001 {\n+        let count = if cfg!(miri) { 101 } else { 1001 };\n+\n+        for i in 1..count {\n             assert!(m.insert(i, i).is_none());\n \n             for j in 1..=i {\n                 let r = m.get(&j);\n                 assert_eq!(r, Some(&j));\n             }\n \n-            for j in i + 1..1001 {\n+            for j in i + 1..count {\n                 let r = m.get(&j);\n                 assert_eq!(r, None);\n             }\n         }\n \n-        for i in 1001..2001 {\n+        for i in count..(2 * count) {\n             assert!(!m.contains_key(&i));\n         }\n \n         // remove forwards\n-        for i in 1..1001 {\n+        for i in 1..count {\n             assert!(m.remove(&i).is_some());\n \n             for j in 1..=i {\n                 assert!(!m.contains_key(&j));\n             }\n \n-            for j in i + 1..1001 {\n+            for j in i + 1..count {\n                 assert!(m.contains_key(&j));\n             }\n         }\n \n-        for i in 1..1001 {\n+        for i in 1..count {\n             assert!(!m.contains_key(&i));\n         }\n \n-        for i in 1..1001 {\n+        for i in 1..count {\n             assert!(m.insert(i, i).is_none());\n         }\n \n         // remove backwards\n-        for i in (1..1001).rev() {\n+        for i in (1..count).rev() {\n             assert!(m.remove(&i).is_some());\n \n-            for j in i..1001 {\n+            for j in i..count {\n                 assert!(!m.contains_key(&j));\n             }\n \n@@ -817,6 +820,7 @@ fn test_retain() {\n }\n \n #[test]\n+#[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n #[cfg_attr(target_os = \"android\", ignore)] // Android used in CI has a broken dlmalloc\n fn test_try_reserve() {\n     let mut empty_bytes: HashMap<u8, u8> = HashMap::new();"}, {"sha": "68a19eccc0e7c275073bebce3c84e0549317e7fd", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -94,7 +94,7 @@ fn read_to_end() {\n     assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n     assert_eq!(v, b\"1\");\n \n-    let cap = 1024 * 1024;\n+    let cap = if cfg!(miri) { 1024 } else { 1024 * 1024 };\n     let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n     let mut v = Vec::new();\n     let (a, b) = data.split_at(data.len() / 2);\n@@ -309,6 +309,7 @@ fn chain_zero_length_read_is_not_eof() {\n \n #[bench]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_read_to_end(b: &mut test::Bencher) {\n     b.iter(|| {\n         let mut lr = repeat(1).take(10000000);"}, {"sha": "ead06f40d87c4944b48935395de6cdc6e9aa8af1", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -187,6 +187,7 @@\n //! [rust-discord]: https://discord.gg/rust-lang\n //! [array]: prim@array\n //! [slice]: prim@slice\n+\n #![cfg_attr(not(feature = \"restricted-std\"), stable(feature = \"rust1\", since = \"1.0.0\"))]\n #![cfg_attr(feature = \"restricted-std\", unstable(feature = \"restricted_std\", issue = \"none\"))]\n #![doc(\n@@ -201,25 +202,35 @@\n     no_global_oom_handling,\n     not(no_global_oom_handling)\n ))]\n+// To run libstd tests without x.py without ending up with two copies of libstd, Miri needs to be\n+// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n+// rustc itself never sets the feature, so this line has no affect there.\n+#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n+// miri-test-libstd also prefers to make std use the sysroot versions of the dependencies.\n+#![cfg_attr(feature = \"miri-test-libstd\", feature(rustc_private))]\n // Don't link to std. We are std.\n #![no_std]\n+// Tell the compiler to link to either panic_abort or panic_unwind\n+#![needs_panic_runtime]\n+//\n+// Lints:\n #![warn(deprecated_in_future)]\n #![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n #![allow(explicit_outlives_requirements)]\n #![allow(unused_lifetimes)]\n-// Tell the compiler to link to either panic_abort or panic_unwind\n-#![needs_panic_runtime]\n+#![deny(rustc::existing_doc_keyword)]\n // Ensure that std can be linked against panic_abort despite compiled with `-C panic=unwind`\n #![deny(ffi_unwind_calls)]\n // std may use features in a platform-specific way\n #![allow(unused_features)]\n+//\n+// Features:\n #![cfg_attr(test, feature(internal_output_capture, print_internals, update_panic_count, rt))]\n #![cfg_attr(\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n )]\n-#![deny(rustc::existing_doc_keyword)]\n //\n // Language features:\n #![feature(alloc_error_handler)]"}, {"sha": "dd307022c6d05ce5c55e81c84c642eb6056c8e54", "filename": "library/std/src/path/tests.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -1768,6 +1768,7 @@ fn test_windows_absolute() {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_cmp_fast_path_buf_sort(b: &mut test::Bencher) {\n     let prefix = \"my/home\";\n     let mut paths: Vec<_> =\n@@ -1781,6 +1782,7 @@ fn bench_path_cmp_fast_path_buf_sort(b: &mut test::Bencher) {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_cmp_fast_path_long(b: &mut test::Bencher) {\n     let prefix = \"/my/home/is/my/castle/and/my/castle/has/a/rusty/workbench/\";\n     let paths: Vec<_> =\n@@ -1799,6 +1801,7 @@ fn bench_path_cmp_fast_path_long(b: &mut test::Bencher) {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_cmp_fast_path_short(b: &mut test::Bencher) {\n     let prefix = \"my/home\";\n     let paths: Vec<_> =\n@@ -1817,6 +1820,7 @@ fn bench_path_cmp_fast_path_short(b: &mut test::Bencher) {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_hashset(b: &mut test::Bencher) {\n     let prefix = \"/my/home/is/my/castle/and/my/castle/has/a/rusty/workbench/\";\n     let paths: Vec<_> =\n@@ -1835,6 +1839,7 @@ fn bench_path_hashset(b: &mut test::Bencher) {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_hashset_miss(b: &mut test::Bencher) {\n     let prefix = \"/my/home/is/my/castle/and/my/castle/has/a/rusty/workbench/\";\n     let paths: Vec<_> ="}, {"sha": "34b2a9a98ac36fa523fc4435fc12db5a8fe99f23", "filename": "library/std/src/sync/mpsc/mpsc_queue/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -13,7 +13,7 @@ fn test_full() {\n #[test]\n fn test() {\n     let nthreads = 8;\n-    let nmsgs = 1000;\n+    let nmsgs = if cfg!(miri) { 100 } else { 1000 };\n     let q = Queue::new();\n     match q.pop() {\n         Empty => {}"}, {"sha": "eb6d5c2cf66d8fc71a850d05646c1706916dfbbc", "filename": "library/std/src/sync/mpsc/spsc_queue/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -77,12 +77,13 @@ fn stress() {\n     }\n \n     unsafe fn stress_bound(bound: usize) {\n+        let count = if cfg!(miri) { 1000 } else { 100000 };\n         let q = Arc::new(Queue::with_additions(bound, (), ()));\n \n         let (tx, rx) = channel();\n         let q2 = q.clone();\n         let _t = thread::spawn(move || {\n-            for _ in 0..100000 {\n+            for _ in 0..count {\n                 loop {\n                     match q2.pop() {\n                         Some(1) => break,\n@@ -93,7 +94,7 @@ fn stress() {\n             }\n             tx.send(()).unwrap();\n         });\n-        for _ in 0..100000 {\n+        for _ in 0..count {\n             q.push(1);\n         }\n         rx.recv().unwrap();"}, {"sha": "63c79436974d592cf6bb9a6a6f017e6dc5ea0fb5", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -113,23 +113,25 @@ fn chan_gone_concurrent() {\n \n #[test]\n fn stress() {\n+    let count = if cfg!(miri) { 100 } else { 10000 };\n     let (tx, rx) = sync_channel::<i32>(0);\n     thread::spawn(move || {\n-        for _ in 0..10000 {\n+        for _ in 0..count {\n             tx.send(1).unwrap();\n         }\n     });\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n }\n \n #[test]\n fn stress_recv_timeout_two_threads() {\n+    let count = if cfg!(miri) { 100 } else { 10000 };\n     let (tx, rx) = sync_channel::<i32>(0);\n \n     thread::spawn(move || {\n-        for _ in 0..10000 {\n+        for _ in 0..count {\n             tx.send(1).unwrap();\n         }\n     });\n@@ -146,12 +148,12 @@ fn stress_recv_timeout_two_threads() {\n         }\n     }\n \n-    assert_eq!(recv_count, 10000);\n+    assert_eq!(recv_count, count);\n }\n \n #[test]\n fn stress_recv_timeout_shared() {\n-    const AMT: u32 = 1000;\n+    const AMT: u32 = if cfg!(miri) { 100 } else { 1000 };\n     const NTHREADS: u32 = 8;\n     let (tx, rx) = sync_channel::<i32>(0);\n     let (dtx, drx) = sync_channel::<()>(0);\n@@ -191,7 +193,7 @@ fn stress_recv_timeout_shared() {\n \n #[test]\n fn stress_shared() {\n-    const AMT: u32 = 1000;\n+    const AMT: u32 = if cfg!(miri) { 100 } else { 1000 };\n     const NTHREADS: u32 = 8;\n     let (tx, rx) = sync_channel::<i32>(0);\n     let (dtx, drx) = sync_channel::<()>(0);\n@@ -438,12 +440,13 @@ fn stream_send_recv_stress() {\n \n #[test]\n fn recv_a_lot() {\n+    let count = if cfg!(miri) { 1000 } else { 10000 };\n     // Regression test that we don't run out of stack in scheduler context\n-    let (tx, rx) = sync_channel(10000);\n-    for _ in 0..10000 {\n+    let (tx, rx) = sync_channel(count);\n+    for _ in 0..count {\n         tx.send(()).unwrap();\n     }\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         rx.recv().unwrap();\n     }\n }"}, {"sha": "f6d0796f604fa9c2a4aa3ad65a202fa9d491a932", "filename": "library/std/src/sync/mpsc/tests.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -120,21 +120,22 @@ fn chan_gone_concurrent() {\n \n #[test]\n fn stress() {\n+    let count = if cfg!(miri) { 100 } else { 10000 };\n     let (tx, rx) = channel::<i32>();\n     let t = thread::spawn(move || {\n-        for _ in 0..10000 {\n+        for _ in 0..count {\n             tx.send(1).unwrap();\n         }\n     });\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n     t.join().ok().expect(\"thread panicked\");\n }\n \n #[test]\n fn stress_shared() {\n-    const AMT: u32 = 10000;\n+    const AMT: u32 = if cfg!(miri) { 100 } else { 10000 };\n     const NTHREADS: u32 = 8;\n     let (tx, rx) = channel::<i32>();\n \n@@ -504,12 +505,13 @@ fn very_long_recv_timeout_wont_panic() {\n \n #[test]\n fn recv_a_lot() {\n+    let count = if cfg!(miri) { 1000 } else { 10000 };\n     // Regression test that we don't run out of stack in scheduler context\n     let (tx, rx) = channel();\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         tx.send(()).unwrap();\n     }\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         rx.recv().unwrap();\n     }\n }"}, {"sha": "b5b3ad9898edbd0e8cbfb43ffb74f8afd92c1be8", "filename": "library/std/src/sync/rwlock/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -19,7 +19,7 @@ fn smoke() {\n #[test]\n fn frob() {\n     const N: u32 = 10;\n-    const M: usize = 1000;\n+    const M: usize = if cfg!(miri) { 100 } else { 1000 };\n \n     let r = Arc::new(RwLock::new(()));\n "}, {"sha": "f38d2fd3d704e142c2cf25c2e30aafeb13e2ddf3", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -829,6 +829,7 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     )))]\n+    #[cfg_attr(miri, allow(unused))]\n     fn name_cstr(&self) -> &CStr {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n     }\n@@ -840,6 +841,7 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     ))]\n+    #[cfg_attr(miri, allow(unused))]\n     fn name_cstr(&self) -> &CStr {\n         &self.name\n     }"}, {"sha": "130e47c8d44f09e0e8434089875124bf886c4fa9", "filename": "library/std/src/thread/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -329,3 +329,22 @@ fn test_scoped_threads_nll() {\n     let x = 42_u8;\n     foo(&x);\n }\n+\n+// Regression test for https://github.com/rust-lang/rust/issues/98498.\n+#[test]\n+#[cfg(miri)] // relies on Miri's data race detector\n+fn scope_join_race() {\n+    for _ in 0..100 {\n+        let a_bool = AtomicBool::new(false);\n+\n+        thread::scope(|s| {\n+            for _ in 0..5 {\n+                s.spawn(|| a_bool.load(Ordering::Relaxed));\n+            }\n+\n+            for _ in 0..5 {\n+                s.spawn(|| a_bool.load(Ordering::Relaxed));\n+            }\n+        });\n+    }\n+}"}, {"sha": "6229556c85fee926f0535f3d3867c9b99b808bf3", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93edf3335ef172274acb208d672db51d40eeb2f/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=e93edf3335ef172274acb208d672db51d40eeb2f", "patch": "@@ -31,7 +31,8 @@ fn instant_monotonic_concurrent() -> crate::thread::Result<()> {\n         .map(|_| {\n             crate::thread::spawn(|| {\n                 let mut old = Instant::now();\n-                for _ in 0..5_000_000 {\n+                let count = if cfg!(miri) { 1_000 } else { 5_000_000 };\n+                for _ in 0..count {\n                     let new = Instant::now();\n                     assert!(new >= old);\n                     old = new;"}]}