{"sha": "5778ed4c926da6069ab899c8d4694527ed89190c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NzhlZDRjOTI2ZGE2MDY5YWI4OTljOGQ0Njk0NTI3ZWQ4OTE5MGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-15T02:18:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:31:47Z"}, "message": "std: Add a Duration type\n\nTaken from rust-chrono[1]. Needed for timers per #11189.\nExperimental.\n\n[1]: https://github.com/lifthrasiir/rust-chrono", "tree": {"sha": "96880d75e60c278a6c15576d5fa25544875e5d3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96880d75e60c278a6c15576d5fa25544875e5d3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5778ed4c926da6069ab899c8d4694527ed89190c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5778ed4c926da6069ab899c8d4694527ed89190c", "html_url": "https://github.com/rust-lang/rust/commit/5778ed4c926da6069ab899c8d4694527ed89190c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5778ed4c926da6069ab899c8d4694527ed89190c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9177707926d4fbed9dd9e4e7afc9a8c185dafe0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9177707926d4fbed9dd9e4e7afc9a8c185dafe0", "html_url": "https://github.com/rust-lang/rust/commit/d9177707926d4fbed9dd9e4e7afc9a8c185dafe0"}], "stats": {"total": 417, "additions": 417, "deletions": 0}, "files": [{"sha": "7bc07d7acb6c8b1685d983f779c08da1b7a9341b", "filename": "src/libstd/duration.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/5778ed4c926da6069ab899c8d4694527ed89190c/src%2Flibstd%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5778ed4c926da6069ab899c8d4694527ed89190c/src%2Flibstd%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fduration.rs?ref=5778ed4c926da6069ab899c8d4694527ed89190c", "patch": "@@ -0,0 +1,415 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Temporal quantification\n+\n+#![experimental]\n+#![allow(missing_doc)] // FIXME\n+\n+use {fmt, num, i32};\n+use option::{Option, Some, None};\n+use result::{Result, Ok, Err};\n+use ops::{Neg, Add, Sub, Mul, Div};\n+use num::{CheckedAdd, ToPrimitive};\n+\n+pub static MIN_DAYS: i32 = i32::MIN;\n+pub static MAX_DAYS: i32 = i32::MAX;\n+\n+static NANOS_PER_SEC: i32 = 1_000_000_000;\n+static SECS_PER_DAY: i32 = 86400;\n+\n+macro_rules! earlyexit(\n+    ($e:expr) => (match $e { Some(v) => v, None => return None })\n+)\n+\n+/// ISO 8601 duration\n+#[deriving(PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Duration {\n+    days: i32,\n+    secs: u32,\n+    nanos: u32,\n+}\n+\n+impl Duration {\n+    pub fn new(days: i32, secs: i32, nanos: i32) -> Option<Duration> {\n+        let (secs_, nanos) = div_mod_floor(nanos, NANOS_PER_SEC);\n+        let secs = earlyexit!(secs.checked_add(&secs_));\n+        let (days_, secs) = div_mod_floor(secs, SECS_PER_DAY);\n+        let days = earlyexit!(days.checked_add(&days_).and_then(|v| v.to_i32()));\n+        Some(Duration { days: days, secs: secs as u32, nanos: nanos as u32 })\n+    }\n+\n+    #[inline]\n+    pub fn weeks(weeks: i32) -> Duration {\n+        Duration::days(weeks * 7)\n+    }\n+\n+    #[inline]\n+    pub fn days(days: i32) -> Duration {\n+        let days = days.to_i32().expect(\"Duration::days out of bounds\");\n+        Duration { days: days, secs: 0, nanos: 0 }\n+    }\n+\n+    #[inline]\n+    pub fn hours(hours: i32) -> Duration {\n+        let (days, hours) = div_mod_floor(hours, (SECS_PER_DAY / 3600));\n+        let secs = hours * 3600;\n+        Duration { secs: secs as u32, ..Duration::days(days) }\n+    }\n+\n+    #[inline]\n+    pub fn minutes(mins: i32) -> Duration {\n+        let (days, mins) = div_mod_floor(mins, (SECS_PER_DAY / 60));\n+        let secs = mins * 60;\n+        Duration { secs: secs as u32, ..Duration::days(days) }\n+    }\n+\n+    #[inline]\n+    pub fn seconds(secs: i32) -> Duration {\n+        let (days, secs) = div_mod_floor(secs, SECS_PER_DAY);\n+        Duration { secs: secs as u32, ..Duration::days(days) }\n+    }\n+\n+    #[inline]\n+    pub fn milliseconds(millis: i32) -> Duration {\n+        let (secs, millis) = div_mod_floor(millis, (NANOS_PER_SEC / 1_000_000));\n+        let nanos = millis * 1_000_000;\n+        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n+    }\n+\n+    #[inline]\n+    pub fn microseconds(micros: i32) -> Duration {\n+        let (secs, micros) = div_mod_floor(micros, (NANOS_PER_SEC / 1_000));\n+        let nanos = micros * 1_000;\n+        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n+    }\n+\n+    #[inline]\n+    pub fn nanoseconds(nanos: i32) -> Duration {\n+        let (secs, nanos) = div_mod_floor(nanos, NANOS_PER_SEC);\n+        Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n+    }\n+\n+    #[inline]\n+    pub fn ndays(&self) -> i32 {\n+        self.days as i32\n+    }\n+\n+    #[inline]\n+    pub fn nseconds(&self) -> u32 {\n+        self.secs as u32\n+    }\n+\n+    #[inline]\n+    pub fn nnanoseconds(&self) -> u32 {\n+        self.nanos as u32\n+    }\n+}\n+\n+impl num::Zero for Duration {\n+    #[inline]\n+    fn zero() -> Duration {\n+        Duration { days: 0, secs: 0, nanos: 0 }\n+    }\n+\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.days == 0 && self.secs == 0 && self.nanos == 0\n+    }\n+}\n+\n+impl Neg<Duration> for Duration {\n+    fn neg(&self) -> Duration {\n+        // FIXME overflow (e.g. `-Duration::days(i32::MIN as i32)`)\n+        let mut days = -(self.days as i32);\n+        let mut secs = -(self.secs as i32);\n+        let mut nanos = -(self.nanos as i32);\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        if secs < 0 {\n+            secs += SECS_PER_DAY;\n+            days -= 1;\n+        }\n+        Duration { days: days as i32, secs: secs as u32, nanos: nanos as u32 }\n+    }\n+}\n+\n+impl Add<Duration,Duration> for Duration {\n+    fn add(&self, rhs: &Duration) -> Duration {\n+        let mut days = self.days + rhs.days;\n+        let mut secs = self.secs + rhs.secs;\n+        let mut nanos = self.nanos + rhs.nanos;\n+        if nanos >= NANOS_PER_SEC as u32 {\n+            nanos -= NANOS_PER_SEC as u32;\n+            secs += 1;\n+        }\n+        if secs >= SECS_PER_DAY as u32 {\n+            secs -= SECS_PER_DAY as u32;\n+            days += 1;\n+        }\n+        Duration { days: days, secs: secs, nanos: nanos }\n+    }\n+}\n+\n+impl num::CheckedAdd for Duration {\n+    fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n+        let mut days = earlyexit!(self.days.checked_add(&rhs.days));\n+        let mut secs = self.secs + rhs.secs;\n+        let mut nanos = self.nanos + rhs.nanos;\n+        if nanos >= NANOS_PER_SEC as u32 {\n+            nanos -= NANOS_PER_SEC as u32;\n+            secs += 1;\n+        }\n+        if secs >= SECS_PER_DAY as u32 {\n+            secs -= SECS_PER_DAY as u32;\n+            days = earlyexit!(days.checked_add(&1));\n+        }\n+        Some(Duration { days: days, secs: secs, nanos: nanos })\n+    }\n+}\n+\n+impl Sub<Duration,Duration> for Duration {\n+    fn sub(&self, rhs: &Duration) -> Duration {\n+        let mut days = self.days - rhs.days;\n+        let mut secs = self.secs as i32 - rhs.secs as i32;\n+        let mut nanos = self.nanos as i32 - rhs.nanos as i32;\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        if secs < 0 {\n+            secs += SECS_PER_DAY;\n+            days -= 1;\n+        }\n+        Duration { days: days, secs: secs as u32, nanos: nanos as u32 }\n+    }\n+}\n+\n+impl num::CheckedSub for Duration {\n+    fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n+        let mut days = earlyexit!(self.days.checked_sub(&rhs.days));\n+        let mut secs = self.secs as i32 - rhs.secs as i32;\n+        let mut nanos = self.nanos as i32 - rhs.nanos as i32;\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        if secs < 0 {\n+            secs += SECS_PER_DAY;\n+            days = earlyexit!(days.checked_sub(&1));\n+        }\n+        Some(Duration { days: days, secs: secs as u32, nanos: nanos as u32 })\n+    }\n+}\n+\n+impl Mul<i32,Duration> for Duration {\n+    fn mul(&self, rhs: &i32) -> Duration {\n+        /// Given `0 <= y < limit <= 2^30`,\n+        /// returns `(h,l)` such that `x * y = h * limit + l` where `0 <= l < limit`.\n+        fn mul_i64_u32_limit(x: i64, y: u32, limit: u32) -> (i64,u32) {\n+            let y = y as i64;\n+            let limit = limit as i64;\n+            let (xh, xl) = div_mod_floor_64(x, limit);\n+            let (h, l) = (xh * y, xl * y);\n+            let (h_, l) = div_rem_64(l, limit);\n+            (h + h_, l as u32)\n+        }\n+\n+        let rhs = *rhs as i64;\n+        let (secs1, nanos) = mul_i64_u32_limit(rhs, self.nanos, NANOS_PER_SEC as u32);\n+        let (days1, secs1) = div_mod_floor_64(secs1, (SECS_PER_DAY as i64));\n+        let (days2, secs2) = mul_i64_u32_limit(rhs, self.secs, SECS_PER_DAY as u32);\n+        let mut days = self.days as i64 * rhs + days1 + days2;\n+        let mut secs = secs1 as u32 + secs2;\n+        if secs >= SECS_PER_DAY as u32 {\n+            secs -= 1;\n+            days += 1;\n+        }\n+        Duration { days: days as i32, secs: secs, nanos: nanos }\n+    }\n+}\n+\n+impl Div<i32,Duration> for Duration {\n+    fn div(&self, rhs: &i32) -> Duration {\n+        let (rhs, days, secs, nanos) = if *rhs < 0 {\n+            let negated = -*self;\n+            (-*rhs as i64, negated.days as i64, negated.secs as i64, negated.nanos as i64)\n+        } else {\n+            (*rhs as i64, self.days as i64, self.secs as i64, self.nanos as i64)\n+        };\n+\n+        let (days, carry) = div_mod_floor_64(days, rhs);\n+        let secs = secs + carry * SECS_PER_DAY as i64;\n+        let (secs, carry) = div_mod_floor_64(secs, rhs);\n+        let nanos = nanos + carry * NANOS_PER_SEC as i64;\n+        let nanos = nanos / rhs;\n+        Duration { days: days as i32, secs: secs as u32, nanos: nanos as u32 }\n+    }\n+}\n+\n+impl fmt::Show for Duration {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let hasdate = self.days != 0;\n+        let hastime = (self.secs != 0 || self.nanos != 0) || !hasdate;\n+\n+        try!('P'.fmt(f));\n+        if hasdate {\n+            // technically speaking the negative part is not the valid ISO 8601,\n+            // but we need to print it anyway.\n+            try!(write!(f, \"{}D\", self.days));\n+        }\n+        if hastime {\n+            if self.nanos == 0 {\n+                try!(write!(f, \"T{}S\", self.secs));\n+            } else if self.nanos % 1_000_000 == 0 {\n+                try!(write!(f, \"T{},{:03}S\", self.secs, self.nanos / 1_000_000));\n+            } else if self.nanos % 1_000 == 0 {\n+                try!(write!(f, \"T{},{:06}S\", self.secs, self.nanos / 1_000));\n+            } else {\n+                try!(write!(f, \"T{},{:09}S\", self.secs, self.nanos));\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+// Copied from libnum\n+#[inline]\n+fn div_mod_floor(this: i32, other: i32) -> (i32, i32) {\n+    (div_floor(this, other), mod_floor(this, other))\n+}\n+\n+#[inline]\n+fn div_floor(this: i32, other: i32) -> i32 {\n+    match div_rem(this, other) {\n+        (d, r) if (r > 0 && other < 0)\n+               || (r < 0 && other > 0) => d - 1,\n+        (d, _)                         => d,\n+    }\n+}\n+\n+#[inline]\n+fn mod_floor(this: i32, other: i32) -> i32 {\n+    match this % other {\n+        r if (r > 0 && other < 0)\n+          || (r < 0 && other > 0) => r + other,\n+        r                         => r,\n+    }\n+}\n+\n+#[inline]\n+fn div_rem(this: i32, other: i32) -> (i32, i32) {\n+    (this / other, this % other)\n+}\n+\n+#[inline]\n+fn div_mod_floor_64(this: i64, other: i64) -> (i64, i64) {\n+    (div_floor_64(this, other), mod_floor_64(this, other))\n+}\n+\n+#[inline]\n+fn div_floor_64(this: i64, other: i64) -> i64 {\n+    match div_rem_64(this, other) {\n+        (d, r) if (r > 0 && other < 0)\n+               || (r < 0 && other > 0) => d - 1,\n+        (d, _)                         => d,\n+    }\n+}\n+\n+#[inline]\n+fn mod_floor_64(this: i64, other: i64) -> i64 {\n+    match this % other {\n+        r if (r > 0 && other < 0)\n+          || (r < 0 && other > 0) => r + other,\n+        r                         => r,\n+    }\n+}\n+\n+#[inline]\n+fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n+    (this / other, this % other)\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Duration, MIN_DAYS, MAX_DAYS};\n+    use i32;\n+    use num::{CheckedAdd, CheckedSub, Zero};\n+    use to_string::ToString;\n+\n+    fn zero() -> Duration { Zero::zero() }\n+\n+    #[test]\n+    fn test_duration() {\n+        assert!(zero() != Duration::seconds(1));\n+        assert_eq!(Duration::seconds(1) + Duration::seconds(2), Duration::seconds(3));\n+        assert_eq!(Duration::seconds(86399) + Duration::seconds(4),\n+                   Duration::days(1) + Duration::seconds(3));\n+        assert_eq!(Duration::days(10) - Duration::seconds(1000), Duration::seconds(863000));\n+        assert_eq!(Duration::days(10) - Duration::seconds(1000000), Duration::seconds(-136000));\n+        assert_eq!(Duration::days(2) + Duration::seconds(86399) + Duration::nanoseconds(1234567890),\n+                   Duration::days(3) + Duration::nanoseconds(234567890));\n+        assert_eq!(-Duration::days(3), Duration::days(-3));\n+        assert_eq!(-(Duration::days(3) + Duration::seconds(70)),\n+                   Duration::days(-4) + Duration::seconds(86400-70));\n+    }\n+\n+    #[test]\n+    fn test_duration_checked_ops() {\n+        assert_eq!(Duration::days(MAX_DAYS).checked_add(&Duration::seconds(86399)),\n+                   Some(Duration::days(MAX_DAYS - 1) + Duration::seconds(86400+86399)));\n+        assert!(Duration::days(MAX_DAYS).checked_add(&Duration::seconds(86400)).is_none());\n+\n+        assert_eq!(Duration::days(MIN_DAYS).checked_sub(&Duration::seconds(0)),\n+                   Some(Duration::days(MIN_DAYS)));\n+        assert!(Duration::days(MIN_DAYS).checked_sub(&Duration::seconds(1)).is_none());\n+    }\n+\n+    #[test]\n+    fn test_duration_mul() {\n+        assert_eq!(zero() * i32::MAX, zero());\n+        assert_eq!(zero() * i32::MIN, zero());\n+        assert_eq!(Duration::nanoseconds(1) * 0, zero());\n+        assert_eq!(Duration::nanoseconds(1) * 1, Duration::nanoseconds(1));\n+        assert_eq!(Duration::nanoseconds(1) * 1_000_000_000, Duration::seconds(1));\n+        assert_eq!(Duration::nanoseconds(1) * -1_000_000_000, -Duration::seconds(1));\n+        assert_eq!(-Duration::nanoseconds(1) * 1_000_000_000, -Duration::seconds(1));\n+        assert_eq!(Duration::nanoseconds(30) * 333_333_333,\n+                   Duration::seconds(10) - Duration::nanoseconds(10));\n+        assert_eq!((Duration::nanoseconds(1) + Duration::seconds(1) + Duration::days(1)) * 3,\n+                   Duration::nanoseconds(3) + Duration::seconds(3) + Duration::days(3));\n+    }\n+\n+    #[test]\n+    fn test_duration_div() {\n+        assert_eq!(zero() / i32::MAX, zero());\n+        assert_eq!(zero() / i32::MIN, zero());\n+        assert_eq!(Duration::nanoseconds(123_456_789) / 1, Duration::nanoseconds(123_456_789));\n+        assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n+        assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n+        assert_eq!(-Duration::nanoseconds(123_456_789) / 1, -Duration::nanoseconds(123_456_789));\n+    }\n+\n+    #[test]\n+    fn test_duration_fmt() {\n+        assert_eq!(zero().to_string(), \"PT0S\".to_string());\n+        assert_eq!(Duration::days(42).to_string(), \"P42D\".to_string());\n+        assert_eq!(Duration::days(-42).to_string(), \"P-42D\".to_string());\n+        assert_eq!(Duration::seconds(42).to_string(), \"PT42S\".to_string());\n+        assert_eq!(Duration::milliseconds(42).to_string(), \"PT0,042S\".to_string());\n+        assert_eq!(Duration::microseconds(42).to_string(), \"PT0,000042S\".to_string());\n+        assert_eq!(Duration::nanoseconds(42).to_string(), \"PT0,000000042S\".to_string());\n+        assert_eq!((Duration::days(7) + Duration::milliseconds(6543)).to_string(),\n+                   \"P7DT6,543S\".to_string());\n+    }\n+}"}, {"sha": "f2db4944de43d092d10f6e5ac0bca4d7d284686f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5778ed4c926da6069ab899c8d4694527ed89190c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5778ed4c926da6069ab899c8d4694527ed89190c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5778ed4c926da6069ab899c8d4694527ed89190c", "patch": "@@ -233,6 +233,8 @@ pub mod ascii;\n #[cfg(not(test))]\n pub mod gc;\n \n+pub mod duration;\n+\n /* Common traits */\n \n pub mod from_str;"}]}