{"sha": "ed84717869d4847dd9aa835efd498922f6c61bce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkODQ3MTc4NjlkNDg0N2RkOWFhODM1ZWZkNDk4OTIyZjZjNjFiY2U=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-09-18T12:54:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-09-18T12:55:07Z"}, "message": "internal: better naming", "tree": {"sha": "7596b393f275d74d3ab257e40431b7e6e363d717", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7596b393f275d74d3ab257e40431b7e6e363d717"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed84717869d4847dd9aa835efd498922f6c61bce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed84717869d4847dd9aa835efd498922f6c61bce", "html_url": "https://github.com/rust-lang/rust/commit/ed84717869d4847dd9aa835efd498922f6c61bce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed84717869d4847dd9aa835efd498922f6c61bce/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dc2aeea0f242a7fe7a9c9add731a1de1495a59a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dc2aeea0f242a7fe7a9c9add731a1de1495a59a", "html_url": "https://github.com/rust-lang/rust/commit/3dc2aeea0f242a7fe7a9c9add731a1de1495a59a"}], "stats": {"total": 120, "additions": 60, "deletions": 60}, "files": [{"sha": "d0b07f59314339069ba3b0bd5c08c3af1f1a7dbe", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -34,8 +34,8 @@ mod items;\n mod params;\n mod paths;\n mod patterns;\n-mod type_args;\n-mod type_params;\n+mod generic_args;\n+mod generic_params;\n mod types;\n \n use crate::{"}, {"sha": "29310b71bd8ce74f58d256c8c46556dcdcce9e98", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -486,7 +486,7 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     let m = lhs.precede(p);\n     p.bump_any();\n     name_ref(p);\n-    type_args::opt_generic_arg_list(p, true);\n+    generic_args::opt_generic_arg_list(p, true);\n     if p.at(T!['(']) {\n         arg_list(p);\n     }"}, {"sha": "0ae3eea5778361d903f4d12f854c42054c207ceb", "filename": "crates/parser/src/grammar/generic_args.rs", "status": "renamed", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -23,38 +23,6 @@ pub(super) fn opt_generic_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     m.complete(p, GENERIC_ARG_LIST);\n }\n \n-pub(super) fn const_arg(p: &mut Parser) {\n-    let m = p.start();\n-    // FIXME: duplicates the code below\n-    match p.current() {\n-        T!['{'] => {\n-            expressions::block_expr(p);\n-            m.complete(p, CONST_ARG);\n-        }\n-        k if k.is_literal() => {\n-            expressions::literal(p);\n-            m.complete(p, CONST_ARG);\n-        }\n-        T![true] | T![false] => {\n-            expressions::literal(p);\n-            m.complete(p, CONST_ARG);\n-        }\n-        T![-] => {\n-            let lm = p.start();\n-            p.bump(T![-]);\n-            expressions::literal(p);\n-            lm.complete(p, PREFIX_EXPR);\n-            m.complete(p, CONST_ARG);\n-        }\n-        _ => {\n-            let lm = p.start();\n-            paths::use_path(p);\n-            lm.complete(p, PATH_EXPR);\n-            m.complete(p, CONST_ARG);\n-        }\n-    }\n-}\n-\n // test type_arg\n // type A = B<'static, i32, 1, { 2 }, Item=u64, true, false>;\n fn generic_arg(p: &mut Parser) {\n@@ -94,7 +62,7 @@ fn generic_arg(p: &mut Parser) {\n                 }\n                 // NameRef<...>:\n                 T![:] => {\n-                    type_params::bounds(p);\n+                    generic_params::bounds(p);\n \n                     path_seg.abandon(p);\n                     path.abandon(p);\n@@ -137,3 +105,35 @@ fn generic_arg(p: &mut Parser) {\n         }\n     }\n }\n+\n+pub(super) fn const_arg(p: &mut Parser) {\n+    let m = p.start();\n+    // FIXME: duplicates the code above\n+    match p.current() {\n+        T!['{'] => {\n+            expressions::block_expr(p);\n+            m.complete(p, CONST_ARG);\n+        }\n+        k if k.is_literal() => {\n+            expressions::literal(p);\n+            m.complete(p, CONST_ARG);\n+        }\n+        T![true] | T![false] => {\n+            expressions::literal(p);\n+            m.complete(p, CONST_ARG);\n+        }\n+        T![-] => {\n+            let lm = p.start();\n+            p.bump(T![-]);\n+            expressions::literal(p);\n+            lm.complete(p, PREFIX_EXPR);\n+            m.complete(p, CONST_ARG);\n+        }\n+        _ => {\n+            let lm = p.start();\n+            paths::use_path(p);\n+            lm.complete(p, PATH_EXPR);\n+            m.complete(p, CONST_ARG);\n+        }\n+    }\n+}", "previous_filename": "crates/parser/src/grammar/type_args.rs"}, {"sha": "b2ce101835ddcf74343711c6aea8dfeca9af1fd8", "filename": "crates/parser/src/grammar/generic_params.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -82,7 +82,7 @@ fn const_param(p: &mut Parser, m: Marker) {\n         // struct B<const N: i32 = {}>;\n         // struct C<const N: i32 = some::CONST>;\n         p.bump(T![=]);\n-        type_args::const_arg(p);\n+        generic_args::const_arg(p);\n     }\n \n     m.complete(p, CONST_PARAM);", "previous_filename": "crates/parser/src/grammar/type_params.rs"}, {"sha": "517da6e95c491da1cb17365f2d08ad01bca66070", "filename": "crates/parser/src/grammar/items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -284,15 +284,15 @@ fn type_alias(p: &mut Parser, m: Marker) {\n \n     // test type_item_type_params\n     // type Result<T> = ();\n-    type_params::opt_generic_param_list(p);\n+    generic_params::opt_generic_param_list(p);\n \n     if p.at(T![:]) {\n-        type_params::bounds(p);\n+        generic_params::bounds(p);\n     }\n \n     // test type_item_where_clause\n     // type Foo where Foo: Copy = ();\n-    type_params::opt_where_clause(p);\n+    generic_params::opt_where_clause(p);\n     if p.eat(T![=]) {\n         types::type_(p);\n     }\n@@ -383,7 +383,7 @@ fn fn_(p: &mut Parser, m: Marker) {\n     name_r(p, ITEM_RECOVERY_SET);\n     // test function_type_params\n     // fn foo<T: Clone + Copy>(){}\n-    type_params::opt_generic_param_list(p);\n+    generic_params::opt_generic_param_list(p);\n \n     if p.at(T!['(']) {\n         params::param_list_fn_def(p);\n@@ -397,7 +397,7 @@ fn fn_(p: &mut Parser, m: Marker) {\n \n     // test function_where_clause\n     // fn foo<T>() where T: Copy {}\n-    type_params::opt_where_clause(p);\n+    generic_params::opt_where_clause(p);\n \n     if p.at(T![;]) {\n         // test fn_decl"}, {"sha": "e4b1116958a9b43ffee6b30ef6c20909490faeb2", "filename": "crates/parser/src/grammar/items/adt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -17,10 +17,10 @@ pub(super) fn union(p: &mut Parser, m: Marker) {\n \n fn struct_or_union(p: &mut Parser, m: Marker, is_struct: bool) {\n     name_r(p, ITEM_RECOVERY_SET);\n-    type_params::opt_generic_param_list(p);\n+    generic_params::opt_generic_param_list(p);\n     match p.current() {\n         T![where] => {\n-            type_params::opt_where_clause(p);\n+            generic_params::opt_where_clause(p);\n             match p.current() {\n                 T![;] => p.bump(T![;]),\n                 T!['{'] => record_field_list(p),\n@@ -42,7 +42,7 @@ fn struct_or_union(p: &mut Parser, m: Marker, is_struct: bool) {\n             tuple_field_list(p);\n             // test tuple_struct_where\n             // struct S<T>(T) where T: Clone;\n-            type_params::opt_where_clause(p);\n+            generic_params::opt_where_clause(p);\n             p.expect(T![;]);\n         }\n         _ => p.error(if is_struct { \"expected `;`, `{`, or `(`\" } else { \"expected `{`\" }),\n@@ -53,8 +53,8 @@ fn struct_or_union(p: &mut Parser, m: Marker, is_struct: bool) {\n pub(super) fn enum_(p: &mut Parser, m: Marker) {\n     p.bump(T![enum]);\n     name_r(p, ITEM_RECOVERY_SET);\n-    type_params::opt_generic_param_list(p);\n-    type_params::opt_where_clause(p);\n+    generic_params::opt_generic_param_list(p);\n+    generic_params::opt_where_clause(p);\n     if p.at(T!['{']) {\n         variant_list(p);\n     } else {"}, {"sha": "d6bb3b9b621fc7b90a898a22e76208807de5eca1", "filename": "crates/parser/src/grammar/items/traits.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -8,17 +8,17 @@ pub(super) fn trait_(p: &mut Parser, m: Marker) {\n \n     // test trait_item_generic_params\n     // trait X<U: Debug + Display> {}\n-    type_params::opt_generic_param_list(p);\n+    generic_params::opt_generic_param_list(p);\n \n     if p.eat(T![=]) {\n         // test trait_alias\n         // trait Z<U> = T<U>;\n-        type_params::bounds_without_colon(p);\n+        generic_params::bounds_without_colon(p);\n \n         // test trait_alias_where_clause\n         // trait Z<U> = T<U> where U: Copy;\n         // trait Z<U> = where Self: T<U>;\n-        type_params::opt_where_clause(p);\n+        generic_params::opt_where_clause(p);\n         p.expect(T![;]);\n         m.complete(p, TRAIT);\n         return;\n@@ -27,12 +27,12 @@ pub(super) fn trait_(p: &mut Parser, m: Marker) {\n     if p.at(T![:]) {\n         // test trait_item_bounds\n         // trait T: Hash + Clone {}\n-        type_params::bounds(p);\n+        generic_params::bounds(p);\n     }\n \n     // test trait_item_where_clause\n     // trait T where Self: Copy {}\n-    type_params::opt_where_clause(p);\n+    generic_params::opt_where_clause(p);\n \n     if p.at(T!['{']) {\n         assoc_item_list(p);\n@@ -47,7 +47,7 @@ pub(super) fn trait_(p: &mut Parser, m: Marker) {\n pub(super) fn impl_(p: &mut Parser, m: Marker) {\n     p.bump(T![impl]);\n     if p.at(T![<]) && not_a_qualified_path(p) {\n-        type_params::opt_generic_param_list(p);\n+        generic_params::opt_generic_param_list(p);\n     }\n \n     // test impl_item_const\n@@ -64,7 +64,7 @@ pub(super) fn impl_(p: &mut Parser, m: Marker) {\n     if p.eat(T![for]) {\n         impl_type(p);\n     }\n-    type_params::opt_where_clause(p);\n+    generic_params::opt_where_clause(p);\n     if p.at(T!['{']) {\n         assoc_item_list(p);\n     } else {"}, {"sha": "e51dc38f97350f653e2e36f08e9467e1e9dfefef", "filename": "crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -117,9 +117,9 @@ fn opt_path_type_args(p: &mut Parser, mode: Mode) {\n                 params::param_list_fn_trait(p);\n                 opt_ret_type(p);\n             } else {\n-                type_args::opt_generic_arg_list(p, false)\n+                generic_args::opt_generic_arg_list(p, false)\n             }\n         }\n-        Mode::Expr => type_args::opt_generic_arg_list(p, true),\n+        Mode::Expr => generic_args::opt_generic_arg_list(p, true),\n     }\n }"}, {"sha": "c2aa9ffc3bdb372f214698b0bfbb81dbb90a1d3b", "filename": "crates/parser/src/grammar/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed84717869d4847dd9aa835efd498922f6c61bce/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=ed84717869d4847dd9aa835efd498922f6c61bce", "patch": "@@ -216,7 +216,7 @@ pub(super) fn for_binder(p: &mut Parser) {\n     assert!(p.at(T![for]));\n     p.bump(T![for]);\n     if p.at(T![<]) {\n-        type_params::opt_generic_param_list(p);\n+        generic_params::opt_generic_param_list(p);\n     } else {\n         p.error(\"expected `<`\");\n     }\n@@ -254,7 +254,7 @@ fn impl_trait_type(p: &mut Parser) {\n     assert!(p.at(T![impl]));\n     let m = p.start();\n     p.bump(T![impl]);\n-    type_params::bounds_without_colon(p);\n+    generic_params::bounds_without_colon(p);\n     m.complete(p, IMPL_TRAIT_TYPE);\n }\n \n@@ -264,7 +264,7 @@ fn dyn_trait_type(p: &mut Parser) {\n     assert!(p.at(T![dyn]));\n     let m = p.start();\n     p.bump(T![dyn]);\n-    type_params::bounds_without_colon(p);\n+    generic_params::bounds_without_colon(p);\n     m.complete(p, DYN_TRAIT_TYPE);\n }\n \n@@ -339,7 +339,7 @@ fn opt_type_bounds_as_dyn_trait_type(p: &mut Parser, type_marker: CompletedMarke\n     p.eat(T![+]);\n \n     // Parse rest of the bounds into the TYPE_BOUND_LIST\n-    let m = type_params::bounds_without_colon_m(p, m);\n+    let m = generic_params::bounds_without_colon_m(p, m);\n \n     // Finally precede everything with DYN_TRAIT_TYPE\n     m.precede(p).complete(p, DYN_TRAIT_TYPE);"}]}