{"sha": "1cbc45942d5c0f6eb5d94e3b10762ba541958035", "node_id": "C_kwDOAAsO6NoAKDFjYmM0NTk0MmQ1YzBmNmViNWQ5NGUzYjEwNzYyYmE1NDE5NTgwMzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-21T15:22:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-21T15:22:54Z"}, "message": "Auto merge of #104673 - matthiaskrgr:rollup-85f65ov, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #104420 (Fix doc example for `wrapping_abs`)\n - #104499 (rustdoc JSON: Use `Function` everywhere and remove `Method`)\n - #104500 (`rustc_ast`: remove `ref` patterns)\n - #104511 (Mark functions created for `raw-dylib` on x86 with DllImport storage class)\n - #104595 (Add `PolyExistentialPredicate` type alias)\n - #104605 (deduplicate constant evaluation in cranelift backend)\n - #104628 (Revert \"Update CI to use Android NDK r25b\")\n - #104662 (Streamline deriving on packed structs.)\n - #104667 (Revert formatting changes of a test)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b70de974f4890d3269fc5587be1033311a9b9186", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b70de974f4890d3269fc5587be1033311a9b9186"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cbc45942d5c0f6eb5d94e3b10762ba541958035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cbc45942d5c0f6eb5d94e3b10762ba541958035", "html_url": "https://github.com/rust-lang/rust/commit/1cbc45942d5c0f6eb5d94e3b10762ba541958035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cbc45942d5c0f6eb5d94e3b10762ba541958035/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fe6f36224e92db6fbde952e0b7e50863161f6ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe6f36224e92db6fbde952e0b7e50863161f6ee", "html_url": "https://github.com/rust-lang/rust/commit/7fe6f36224e92db6fbde952e0b7e50863161f6ee"}, {"sha": "932626127946acc84cc98aa0de30ec890f6ba587", "url": "https://api.github.com/repos/rust-lang/rust/commits/932626127946acc84cc98aa0de30ec890f6ba587", "html_url": "https://github.com/rust-lang/rust/commit/932626127946acc84cc98aa0de30ec890f6ba587"}], "stats": {"total": 914, "additions": 415, "deletions": 499}, "files": [{"sha": "4ad9981991d308196dee93a57497468df1269d73", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -175,9 +175,9 @@ impl GenericArgs {\n     }\n \n     pub fn span(&self) -> Span {\n-        match *self {\n-            AngleBracketed(ref data) => data.span,\n-            Parenthesized(ref data) => data.span,\n+        match self {\n+            AngleBracketed(data) => data.span,\n+            Parenthesized(data) => data.span,\n         }\n     }\n }\n@@ -312,8 +312,8 @@ pub enum GenericBound {\n impl GenericBound {\n     pub fn span(&self) -> Span {\n         match self {\n-            GenericBound::Trait(ref t, ..) => t.span,\n-            GenericBound::Outlives(ref l) => l.ident.span,\n+            GenericBound::Trait(t, ..) => t.span,\n+            GenericBound::Outlives(l) => l.ident.span,\n         }\n     }\n }\n@@ -1115,23 +1115,23 @@ impl Expr {\n     /// If this is not the case, name resolution does not resolve `N` when using\n     /// `min_const_generics` as more complex expressions are not supported.\n     pub fn is_potential_trivial_const_param(&self) -> bool {\n-        let this = if let ExprKind::Block(ref block, None) = self.kind {\n-            if block.stmts.len() == 1 {\n-                if let StmtKind::Expr(ref expr) = block.stmts[0].kind { expr } else { self }\n-            } else {\n-                self\n-            }\n+        let this = if let ExprKind::Block(block, None) = &self.kind\n+            && block.stmts.len() == 1\n+            && let StmtKind::Expr(expr) = &block.stmts[0].kind\n+        {\n+            expr\n         } else {\n             self\n         };\n \n-        if let ExprKind::Path(None, ref path) = this.kind {\n-            if path.segments.len() == 1 && path.segments[0].args.is_none() {\n-                return true;\n-            }\n+        if let ExprKind::Path(None, path) = &this.kind\n+            && path.segments.len() == 1\n+            && path.segments[0].args.is_none()\n+        {\n+            true\n+        } else {\n+            false\n         }\n-\n-        false\n     }\n \n     pub fn to_bound(&self) -> Option<GenericBound> {\n@@ -2393,9 +2393,9 @@ pub enum FnRetTy {\n \n impl FnRetTy {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            FnRetTy::Default(span) => span,\n-            FnRetTy::Ty(ref ty) => ty.span,\n+        match self {\n+            &FnRetTy::Default(span) => span,\n+            FnRetTy::Ty(ty) => ty.span,\n         }\n     }\n }\n@@ -2657,8 +2657,8 @@ pub enum VariantData {\n impl VariantData {\n     /// Return the fields of this variant.\n     pub fn fields(&self) -> &[FieldDef] {\n-        match *self {\n-            VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, _) => fields,\n+        match self {\n+            VariantData::Struct(fields, ..) | VariantData::Tuple(fields, _) => fields,\n             _ => &[],\n         }\n     }"}, {"sha": "b7be94dde480eb205e41db5aeca2718d1ce1f02d", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -44,16 +44,16 @@ impl MarkedAttrs {\n impl NestedMetaItem {\n     /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => Some(item),\n+        match self {\n+            NestedMetaItem::MetaItem(item) => Some(item),\n             _ => None,\n         }\n     }\n \n     /// Returns the `Lit` if `self` is a `NestedMetaItem::Literal`s.\n     pub fn literal(&self) -> Option<&Lit> {\n-        match *self {\n-            NestedMetaItem::Literal(ref lit) => Some(lit),\n+        match self {\n+            NestedMetaItem::Literal(lit) => Some(lit),\n             _ => None,\n         }\n     }\n@@ -116,18 +116,18 @@ impl NestedMetaItem {\n impl Attribute {\n     #[inline]\n     pub fn has_name(&self, name: Symbol) -> bool {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.path == name,\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.path == name,\n             AttrKind::DocComment(..) => false,\n         }\n     }\n \n     /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => {\n-                if normal.item.path.segments.len() == 1 {\n-                    Some(normal.item.path.segments[0].ident)\n+        match &self.kind {\n+            AttrKind::Normal(normal) => {\n+                if let [ident] = &*normal.item.path.segments {\n+                    Some(ident.ident)\n                 } else {\n                     None\n                 }\n@@ -140,17 +140,15 @@ impl Attribute {\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => {\n-                normal.item.meta_kind().and_then(|kind| kind.value_str())\n-            }\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta_kind().and_then(|kind| kind.value_str()),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => match normal.item.meta_kind() {\n+        match &self.kind {\n+            AttrKind::Normal(normal) => match normal.item.meta_kind() {\n                 Some(MetaItemKind::List(list)) => Some(list),\n                 _ => None,\n             },\n@@ -191,8 +189,8 @@ impl MetaItem {\n     }\n \n     pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        match self.kind {\n-            MetaItemKind::List(ref l) => Some(&l[..]),\n+        match &self.kind {\n+            MetaItemKind::List(l) => Some(&**l),\n             _ => None,\n         }\n     }\n@@ -268,9 +266,9 @@ impl Attribute {\n     /// * `#[doc = \"doc\"]` returns `Some(\"doc\")`.\n     /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            AttrKind::DocComment(.., data) => Some(data),\n-            AttrKind::Normal(ref normal) if normal.item.path == sym::doc => {\n+        match &self.kind {\n+            AttrKind::DocComment(.., data) => Some(*data),\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => {\n                 normal.item.meta_kind().and_then(|kind| kind.value_str())\n             }\n             _ => None,\n@@ -282,8 +280,8 @@ impl Attribute {\n     }\n \n     pub fn get_normal_item(&self) -> &AttrItem {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => &normal.item,\n+        match &self.kind {\n+            AttrKind::Normal(normal) => &normal.item,\n             AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n         }\n     }\n@@ -297,28 +295,28 @@ impl Attribute {\n \n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.meta(self.span),\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta(self.span),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.meta_kind(),\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta_kind(),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn tokens(&self) -> TokenStream {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal\n                 .tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n                 .to_attr_token_stream()\n                 .to_tokenstream(),\n-            AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token(\n+            &AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token(\n                 Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n                 Spacing::Alone,\n             )]),\n@@ -496,17 +494,17 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments, tokens: None }\n             }\n-            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. }, _)) => match *nt {\n-                token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n-                token::Nonterminal::NtPath(ref path) => (**path).clone(),\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. }, _)) => match &*nt {\n+                token::Nonterminal::NtMeta(item) => return item.meta(item.path.span),\n+                token::Nonterminal::NtPath(path) => (**path).clone(),\n                 _ => return None,\n             },\n             _ => return None,\n         };\n         let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n         let kind = MetaItemKind::from_tokens(tokens)?;\n-        let hi = match kind {\n-            MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n+        let hi = match &kind {\n+            MetaItemKind::NameValue(lit) => lit.span.hi(),\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(path.span.hi()),\n             _ => path.span.hi(),\n         };\n@@ -518,8 +516,8 @@ impl MetaItem {\n impl MetaItemKind {\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self {\n-            MetaItemKind::NameValue(ref v) => match v.kind {\n-                LitKind::Str(ref s, _) => Some(*s),\n+            MetaItemKind::NameValue(v) => match v.kind {\n+                LitKind::Str(s, _) => Some(s),\n                 _ => None,\n             },\n             _ => None,\n@@ -557,15 +555,15 @@ impl MetaItemKind {\n     }\n \n     fn token_trees(&self, span: Span) -> Vec<TokenTree> {\n-        match *self {\n+        match self {\n             MetaItemKind::Word => vec![],\n-            MetaItemKind::NameValue(ref lit) => {\n+            MetaItemKind::NameValue(lit) => {\n                 vec![\n                     TokenTree::token_alone(token::Eq, span),\n                     TokenTree::Token(lit.to_token(), Spacing::Alone),\n                 ]\n             }\n-            MetaItemKind::List(ref list) => {\n+            MetaItemKind::List(list) => {\n                 let mut tokens = Vec::new();\n                 for (i, item) in list.iter().enumerate() {\n                     if i > 0 {\n@@ -648,16 +646,16 @@ impl MetaItemKind {\n \n impl NestedMetaItem {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.span,\n-            NestedMetaItem::Literal(ref lit) => lit.span,\n+        match self {\n+            NestedMetaItem::MetaItem(item) => item.span,\n+            NestedMetaItem::Literal(lit) => lit.span,\n         }\n     }\n \n     fn token_trees(&self) -> Vec<TokenTree> {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.token_trees(),\n-            NestedMetaItem::Literal(ref lit) => {\n+        match self {\n+            NestedMetaItem::MetaItem(item) => item.token_trees(),\n+            NestedMetaItem::Literal(lit) => {\n                 vec![TokenTree::Token(lit.to_token(), Spacing::Alone)]\n             }\n         }"}, {"sha": "f9ab5a17570855bcd3fb4351e61de63558510920", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -439,15 +439,15 @@ pub fn noop_visit_constraint<T: MutVisitor>(\n ) {\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    if let Some(ref mut gen_args) = gen_args {\n+    if let Some(gen_args) = gen_args {\n         vis.visit_generic_args(gen_args);\n     }\n     match kind {\n-        AssocConstraintKind::Equality { ref mut term } => match term {\n+        AssocConstraintKind::Equality { term } => match term {\n             Term::Ty(ty) => vis.visit_ty(ty),\n             Term::Const(c) => vis.visit_anon_const(c),\n         },\n-        AssocConstraintKind::Bound { ref mut bounds } => visit_bounds(bounds, vis),\n+        AssocConstraintKind::Bound { bounds } => visit_bounds(bounds, vis),\n     }\n     vis.visit_span(span);\n }\n@@ -880,7 +880,7 @@ pub fn noop_flat_map_generic_param<T: MutVisitor>(\n     let GenericParam { id, ident, attrs, bounds, kind, colon_span, is_placeholder: _ } = &mut param;\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    if let Some(ref mut colon_span) = colon_span {\n+    if let Some(colon_span) = colon_span {\n         vis.visit_span(colon_span);\n     }\n     visit_attrs(attrs, vis);"}, {"sha": "cb32925584c58a20dcb191724765c7e0aa9ef84f", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -601,17 +601,18 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind && let NtPath(..) = **nt {\n+        if let Interpolated(nt) = &self.kind && let NtPath(..) = **nt {\n             return true;\n         }\n+\n         false\n     }\n \n     /// Would `maybe_whole_expr` in `parser.rs` return `Ok(..)`?\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind\n+        if let Interpolated(nt) = &self.kind\n             && let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtBlock(_) = **nt\n         {\n             return true;\n@@ -622,9 +623,10 @@ impl Token {\n \n     // Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind && let NtBlock(..) = **nt {\n+        if let Interpolated(nt) = &self.kind && let NtBlock(..) = **nt {\n             return true;\n         }\n+\n         false\n     }\n "}, {"sha": "f65f1f069cba230b790ac60ae97ecbcd3fe94070", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -377,26 +377,26 @@ pub fn needs_par_as_let_scrutinee(order: i8) -> bool {\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-    match value.kind {\n+    match &value.kind {\n         ast::ExprKind::Struct(..) => true,\n \n-        ast::ExprKind::Assign(ref lhs, ref rhs, _)\n-        | ast::ExprKind::AssignOp(_, ref lhs, ref rhs)\n-        | ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+        ast::ExprKind::Assign(lhs, rhs, _)\n+        | ast::ExprKind::AssignOp(_, lhs, rhs)\n+        | ast::ExprKind::Binary(_, lhs, rhs) => {\n             // X { y: 1 } + X { y: 2 }\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n-        ast::ExprKind::Await(ref x)\n-        | ast::ExprKind::Unary(_, ref x)\n-        | ast::ExprKind::Cast(ref x, _)\n-        | ast::ExprKind::Type(ref x, _)\n-        | ast::ExprKind::Field(ref x, _)\n-        | ast::ExprKind::Index(ref x, _) => {\n+        ast::ExprKind::Await(x)\n+        | ast::ExprKind::Unary(_, x)\n+        | ast::ExprKind::Cast(x, _)\n+        | ast::ExprKind::Type(x, _)\n+        | ast::ExprKind::Field(x, _)\n+        | ast::ExprKind::Index(x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)\n         }\n \n-        ast::ExprKind::MethodCall(box ast::MethodCall { ref receiver, .. }) => {\n+        ast::ExprKind::MethodCall(box ast::MethodCall { receiver, .. }) => {\n             // X { y: 1 }.bar(...)\n             contains_exterior_struct_lit(&receiver)\n         }"}, {"sha": "0978fc94d698d11a69bab0a1ea5e6857ddb608c2", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 128, "deletions": 138, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -299,74 +299,68 @@ pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitR\n pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n-    match item.kind {\n+    match &item.kind {\n         ItemKind::ExternCrate(_) => {}\n-        ItemKind::Use(ref use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n-        ItemKind::Static(ref typ, _, ref expr) | ItemKind::Const(_, ref typ, ref expr) => {\n+        ItemKind::Use(use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n+        ItemKind::Static(typ, _, expr) | ItemKind::Const(_, typ, expr) => {\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        ItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        ItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind =\n                 FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, generics, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n-        ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n+        ItemKind::Mod(_unsafety, mod_kind) => match mod_kind {\n             ModKind::Loaded(items, _inline, _inner_span) => {\n                 walk_list!(visitor, visit_item, items)\n             }\n             ModKind::Unloaded => {}\n         },\n-        ItemKind::ForeignMod(ref foreign_module) => {\n+        ItemKind::ForeignMod(foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemKind::GlobalAsm(ref asm) => visitor.visit_inline_asm(asm),\n-        ItemKind::TyAlias(box TyAlias { ref generics, ref bounds, ref ty, .. }) => {\n+        ItemKind::GlobalAsm(asm) => visitor.visit_inline_asm(asm),\n+        ItemKind::TyAlias(box TyAlias { generics, bounds, ty, .. }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_ty, ty);\n         }\n-        ItemKind::Enum(ref enum_definition, ref generics) => {\n+        ItemKind::Enum(enum_definition, generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_enum_def(enum_definition)\n         }\n         ItemKind::Impl(box Impl {\n             defaultness: _,\n             unsafety: _,\n-            ref generics,\n+            generics,\n             constness: _,\n             polarity: _,\n-            ref of_trait,\n-            ref self_ty,\n-            ref items,\n+            of_trait,\n+            self_ty,\n+            items,\n         }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n             walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Impl);\n         }\n-        ItemKind::Struct(ref struct_definition, ref generics)\n-        | ItemKind::Union(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(struct_definition, generics)\n+        | ItemKind::Union(struct_definition, generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_variant_data(struct_definition);\n         }\n-        ItemKind::Trait(box Trait {\n-            unsafety: _,\n-            is_auto: _,\n-            ref generics,\n-            ref bounds,\n-            ref items,\n-        }) => {\n+        ItemKind::Trait(box Trait { unsafety: _, is_auto: _, generics, bounds, items }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::SuperTraits);\n             walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Trait);\n         }\n-        ItemKind::TraitAlias(ref generics, ref bounds) => {\n+        ItemKind::TraitAlias(generics, bounds) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n-        ItemKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n-        ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n+        ItemKind::MacCall(mac) => visitor.visit_mac_call(mac),\n+        ItemKind::MacroDef(ts) => visitor.visit_mac_def(ts, item.id),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n@@ -399,39 +393,39 @@ pub fn walk_pat_field<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a PatField) {\n }\n \n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n-    match typ.kind {\n-        TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(ref opt_lifetime, ref mutable_type) => {\n+    match &typ.kind {\n+        TyKind::Slice(ty) | TyKind::Paren(ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Rptr(opt_lifetime, mutable_type) => {\n             walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Rptr);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(ref tuple_element_types) => {\n+        TyKind::Tup(tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n-        TyKind::BareFn(ref function_declaration) => {\n+        TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n             walk_fn_decl(visitor, &function_declaration.decl);\n         }\n-        TyKind::Path(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+        TyKind::Path(maybe_qself, path) => {\n+            if let Some(qself) = maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, typ.id);\n         }\n-        TyKind::Array(ref ty, ref length) => {\n+        TyKind::Array(ty, length) => {\n             visitor.visit_ty(ty);\n             visitor.visit_anon_const(length)\n         }\n-        TyKind::TraitObject(ref bounds, ..) => {\n+        TyKind::TraitObject(bounds, ..) => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::TraitObject);\n         }\n-        TyKind::ImplTrait(_, ref bounds) => {\n+        TyKind::ImplTrait(_, bounds) => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Impl);\n         }\n-        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Typeof(expression) => visitor.visit_anon_const(expression),\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n-        TyKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        TyKind::MacCall(mac) => visitor.visit_mac_call(mac),\n         TyKind::Never | TyKind::CVarArgs => {}\n     }\n }\n@@ -444,15 +438,15 @@ pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n \n pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree, id: NodeId) {\n     visitor.visit_path(&use_tree.prefix, id);\n-    match use_tree.kind {\n+    match &use_tree.kind {\n         UseTreeKind::Simple(rename, ..) => {\n             // The extra IDs are handled during HIR lowering.\n-            if let Some(rename) = rename {\n+            if let &Some(rename) = rename {\n                 visitor.visit_ident(rename);\n             }\n         }\n         UseTreeKind::Glob => {}\n-        UseTreeKind::Nested(ref use_trees) => {\n+        UseTreeKind::Nested(use_trees) => {\n             for &(ref nested_tree, nested_id) in use_trees {\n                 visitor.visit_use_tree(nested_tree, nested_id, true);\n             }\n@@ -462,7 +456,7 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree,\n \n pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V, segment: &'a PathSegment) {\n     visitor.visit_ident(segment.ident);\n-    if let Some(ref args) = segment.args {\n+    if let Some(args) = &segment.args {\n         visitor.visit_generic_args(args);\n     }\n }\n@@ -471,16 +465,16 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V, generic_args: &'a GenericArgs)\n where\n     V: Visitor<'a>,\n {\n-    match *generic_args {\n-        GenericArgs::AngleBracketed(ref data) => {\n+    match generic_args {\n+        GenericArgs::AngleBracketed(data) => {\n             for arg in &data.args {\n                 match arg {\n                     AngleBracketedArg::Arg(a) => visitor.visit_generic_arg(a),\n                     AngleBracketedArg::Constraint(c) => visitor.visit_assoc_constraint(c),\n                 }\n             }\n         }\n-        GenericArgs::Parenthesized(ref data) => {\n+        GenericArgs::Parenthesized(data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);\n             walk_fn_ret_ty(visitor, &data.output);\n         }\n@@ -500,64 +494,64 @@ where\n \n pub fn walk_assoc_constraint<'a, V: Visitor<'a>>(visitor: &mut V, constraint: &'a AssocConstraint) {\n     visitor.visit_ident(constraint.ident);\n-    if let Some(ref gen_args) = constraint.gen_args {\n+    if let Some(gen_args) = &constraint.gen_args {\n         visitor.visit_generic_args(gen_args);\n     }\n-    match constraint.kind {\n-        AssocConstraintKind::Equality { ref term } => match term {\n+    match &constraint.kind {\n+        AssocConstraintKind::Equality { term } => match term {\n             Term::Ty(ty) => visitor.visit_ty(ty),\n             Term::Const(c) => visitor.visit_anon_const(c),\n         },\n-        AssocConstraintKind::Bound { ref bounds } => {\n+        AssocConstraintKind::Bound { bounds } => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n     }\n }\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n-    match pattern.kind {\n-        PatKind::TupleStruct(ref opt_qself, ref path, ref elems) => {\n-            if let Some(ref qself) = *opt_qself {\n+    match &pattern.kind {\n+        PatKind::TupleStruct(opt_qself, path, elems) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::Path(ref opt_qself, ref path) => {\n-            if let Some(ref qself) = *opt_qself {\n+        PatKind::Path(opt_qself, path) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatKind::Struct(ref opt_qself, ref path, ref fields, _) => {\n-            if let Some(ref qself) = *opt_qself {\n+        PatKind::Struct(opt_qself, path, fields, _) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat_field, fields);\n         }\n-        PatKind::Box(ref subpattern)\n-        | PatKind::Ref(ref subpattern, _)\n-        | PatKind::Paren(ref subpattern) => visitor.visit_pat(subpattern),\n-        PatKind::Ident(_, ident, ref optional_subpattern) => {\n-            visitor.visit_ident(ident);\n+        PatKind::Box(subpattern) | PatKind::Ref(subpattern, _) | PatKind::Paren(subpattern) => {\n+            visitor.visit_pat(subpattern)\n+        }\n+        PatKind::Ident(_, ident, optional_subpattern) => {\n+            visitor.visit_ident(*ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n-        PatKind::Range(ref lower_bound, ref upper_bound, _) => {\n+        PatKind::Lit(expression) => visitor.visit_expr(expression),\n+        PatKind::Range(lower_bound, upper_bound, _) => {\n             walk_list!(visitor, visit_expr, lower_bound);\n             walk_list!(visitor, visit_expr, upper_bound);\n         }\n         PatKind::Wild | PatKind::Rest => {}\n-        PatKind::Tuple(ref elems) | PatKind::Slice(ref elems) | PatKind::Or(ref elems) => {\n+        PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        PatKind::MacCall(mac) => visitor.visit_mac_call(mac),\n     }\n }\n \n pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignItem) {\n-    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    let &Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = item;\n     visitor.visit_vis(vis);\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -566,7 +560,7 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        ForeignItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        ForeignItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind = FnKind::Fn(FnCtxt::Foreign, ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n@@ -582,22 +576,20 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n }\n \n pub fn walk_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a GenericBound) {\n-    match *bound {\n-        GenericBound::Trait(ref typ, ref _modifier) => visitor.visit_poly_trait_ref(typ),\n-        GenericBound::Outlives(ref lifetime) => {\n-            visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound)\n-        }\n+    match bound {\n+        GenericBound::Trait(typ, _modifier) => visitor.visit_poly_trait_ref(typ),\n+        GenericBound::Outlives(lifetime) => visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound),\n     }\n }\n \n pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a GenericParam) {\n     visitor.visit_ident(param.ident);\n     walk_list!(visitor, visit_attribute, param.attrs.iter());\n     walk_list!(visitor, visit_param_bound, &param.bounds, BoundKind::Bound);\n-    match param.kind {\n+    match &param.kind {\n         GenericParamKind::Lifetime => (),\n-        GenericParamKind::Type { ref default } => walk_list!(visitor, visit_ty, default),\n-        GenericParamKind::Const { ref ty, ref default, .. } => {\n+        GenericParamKind::Type { default } => walk_list!(visitor, visit_ty, default),\n+        GenericParamKind::Const { ty, default, .. } => {\n             visitor.visit_ty(ty);\n             if let Some(default) = default {\n                 visitor.visit_anon_const(default);\n@@ -621,32 +613,30 @@ pub fn walk_closure_binder<'a, V: Visitor<'a>>(visitor: &mut V, binder: &'a Clos\n }\n \n pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a WherePredicate) {\n-    match *predicate {\n+    match predicate {\n         WherePredicate::BoundPredicate(WhereBoundPredicate {\n-            ref bounded_ty,\n-            ref bounds,\n-            ref bound_generic_params,\n+            bounded_ty,\n+            bounds,\n+            bound_generic_params,\n             ..\n         }) => {\n             visitor.visit_ty(bounded_ty);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n-        WherePredicate::RegionPredicate(WhereRegionPredicate {\n-            ref lifetime, ref bounds, ..\n-        }) => {\n+        WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, .. }) => {\n             visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n-        WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, .. }) => {\n+        WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n             visitor.visit_ty(lhs_ty);\n             visitor.visit_ty(rhs_ty);\n         }\n     }\n }\n \n pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FnRetTy) {\n-    if let FnRetTy::Ty(ref output_ty) = *ret_ty {\n+    if let FnRetTy::Ty(output_ty) = ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n@@ -675,7 +665,7 @@ pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>) {\n }\n \n pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem, ctxt: AssocCtxt) {\n-    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    let &Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = item;\n     visitor.visit_vis(vis);\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -684,7 +674,7 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem,\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        AssocItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        AssocItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n@@ -717,13 +707,13 @@ pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) {\n }\n \n pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n-    match statement.kind {\n-        StmtKind::Local(ref local) => visitor.visit_local(local),\n-        StmtKind::Item(ref item) => visitor.visit_item(item),\n-        StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => visitor.visit_expr(expr),\n+    match &statement.kind {\n+        StmtKind::Local(local) => visitor.visit_local(local),\n+        StmtKind::Item(item) => visitor.visit_item(item),\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => visitor.visit_expr(expr),\n         StmtKind::Empty => {}\n-        StmtKind::MacCall(ref mac) => {\n-            let MacCallStmt { ref mac, style: _, ref attrs, tokens: _ } = **mac;\n+        StmtKind::MacCall(mac) => {\n+            let MacCallStmt { mac, attrs, style: _, tokens: _ } = &**mac;\n             visitor.visit_mac_call(mac);\n             for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);\n@@ -760,7 +750,7 @@ pub fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm)\n }\n \n pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineAsmSym) {\n-    if let Some(ref qself) = sym.qself {\n+    if let Some(qself) = &sym.qself {\n         visitor.visit_ty(&qself.ty);\n     }\n     visitor.visit_path(&sym.path, sym.id);\n@@ -769,18 +759,18 @@ pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineA\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n-    match expression.kind {\n-        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(ref subexpressions) => {\n+    match &expression.kind {\n+        ExprKind::Box(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::Array(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n-        ExprKind::Repeat(ref element, ref count) => {\n+        ExprKind::ConstBlock(anon_const) => visitor.visit_anon_const(anon_const),\n+        ExprKind::Repeat(element, count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)\n         }\n-        ExprKind::Struct(ref se) => {\n-            if let Some(ref qself) = se.qself {\n+        ExprKind::Struct(se) => {\n+            if let Some(qself) = &se.qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(&se.path, expression.id);\n@@ -791,124 +781,124 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                 StructRest::None => {}\n             }\n         }\n-        ExprKind::Tup(ref subexpressions) => {\n+        ExprKind::Tup(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::Call(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(callee_expression, arguments) => {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(box MethodCall { ref seg, ref receiver, ref args, span: _ }) => {\n+        ExprKind::MethodCall(box MethodCall { seg, receiver, args, span: _ }) => {\n             visitor.visit_path_segment(seg);\n             visitor.visit_expr(receiver);\n             walk_list!(visitor, visit_expr, args);\n         }\n-        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+        ExprKind::Binary(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, _, subexpression) | ExprKind::Unary(_, subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+        ExprKind::Cast(subexpression, typ) | ExprKind::Type(subexpression, typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprKind::Let(ref pat, ref expr, _) => {\n+        ExprKind::Let(pat, expr, _) => {\n             visitor.visit_pat(pat);\n             visitor.visit_expr(expr);\n         }\n-        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n+        ExprKind::If(head_expression, if_block, optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::While(subexpression, block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::ForLoop(pattern, subexpression, block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Loop(ref block, ref opt_label) => {\n+        ExprKind::Loop(block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Match(ref subexpression, ref arms) => {\n+        ExprKind::Match(subexpression, arms) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprKind::Closure(box Closure {\n-            ref binder,\n+            binder,\n             capture_clause: _,\n             asyncness: _,\n             movability: _,\n-            ref fn_decl,\n-            ref body,\n+            fn_decl,\n+            body,\n             fn_decl_span: _,\n         }) => {\n             visitor.visit_fn(FnKind::Closure(binder, fn_decl, body), expression.span, expression.id)\n         }\n-        ExprKind::Block(ref block, ref opt_label) => {\n+        ExprKind::Block(block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Async(_, _, ref body) => {\n+        ExprKind::Async(_, _, body) => {\n             visitor.visit_block(body);\n         }\n-        ExprKind::Await(ref expr) => visitor.visit_expr(expr),\n-        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+        ExprKind::Await(expr) => visitor.visit_expr(expr),\n+        ExprKind::Assign(lhs, rhs, _) => {\n             visitor.visit_expr(lhs);\n             visitor.visit_expr(rhs);\n         }\n-        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+        ExprKind::AssignOp(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n         }\n-        ExprKind::Field(ref subexpression, ident) => {\n+        ExprKind::Field(subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident);\n+            visitor.visit_ident(*ident);\n         }\n-        ExprKind::Index(ref main_expression, ref index_expression) => {\n+        ExprKind::Index(main_expression, index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprKind::Range(ref start, ref end, _) => {\n+        ExprKind::Range(start, end, _) => {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }\n         ExprKind::Underscore => {}\n-        ExprKind::Path(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+        ExprKind::Path(maybe_qself, path) => {\n+            if let Some(qself) = maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_label, ref opt_expr) => {\n+        ExprKind::Break(opt_label, opt_expr) => {\n             walk_list!(visitor, visit_label, opt_label);\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprKind::Continue(ref opt_label) => {\n+        ExprKind::Continue(opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n         }\n-        ExprKind::Ret(ref optional_expression) => {\n+        ExprKind::Ret(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::Yeet(ref optional_expression) => {\n+        ExprKind::Yeet(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n-        ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::InlineAsm(ref asm) => visitor.visit_inline_asm(asm),\n-        ExprKind::Yield(ref optional_expression) => {\n+        ExprKind::MacCall(mac) => visitor.visit_mac_call(mac),\n+        ExprKind::Paren(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::InlineAsm(asm) => visitor.visit_inline_asm(asm),\n+        ExprKind::Yield(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::Try(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::TryBlock(ref body) => visitor.visit_block(body),\n+        ExprKind::Try(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::TryBlock(body) => visitor.visit_block(body),\n         ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n \n@@ -935,8 +925,8 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n }\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n-    match attr.kind {\n-        AttrKind::Normal(ref normal) => walk_mac_args(visitor, &normal.item.args),\n+    match &attr.kind {\n+        AttrKind::Normal(normal) => walk_mac_args(visitor, &normal.item.args),\n         AttrKind::DocComment(..) => {}\n     }\n }"}, {"sha": "3309fab224fb71112fac7cb5c37225f2ab26d5e8", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 24, "deletions": 70, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -448,7 +448,8 @@ impl<'a> TraitDef<'a> {\n                     _ => unreachable!(),\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n-                let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n+                let copy_fields =\n+                    is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n                 let newitem = match item.kind {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n@@ -457,16 +458,14 @@ impl<'a> TraitDef<'a> {\n                         item.ident,\n                         generics,\n                         from_scratch,\n-                        is_packed,\n-                        always_copy,\n+                        copy_fields,\n                     ),\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        // We ignore `is_packed`/`always_copy` here, because\n-                        // `repr(packed)` enums cause an error later on.\n+                        // We ignore `is_packed` here, because `repr(packed)`\n+                        // enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n-                        // downstream in blatantly illegal code, so it\n-                        // is fine.\n+                        // downstream in blatantly illegal code, so it is fine.\n                         self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n@@ -477,8 +476,7 @@ impl<'a> TraitDef<'a> {\n                                 item.ident,\n                                 generics,\n                                 from_scratch,\n-                                is_packed,\n-                                always_copy,\n+                                copy_fields,\n                             )\n                         } else {\n                             cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n@@ -748,8 +746,7 @@ impl<'a> TraitDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n-        is_packed: bool,\n-        always_copy: bool,\n+        copy_fields: bool,\n     ) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> =\n             struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n@@ -777,8 +774,7 @@ impl<'a> TraitDef<'a> {\n                         type_ident,\n                         &selflike_args,\n                         &nonselflike_args,\n-                        is_packed,\n-                        always_copy,\n+                        copy_fields,\n                     )\n                 };\n \n@@ -1016,19 +1012,9 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n-    /// If the struct doesn't impl `Copy`, we use let-destructuring with `ref`:\n-    /// ```\n-    /// # struct A { x: u8, y: u8 }\n-    /// impl PartialEq for A {\n-    ///     fn eq(&self, other: &A) -> bool {\n-    ///         let Self { x: ref __self_0_0, y: ref __self_0_1 } = *self;\n-    ///         let Self { x: ref __self_1_0, y: ref __self_1_1 } = *other;\n-    ///         *__self_0_0 == *__self_1_0 && *__self_0_1 == *__self_1_1\n-    ///     }\n-    /// }\n-    /// ```\n-    /// This latter case only works if the fields match the alignment required\n-    /// by the `packed(N)` attribute. (We'll get errors later on if not.)\n+    /// If the struct doesn't impl `Copy`, we use the normal `&self.x`. This\n+    /// only works if the fields match the alignment required by the\n+    /// `packed(N)` attribute. (We'll get errors later on if not.)\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1037,51 +1023,19 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         selflike_args: &[P<Expr>],\n         nonselflike_args: &[P<Expr>],\n-        is_packed: bool,\n-        always_copy: bool,\n+        copy_fields: bool,\n     ) -> BlockOrExpr {\n-        let span = trait_.span;\n         assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n \n-        let mk_body = |cx, selflike_fields| {\n-            self.call_substructure_method(\n-                cx,\n-                trait_,\n-                type_ident,\n-                nonselflike_args,\n-                &Struct(struct_def, selflike_fields),\n-            )\n-        };\n-\n-        if !is_packed {\n-            let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, false);\n-            mk_body(cx, selflike_fields)\n-        } else if always_copy {\n-            let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, true);\n-            mk_body(cx, selflike_fields)\n-        } else {\n-            // Packed and not copy. Need to use ref patterns.\n-            let prefixes: Vec<_> =\n-                (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n-            let selflike_fields = trait_.create_struct_pattern_fields(cx, struct_def, &prefixes);\n-            let mut body = mk_body(cx, selflike_fields);\n-\n-            let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, ByRef::Yes);\n-\n-            // Do the let-destructuring.\n-            let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n-                .map(|(selflike_arg_expr, pat)| {\n-                    let selflike_arg_expr = cx.expr_deref(span, selflike_arg_expr.clone());\n-                    cx.stmt_let_pat(span, pat, selflike_arg_expr)\n-                })\n-                .collect();\n-            stmts.extend(std::mem::take(&mut body.0));\n-            BlockOrExpr(stmts, body.1)\n-        }\n+        let selflike_fields =\n+            trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, copy_fields);\n+        self.call_substructure_method(\n+            cx,\n+            trait_,\n+            type_ident,\n+            nonselflike_args,\n+            &Struct(struct_def, selflike_fields),\n+        )\n     }\n \n     fn expand_static_struct_method_body(\n@@ -1531,7 +1485,7 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         selflike_args: &[P<Expr>],\n         struct_def: &'a VariantData,\n-        copy: bool,\n+        copy_fields: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, struct_field, sp| {\n             selflike_args\n@@ -1550,7 +1504,7 @@ impl<'a> TraitDef<'a> {\n                             }),\n                         ),\n                     );\n-                    if copy {\n+                    if copy_fields {\n                         field_expr = cx.expr_block(\n                             cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n                         );"}, {"sha": "077f33bb99cf7ad5e74fda657454ed21814aa711", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -38,22 +38,8 @@ impl ConstantCx {\n pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n-        let unevaluated = match fx.monomorphize(constant.literal) {\n-            ConstantKind::Ty(_) => unreachable!(),\n-            ConstantKind::Unevaluated(uv, _) => uv,\n-            ConstantKind::Val(..) => continue,\n-        };\n-\n-        if let Err(err) = fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n+        if eval_mir_constant(fx, constant).is_none() {\n             all_constants_ok = false;\n-            match err {\n-                ErrorHandled::Reported(_) => {\n-                    fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n-                }\n-                ErrorHandled::TooGeneric => {\n-                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n-                }\n-            }\n         }\n     }\n     all_constants_ok\n@@ -80,15 +66,15 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n }\n \n pub(crate) fn eval_mir_constant<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n-) -> (ConstValue<'tcx>, Ty<'tcx>) {\n+) -> Option<(ConstValue<'tcx>, Ty<'tcx>)> {\n     let constant_kind = fx.monomorphize(constant.literal);\n     let uv = match constant_kind {\n         ConstantKind::Ty(const_) => match const_.kind() {\n             ty::ConstKind::Unevaluated(uv) => uv.expand(),\n             ty::ConstKind::Value(val) => {\n-                return (fx.tcx.valtree_to_const_val((const_.ty(), val)), const_.ty());\n+                return Some((fx.tcx.valtree_to_const_val((const_.ty(), val)), const_.ty()));\n             }\n             err => span_bug!(\n                 constant.span,\n@@ -102,22 +88,31 @@ pub(crate) fn eval_mir_constant<'tcx>(\n             span_bug!(constant.span, \"MIR constant refers to static\");\n         }\n         ConstantKind::Unevaluated(uv, _) => uv,\n-        ConstantKind::Val(val, _) => return (val, constant_kind.ty()),\n+        ConstantKind::Val(val, _) => return Some((val, constant_kind.ty())),\n     };\n \n-    (\n-        fx.tcx.const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).unwrap_or_else(|_err| {\n-            span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n-        }),\n-        constant_kind.ty(),\n-    )\n+    let val = fx\n+        .tcx\n+        .const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None)\n+        .map_err(|err| match err {\n+            ErrorHandled::Reported(_) => {\n+                fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n+            }\n+            ErrorHandled::TooGeneric => {\n+                span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n+            }\n+        })\n+        .ok();\n+    val.map(|val| (val, constant_kind.ty()))\n }\n \n pub(crate) fn codegen_constant_operand<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n-    let (const_val, ty) = eval_mir_constant(fx, constant);\n+    let (const_val, ty) = eval_mir_constant(fx, constant).unwrap_or_else(|| {\n+        span_bug!(constant.span, \"erroneous constant not captured by required_consts\")\n+    });\n \n     codegen_const_value(fx, const_val, ty)\n }\n@@ -453,20 +448,13 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n     assert!(cx.todo.is_empty(), \"{:?}\", cx.todo);\n }\n \n+/// Used only for intrinsic implementations that need a compile-time constant\n pub(crate) fn mir_operand_get_const_val<'tcx>(\n     fx: &FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> Option<ConstValue<'tcx>> {\n     match operand {\n-        Operand::Constant(const_) => match fx.monomorphize(const_.literal) {\n-            ConstantKind::Ty(const_) => Some(\n-                const_.eval_for_mir(fx.tcx, ParamEnv::reveal_all()).try_to_value(fx.tcx).unwrap(),\n-            ),\n-            ConstantKind::Val(val, _) => Some(val),\n-            ConstantKind::Unevaluated(uv, _) => {\n-                Some(fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), uv, None).unwrap())\n-            }\n-        },\n+        Operand::Constant(const_) => Some(eval_mir_constant(fx, const_).unwrap().0),\n         // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored\n         // inside a temporary before being passed to the intrinsic requiring the const argument.\n         // This code tries to find a single constant defining definition of the referenced local."}, {"sha": "70ff5c9617b7a8c7c3ecdf008467d18eb924fb0d", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -83,7 +83,20 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n         let llfn = if tcx.sess.target.arch == \"x86\" &&\n             let Some(dllimport) = common::get_dllimport(tcx, instance_def_id, sym)\n         {\n-            cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi)\n+            // Fix for https://github.com/rust-lang/rust/issues/104453\n+            // On x86 Windows, LLVM uses 'L' as the prefix for any private\n+            // global symbols, so when we create an undecorated function symbol\n+            // that begins with an 'L' LLVM misinterprets that as a private\n+            // global symbol that it created and so fails the compilation at a\n+            // later stage since such a symbol must have a definition.\n+            //\n+            // To avoid this, we set the Storage Class to \"DllImport\" so that\n+            // LLVM will prefix the name with `__imp_`. Ideally, we'd like the\n+            // existing logic below to set the Storage Class, but it has an\n+            // exemption for MinGW for backwards compatability.\n+            let llfn = cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi);\n+            unsafe { llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport); }\n+            llfn\n         } else {\n             cx.declare_fn(sym, fn_abi)\n         };"}, {"sha": "53ff3c24096262207ff95b19e35f1142ca2b2c71", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -42,7 +42,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         self.cx.tcx().const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).map_err(|err| {\n-            self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+            match err {\n+                ErrorHandled::Reported(_) => {\n+                    self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+                }\n+                ErrorHandled::TooGeneric => {\n+                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n+                }\n+            }\n             err\n         })\n     }"}, {"sha": "14c8c88028bdac0448ad5321272730a4842fcfe0", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         self.pretty_print_dyn_existential(predicates)\n     }"}, {"sha": "e744ed2dcc54733e1fcf8190f97c2ba2c6fcb3a2", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -3000,7 +3000,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn compute_object_lifetime_bound(\n         &self,\n         span: Span,\n-        existential_predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        existential_predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Option<ty::Region<'tcx>> // if None, use the default\n     {\n         let tcx = self.tcx();"}, {"sha": "cf3b37f0a25088e4e5f00624a8ef172df8b6475a", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -748,7 +748,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         &self,\n         a: Ty<'tcx>,\n         b: Ty<'tcx>,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n         b_region: ty::Region<'tcx>,\n     ) -> CoerceResult<'tcx> {\n         if !self.tcx.features().dyn_star {"}, {"sha": "b8aff69b3719d46b4fb3ffc9847d7a179ac3dc76", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -543,7 +543,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+                _predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Err(NonTrivialPath)\n             }"}, {"sha": "589b4d6a10ff13da19e4de7524f0e59497e11d21", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1159,7 +1159,7 @@ impl<'tcx> LateContext<'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+                _predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Ok(())\n             }"}, {"sha": "b469eebfad993836e852bc07bb6ed7f104bcd348", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -298,7 +298,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<Ty\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n+    for ty::List<ty::PolyExistentialPredicate<'tcx>>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n@@ -379,7 +379,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,\n-    &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+    &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     &'tcx traits::ImplSource<'tcx, ()>,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,"}, {"sha": "9a58a196ed721cd6369794c02849de99a10d13f9", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,5 +1,4 @@\n use crate::mir::interpret::LitToConstInput;\n-use crate::mir::ConstantKind;\n use crate::ty::{self, DefIdTree, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n@@ -230,20 +229,6 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    /// Tries to evaluate the constant if it is `Unevaluated` and creates a ConstValue if the\n-    /// evaluation succeeds. If it doesn't succeed, returns the unevaluated constant.\n-    pub fn eval_for_mir(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> ConstantKind<'tcx> {\n-        if let Some(val) = self.kind().try_eval_for_mir(tcx, param_env) {\n-            match val {\n-                Ok(const_val) => ConstantKind::from_value(const_val, self.ty()),\n-                Err(guar) => ConstantKind::Ty(tcx.const_error_with_guaranteed(self.ty(), guar)),\n-            }\n-        } else {\n-            ConstantKind::Ty(self)\n-        }\n-    }\n-\n     #[inline]\n     /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n     pub fn eval_bits(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {"}, {"sha": "13695089eb828a6043172695bcc5a56e440bd22b", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -17,11 +17,11 @@ use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n-    ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, ExistentialPredicate, FloatTy,\n-    FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List,\n-    ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy, Region,\n-    RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy,\n-    Visibility,\n+    ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, FloatTy, FloatVar, FloatVid,\n+    GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n+    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy,\n+    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n+    UintTy, Visibility,\n };\n use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n use rustc_ast as ast;\n@@ -109,7 +109,7 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type Mutability = hir::Mutability;\n     type Movability = hir::Movability;\n     type PolyFnSig = PolyFnSig<'tcx>;\n-    type ListBinderExistentialPredicate = &'tcx List<Binder<'tcx, ExistentialPredicate<'tcx>>>;\n+    type ListBinderExistentialPredicate = &'tcx List<PolyExistentialPredicate<'tcx>>;\n     type BinderListTy = Binder<'tcx, &'tcx List<Ty<'tcx>>>;\n     type ListTy = &'tcx List<Ty<'tcx>>;\n     type ProjectionTy = ty::ProjectionTy<'tcx>;\n@@ -140,8 +140,7 @@ pub struct CtxtInterners<'tcx> {\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind<'tcx>>,\n-    poly_existential_predicates:\n-        InternedSet<'tcx, List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>>,\n+    poly_existential_predicates: InternedSet<'tcx, List<PolyExistentialPredicate<'tcx>>>,\n     predicate: InternedSet<'tcx, PredicateS<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n@@ -1810,7 +1809,7 @@ nop_lift! {const_; Const<'a> => Const<'tcx>}\n nop_lift! {const_allocation; ConstAllocation<'a> => ConstAllocation<'tcx>}\n nop_lift! {predicate; Predicate<'a> => Predicate<'tcx>}\n \n-nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n+nop_list_lift! {poly_existential_predicates; PolyExistentialPredicate<'a> => PolyExistentialPredicate<'tcx>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n nop_list_lift! {projs; ProjectionKind => ProjectionKind}\n@@ -2265,7 +2264,7 @@ slice_interners!(\n     substs: _intern_substs(GenericArg<'tcx>),\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo<'tcx>),\n     poly_existential_predicates:\n-        _intern_poly_existential_predicates(ty::Binder<'tcx, ExistentialPredicate<'tcx>>),\n+        _intern_poly_existential_predicates(PolyExistentialPredicate<'tcx>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n     place_elems: _intern_place_elems(PlaceElem<'tcx>),\n@@ -2544,7 +2543,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn mk_dynamic(\n         self,\n-        obj: &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>,\n+        obj: &'tcx List<PolyExistentialPredicate<'tcx>>,\n         reg: ty::Region<'tcx>,\n         repr: DynKind,\n     ) -> Ty<'tcx> {\n@@ -2682,8 +2681,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn intern_poly_existential_predicates(\n         self,\n-        eps: &[ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n-    ) -> &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n+        eps: &[PolyExistentialPredicate<'tcx>],\n+    ) -> &'tcx List<PolyExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n         assert!(\n             eps.array_windows()\n@@ -2767,10 +2766,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn mk_poly_existential_predicates<\n-        I: InternAs<\n-            [ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n-            &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>,\n-        >,\n+        I: InternAs<[PolyExistentialPredicate<'tcx>], &'tcx List<PolyExistentialPredicate<'tcx>>>,\n     >(\n         self,\n         iter: I,"}, {"sha": "a61f41b9c580f02086e36a283f1e9eabada4eac4", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -69,9 +69,7 @@ pub enum TypeError<'tcx> {\n     CyclicTy(Ty<'tcx>),\n     CyclicConst(ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n-    ExistentialMismatch(\n-        ExpectedFound<&'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>>,\n-    ),\n+    ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>>),\n     ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<ty::Const<'tcx>>),\n "}, {"sha": "b4779655252f90aa637ee1e541b43904eecb6d30", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -94,9 +94,10 @@ pub use self::sty::{\n     BoundVariableKind, CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid,\n     EarlyBoundRegion, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig,\n     FreeRegion, GenSig, GeneratorSubsts, GeneratorSubstsParts, InlineConstSubsts,\n-    InlineConstSubstsParts, ParamConst, ParamTy, PolyExistentialProjection,\n-    PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind,\n-    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts, VarianceDiagInfo,\n+    InlineConstSubstsParts, ParamConst, ParamTy, PolyExistentialPredicate,\n+    PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef,\n+    ProjectionTy, Region, RegionKind, RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts,\n+    VarianceDiagInfo,\n };\n pub use self::trait_def::TraitDef;\n "}, {"sha": "667298b9b5b1316ff2738e5c08b1ceab2502be75", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -63,7 +63,7 @@ pub trait Printer<'tcx>: Sized {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error>;\n \n     fn print_const(self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error>;\n@@ -308,9 +308,7 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, P: Printer<'tcx>> Print<'tcx, P>\n-    for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n-{\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>> {\n     type Output = P::DynExistential;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {"}, {"sha": "a0c076cbbb245607024cd544f556220c4ff64471", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1060,7 +1060,7 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn pretty_print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         // Generate the main trait ref, including associated types.\n         let mut first = true;\n@@ -1772,7 +1772,7 @@ impl<'tcx> Printer<'tcx> for FmtPrinter<'_, 'tcx> {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         self.pretty_print_dyn_existential(predicates)\n     }\n@@ -2530,12 +2530,12 @@ pub struct PrintClosureAsImpl<'tcx> {\n forward_display_to_print! {\n     ty::Region<'tcx>,\n     Ty<'tcx>,\n-    &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+    &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ty::Const<'tcx>,\n \n     // HACK(eddyb) these are exhaustive instead of generic,\n     // because `for<'tcx>` isn't possible yet.\n-    ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>,\n+    ty::PolyExistentialPredicate<'tcx>,\n     ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     ty::Binder<'tcx, ty::ExistentialTraitRef<'tcx>>,\n     ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,"}, {"sha": "0adc700586d9cc622868a4e02fda29190a5f01e6", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -658,7 +658,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     if is_match { Ok(a) } else { Err(TypeError::ConstMismatch(expected_found(relation, a, b))) }\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: Self,"}, {"sha": "6be8fdd7cd795ab53f0f9388ada888d6c1352764", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -586,7 +586,7 @@ impl<'tcx, T: TypeVisitable<'tcx>> TypeSuperVisitable<'tcx> for ty::Binder<'tcx,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_poly_existential_predicates(v))\n     }"}, {"sha": "e2a7b09de6ab452f48c0df79644a89d1d906606c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -703,7 +703,9 @@ impl<'tcx> ExistentialPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Binder<'tcx, ExistentialPredicate<'tcx>> {\n+pub type PolyExistentialPredicate<'tcx> = Binder<'tcx, ExistentialPredicate<'tcx>>;\n+\n+impl<'tcx> PolyExistentialPredicate<'tcx> {\n     /// Given an existential predicate like `?Self: PartialEq<u32>` (e.g., derived from `dyn PartialEq<u32>`),\n     /// and a concrete type `self_ty`, returns a full predicate where the existentially quantified variable `?Self`\n     /// has been replaced with `self_ty` (e.g., `self_ty: PartialEq<u32>`, in our example).\n@@ -727,7 +729,7 @@ impl<'tcx> Binder<'tcx, ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n+impl<'tcx> List<ty::PolyExistentialPredicate<'tcx>> {\n     /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n     /// A Rust trait object type consists (in addition to a lifetime bound)"}, {"sha": "c60a2f4671d6c4d841565f9aaba8bb6f67279fa7", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -244,7 +244,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n \n     fn print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         let mut first = true;\n         for p in predicates {"}, {"sha": "87128e0f893a263edb6a8b9a6877f697338d1da7", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -12,8 +12,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n-    self, Binder, Const, ExistentialPredicate, FloatTy, FnSig, IntTy, List, Region, RegionKind,\n-    TermKind, Ty, TyCtxt, UintTy,\n+    self, Const, ExistentialPredicate, FloatTy, FnSig, IntTy, List, Region, RegionKind, TermKind,\n+    Ty, TyCtxt, UintTy,\n };\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::sym;\n@@ -226,7 +226,7 @@ fn encode_fnsig<'tcx>(\n /// Rust types that are not used at the FFI boundary.\n fn encode_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    predicate: Binder<'tcx, ExistentialPredicate<'tcx>>,\n+    predicate: ty::PolyExistentialPredicate<'tcx>,\n     dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n     options: EncodeTyOptions,\n ) -> String {\n@@ -261,13 +261,13 @@ fn encode_predicate<'tcx>(\n /// Rust types that are not used at the FFI boundary.\n fn encode_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    predicates: &List<Binder<'tcx, ExistentialPredicate<'tcx>>>,\n+    predicates: &List<ty::PolyExistentialPredicate<'tcx>>,\n     dict: &mut FxHashMap<DictKey<'tcx>, usize>,\n     options: EncodeTyOptions,\n ) -> String {\n     // <predicate1[..predicateN]>E as part of vendor extended type\n     let mut s = String::new();\n-    let predicates: Vec<Binder<'tcx, ExistentialPredicate<'tcx>>> =\n+    let predicates: Vec<ty::PolyExistentialPredicate<'tcx>> =\n         predicates.iter().map(|predicate| predicate).collect();\n     for predicate in predicates {\n         s.push_str(&encode_predicate(tcx, predicate, dict, options));"}, {"sha": "6ad0a7d29110c929c51e3ecd71978e29c61b9fcd", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -502,7 +502,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n     fn print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         // Okay, so this is a bit tricky. Imagine we have a trait object like\n         // `dyn for<'a> Foo<'a, Bar = &'a ()>`. When we mangle this, the"}, {"sha": "fce92c66ee8c75ec646eefea4147d27cf0fb9440", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -758,7 +758,7 @@ impl<'tcx> WfPredicates<'tcx> {\n     fn from_object_ty(\n         &mut self,\n         ty: Ty<'tcx>,\n-        data: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        data: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n         region: ty::Region<'tcx>,\n     ) {\n         // Imagine a type like this:\n@@ -822,7 +822,7 @@ impl<'tcx> WfPredicates<'tcx> {\n /// `infer::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    existential_predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+    existential_predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n ) -> Vec<ty::Region<'tcx>> {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically"}, {"sha": "36bd466496e12892e5e2ca22d1e84386ffb92f1d", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -634,7 +634,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n }\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>>>\n-    for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n+    for &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>\n {\n     fn lower_into(\n         self,"}, {"sha": "141cbc7669b0b42e13a8c8af115de2480f6dcb7c", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -659,7 +659,7 @@ macro_rules! nonzero_signed_operations {\n                 #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n                 #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n                                 stringify!($Int), \"::MIN)?;\")]\n-                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                #[doc = concat!(\"# let max = \", stringify!($Ty), \"::new(\",\n                                 stringify!($Int), \"::MAX)?;\")]\n                 ///\n                 /// assert_eq!(pos, pos.wrapping_abs());"}, {"sha": "7128d542acfe9d0609c165c3c7b074bd904c2d0c", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -47,8 +47,6 @@ fn cc2ar(cc: &Path, target: TargetSelection) -> Option<PathBuf> {\n         Some(PathBuf::from(\"ar\"))\n     } else if target.contains(\"vxworks\") {\n         Some(PathBuf::from(\"wr-ar\"))\n-    } else if target.contains(\"android\") {\n-        Some(cc.parent().unwrap().join(PathBuf::from(\"llvm-ar\")))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();\n@@ -221,22 +219,12 @@ fn set_compiler(\n }\n \n pub(crate) fn ndk_compiler(compiler: Language, triple: &str, ndk: &Path) -> PathBuf {\n-    let mut triple_iter = triple.split(\"-\");\n-    let triple_translated = if let Some(arch) = triple_iter.next() {\n-        let arch_new = match arch {\n-            \"arm\" | \"armv7\" | \"armv7neon\" | \"thumbv7\" | \"thumbv7neon\" => \"armv7a\",\n-            other => other,\n-        };\n-        std::iter::once(arch_new).chain(triple_iter).collect::<Vec<&str>>().join(\"-\")\n-    } else {\n-        triple.to_string()\n-    };\n-\n-    // API 19 is the earliest API level supported by NDK r25b but AArch64 and x86_64 support\n-    // begins at API level 21.\n-    let api_level =\n-        if triple.contains(\"aarch64\") || triple.contains(\"x86_64\") { \"21\" } else { \"19\" };\n-    let compiler = format!(\"{}{}-{}\", triple_translated, api_level, compiler.clang());\n+    let triple_translated = triple\n+        .replace(\"armv7neon\", \"arm\")\n+        .replace(\"armv7\", \"arm\")\n+        .replace(\"thumbv7neon\", \"arm\")\n+        .replace(\"thumbv7\", \"arm\");\n+    let compiler = format!(\"{}-{}\", triple_translated, compiler.clang());\n     ndk.join(\"bin\").join(compiler)\n }\n "}, {"sha": "7a875c960e13312d77d11983c0f4bab304b4c554", "filename": "src/ci/docker/host-x86_64/arm-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -6,7 +6,7 @@ RUN sh /scripts/android-base-apt-get.sh\n \n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_ndk android-ndk-r25b-linux.zip\n+    download_and_make_toolchain android-ndk-r15c-linux-x86_64.zip arm 14\n \n RUN dpkg --add-architecture i386 && \\\n     apt-get update && \\\n@@ -30,7 +30,7 @@ ENV PATH=$PATH:/android/sdk/platform-tools\n \n ENV TARGETS=arm-linux-androideabi\n \n-ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/\n+ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n \n ENV SCRIPT python3 ../x.py --stage 2 test --host='' --target $TARGETS\n "}, {"sha": "2328db4ab8b1d126dd774a67a744afb990bde1e0", "filename": "src/ci/docker/host-x86_64/dist-android/Dockerfile", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -6,7 +6,14 @@ RUN sh /scripts/android-base-apt-get.sh\n # ndk\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_ndk android-ndk-r25b-linux.zip\n+    download_ndk android-ndk-r15c-linux-x86_64.zip && \\\n+    make_standalone_toolchain arm 14 && \\\n+    make_standalone_toolchain x86 14 && \\\n+    make_standalone_toolchain arm 21 && \\\n+    make_standalone_toolchain x86 21 && \\\n+    make_standalone_toolchain arm64 21 && \\\n+    make_standalone_toolchain x86_64 21 && \\\n+    remove_ndk\n \n # env\n ENV TARGETS=arm-linux-androideabi\n@@ -19,12 +26,12 @@ ENV TARGETS=$TARGETS,x86_64-linux-android\n ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-profiler \\\n-      --arm-linux-androideabi-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n-      --armv7-linux-androideabi-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n-      --thumbv7neon-linux-androideabi-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n-      --i686-linux-android-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n-      --aarch64-linux-android-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n-      --x86_64-linux-android-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n+      --arm-linux-androideabi-ndk=/android/ndk/arm-14 \\\n+      --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\\n+      --thumbv7neon-linux-androideabi-ndk=/android/ndk/arm-14 \\\n+      --i686-linux-android-ndk=/android/ndk/x86-14 \\\n+      --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n+      --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n       --disable-docs\n \n ENV SCRIPT python3 ../x.py dist --host='' --target $TARGETS"}, {"sha": "ba70c62ea3081a96725e3c942e9b21b3d46100f7", "filename": "src/ci/docker/scripts/android-ndk.sh", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -4,10 +4,28 @@ set -ex\n URL=https://dl.google.com/android/repository\n \n download_ndk() {\n-    mkdir /android/\n-    cd /android\n+    mkdir -p /android/ndk\n+    cd /android/ndk\n     curl -fO $URL/$1\n     unzip -q $1\n     rm $1\n     mv android-ndk-* ndk\n }\n+\n+make_standalone_toolchain() {\n+    # See https://developer.android.com/ndk/guides/standalone_toolchain.htm\n+    python3 /android/ndk/ndk/build/tools/make_standalone_toolchain.py \\\n+        --install-dir /android/ndk/$1-$2 \\\n+        --arch $1 \\\n+        --api $2\n+}\n+\n+remove_ndk() {\n+    rm -rf /android/ndk/ndk\n+}\n+\n+download_and_make_toolchain() {\n+    download_ndk $1 && \\\n+    make_standalone_toolchain $2 $3 && \\\n+    remove_ndk\n+}"}, {"sha": "6995778a93d6158a0c854d5ecedf3f1da125f1d6", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -257,12 +257,12 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         StructFieldItem(f) => ItemEnum::StructField(f.into_tcx(tcx)),\n         EnumItem(e) => ItemEnum::Enum(e.into_tcx(tcx)),\n         VariantItem(v) => ItemEnum::Variant(v.into_tcx(tcx)),\n-        FunctionItem(f) => ItemEnum::Function(from_function(f, header.unwrap(), tcx)),\n-        ForeignFunctionItem(f) => ItemEnum::Function(from_function(f, header.unwrap(), tcx)),\n+        FunctionItem(f) => ItemEnum::Function(from_function(f, true, header.unwrap(), tcx)),\n+        ForeignFunctionItem(f) => ItemEnum::Function(from_function(f, false, header.unwrap(), tcx)),\n         TraitItem(t) => ItemEnum::Trait((*t).into_tcx(tcx)),\n         TraitAliasItem(t) => ItemEnum::TraitAlias(t.into_tcx(tcx)),\n-        MethodItem(m, _) => ItemEnum::Method(from_function_method(m, true, header.unwrap(), tcx)),\n-        TyMethodItem(m) => ItemEnum::Method(from_function_method(m, false, header.unwrap(), tcx)),\n+        MethodItem(m, _) => ItemEnum::Function(from_function(m, true, header.unwrap(), tcx)),\n+        TyMethodItem(m) => ItemEnum::Function(from_function(m, false, header.unwrap(), tcx)),\n         ImplItem(i) => ItemEnum::Impl((*i).into_tcx(tcx)),\n         StaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignStaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n@@ -618,6 +618,7 @@ impl FromWithTcx<clean::Impl> for Impl {\n \n pub(crate) fn from_function(\n     function: Box<clean::Function>,\n+    has_body: bool,\n     header: rustc_hir::FnHeader,\n     tcx: TyCtxt<'_>,\n ) -> Function {\n@@ -626,20 +627,6 @@ pub(crate) fn from_function(\n         decl: decl.into_tcx(tcx),\n         generics: generics.into_tcx(tcx),\n         header: from_fn_header(&header),\n-    }\n-}\n-\n-pub(crate) fn from_function_method(\n-    function: Box<clean::Function>,\n-    has_body: bool,\n-    header: rustc_hir::FnHeader,\n-    tcx: TyCtxt<'_>,\n-) -> Method {\n-    let clean::Function { decl, generics } = *function;\n-    Method {\n-        decl: decl.into_tcx(tcx),\n-        generics: generics.into_tcx(tcx),\n-        header: from_fn_header(&header),\n         has_body,\n     }\n }\n@@ -759,14 +746,13 @@ impl FromWithTcx<ItemType> for ItemKind {\n             Struct => ItemKind::Struct,\n             Union => ItemKind::Union,\n             Enum => ItemKind::Enum,\n-            Function => ItemKind::Function,\n+            Function | TyMethod | Method => ItemKind::Function,\n             Typedef => ItemKind::Typedef,\n             OpaqueTy => ItemKind::OpaqueTy,\n             Static => ItemKind::Static,\n             Constant => ItemKind::Constant,\n             Trait => ItemKind::Trait,\n             Impl => ItemKind::Impl,\n-            TyMethod | Method => ItemKind::Method,\n             StructField => ItemKind::StructField,\n             Variant => ItemKind::Variant,\n             Macro => ItemKind::Macro,"}, {"sha": "e4df1332521a782750061c446d6382d8b96f007a", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -223,15 +223,14 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                     false\n                 }\n \n-                types::ItemEnum::Method(_)\n+                types::ItemEnum::Function(_)\n                 | types::ItemEnum::Module(_)\n                 | types::ItemEnum::AssocConst { .. }\n                 | types::ItemEnum::AssocType { .. } => true,\n                 types::ItemEnum::ExternCrate { .. }\n                 | types::ItemEnum::Import(_)\n                 | types::ItemEnum::StructField(_)\n                 | types::ItemEnum::Variant(_)\n-                | types::ItemEnum::Function(_)\n                 | types::ItemEnum::TraitAlias(_)\n                 | types::ItemEnum::Impl(_)\n                 | types::ItemEnum::Typedef(_)"}, {"sha": "dd40f3507523c1a612bd7793e98ca0ead7717fe1", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -9,7 +9,7 @@ use std::path::PathBuf;\n use serde::{Deserialize, Serialize};\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 22;\n+pub const FORMAT_VERSION: u32 = 23;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -210,7 +210,6 @@ pub enum ItemKind {\n     Constant,\n     Trait,\n     TraitAlias,\n-    Method,\n     Impl,\n     Static,\n     ForeignType,\n@@ -243,7 +242,6 @@ pub enum ItemEnum {\n \n     Trait(Trait),\n     TraitAlias(TraitAlias),\n-    Method(Method),\n     Impl(Impl),\n \n     Typedef(Typedef),\n@@ -415,18 +413,12 @@ pub enum Abi {\n     Other(String),\n }\n \n+/// Represents a function (including methods and other associated functions)\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub header: Header,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\n-pub struct Method {\n-    pub decl: FnDecl,\n-    pub generics: Generics,\n-    pub header: Header,\n     pub has_body: bool,\n }\n "}, {"sha": "9a3cd9ebe1b4ba57da084233d33404e1abd829cf", "filename": "src/test/run-make/raw-dylib-import-name-type/driver.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fdriver.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -3,6 +3,7 @@\n \n #[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"undecorated\")]\n extern \"C\" {\n+    fn LooksLikeAPrivateGlobal(i: i32);\n     fn cdecl_fn_undecorated(i: i32);\n     #[link_name = \"cdecl_fn_undecorated2\"]\n     fn cdecl_fn_undecorated_renamed(i: i32);\n@@ -84,6 +85,13 @@ extern {\n \n pub fn main() {\n     unsafe {\n+        // Regression test for #104453\n+        // On x86 LLVM uses 'L' as the prefix for private globals (PrivateGlobalPrefix), which\n+        // causes it to believe that undecorated functions starting with 'L' are actually temporary\n+        // symbols that it generated, which causes a later check to fail as the symbols we are\n+        // creating don't have definitions (whereas all temporary symbols do).\n+        LooksLikeAPrivateGlobal(13);\n+\n         cdecl_fn_undecorated(1);\n         cdecl_fn_undecorated_renamed(10);\n         cdecl_fn_noprefix(2);"}, {"sha": "23c1e489e5ea21ac905b4c7a20870c0df2d663f3", "filename": "src/test/run-make/raw-dylib-import-name-type/extern.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.c", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.c?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,6 +1,11 @@\n #include <stdio.h>\n #include <stdint.h>\n \n+void _cdecl LooksLikeAPrivateGlobal(int i) {\n+    printf(\"LooksLikeAPrivateGlobal(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n void _cdecl cdecl_fn_undecorated(int i) {\n     printf(\"cdecl_fn_undecorated(%d)\\n\", i);\n     fflush(stdout);"}, {"sha": "498e90e862d4b76dda3678f60b1284c05342dda2", "filename": "src/test/run-make/raw-dylib-import-name-type/extern.gnu.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.gnu.def", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.gnu.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.gnu.def?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,5 +1,6 @@\n LIBRARY extern\n EXPORTS\n+    LooksLikeAPrivateGlobal\n     cdecl_fn_undecorated\n     cdecl_fn_undecorated2\n     cdecl_fn_noprefix"}, {"sha": "cddb88bb8b5f03686a6870e955afbe78ed16e54f", "filename": "src/test/run-make/raw-dylib-import-name-type/extern.msvc.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.msvc.def", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.msvc.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.msvc.def?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,5 +1,6 @@\n LIBRARY extern\n EXPORTS\n+    LooksLikeAPrivateGlobal\n     cdecl_fn_undecorated\n     cdecl_fn_undecorated2\n     cdecl_fn_noprefix"}, {"sha": "a2a2bfeec7d97f8ff26e45c73b316b5e8d7274cc", "filename": "src/test/run-make/raw-dylib-import-name-type/output.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Foutput.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Foutput.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Foutput.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,3 +1,4 @@\n+LooksLikeAPrivateGlobal(13)\n cdecl_fn_undecorated(1)\n cdecl_fn_undecorated2(10)\n cdecl_fn_noprefix(2)"}, {"sha": "fa88b6113a5818cc783a39e3404cd3d947274f4b", "filename": "src/test/rustdoc-json/impls/import_from_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frustdoc-json%2Fimpls%2Fimport_from_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Frustdoc-json%2Fimpls%2Fimport_from_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fimpls%2Fimport_from_private.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -8,7 +8,7 @@ mod bar {\n     pub struct Baz;\n     // @set impl = \"$.index[*][?(@.kind=='impl')].id\"\n     impl Baz {\n-        // @set doit = \"$.index[*][?(@.kind=='method')].id\"\n+        // @set doit = \"$.index[*][?(@.kind=='function')].id\"\n         pub fn doit() {}\n     }\n }"}, {"sha": "a63cbd4ca7edea3d2227db9b81300925274fe3c4", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -463,16 +463,14 @@ struct PackedNonCopy(u8);\n impl ::core::clone::Clone for PackedNonCopy {\n     #[inline]\n     fn clone(&self) -> PackedNonCopy {\n-        let Self(ref __self_0_0) = *self;\n-        PackedNonCopy(::core::clone::Clone::clone(__self_0_0))\n+        PackedNonCopy(::core::clone::Clone::clone(&self.0))\n     }\n }\n #[automatically_derived]\n impl ::core::fmt::Debug for PackedNonCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        let Self(ref __self_0_0) = *self;\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedNonCopy\",\n-            &__self_0_0)\n+            &&self.0)\n     }\n }\n #[automatically_derived]\n@@ -485,20 +483,15 @@ impl ::core::default::Default for PackedNonCopy {\n #[automatically_derived]\n impl ::core::hash::Hash for PackedNonCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        let Self(ref __self_0_0) = *self;\n-        ::core::hash::Hash::hash(__self_0_0, state)\n+        ::core::hash::Hash::hash(&self.0, state)\n     }\n }\n #[automatically_derived]\n impl ::core::marker::StructuralPartialEq for PackedNonCopy { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for PackedNonCopy {\n     #[inline]\n-    fn eq(&self, other: &PackedNonCopy) -> bool {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        *__self_0_0 == *__self_1_0\n-    }\n+    fn eq(&self, other: &PackedNonCopy) -> bool { self.0 == other.0 }\n }\n #[automatically_derived]\n impl ::core::marker::StructuralEq for PackedNonCopy { }\n@@ -516,18 +509,14 @@ impl ::core::cmp::PartialOrd for PackedNonCopy {\n     #[inline]\n     fn partial_cmp(&self, other: &PackedNonCopy)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        ::core::cmp::PartialOrd::partial_cmp(__self_0_0, __self_1_0)\n+        ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)\n     }\n }\n #[automatically_derived]\n impl ::core::cmp::Ord for PackedNonCopy {\n     #[inline]\n     fn cmp(&self, other: &PackedNonCopy) -> ::core::cmp::Ordering {\n-        let Self(ref __self_0_0) = *self;\n-        let Self(ref __self_1_0) = *other;\n-        ::core::cmp::Ord::cmp(__self_0_0, __self_1_0)\n+        ::core::cmp::Ord::cmp(&self.0, &other.0)\n     }\n }\n "}, {"sha": "92750bec8b20c9bfaf771beeefdc96d140bced38", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -21,27 +21,27 @@ accept_pat!([p | q]);\n #[cfg(FALSE)]\n fn or_patterns() {\n     // Top level of `let`:\n-    let (A | B);\n+    let (| A | B);\n     let (A | B);\n     let (A | B): u8;\n     let (A | B) = 0;\n     let (A | B): u8 = 0;\n \n     // Top level of `for`:\n-    for A | B in 0 {}\n+    for | A | B in 0 {}\n     for A | B in 0 {}\n \n     // Top level of `while`:\n-    while let A | B = 0 {}\n+    while let | A | B = 0 {}\n     while let A | B = 0 {}\n \n     // Top level of `if`:\n-    if let A | B = 0 {}\n+    if let | A | B = 0 {}\n     if let A | B = 0 {}\n \n     // Top level of `match` arms:\n     match 0 {\n-        A | B => {}\n+        | A | B => {}\n         A | B => {}\n     }\n "}, {"sha": "ea00650d42aa19463d5ca42e2ace17a17d7b85c4", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -687,7 +687,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n fn matches_preds<'tcx>(\n     cx: &LateContext<'tcx>,\n     ty: Ty<'tcx>,\n-    preds: &'tcx [Binder<'tcx, ExistentialPredicate<'tcx>>],\n+    preds: &'tcx [ty::PolyExistentialPredicate<'tcx>],\n ) -> bool {\n     let infcx = cx.tcx.infer_ctxt().build();\n     preds.iter().all(|&p| match cx.tcx.erase_late_bound_regions(p) {"}, {"sha": "225651a997ed4fa1b7107e7ef99e9c1041abc945", "filename": "src/tools/jsondoclint/src/item_kind.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -17,7 +17,6 @@ pub(crate) enum Kind {\n     Constant,\n     Trait,\n     TraitAlias,\n-    Method,\n     Impl,\n     Static,\n     ForeignType,\n@@ -63,7 +62,6 @@ impl Kind {\n             // Only in traits\n             AssocConst => false,\n             AssocType => false,\n-            Method => false,\n \n             StructField => false, // Only in structs or variants\n             Variant => false,     // Only in enums\n@@ -74,7 +72,7 @@ impl Kind {\n         match self {\n             Kind::AssocConst => true,\n             Kind::AssocType => true,\n-            Kind::Method => true,\n+            Kind::Function => true,\n \n             Kind::Module => false,\n             Kind::ExternCrate => false,\n@@ -84,7 +82,6 @@ impl Kind {\n             Kind::Union => false,\n             Kind::Enum => false,\n             Kind::Variant => false,\n-            Kind::Function => false,\n             Kind::Typedef => false,\n             Kind::OpaqueTy => false,\n             Kind::Constant => false,\n@@ -134,7 +131,6 @@ impl Kind {\n             ItemEnum::Function(_) => Function,\n             ItemEnum::Trait(_) => Trait,\n             ItemEnum::TraitAlias(_) => TraitAlias,\n-            ItemEnum::Method(_) => Method,\n             ItemEnum::Impl(_) => Impl,\n             ItemEnum::Typedef(_) => Typedef,\n             ItemEnum::OpaqueTy(_) => OpaqueTy,\n@@ -164,7 +160,6 @@ impl Kind {\n             ItemKind::Import => Import,\n             ItemKind::Keyword => Keyword,\n             ItemKind::Macro => Macro,\n-            ItemKind::Method => Method,\n             ItemKind::Module => Module,\n             ItemKind::OpaqueTy => OpaqueTy,\n             ItemKind::Primitive => Primitive,"}, {"sha": "5b293a3c4f701fe8986904386e80f06c5a52d4e3", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -3,9 +3,9 @@ use std::hash::Hash;\n \n use rustdoc_json_types::{\n     Constant, Crate, DynTrait, Enum, FnDecl, Function, FunctionPointer, GenericArg, GenericArgs,\n-    GenericBound, GenericParamDef, Generics, Id, Impl, Import, ItemEnum, Method, Module, OpaqueTy,\n-    Path, Primitive, ProcMacro, Static, Struct, StructKind, Term, Trait, TraitAlias, Type,\n-    TypeBinding, TypeBindingKind, Typedef, Union, Variant, WherePredicate,\n+    GenericBound, GenericParamDef, Generics, Id, Impl, Import, ItemEnum, Module, OpaqueTy, Path,\n+    Primitive, ProcMacro, Static, Struct, StructKind, Term, Trait, TraitAlias, Type, TypeBinding,\n+    TypeBindingKind, Typedef, Union, Variant, WherePredicate,\n };\n \n use crate::{item_kind::Kind, Error, ErrorKind};\n@@ -67,7 +67,6 @@ impl<'a> Validator<'a> {\n                 ItemEnum::Function(x) => self.check_function(x),\n                 ItemEnum::Trait(x) => self.check_trait(x),\n                 ItemEnum::TraitAlias(x) => self.check_trait_alias(x),\n-                ItemEnum::Method(x) => self.check_method(x),\n                 ItemEnum::Impl(x) => self.check_impl(x),\n                 ItemEnum::Typedef(x) => self.check_typedef(x),\n                 ItemEnum::OpaqueTy(x) => self.check_opaque_ty(x),\n@@ -176,11 +175,6 @@ impl<'a> Validator<'a> {\n         x.params.iter().for_each(|i| self.check_generic_bound(i));\n     }\n \n-    fn check_method(&mut self, x: &'a Method) {\n-        self.check_fn_decl(&x.decl);\n-        self.check_generics(&x.generics);\n-    }\n-\n     fn check_impl(&mut self, x: &'a Impl) {\n         self.check_generics(&x.generics);\n         if let Some(path) = &x.trait_ {"}]}