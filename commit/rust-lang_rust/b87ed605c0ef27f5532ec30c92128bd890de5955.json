{"sha": "b87ed605c0ef27f5532ec30c92128bd890de5955", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4N2VkNjA1YzBlZjI3ZjU1MzJlYzMwYzkyMTI4YmQ4OTBkZTU5NTU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-15T00:18:49Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-15T23:13:56Z"}, "message": "std: Rename unstable::mutex::Mutex to StaticNativeMutex.\n\nThis better reflects its purpose and design.", "tree": {"sha": "55810612bec1de77a67738853ea98539582fa809", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55810612bec1de77a67738853ea98539582fa809"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b87ed605c0ef27f5532ec30c92128bd890de5955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b87ed605c0ef27f5532ec30c92128bd890de5955", "html_url": "https://github.com/rust-lang/rust/commit/b87ed605c0ef27f5532ec30c92128bd890de5955", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b87ed605c0ef27f5532ec30c92128bd890de5955/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75d92dbabe5bab3a1ca85c305a3773bca2e38145", "url": "https://api.github.com/repos/rust-lang/rust/commits/75d92dbabe5bab3a1ca85c305a3773bca2e38145", "html_url": "https://github.com/rust-lang/rust/commit/75d92dbabe5bab3a1ca85c305a3773bca2e38145"}], "stats": {"total": 134, "additions": 69, "deletions": 65}, "files": [{"sha": "bf6a6d54220d9fc0b5c2a8702133f57eae0c3d7b", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -15,7 +15,7 @@ use std::rt::rtio::{RemoteCallback, PausableIdleCallback, Callback, EventLoop};\n use std::rt::task::BlockedTask;\n use std::rt::task::Task;\n use std::sync::deque;\n-use std::unstable::mutex::Mutex;\n+use std::unstable::mutex::StaticNativeMutex;\n use std::unstable::raw;\n \n use TaskState;\n@@ -764,7 +764,7 @@ impl Scheduler {\n         // to it, but we're guaranteed that the task won't exit until we've\n         // unlocked the lock so there's no worry of this memory going away.\n         let cur = self.change_task_context(cur, next, |sched, mut task| {\n-            let lock: *mut Mutex = &mut task.nasty_deschedule_lock;\n+            let lock: *mut StaticNativeMutex = &mut task.nasty_deschedule_lock;\n             unsafe {\n                 let _guard = (*lock).lock();\n                 f(sched, BlockedTask::block(task.swap()));\n@@ -1453,8 +1453,8 @@ mod test {\n \n     #[test]\n     fn test_spawn_sched_blocking() {\n-        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n-        static mut LOCK: Mutex = MUTEX_INIT;\n+        use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers"}, {"sha": "c0c0ef3e24fc68882fbf36bc096fdf047d45b6f3", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -25,7 +25,7 @@ use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask, SendMessage};\n use std::task::TaskOpts;\n-use std::unstable::mutex::Mutex;\n+use std::unstable::mutex::StaticNativeMutex;\n use std::unstable::raw;\n \n use context::Context;\n@@ -65,7 +65,7 @@ pub struct GreenTask {\n     pool_id: uint,\n \n     // See the comments in the scheduler about why this is necessary\n-    nasty_deschedule_lock: Mutex,\n+    nasty_deschedule_lock: StaticNativeMutex,\n }\n \n pub enum TaskType {\n@@ -163,7 +163,7 @@ impl GreenTask {\n             task_type: task_type,\n             sched: None,\n             handle: None,\n-            nasty_deschedule_lock: unsafe { Mutex::new() },\n+            nasty_deschedule_lock: unsafe { StaticNativeMutex::new() },\n             task: Some(~Task::new()),\n         }\n     }\n@@ -322,7 +322,7 @@ impl GreenTask {\n     // uncontended except for when the task is rescheduled).\n     fn reawaken_remotely(mut ~self) {\n         unsafe {\n-            let mtx = &mut self.nasty_deschedule_lock as *mut Mutex;\n+            let mtx = &mut self.nasty_deschedule_lock as *mut StaticNativeMutex;\n             let handle = self.handle.get_mut_ref() as *mut SchedHandle;\n             let _guard = (*mtx).lock();\n             (*handle).send(RunOnce(self));"}, {"sha": "b1addc5cda53136f516e35719cb49fd53fe9e170", "filename": "src/libnative/bookkeeping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibnative%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibnative%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fbookkeeping.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -17,10 +17,10 @@\n //! The green counterpart for this is bookkeeping on sched pools.\n \n use std::sync::atomics;\n-use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n static mut TASK_COUNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n-static mut TASK_LOCK: Mutex = MUTEX_INIT;\n+static mut TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n pub fn increment() {\n     let _ = unsafe { TASK_COUNT.fetch_add(1, atomics::SeqCst) };"}, {"sha": "b33b54862dc2bcb0679da957246f536882850010", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -218,9 +218,9 @@ pub fn init() {\n     }\n \n     unsafe {\n-        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+        use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut INITIALIZED: bool = false;\n-        static mut LOCK: Mutex = MUTEX_INIT;\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n         let _guard = LOCK.lock();\n         if !INITIALIZED {"}, {"sha": "004cd6f311452dfde95e61b9225997295b979e6f", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -22,7 +22,7 @@\n \n use std::cast;\n use std::rt;\n-use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n use bookkeeping;\n use io::timer::{Req, Shutdown};\n@@ -37,7 +37,7 @@ static mut HELPER_CHAN: *mut Chan<Req> = 0 as *mut Chan<Req>;\n static mut HELPER_SIGNAL: imp::signal = 0 as imp::signal;\n \n pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n-    static mut LOCK: Mutex = MUTEX_INIT;\n+    static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     static mut INITIALIZED: bool = false;\n \n     unsafe {"}, {"sha": "e4a8c45eb0b934e5892888064d1289c7b971f265", "filename": "src/libnative/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -22,7 +22,7 @@ use std::rt::task::{Task, BlockedTask, SendMessage};\n use std::rt::thread::Thread;\n use std::rt;\n use std::task::TaskOpts;\n-use std::unstable::mutex::Mutex;\n+use std::unstable::mutex::StaticNativeMutex;\n use std::unstable::stack;\n \n use io;\n@@ -40,7 +40,7 @@ pub fn new(stack_bounds: (uint, uint)) -> ~Task {\n \n fn ops() -> ~Ops {\n     ~Ops {\n-        lock: unsafe { Mutex::new() },\n+        lock: unsafe { StaticNativeMutex::new() },\n         awoken: false,\n         io: io::IoFactory::new(),\n         // these *should* get overwritten\n@@ -109,7 +109,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n // This structure is the glue between channels and the 1:1 scheduling mode. This\n // structure is allocated once per task.\n struct Ops {\n-    lock: Mutex,       // native synchronization\n+    lock: StaticNativeMutex,       // native synchronization\n     awoken: bool,      // used to prevent spurious wakeups\n     io: io::IoFactory, // local I/O factory\n "}, {"sha": "61fc700c3c094f78b717c67d341deb1a7990e8ff", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -28,7 +28,7 @@ use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use sync::atomics;\n-use unstable::mutex::Mutex;\n+use unstable::mutex::StaticNativeMutex;\n use vec::OwnedVector;\n \n use mpsc = sync::mpsc_queue;\n@@ -53,7 +53,7 @@ pub struct Packet<T> {\n \n     // this lock protects various portions of this implementation during\n     // select()\n-    select_lock: Mutex,\n+    select_lock: StaticNativeMutex,\n }\n \n pub enum Failure {\n@@ -72,7 +72,7 @@ impl<T: Send> Packet<T> {\n             channels: atomics::AtomicInt::new(2),\n             port_dropped: atomics::AtomicBool::new(false),\n             sender_drain: atomics::AtomicInt::new(0),\n-            select_lock: unsafe { Mutex::new() },\n+            select_lock: unsafe { StaticNativeMutex::new() },\n         };\n         // see comments in inherit_blocker about why we grab this lock\n         unsafe { p.select_lock.lock_noguard() }"}, {"sha": "719ed62d03d0aaa65707319c5696db53680088d4", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -144,9 +144,9 @@ Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: || -> T) -> T {\n-    use unstable::mutex::{Mutex, MUTEX_INIT};\n+    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n-    static mut lock: Mutex = MUTEX_INIT;\n+    static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n     unsafe {\n         let _guard = lock.lock();"}, {"sha": "6f73265978bf4ecc4faa6f428b0aa59787576e4f", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -68,11 +68,11 @@ mod imp {\n     use option::{Option, Some, None};\n     use ptr::RawPtr;\n     use iter::Iterator;\n-    use unstable::mutex::{Mutex, MUTEX_INIT};\n+    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n \n     static mut global_args_ptr: uint = 0;\n-    static mut lock: Mutex = MUTEX_INIT;\n+    static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n     #[cfg(not(test))]\n     pub unsafe fn init(argc: int, argv: **u8) {"}, {"sha": "84fa528ebf130746d92a90f7f4d3cbbecd0d295d", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -152,8 +152,8 @@ pub mod dl {\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n-        use unstable::mutex::{Mutex, MUTEX_INIT};\n-        static mut lock: Mutex = MUTEX_INIT;\n+        use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence"}, {"sha": "d8d051236b3f7d7b905c4591d34c86ed59ac69c6", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -11,9 +11,9 @@\n //! A native mutex and condition variable type\n //!\n //! This module contains bindings to the platform's native mutex/condition\n-//! variable primitives. It provides a single type, `Mutex`, which can be\n-//! statically initialized via the `MUTEX_INIT` value. This object serves as both a\n-//! mutex and a condition variable simultaneously.\n+//! variable primitives. It provides a single type, `StaticNativeMutex`, which can be\n+//! statically initialized via the `NATIVE_MUTEX_INIT` value. This object serves as\n+//! both a mutex and a condition variable simultaneously.\n //!\n //! The lock is lazily initialized, but it can only be unsafely destroyed. A\n //! statically initialized lock doesn't necessarily have a time at which it can\n@@ -27,21 +27,23 @@\n //!\n //! # Example\n //!\n-//!     use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+//!     use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n //!\n //!     // Use a statically initialized mutex\n-//!     static mut lock: Mutex = MUTEX_INIT;\n+//!     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n //!\n //!     unsafe {\n-//!         lock.lock();\n-//!         lock.unlock();\n-//!     }\n+//!         let _guard = lock.lock();\n+//!     } // automatically unlocked here\n //!\n //!     // Use a normally initialized mutex\n-//!     let mut lock = Mutex::new();\n //!     unsafe {\n-//!         lock.lock();\n-//!         lock.unlock();\n+//!         let mut lock = StaticNativeMutex::new();\n+//!\n+//!         // sometimes the RAII guard isn't appropriate\n+//!         lock.lock_noguard();\n+//!         lock.unlock_noguard();\n+//!\n //!         lock.destroy();\n //!     }\n \n@@ -50,7 +52,9 @@\n use option::{Option, None, Some};\n use ops::Drop;\n \n-pub struct Mutex {\n+/// A native mutex suitable for storing in statics (that is, it has\n+/// the `destroy` method rather than a destructor).\n+pub struct StaticNativeMutex {\n     priv inner: imp::Mutex,\n }\n \n@@ -62,33 +66,33 @@ pub struct Mutex {\n /// then.\n #[must_use]\n pub struct LockGuard<'a> {\n-    priv lock: &'a mut Mutex\n+    priv lock: &'a mut StaticNativeMutex\n }\n \n-pub static MUTEX_INIT: Mutex = Mutex {\n+pub static NATIVE_MUTEX_INIT: StaticNativeMutex = StaticNativeMutex {\n     inner: imp::MUTEX_INIT,\n };\n \n-impl Mutex {\n-    /// Creates a new mutex\n-    pub unsafe fn new() -> Mutex {\n-        Mutex { inner: imp::Mutex::new() }\n+impl StaticNativeMutex {\n+    /// Creates a new mutex.\n+    ///\n+    /// Note that a mutex created in this way needs to be explicit\n+    /// freed with a call to `destroy` or it will leak.\n+    pub unsafe fn new() -> StaticNativeMutex {\n+        StaticNativeMutex { inner: imp::Mutex::new() }\n     }\n \n     /// Acquires this lock. This assumes that the current thread does not\n     /// already hold the lock.\n     ///\n     /// # Example\n-    /// ```\n-    /// use std::unstable::mutex::Mutex;\n+    /// ```rust\n+    /// use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    /// static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     /// unsafe {\n-    ///     let mut lock = Mutex::new();\n-    ///\n-    ///     {\n-    ///         let _guard = lock.lock();\n-    ///         // critical section...\n-    ///     } // automatically unlocked in `_guard`'s destructor\n-    /// }\n+    ///     let _guard = LOCK.lock();\n+    ///     // critical section...\n+    /// } // automatically unlocked in `_guard`'s destructor\n     /// ```\n     pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n         self.inner.lock();\n@@ -455,20 +459,20 @@ mod test {\n     use prelude::*;\n \n     use mem::drop;\n-    use super::{Mutex, MUTEX_INIT};\n+    use super::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use rt::thread::Thread;\n \n     #[test]\n     fn smoke_lock() {\n-        static mut lock: Mutex = MUTEX_INIT;\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             let _guard = lock.lock();\n         }\n     }\n \n     #[test]\n     fn smoke_cond() {\n-        static mut lock: Mutex = MUTEX_INIT;\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             let mut guard = lock.lock();\n             let t = Thread::start(proc() {\n@@ -484,7 +488,7 @@ mod test {\n \n     #[test]\n     fn smoke_lock_noguard() {\n-        static mut lock: Mutex = MUTEX_INIT;\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             lock.lock_noguard();\n             lock.unlock_noguard();\n@@ -493,7 +497,7 @@ mod test {\n \n     #[test]\n     fn smoke_cond_noguard() {\n-        static mut lock: Mutex = MUTEX_INIT;\n+        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             lock.lock_noguard();\n             let t = Thread::start(proc() {\n@@ -511,7 +515,7 @@ mod test {\n     #[test]\n     fn destroy_immediately() {\n         unsafe {\n-            let mut m = Mutex::new();\n+            let mut m = StaticNativeMutex::new();\n             m.destroy();\n         }\n     }"}, {"sha": "0a6de50bf23a9dd5c19583cf3927d21c5d0d4b1c", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -13,10 +13,10 @@ use kinds::Send;\n use ops::Drop;\n use option::Option;\n use sync::arc::UnsafeArc;\n-use unstable::mutex::{Mutex, LockGuard};\n+use unstable::mutex::{StaticNativeMutex, LockGuard};\n \n pub struct LittleLock {\n-    priv l: Mutex,\n+    priv l: StaticNativeMutex,\n }\n \n pub struct LittleGuard<'a> {\n@@ -31,7 +31,7 @@ impl Drop for LittleLock {\n \n impl LittleLock {\n     pub fn new() -> LittleLock {\n-        unsafe { LittleLock { l: Mutex::new() } }\n+        unsafe { LittleLock { l: StaticNativeMutex::new() } }\n     }\n \n     pub unsafe fn lock<'a>(&'a mut self) -> LittleGuard<'a> {"}, {"sha": "b37e2f3a45dc6dbfd2be9e01ab5269f4c04872b6", "filename": "src/libsync/sync/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibsync%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87ed605c0ef27f5532ec30c92128bd890de5955/src%2Flibsync%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fmutex.rs?ref=b87ed605c0ef27f5532ec30c92128bd890de5955", "patch": "@@ -133,7 +133,7 @@ pub struct StaticMutex {\n     /// uint-cast of the native thread waiting for this mutex\n     priv native_blocker: uint,\n     /// an OS mutex used by native threads\n-    priv lock: mutex::Mutex,\n+    priv lock: mutex::StaticNativeMutex,\n \n     /// A concurrent mpsc queue used by green threads, along with a count used\n     /// to figure out when to dequeue and enqueue.\n@@ -150,7 +150,7 @@ pub struct Guard<'a> {\n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n pub static MUTEX_INIT: StaticMutex = StaticMutex {\n-    lock: mutex::MUTEX_INIT,\n+    lock: mutex::NATIVE_MUTEX_INIT,\n     state: atomics::INIT_ATOMIC_UINT,\n     flavor: Unlocked,\n     green_blocker: 0,\n@@ -441,7 +441,7 @@ impl Mutex {\n                 native_blocker: 0,\n                 green_cnt: atomics::AtomicUint::new(0),\n                 q: q::Queue::new(),\n-                lock: unsafe { mutex::Mutex::new() },\n+                lock: unsafe { mutex::StaticNativeMutex::new() },\n             }\n         }\n     }"}]}