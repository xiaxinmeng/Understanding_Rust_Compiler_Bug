{"sha": "2136e75c0bce090d104bb5b5006e48e42fb22a0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMzZlNzVjMGJjZTA5MGQxMDRiYjViNTAwNmU0OGU0MmZiMjJhMGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T20:04:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T20:04:56Z"}, "message": "move path completion to a separate component", "tree": {"sha": "d17fa5832a8e04f925f9d3b62c3c2bf23a2de714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d17fa5832a8e04f925f9d3b62c3c2bf23a2de714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2136e75c0bce090d104bb5b5006e48e42fb22a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2136e75c0bce090d104bb5b5006e48e42fb22a0a", "html_url": "https://github.com/rust-lang/rust/commit/2136e75c0bce090d104bb5b5006e48e42fb22a0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2136e75c0bce090d104bb5b5006e48e42fb22a0a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbe67339df2bbcb17e12ad74e8b8cd53baffb9f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe67339df2bbcb17e12ad74e8b8cd53baffb9f7", "html_url": "https://github.com/rust-lang/rust/commit/cbe67339df2bbcb17e12ad74e8b8cd53baffb9f7"}], "stats": {"total": 171, "additions": 127, "deletions": 44}, "files": [{"sha": "d91304bc28b9260ad22f930fbccd0112892af5a3", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2136e75c0bce090d104bb5b5006e48e42fb22a0a/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2136e75c0bce090d104bb5b5006e48e42fb22a0a/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=2136e75c0bce090d104bb5b5006e48e42fb22a0a", "patch": "@@ -4,13 +4,12 @@ mod reference_completion;\n mod complete_fn_param;\n mod complete_keyword;\n mod complete_snippet;\n+mod complete_path;\n \n use ra_editor::find_node_at_offset;\n use ra_text_edit::AtomTextEdit;\n use ra_syntax::{\n-    algo::{\n-        find_leaf_at_offset,\n-    },\n+    algo::find_leaf_at_offset,\n     ast,\n     AstNode,\n     SyntaxNodeRef,\n@@ -48,11 +47,12 @@ pub(crate) fn completions(\n         reference_completion::completions(&mut acc, db, &module, &file, name_ref)?;\n     }\n \n-    let ctx = ctry!(SyntaxContext::new(&original_file, position.offset));\n+    let ctx = ctry!(SyntaxContext::new(db, &original_file, position)?);\n     complete_fn_param::complete_fn_param(&mut acc, &ctx);\n     complete_keyword::complete_expr_keyword(&mut acc, &ctx);\n     complete_snippet::complete_expr_snippet(&mut acc, &ctx);\n     complete_snippet::complete_item_snippet(&mut acc, &ctx);\n+    complete_path::complete_path(&mut acc, &ctx)?;\n \n     Ok(Some(acc))\n }\n@@ -61,31 +61,44 @@ pub(crate) fn completions(\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n pub(super) struct SyntaxContext<'a> {\n+    db: &'a db::RootDatabase,\n     leaf: SyntaxNodeRef<'a>,\n+    module: Option<hir::Module>,\n     enclosing_fn: Option<ast::FnDef<'a>>,\n     is_param: bool,\n     /// A single-indent path, like `foo`.\n     is_trivial_path: bool,\n+    /// If not a trivial, path, the prefix (qualifier).\n+    path_prefix: Option<hir::Path>,\n     after_if: bool,\n     is_stmt: bool,\n     /// Something is typed at the \"top\" level, in module or impl/trait.\n     is_new_item: bool,\n }\n \n-impl SyntaxContext<'_> {\n-    pub(super) fn new(original_file: &SourceFileNode, offset: TextUnit) -> Option<SyntaxContext> {\n-        let leaf = find_leaf_at_offset(original_file.syntax(), offset).left_biased()?;\n+impl<'a> SyntaxContext<'a> {\n+    pub(super) fn new(\n+        db: &'a db::RootDatabase,\n+        original_file: &'a SourceFileNode,\n+        position: FilePosition,\n+    ) -> Cancelable<Option<SyntaxContext<'a>>> {\n+        let module = source_binder::module_from_position(db, position)?;\n+        let leaf =\n+            ctry!(find_leaf_at_offset(original_file.syntax(), position.offset).left_biased());\n         let mut ctx = SyntaxContext {\n+            db,\n             leaf,\n+            module,\n             enclosing_fn: None,\n             is_param: false,\n             is_trivial_path: false,\n+            path_prefix: None,\n             after_if: false,\n             is_stmt: false,\n             is_new_item: false,\n         };\n-        ctx.fill(original_file, offset);\n-        Some(ctx)\n+        ctx.fill(original_file, position.offset);\n+        Ok(Some(ctx))\n     }\n \n     fn fill(&mut self, original_file: &SourceFileNode, offset: TextUnit) {\n@@ -140,11 +153,13 @@ impl SyntaxContext<'_> {\n         };\n         if let Some(segment) = ast::PathSegment::cast(parent) {\n             let path = segment.parent_path();\n-            // if let Some(path) = Path::from_ast(path) {\n-            //     if !path.is_ident() {\n-            //         return Some(NameRefKind::Path(path));\n-            //     }\n-            // }\n+            if let Some(mut path) = hir::Path::from_ast(path) {\n+                if !path.is_ident() {\n+                    path.segments.pop().unwrap();\n+                    self.path_prefix = Some(path);\n+                    return;\n+                }\n+            }\n             if path.qualifier().is_none() {\n                 self.is_trivial_path = true;\n                 self.enclosing_fn = self"}, {"sha": "d04503e46a08a77a181808aa7c7dae65186ddcaa", "filename": "crates/ra_analysis/src/completion/complete_path.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2136e75c0bce090d104bb5b5006e48e42fb22a0a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2136e75c0bce090d104bb5b5006e48e42fb22a0a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=2136e75c0bce090d104bb5b5006e48e42fb22a0a", "patch": "@@ -0,0 +1,95 @@\n+use crate::{\n+    completion::{CompletionItem, Completions, CompletionKind::*, SyntaxContext},\n+    Cancelable,\n+};\n+\n+pub(super) fn complete_path(acc: &mut Completions, ctx: &SyntaxContext) -> Cancelable<()> {\n+    let (path, module) = match (&ctx.path_prefix, &ctx.module) {\n+        (Some(path), Some(module)) => (path.clone(), module),\n+        _ => return Ok(()),\n+    };\n+    let def_id = match module.resolve_path(ctx.db, path)? {\n+        None => return Ok(()),\n+        Some(it) => it,\n+    };\n+    let target_module = match def_id.resolve(ctx.db)? {\n+        hir::Def::Module(it) => it,\n+        _ => return Ok(()),\n+    };\n+    let module_scope = target_module.scope(ctx.db)?;\n+    module_scope.entries().for_each(|(name, _res)| {\n+        CompletionItem::new(name.to_string())\n+            .kind(Reference)\n+            .add_to(acc)\n+    });\n+    Ok(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+\n+    fn check_reference_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Reference);\n+    }\n+\n+    #[test]\n+    fn completes_use_item_starting_with_self() {\n+        check_reference_completion(\n+            r\"\n+            use self::m::<|>;\n+\n+            mod m {\n+                struct Bar;\n+            }\n+            \",\n+            \"Bar\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_use_item_starting_with_crate() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct Spam;\n+            //- /foo.rs\n+            use crate::Sp<|>\n+            \",\n+            \"Spam;foo\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_nested_use_tree() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct Spam;\n+            //- /foo.rs\n+            use crate::{Sp<|>};\n+            \",\n+            \"Spam;foo\",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_deeply_nested_use_tree() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            pub mod bar {\n+                pub mod baz {\n+                    pub struct Spam;\n+                }\n+            }\n+            //- /foo.rs\n+            use crate::{bar::{baz::Sp<|>}};\n+            \",\n+            \"Spam\",\n+        );\n+    }\n+}"}, {"sha": "459ed8f6f763c8c6e8a9feb0b8c38ff704beda02", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2136e75c0bce090d104bb5b5006e48e42fb22a0a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2136e75c0bce090d104bb5b5006e48e42fb22a0a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=2136e75c0bce090d104bb5b5006e48e42fb22a0a", "patch": "@@ -1,12 +1,12 @@\n-use rustc_hash::{FxHashSet};\n+use rustc_hash::FxHashSet;\n use ra_syntax::{\n     SourceFileNode, AstNode,\n     ast,\n     SyntaxKind::*,\n };\n use hir::{\n     self,\n-    FnScopes, Def, Path\n+    FnScopes, Path\n };\n \n use crate::{\n@@ -53,7 +53,7 @@ pub(super) fn completions(\n                         .add_to(acc)\n                 });\n         }\n-        NameRefKind::Path(path) => complete_path(acc, db, module, path)?,\n+        NameRefKind::Path(_) => (),\n         NameRefKind::BareIdentInMod => (),\n     }\n     Ok(())\n@@ -121,33 +121,6 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Completions)\n     }\n }\n \n-fn complete_path(\n-    acc: &mut Completions,\n-    db: &RootDatabase,\n-    module: &hir::Module,\n-    mut path: Path,\n-) -> Cancelable<()> {\n-    if path.segments.is_empty() {\n-        return Ok(());\n-    }\n-    path.segments.pop();\n-    let def_id = match module.resolve_path(db, path)? {\n-        None => return Ok(()),\n-        Some(it) => it,\n-    };\n-    let target_module = match def_id.resolve(db)? {\n-        Def::Module(it) => it,\n-        _ => return Ok(()),\n-    };\n-    let module_scope = target_module.scope(db)?;\n-    module_scope.entries().for_each(|(name, _res)| {\n-        CompletionItem::new(name.to_string())\n-            .kind(Reference)\n-            .add_to(acc)\n-    });\n-    Ok(())\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::completion::{CompletionKind, check_completion};"}]}