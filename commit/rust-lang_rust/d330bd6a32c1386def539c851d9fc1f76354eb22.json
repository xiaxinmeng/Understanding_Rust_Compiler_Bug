{"sha": "d330bd6a32c1386def539c851d9fc1f76354eb22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMzBiZDZhMzJjMTM4NmRlZjUzOWM4NTFkOWZjMWY3NjM1NGViMjI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-07T09:32:02Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-07T10:10:57Z"}, "message": "Glob import variants before matching and simplify some code.", "tree": {"sha": "9a969ae2e1170a952165689febac142389a5ea8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a969ae2e1170a952165689febac142389a5ea8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d330bd6a32c1386def539c851d9fc1f76354eb22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d330bd6a32c1386def539c851d9fc1f76354eb22", "html_url": "https://github.com/rust-lang/rust/commit/d330bd6a32c1386def539c851d9fc1f76354eb22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d330bd6a32c1386def539c851d9fc1f76354eb22/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f4e0b5051f82ed3032fcb8beb576e2b8212faa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4", "html_url": "https://github.com/rust-lang/rust/commit/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4"}], "stats": {"total": 118, "additions": 61, "deletions": 57}, "files": [{"sha": "df5ad1114519baa87ff878c41225896fcf018de5", "filename": "src/interpreter.rs", "status": "modified", "additions": 61, "deletions": 57, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d330bd6a32c1386def539c851d9fc1f76354eb22/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d330bd6a32c1386def539c851d9fc1f76354eb22/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=d330bd6a32c1386def539c851d9fc1f76354eb22", "patch": "@@ -150,22 +150,19 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n             for stmt in &block_data.statements {\n                 if TRACE_EXECUTION { println!(\"{:?}\", stmt); }\n-\n-                match stmt.kind {\n-                    mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                        let ptr = try!(self.lvalue_to_ptr(lvalue));\n-                        try!(self.eval_rvalue_into(rvalue, &ptr));\n-                    }\n-                }\n+                let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n+                let ptr = try!(self.lvalue_to_ptr(lvalue));\n+                try!(self.eval_rvalue_into(rvalue, &ptr));\n             }\n \n             if TRACE_EXECUTION { println!(\"{:?}\", block_data.terminator()); }\n \n+            use rustc::mir::repr::Terminator::*;\n             match *block_data.terminator() {\n-                mir::Terminator::Return => break,\n-                mir::Terminator::Goto { target } => block = target,\n+                Return => break,\n+                Goto { target } => block = target,\n \n-                // mir::Terminator::Call { ref func, ref args, ref destination, .. } => {\n+                // Call { ref func, ref args, ref destination, .. } => {\n                 //     let ptr = destination.as_ref().map(|&(ref lv, _)| self.lvalue_to_ptr(lv));\n                 //     let func_val = self.operand_to_ptr(func);\n \n@@ -193,15 +190,16 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 //     }\n                 // }\n \n-                // mir::Terminator::If { ref cond, targets: (then_target, else_target) } => {\n+                // If { ref cond, targets: (then_target, else_target) } => {\n+                //     let cond_ptr = try!(self.operand_to_ptr(cond));\n                 //     match self.operand_to_ptr(cond) {\n                 //         Value::Bool(true) => block = then_target,\n                 //         Value::Bool(false) => block = else_target,\n                 //         cond_val => panic!(\"Non-boolean `if` condition value: {:?}\", cond_val),\n                 //     }\n                 // }\n \n-                // mir::Terminator::SwitchInt { ref discr, ref values, ref targets, .. } => {\n+                // SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 //     let discr_val = self.read_lvalue(discr);\n \n                 //     let index = values.iter().position(|v| discr_val == self.const_to_ptr(v))\n@@ -210,7 +208,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 //     block = targets[index];\n                 // }\n \n-                // mir::Terminator::Switch { ref discr, ref targets, .. } => {\n+                // Switch { ref discr, ref targets, .. } => {\n                 //     let discr_val = self.read_lvalue(discr);\n \n                 //     if let Value::Adt { variant, .. } = discr_val {\n@@ -220,12 +218,12 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 //     }\n                 // }\n \n-                mir::Terminator::Drop { target, .. } => {\n+                Drop { target, .. } => {\n                     // TODO: Handle destructors and dynamic drop.\n                     block = target;\n                 }\n \n-                mir::Terminator::Resume => unimplemented!(),\n+                Resume => unimplemented!(),\n                 _ => unimplemented!(),\n             }\n         }\n@@ -237,12 +235,13 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n     fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue) -> EvalResult<Pointer> {\n         let frame = self.stack.last().expect(\"no call frames exists\");\n \n+        use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n-            mir::Lvalue::ReturnPointer => frame.return_ptr.clone()\n+            ReturnPointer => frame.return_ptr.clone()\n                 .expect(\"ReturnPointer used in a function with no return value\"),\n-            mir::Lvalue::Arg(i)  => frame.arg_ptr(i),\n-            mir::Lvalue::Var(i)  => frame.var_ptr(i),\n-            mir::Lvalue::Temp(i) => frame.temp_ptr(i),\n+            Arg(i)  => frame.arg_ptr(i),\n+            Var(i)  => frame.var_ptr(i),\n+            Temp(i) => frame.temp_ptr(i),\n             ref l => panic!(\"can't handle lvalue: {:?}\", l),\n         };\n \n@@ -286,28 +285,29 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n     fn eval_binary_op(&mut self, bin_op: mir::BinOp, left: Pointer, right: Pointer, dest: &Pointer)\n             -> EvalResult<()> {\n+        use rustc::mir::repr::BinOp::*;\n         match (&left.repr, &right.repr, &dest.repr) {\n             (&Repr::Int, &Repr::Int, &Repr::Int) => {\n                 let l = try!(self.memory.read_int(&left));\n                 let r = try!(self.memory.read_int(&right));\n                 let n = match bin_op {\n-                    mir::BinOp::Add    => l + r,\n-                    mir::BinOp::Sub    => l - r,\n-                    mir::BinOp::Mul    => l * r,\n-                    mir::BinOp::Div    => l / r,\n-                    mir::BinOp::Rem    => l % r,\n-                    mir::BinOp::BitXor => l ^ r,\n-                    mir::BinOp::BitAnd => l & r,\n-                    mir::BinOp::BitOr  => l | r,\n-                    mir::BinOp::Shl    => l << r,\n-                    mir::BinOp::Shr    => l >> r,\n-                    _                  => unimplemented!(),\n-                    // mir::BinOp::Eq     => Value::Bool(l == r),\n-                    // mir::BinOp::Lt     => Value::Bool(l < r),\n-                    // mir::BinOp::Le     => Value::Bool(l <= r),\n-                    // mir::BinOp::Ne     => Value::Bool(l != r),\n-                    // mir::BinOp::Ge     => Value::Bool(l >= r),\n-                    // mir::BinOp::Gt     => Value::Bool(l > r),\n+                    Add    => l + r,\n+                    Sub    => l - r,\n+                    Mul    => l * r,\n+                    Div    => l / r,\n+                    Rem    => l % r,\n+                    BitXor => l ^ r,\n+                    BitAnd => l & r,\n+                    BitOr  => l | r,\n+                    Shl    => l << r,\n+                    Shr    => l >> r,\n+                    _      => unimplemented!(),\n+                    // Eq     => Value::Bool(l == r),\n+                    // Lt     => Value::Bool(l < r),\n+                    // Le     => Value::Bool(l <= r),\n+                    // Ne     => Value::Bool(l != r),\n+                    // Ge     => Value::Bool(l >= r),\n+                    // Gt     => Value::Bool(l > r),\n                 };\n                 self.memory.write_int(dest, n)\n             }\n@@ -317,19 +317,20 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n     }\n \n     fn eval_rvalue_into(&mut self, rvalue: &mir::Rvalue, dest: &Pointer) -> EvalResult<()> {\n+        use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n-            mir::Rvalue::Use(ref operand) => {\n+            Use(ref operand) => {\n                 let src = try!(self.operand_to_ptr(operand));\n                 try!(self.memory.copy(&src, dest, src.repr.size()));\n             }\n \n-            mir::Rvalue::BinaryOp(bin_op, ref left, ref right) => {\n+            BinaryOp(bin_op, ref left, ref right) => {\n                 let left_ptr = try!(self.operand_to_ptr(left));\n                 let right_ptr = try!(self.operand_to_ptr(right));\n                 try!(self.eval_binary_op(bin_op, left_ptr, right_ptr, dest));\n             }\n \n-            mir::Rvalue::UnaryOp(un_op, ref operand) => {\n+            UnaryOp(un_op, ref operand) => {\n                 let ptr = try!(self.operand_to_ptr(operand));\n                 let m = try!(self.memory.read_int(&ptr));\n                 let n = match (un_op, ptr.repr) {\n@@ -340,7 +341,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 try!(self.memory.write_int(dest, n));\n             }\n \n-            mir::Rvalue::Aggregate(mir::AggregateKind::Tuple, ref operands) => {\n+            Aggregate(mir::AggregateKind::Tuple, ref operands) => {\n                 match dest.repr {\n                     Repr::Aggregate { ref fields, .. } => {\n                         for (field, operand) in fields.iter().zip(operands) {\n@@ -354,11 +355,11 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 }\n             }\n \n-            // mir::Rvalue::Ref(_region, _kind, ref lvalue) => {\n+            // Ref(_region, _kind, ref lvalue) => {\n             //     Value::Pointer(self.lvalue_to_ptr(lvalue))\n             // }\n \n-            // mir::Rvalue::Aggregate(mir::AggregateKind::Adt(ref adt_def, variant, _substs),\n+            // Aggregate(mir::AggregateKind::Adt(ref adt_def, variant, _substs),\n             //                        ref operands) => {\n             //     let max_fields = adt_def.variants\n             //         .iter()\n@@ -383,14 +384,16 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n     }\n \n     fn operand_to_ptr(&mut self, op: &mir::Operand) -> EvalResult<Pointer> {\n+        use rustc::mir::repr::Operand::*;\n         match *op {\n-            mir::Operand::Consume(ref lvalue) => self.lvalue_to_ptr(lvalue),\n+            Consume(ref lvalue) => self.lvalue_to_ptr(lvalue),\n \n-            mir::Operand::Constant(ref constant) => {\n+            Constant(ref constant) => {\n+                use rustc::mir::repr::Literal::*;\n                 match constant.literal {\n-                    mir::Literal::Value { ref value } => self.const_to_ptr(value),\n+                    Value { ref value } => self.const_to_ptr(value),\n \n-                    mir::Literal::Item { def_id, kind, .. } => match kind {\n+                    Item { def_id, kind, .. } => match kind {\n                         // mir::ItemKind::Function | mir::ItemKind::Method => Value::Func(def_id),\n                         _ => panic!(\"can't handle item literal: {:?}\", constant.literal),\n                     },\n@@ -400,22 +403,23 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n     }\n \n     fn const_to_ptr(&mut self, const_val: &const_eval::ConstVal) -> EvalResult<Pointer> {\n+        use rustc::middle::const_eval::ConstVal::*;\n         match *const_val {\n-            const_eval::ConstVal::Float(_f)         => unimplemented!(),\n-            const_eval::ConstVal::Int(n) => {\n+            Float(_f)         => unimplemented!(),\n+            Int(n) => {\n                 let ptr = self.memory.allocate(Repr::Int);\n                 try!(self.memory.write_int(&ptr, n));\n                 Ok(ptr)\n             }\n-            const_eval::ConstVal::Uint(_u)          => unimplemented!(),\n-            const_eval::ConstVal::Str(ref _s)       => unimplemented!(),\n-            const_eval::ConstVal::ByteStr(ref _bs)  => unimplemented!(),\n-            const_eval::ConstVal::Bool(b)           => unimplemented!(),\n-            const_eval::ConstVal::Struct(_node_id)  => unimplemented!(),\n-            const_eval::ConstVal::Tuple(_node_id)   => unimplemented!(),\n-            const_eval::ConstVal::Function(_def_id) => unimplemented!(),\n-            const_eval::ConstVal::Array(_, _)       => unimplemented!(),\n-            const_eval::ConstVal::Repeat(_, _)      => unimplemented!(),\n+            Uint(_u)          => unimplemented!(),\n+            Str(ref _s)       => unimplemented!(),\n+            ByteStr(ref _bs)  => unimplemented!(),\n+            Bool(b)           => unimplemented!(),\n+            Struct(_node_id)  => unimplemented!(),\n+            Tuple(_node_id)   => unimplemented!(),\n+            Function(_def_id) => unimplemented!(),\n+            Array(_, _)       => unimplemented!(),\n+            Repeat(_, _)      => unimplemented!(),\n         }\n     }\n }"}]}