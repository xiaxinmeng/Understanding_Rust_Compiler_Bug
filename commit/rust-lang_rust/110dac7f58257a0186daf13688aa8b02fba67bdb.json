{"sha": "110dac7f58257a0186daf13688aa8b02fba67bdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMGRhYzdmNTgyNTdhMDE4NmRhZjEzNjg4YWE4YjAyZmJhNjdiZGI=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-02T15:43:27Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:37:16Z"}, "message": "move option_as_ref_deref to its own module", "tree": {"sha": "826e39391822ed91fe62aa8f6db813eaef35377f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/826e39391822ed91fe62aa8f6db813eaef35377f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/110dac7f58257a0186daf13688aa8b02fba67bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/110dac7f58257a0186daf13688aa8b02fba67bdb", "html_url": "https://github.com/rust-lang/rust/commit/110dac7f58257a0186daf13688aa8b02fba67bdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/110dac7f58257a0186daf13688aa8b02fba67bdb/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "483bac2dc0a47df87141a98df1d470b25cd2eda3", "url": "https://api.github.com/repos/rust-lang/rust/commits/483bac2dc0a47df87141a98df1d470b25cd2eda3", "html_url": "https://github.com/rust-lang/rust/commit/483bac2dc0a47df87141a98df1d470b25cd2eda3"}], "stats": {"total": 236, "additions": 125, "deletions": 111}, "files": [{"sha": "c6b6ef34bc442797c5511751bec3e68a42bea37b", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 111, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/110dac7f58257a0186daf13688aa8b02fba67bdb/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110dac7f58257a0186daf13688aa8b02fba67bdb/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=110dac7f58257a0186daf13688aa8b02fba67bdb", "patch": "@@ -10,6 +10,7 @@ mod inspect_for_each;\n mod iter_count;\n mod manual_saturating_arithmetic;\n mod ok_expect;\n+mod option_as_ref_deref;\n mod option_map_unwrap_or;\n mod skip_while_next;\n mod unnecessary_filter_map;\n@@ -1725,10 +1726,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             },\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n             [\"map\", \"as_ref\"] => {\n-                lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], false, self.msrv.as_ref())\n+                option_as_ref_deref::check(cx, expr, arg_lists[1], arg_lists[0], false, self.msrv.as_ref())\n             },\n             [\"map\", \"as_mut\"] => {\n-                lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true, self.msrv.as_ref())\n+                option_as_ref_deref::check(cx, expr, arg_lists[1], arg_lists[0], true, self.msrv.as_ref())\n             },\n             [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"unwrap_or\"),\n             [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"get_or_insert\"),\n@@ -3584,115 +3585,6 @@ fn lint_suspicious_map(cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n     );\n }\n \n-const OPTION_AS_REF_DEREF_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n-\n-/// lint use of `_.as_ref().map(Deref::deref)` for `Option`s\n-fn lint_option_as_ref_deref<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &hir::Expr<'_>,\n-    as_ref_args: &[hir::Expr<'_>],\n-    map_args: &[hir::Expr<'_>],\n-    is_mut: bool,\n-    msrv: Option<&RustcVersion>,\n-) {\n-    if !meets_msrv(msrv, &OPTION_AS_REF_DEREF_MSRV) {\n-        return;\n-    }\n-\n-    let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n-\n-    let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n-    if !is_type_diagnostic_item(cx, option_ty, sym::option_type) {\n-        return;\n-    }\n-\n-    let deref_aliases: [&[&str]; 9] = [\n-        &paths::DEREF_TRAIT_METHOD,\n-        &paths::DEREF_MUT_TRAIT_METHOD,\n-        &paths::CSTRING_AS_C_STR,\n-        &paths::OS_STRING_AS_OS_STR,\n-        &paths::PATH_BUF_AS_PATH,\n-        &paths::STRING_AS_STR,\n-        &paths::STRING_AS_MUT_STR,\n-        &paths::VEC_AS_SLICE,\n-        &paths::VEC_AS_MUT_SLICE,\n-    ];\n-\n-    let is_deref = match map_args[1].kind {\n-        hir::ExprKind::Path(ref expr_qpath) => cx\n-            .qpath_res(expr_qpath, map_args[1].hir_id)\n-            .opt_def_id()\n-            .map_or(false, |fun_def_id| {\n-                deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n-            }),\n-        hir::ExprKind::Closure(_, _, body_id, _, _) => {\n-            let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n-\n-            match &closure_expr.kind {\n-                hir::ExprKind::MethodCall(_, _, args, _) => {\n-                    if_chain! {\n-                        if args.len() == 1;\n-                        if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);\n-                        let adj = cx\n-                            .typeck_results()\n-                            .expr_adjustments(&args[0])\n-                            .iter()\n-                            .map(|x| &x.kind)\n-                            .collect::<Box<[_]>>();\n-                        if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n-                        then {\n-                            let method_did = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id).unwrap();\n-                            deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n-                        } else {\n-                            false\n-                        }\n-                    }\n-                },\n-                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref inner) if same_mutability(m) => {\n-                    if_chain! {\n-                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner1) = inner.kind;\n-                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner2) = inner1.kind;\n-                        then {\n-                            path_to_local_id(inner2, closure_body.params[0].pat.hir_id)\n-                        } else {\n-                            false\n-                        }\n-                    }\n-                },\n-                _ => false,\n-            }\n-        },\n-        _ => false,\n-    };\n-\n-    if is_deref {\n-        let current_method = if is_mut {\n-            format!(\".as_mut().map({})\", snippet(cx, map_args[1].span, \"..\"))\n-        } else {\n-            format!(\".as_ref().map({})\", snippet(cx, map_args[1].span, \"..\"))\n-        };\n-        let method_hint = if is_mut { \"as_deref_mut\" } else { \"as_deref\" };\n-        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_args[0].span, \"..\"), method_hint);\n-        let suggestion = format!(\"try using {} instead\", method_hint);\n-\n-        let msg = format!(\n-            \"called `{0}` on an Option value. This can be done more directly \\\n-            by calling `{1}` instead\",\n-            current_method, hint\n-        );\n-        span_lint_and_sugg(\n-            cx,\n-            OPTION_AS_REF_DEREF,\n-            expr.span,\n-            &msg,\n-            &suggestion,\n-            hint,\n-            Applicability::MachineApplicable,\n-        );\n-    }\n-}\n-\n fn lint_map_collect(\n     cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,"}, {"sha": "89067dbfe0e51a780e6e6df125d2c9cfad98e357", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/110dac7f58257a0186daf13688aa8b02fba67bdb/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110dac7f58257a0186daf13688aa8b02fba67bdb/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=110dac7f58257a0186daf13688aa8b02fba67bdb", "patch": "@@ -0,0 +1,122 @@\n+use crate::utils::{\n+    is_type_diagnostic_item, match_def_path, meets_msrv, path_to_local_id, paths, remove_blocks, snippet,\n+    span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n+use rustc_span::sym;\n+\n+use super::OPTION_AS_REF_DEREF;\n+\n+const OPTION_AS_REF_DEREF_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n+\n+/// lint use of `_.as_ref().map(Deref::deref)` for `Option`s\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    as_ref_args: &[hir::Expr<'_>],\n+    map_args: &[hir::Expr<'_>],\n+    is_mut: bool,\n+    msrv: Option<&RustcVersion>,\n+) {\n+    if !meets_msrv(msrv, &OPTION_AS_REF_DEREF_MSRV) {\n+        return;\n+    }\n+\n+    let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n+\n+    let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n+    if !is_type_diagnostic_item(cx, option_ty, sym::option_type) {\n+        return;\n+    }\n+\n+    let deref_aliases: [&[&str]; 9] = [\n+        &paths::DEREF_TRAIT_METHOD,\n+        &paths::DEREF_MUT_TRAIT_METHOD,\n+        &paths::CSTRING_AS_C_STR,\n+        &paths::OS_STRING_AS_OS_STR,\n+        &paths::PATH_BUF_AS_PATH,\n+        &paths::STRING_AS_STR,\n+        &paths::STRING_AS_MUT_STR,\n+        &paths::VEC_AS_SLICE,\n+        &paths::VEC_AS_MUT_SLICE,\n+    ];\n+\n+    let is_deref = match map_args[1].kind {\n+        hir::ExprKind::Path(ref expr_qpath) => cx\n+            .qpath_res(expr_qpath, map_args[1].hir_id)\n+            .opt_def_id()\n+            .map_or(false, |fun_def_id| {\n+                deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n+            }),\n+        hir::ExprKind::Closure(_, _, body_id, _, _) => {\n+            let closure_body = cx.tcx.hir().body(body_id);\n+            let closure_expr = remove_blocks(&closure_body.value);\n+\n+            match &closure_expr.kind {\n+                hir::ExprKind::MethodCall(_, _, args, _) => {\n+                    if_chain! {\n+                        if args.len() == 1;\n+                        if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);\n+                        let adj = cx\n+                            .typeck_results()\n+                            .expr_adjustments(&args[0])\n+                            .iter()\n+                            .map(|x| &x.kind)\n+                            .collect::<Box<[_]>>();\n+                        if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n+                        then {\n+                            let method_did = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id).unwrap();\n+                            deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                },\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref inner) if same_mutability(m) => {\n+                    if_chain! {\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner1) = inner.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner2) = inner1.kind;\n+                        then {\n+                            path_to_local_id(inner2, closure_body.params[0].pat.hir_id)\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                },\n+                _ => false,\n+            }\n+        },\n+        _ => false,\n+    };\n+\n+    if is_deref {\n+        let current_method = if is_mut {\n+            format!(\".as_mut().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+        } else {\n+            format!(\".as_ref().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+        };\n+        let method_hint = if is_mut { \"as_deref_mut\" } else { \"as_deref\" };\n+        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_args[0].span, \"..\"), method_hint);\n+        let suggestion = format!(\"try using {} instead\", method_hint);\n+\n+        let msg = format!(\n+            \"called `{0}` on an Option value. This can be done more directly \\\n+            by calling `{1}` instead\",\n+            current_method, hint\n+        );\n+        span_lint_and_sugg(\n+            cx,\n+            OPTION_AS_REF_DEREF,\n+            expr.span,\n+            &msg,\n+            &suggestion,\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}]}