{"sha": "27f5d830eb11cd7bdc834d6f0d78120976f75443", "node_id": "C_kwDOAAsO6NoAKDI3ZjVkODMwZWIxMWNkN2JkYzgzNGQ2ZjBkNzgxMjA5NzZmNzU0NDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-02T19:07:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-02T19:07:07Z"}, "message": "Auto merge of #93594 - matthiaskrgr:rollup-lcvhpdv, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #92528 (Make `Fingerprint::combine_commutative` associative)\n - #93221 ([borrowck] Fix help on mutating &self in async fns)\n - #93542 (Prevent lifetime elision in type alias)\n - #93546 (Validate that values in switch int terminator are unique)\n - #93571 (better suggestion for duplicated `where` clause)\n - #93574 (don't suggest adding `let` due to bad assignment expressions inside of `while` loop)\n - #93590 (More let_else adoptions)\n - #93592 (Remove unused dep from rustc_arena)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2f08e48c477c4a63fdffcdd0fd7b3ae26dcd693d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f08e48c477c4a63fdffcdd0fd7b3ae26dcd693d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27f5d830eb11cd7bdc834d6f0d78120976f75443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27f5d830eb11cd7bdc834d6f0d78120976f75443", "html_url": "https://github.com/rust-lang/rust/commit/27f5d830eb11cd7bdc834d6f0d78120976f75443", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27f5d830eb11cd7bdc834d6f0d78120976f75443/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cd14d2f561a61e9838546f133afcf06038d761b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd14d2f561a61e9838546f133afcf06038d761b", "html_url": "https://github.com/rust-lang/rust/commit/7cd14d2f561a61e9838546f133afcf06038d761b"}, {"sha": "93155c59563a6a9017bc868c41243ffe7dc7fe89", "url": "https://api.github.com/repos/rust-lang/rust/commits/93155c59563a6a9017bc868c41243ffe7dc7fe89", "html_url": "https://github.com/rust-lang/rust/commit/93155c59563a6a9017bc868c41243ffe7dc7fe89"}], "stats": {"total": 749, "additions": 494, "deletions": 255}, "files": [{"sha": "208ce841759b990e243e44f48a38b91f016c1903", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -3403,7 +3403,6 @@ dependencies = [\n name = \"rustc_arena\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc_data_structures\",\n  \"smallvec\",\n ]\n "}, {"sha": "ee3a7b51b699a693de3465e7c8b0b1efcc036576", "filename": "compiler/rustc_arena/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2FCargo.toml?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -4,5 +4,4 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n-rustc_data_structures = { path = \"../rustc_data_structures\" }\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "cacc36b616a1e05590762693c4db09376445738a", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -471,9 +471,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // two imports.\n                 for new_node_id in [id1, id2] {\n                     let new_id = self.resolver.local_def_id(new_node_id);\n-                    let res = if let Some(res) = resolutions.next() {\n-                        res\n-                    } else {\n+                    let Some(res) = resolutions.next() else {\n                         // Associate an HirId to both ids even if there is no resolution.\n                         let _old = self\n                             .node_id_to_hir_id"}, {"sha": "b1e601516ab97e947c73ba5f346bd574e0f65378", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -32,6 +32,7 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n+#![feature(let_else)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]"}, {"sha": "8c5beb1025803ec05b2450e6dd72793675866afe", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 67, "deletions": 71, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -217,85 +217,81 @@ where\n                     let mut issue_num = None;\n                     let mut is_soft = false;\n                     for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty() {\n-                                sym::feature => {\n-                                    if !get(mi, &mut feature) {\n-                                        continue 'outer;\n-                                    }\n+                        let Some(mi) = meta.meta_item() else {\n+                            handle_errors(\n+                                &sess.parse_sess,\n+                                meta.span(),\n+                                AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                            );\n+                            continue 'outer;\n+                        };\n+                        match mi.name_or_empty() {\n+                            sym::feature => {\n+                                if !get(mi, &mut feature) {\n+                                    continue 'outer;\n                                 }\n-                                sym::reason => {\n-                                    if !get(mi, &mut reason) {\n-                                        continue 'outer;\n-                                    }\n+                            }\n+                            sym::reason => {\n+                                if !get(mi, &mut reason) {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            sym::issue => {\n+                                if !get(mi, &mut issue) {\n+                                    continue 'outer;\n                                 }\n-                                sym::issue => {\n-                                    if !get(mi, &mut issue) {\n-                                        continue 'outer;\n-                                    }\n \n-                                    // These unwraps are safe because `get` ensures the meta item\n-                                    // is a name/value pair string literal.\n-                                    issue_num = match issue.unwrap().as_str() {\n-                                        \"none\" => None,\n-                                        issue => {\n-                                            let emit_diag = |msg: &str| {\n-                                                struct_span_err!(\n-                                                    diagnostic,\n-                                                    mi.span,\n-                                                    E0545,\n-                                                    \"`issue` must be a non-zero numeric string \\\n-                                                    or \\\"none\\\"\",\n-                                                )\n-                                                .span_label(\n-                                                    mi.name_value_literal_span().unwrap(),\n-                                                    msg,\n-                                                )\n-                                                .emit();\n-                                            };\n-                                            match issue.parse() {\n-                                                Ok(0) => {\n-                                                    emit_diag(\n-                                                        \"`issue` must not be \\\"0\\\", \\\n-                                                        use \\\"none\\\" instead\",\n-                                                    );\n-                                                    continue 'outer;\n-                                                }\n-                                                Ok(num) => NonZeroU32::new(num),\n-                                                Err(err) => {\n-                                                    emit_diag(&err.to_string());\n-                                                    continue 'outer;\n-                                                }\n+                                // These unwraps are safe because `get` ensures the meta item\n+                                // is a name/value pair string literal.\n+                                issue_num = match issue.unwrap().as_str() {\n+                                    \"none\" => None,\n+                                    issue => {\n+                                        let emit_diag = |msg: &str| {\n+                                            struct_span_err!(\n+                                                diagnostic,\n+                                                mi.span,\n+                                                E0545,\n+                                                \"`issue` must be a non-zero numeric string \\\n+                                                or \\\"none\\\"\",\n+                                            )\n+                                            .span_label(mi.name_value_literal_span().unwrap(), msg)\n+                                            .emit();\n+                                        };\n+                                        match issue.parse() {\n+                                            Ok(0) => {\n+                                                emit_diag(\n+                                                    \"`issue` must not be \\\"0\\\", \\\n+                                                    use \\\"none\\\" instead\",\n+                                                );\n+                                                continue 'outer;\n+                                            }\n+                                            Ok(num) => NonZeroU32::new(num),\n+                                            Err(err) => {\n+                                                emit_diag(&err.to_string());\n+                                                continue 'outer;\n                                             }\n                                         }\n-                                    };\n-                                }\n-                                sym::soft => {\n-                                    if !mi.is_word() {\n-                                        let msg = \"`soft` should not have any arguments\";\n-                                        sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n                                     }\n-                                    is_soft = true;\n-                                }\n-                                _ => {\n-                                    handle_errors(\n-                                        &sess.parse_sess,\n-                                        meta.span(),\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            &[\"feature\", \"reason\", \"issue\", \"soft\"],\n-                                        ),\n-                                    );\n-                                    continue 'outer;\n+                                };\n+                            }\n+                            sym::soft => {\n+                                if !mi.is_word() {\n+                                    let msg = \"`soft` should not have any arguments\";\n+                                    sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n                                 }\n+                                is_soft = true;\n+                            }\n+                            _ => {\n+                                handle_errors(\n+                                    &sess.parse_sess,\n+                                    meta.span(),\n+                                    AttrError::UnknownMetaItem(\n+                                        pprust::path_to_string(&mi.path),\n+                                        &[\"feature\", \"reason\", \"issue\", \"soft\"],\n+                                    ),\n+                                );\n+                                continue 'outer;\n                             }\n-                        } else {\n-                            handle_errors(\n-                                &sess.parse_sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n-                            );\n-                            continue 'outer;\n                         }\n                     }\n "}, {"sha": "c95c1c40a34c20fc211cfbbf31b5241cb7cddbca", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -4,6 +4,8 @@\n //! The goal is to move the definition of `MetaItem` and things that don't need to be in `syntax`\n //! to this crate.\n \n+#![feature(let_else)]\n+\n #[macro_use]\n extern crate rustc_macros;\n "}, {"sha": "049c3aab97933a6bcc2b8c7eb4b58c056a904f0a", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -488,12 +488,32 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     // don't create labels for compiler-generated spans\n                                     Some(_) => None,\n                                     None => {\n-                                        let (span, suggestion) = suggest_ampmut(\n-                                            self.infcx.tcx,\n-                                            local_decl,\n-                                            opt_assignment_rhs_span,\n-                                            *opt_ty_info,\n-                                        );\n+                                        let (span, suggestion) = if name != kw::SelfLower {\n+                                            suggest_ampmut(\n+                                                self.infcx.tcx,\n+                                                local_decl,\n+                                                opt_assignment_rhs_span,\n+                                                *opt_ty_info,\n+                                            )\n+                                        } else {\n+                                            match local_decl.local_info.as_deref() {\n+                                                Some(LocalInfo::User(ClearCrossCrate::Set(\n+                                                    mir::BindingForm::Var(mir::VarBindingForm {\n+                                                        opt_ty_info: None,\n+                                                        ..\n+                                                    }),\n+                                                ))) => {\n+                                                    suggest_ampmut_self(self.infcx.tcx, local_decl)\n+                                                }\n+                                                // explicit self (eg `self: &'a Self`)\n+                                                _ => suggest_ampmut(\n+                                                    self.infcx.tcx,\n+                                                    local_decl,\n+                                                    opt_assignment_rhs_span,\n+                                                    *opt_ty_info,\n+                                                ),\n+                                            }\n+                                        };\n                                         Some((true, span, suggestion))\n                                     }\n                                 }"}, {"sha": "3409f14c98b733b3054b4b92465e31908c7382b4", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 65, "deletions": 72, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -311,43 +311,39 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 ty::BoundRegionKind::BrEnv => {\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n-                    if let DefiningTy::Closure(_, substs) = def_ty {\n-                        let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir().expect_expr(self.mir_hir_id()).kind\n-                        {\n-                            span\n-                        } else {\n-                            bug!(\"Closure is not defined by a closure expr\");\n-                        };\n-                        let region_name = self.synthesize_region_name();\n-\n-                        let closure_kind_ty = substs.as_closure().kind_ty();\n-                        let note = match closure_kind_ty.to_opt_closure_kind() {\n-                            Some(ty::ClosureKind::Fn) => {\n-                                \"closure implements `Fn`, so references to captured variables \\\n-                                 can't escape the closure\"\n-                            }\n-                            Some(ty::ClosureKind::FnMut) => {\n-                                \"closure implements `FnMut`, so references to captured variables \\\n-                                 can't escape the closure\"\n-                            }\n-                            Some(ty::ClosureKind::FnOnce) => {\n-                                bug!(\"BrEnv in a `FnOnce` closure\");\n-                            }\n-                            None => bug!(\"Closure kind not inferred in borrow check\"),\n-                        };\n-\n-                        Some(RegionName {\n-                            name: region_name,\n-                            source: RegionNameSource::SynthesizedFreeEnvRegion(\n-                                args_span,\n-                                note.to_string(),\n-                            ),\n-                        })\n-                    } else {\n+                    let DefiningTy::Closure(_, substs) = def_ty else {\n                         // Can't have BrEnv in functions, constants or generators.\n                         bug!(\"BrEnv outside of closure.\");\n-                    }\n+                    };\n+                    let hir::ExprKind::Closure(_, _, _, args_span, _) =\n+                        tcx.hir().expect_expr(self.mir_hir_id()).kind else {\n+                        bug!(\"Closure is not defined by a closure expr\");\n+                    };\n+                    let region_name = self.synthesize_region_name();\n+\n+                    let closure_kind_ty = substs.as_closure().kind_ty();\n+                    let note = match closure_kind_ty.to_opt_closure_kind() {\n+                        Some(ty::ClosureKind::Fn) => {\n+                            \"closure implements `Fn`, so references to captured variables \\\n+                                can't escape the closure\"\n+                        }\n+                        Some(ty::ClosureKind::FnMut) => {\n+                            \"closure implements `FnMut`, so references to captured variables \\\n+                                can't escape the closure\"\n+                        }\n+                        Some(ty::ClosureKind::FnOnce) => {\n+                            bug!(\"BrEnv in a `FnOnce` closure\");\n+                        }\n+                        None => bug!(\"Closure kind not inferred in borrow check\"),\n+                    };\n+\n+                    Some(RegionName {\n+                        name: region_name,\n+                        source: RegionNameSource::SynthesizedFreeEnvRegion(\n+                            args_span,\n+                            note.to_string(),\n+                        ),\n+                    })\n                 }\n \n                 ty::BoundRegionKind::BrAnon(_) => None,\n@@ -765,48 +761,45 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     fn get_future_inner_return_ty(&self, hir_ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n         let hir = self.infcx.tcx.hir();\n \n-        if let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind {\n-            let opaque_ty = hir.item(id);\n-            if let hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                bounds:\n-                    [\n-                        hir::GenericBound::LangItemTrait(\n-                            hir::LangItem::Future,\n-                            _,\n-                            _,\n-                            hir::GenericArgs {\n-                                bindings:\n-                                    [\n-                                        hir::TypeBinding {\n-                                            ident: Ident { name: sym::Output, .. },\n-                                            kind:\n-                                                hir::TypeBindingKind::Equality {\n-                                                    term: hir::Term::Ty(ty),\n-                                                },\n-                                            ..\n-                                        },\n-                                    ],\n-                                ..\n-                            },\n-                        ),\n-                    ],\n-                ..\n-            }) = opaque_ty.kind\n-            {\n-                ty\n-            } else {\n-                span_bug!(\n-                    hir_ty.span,\n-                    \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n-                    opaque_ty\n-                );\n-            }\n-        } else {\n+        let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind else {\n             span_bug!(\n                 hir_ty.span,\n                 \"lowered return type of async fn is not OpaqueDef: {:?}\",\n                 hir_ty\n             );\n+        };\n+        let opaque_ty = hir.item(id);\n+        if let hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+            bounds:\n+                [\n+                    hir::GenericBound::LangItemTrait(\n+                        hir::LangItem::Future,\n+                        _,\n+                        _,\n+                        hir::GenericArgs {\n+                            bindings:\n+                                [\n+                                    hir::TypeBinding {\n+                                        ident: Ident { name: sym::Output, .. },\n+                                        kind:\n+                                            hir::TypeBindingKind::Equality { term: hir::Term::Ty(ty) },\n+                                        ..\n+                                    },\n+                                ],\n+                            ..\n+                        },\n+                    ),\n+                ],\n+            ..\n+        }) = opaque_ty.kind\n+        {\n+            ty\n+        } else {\n+            span_bug!(\n+                hir_ty.span,\n+                \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n+                opaque_ty\n+            );\n         }\n     }\n "}, {"sha": "5597a8b091554769adc7dd0f07be095b02ea8739", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -1427,9 +1427,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             bug!(\"temporary should be initialized exactly once\")\n                         };\n \n-                        let loc = match init.location {\n-                            InitLocation::Statement(stmt) => stmt,\n-                            _ => bug!(\"temporary initialized in arguments\"),\n+                        let InitLocation::Statement(loc) = init.location else {\n+                            bug!(\"temporary initialized in arguments\")\n                         };\n \n                         let body = self.body;"}, {"sha": "cf15fc4ddc3a54fa3fe60f13453274462fbb6831", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -55,6 +55,7 @@ impl<'tcx> MirPass<'tcx> for Validator {\n             reachable_blocks: traversal::reachable_as_bitset(body),\n             storage_liveness,\n             place_cache: Vec::new(),\n+            value_cache: Vec::new(),\n         }\n         .visit_body(body);\n     }\n@@ -109,6 +110,7 @@ struct TypeChecker<'a, 'tcx> {\n     reachable_blocks: BitSet<BasicBlock>,\n     storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n     place_cache: Vec<PlaceRef<'tcx>>,\n+    value_cache: Vec<u128>,\n }\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n@@ -398,6 +400,22 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.check_edge(location, target, EdgeKind::Normal);\n                 }\n                 self.check_edge(location, targets.otherwise(), EdgeKind::Normal);\n+\n+                self.value_cache.clear();\n+                self.value_cache.extend(targets.iter().map(|(value, _)| value));\n+                let all_len = self.value_cache.len();\n+                self.value_cache.sort_unstable();\n+                self.value_cache.dedup();\n+                let has_duplicates = all_len != self.value_cache.len();\n+                if has_duplicates {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"duplicated values in `SwitchInt` terminator: {:?}\",\n+                            terminator.kind,\n+                        ),\n+                    );\n+                }\n             }\n             TerminatorKind::Drop { target, unwind, .. } => {\n                 self.check_edge(location, *target, EdgeKind::Normal);"}, {"sha": "e931379dd3a70d5d7416e034d1877d01f0605dd8", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -3,6 +3,9 @@ use rustc_serialize::{Decodable, Encodable};\n use std::convert::TryInto;\n use std::hash::{Hash, Hasher};\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy)]\n #[repr(C)]\n pub struct Fingerprint(u64, u64);\n@@ -54,7 +57,7 @@ impl Fingerprint {\n \n         let c = a.wrapping_add(b);\n \n-        Fingerprint((c >> 64) as u64, c as u64)\n+        Fingerprint(c as u64, (c >> 64) as u64)\n     }\n \n     pub fn to_hex(&self) -> String {"}, {"sha": "9b0783e33ab472e6b32b0055631e20c8f47cf964", "filename": "compiler/rustc_data_structures/src/fingerprint/tests.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint%2Ftests.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,14 @@\n+use super::*;\n+\n+// Check that `combine_commutative` is order independent.\n+#[test]\n+fn combine_commutative_is_order_independent() {\n+    let a = Fingerprint::new(0xf6622fb349898b06, 0x70be9377b2f9c610);\n+    let b = Fingerprint::new(0xa9562bf5a2a5303c, 0x67d9b6c82034f13d);\n+    let c = Fingerprint::new(0x0d013a27811dbbc3, 0x9a3f7b3d9142ec43);\n+    let permutations = [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)];\n+    let f = a.combine_commutative(b).combine_commutative(c);\n+    for p in &permutations {\n+        assert_eq!(f, p.0.combine_commutative(p.1).combine_commutative(p.2));\n+    }\n+}"}, {"sha": "6329bcee4fa3f1c6eb4e12c4c53d73439f5f71dd", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -602,33 +602,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                    if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                    let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                         VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n-                    )))) = self.local_decls[local].local_info\n-                    {\n-                        // `try_upvars_resolved` may fail if it is unable to resolve the given\n-                        // `PlaceBuilder` inside a closure. In this case, we don't want to include\n-                        // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n-                        // assignments. This is because a closure only captures the precise places\n-                        // that it will read and as a result a closure may not capture the entire\n-                        // tuple/struct and rather have individual places that will be read in the\n-                        // final MIR.\n-                        // Example:\n-                        // ```\n-                        // let foo = (0, 1);\n-                        // let c = || {\n-                        //    let (v1, v2) = foo;\n-                        // };\n-                        // ```\n-                        if let Ok(match_pair_resolved) =\n-                            initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n-                        {\n-                            let place =\n-                                match_pair_resolved.into_place(self.tcx, self.typeck_results);\n-                            *match_place = Some(place);\n-                        }\n-                    } else {\n+                    )))) = self.local_decls[local].local_info else {\n                         bug!(\"Let binding to non-user variable.\")\n+                    };\n+                    // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                    // `PlaceBuilder` inside a closure. In this case, we don't want to include\n+                    // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n+                    // assignments. This is because a closure only captures the precise places\n+                    // that it will read and as a result a closure may not capture the entire\n+                    // tuple/struct and rather have individual places that will be read in the\n+                    // final MIR.\n+                    // Example:\n+                    // ```\n+                    // let foo = (0, 1);\n+                    // let c = || {\n+                    //    let (v1, v2) = foo;\n+                    // };\n+                    // ```\n+                    if let Ok(match_pair_resolved) =\n+                        initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                    {\n+                        let place = match_pair_resolved.into_place(self.tcx, self.typeck_results);\n+                        *match_place = Some(place);\n                     }\n                 }\n                 // All of the subcandidates should bind the same locals, so we"}, {"sha": "49cd21c2137b78c32dd3adb88918c2f73d847a8d", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -227,16 +227,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let target_blocks = make_target_blocks(self);\n                 let terminator = if *switch_ty.kind() == ty::Bool {\n                     assert!(!options.is_empty() && options.len() <= 2);\n-                    if let [first_bb, second_bb] = *target_blocks {\n-                        let (true_bb, false_bb) = match options[0] {\n-                            1 => (first_bb, second_bb),\n-                            0 => (second_bb, first_bb),\n-                            v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n-                        };\n-                        TerminatorKind::if_(self.tcx, Operand::Copy(place), true_bb, false_bb)\n-                    } else {\n+                    let [first_bb, second_bb] = *target_blocks else {\n                         bug!(\"`TestKind::SwitchInt` on `bool` should have two targets\")\n-                    }\n+                    };\n+                    let (true_bb, false_bb) = match options[0] {\n+                        1 => (first_bb, second_bb),\n+                        0 => (second_bb, first_bb),\n+                        v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n+                    };\n+                    TerminatorKind::if_(self.tcx, Operand::Copy(place), true_bb, false_bb)\n                 } else {\n                     // The switch may be inexhaustive so we have a catch all block\n                     debug_assert_eq!(options.len() + 1, target_blocks.len());\n@@ -285,24 +284,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let hi = self.literal_operand(test.span, hi);\n                 let val = Operand::Copy(place);\n \n-                if let [success, fail] = *target_blocks {\n-                    self.compare(\n-                        block,\n-                        lower_bound_success,\n-                        fail,\n-                        source_info,\n-                        BinOp::Le,\n-                        lo,\n-                        val.clone(),\n-                    );\n-                    let op = match *end {\n-                        RangeEnd::Included => BinOp::Le,\n-                        RangeEnd::Excluded => BinOp::Lt,\n-                    };\n-                    self.compare(lower_bound_success, success, fail, source_info, op, val, hi);\n-                } else {\n+                let [success, fail] = *target_blocks else {\n                     bug!(\"`TestKind::Range` should have two target blocks\");\n-                }\n+                };\n+                self.compare(\n+                    block,\n+                    lower_bound_success,\n+                    fail,\n+                    source_info,\n+                    BinOp::Le,\n+                    lo,\n+                    val.clone(),\n+                );\n+                let op = match *end {\n+                    RangeEnd::Included => BinOp::Le,\n+                    RangeEnd::Excluded => BinOp::Lt,\n+                };\n+                self.compare(lower_bound_success, success, fail, source_info, op, val, hi);\n             }\n \n             TestKind::Len { len, op } => {\n@@ -317,21 +315,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // expected = <N>\n                 let expected = self.push_usize(block, source_info, len);\n \n-                if let [true_bb, false_bb] = *target_blocks {\n-                    // result = actual == expected OR result = actual < expected\n-                    // branch based on result\n-                    self.compare(\n-                        block,\n-                        true_bb,\n-                        false_bb,\n-                        source_info,\n-                        op,\n-                        Operand::Move(actual),\n-                        Operand::Move(expected),\n-                    );\n-                } else {\n+                let [true_bb, false_bb] = *target_blocks else {\n                     bug!(\"`TestKind::Len` should have two target blocks\");\n-                }\n+                };\n+                // result = actual == expected OR result = actual < expected\n+                // branch based on result\n+                self.compare(\n+                    block,\n+                    true_bb,\n+                    false_bb,\n+                    source_info,\n+                    op,\n+                    Operand::Move(actual),\n+                    Operand::Move(expected),\n+                );\n             }\n         }\n     }\n@@ -459,16 +456,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n         self.diverge_from(block);\n \n-        if let [success_block, fail_block] = *make_target_blocks(self) {\n-            // check the result\n-            self.cfg.terminate(\n-                eq_block,\n-                source_info,\n-                TerminatorKind::if_(self.tcx, Operand::Move(eq_result), success_block, fail_block),\n-            );\n-        } else {\n+        let [success_block, fail_block] = *make_target_blocks(self) else {\n             bug!(\"`TestKind::Eq` should have two target blocks\")\n-        }\n+        };\n+        // check the result\n+        self.cfg.terminate(\n+            eq_block,\n+            source_info,\n+            TerminatorKind::if_(self.tcx, Operand::Move(eq_result), success_block, fail_block),\n+        );\n     }\n \n     /// Given that we are performing `test` against `test_place`, this job"}, {"sha": "62ed104aef37c0cd65fede734171721973fbab31", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::token;\n use rustc_ast::{\n     self as ast, Attribute, GenericBounds, GenericParam, GenericParamKind, WhereClause,\n };\n-use rustc_errors::PResult;\n+use rustc_errors::{Applicability, PResult};\n use rustc_span::symbol::kw;\n \n impl<'a> Parser<'a> {\n@@ -256,7 +256,21 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n \n-            if !self.eat(&token::Comma) {\n+            let prev_token = self.prev_token.span;\n+            let ate_comma = self.eat(&token::Comma);\n+\n+            if self.eat_keyword_noexpect(kw::Where) {\n+                let msg = &format!(\"cannot define duplicate `where` clauses on an item\");\n+                let mut err = self.struct_span_err(self.token.span, msg);\n+                err.span_label(lo, \"previous `where` clause starts here\");\n+                err.span_suggestion_verbose(\n+                    prev_token.shrink_to_hi().to(self.prev_token.span),\n+                    \"consider joining the two `where` clauses into one\",\n+                    \",\".to_owned(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n+            } else if !ate_comma {\n                 break;\n             }\n         }"}, {"sha": "93f5d79c0db1338ce60405269b7c57fa44c71f86", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -1221,7 +1221,7 @@ impl<'a> Parser<'a> {\n \n                 let struct_def = if this.check(&token::OpenDelim(token::Brace)) {\n                     // Parse a struct variant.\n-                    let (fields, recovered) = this.parse_record_struct_body(\"struct\")?;\n+                    let (fields, recovered) = this.parse_record_struct_body(\"struct\", false)?;\n                     VariantData::Struct(fields, recovered)\n                 } else if this.check(&token::OpenDelim(token::Paren)) {\n                     VariantData::Tuple(this.parse_tuple_struct_body()?, DUMMY_NODE_ID)\n@@ -1275,15 +1275,17 @@ impl<'a> Parser<'a> {\n                 VariantData::Unit(DUMMY_NODE_ID)\n             } else {\n                 // If we see: `struct Foo<T> where T: Copy { ... }`\n-                let (fields, recovered) = self.parse_record_struct_body(\"struct\")?;\n+                let (fields, recovered) =\n+                    self.parse_record_struct_body(\"struct\", generics.where_clause.has_where_token)?;\n                 VariantData::Struct(fields, recovered)\n             }\n         // No `where` so: `struct Foo<T>;`\n         } else if self.eat(&token::Semi) {\n             VariantData::Unit(DUMMY_NODE_ID)\n         // Record-style struct definition\n         } else if self.token == token::OpenDelim(token::Brace) {\n-            let (fields, recovered) = self.parse_record_struct_body(\"struct\")?;\n+            let (fields, recovered) =\n+                self.parse_record_struct_body(\"struct\", generics.where_clause.has_where_token)?;\n             VariantData::Struct(fields, recovered)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n@@ -1313,10 +1315,12 @@ impl<'a> Parser<'a> {\n \n         let vdata = if self.token.is_keyword(kw::Where) {\n             generics.where_clause = self.parse_where_clause()?;\n-            let (fields, recovered) = self.parse_record_struct_body(\"union\")?;\n+            let (fields, recovered) =\n+                self.parse_record_struct_body(\"union\", generics.where_clause.has_where_token)?;\n             VariantData::Struct(fields, recovered)\n         } else if self.token == token::OpenDelim(token::Brace) {\n-            let (fields, recovered) = self.parse_record_struct_body(\"union\")?;\n+            let (fields, recovered) =\n+                self.parse_record_struct_body(\"union\", generics.where_clause.has_where_token)?;\n             VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = super::token_descr(&self.token);\n@@ -1332,6 +1336,7 @@ impl<'a> Parser<'a> {\n     fn parse_record_struct_body(\n         &mut self,\n         adt_ty: &str,\n+        parsed_where: bool,\n     ) -> PResult<'a, (Vec<FieldDef>, /* recovered */ bool)> {\n         let mut fields = Vec::new();\n         let mut recovered = false;\n@@ -1353,9 +1358,19 @@ impl<'a> Parser<'a> {\n             self.eat(&token::CloseDelim(token::Brace));\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let msg = &format!(\"expected `where`, or `{{` after struct name, found {}\", token_str);\n+            let msg = &format!(\n+                \"expected {}`{{` after struct name, found {}\",\n+                if parsed_where { \"\" } else { \"`where`, or \" },\n+                token_str\n+            );\n             let mut err = self.struct_span_err(self.token.span, msg);\n-            err.span_label(self.token.span, \"expected `where`, or `{` after struct name\");\n+            err.span_label(\n+                self.token.span,\n+                format!(\n+                    \"expected {}`{{` after struct name\",\n+                    if parsed_where { \"\" } else { \"`where`, or \" }\n+                ),\n+            );\n             return Err(err);\n         }\n "}, {"sha": "a3f7e84b1d524b5ccca0d5feb7481813c5c691da", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -47,11 +47,10 @@ use rls_data::{\n \n use tracing::{debug, error};\n \n+#[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5213\n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $sp:expr) => {\n-        let $id = if let super::Data::$kind(data) = $id {\n-            data\n-        } else {\n+        let super::Data::$kind($id) = $id else {\n             span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n         };\n     };"}, {"sha": "2eebddb47df5c24d2f7f4ea74ad05c36996d8b18", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(if_let_guard)]\n #![feature(nll)]\n+#![feature(let_else)]\n #![recursion_limit = \"256\"]\n #![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]\n "}, {"sha": "82cda5a2f2e738fdee2b2c9c3571127c76b31e90", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -865,14 +865,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ),\n                     ..\n                 }) => {\n-                    // We have a situation like `while Some(0) = value.get(0) {`, where `while let`\n-                    // was more likely intended.\n-                    err.span_suggestion_verbose(\n-                        expr.span.shrink_to_lo(),\n-                        \"you might have meant to use pattern destructuring\",\n-                        \"let \".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n+                    // Check if our lhs is a child of the condition of a while loop\n+                    let expr_is_ancestor = std::iter::successors(Some(lhs.hir_id), |id| {\n+                        self.tcx.hir().find_parent_node(*id)\n+                    })\n+                    .take_while(|id| *id != parent)\n+                    .any(|id| id == expr.hir_id);\n+                    // if it is, then we have a situation like `while Some(0) = value.get(0) {`,\n+                    // where `while let` was more likely intended.\n+                    if expr_is_ancestor {\n+                        err.span_suggestion_verbose(\n+                            expr.span.shrink_to_lo(),\n+                            \"you might have meant to use pattern destructuring\",\n+                            \"let \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                     break;\n                 }\n                 hir::Node::Item(_)"}, {"sha": "95404b33822e363e1b26fcb545066d954f6056ab", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -1427,15 +1427,25 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n         return None;\n     }\n \n+    use crate::rustc_trait_selection::infer::TyCtxtInferExt;\n+    use crate::rustc_trait_selection::traits::query::normalize::AtExt;\n+    use rustc_middle::traits::ObligationCause;\n+\n     // Try to normalize `<X as Y>::T` to a type\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n-    match cx.tcx.try_normalize_erasing_regions(cx.param_env, lifted) {\n+    let normalized = cx.tcx.infer_ctxt().enter(|infcx| {\n+        infcx\n+            .at(&ObligationCause::dummy(), cx.param_env)\n+            .normalize(lifted)\n+            .map(|resolved| infcx.resolve_vars_if_possible(resolved.value))\n+    });\n+    match normalized {\n         Ok(normalized_value) => {\n-            trace!(\"normalized {:?} to {:?}\", ty, normalized_value);\n+            debug!(\"normalized {:?} to {:?}\", ty, normalized_value);\n             Some(normalized_value)\n         }\n         Err(err) => {\n-            info!(\"failed to normalize {:?}: {:?}\", ty, err);\n+            debug!(\"failed to normalize {:?}: {:?}\", ty, err);\n             None\n         }\n     }"}, {"sha": "5d30a745a61a6027e4d3c8dab75fb571baff0717", "filename": "src/test/rustdoc/lifetime-name.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Frustdoc%2Flifetime-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Frustdoc%2Flifetime-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Flifetime-name.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,5 @@\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/type.Resolutions.html'\n+// @has - '//*[@class=\"rust typedef\"]' \"pub type Resolutions<'tcx> = &'tcx u8;\"\n+pub type Resolutions<'tcx> = &'tcx u8;"}, {"sha": "f4db5ecafac40a6be0600830a20bff70cc3de149", "filename": "src/test/ui/borrowck/issue-93093.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fborrowck%2Fissue-93093.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fborrowck%2Fissue-93093.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-93093.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,14 @@\n+// edition:2018\n+struct S {\n+    foo: usize,\n+}\n+impl S {\n+    async fn bar(&self) { //~ HELP consider changing this to be a mutable reference\n+        //~| SUGGESTION &mut self\n+        self.foo += 1; //~ ERROR cannot assign to `self.foo`, which is behind a `&` reference [E0594]\n+    }\n+}\n+\n+fn main() {\n+    S { foo: 1 }.bar();\n+}"}, {"sha": "031128af47655e34fa8cef6f8552eb2f887afabe", "filename": "src/test/ui/borrowck/issue-93093.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fborrowck%2Fissue-93093.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fborrowck%2Fissue-93093.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-93093.stderr?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,12 @@\n+error[E0594]: cannot assign to `self.foo`, which is behind a `&` reference\n+  --> $DIR/issue-93093.rs:8:9\n+   |\n+LL |     async fn bar(&self) {\n+   |                  ----- help: consider changing this to be a mutable reference: `&mut self`\n+LL |\n+LL |         self.foo += 1;\n+   |         ^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "823880b1b42c615a2f6090843f36352117b3a582", "filename": "src/test/ui/parser/bad-struct-following-where.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fparser%2Fbad-struct-following-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fparser%2Fbad-struct-following-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-struct-following-where.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,2 @@\n+struct A where T: Sized !\n+//~^ ERROR expected `{` after struct name, found"}, {"sha": "bb79776dc8459ba550559320579c634fb6ce9dbb", "filename": "src/test/ui/parser/bad-struct-following-where.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fparser%2Fbad-struct-following-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fparser%2Fbad-struct-following-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-struct-following-where.stderr?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,8 @@\n+error: expected `{` after struct name, found `!`\n+  --> $DIR/bad-struct-following-where.rs:1:25\n+   |\n+LL | struct A where T: Sized !\n+   |                         ^ expected `{` after struct name\n+\n+error: aborting due to previous error\n+"}, {"sha": "9eb2ffb06f02da872d1693c3a424e911bf9abc6b", "filename": "src/test/ui/parser/duplicate-where-clauses.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fparser%2Fduplicate-where-clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fparser%2Fduplicate-where-clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-where-clauses.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,19 @@\n+struct A where (): Sized where (): Sized {}\n+//~^ ERROR cannot define duplicate `where` clauses on an item\n+\n+fn b() where (): Sized where (): Sized {}\n+//~^ ERROR cannot define duplicate `where` clauses on an item\n+\n+enum C where (): Sized where (): Sized {}\n+//~^ ERROR cannot define duplicate `where` clauses on an item\n+\n+struct D where (): Sized, where (): Sized {}\n+//~^ ERROR cannot define duplicate `where` clauses on an item\n+\n+fn e() where (): Sized, where (): Sized {}\n+//~^ ERROR cannot define duplicate `where` clauses on an item\n+\n+enum F where (): Sized, where (): Sized {}\n+//~^ ERROR cannot define duplicate `where` clauses on an item\n+\n+fn main() {}"}, {"sha": "8250d4f1e056842c19c05f8c761c7398ad91ab6c", "filename": "src/test/ui/parser/duplicate-where-clauses.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fparser%2Fduplicate-where-clauses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Fparser%2Fduplicate-where-clauses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-where-clauses.stderr?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,80 @@\n+error: cannot define duplicate `where` clauses on an item\n+  --> $DIR/duplicate-where-clauses.rs:1:32\n+   |\n+LL | struct A where (): Sized where (): Sized {}\n+   |                -               ^\n+   |                |\n+   |                previous `where` clause starts here\n+   |\n+help: consider joining the two `where` clauses into one\n+   |\n+LL | struct A where (): Sized, (): Sized {}\n+   |                         ~\n+\n+error: cannot define duplicate `where` clauses on an item\n+  --> $DIR/duplicate-where-clauses.rs:4:30\n+   |\n+LL | fn b() where (): Sized where (): Sized {}\n+   |              -               ^\n+   |              |\n+   |              previous `where` clause starts here\n+   |\n+help: consider joining the two `where` clauses into one\n+   |\n+LL | fn b() where (): Sized, (): Sized {}\n+   |                       ~\n+\n+error: cannot define duplicate `where` clauses on an item\n+  --> $DIR/duplicate-where-clauses.rs:7:30\n+   |\n+LL | enum C where (): Sized where (): Sized {}\n+   |              -               ^\n+   |              |\n+   |              previous `where` clause starts here\n+   |\n+help: consider joining the two `where` clauses into one\n+   |\n+LL | enum C where (): Sized, (): Sized {}\n+   |                       ~\n+\n+error: cannot define duplicate `where` clauses on an item\n+  --> $DIR/duplicate-where-clauses.rs:10:33\n+   |\n+LL | struct D where (): Sized, where (): Sized {}\n+   |                -                ^\n+   |                |\n+   |                previous `where` clause starts here\n+   |\n+help: consider joining the two `where` clauses into one\n+   |\n+LL | struct D where (): Sized, (): Sized {}\n+   |                         ~\n+\n+error: cannot define duplicate `where` clauses on an item\n+  --> $DIR/duplicate-where-clauses.rs:13:31\n+   |\n+LL | fn e() where (): Sized, where (): Sized {}\n+   |              -                ^\n+   |              |\n+   |              previous `where` clause starts here\n+   |\n+help: consider joining the two `where` clauses into one\n+   |\n+LL | fn e() where (): Sized, (): Sized {}\n+   |                       ~\n+\n+error: cannot define duplicate `where` clauses on an item\n+  --> $DIR/duplicate-where-clauses.rs:16:31\n+   |\n+LL | enum F where (): Sized, where (): Sized {}\n+   |              -                ^\n+   |              |\n+   |              previous `where` clause starts here\n+   |\n+help: consider joining the two `where` clauses into one\n+   |\n+LL | enum F where (): Sized, (): Sized {}\n+   |                       ~\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "f8f98d5c1c7dcd038e1efb7f52f48d1309756f0d", "filename": "src/test/ui/typeck/issue-93486.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.rs?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    while let 1 = 1 {\n+        vec![].last_mut().unwrap() = 3_u8;\n+        //~^ ERROR invalid left-hand side of assignment\n+    }\n+}"}, {"sha": "70b5b63f1cba7ccb7034b6ecf3e1068e5ada37ad", "filename": "src/test/ui/typeck/issue-93486.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27f5d830eb11cd7bdc834d6f0d78120976f75443/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr?ref=27f5d830eb11cd7bdc834d6f0d78120976f75443", "patch": "@@ -0,0 +1,11 @@\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/issue-93486.rs:3:36\n+   |\n+LL |         vec![].last_mut().unwrap() = 3_u8;\n+   |         -------------------------- ^\n+   |         |\n+   |         cannot assign to this expression\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0070`."}]}