{"sha": "7ccb0e63c5d1372f970f592b2d0b531ce591a63d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjY2IwZTYzYzVkMTM3MmY5NzBmNTkyYjJkMGI1MzFjZTU5MWE2M2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-07T23:36:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-08T14:53:45Z"}, "message": "core: Remove uses of DVec in io/repr", "tree": {"sha": "d51d84109ff04ca3376ff16af9c48208f1689e51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d51d84109ff04ca3376ff16af9c48208f1689e51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ccb0e63c5d1372f970f592b2d0b531ce591a63d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ccb0e63c5d1372f970f592b2d0b531ce591a63d", "html_url": "https://github.com/rust-lang/rust/commit/7ccb0e63c5d1372f970f592b2d0b531ce591a63d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ccb0e63c5d1372f970f592b2d0b531ce591a63d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "647a94d01a54a75e08fd1b6fa74761f70874bafe", "url": "https://api.github.com/repos/rust-lang/rust/commits/647a94d01a54a75e08fd1b6fa74761f70874bafe", "html_url": "https://github.com/rust-lang/rust/commit/647a94d01a54a75e08fd1b6fa74761f70874bafe"}], "stats": {"total": 72, "additions": 34, "deletions": 38}, "files": [{"sha": "34fa4c972ea771c4ed500630e7019cf7666acb8f", "filename": "src/libcore/io.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7ccb0e63c5d1372f970f592b2d0b531ce591a63d/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccb0e63c5d1372f970f592b2d0b531ce591a63d/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=7ccb0e63c5d1372f970f592b2d0b531ce591a63d", "patch": "@@ -16,7 +16,6 @@ Basic input/output\n \n use result::Result;\n \n-use dvec::DVec;\n use int;\n use libc;\n use libc::{c_int, c_long, c_uint, c_void, size_t, ssize_t};\n@@ -1109,30 +1108,25 @@ pub fn print(s: &str) { stdout().write_str(s); }\n pub fn println(s: &str) { stdout().write_line(s); }\n \n pub struct BytesWriter {\n-    bytes: DVec<u8>,\n+    mut bytes: ~[u8],\n     mut pos: uint,\n }\n \n impl Writer for BytesWriter {\n     fn write(&self, v: &[const u8]) {\n-        do self.bytes.swap |bytes| {\n-            let mut bytes = bytes;\n-            let v_len = v.len();\n-            let bytes_len = bytes.len();\n-\n-            let count = uint::max(bytes_len, self.pos + v_len);\n-            vec::reserve(&mut bytes, count);\n-            unsafe { vec::raw::set_len(&mut bytes, count); }\n-\n-            {\n-                let view = vec::mut_slice(bytes, self.pos, count);\n-                vec::bytes::copy_memory(view, v, v_len);\n-            }\n+        let v_len = v.len();\n+        let bytes_len = self.bytes.len();\n \n-            self.pos += v_len;\n+        let count = uint::max(bytes_len, self.pos + v_len);\n+        vec::reserve(&mut self.bytes, count);\n \n-            bytes\n+        unsafe {\n+            vec::raw::set_len(&mut self.bytes, count);\n+            let view = vec::mut_slice(self.bytes, self.pos, count);\n+            vec::bytes::copy_memory(view, v, v_len);\n         }\n+\n+        self.pos += v_len;\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n@@ -1145,14 +1139,14 @@ impl Writer for BytesWriter {\n }\n \n pub pure fn BytesWriter() -> BytesWriter {\n-    BytesWriter { bytes: DVec(), mut pos: 0u }\n+    BytesWriter { bytes: ~[], mut pos: 0u }\n }\n \n pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n-    // FIXME (#3758): This should not be needed.\n-    unsafe { wr.bytes.check_out(|bytes| bytes) }\n+    let @BytesWriter{bytes, _} = wr;\n+    return bytes;\n }\n \n pub pure fn with_str_writer(f: fn(Writer)) -> ~str {"}, {"sha": "e9122754eb42a10871160fcf935883ccd5628349", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7ccb0e63c5d1372f970f592b2d0b531ce591a63d/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccb0e63c5d1372f970f592b2d0b531ce591a63d/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=7ccb0e63c5d1372f970f592b2d0b531ce591a63d", "patch": "@@ -16,7 +16,6 @@ More runtime type reflection\n \n use cast::transmute;\n use char;\n-use dvec::DVec;\n use intrinsic;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n use io::{Writer, WriterUtil};\n@@ -147,14 +146,14 @@ enum VariantState {\n \n pub struct ReprVisitor {\n     mut ptr: *c_void,\n-    ptr_stk: DVec<*c_void>,\n-    var_stk: DVec<VariantState>,\n+    mut ptr_stk: ~[*c_void],\n+    mut var_stk: ~[VariantState],\n     writer: @Writer\n }\n pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n     ReprVisitor { ptr: ptr,\n-                  ptr_stk: DVec(),\n-                  var_stk: DVec(),\n+                  ptr_stk: ~[],\n+                  var_stk: ~[],\n                   writer: writer }\n }\n \n@@ -500,7 +499,7 @@ impl TyVisitor for ReprVisitor {\n     }\n \n     fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        match self.var_stk.last() {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Degenerate | TagMatch => {\n                 if i != 0 {\n                     self.writer.write_str(\", \");\n@@ -518,7 +517,7 @@ impl TyVisitor for ReprVisitor {\n                                 _disr_val: int,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n-        match self.var_stk.last() {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Degenerate | TagMatch => {\n                 if n_fields > 0 {\n                     self.writer.write_char(')');"}, {"sha": "f035916f59423aaf6d45ac9d6121481806ee659a", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7ccb0e63c5d1372f970f592b2d0b531ce591a63d/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccb0e63c5d1372f970f592b2d0b531ce591a63d/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=7ccb0e63c5d1372f970f592b2d0b531ce591a63d", "patch": "@@ -12,7 +12,6 @@\n \n use cast;\n use cmp::Eq;\n-use dvec;\n use libc;\n use option;\n use prelude::*;\n@@ -35,11 +34,11 @@ impl Eq for LocalData {\n     pure fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n }\n \n-// We use dvec because it's the best data structure in core. If TLS is used\n-// heavily in future, this could be made more efficient with a proper map.\n+// If TLS is used heavily in future, this could be made more efficient with a\n+// proper map.\n type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n+type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n@@ -60,17 +59,21 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     // drop when they finish. No \"re-storing after modifying\" is needed.\n     let map_ptr = rt::rust_get_task_local_data(task);\n     if map_ptr.is_null() {\n-        let map: TaskLocalMap = @dvec::DVec();\n+        let map: TaskLocalMap = @mut ~[];\n         // Use reinterpret_cast -- transmute would take map away from us also.\n         rt::rust_set_task_local_data(\n             task, cast::reinterpret_cast(&map));\n         rt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n         // Also need to reference it an extra time to keep it for now.\n-        cast::bump_box_refcount(map);\n+        let nonmut = cast::transmute::<TaskLocalMap,\n+                                       @~[Option<TaskLocalElement>]>(map);\n+        cast::bump_box_refcount(nonmut);\n         map\n     } else {\n         let map = cast::transmute(map_ptr);\n-        cast::bump_box_refcount(map);\n+        let nonmut = cast::transmute::<TaskLocalMap,\n+                                       @~[Option<TaskLocalElement>]>(map);\n+        cast::bump_box_refcount(nonmut);\n         map\n     }\n }\n@@ -118,7 +121,7 @@ unsafe fn local_get_helper<T:Durable>(\n         let data: @T = cast::transmute(data_ptr);\n         cast::bump_box_refcount(data);\n         if do_pop {\n-            (*map).set_elt(index, None);\n+            map[index] = None;\n         }\n         data\n     }\n@@ -159,13 +162,13 @@ pub unsafe fn local_set<T:Durable>(\n         Some((index, _old_data_ptr)) => {\n             // Key already had a value set, _old_data_ptr, whose reference\n             // will get dropped when the local_data box is overwritten.\n-            (*map).set_elt(index, new_entry);\n+            map[index] = new_entry;\n         }\n         None => {\n             // Find an empty slot. If not, grow the vector.\n             match (*map).position(|x| x.is_none()) {\n-                Some(empty_index) => (*map).set_elt(empty_index, new_entry),\n-                None => (*map).push(new_entry)\n+                Some(empty_index) => { map[empty_index] = new_entry; }\n+                None => { map.push(new_entry); }\n             }\n         }\n     }"}]}