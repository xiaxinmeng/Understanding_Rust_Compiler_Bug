{"sha": "19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZGQxZmQ0ZDQxNTM4ZGU3ZWEzODZhMmQwZDE4ZTI3YmY5NWY2M2M=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-12T14:23:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-12T14:23:32Z"}, "message": "Merge #7904\n\n7904: Improved completion sorting r=JoshMcguigan a=JoshMcguigan\n\nI was working on extending #3954 to apply completion scores in more places (I'll have another PR open for that soon) when I discovered that actually completion sorting was not working for me at all in `coc.nvim`. This led me down a bit of a rabbit hole of how coc and vs code each sort completion items.\r\n\r\nBefore this PR, rust-analyzer was setting the `sortText` field on completion items to `None` if we hadn't applied any completion score for that item, or to the label of the item with a leading whitespace character if we had applied any completion score. Completion score is defined in rust-analyzer as an enum with two variants, `TypeMatch` and `TypeAndNameMatch`. \r\n\r\nIn vs code the above strategy works, because if `sortText` isn't set [they default it to the label](https://github.com/microsoft/vscode/commit/b4ead4ed665e1ce2e58d8329c682f78da2d4e89d). However, coc [does not do this](https://github.com/neoclide/coc.nvim/blob/e211e361475a38b146a903b9b02343551c6cd372/src/completion/complete.ts#L245).\r\n\r\nI was going to file a bug report against coc, but I read the [LSP spec for the `sortText` field](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion) and I feel like it is ambiguous and coc could claim what they do is a valid interpretation of the spec.\r\n\r\nFurther, the existing rust-analyzer behavior of prepending a leading whitespace character for completion items with any completion score does not handle sorting `TypeAndNameMatch` completions above `TypeMatch` completions. They were both being treated the same.\r\n\r\nThe first change this PR makes is to set the `sortText` field to either \"1\" for `TypeAndNameMatch` completions, \"2\" for `TypeMatch` completions, or \"3\" for completions which are neither of those. This change works around the potential ambiguity in the LSP spec and fixes completion sorting for users of coc. It also allows `TypeAndNameMatch` items to be sorted above just `TypeMatch` items (of course both of these will be sorted above completion items without a score). \r\n\r\nThe second change this PR makes is to use the actual completion scores for ref matches. The existing code ignored the actual score and always assumed these would be a high priority completion item.\r\n\r\n#### Before\r\n\r\nHere coc just sorts based on how close the items are in the file.\r\n\r\n![image](https://user-images.githubusercontent.com/22216761/110249880-46063580-7f2d-11eb-9233-91a2bbd48238.png)\r\n\r\n#### After\r\n\r\nHere we correctly get `zzz` first, since that is both a type and name match. Then we get `ccc` which is just a type match.\r\n\r\n![image](https://user-images.githubusercontent.com/22216761/110249883-4e5e7080-7f2d-11eb-9269-a3bc133fdee7.png)\r\n\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>", "tree": {"sha": "8f7d8057858f366060b6e71c027a3053269a1c8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f7d8057858f366060b6e71c027a3053269a1c8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgS3lkCRBK7hj4Ov3rIwAAdHIIAAUOanqRXRaR7r7D+xYWOTxL\n1Bm2pI/mp9/fy27aDxPvs6fBFOvnYejEx3rrF1HL6GVzOJ9vdrYZKh//UoO5soW8\nvpwjsj9NurHXkHi33vmwnKQxwX0xyhD1IqqNCb4HoGjNO8UMmVykDPCqZdIA7355\n/3tqoIwtaRcBuhITzDTf37hux4nNo6C4J1nb/7v6LjonlWudt1t16z5hkxnnU9dS\nLyEnuQlYNIaoWIvx0ZXJXR2km3mDmbE0e59EFvh2q4Ty/SJ+73vkeihsZq5ahcpm\ncnnjiDqtOQBKM7zPQoxGWDOvQFPzeX27lPL0RWDshHRA48vjp4qIj1Kt7iF0eYE=\n=IXzp\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f7d8057858f366060b6e71c027a3053269a1c8d\nparent 393e2356594560dec84e73471f26a366a6fc91dd\nparent acbe297fbd10250e0d99d1e3e98751dd6ef77adc\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615559012 +0000\ncommitter GitHub <noreply@github.com> 1615559012 +0000\n\nMerge #7904\n\n7904: Improved completion sorting r=JoshMcguigan a=JoshMcguigan\n\nI was working on extending #3954 to apply completion scores in more places (I'll have another PR open for that soon) when I discovered that actually completion sorting was not working for me at all in `coc.nvim`. This led me down a bit of a rabbit hole of how coc and vs code each sort completion items.\r\n\r\nBefore this PR, rust-analyzer was setting the `sortText` field on completion items to `None` if we hadn't applied any completion score for that item, or to the label of the item with a leading whitespace character if we had applied any completion score. Completion score is defined in rust-analyzer as an enum with two variants, `TypeMatch` and `TypeAndNameMatch`. \r\n\r\nIn vs code the above strategy works, because if `sortText` isn't set [they default it to the label](https://github.com/microsoft/vscode/commit/b4ead4ed665e1ce2e58d8329c682f78da2d4e89d). However, coc [does not do this](https://github.com/neoclide/coc.nvim/blob/e211e361475a38b146a903b9b02343551c6cd372/src/completion/complete.ts#L245).\r\n\r\nI was going to file a bug report against coc, but I read the [LSP spec for the `sortText` field](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion) and I feel like it is ambiguous and coc could claim what they do is a valid interpretation of the spec.\r\n\r\nFurther, the existing rust-analyzer behavior of prepending a leading whitespace character for completion items with any completion score does not handle sorting `TypeAndNameMatch` completions above `TypeMatch` completions. They were both being treated the same.\r\n\r\nThe first change this PR makes is to set the `sortText` field to either \"1\" for `TypeAndNameMatch` completions, \"2\" for `TypeMatch` completions, or \"3\" for completions which are neither of those. This change works around the potential ambiguity in the LSP spec and fixes completion sorting for users of coc. It also allows `TypeAndNameMatch` items to be sorted above just `TypeMatch` items (of course both of these will be sorted above completion items without a score). \r\n\r\nThe second change this PR makes is to use the actual completion scores for ref matches. The existing code ignored the actual score and always assumed these would be a high priority completion item.\r\n\r\n#### Before\r\n\r\nHere coc just sorts based on how close the items are in the file.\r\n\r\n![image](https://user-images.githubusercontent.com/22216761/110249880-46063580-7f2d-11eb-9233-91a2bbd48238.png)\r\n\r\n#### After\r\n\r\nHere we correctly get `zzz` first, since that is both a type and name match. Then we get `ccc` which is just a type match.\r\n\r\n![image](https://user-images.githubusercontent.com/22216761/110249883-4e5e7080-7f2d-11eb-9269-a3bc133fdee7.png)\r\n\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "html_url": "https://github.com/rust-lang/rust/commit/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "393e2356594560dec84e73471f26a366a6fc91dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/393e2356594560dec84e73471f26a366a6fc91dd", "html_url": "https://github.com/rust-lang/rust/commit/393e2356594560dec84e73471f26a366a6fc91dd"}, {"sha": "acbe297fbd10250e0d99d1e3e98751dd6ef77adc", "url": "https://api.github.com/repos/rust-lang/rust/commits/acbe297fbd10250e0d99d1e3e98751dd6ef77adc", "html_url": "https://github.com/rust-lang/rust/commit/acbe297fbd10250e0d99d1e3e98751dd6ef77adc"}], "stats": {"total": 186, "additions": 140, "deletions": 46}, "files": [{"sha": "0a493d2f30afab27ee911ce773d71205a4d8a5cf", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "patch": "@@ -87,7 +87,7 @@ pub use crate::{\n pub use hir::{Documentation, Semantics};\n pub use ide_assists::{Assist, AssistConfig, AssistId, AssistKind};\n pub use ide_completion::{\n-    CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, ImportEdit,\n+    CompletionConfig, CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit,\n     InsertTextFormat,\n };\n pub use ide_db::{"}, {"sha": "3febab32b589093a662d59cefb026cb9a8ea5ef5", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 104, "deletions": 19, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "patch": "@@ -70,7 +70,7 @@ pub struct CompletionItem {\n     /// Note that Relevance ignores fuzzy match score. We compute Relevance for\n     /// all possible items, and then separately build an ordered completion list\n     /// based on relevance and fuzzy matching with the already typed identifier.\n-    relevance: Relevance,\n+    relevance: CompletionRelevance,\n \n     /// Indicates that a reference or mutable reference to this variable is a\n     /// possible match.\n@@ -107,9 +107,11 @@ impl fmt::Debug for CompletionItem {\n         if self.deprecated {\n             s.field(\"deprecated\", &true);\n         }\n-        if self.relevance.is_relevant() {\n+\n+        if self.relevance != CompletionRelevance::default() {\n             s.field(\"relevance\", &self.relevance);\n         }\n+\n         if let Some(mutability) = &self.ref_match {\n             s.field(\"ref_match\", &format!(\"&{}\", mutability.as_keyword_for_ref()));\n         }\n@@ -120,16 +122,8 @@ impl fmt::Debug for CompletionItem {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, Ord, PartialOrd, Eq, PartialEq)]\n-pub enum CompletionScore {\n-    /// If only type match\n-    TypeMatch,\n-    /// If type and name match\n-    TypeAndNameMatch,\n-}\n-\n #[derive(Debug, Clone, Copy, Ord, PartialOrd, Eq, PartialEq, Default)]\n-pub struct Relevance {\n+pub struct CompletionRelevance {\n     /// This is set in cases like these:\n     ///\n     /// ```\n@@ -152,9 +146,34 @@ pub struct Relevance {\n     pub exact_type_match: bool,\n }\n \n-impl Relevance {\n+impl CompletionRelevance {\n+    /// Provides a relevance score. Higher values are more relevant.\n+    ///\n+    /// The absolute value of the relevance score is not meaningful, for\n+    /// example a value of 0 doesn't mean \"not relevant\", rather\n+    /// it means \"least relevant\". The score value should only be used\n+    /// for relative ordering.\n+    ///\n+    /// See is_relevant if you need to make some judgement about score\n+    /// in an absolute sense.\n+    pub fn score(&self) -> u32 {\n+        let mut score = 0;\n+\n+        if self.exact_name_match {\n+            score += 1;\n+        }\n+        if self.exact_type_match {\n+            score += 1;\n+        }\n+\n+        score\n+    }\n+\n+    /// Returns true when the score for this threshold is above\n+    /// some threshold such that we think it is especially likely\n+    /// to be relevant.\n     pub fn is_relevant(&self) -> bool {\n-        self != &Relevance::default()\n+        self.score() > 0\n     }\n }\n \n@@ -249,7 +268,7 @@ impl CompletionItem {\n             text_edit: None,\n             deprecated: false,\n             trigger_call_info: None,\n-            relevance: Relevance::default(),\n+            relevance: CompletionRelevance::default(),\n             ref_match: None,\n             import_to_add: None,\n         }\n@@ -292,16 +311,22 @@ impl CompletionItem {\n         self.deprecated\n     }\n \n-    pub fn relevance(&self) -> Relevance {\n+    pub fn relevance(&self) -> CompletionRelevance {\n         self.relevance\n     }\n \n     pub fn trigger_call_info(&self) -> bool {\n         self.trigger_call_info\n     }\n \n-    pub fn ref_match(&self) -> Option<Mutability> {\n-        self.ref_match\n+    pub fn ref_match(&self) -> Option<(Mutability, CompletionRelevance)> {\n+        // Relevance of the ref match should be the same as the original\n+        // match, but with exact type match set because self.ref_match\n+        // is only set if there is an exact type match.\n+        let mut relevance = self.relevance;\n+        relevance.exact_type_match = true;\n+\n+        self.ref_match.map(|mutability| (mutability, relevance))\n     }\n \n     pub fn import_to_add(&self) -> Option<&ImportEdit> {\n@@ -349,7 +374,7 @@ pub(crate) struct Builder {\n     text_edit: Option<TextEdit>,\n     deprecated: bool,\n     trigger_call_info: Option<bool>,\n-    relevance: Relevance,\n+    relevance: CompletionRelevance,\n     ref_match: Option<Mutability>,\n }\n \n@@ -457,7 +482,7 @@ impl Builder {\n         self.deprecated = deprecated;\n         self\n     }\n-    pub(crate) fn set_relevance(&mut self, relevance: Relevance) -> &mut Builder {\n+    pub(crate) fn set_relevance(&mut self, relevance: CompletionRelevance) -> &mut Builder {\n         self.relevance = relevance;\n         self\n     }\n@@ -474,3 +499,63 @@ impl Builder {\n         self\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use itertools::Itertools;\n+    use test_utils::assert_eq_text;\n+\n+    use super::CompletionRelevance;\n+\n+    /// Check that these are CompletionRelevance are sorted in ascending order\n+    /// by their relevance score.\n+    ///\n+    /// We want to avoid making assertions about the absolute score of any\n+    /// item, but we do want to assert whether each is >, <, or == to the\n+    /// others.\n+    ///\n+    /// If provided vec![vec![a], vec![b, c], vec![d]], then this will assert:\n+    ///     a.score < b.score == c.score < d.score\n+    fn check_relevance_score_ordered(expected_relevance_order: Vec<Vec<CompletionRelevance>>) {\n+        let expected = format!(\"{:#?}\", &expected_relevance_order);\n+\n+        let actual_relevance_order = expected_relevance_order\n+            .into_iter()\n+            .flatten()\n+            .map(|r| (r.score(), r))\n+            .sorted_by_key(|(score, _r)| *score)\n+            .fold(\n+                (u32::MIN, vec![vec![]]),\n+                |(mut currently_collecting_score, mut out), (score, r)| {\n+                    if currently_collecting_score == score {\n+                        out.last_mut().unwrap().push(r);\n+                    } else {\n+                        currently_collecting_score = score;\n+                        out.push(vec![r]);\n+                    }\n+                    (currently_collecting_score, out)\n+                },\n+            )\n+            .1;\n+\n+        let actual = format!(\"{:#?}\", &actual_relevance_order);\n+\n+        assert_eq_text!(&expected, &actual);\n+    }\n+\n+    #[test]\n+    fn relevance_score() {\n+        // This test asserts that the relevance score for these items is ascending, and\n+        // that any items in the same vec have the same score.\n+        let expected_relevance_order = vec![\n+            vec![CompletionRelevance::default()],\n+            vec![\n+                CompletionRelevance { exact_name_match: true, ..CompletionRelevance::default() },\n+                CompletionRelevance { exact_type_match: true, ..CompletionRelevance::default() },\n+            ],\n+            vec![CompletionRelevance { exact_name_match: true, exact_type_match: true }],\n+        ];\n+\n+        check_relevance_score_ordered(expected_relevance_order);\n+    }\n+}"}, {"sha": "263554ecf72805a95d19176d33e6656e35a4b200", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "patch": "@@ -23,10 +23,7 @@ use crate::{completions::Completions, context::CompletionContext, item::Completi\n \n pub use crate::{\n     config::CompletionConfig,\n-    item::{\n-        CompletionItem, CompletionItemKind, CompletionScore, ImportEdit, InsertTextFormat,\n-        Relevance,\n-    },\n+    item::{CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit, InsertTextFormat},\n };\n \n //FIXME: split the following feature into fine-grained features."}, {"sha": "db31896e53228fe3d6b8b61870de36580f20e54c", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "patch": "@@ -20,7 +20,7 @@ use ide_db::{\n use syntax::TextRange;\n \n use crate::{\n-    item::{ImportEdit, Relevance},\n+    item::{CompletionRelevance, ImportEdit},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n };\n \n@@ -322,9 +322,9 @@ impl<'a> Render<'a> {\n     }\n }\n \n-fn compute_relevance(ctx: &RenderContext, ty: &Type, name: &str) -> Option<Relevance> {\n+fn compute_relevance(ctx: &RenderContext, ty: &Type, name: &str) -> Option<CompletionRelevance> {\n     let (expected_name, expected_type) = ctx.expected_name_and_type()?;\n-    let mut res = Relevance::default();\n+    let mut res = CompletionRelevance::default();\n     res.exact_type_match = ty == &expected_type;\n     res.exact_name_match = name == &expected_name;\n     Some(res)\n@@ -338,7 +338,7 @@ mod tests {\n \n     use crate::{\n         test_utils::{check_edit, do_completion, get_all_items, TEST_CONFIG},\n-        CompletionKind, Relevance,\n+        CompletionKind, CompletionRelevance,\n     };\n \n     fn check(ra_fixture: &str, expect: Expect) {\n@@ -347,12 +347,14 @@ mod tests {\n     }\n \n     fn check_relevance(ra_fixture: &str, expect: Expect) {\n-        fn display_relevance(relevance: Relevance) -> &'static str {\n+        fn display_relevance(relevance: CompletionRelevance) -> &'static str {\n             match relevance {\n-                Relevance { exact_type_match: true, exact_name_match: true } => \"[type+name]\",\n-                Relevance { exact_type_match: true, exact_name_match: false } => \"[type]\",\n-                Relevance { exact_type_match: false, exact_name_match: true } => \"[name]\",\n-                Relevance { exact_type_match: false, exact_name_match: false } => \"[]\",\n+                CompletionRelevance { exact_type_match: true, exact_name_match: true } => {\n+                    \"[type+name]\"\n+                }\n+                CompletionRelevance { exact_type_match: true, exact_name_match: false } => \"[type]\",\n+                CompletionRelevance { exact_type_match: false, exact_name_match: true } => \"[name]\",\n+                CompletionRelevance { exact_type_match: false, exact_name_match: false } => \"[]\",\n             }\n         }\n \n@@ -975,7 +977,7 @@ fn main() {\n                             Local,\n                         ),\n                         detail: \"S\",\n-                        relevance: Relevance {\n+                        relevance: CompletionRelevance {\n                             exact_name_match: true,\n                             exact_type_match: false,\n                         },"}, {"sha": "1a8cdadad0084d6c91ca2c9401a888dd4b300a72", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dd1fd4d41538de7ea386a2d0d18e27bf95f63c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=19dd1fd4d41538de7ea386a2d0d18e27bf95f63c", "patch": "@@ -6,9 +6,10 @@ use std::{\n \n use ide::{\n     Annotation, AnnotationKind, Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind,\n-    Documentation, FileId, FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HlMod, HlPunct,\n-    HlRange, HlTag, Indel, InlayHint, InlayKind, InsertTextFormat, Markup, NavigationTarget,\n-    ReferenceAccess, RenameError, Runnable, Severity, SourceChange, TextEdit, TextRange, TextSize,\n+    CompletionRelevance, Documentation, FileId, FileRange, FileSystemEdit, Fold, FoldKind,\n+    Highlight, HlMod, HlPunct, HlRange, HlTag, Indel, InlayHint, InlayKind, InsertTextFormat,\n+    Markup, NavigationTarget, ReferenceAccess, RenameError, Runnable, Severity, SourceChange,\n+    TextEdit, TextRange, TextSize,\n };\n use ide_db::SymbolKind;\n use itertools::Itertools;\n@@ -213,12 +214,22 @@ pub(crate) fn completion_item(\n         ..Default::default()\n     };\n \n-    if item.relevance().is_relevant() {\n-        lsp_item.preselect = Some(true);\n-        // HACK: sort preselect items first\n-        lsp_item.sort_text = Some(format!(\" {}\", item.label()));\n+    fn set_score(res: &mut lsp_types::CompletionItem, relevance: CompletionRelevance) {\n+        if relevance.is_relevant() {\n+            res.preselect = Some(true);\n+        }\n+        // The relevance needs to be inverted to come up with a sort score\n+        // because the client will sort ascending.\n+        let sort_score = relevance.score() ^ 0xFF_FF_FF_FF;\n+        // Zero pad the string to ensure values can be properly sorted\n+        // by the client. Hex format is used because it is easier to\n+        // visually compare very large values, which the sort text\n+        // tends to be since it is the opposite of the score.\n+        res.sort_text = Some(format!(\"{:08x}\", sort_score));\n     }\n \n+    set_score(&mut lsp_item, item.relevance());\n+\n     if item.deprecated() {\n         lsp_item.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n     }\n@@ -228,10 +239,9 @@ pub(crate) fn completion_item(\n     }\n \n     let mut res = match item.ref_match() {\n-        Some(mutability) => {\n+        Some((mutability, relevance)) => {\n             let mut lsp_item_with_ref = lsp_item.clone();\n-            lsp_item.preselect = Some(true);\n-            lsp_item.sort_text = Some(format!(\" {}\", item.label()));\n+            set_score(&mut lsp_item_with_ref, relevance);\n             lsp_item_with_ref.label =\n                 format!(\"&{}{}\", mutability.as_keyword_for_ref(), lsp_item_with_ref.label);\n             if let Some(lsp_types::CompletionTextEdit::Edit(it)) = &mut lsp_item_with_ref.text_edit\n@@ -1107,13 +1117,13 @@ mod tests {\n                 (\n                     \"&arg\",\n                     Some(\n-                        \" arg\",\n+                        \"fffffffd\",\n                     ),\n                 ),\n                 (\n                     \"arg\",\n                     Some(\n-                        \" arg\",\n+                        \"fffffffe\",\n                     ),\n                 ),\n             ]"}]}