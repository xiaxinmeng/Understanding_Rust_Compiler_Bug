{"sha": "eba10270c6b7927672da6e73f58ec80afff4a2d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYTEwMjcwYzZiNzkyNzY3MmRhNmU3M2Y1OGVjODBhZmZmNGEyZDY=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-10-16T18:04:11Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-10-16T18:29:21Z"}, "message": "map_bound_ref -> rebind", "tree": {"sha": "22b77f17a36e782e103460d300e8cfc8d3c9ffe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22b77f17a36e782e103460d300e8cfc8d3c9ffe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eba10270c6b7927672da6e73f58ec80afff4a2d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eba10270c6b7927672da6e73f58ec80afff4a2d6", "html_url": "https://github.com/rust-lang/rust/commit/eba10270c6b7927672da6e73f58ec80afff4a2d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eba10270c6b7927672da6e73f58ec80afff4a2d6/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11d62aa2849b48b850c412cc7ce20d8a60a74ab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/11d62aa2849b48b850c412cc7ce20d8a60a74ab8", "html_url": "https://github.com/rust-lang/rust/commit/11d62aa2849b48b850c412cc7ce20d8a60a74ab8"}], "stats": {"total": 155, "additions": 77, "deletions": 78}, "files": [{"sha": "6a1715ef8189992e1b6742cda5c1bd72b34fbee4", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -551,8 +551,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n-        Ok(a.map_bound(|_| result))\n+        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn relate_item_substs(\n@@ -834,8 +833,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n-        Ok(a.map_bound(|_| result))\n+        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn tys(&mut self, t: Ty<'tcx>, _t: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {"}, {"sha": "abdd6edea90249454287e11193774404a3967fc3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -1004,6 +1004,6 @@ where\n         self.first_free_index.shift_in(1);\n         let result = self.relate(a.skip_binder(), a.skip_binder())?;\n         self.first_free_index.shift_out(1);\n-        Ok(a.map_bound(|_| result))\n+        Ok(ty::Binder::bind(result))\n     }\n }"}, {"sha": "2116c23652639272660eb66cab7e9c1fe346a587", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -134,7 +134,7 @@ impl Elaborator<'tcx> {\n \n                 let obligations = predicates.predicates.iter().map(|&(pred, _)| {\n                     predicate_obligation(\n-                        pred.subst_supertrait(tcx, &bound_predicate.map_bound(|_| data.trait_ref)),\n+                        pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n                         obligation.param_env,\n                         obligation.cause.clone(),\n                     )"}, {"sha": "27bccc0bcafa4a1bbd8efc65d50e176b60613f06", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -118,7 +118,6 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n-        Ok(a.map_bound(|_| result))\n+        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n }"}, {"sha": "acdf1f642ab9b21780beb1f585882cc35b4f1a5f", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -620,7 +620,7 @@ pub trait PrettyPrinter<'tcx>:\n                         // FIXME(lcnr): Find out why exactly this is the case :)\n                         let bound_predicate = predicate.bound_atom_with_opt_escaping(self.tcx());\n                         if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n-                            let trait_ref = bound_predicate.map_bound(|_| pred.trait_ref);\n+                            let trait_ref = bound_predicate.rebind(pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n                                 is_sized = true;"}, {"sha": "15803dbd8429f4ba063b784320b27b90082d354b", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -549,7 +549,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.as_ref().skip_binder()).map(|v| self.map_bound_ref(|_| v))\n+        tcx.lift(self.as_ref().skip_binder()).map(|v| self.rebind(v))\n     }\n }\n "}, {"sha": "fd2c7dd5b5ab56daace589634eec88caf2ecc176", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -702,16 +702,14 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match self.skip_binder() {\n-            ExistentialPredicate::Trait(tr) => self\n-                .map_bound_ref(|_| tr)\n-                .with_self_ty(tcx, self_ty)\n-                .without_const()\n-                .to_predicate(tcx),\n+            ExistentialPredicate::Trait(tr) => {\n+                self.rebind(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n+            }\n             ExistentialPredicate::Projection(p) => {\n-                self.map_bound_ref(|_| p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n+                self.rebind(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n-                let trait_ref = self.map_bound_ref(|_| ty::TraitRef {\n+                let trait_ref = self.rebind(ty::TraitRef {\n                     def_id: did,\n                     substs: tcx.mk_substs_trait(self_ty, &[]),\n                 });\n@@ -779,7 +777,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n \n impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n-        self.map_bound_ref(|b| b.principal()).transpose()\n+        self.map_bound(|b| b.principal()).transpose()\n     }\n \n     pub fn principal_def_id(&self) -> Option<DefId> {\n@@ -1004,6 +1002,14 @@ impl<T> Binder<T> {\n         Binder(f(self.0))\n     }\n \n+    /// Wraps a `value` in a binder, using the same bound variables as the\n+    /// current `Binder`. This should not be used if the new value *changes*\n+    /// the bound variables. Note: the (old or new) value itself does not\n+    /// necessarily need to *name* all the bound variables.\n+    pub fn rebind<U>(&self, value: U) -> Binder<U> {\n+        Binder(value)\n+    }\n+\n     /// Unwraps and returns the value within, but only if it contains\n     /// no bound vars at all. (In other words, if this binder --\n     /// and indeed any enclosing binder -- doesn't bind anything at"}, {"sha": "867ecea04e4247cae537d27bd032259e6c36a8aa", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -651,10 +651,10 @@ impl AutoTraitFinder<'tcx> {\n                     {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n-                    predicates.push_back(bound_predicate.map_bound_ref(|_| p));\n+                    predicates.push_back(bound_predicate.rebind(p));\n                 }\n                 ty::PredicateAtom::Projection(p) => {\n-                    let p = bound_predicate.map_bound_ref(|_| p);\n+                    let p = bound_predicate.rebind(p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -784,13 +784,13 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                 }\n                 ty::PredicateAtom::RegionOutlives(binder) => {\n-                    let binder = bound_predicate.map_bound_ref(|_| binder);\n+                    let binder = bound_predicate.rebind(binder);\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n                 ty::PredicateAtom::TypeOutlives(binder) => {\n-                    let binder = bound_predicate.map_bound_ref(|_| binder);\n+                    let binder = bound_predicate.rebind(binder);\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "2b95da4c5b965741de65b9d4bf178103ad545770", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let bound_predicate = obligation.predicate.bound_atom(self.tcx);\n                 match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                        let trait_predicate = bound_predicate.map_bound_ref(|_| trait_predicate);\n+                        let trait_predicate = bound_predicate.rebind(trait_predicate);\n                         let trait_predicate = self.resolve_vars_if_possible(&trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n@@ -532,7 +532,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::PredicateAtom::RegionOutlives(predicate) => {\n-                        let predicate = bound_predicate.map_bound_ref(|_| predicate);\n+                        let predicate = bound_predicate.rebind(predicate);\n                         let predicate = self.resolve_vars_if_possible(&predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, predicate)\n@@ -1082,7 +1082,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let bound_error = error.bound_atom(self.tcx);\n         let (cond, error) = match (cond.skip_binders(), bound_error.skip_binder()) {\n             (ty::PredicateAtom::Trait(..), ty::PredicateAtom::Trait(error, _)) => {\n-                (cond, bound_error.map_bound_ref(|_| error))\n+                (cond, bound_error.rebind(error))\n             }\n             _ => {\n                 // FIXME: make this work in other cases too.\n@@ -1094,7 +1094,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let bound_predicate = obligation.predicate.bound_atom(self.tcx);\n             if let ty::PredicateAtom::Trait(implication, _) = bound_predicate.skip_binder() {\n                 let error = error.to_poly_trait_ref();\n-                let implication = bound_predicate.map_bound_ref(|_| implication.trait_ref);\n+                let implication = bound_predicate.rebind(implication.trait_ref);\n                 // FIXME: I'm just not taking associated types at all here.\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n@@ -1178,7 +1178,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    &bound_predicate.map_bound_ref(|_| data),\n+                    &bound_predicate.rebind(data),\n                 );\n                 let mut obligations = vec![];\n                 let normalized_ty = super::normalize_projection_type(\n@@ -1463,7 +1463,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut err = match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(data, _) => {\n                 let self_ty = data.trait_ref.self_ty();\n-                let trait_ref = bound_predicate.map_bound_ref(|_| data.trait_ref);\n+                let trait_ref = bound_predicate.rebind(data.trait_ref);\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind(), trait_ref);\n \n                 if predicate.references_error() {\n@@ -1587,7 +1587,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282)\n             }\n             ty::PredicateAtom::Projection(data) => {\n-                let trait_ref = bound_predicate.map_bound_ref(|_| data).to_poly_trait_ref(self.tcx);\n+                let trait_ref = bound_predicate.rebind(data).to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 let ty = data.ty;\n                 if predicate.references_error() {"}, {"sha": "495a250be7c1fba0d6aa8cc6c451a1e47a9b02d0", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n                 ty::PredicateAtom::Trait(trait_ref, _constness) => {\n-                    let trait_obligation = obligation.with(binder.map_bound_ref(|_| trait_ref));\n+                    let trait_obligation = obligation.with(binder.rebind(trait_ref));\n \n                     self.process_trait_obligation(\n                         obligation,\n@@ -362,7 +362,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     )\n                 }\n                 ty::PredicateAtom::Projection(data) => {\n-                    let project_obligation = obligation.with(binder.map_bound_ref(|_| data));\n+                    let project_obligation = obligation.with(binder.rebind(data));\n \n                     self.process_projection_obligation(\n                         project_obligation,"}, {"sha": "63e1fe4a38a9a458cd377df90522167bbd86570d", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -634,9 +634,9 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n                 // indirect obligations (e.g., we project to `?0`,\n                 // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n                 // ?0>`).\n-                ty::PredicateAtom::Projection(data) => infcx\n-                    .unresolved_type_vars(&bound_predicate.map_bound_ref(|_| data.ty))\n-                    .is_some(),\n+                ty::PredicateAtom::Projection(data) => {\n+                    infcx.unresolved_type_vars(&bound_predicate.rebind(data.ty)).is_some()\n+                }\n \n                 // We are only interested in `T: Foo<X = U>` predicates, whre\n                 // `U` references one of `unresolved_type_vars`. =)\n@@ -910,7 +910,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n         debug!(?predicate);\n         let bound_predicate = predicate.bound_atom(infcx.tcx);\n         if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n-            let data = bound_predicate.map_bound_ref(|_| data);\n+            let data = bound_predicate.rebind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id"}, {"sha": "d0f1af253eb3d2e6fa06a729f5b4eec4671cf77c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -449,17 +449,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let result = ensure_sufficient_stack(|| {\n-            let bound_predicate = obligation.predicate.bound_atom(self.infcx().tcx);\n+            let bound_predicate =\n+                obligation.predicate.bound_atom_with_opt_escaping(self.infcx().tcx);\n             match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(t, _) => {\n-                    let t = bound_predicate.map_bound_ref(|_| t);\n+                    let t = bound_predicate.rebind(t);\n                     debug_assert!(!t.has_escaping_bound_vars());\n                     let obligation = obligation.with(t);\n                     self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n                 }\n \n                 ty::PredicateAtom::Subtype(p) => {\n-                    let p = bound_predicate.map_bound_ref(|_| p);\n+                    let p = bound_predicate.rebind(p);\n                     // Does this code ever run?\n                     match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                         Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -503,7 +504,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateAtom::Projection(data) => {\n-                    let data = bound_predicate.map_bound_ref(|_| data);\n+                    let data = bound_predicate.rebind(data);\n                     let project_obligation = obligation.with(data);\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n@@ -1177,7 +1178,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .filter_map(|(idx, bound)| {\n                 let bound_predicate = bound.bound_atom(self.infcx.tcx);\n                 if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n-                    let bound = bound_predicate.map_bound_ref(|_| pred.trait_ref);\n+                    let bound = bound_predicate.rebind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n                         match self.match_projection(\n                             obligation,\n@@ -1534,15 +1535,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Tuple(tys) => Where(\n                 obligation\n                     .predicate\n-                    .map_bound_ref(|_| tys.last().into_iter().map(|k| k.expect_ty()).collect()),\n+                    .rebind(tys.last().into_iter().map(|k| k.expect_ty()).collect()),\n             ),\n \n             ty::Adt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n-                Where(obligation.predicate.map_bound_ref(|_| {\n-                    sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n-                }))\n+                Where(\n+                    obligation.predicate.rebind({\n+                        sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n+                    }),\n+                )\n             }\n \n             ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => None,\n@@ -1594,16 +1597,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Array(element_ty, _) => {\n                 // (*) binder moved here\n-                Where(obligation.predicate.map_bound_ref(|_| vec![*element_ty]))\n+                Where(obligation.predicate.rebind(vec![*element_ty]))\n             }\n \n             ty::Tuple(tys) => {\n                 // (*) binder moved here\n-                Where(\n-                    obligation\n-                        .predicate\n-                        .map_bound_ref(|_| tys.iter().map(|k| k.expect_ty()).collect()),\n-                )\n+                Where(obligation.predicate.rebind(tys.iter().map(|k| k.expect_ty()).collect()))\n             }\n \n             ty::Closure(_, substs) => {\n@@ -1613,11 +1612,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // Not yet resolved.\n                     Ambiguous\n                 } else {\n-                    Where(\n-                        obligation\n-                            .predicate\n-                            .map_bound_ref(|_| substs.as_closure().upvar_tys().collect()),\n-                    )\n+                    Where(obligation.predicate.rebind(substs.as_closure().upvar_tys().collect()))\n                 }\n             }\n "}, {"sha": "7674259b8fe4d8f6ca9a0d77610db35959760252", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -1098,7 +1098,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let bound_predicate = obligation.predicate.bound_atom(tcx);\n                 match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(pred, _) => {\n-                        let pred = bound_predicate.map_bound_ref(|_| pred);\n+                        let pred = bound_predicate.rebind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n@@ -1107,7 +1107,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         );\n                     }\n                     ty::PredicateAtom::Projection(pred) => {\n-                        let pred = bound_predicate.map_bound_ref(|_| pred);\n+                        let pred = bound_predicate.rebind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self ="}, {"sha": "5b42a9c4c0bc59a574d2910a5989df26249b04fe", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // the complete signature.\n                     self.deduce_sig_from_projection(\n                         Some(obligation.cause.span),\n-                        bound_predicate.map_bound_ref(|_| proj_predicate),\n+                        bound_predicate.rebind(proj_predicate),\n                     )\n                 } else {\n                     None"}, {"sha": "53ad100206297e9da55b3338a3de877d3e9b0ff5", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -595,7 +595,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    bound_predicate.map_bound_ref(|_| trait_pred)\n+                    bound_predicate.rebind(trait_pred)\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);"}, {"sha": "9fcb3a8cdfdaa02a85817ba123d10a3d4103af40", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -229,12 +229,12 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n             let bound_predicate = predicate.bound_atom(tcx);\n             let bound_p = p.bound_atom(tcx);\n             match (predicate.skip_binders(), p.skip_binders()) {\n-                (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => relator\n-                    .relate(bound_predicate.map_bound_ref(|_| a), bound_p.map_bound_ref(|_| b))\n-                    .is_ok(),\n-                (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => relator\n-                    .relate(bound_predicate.map_bound_ref(|_| a), bound_p.map_bound_ref(|_| b))\n-                    .is_ok(),\n+                (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => {\n+                    relator.relate(bound_predicate.rebind(a), bound_p.rebind(b)).is_ok()\n+                }\n+                (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => {\n+                    relator.relate(bound_predicate.rebind(a), bound_p.rebind(b)).is_ok()\n+                }\n                 _ => predicate == p,\n             }\n         };"}, {"sha": "a70705bd85a0c625361942b1b1d5f50f79a10009", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -803,7 +803,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 ty::PredicateAtom::Trait(trait_predicate, _) => {\n                     match trait_predicate.trait_ref.self_ty().kind() {\n                         ty::Param(ref p) if *p == param_ty => {\n-                            Some(bound_predicate.map_bound_ref(|_| trait_predicate.trait_ref))\n+                            Some(bound_predicate.rebind(trait_predicate.trait_ref))\n                         }\n                         _ => None,\n                     }"}, {"sha": "bd0ac75c8ed9018174fb3ee8400d08b5293dc843", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -640,7 +640,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let bound_predicate = pred.bound_atom(tcx);\n                         match bound_predicate.skip_binder() {\n                             ty::PredicateAtom::Projection(pred) => {\n-                                let pred = bound_predicate.map_bound_ref(|_| pred);\n+                                let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n                                     pred.skip_binder().projection_ty.trait_ref(self.tcx);"}, {"sha": "94f961218ba46802796df3d25c667721045d80d3", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -862,7 +862,7 @@ fn bounds_from_generic_predicates<'tcx>(\n                 }\n             }\n             ty::PredicateAtom::Projection(projection_pred) => {\n-                projections.push(bound_predicate.map_bound_ref(|_| projection_pred));\n+                projections.push(bound_predicate.rebind(projection_pred));\n             }\n             _ => {}\n         }"}, {"sha": "20d6bda1f1154b45329776d53c6e720568c29404", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -317,14 +317,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     ) -> FxHashSet<GenericParamDef> {\n         let bound_predicate = pred.bound_atom(tcx);\n         let regions = match bound_predicate.skip_binder() {\n-            ty::PredicateAtom::Trait(poly_trait_pred, _) => tcx\n-                .collect_referenced_late_bound_regions(\n-                    &bound_predicate.map_bound_ref(|_| poly_trait_pred),\n-                ),\n-            ty::PredicateAtom::Projection(poly_proj_pred) => tcx\n-                .collect_referenced_late_bound_regions(\n-                    &bound_predicate.map_bound_ref(|_| poly_proj_pred),\n-                ),\n+            ty::PredicateAtom::Trait(poly_trait_pred, _) => {\n+                tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_trait_pred))\n+            }\n+            ty::PredicateAtom::Projection(poly_proj_pred) => {\n+                tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_proj_pred))\n+            }\n             _ => return FxHashSet::default(),\n         };\n "}, {"sha": "f74dd875ca3056d78e515fa015248761649d1366", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eba10270c6b7927672da6e73f58ec80afff4a2d6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba10270c6b7927672da6e73f58ec80afff4a2d6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=eba10270c6b7927672da6e73f58ec80afff4a2d6", "patch": "@@ -1689,7 +1689,10 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .filter_map(|bound| {\n                         // Note: The substs of opaque types can contain unbound variables,\n                         // meaning that we have to use `ignore_quantifiers_with_unbound_vars` here.\n-                        let trait_ref = match bound.bound_atom(cx.tcx).skip_binder() {\n+                        let trait_ref = match bound\n+                            .bound_atom_with_opt_escaping(cx.tcx)\n+                            .skip_binder()\n+                        {\n                             ty::PredicateAtom::Trait(tr, _constness) => {\n                                 ty::Binder::bind(tr.trait_ref)\n                             }\n@@ -1713,7 +1716,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             .iter()\n                             .filter_map(|bound| {\n                                 if let ty::PredicateAtom::Projection(proj) =\n-                                    bound.bound_atom(cx.tcx).skip_binder()\n+                                    bound.bound_atom_with_opt_escaping(cx.tcx).skip_binder()\n                                 {\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == trait_ref.skip_binder()"}]}