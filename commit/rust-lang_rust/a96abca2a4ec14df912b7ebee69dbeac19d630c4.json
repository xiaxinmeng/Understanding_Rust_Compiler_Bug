{"sha": "a96abca2a4ec14df912b7ebee69dbeac19d630c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NmFiY2EyYTRlYzE0ZGY5MTJiN2ViZWU2OWRiZWFjMTlkNjMwYzQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-16T14:25:54Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:05Z"}, "message": "rustc_metadata: replace RBML with a simple and type-safe scheme.", "tree": {"sha": "06c4cc96dc05d99f5f34ff44dfb142880a9f62f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06c4cc96dc05d99f5f34ff44dfb142880a9f62f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a96abca2a4ec14df912b7ebee69dbeac19d630c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a96abca2a4ec14df912b7ebee69dbeac19d630c4", "html_url": "https://github.com/rust-lang/rust/commit/a96abca2a4ec14df912b7ebee69dbeac19d630c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a96abca2a4ec14df912b7ebee69dbeac19d630c4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24aef24e1aa732115c1a98feb06510de372fcf0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/24aef24e1aa732115c1a98feb06510de372fcf0c", "html_url": "https://github.com/rust-lang/rust/commit/24aef24e1aa732115c1a98feb06510de372fcf0c"}], "stats": {"total": 4298, "additions": 1827, "deletions": 2471}, "files": [{"sha": "658825d417e4ca3cd4b3249977fa720c906eac4a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -138,11 +138,11 @@ pub trait CrateStore<'tcx> {\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx>;\n+                         -> ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n-    fn fn_arg_names(&self, did: DefId) -> Vec<String>;\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n@@ -299,13 +299,13 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx> { bug!(\"item_generics\") }\n+                         -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }\n-    fn fn_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"fn_arg_names\") }\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info"}, {"sha": "8a9b2846ac666487efd2a6469fa0a34bf06d2ba4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -737,6 +737,9 @@ pub struct GenericPredicates<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n+impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n+\n impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n@@ -2457,7 +2460,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn lookup_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"generics\", did, &self.generics,\n-            || self.sess.cstore.item_generics(self.global_tcx(), did))\n+            || self.alloc_generics(self.sess.cstore.item_generics(self.global_tcx(), did)))\n     }\n \n     /// Given the did of an item, returns its full set of predicates."}, {"sha": "680d55955bb96a928beb606c0986ea0a91155767", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -13,7 +13,6 @@ flate = { path = \"../libflate\" }\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "c9dbedacbc1a5a3a85cb40e72960aa4422d8ee93", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 95, "deletions": 126, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -13,43 +13,92 @@ use rustc::hir::map as ast_map;\n use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange};\n \n use cstore::CrateMetadata;\n-use decoder::DecodeContext;\n use encoder::EncodeContext;\n+use schema::*;\n \n use rustc::middle::cstore::{InlinedItem, InlinedItemRef};\n-use rustc::hir::def;\n+use rustc::middle::const_qualif::ConstQualif;\n+use rustc::hir::def::{self, Def};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt, Ty};\n \n use syntax::ast;\n \n-use rbml;\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::Encodable;\n \n-// ______________________________________________________________________\n-// Top-level methods.\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Ast<'tcx> {\n+    id_range: IdRange,\n+    item: Lazy<InlinedItem>,\n+    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+enum TableEntry<'tcx> {\n+    Def(Def),\n+    NodeType(Ty<'tcx>),\n+    ItemSubsts(ty::ItemSubsts<'tcx>),\n+    Adjustment(ty::adjustment::AutoAdjustment<'tcx>),\n+    ConstQualif(ConstQualif)\n+}\n \n-pub fn encode_inlined_item(ecx: &mut EncodeContext, ii: InlinedItemRef) {\n-    ecx.tag(::common::item_tag::ast, |ecx| {\n-        let mut visitor = IdRangeComputingVisitor::new();\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+    pub fn encode_inlined_item(&mut self, ii: InlinedItemRef) -> Lazy<Ast<'tcx>> {\n+        let mut id_visitor = IdRangeComputingVisitor::new();\n         match ii {\n-            InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n-            InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n-            InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n+            InlinedItemRef::Item(_, i) => id_visitor.visit_item(i),\n+            InlinedItemRef::TraitItem(_, ti) => id_visitor.visit_trait_item(ti),\n+            InlinedItemRef::ImplItem(_, ii) => id_visitor.visit_impl_item(ii)\n         }\n-        visitor.result().encode(ecx).unwrap();\n \n-        ii.encode(ecx).unwrap();\n+        let ii_pos = self.position();\n+        ii.encode(self).unwrap();\n+\n+        let tables_pos = self.position();\n+        let tables_count = {\n+            let mut visitor = SideTableEncodingIdVisitor {\n+                ecx: self,\n+                count: 0\n+            };\n+            match ii {\n+                InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n+                InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n+                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n+            }\n+            visitor.count\n+        };\n+\n+        self.lazy(&Ast {\n+            id_range: id_visitor.result(),\n+            item: Lazy::with_position(ii_pos),\n+            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count)\n+        })\n+    }\n+}\n+\n+struct SideTableEncodingIdVisitor<'a, 'b:'a, 'tcx:'b> {\n+    ecx: &'a mut EncodeContext<'b, 'tcx>,\n+    count: usize\n+}\n+\n+impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n+    fn visit_id(&mut self, id: ast::NodeId) {\n+        debug!(\"Encoding side tables for id {}\", id);\n \n-        let mut visitor = SideTableEncodingIdVisitor {\n-            ecx: ecx\n+        let tcx = self.ecx.tcx;\n+        let mut encode = |entry: Option<TableEntry>| {\n+            if let Some(entry) = entry {\n+                (id, entry).encode(self.ecx).unwrap();\n+                self.count += 1;\n+            }\n         };\n-        match ii {\n-            InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n-            InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n-            InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n-        }\n-    });\n+\n+        encode(tcx.expect_def_or_none(id).map(TableEntry::Def));\n+        encode(tcx.node_types().get(&id).cloned().map(TableEntry::NodeType));\n+        encode(tcx.tables.borrow().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n+        encode(tcx.tables.borrow().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n+        encode(tcx.const_qualif_map.borrow().get(&id).cloned().map(TableEntry::ConstQualif));\n+    }\n }\n \n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n@@ -58,17 +107,19 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      parent_def_path: ast_map::DefPath,\n                                      parent_did: DefId,\n-                                     ast_doc: rbml::Doc,\n+                                     ast: Ast<'tcx>,\n                                      orig_did: DefId)\n                                      -> &'tcx InlinedItem {\n     debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n-    let dcx = &mut DecodeContext::new(ast_doc, Some(cdata)).typed(tcx);\n-    dcx.from_id_range = IdRange::decode(dcx).unwrap();\n-    let cnt = dcx.from_id_range.max.as_usize() - dcx.from_id_range.min.as_usize();\n-    dcx.to_id_range.min = tcx.sess.reserve_node_ids(cnt);\n-    dcx.to_id_range.max = ast::NodeId::new(dcx.to_id_range.min.as_usize() + cnt);\n-    let ii = InlinedItem::decode(dcx).unwrap();\n \n+    let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n+    let start = tcx.sess.reserve_node_ids(cnt);\n+    let id_ranges = [ast.id_range, IdRange {\n+        min: start,\n+        max: ast::NodeId::new(start.as_usize() + cnt)\n+    }];\n+\n+    let ii = ast.item.decode((cdata, tcx, id_ranges));\n     let ii = ast_map::map_decoded_item(&tcx.map,\n                                        parent_def_path,\n                                        parent_did,\n@@ -83,107 +134,25 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n     tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));\n \n-    decode_side_tables(dcx, ast_doc);\n-\n-    ii\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding the side tables\n-\n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn tag<F>(&mut self,\n-              tag_id: usize,\n-              f: F) where\n-        F: FnOnce(&mut Self),\n-    {\n-        self.start_tag(tag_id).unwrap();\n-        f(self);\n-        self.end_tag().unwrap();\n-    }\n-\n-    fn entry(&mut self, table: Table, id: ast::NodeId) {\n-        table.encode(self).unwrap();\n-        id.encode(self).unwrap();\n-    }\n-}\n-\n-struct SideTableEncodingIdVisitor<'a, 'b:'a, 'tcx:'b> {\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-}\n-\n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n-    fn visit_id(&mut self, id: ast::NodeId) {\n-        encode_side_tables_for_id(self.ecx, id)\n-    }\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n-enum Table {\n-    Def,\n-    NodeType,\n-    ItemSubsts,\n-    Adjustment,\n-    ConstQualif\n-}\n-\n-fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n-    let tcx = ecx.tcx;\n-\n-    debug!(\"Encoding side tables for id {}\", id);\n-\n-    if let Some(def) = tcx.expect_def_or_none(id) {\n-        ecx.entry(Table::Def, id);\n-        def.encode(ecx).unwrap();\n-    }\n-\n-    if let Some(ty) = tcx.node_types().get(&id) {\n-        ecx.entry(Table::NodeType, id);\n-        ty.encode(ecx).unwrap();\n-    }\n-\n-    if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n-        ecx.entry(Table::ItemSubsts, id);\n-        item_substs.substs.encode(ecx).unwrap();\n-    }\n-\n-    if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n-        ecx.entry(Table::Adjustment, id);\n-        adjustment.encode(ecx).unwrap();\n-    }\n-\n-    if let Some(qualif) = tcx.const_qualif_map.borrow().get(&id) {\n-        ecx.entry(Table::ConstQualif, id);\n-        qualif.encode(ecx).unwrap();\n-    }\n-}\n-\n-fn decode_side_tables(dcx: &mut DecodeContext, ast_doc: rbml::Doc) {\n-    while dcx.opaque.position() < ast_doc.end {\n-        let table = Decodable::decode(dcx).unwrap();\n-        let id = Decodable::decode(dcx).unwrap();\n-        debug!(\"decode_side_tables: entry for id={}, table={:?}\", id, table);\n-        match table {\n-            Table::Def => {\n-                let def = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n+    for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n+        match entry {\n+            TableEntry::Def(def) => {\n+                tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n             }\n-            Table::NodeType => {\n-                let ty = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().node_type_insert(id, ty);\n+            TableEntry::NodeType(ty) => {\n+                tcx.node_type_insert(id, ty);\n             }\n-            Table::ItemSubsts => {\n-                let item_substs = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n+            TableEntry::ItemSubsts(item_substs) => {\n+                tcx.tables.borrow_mut().item_substs.insert(id, item_substs);\n             }\n-            Table::Adjustment => {\n-                let adj = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().tables.borrow_mut().adjustments.insert(id, adj);\n+            TableEntry::Adjustment(adj) => {\n+                tcx.tables.borrow_mut().adjustments.insert(id, adj);\n             }\n-            Table::ConstQualif => {\n-                let qualif = Decodable::decode(dcx).unwrap();\n-                dcx.tcx().const_qualif_map.borrow_mut().insert(id, qualif);\n+            TableEntry::ConstQualif(qualif) => {\n+                tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n             }\n         }\n     }\n+\n+    ii\n }"}, {"sha": "f30551cadd97adfca0afc5bcafd092e7613a204d", "filename": "src/librustc_metadata/common.rs", "status": "removed", "additions": 0, "deletions": 206, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/24aef24e1aa732115c1a98feb06510de372fcf0c/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aef24e1aa732115c1a98feb06510de372fcf0c/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=24aef24e1aa732115c1a98feb06510de372fcf0c", "patch": "@@ -1,206 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_camel_case_types, non_upper_case_globals)]\n-\n-use rustc::hir;\n-use rustc::hir::def;\n-use rustc::hir::def_id::{DefIndex, DefId};\n-use rustc::ty;\n-use rustc::session::config::PanicStrategy;\n-\n-#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n-pub enum Family {\n-    ImmStatic,\n-    MutStatic,\n-    ForeignImmStatic,\n-    ForeignMutStatic,\n-    Fn,\n-    ForeignFn,\n-    Method,\n-    AssociatedType,\n-    Type,\n-    Mod,\n-    ForeignMod,\n-    Enum,\n-    Variant,\n-    Impl,\n-    DefaultImpl,\n-    Trait,\n-    Struct,\n-    Union,\n-    Field,\n-    Const,\n-    AssociatedConst,\n-    Closure\n-}\n-\n-// NB: increment this if you change the format of metadata such that\n-// rustc_version can't be found.\n-pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2];\n-\n-// GAP 0x7c\n-// GAP 0x108\n-pub fn rustc_version() -> String {\n-    format!(\n-        \"rustc {}\",\n-        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n-    )\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateInfo {\n-    pub name: String,\n-    pub triple: String,\n-    pub hash: hir::svh::Svh,\n-    pub disambiguator: String,\n-    pub panic_strategy: PanicStrategy,\n-    pub plugin_registrar_fn: Option<DefIndex>,\n-    pub macro_derive_registrar: Option<DefIndex>\n-}\n-\n-pub mod root_tag {\n-    pub const rustc_version: usize = 0x10f;\n-\n-    pub const crate_info: usize = 0x104;\n-\n-    pub const index: usize = 0x110;\n-    pub const crate_deps: usize = 0x102;\n-    pub const dylib_dependency_formats: usize = 0x106;\n-    pub const native_libraries: usize = 0x10a;\n-    pub const lang_items: usize = 0x107;\n-    pub const lang_items_missing: usize = 0x76;\n-    pub const impls: usize = 0x109;\n-    pub const reachable_ids: usize = 0x10c;\n-    pub const macro_defs: usize = 0x10e;\n-    pub const codemap: usize = 0xa1;\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct ModData {\n-    pub reexports: Vec<def::Export>\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData {\n-    pub kind: ty::VariantKind,\n-    pub disr: u64,\n-\n-    /// If this is a struct's only variant, this\n-    /// is the index of the \"struct ctor\" item.\n-    pub struct_ctor: Option<DefIndex>\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitData {\n-    pub unsafety: hir::Unsafety,\n-    pub paren_sugar: bool,\n-    pub has_default_impl: bool\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct ImplData {\n-    pub polarity: hir::ImplPolarity,\n-    pub parent_impl: Option<DefId>,\n-    pub coerce_unsized_kind: Option<ty::adjustment::CustomCoerceUnsized>,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitAssociatedData {\n-    pub has_default: bool\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct ImplAssociatedData {\n-    pub defaultness: hir::Defaultness,\n-    pub constness: hir::Constness\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct FnData {\n-    pub constness: hir::Constness\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct ClosureData {\n-    pub kind: ty::ClosureKind\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub enum EntryData {\n-    Other,\n-    Mod(ModData),\n-    Variant(VariantData),\n-    Trait(TraitData),\n-    Impl(ImplData),\n-    TraitAssociated(TraitAssociatedData),\n-    ImplAssociated(ImplAssociatedData),\n-    Fn(FnData),\n-    Closure(ClosureData)\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitTypedData<'tcx> {\n-    pub trait_ref: ty::TraitRef<'tcx>\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct ImplTypedData<'tcx> {\n-    pub trait_ref: Option<ty::TraitRef<'tcx>>\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodTypedData<'tcx> {\n-    pub explicit_self: ty::ExplicitSelfCategory<'tcx>\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct ClosureTypedData<'tcx> {\n-    pub ty: ty::ClosureTy<'tcx>\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub enum EntryTypedData<'tcx> {\n-    Other,\n-    Trait(TraitTypedData<'tcx>),\n-    Impl(ImplTypedData<'tcx>),\n-    Method(MethodTypedData<'tcx>),\n-    Closure(ClosureTypedData<'tcx>)\n-}\n-\n-pub mod item_tag {\n-    pub const def_key: usize = 0x2c;\n-    pub const family: usize = 0x24;\n-    pub const attributes: usize = 0x101;\n-    pub const visibility: usize = 0x78;\n-    pub const children: usize = 0x7b;\n-    pub const stability: usize = 0x88;\n-    pub const deprecation: usize = 0xa7;\n-\n-    pub const ty: usize = 0x25;\n-    pub const inherent_impls: usize = 0x79;\n-    pub const variances: usize = 0x43;\n-    pub const generics: usize = 0x8f;\n-    pub const predicates: usize = 0x95;\n-    pub const super_predicates: usize = 0xa3;\n-\n-    pub const ast: usize = 0x50;\n-    pub const mir: usize = 0x52;\n-\n-    pub const data: usize = 0x3c;\n-    pub const typed_data: usize = 0x3d;\n-\n-    pub const fn_arg_names: usize = 0x85;\n-}\n-\n-/// The shorthand encoding uses an enum's variant index `usize`\n-/// and is offset by this value so it never matches a real variant.\n-/// This offset is also chosen so that the first byte is never < 0x80.\n-pub const SHORTHAND_OFFSET: usize = 0x80;"}, {"sha": "95be77c24f46eb952e4c6732fd99dda696f554e0", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 39, "deletions": 172, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use common::CrateInfo;\n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use loader::{self, CratePaths};\n+use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n@@ -34,12 +32,11 @@ use std::fs;\n \n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap;\n use syntax::parse;\n use syntax::attr;\n use syntax::parse::token::InternedString;\n use syntax::visit;\n-use syntax_pos::{self, Span, mk_sp, Pos};\n+use syntax_pos::{self, Span, mk_sp};\n use log;\n \n struct LocalCrateReader<'a> {\n@@ -148,7 +145,7 @@ impl Deref for PMDSource {\n \n     fn deref(&self) -> &MetadataBlob {\n         match *self {\n-            PMDSource::Registered(ref cmd) => &cmd.data,\n+            PMDSource::Registered(ref cmd) => &cmd.blob,\n             PMDSource::Owned(ref lib) => &lib.metadata\n         }\n     }\n@@ -261,28 +258,28 @@ impl<'a> CrateReader<'a> {\n \n     fn verify_no_symbol_conflicts(&self,\n                                   span: Span,\n-                                  info: &CrateInfo) {\n+                                  root: &CrateRoot) {\n         // Check for (potential) conflicts with the local crate\n-        if self.local_crate_name == info.name &&\n-           self.sess.local_crate_disambiguator() == &info.disambiguator[..] {\n+        if self.local_crate_name == root.name &&\n+           self.sess.local_crate_disambiguator() == &root.disambiguator[..] {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n                          compiled with the same `-C metadata` arguments. This \\\n                          will result in symbol conflicts between the two.\",\n-                        info.name)\n+                        root.name)\n         }\n \n         // Check for conflicts with any crate loaded so far\n         self.cstore.iter_crate_data(|_, other| {\n-            if other.name() == info.name && // same crate-name\n-               other.disambiguator() == info.disambiguator &&  // same crate-disambiguator\n-               other.hash() != info.hash { // but different SVH\n+            if other.name() == root.name && // same crate-name\n+               other.disambiguator() == root.disambiguator &&  // same crate-disambiguator\n+               other.hash() != root.hash { // but different SVH\n                 span_fatal!(self.sess, span, E0523,\n                         \"found two different crates with name `{}` that are \\\n                          not distinguished by differing `-C metadata`. This \\\n                          will result in symbol conflicts between the two.\",\n-                        info.name)\n+                        root.name)\n             }\n         });\n     }\n@@ -297,8 +294,8 @@ impl<'a> CrateReader<'a> {\n                       -> (CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n         info!(\"register crate `extern crate {} as {}`\", name, ident);\n-        let crate_info = lib.metadata.get_crate_info();\n-        self.verify_no_symbol_conflicts(span, &crate_info);\n+        let crate_root = lib.metadata.get_root();\n+        self.verify_no_symbol_conflicts(span, &crate_root);\n \n         // Claim this crate number and cache it\n         let cnum = self.next_crate_num;\n@@ -319,20 +316,19 @@ impl<'a> CrateReader<'a> {\n \n         let loader::Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, &metadata, cnum, span);\n+        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span);\n \n-        if crate_info.macro_derive_registrar.is_some() {\n+        if crate_root.macro_derive_registrar.is_some() {\n             self.sess.span_err(span, \"crates of the `rustc-macro` crate type \\\n                                       cannot be linked at runtime\");\n         }\n \n         let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n-            info: crate_info,\n-            index: metadata.load_index(),\n-            key_map: metadata.load_key_map(),\n-            data: metadata,\n+            key_map: metadata.load_key_map(crate_root.index),\n+            root: crate_root,\n+            blob: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n@@ -416,11 +412,11 @@ impl<'a> CrateReader<'a> {\n         // Note that we only do this for target triple crates, though, as we\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n-        let crate_info = library.metadata.get_crate_info();\n+        let root = library.metadata.get_root();\n         if loader.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n-                if data.name() == crate_info.name && crate_info.hash == data.hash() {\n+                if data.name() == root.name && root.hash == data.hash() {\n                     assert!(loader.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n@@ -467,23 +463,25 @@ impl<'a> CrateReader<'a> {\n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n+                          crate_root: &CrateRoot,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n                           span: Span)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n-        let map: FnvHashMap<_, _> = metadata.get_crate_deps().iter().map(|dep| {\n+        let deps = crate_root.crate_deps.decode(metadata);\n+        let map: FnvHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, ..) = self.resolve_crate(root,\n-                                                        &dep.name,\n-                                                        &dep.name,\n+                                                        &dep.name.as_str(),\n+                                                        &dep.name.as_str(),\n                                                         Some(&dep.hash),\n                                                         span,\n                                                         PathKind::Dependency,\n                                                         dep.explicitly_linked);\n-            (dep.cnum, local_cnum)\n+            (CrateNum::new(crate_num + 1), local_cnum)\n         }).collect();\n \n         let max_cnum = map.values().cloned().max().map(|cnum| cnum.as_u32()).unwrap_or(0);\n@@ -568,21 +566,21 @@ impl<'a> CrateReader<'a> {\n         let ci = self.extract_crate_info(item).unwrap();\n         let ekrate = self.read_extension_crate(item.span, &ci);\n \n-        let crate_info = ekrate.metadata.get_crate_info();\n+        let root = ekrate.metadata.get_root();\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut ret = Macros {\n             macro_rules: Vec::new(),\n             custom_derive_registrar: None,\n-            svh: crate_info.hash,\n+            svh: root.hash,\n             dylib: None,\n         };\n-        ekrate.metadata.each_exported_macro(|name, attrs, span, body| {\n+        for def in root.macro_defs.decode(&*ekrate.metadata) {\n             // NB: Don't use parse::parse_tts_from_source_str because it parses with\n             // quote_depth > 0.\n             let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n                                                           self.local_crate_config.clone(),\n                                                           source_name.clone(),\n-                                                          body);\n+                                                          def.body);\n             let lo = p.span.lo;\n             let body = match p.parse_all_token_trees() {\n                 Ok(body) => body,\n@@ -595,13 +593,13 @@ impl<'a> CrateReader<'a> {\n             let local_span = mk_sp(lo, p.last_span.hi);\n \n             // Mark the attrs as used\n-            for attr in &attrs {\n+            for attr in &def.attrs {\n                 attr::mark_used(attr);\n             }\n \n             ret.macro_rules.push(ast::MacroDef {\n-                ident: ast::Ident::with_empty_ctxt(name),\n-                attrs: attrs,\n+                ident: ast::Ident::with_empty_ctxt(def.name),\n+                attrs: def.attrs,\n                 id: ast::DUMMY_NODE_ID,\n                 span: local_span,\n                 imported_from: Some(item.ident),\n@@ -613,11 +611,10 @@ impl<'a> CrateReader<'a> {\n                 body: body,\n             });\n             self.sess.imported_macro_spans.borrow_mut()\n-                .insert(local_span, (name.as_str().to_string(), span));\n-            true\n-        });\n+                .insert(local_span, (def.name.as_str().to_string(), def.span));\n+        }\n \n-        match crate_info.macro_derive_registrar {\n+        match root.macro_derive_registrar {\n             Some(id) => ret.custom_derive_registrar = Some(id),\n \n             // If this crate is not a rustc-macro crate then we might be able to\n@@ -671,10 +668,10 @@ impl<'a> CrateReader<'a> {\n             span_fatal!(self.sess, span, E0456, \"{}\", &message[..]);\n         }\n \n-        let crate_info = ekrate.metadata.get_crate_info();\n-        match (ekrate.dylib.as_ref(), crate_info.plugin_registrar_fn) {\n+        let root = ekrate.metadata.get_root();\n+        match (ekrate.dylib.as_ref(), root.plugin_registrar_fn) {\n             (Some(dylib), Some(reg)) => {\n-                Some((dylib.to_path_buf(), crate_info.hash, reg))\n+                Some((dylib.to_path_buf(), root.hash, reg))\n             }\n             (None, Some(_)) => {\n                 span_err!(self.sess, span, E0457,\n@@ -1086,133 +1083,3 @@ pub fn read_local_crates(sess: & Session,\n                          dep_graph: &DepGraph) {\n     LocalCrateReader::new(sess, cstore, defs, krate, local_crate_name).read_crates(dep_graph)\n }\n-\n-/// Imports the codemap from an external crate into the codemap of the crate\n-/// currently being compiled (the \"local crate\").\n-///\n-/// The import algorithm works analogous to how AST items are inlined from an\n-/// external crate's metadata:\n-/// For every FileMap in the external codemap an 'inline' copy is created in the\n-/// local codemap. The correspondence relation between external and local\n-/// FileMaps is recorded in the `ImportedFileMap` objects returned from this\n-/// function. When an item from an external crate is later inlined into this\n-/// crate, this correspondence information is used to translate the span\n-/// information of the inlined item so that it refers the correct positions in\n-/// the local codemap (see `<decoder::DecodeContext as SpecializedDecoder<Span>>`).\n-///\n-/// The import algorithm in the function below will reuse FileMaps already\n-/// existing in the local codemap. For example, even if the FileMap of some\n-/// source file of libstd gets imported many times, there will only ever be\n-/// one FileMap object for the corresponding file in the local codemap.\n-///\n-/// Note that imported FileMaps do not actually contain the source code of the\n-/// file they represent, just information about length, line breaks, and\n-/// multibyte characters. This information is enough to generate valid debuginfo\n-/// for items inlined from other crates.\n-pub fn import_codemap(local_codemap: &codemap::CodeMap,\n-                      metadata: &MetadataBlob)\n-                      -> Vec<cstore::ImportedFileMap> {\n-    let external_codemap = metadata.get_imported_filemaps();\n-\n-    let imported_filemaps = external_codemap.into_iter().map(|filemap_to_import| {\n-        // Try to find an existing FileMap that can be reused for the filemap to\n-        // be imported. A FileMap is reusable if it is exactly the same, just\n-        // positioned at a different offset within the codemap.\n-        let reusable_filemap = {\n-            local_codemap.files\n-                         .borrow()\n-                         .iter()\n-                         .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n-                         .map(|rc| rc.clone())\n-        };\n-\n-        match reusable_filemap {\n-            Some(fm) => {\n-                cstore::ImportedFileMap {\n-                    original_start_pos: filemap_to_import.start_pos,\n-                    original_end_pos: filemap_to_import.end_pos,\n-                    translated_filemap: fm\n-                }\n-            }\n-            None => {\n-                // We can't reuse an existing FileMap, so allocate a new one\n-                // containing the information we need.\n-                let syntax_pos::FileMap {\n-                    name,\n-                    abs_path,\n-                    start_pos,\n-                    end_pos,\n-                    lines,\n-                    multibyte_chars,\n-                    ..\n-                } = filemap_to_import;\n-\n-                let source_length = (end_pos - start_pos).to_usize();\n-\n-                // Translate line-start positions and multibyte character\n-                // position into frame of reference local to file.\n-                // `CodeMap::new_imported_filemap()` will then translate those\n-                // coordinates to their new global frame of reference when the\n-                // offset of the FileMap is known.\n-                let mut lines = lines.into_inner();\n-                for pos in &mut lines {\n-                    *pos = *pos - start_pos;\n-                }\n-                let mut multibyte_chars = multibyte_chars.into_inner();\n-                for mbc in &mut multibyte_chars {\n-                    mbc.pos = mbc.pos - start_pos;\n-                }\n-\n-                let local_version = local_codemap.new_imported_filemap(name,\n-                                                                       abs_path,\n-                                                                       source_length,\n-                                                                       lines,\n-                                                                       multibyte_chars);\n-                cstore::ImportedFileMap {\n-                    original_start_pos: start_pos,\n-                    original_end_pos: end_pos,\n-                    translated_filemap: local_version\n-                }\n-            }\n-        }\n-    }).collect();\n-\n-    return imported_filemaps;\n-\n-    fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap,\n-                                 fm2: &syntax_pos::FileMap)\n-                                 -> bool {\n-        if fm1.name != fm2.name {\n-            return false;\n-        }\n-\n-        let lines1 = fm1.lines.borrow();\n-        let lines2 = fm2.lines.borrow();\n-\n-        if lines1.len() != lines2.len() {\n-            return false;\n-        }\n-\n-        for (&line1, &line2) in lines1.iter().zip(lines2.iter()) {\n-            if (line1 - fm1.start_pos) != (line2 - fm2.start_pos) {\n-                return false;\n-            }\n-        }\n-\n-        let multibytes1 = fm1.multibyte_chars.borrow();\n-        let multibytes2 = fm2.multibyte_chars.borrow();\n-\n-        if multibytes1.len() != multibytes2.len() {\n-            return false;\n-        }\n-\n-        for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n-            if (mb1.bytes != mb2.bytes) ||\n-               ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n-                return false;\n-            }\n-        }\n-\n-        true\n-    }\n-}"}, {"sha": "f508c5dc9cfb0f85e516340cd841df1d99aabc15", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use cstore;\n-use common;\n use encoder;\n use loader;\n+use schema;\n \n use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, ExternCrate};\n use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n@@ -97,7 +97,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx>\n+                         -> ty::Generics<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_generics(def.index, tcx)\n@@ -121,7 +121,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).get_adt_def(def.index, tcx)\n     }\n \n-    fn fn_arg_names(&self, did: DefId) -> Vec<String>\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>\n     {\n         self.dep_graph.read(DepNode::MetaData(did));\n         self.get_crate_data(did.krate).get_fn_arg_names(did.index)\n@@ -140,10 +140,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let mut result = vec![];\n-        self.get_crate_data(def_id.krate)\n-            .each_inherent_implementation_for_type(def_id.index, |iid| result.push(iid));\n-        result\n+        self.get_crate_data(def_id.krate).get_inherent_implementations_for_type(def_id.index)\n     }\n \n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n@@ -153,9 +150,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         }\n         let mut result = vec![];\n         self.iter_crate_data(|_, cdata| {\n-            cdata.each_implementation_for_trait(filter, &mut |iid| {\n-                result.push(iid)\n-            })\n+            cdata.get_implementations_for_trait(filter, &mut result)\n         });\n         result\n     }\n@@ -308,7 +303,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n     {\n-        self.get_crate_data(cnum).info.plugin_registrar_fn.map(|index| DefId {\n+        self.get_crate_data(cnum).root.plugin_registrar_fn.map(|index| DefId {\n             krate: cnum,\n             index: index\n         })\n@@ -552,7 +547,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn metadata_encoding_version(&self) -> &[u8]\n     {\n-        common::metadata_encoding_version\n+        schema::METADATA_HEADER\n     }\n \n     /// Returns a map from a sufficiently visible external item (i.e. an external item that is"}, {"sha": "0a1ff70a0497e518992afb0b8507f63aab173d32", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 11, "deletions": 58, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -11,12 +11,8 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-pub use self::MetadataBlob::*;\n-\n-use common;\n-use creader;\n-use index;\n use loader;\n+use schema;\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n@@ -27,13 +23,12 @@ use rustc::session::config::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap, FnvHashSet};\n \n-use std::cell::{RefCell, Ref, Cell};\n+use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::codemap;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibraryKind, LinkagePreference};\n@@ -47,12 +42,12 @@ pub use rustc::middle::cstore::{CrateSource, LinkMeta};\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub enum MetadataBlob {\n-    MetadataVec(Bytes),\n-    MetadataArchive(loader::ArchiveMetadata),\n+    Inflated(Bytes),\n+    Archive(loader::ArchiveMetadata),\n }\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n-/// See creader::import_codemap() for more information.\n+/// See `imported_filemaps()` for more information.\n pub struct ImportedFileMap {\n     /// This FileMap's byte-offset within the codemap of its original crate\n     pub original_start_pos: syntax_pos::BytePos,\n@@ -70,13 +65,12 @@ pub struct CrateMetadata {\n     /// (e.g., by the allocator)\n     pub extern_crate: Cell<Option<ExternCrate>>,\n \n-    pub data: MetadataBlob,\n+    pub blob: MetadataBlob,\n     pub cnum_map: RefCell<CrateNumMap>,\n     pub cnum: CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n \n-    pub info: common::CrateInfo,\n-    pub index: index::Index,\n+    pub root: schema::CrateRoot,\n \n     /// For each public item in this crate, we encode a key.  When the\n     /// crate is loaded, we read all the keys and put them in this\n@@ -294,23 +288,9 @@ impl CStore {\n }\n \n impl CrateMetadata {\n-    pub fn name(&self) -> &str { &self.info.name }\n-    pub fn hash(&self) -> Svh { self.info.hash }\n-    pub fn disambiguator(&self) -> &str { &self.info.disambiguator }\n-    pub fn imported_filemaps<'a>(&'a self, codemap: &codemap::CodeMap)\n-                                 -> Ref<'a, Vec<ImportedFileMap>> {\n-        let filemaps = self.codemap_import_info.borrow();\n-        if filemaps.is_empty() {\n-            drop(filemaps);\n-            let filemaps = creader::import_codemap(codemap, &self.data);\n-\n-            // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n-            *self.codemap_import_info.borrow_mut() = filemaps;\n-            self.codemap_import_info.borrow()\n-        } else {\n-            filemaps\n-        }\n-    }\n+    pub fn name(&self) -> &str { &self.root.name }\n+    pub fn hash(&self) -> Svh { self.root.hash }\n+    pub fn disambiguator(&self) -> &str { &self.root.disambiguator }\n \n     pub fn is_staged_api(&self) -> bool {\n         self.get_item_attrs(CRATE_DEF_INDEX).iter().any(|attr| {\n@@ -349,33 +329,6 @@ impl CrateMetadata {\n     }\n \n     pub fn panic_strategy(&self) -> PanicStrategy {\n-        self.info.panic_strategy.clone()\n-    }\n-}\n-\n-impl MetadataBlob {\n-    pub fn as_slice_raw<'a>(&'a self) -> &'a [u8] {\n-        match *self {\n-            MetadataVec(ref vec) => &vec[..],\n-            MetadataArchive(ref ar) => ar.as_slice(),\n-        }\n-    }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n-        let slice = self.as_slice_raw();\n-        let len_offset = 4 + common::metadata_encoding_version.len();\n-        if slice.len() < len_offset+4 {\n-            &[] // corrupt metadata\n-        } else {\n-            let len = (((slice[len_offset+0] as u32) << 24) |\n-                       ((slice[len_offset+1] as u32) << 16) |\n-                       ((slice[len_offset+2] as u32) << 8) |\n-                       ((slice[len_offset+3] as u32) << 0)) as usize;\n-            if len <= slice.len() - 4 - len_offset {\n-                &slice[len_offset + 4..len_offset + len + 4]\n-            } else {\n-                &[] // corrupt or old metadata\n-            }\n-        }\n+        self.root.panic_strategy.clone()\n     }\n }"}, {"sha": "7a4d3ed657a1e7862a2d2c0033bbd24590f1bb25", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 493, "deletions": 464, "changes": 957, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -11,11 +11,10 @@\n // Decoding metadata from a single crate's metadata\n \n use astencode::decode_inlined_item;\n-use cstore::{CrateMetadata, MetadataBlob, NativeLibraryKind};\n-use common::*;\n-use index;\n+use cstore::{self, CrateMetadata, MetadataBlob, NativeLibraryKind};\n+use index::Index;\n+use schema::*;\n \n-use rustc::hir::svh::Svh;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::{DefKey, DefPathData};\n use rustc::util::nodemap::FnvHashMap;\n@@ -26,81 +25,126 @@ use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n use rustc::hir::def::{self, Def};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc::middle::lang_items;\n-use rustc::ty::{ImplContainer, TraitContainer};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n \n use rustc_const_math::ConstInt;\n \n use rustc::mir::repr::Mir;\n \n+use std::cell::Ref;\n use std::io;\n use std::mem;\n use std::rc::Rc;\n use std::str;\n use std::u32;\n \n-use rbml;\n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, NodeId};\n+use syntax::codemap;\n use syntax::parse::token;\n-use syntax_pos::{self, Span, BytePos};\n+use syntax_pos::{self, Span, BytePos, Pos};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n-    pub opaque: opaque::Decoder<'a>,\n+    opaque: opaque::Decoder<'a>,\n     tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     cdata: Option<&'a CrateMetadata>,\n-    pub from_id_range: IdRange,\n-    pub to_id_range: IdRange,\n+    from_id_range: IdRange,\n+    to_id_range: IdRange,\n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n }\n \n-impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    pub fn new(doc: rbml::Doc<'a>, cdata: Option<&'a CrateMetadata>)\n-               -> DecodeContext<'a, 'tcx> {\n+/// Abstract over the various ways one can create metadata decoders.\n+pub trait Metadata<'a, 'tcx>: Copy {\n+    fn raw_bytes(self) -> &'a [u8];\n+    fn cdata(self) -> Option<&'a CrateMetadata> { None }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n+\n+    fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let id_range = IdRange {\n             min: NodeId::from_u32(u32::MIN),\n             max: NodeId::from_u32(u32::MAX)\n         };\n         DecodeContext {\n-            opaque: opaque::Decoder::new(doc.data, doc.start),\n-            cdata: cdata,\n-            tcx: None,\n+            opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n+            cdata: self.cdata(),\n+            tcx: self.tcx(),\n             from_id_range: id_range,\n             to_id_range: id_range,\n             last_filemap_index: 0\n         }\n     }\n+}\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n+    fn raw_bytes(self) -> &'a [u8] {\n+        match *self {\n+            MetadataBlob::Inflated(ref vec) => &vec[..],\n+            MetadataBlob::Archive(ref ar) => ar.as_slice(),\n+        }\n     }\n+}\n \n-    pub fn cdata(&self) -> &'a CrateMetadata {\n-        self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n-    }\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n+    fn raw_bytes(self) -> &'a [u8] { self.blob.raw_bytes() }\n+    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self) }\n+}\n+\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>) {\n+    fn raw_bytes(self) -> &'a [u8] { self.0.raw_bytes() }\n+    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self.0) }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { Some(self.1) }\n+}\n \n-    pub fn decode<T: Decodable>(&mut self) -> T {\n-        T::decode(self).unwrap()\n+// HACK(eddyb) Only used by astencode to customize the from/to IdRange's.\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>, [IdRange; 2]) {\n+    fn raw_bytes(self) -> &'a [u8] { self.0.raw_bytes() }\n+    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self.0) }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { Some(self.1) }\n+\n+    fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n+        let mut dcx = (self.0, self.1).decoder(pos);\n+        dcx.from_id_range = self.2[0];\n+        dcx.to_id_range = self.2[1];\n+        dcx\n     }\n+}\n \n-    pub fn typed(mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        self.tcx = Some(tcx);\n-        self\n+impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n+    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n+        T::decode(&mut meta.decoder(self.position)).unwrap()\n     }\n+}\n \n-    /// Iterate over the indices of a sequence.\n-    /// This will work solely because of `serialize::opaque`'s\n-    /// simple encoding of `n: usize` followed by `n` elements.\n-    pub fn seq<T: Decodable>(mut self) -> impl Iterator<Item=T> {\n-        (0..self.read_usize().unwrap()).map(move |_| {\n-            self.decode()\n+impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n+    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> impl Iterator<Item=T> + 'a {\n+        let mut dcx = meta.decoder(self.position);\n+        (0..self.len).map(move |_| {\n+            T::decode(&mut dcx).unwrap()\n         })\n     }\n }\n \n+impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n+    }\n+\n+    pub fn cdata(&self) -> &'a CrateMetadata {\n+        self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n+    }\n+\n+    fn with_position<F: FnOnce(&mut Self) -> R, R>(&mut self, pos: usize, f: F) -> R {\n+        let new = opaque::Decoder::new(self.opaque.data, pos);\n+        let old = mem::replace(&mut self.opaque, new);\n+        let r = f(self);\n+        self.opaque = old;\n+        r\n+    }\n+}\n+\n macro_rules! decoder_methods {\n     ($($name:ident -> $ty:ty;)*) => {\n         $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n@@ -139,6 +183,19 @@ impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n+        Ok(Lazy::with_position(self.read_usize()?))\n+    }\n+}\n+\n+impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<LazySeq<T>, Self::Error> {\n+        let len = self.read_usize()?;\n+        Ok(LazySeq::with_position_and_length(self.read_usize()?, len))\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedDecoder<NodeId> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n         let id = u32::decode(self)?;\n@@ -252,15 +309,33 @@ impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n                 return Ok(ty);\n             }\n \n-            let new = opaque::Decoder::new(self.opaque.data, key.pos);\n-            let old = mem::replace(&mut self.opaque, new);\n-            let ty = Ty::decode(self)?;\n-            self.opaque = old;\n+            let ty = self.with_position(key.pos, Ty::decode)?;\n             tcx.rcache.borrow_mut().insert(key, ty);\n-            return Ok(ty);\n+            Ok(ty)\n+        } else {\n+            Ok(tcx.mk_ty(ty::TypeVariants::decode(self)?))\n         }\n+    }\n+}\n+\n+\n+impl<'a, 'tcx> SpecializedDecoder<ty::GenericPredicates<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ty::GenericPredicates<'tcx>, Self::Error> {\n+        Ok(ty::GenericPredicates {\n+            parent: Decodable::decode(self)?,\n+            predicates: (0..self.read_usize()?).map(|_| {\n+                // Handle shorthands first, if we have an usize > 0x80.\n+                if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n+                    let pos = self.read_usize()?;\n+                    assert!(pos >= SHORTHAND_OFFSET);\n+                    let pos = pos - SHORTHAND_OFFSET;\n \n-        Ok(tcx.mk_ty(ty::TypeVariants::decode(self)?))\n+                    self.with_position(pos, ty::Predicate::decode)\n+                } else {\n+                    ty::Predicate::decode(self)\n+                }\n+            }).collect()?\n+        })\n     }\n }\n \n@@ -295,185 +370,110 @@ impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx>\n     }\n }\n \n-#[derive(Clone)]\n-pub struct CrateDep {\n-    pub cnum: CrateNum,\n-    pub name: String,\n-    pub hash: Svh,\n-    pub explicitly_linked: bool,\n-}\n-\n impl<'a, 'tcx> MetadataBlob {\n-    fn root(&self) -> rbml::Doc {\n-        rbml::Doc::new(self.as_slice())\n-    }\n-\n-    fn child_at(&'a self, pos: usize, tag: usize) -> DecodeContext<'a, 'tcx> {\n-        DecodeContext::new(rbml::Doc::at(self.as_slice(), pos).child(tag), None)\n+    pub fn is_compatible(&self) -> bool {\n+        self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n \n-    fn get(&'a self, tag: usize) -> DecodeContext<'a, 'tcx> {\n-        DecodeContext::new(self.root().child(tag), None)\n+    pub fn get_root(&self) -> CrateRoot {\n+        let slice = self.raw_bytes();\n+        let offset = METADATA_HEADER.len();\n+        let pos = (((slice[offset + 0] as u32) << 24) |\n+                   ((slice[offset + 1] as u32) << 16) |\n+                   ((slice[offset + 2] as u32) << 8) |\n+                   ((slice[offset + 3] as u32) << 0)) as usize;\n+        Lazy::with_position(pos).decode(self)\n     }\n \n-    pub fn load_index(&self) -> index::Index {\n-        index::Index::from_rbml(self.root().child(root_tag::index))\n-    }\n-\n-    pub fn crate_rustc_version(&self) -> Option<String> {\n-        self.root().maybe_child(root_tag::rustc_version).map(|s| {\n-            str::from_utf8(&s.data[s.start..s.end]).unwrap().to_string()\n-        })\n-    }\n-\n-    // Go through each item in the metadata and create a map from that\n-    // item's def-key to the item's DefIndex.\n-    pub fn load_key_map(&self) -> FnvHashMap<DefKey, DefIndex> {\n-        self.load_index().iter_enumerated(self.as_slice()).map(|(index, pos)| {\n-            (self.child_at(pos as usize, item_tag::def_key).decode(), index)\n-        }).collect()\n-    }\n-\n-    pub fn get_crate_deps(&self) -> Vec<CrateDep> {\n-        let dcx = self.get(root_tag::crate_deps);\n-\n-        dcx.seq().enumerate().map(|(crate_num, (name, hash, explicitly_linked))| {\n-            CrateDep {\n-                cnum: CrateNum::new(crate_num + 1),\n-                name: name,\n-                hash: hash,\n-                explicitly_linked: explicitly_linked,\n-            }\n+    /// Go through each item in the metadata and create a map from that\n+    /// item's def-key to the item's DefIndex.\n+    pub fn load_key_map(&self, index: LazySeq<Index>) -> FnvHashMap<DefKey, DefIndex> {\n+        index.iter_enumerated(self.raw_bytes()).map(|(index, item)| {\n+            (item.decode(self).def_key.decode(self), index)\n         }).collect()\n     }\n \n-    pub fn get_crate_info(&self) -> CrateInfo {\n-        self.get(root_tag::crate_info).decode()\n-    }\n-\n     pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n-        for dep in &self.get_crate_deps() {\n-            write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash)?;\n+        let root = self.get_root();\n+        for (i, dep) in root.crate_deps.decode(self).enumerate() {\n+            write!(out, \"{} {}-{}\\n\", i + 1, dep.name, dep.hash)?;\n         }\n         write!(out, \"\\n\")?;\n         Ok(())\n     }\n-\n-    pub fn get_imported_filemaps(&self) -> Vec<syntax_pos::FileMap> {\n-        self.get(root_tag::codemap).decode()\n-    }\n-\n-    pub fn each_exported_macro<F>(&self, mut f: F) where\n-        F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n-    {\n-        for (name, attrs, span, body) in self.get(root_tag::macro_defs).seq() {\n-            if !f(name, attrs, span, body) {\n-                break;\n-            }\n-        }\n-    }\n }\n \n-impl Family {\n+impl<'tcx> EntryKind<'tcx> {\n     fn to_def(&self, did: DefId) -> Option<Def> {\n         Some(match *self {\n-            Family::Const  => Def::Const(did),\n-            Family::AssociatedConst => Def::AssociatedConst(did),\n-            Family::ImmStatic | Family::ForeignImmStatic => Def::Static(did, false),\n-            Family::MutStatic | Family::ForeignMutStatic => Def::Static(did, true),\n-            Family::Struct => Def::Struct(did),\n-            Family::Union => Def::Union(did),\n-            Family::Fn | Family::ForeignFn  => Def::Fn(did),\n-            Family::Method => Def::Method(did),\n-            Family::Type => Def::TyAlias(did),\n-            Family::AssociatedType => Def::AssociatedTy(did),\n-            Family::Mod => Def::Mod(did),\n-            Family::Variant => Def::Variant(did),\n-            Family::Trait => Def::Trait(did),\n-            Family::Enum => Def::Enum(did),\n-\n-            Family::ForeignMod |\n-            Family::Impl |\n-            Family::DefaultImpl |\n-            Family::Field |\n-            Family::Closure => {\n+            EntryKind::Const  => Def::Const(did),\n+            EntryKind::AssociatedConst(_) => Def::AssociatedConst(did),\n+            EntryKind::ImmStatic |\n+            EntryKind::ForeignImmStatic => Def::Static(did, false),\n+            EntryKind::MutStatic |\n+            EntryKind::ForeignMutStatic => Def::Static(did, true),\n+            EntryKind::Struct(_) => Def::Struct(did),\n+            EntryKind::Union(_) => Def::Union(did),\n+            EntryKind::Fn(_) |\n+            EntryKind::ForeignFn(_) => Def::Fn(did),\n+            EntryKind::Method(_) => Def::Method(did),\n+            EntryKind::Type => Def::TyAlias(did),\n+            EntryKind::AssociatedType(_) => Def::AssociatedTy(did),\n+            EntryKind::Mod(_) => Def::Mod(did),\n+            EntryKind::Variant(_) => Def::Variant(did),\n+            EntryKind::Trait(_) => Def::Trait(did),\n+            EntryKind::Enum => Def::Enum(did),\n+\n+            EntryKind::ForeignMod |\n+            EntryKind::Impl(_) |\n+            EntryKind::DefaultImpl(_) |\n+            EntryKind::Field |\n+            EntryKind::Closure (_) => {\n                 return None\n             }\n         })\n     }\n }\n \n-impl<'a, 'tcx> CrateMetadata {\n-    fn maybe_get(&'a self, item: rbml::Doc<'a>, tag: usize)\n-                 -> Option<DecodeContext<'a, 'tcx>> {\n-        item.maybe_child(tag).map(|child| {\n-            DecodeContext::new(child, Some(self))\n-        })\n-    }\n-\n-    fn get(&'a self, item: rbml::Doc<'a>, tag: usize) -> DecodeContext<'a, 'tcx> {\n-        match self.maybe_get(item, tag) {\n-            Some(dcx) => dcx,\n-            None => bug!(\"failed to find child with tag {}\", tag)\n+fn def_key_name(def_key: &hir_map::DefKey) -> Option<ast::Name> {\n+    match def_key.disambiguated_data.data {\n+        DefPathData::TypeNs(ref name) |\n+        DefPathData::ValueNs(ref name) |\n+        DefPathData::Module(ref name) |\n+        DefPathData::MacroDef(ref name) |\n+        DefPathData::TypeParam(ref name) |\n+        DefPathData::LifetimeDef(ref name) |\n+        DefPathData::EnumVariant(ref name) |\n+        DefPathData::Field(ref name) |\n+        DefPathData::Binding(ref name) => {\n+            Some(token::intern(name))\n         }\n-    }\n-\n-    fn item_family(&self, item: rbml::Doc) -> Family {\n-        self.get(item, item_tag::family).decode()\n-    }\n \n-    fn item_visibility(&self, item: rbml::Doc) -> ty::Visibility {\n-        self.get(item, item_tag::visibility).decode()\n-    }\n+        DefPathData::InlinedRoot(_) => bug!(\"unexpected DefPathData\"),\n \n-    fn item_def_key(&self, item: rbml::Doc) -> hir_map::DefKey {\n-        self.get(item, item_tag::def_key).decode()\n-    }\n-\n-    fn item_name(&self, item: rbml::Doc) -> ast::Name {\n-        self.maybe_item_name(item).expect(\"no item in item_name\")\n-    }\n-\n-    fn maybe_item_name(&self, item: rbml::Doc) -> Option<ast::Name> {\n-        let name = match self.item_def_key(item).disambiguated_data.data {\n-            DefPathData::TypeNs(name) |\n-            DefPathData::ValueNs(name) |\n-            DefPathData::Module(name) |\n-            DefPathData::MacroDef(name) |\n-            DefPathData::TypeParam(name) |\n-            DefPathData::LifetimeDef(name) |\n-            DefPathData::EnumVariant(name) |\n-            DefPathData::Field(name) |\n-            DefPathData::Binding(name) => Some(name),\n-\n-            DefPathData::InlinedRoot(_) => bug!(\"unexpected DefPathData\"),\n-\n-            DefPathData::CrateRoot |\n-            DefPathData::Misc |\n-            DefPathData::Impl |\n-            DefPathData::ClosureExpr |\n-            DefPathData::StructCtor |\n-            DefPathData::Initializer |\n-            DefPathData::ImplTrait => None\n-        };\n-\n-        name.map(|s| token::intern(&s))\n+        DefPathData::CrateRoot |\n+        DefPathData::Misc |\n+        DefPathData::Impl |\n+        DefPathData::ClosureExpr |\n+        DefPathData::StructCtor |\n+        DefPathData::Initializer |\n+        DefPathData::ImplTrait => None\n     }\n+}\n \n-    fn maybe_entry(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n-        self.index.lookup_item(self.data.as_slice(), item_id).map(|pos| {\n-            rbml::Doc::at(self.data.as_slice(), pos as usize)\n-        })\n+impl<'a, 'tcx> CrateMetadata {\n+    fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n+        self.root.index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n-    fn entry(&self, item_id: DefIndex) -> rbml::Doc {\n+    fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n         match self.maybe_entry(item_id) {\n             None => bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n                          item_id,\n                          self.name,\n                          self.cnum),\n-            Some(d) => d\n+            Some(d) => d.decode(self)\n         }\n     }\n \n@@ -484,62 +484,42 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn entry_data(&self, doc: rbml::Doc) -> EntryData {\n-        self.get(doc, item_tag::data).decode()\n-    }\n-\n-    fn entry_typed_data(&self, doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                        -> EntryTypedData<'tcx> {\n-        self.get(doc, item_tag::typed_data).typed(tcx).decode()\n-    }\n-\n-    fn item_parent_item(&self, d: rbml::Doc) -> Option<DefId> {\n-        self.item_def_key(d).parent.map(|index| self.local_def_id(index))\n-    }\n-\n-    fn doc_type(&self, doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n-        self.maybe_doc_type(doc, tcx).expect(\"missing item_tag::ty\")\n-    }\n-\n-    fn maybe_doc_type(&self, doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n-        self.maybe_get(doc, item_tag::ty).map(|dcx| dcx.typed(tcx).decode())\n+    fn item_name(&self, item: &Entry<'tcx>) -> ast::Name {\n+        def_key_name(&item.def_key.decode(self)).expect(\"no name in item_name\")\n     }\n \n     pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n-        self.item_family(self.entry(index)).to_def(self.local_def_id(index))\n+        self.entry(index).kind.to_def(self.local_def_id(index))\n     }\n \n     pub fn get_trait_def(&self,\n                          item_id: DefIndex,\n                          tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx> {\n-        let item_doc = self.entry(item_id);\n-        let generics = self.doc_generics(item_doc, tcx);\n-\n-        let data = match self.entry_data(item_doc) {\n-            EntryData::Trait(data) => data,\n-            _ => bug!()\n-        };\n-        let typed_data = match self.entry_typed_data(item_doc, tcx) {\n-            EntryTypedData::Trait(data) => data,\n+        let data = match self.entry(item_id).kind {\n+            EntryKind::Trait(data) => data.decode(self),\n             _ => bug!()\n         };\n \n-        ty::TraitDef::new(data.unsafety, data.paren_sugar, generics, typed_data.trait_ref,\n-                          self.def_path(item_id).unwrap().deterministic_hash(tcx)))\n+        ty::TraitDef::new(data.unsafety, data.paren_sugar,\n+                          tcx.lookup_generics(self.local_def_id(item_id)),\n+                          data.trait_ref.decode((self, tcx)),\n+                          self.def_path(item_id).unwrap().deterministic_hash(tcx))\n     }\n \n-    fn get_variant(&self, item: rbml::Doc, index: DefIndex)\n-                  -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n-        let data = match self.entry_data(item) {\n-            EntryData::Variant(data) => data,\n+    fn get_variant(&self, item: &Entry<'tcx>, index: DefIndex)\n+                   -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n+        let data = match item.kind {\n+            EntryKind::Variant(data) |\n+            EntryKind::Struct(data) |\n+            EntryKind::Union(data) => data.decode(self),\n             _ => bug!()\n         };\n \n-        let fields = self.get(item, item_tag::children).seq().map(|index| {\n+        let fields = item.children.decode(self).map(|index| {\n             let f = self.entry(index);\n             ty::FieldDefData::new(self.local_def_id(index),\n-                                  self.item_name(f),\n-                                  self.item_visibility(f))\n+                                  self.item_name(&f),\n+                                  f.visibility)\n         }).collect();\n \n         (ty::VariantDefData {\n@@ -553,27 +533,25 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                        -> ty::AdtDefMaster<'tcx> {\n-        let doc = self.entry(item_id);\n+        let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n         let mut ctor_index = None;\n-        let family = self.item_family(doc);\n-        let variants = if family == Family::Enum {\n-            self.get(doc, item_tag::children).seq().map(|index| {\n-                let (variant, struct_ctor) = self.get_variant(self.entry(index), index);\n+        let variants = if let EntryKind::Enum = item.kind {\n+            item.children.decode(self).map(|index| {\n+                let (variant, struct_ctor) = self.get_variant(&self.entry(index), index);\n                 assert_eq!(struct_ctor, None);\n                 variant\n             }).collect()\n         } else{\n-            let (variant, struct_ctor) = self.get_variant(doc, item_id);\n+            let (variant, struct_ctor) = self.get_variant(&item, item_id);\n             ctor_index = struct_ctor;\n             vec![variant]\n         };\n-        let kind = match family {\n-            Family::Enum => ty::AdtKind::Enum,\n-            Family::Struct => ty::AdtKind::Struct,\n-            Family::Union => ty::AdtKind::Union,\n-            _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n-                      family, did)\n+        let kind = match item.kind {\n+            EntryKind::Enum => ty::AdtKind::Enum,\n+            EntryKind::Struct(_) => ty::AdtKind::Struct,\n+            EntryKind::Union(_) => ty::AdtKind::Union,\n+            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did)\n         };\n \n         let adt = tcx.intern_adt_def(did, kind, variants);\n@@ -599,42 +577,43 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                           -> ty::GenericPredicates<'tcx> {\n-        self.doc_predicates(self.entry(item_id), tcx, item_tag::predicates)\n+        self.entry(item_id).predicates.unwrap().decode((self, tcx))\n     }\n \n     pub fn get_super_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                 -> ty::GenericPredicates<'tcx> {\n-        self.doc_predicates(self.entry(item_id), tcx, item_tag::super_predicates)\n+        match self.entry(item_id).kind {\n+            EntryKind::Trait(data) => {\n+                data.decode(self).super_predicates.decode((self, tcx))\n+            }\n+            _ => bug!()\n+        }\n     }\n \n     pub fn get_generics(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                        -> &'tcx ty::Generics<'tcx> {\n-        self.doc_generics(self.entry(item_id), tcx)\n+                        -> ty::Generics<'tcx> {\n+        self.entry(item_id).generics.unwrap().decode((self, tcx))\n     }\n \n     pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n-        self.doc_type(self.entry(id), tcx)\n+        self.entry(id).ty.unwrap().decode((self, tcx))\n     }\n \n     pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n-        self.maybe_get(self.entry(id), item_tag::stability).map(|mut dcx| {\n-            dcx.decode()\n-        })\n+        self.entry(id).stability.map(|stab| stab.decode(self))\n     }\n \n     pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        self.maybe_get(self.entry(id), item_tag::deprecation).map(|mut dcx| {\n-            dcx.decode()\n-        })\n+        self.entry(id).deprecation.map(|depr| depr.decode(self))\n     }\n \n     pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n-        self.item_visibility(self.entry(id))\n+        self.entry(id).visibility\n     }\n \n-    fn get_impl_data(&self, id: DefIndex) -> ImplData {\n-        match self.entry_data(self.entry(id)) {\n-            EntryData::Impl(data) => data,\n+    fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n+        match self.entry(id).kind {\n+            EntryKind::Impl(data) => data.decode(self),\n             _ => bug!()\n         }\n     }\n@@ -656,54 +635,47 @@ impl<'a, 'tcx> CrateMetadata {\n                           id: DefIndex,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                           -> Option<ty::TraitRef<'tcx>> {\n-        match self.entry_typed_data(self.entry(id), tcx) {\n-            EntryTypedData::Impl(data) => data.trait_ref,\n-            _ => bug!()\n-        }\n+        self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over the language items in the given crate.\n     pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n-        self.get(self.data.root(), root_tag::lang_items).decode()\n+        self.root.lang_items.decode(self).collect()\n     }\n \n     /// Iterates over each child of the given item.\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F)\n         where F: FnMut(def::Export)\n     {\n         // Find the item.\n-        let item_doc = match self.maybe_entry(id) {\n+        let item = match self.maybe_entry(id) {\n             None => return,\n-            Some(item_doc) => item_doc,\n-        };\n-\n-        let dcx = match self.maybe_get(item_doc, item_tag::children) {\n-            Some(dcx) => dcx,\n-            None => return\n+            Some(item) => item.decode(self),\n         };\n \n         // Iterate over all children.\n-        for child_index in dcx.seq() {\n+        for child_index in item.children.decode(self) {\n             // Get the item.\n             if let Some(child) = self.maybe_entry(child_index) {\n+                let child = child.decode(self);\n                 // Hand off the item to the callback.\n-                match self.item_family(child) {\n+                match child.kind {\n                     // FIXME(eddyb) Don't encode these in children.\n-                    Family::ForeignMod => {\n-                        for child_index in self.get(child, item_tag::children).seq() {\n+                    EntryKind::ForeignMod => {\n+                        for child_index in child.children.decode(self) {\n                             callback(def::Export {\n                                 def_id: self.local_def_id(child_index),\n-                                name: self.item_name(self.entry(child_index))\n+                                name: self.item_name(&self.entry(child_index))\n                             });\n                         }\n                         continue;\n                     }\n-                    Family::Impl | Family::DefaultImpl => continue,\n+                    EntryKind::Impl(_) | EntryKind::DefaultImpl(_) => continue,\n \n                     _ => {}\n                 }\n \n-                if let Some(name) = self.maybe_item_name(child) {\n+                if let Some(name) = def_key_name(&child.def_key.decode(self)) {\n                     callback(def::Export {\n                         def_id: self.local_def_id(child_index),\n                         name: name\n@@ -712,17 +684,15 @@ impl<'a, 'tcx> CrateMetadata {\n             }\n         }\n \n-        let reexports = match self.entry_data(item_doc) {\n-            EntryData::Mod(data) => data.reexports,\n-            _ => return\n-        };\n-        for exp in reexports {\n-            callback(exp);\n+        if let EntryKind::Mod(data) = item.kind {\n+            for exp in data.decode(self).reexports.decode(self) {\n+                callback(exp);\n+            }\n         }\n     }\n \n     pub fn maybe_get_item_name(&self, id: DefIndex) -> Option<ast::Name> {\n-        self.maybe_item_name(self.entry(id))\n+        def_key_name(&self.entry(id).def_key.decode(self))\n     }\n \n     pub fn maybe_get_item_ast(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n@@ -733,157 +703,119 @@ impl<'a, 'tcx> CrateMetadata {\n         let parent_def_id = self.local_def_id(self.def_key(id).parent.unwrap());\n         let mut parent_def_path = self.def_path(id).unwrap();\n         parent_def_path.data.pop();\n-        item_doc.maybe_child(item_tag::ast).map(|ast_doc| {\n-            decode_inlined_item(self, tcx, parent_def_path, parent_def_id, ast_doc, item_did)\n+        item_doc.ast.map(|ast| {\n+            let ast = ast.decode(self);\n+            decode_inlined_item(self, tcx, parent_def_path, parent_def_id, ast, item_did)\n         })\n     }\n \n     pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n-        if let Some(item_doc) = self.maybe_entry(id) {\n-            return item_doc.maybe_child(item_tag::mir).is_some();\n-        }\n-\n-        false\n+        self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n     pub fn maybe_get_item_mir(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n                               -> Option<Mir<'tcx>> {\n-        self.maybe_get(self.entry(id), item_tag::mir).map(|dcx| {\n-            dcx.typed(tcx).decode()\n-        })\n+        self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n     }\n \n     pub fn get_impl_or_trait_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                   -> Option<ty::ImplOrTraitItem<'tcx>> {\n-        let item_doc = self.entry(id);\n-        let family = self.item_family(item_doc);\n-\n-        match family {\n-            Family::AssociatedConst |\n-            Family::Method |\n-            Family::AssociatedType => {}\n-\n-            _ => return None\n-        }\n-\n-        let def_id = self.local_def_id(id);\n-\n-        let container_id = self.item_parent_item(item_doc).unwrap();\n-        let container = match self.item_family(self.entry(container_id.index)) {\n-            Family::Trait => TraitContainer(container_id),\n-            _ => ImplContainer(container_id),\n+        let item = self.entry(id);\n+        let parent_and_name = || {\n+            let def_key = item.def_key.decode(self);\n+            (self.local_def_id(def_key.parent.unwrap()),\n+             def_key_name(&def_key).unwrap())\n         };\n \n-        let name = self.item_name(item_doc);\n-        let vis = self.item_visibility(item_doc);\n-\n-        let (defaultness, has_body) = match self.entry_data(item_doc) {\n-            EntryData::TraitAssociated(data) => {\n-                (hir::Defaultness::Default, data.has_default)\n-            }\n-            EntryData::ImplAssociated(data) => {\n-                (data.defaultness, true)\n-            }\n-            _ => bug!()\n-        };\n-\n-        Some(match family {\n-            Family::AssociatedConst => {\n+        Some(match item.kind {\n+            EntryKind::AssociatedConst(container) => {\n+                let (parent, name) = parent_and_name();\n                 ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n                     name: name,\n-                    ty: self.doc_type(item_doc, tcx),\n-                    vis: vis,\n-                    defaultness: defaultness,\n-                    def_id: def_id,\n-                    container: container,\n-                    has_value: has_body,\n+                    ty: item.ty.unwrap().decode((self, tcx)),\n+                    vis: item.visibility,\n+                    defaultness: container.defaultness(),\n+                    def_id: self.local_def_id(id),\n+                    container: container.with_def_id(parent),\n+                    has_value: container.has_body(),\n                 }))\n             }\n-            Family::Method => {\n-                let generics = self.doc_generics(item_doc, tcx);\n-                let predicates = self.doc_predicates(item_doc, tcx, item_tag::predicates);\n-                let ity = tcx.lookup_item_type(def_id).ty;\n+            EntryKind::Method(data) => {\n+                let (parent, name) = parent_and_name();\n+                let ity = item.ty.unwrap().decode((self, tcx));\n                 let fty = match ity.sty {\n                     ty::TyFnDef(.., fty) => fty,\n                     _ => bug!(\n                         \"the type {:?} of the method {:?} is not a function?\",\n                         ity, name)\n                 };\n \n-                let explicit_self = match self.entry_typed_data(item_doc, tcx) {\n-                    EntryTypedData::Method(data) => data.explicit_self,\n-                    _ => bug!()\n-                };\n+                let data = data.decode(self);\n                 ty::MethodTraitItem(Rc::new(ty::Method {\n                     name: name,\n-                    generics: generics,\n-                    predicates: predicates,\n+                    generics: tcx.lookup_generics(self.local_def_id(id)),\n+                    predicates: item.predicates.unwrap().decode((self, tcx)),\n                     fty: fty,\n-                    explicit_self: explicit_self,\n-                    vis: vis,\n-                    defaultness: defaultness,\n-                    has_body: has_body,\n-                    def_id: def_id,\n-                    container: container,\n+                    explicit_self: data.explicit_self.decode((self, tcx)),\n+                    vis: item.visibility,\n+                    defaultness: data.container.defaultness(),\n+                    has_body: data.container.has_body(),\n+                    def_id: self.local_def_id(id),\n+                    container: data.container.with_def_id(parent),\n                 }))\n             }\n-            Family::AssociatedType => {\n+            EntryKind::AssociatedType(container) => {\n+                let (parent, name) = parent_and_name();\n                 ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n                     name: name,\n-                    ty: self.maybe_doc_type(item_doc, tcx),\n-                    vis: vis,\n-                    defaultness: defaultness,\n-                    def_id: def_id,\n-                    container: container,\n+                    ty: item.ty.map(|ty| ty.decode((self, tcx))),\n+                    vis: item.visibility,\n+                    defaultness: container.defaultness(),\n+                    def_id: self.local_def_id(id),\n+                    container: container.with_def_id(parent),\n                 }))\n             }\n-            _ => bug!()\n+            _ => return None\n         })\n     }\n \n     pub fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n-        let item_doc = self.entry(id);\n-        self.get(item_doc, item_tag::variances).decode()\n+        self.entry(id).variances.decode(self).collect()\n     }\n \n     pub fn get_struct_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n-        let data = match self.entry_data(self.entry(node_id)) {\n-            EntryData::Variant(data) => data,\n-            _ => bug!()\n-        };\n-\n-        data.struct_ctor.map(|index| self.local_def_id(index))\n+        match self.entry(node_id).kind {\n+            EntryKind::Struct(data) => {\n+                data.decode(self).struct_ctor.map(|index| self.local_def_id(index))\n+            }\n+            _ => None\n+        }\n     }\n \n     pub fn get_item_attrs(&self, node_id: DefIndex) -> Vec<ast::Attribute> {\n         // The attributes for a tuple struct are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n         let mut item = self.entry(node_id);\n-        let def_key = self.item_def_key(item);\n+        let def_key = item.def_key.decode(self);\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        self.get_attributes(item)\n+        self.get_attributes(&item)\n     }\n \n     pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        self.get(self.entry(id), item_tag::children).seq().map(|index| {\n-            self.item_name(self.entry(index))\n+        self.entry(id).children.decode(self).map(|index| {\n+            self.item_name(&self.entry(index))\n         }).collect()\n     }\n \n-    fn get_attributes(&self, md: rbml::Doc) -> Vec<ast::Attribute> {\n-        self.maybe_get(md, item_tag::attributes).map_or(vec![], |mut dcx| {\n-            let mut attrs = dcx.decode::<Vec<ast::Attribute>>();\n-\n+    fn get_attributes(&self, item: &Entry<'tcx>) -> Vec<ast::Attribute> {\n+        item.attributes.decode(self).map(|mut attr| {\n             // Need new unique IDs: old thread-local IDs won't map to new threads.\n-            for attr in attrs.iter_mut() {\n-                attr.node.id = attr::mk_attr_id();\n-            }\n-\n-            attrs\n-        })\n+            attr.node.id = attr::mk_attr_id();\n+            attr\n+        }).collect()\n     }\n \n     // Translate a DefId from the current compilation environment to a DefId\n@@ -898,106 +830,97 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    pub fn each_inherent_implementation_for_type<F>(&self, id: DefIndex, mut callback: F)\n-        where F: FnMut(DefId),\n-    {\n-        for impl_def_id in self.get(self.entry(id), item_tag::inherent_impls).seq() {\n-            callback(impl_def_id);\n-        }\n+    pub fn get_inherent_implementations_for_type(&self, id: DefIndex) -> Vec<DefId> {\n+        self.entry(id).inherent_impls.decode(self).map(|index| {\n+            self.local_def_id(index)\n+        }).collect()\n     }\n \n-    pub fn each_implementation_for_trait<F>(&self,\n-                                            filter: Option<DefId>,\n-                                            mut callback: F) where\n-        F: FnMut(DefId),\n-    {\n+    pub fn get_implementations_for_trait(&self, filter: Option<DefId>, result: &mut Vec<DefId>) {\n         // Do a reverse lookup beforehand to avoid touching the crate_num\n         // hash map in the loop below.\n         let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n-            Some(Some(def_id)) => Some(def_id),\n+            Some(Some(def_id)) => Some((def_id.krate.as_u32(), def_id.index)),\n             Some(None) => return,\n             None => None\n         };\n \n         // FIXME(eddyb) Make this O(1) instead of O(n).\n-        for trait_doc in self.data.root().children_of(root_tag::impls) {\n-            let mut dcx = DecodeContext::new(trait_doc, Some(self));\n-\n-            let (krate, index) = dcx.decode();\n-            if let Some(local_did) = filter {\n-                if (local_did.krate.as_u32(), local_did.index) != (krate, index) {\n-                    continue;\n-                }\n+        for trait_impls in self.root.impls.decode(self) {\n+            if filter.is_some() && filter != Some(trait_impls.trait_id) {\n+                continue;\n             }\n \n-            for impl_def_id in dcx.seq() {\n-                callback(impl_def_id);\n+            result.extend(trait_impls.impls.decode(self).map(|index| {\n+                self.local_def_id(index)\n+            }));\n+\n+            if filter.is_some() {\n+                break;\n             }\n         }\n     }\n \n     pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n-        let item_doc = self.entry(id);\n-        let parent_item_id = match self.item_parent_item(item_doc) {\n-            None => return None,\n-            Some(item_id) => item_id,\n-        };\n-        match self.item_family(self.entry(parent_item_id.index)) {\n-            Family::Trait => Some(parent_item_id),\n-            _ => None\n-        }\n+        self.entry(id).def_key.decode(self).parent.and_then(|parent_index| {\n+            match self.entry(parent_index).kind {\n+                EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n+                _ => None\n+            }\n+        })\n     }\n \n \n     pub fn get_native_libraries(&self) -> Vec<(NativeLibraryKind, String)> {\n-        self.get(self.data.root(), root_tag::native_libraries).decode()\n+        self.root.native_libraries.decode(self).collect()\n     }\n \n     pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n-        let dcx = self.get(self.data.root(), root_tag::dylib_dependency_formats);\n-\n-        dcx.seq::<Option<_>>().enumerate().flat_map(|(i, link)| {\n+        self.root.dylib_dependency_formats.decode(self).enumerate().flat_map(|(i, link)| {\n             let cnum = CrateNum::new(i + 1);\n             link.map(|link| (self.cnum_map.borrow()[cnum], link))\n         }).collect()\n     }\n \n     pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n-        self.get(self.data.root(), root_tag::lang_items_missing).decode()\n+        self.root.lang_items_missing.decode(self).collect()\n     }\n \n-    pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<String> {\n-        self.maybe_get(self.entry(id), item_tag::fn_arg_names)\n-            .map_or(vec![], |mut dcx| dcx.decode())\n+    pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+        let arg_names = match self.entry(id).kind {\n+            EntryKind::Fn(data) |\n+            EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n+            EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n+            _ => LazySeq::empty()\n+        };\n+        arg_names.decode(self).collect()\n     }\n \n     pub fn get_reachable_ids(&self) -> Vec<DefId> {\n-        let dcx = self.get(self.data.root(), root_tag::reachable_ids);\n-\n-        dcx.seq().map(|index| self.local_def_id(index)).collect()\n+        self.root.reachable_ids.decode(self).map(|index| self.local_def_id(index)).collect()\n     }\n \n     pub fn is_const_fn(&self, id: DefIndex) -> bool {\n-        let constness = match self.entry_data(self.entry(id)) {\n-            EntryData::ImplAssociated(data) => data.constness,\n-            EntryData::Fn(data) => data.constness,\n+        let constness = match self.entry(id).kind {\n+            EntryKind::Method(data) => data.decode(self).fn_data.constness,\n+            EntryKind::Fn(data) => data.decode(self).constness,\n             _ => hir::Constness::NotConst\n         };\n         constness == hir::Constness::Const\n     }\n \n     pub fn is_extern_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        let item_doc = match self.maybe_entry(id) {\n-            Some(doc) => doc,\n+        let item = match self.maybe_entry(id) {\n+            Some(item) => item.decode(self),\n             None => return false,\n         };\n-        let applicable = match self.item_family(item_doc) {\n-            Family::ImmStatic |\n-            Family::MutStatic |\n-            Family::ForeignImmStatic |\n-            Family::ForeignMutStatic => true,\n+        let applicable = match item.kind {\n+            EntryKind::ImmStatic |\n+            EntryKind::MutStatic |\n+            EntryKind::ForeignImmStatic |\n+            EntryKind::ForeignMutStatic => true,\n \n-            Family::Fn | Family::ForeignFn => {\n+            EntryKind::Fn(_) | EntryKind::ForeignFn(_) => {\n                 self.get_generics(id, tcx).types.is_empty()\n             }\n \n@@ -1006,83 +929,53 @@ impl<'a, 'tcx> CrateMetadata {\n \n         if applicable {\n             attr::contains_extern_indicator(tcx.sess.diagnostic(),\n-                                            &self.get_attributes(item_doc))\n+                                            &self.get_attributes(&item))\n         } else {\n             false\n         }\n     }\n \n     pub fn is_foreign_item(&self, id: DefIndex) -> bool {\n-        match self.item_family(self.entry(id)) {\n-            Family::ForeignImmStatic |\n-            Family::ForeignMutStatic |\n-            Family::ForeignFn => true,\n+        match self.entry(id).kind {\n+            EntryKind::ForeignImmStatic |\n+            EntryKind::ForeignMutStatic |\n+            EntryKind::ForeignFn(_) => true,\n             _ => false\n         }\n     }\n \n-    fn doc_generics(&self, base_doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                    -> &'tcx ty::Generics<'tcx> {\n-        let generics = self.get(base_doc, item_tag::generics).typed(tcx).decode();\n-        tcx.alloc_generics(generics)\n-    }\n-\n-    fn doc_predicates(&self, base_doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, tag: usize)\n-                      -> ty::GenericPredicates<'tcx> {\n-        let mut dcx = self.get(base_doc, tag).typed(tcx);\n-\n-        ty::GenericPredicates {\n-            parent: dcx.decode(),\n-            predicates: (0..dcx.decode::<usize>()).map(|_| {\n-                // Handle shorthands first, if we have an usize > 0x80.\n-                if dcx.opaque.data[dcx.opaque.position()] & 0x80 != 0 {\n-                    let pos = dcx.decode::<usize>();\n-                    assert!(pos >= SHORTHAND_OFFSET);\n-                    let pos = pos - SHORTHAND_OFFSET;\n-\n-                    let data = self.data.as_slice();\n-                    let doc = rbml::Doc {\n-                        data: data,\n-                        start: pos,\n-                        end: data.len(),\n-                    };\n-                    DecodeContext::new(doc, Some(self)).typed(tcx).decode()\n-                } else {\n-                    dcx.decode()\n-                }\n-            }).collect()\n-        }\n-    }\n-\n     pub fn is_defaulted_trait(&self, trait_id: DefIndex) -> bool {\n-        match self.entry_data(self.entry(trait_id)) {\n-            EntryData::Trait(data) => data.has_default_impl,\n+        match self.entry(trait_id).kind {\n+            EntryKind::Trait(data) => data.decode(self).has_default_impl,\n             _ => bug!()\n         }\n     }\n \n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n-        self.item_family(self.entry(impl_id)) == Family::DefaultImpl\n+        match self.entry(impl_id).kind  {\n+            EntryKind::DefaultImpl(_) => true,\n+            _ => false\n+        }\n     }\n \n     pub fn closure_kind(&self, closure_id: DefIndex) -> ty::ClosureKind {\n-        match self.entry_data(self.entry(closure_id)) {\n-            EntryData::Closure(data) => data.kind,\n+        match self.entry(closure_id).kind {\n+            EntryKind::Closure(data) => data.decode(self).kind,\n             _ => bug!()\n         }\n     }\n \n     pub fn closure_ty(&self, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                       -> ty::ClosureTy<'tcx> {\n-        match self.entry_typed_data(self.entry(closure_id), tcx) {\n-            EntryTypedData::Closure(data) => data.ty,\n+        match self.entry(closure_id).kind {\n+            EntryKind::Closure(data) => data.decode(self).ty.decode((self, tcx)),\n             _ => bug!()\n         }\n     }\n \n     pub fn def_key(&self, id: DefIndex) -> hir_map::DefKey {\n         debug!(\"def_key: id={:?}\", id);\n-        self.item_def_key(self.entry(id))\n+        self.entry(id).def_key.decode(self)\n     }\n \n     // Returns the path leading to the thing with this `id`. Note that\n@@ -1096,4 +989,140 @@ impl<'a, 'tcx> CrateMetadata {\n             None\n         }\n     }\n+\n+    /// Imports the codemap from an external crate into the codemap of the crate\n+    /// currently being compiled (the \"local crate\").\n+    ///\n+    /// The import algorithm works analogous to how AST items are inlined from an\n+    /// external crate's metadata:\n+    /// For every FileMap in the external codemap an 'inline' copy is created in the\n+    /// local codemap. The correspondence relation between external and local\n+    /// FileMaps is recorded in the `ImportedFileMap` objects returned from this\n+    /// function. When an item from an external crate is later inlined into this\n+    /// crate, this correspondence information is used to translate the span\n+    /// information of the inlined item so that it refers the correct positions in\n+    /// the local codemap (see `<decoder::DecodeContext as SpecializedDecoder<Span>>`).\n+    ///\n+    /// The import algorithm in the function below will reuse FileMaps already\n+    /// existing in the local codemap. For example, even if the FileMap of some\n+    /// source file of libstd gets imported many times, there will only ever be\n+    /// one FileMap object for the corresponding file in the local codemap.\n+    ///\n+    /// Note that imported FileMaps do not actually contain the source code of the\n+    /// file they represent, just information about length, line breaks, and\n+    /// multibyte characters. This information is enough to generate valid debuginfo\n+    /// for items inlined from other crates.\n+    pub fn imported_filemaps(&'a self, local_codemap: &codemap::CodeMap)\n+                             -> Ref<'a, Vec<cstore::ImportedFileMap>> {\n+        {\n+            let filemaps = self.codemap_import_info.borrow();\n+            if !filemaps.is_empty() {\n+                return filemaps;\n+            }\n+        }\n+\n+        let external_codemap = self.root.codemap.decode(self);\n+\n+        let imported_filemaps = external_codemap.map(|filemap_to_import| {\n+            // Try to find an existing FileMap that can be reused for the filemap to\n+            // be imported. A FileMap is reusable if it is exactly the same, just\n+            // positioned at a different offset within the codemap.\n+            let reusable_filemap = {\n+                local_codemap.files\n+                             .borrow()\n+                             .iter()\n+                             .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n+                             .map(|rc| rc.clone())\n+            };\n+\n+            match reusable_filemap {\n+                Some(fm) => {\n+                    cstore::ImportedFileMap {\n+                        original_start_pos: filemap_to_import.start_pos,\n+                        original_end_pos: filemap_to_import.end_pos,\n+                        translated_filemap: fm\n+                    }\n+                }\n+                None => {\n+                    // We can't reuse an existing FileMap, so allocate a new one\n+                    // containing the information we need.\n+                    let syntax_pos::FileMap {\n+                        name,\n+                        abs_path,\n+                        start_pos,\n+                        end_pos,\n+                        lines,\n+                        multibyte_chars,\n+                        ..\n+                    } = filemap_to_import;\n+\n+                    let source_length = (end_pos - start_pos).to_usize();\n+\n+                    // Translate line-start positions and multibyte character\n+                    // position into frame of reference local to file.\n+                    // `CodeMap::new_imported_filemap()` will then translate those\n+                    // coordinates to their new global frame of reference when the\n+                    // offset of the FileMap is known.\n+                    let mut lines = lines.into_inner();\n+                    for pos in &mut lines {\n+                        *pos = *pos - start_pos;\n+                    }\n+                    let mut multibyte_chars = multibyte_chars.into_inner();\n+                    for mbc in &mut multibyte_chars {\n+                        mbc.pos = mbc.pos - start_pos;\n+                    }\n+\n+                    let local_version = local_codemap.new_imported_filemap(name,\n+                                                                           abs_path,\n+                                                                           source_length,\n+                                                                           lines,\n+                                                                           multibyte_chars);\n+                    cstore::ImportedFileMap {\n+                        original_start_pos: start_pos,\n+                        original_end_pos: end_pos,\n+                        translated_filemap: local_version\n+                    }\n+                }\n+            }\n+        }).collect();\n+\n+        // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n+        *self.codemap_import_info.borrow_mut() = imported_filemaps;\n+        self.codemap_import_info.borrow()\n+    }\n+}\n+\n+fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap, fm2: &syntax_pos::FileMap) -> bool {\n+    if fm1.name != fm2.name {\n+        return false;\n+    }\n+\n+    let lines1 = fm1.lines.borrow();\n+    let lines2 = fm2.lines.borrow();\n+\n+    if lines1.len() != lines2.len() {\n+        return false;\n+    }\n+\n+    for (&line1, &line2) in lines1.iter().zip(lines2.iter()) {\n+        if (line1 - fm1.start_pos) != (line2 - fm2.start_pos) {\n+            return false;\n+        }\n+    }\n+\n+    let multibytes1 = fm1.multibyte_chars.borrow();\n+    let multibytes2 = fm2.multibyte_chars.borrow();\n+\n+    if multibytes1.len() != multibytes2.len() {\n+        return false;\n+    }\n+\n+    for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n+        if (mb1.bytes != mb2.bytes) ||\n+            ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n+            return false;\n+        }\n+    }\n+\n+    true\n }"}, {"sha": "185aa9e3b921ca800df9a3b062ebbc3c9eaa112b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 773, "deletions": 757, "changes": 1530, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -8,19 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Metadata encoding\n-\n-#![allow(unused_must_use)] // everything is just a MemWriter, can't fail\n-\n-use astencode::encode_inlined_item;\n-use common::*;\n use cstore;\n-use index::IndexData;\n+use index::Index;\n+use schema::*;\n \n-use rustc::middle::cstore::{InlinedItemRef, LinkMeta, LinkagePreference};\n+use rustc::middle::cstore::{InlinedItemRef, LinkMeta};\n+use rustc::middle::cstore::{LinkagePreference, NativeLibraryKind};\n use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n use rustc::middle::dependency_format::Linkage;\n+use rustc::middle::lang_items;\n+use rustc::mir;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n \n@@ -33,13 +31,12 @@ use std::hash::Hash;\n use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n-use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n use syntax;\n-use rbml;\n+use syntax_pos;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::Visitor;\n@@ -48,7 +45,7 @@ use rustc::hir::intravisit;\n use super::index_builder::{FromId, IndexBuilder, Untracked};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n-    rbml_w: rbml::writer::Encoder<'a>,\n+    opaque: opaque::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     reexports: &'a def::ExportMap,\n     link_meta: &'a LinkMeta,\n@@ -60,19 +57,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     predicate_shorthands: FnvHashMap<ty::Predicate<'tcx>, usize>,\n }\n \n-impl<'a, 'tcx> Deref for EncodeContext<'a, 'tcx> {\n-    type Target = rbml::writer::Encoder<'a>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.rbml_w\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefMut for EncodeContext<'a, 'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.rbml_w\n-    }\n-}\n-\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n@@ -109,27 +93,60 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'a, 'tcx> {\n+    fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n+        self.emit_usize(lazy.position)\n+    }\n+}\n+\n+impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n+    fn specialized_encode(&mut self, seq: &LazySeq<T>) -> Result<(), Self::Error> {\n+        self.emit_usize(seq.len)?;\n+        self.emit_usize(seq.position)\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n         self.encode_with_shorthand(ty, &ty.sty, |ecx| &mut ecx.type_shorthands)\n     }\n }\n \n+impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'a, 'tcx> {\n+    fn specialized_encode(&mut self, predicates: &ty::GenericPredicates<'tcx>)\n+                          -> Result<(), Self::Error> {\n+        predicates.parent.encode(self)?;\n+        predicates.predicates.len().encode(self)?;\n+        for predicate in &predicates.predicates {\n+            self.encode_with_shorthand(predicate, predicate, |ecx| &mut ecx.predicate_shorthands)?\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn seq<I, F, T>(&mut self, iter: I, mut f: F)\n-    where I: IntoIterator,\n-          I::IntoIter: ExactSizeIterator,\n-          F: FnMut(&mut Self, I::Item) -> T,\n-          T: Encodable {\n-        let iter = iter.into_iter();\n-        self.emit_seq(iter.len(), move |ecx| {\n-            for (i, elem) in iter.enumerate() {\n-                ecx.emit_seq_elt(i, |ecx| {\n-                    f(ecx, elem).encode(ecx)\n-                })?;\n-            }\n-            Ok(())\n-        }).unwrap();\n+    pub fn position(&self) -> usize {\n+        self.opaque.position()\n+    }\n+\n+    pub fn lazy<T: Encodable>(&mut self, value: &T) -> Lazy<T> {\n+        let pos = self.position();\n+        value.encode(self).unwrap();\n+        Lazy::with_position(pos)\n+    }\n+\n+    fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n+    where I: IntoIterator<Item=T>, T: Encodable {\n+        let pos = self.position();\n+        let len = iter.into_iter().map(|value| value.encode(self).unwrap()).count();\n+        LazySeq::with_position_and_length(pos, len)\n+    }\n+\n+    fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n+    where I: IntoIterator<Item=&'b T>, T: 'b + Encodable {\n+        let pos = self.position();\n+        let len = iter.into_iter().map(|value| value.encode(self).unwrap()).count();\n+        LazySeq::with_position_and_length(pos, len)\n     }\n \n     /// Encode the given value or a previously cached shorthand.\n@@ -143,9 +160,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             return self.emit_usize(shorthand);\n         }\n \n-        let start = self.mark_stable_position();\n+        let start = self.position();\n         variant.encode(self)?;\n-        let len = self.mark_stable_position() - start;\n+        let len = self.position() - start;\n \n         // The shorthand encoding uses the same usize as the\n         // discriminant, with an offset so they can't conflict.\n@@ -170,60 +187,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     /// For every DefId that we create a metadata item for, we include a\n     /// serialized copy of its DefKey, which allows us to recreate a path.\n-    fn encode_def_key(&mut self, def_id: DefId) {\n-        self.start_tag(item_tag::def_key);\n-        self.tcx.map.def_key(def_id).encode(self);\n-        self.end_tag();\n-    }\n-\n-    // Item info table encoding\n-    fn encode_family(&mut self, f: Family) {\n-        self.start_tag(item_tag::family);\n-        f.encode(self).unwrap();\n-        self.end_tag();\n-    }\n-\n-    fn encode_item_variances(&mut self, def_id: DefId) {\n-        let v = self.tcx.item_variances(def_id);\n-        self.start_tag(item_tag::variances);\n-        v.encode(self);\n-        self.end_tag();\n-    }\n-\n-    fn encode_bounds_and_type_for_item(&mut self, def_id: DefId) {\n+    fn encode_def_key(&mut self, def_id: DefId) -> Lazy<hir::map::DefKey> {\n         let tcx = self.tcx;\n-        self.encode_bounds_and_type(&tcx.lookup_item_type(def_id),\n-                                    &tcx.lookup_predicates(def_id));\n-    }\n-\n-    fn encode_bounds_and_type(&mut self,\n-                              scheme: &ty::TypeScheme<'tcx>,\n-                              predicates: &ty::GenericPredicates<'tcx>) {\n-        self.encode_generics(&scheme.generics, &predicates);\n-        self.encode_type(scheme.ty);\n+        self.lazy(&tcx.map.def_key(def_id))\n     }\n \n-    fn encode_type(&mut self, typ: Ty<'tcx>) {\n-        self.start_tag(item_tag::ty);\n-        typ.encode(self).unwrap();\n-        self.end_tag();\n+    fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n+        let tcx = self.tcx;\n+        self.lazy_seq(tcx.item_variances(def_id).iter().cloned())\n     }\n \n-    fn encode_variant(&mut self, variant: ty::VariantDef,\n-                      struct_ctor: Option<DefIndex>)\n-                      -> EntryData {\n-        self.start_tag(item_tag::children);\n-        self.seq(&variant.fields, |_, f| {\n-            assert!(f.did.is_local());\n-            f.did.index\n-        });\n-        self.end_tag();\n-\n-        EntryData::Variant(VariantData {\n-            kind: variant.kind,\n-            disr: variant.disr_val.to_u64_unchecked(),\n-            struct_ctor: struct_ctor\n-        })\n+    fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n+        let tcx = self.tcx;\n+        self.lazy(&tcx.lookup_item_type(def_id).ty)\n     }\n \n     /// Encode data for the given variant of the given ADT. The\n@@ -233,97 +209,104 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// e.g., the length of the various vectors).\n     fn encode_enum_variant_info(&mut self,\n                                 (enum_did, Untracked(index)):\n-                                (DefId, Untracked<usize>)) {\n+                                (DefId, Untracked<usize>)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n-        let vid = variant.did;\n-        self.encode_def_key(vid);\n-        self.encode_family(Family::Variant);\n+        let def_id = variant.did;\n+\n+        let data = VariantData {\n+            kind: variant.kind,\n+            disr: variant.disr_val.to_u64_unchecked(),\n+            struct_ctor: None\n+        };\n \n         let enum_id = tcx.map.as_local_node_id(enum_did).unwrap();\n         let enum_vis = &tcx.map.expect_item(enum_id).vis;\n-        self.encode_visibility(enum_vis);\n-\n-        let attrs = tcx.get_attrs(vid);\n-        self.encode_attributes(&attrs);\n-        self.encode_stability(vid);\n-\n-        let data = self.encode_variant(variant, None);\n-\n-        self.start_tag(item_tag::data);\n-        data.encode(self).unwrap();\n-        self.end_tag();\n \n-        self.start_tag(item_tag::typed_data);\n-        EntryTypedData::Other.encode(self).unwrap();\n-        self.end_tag();\n-\n-        self.encode_bounds_and_type_for_item(vid);\n+        Entry {\n+            kind: EntryKind::Variant(self.lazy(&data)),\n+            visibility: enum_vis.simplify(),\n+            def_key: self.encode_def_key(def_id),\n+            attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n+            children: self.lazy_seq(variant.fields.iter().map(|f| {\n+                assert!(f.did.is_local());\n+                f.did.index\n+            })),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+\n+            ast: None,\n+            mir: None\n+        }\n     }\n \n     fn encode_info_for_mod(&mut self,\n                            FromId(id, (md, attrs, vis)):\n-                           FromId<(&hir::Mod, &[ast::Attribute], &hir::Visibility)>) {\n+                           FromId<(&hir::Mod, &[ast::Attribute], &hir::Visibility)>)\n+                           -> Entry<'tcx> {\n         let tcx = self.tcx;\n-\n         let def_id = tcx.map.local_def_id(id);\n-        self.encode_def_key(def_id);\n-        self.encode_family(Family::Mod);\n-        self.encode_visibility(vis);\n-        self.encode_stability(def_id);\n-        self.encode_attributes(attrs);\n-        debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n-\n-        // Encode info about all the module children.\n-        self.start_tag(item_tag::children);\n-        self.seq(&md.item_ids, |_, item_id| {\n-            tcx.map.local_def_id(item_id.id).index\n-        });\n-        self.end_tag();\n \n-        // Encode the reexports of this module, if this module is public.\n-        let reexports = match self.reexports.get(&id) {\n-            Some(exports) if *vis == hir::Public => exports.clone(),\n-            _ => vec![]\n+        let data = ModData {\n+            reexports: match self.reexports.get(&id) {\n+                Some(exports) if *vis == hir::Public => {\n+                    self.lazy_seq_ref(exports)\n+                }\n+                _ => LazySeq::empty()\n+            }\n         };\n \n-        self.start_tag(item_tag::data);\n-        EntryData::Mod(ModData {\n-            reexports: reexports\n-        }).encode(self).unwrap();\n-        self.end_tag();\n-\n-        self.start_tag(item_tag::typed_data);\n-        EntryTypedData::Other.encode(self).unwrap();\n-        self.end_tag();\n-    }\n-\n-    fn encode_visibility<T: HasVisibility>(&mut self, visibility: T) {\n-        let vis = if visibility.is_public() {\n-            ty::Visibility::Public\n-        } else {\n-            ty::Visibility::PrivateExternal\n-        };\n-        self.start_tag(item_tag::visibility);\n-        vis.encode(self).unwrap();\n-        self.end_tag();\n+        Entry {\n+            kind: EntryKind::Mod(self.lazy(&data)),\n+            visibility: vis.simplify(),\n+            def_key: self.encode_def_key(def_id),\n+            attributes: self.encode_attributes(attrs),\n+            children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n+                tcx.map.local_def_id(item_id.id).index\n+            })),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: None,\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: None,\n+            predicates: None,\n+\n+            ast: None,\n+            mir: None\n+        }\n     }\n }\n \n-trait HasVisibility: Sized {\n-    fn is_public(self) -> bool;\n+trait Visibility {\n+    fn simplify(&self) -> ty::Visibility;\n }\n \n-impl<'a> HasVisibility for &'a hir::Visibility {\n-    fn is_public(self) -> bool {\n-        *self == hir::Public\n+impl Visibility for hir::Visibility {\n+    fn simplify(&self) -> ty::Visibility {\n+        if *self == hir::Public {\n+            ty::Visibility::Public\n+        } else {\n+            ty::Visibility::PrivateExternal\n+        }\n     }\n }\n \n-impl HasVisibility for ty::Visibility {\n-    fn is_public(self) -> bool {\n-        self == ty::Visibility::Public\n+impl Visibility for ty::Visibility {\n+    fn simplify(&self) -> ty::Visibility {\n+        if *self == ty::Visibility::Public {\n+            ty::Visibility::Public\n+        } else {\n+            ty::Visibility::PrivateExternal\n+        }\n     }\n }\n \n@@ -350,312 +333,292 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// vectors).\n     fn encode_field(&mut self,\n                     (adt_def_id, Untracked((variant_index, field_index))):\n-                    (DefId, Untracked<(usize, usize)>)) {\n+                    (DefId, Untracked<(usize, usize)>)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        let def = tcx.lookup_adt_def(adt_def_id);\n-        let variant = &def.variants[variant_index];\n+        let variant = &tcx.lookup_adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n \n-        let nm = field.name;\n-        debug!(\"encode_field: encoding {} {:?}\", nm, field.did);\n-\n-        self.encode_family(Family::Field);\n-        self.encode_visibility(field.vis);\n-        self.encode_bounds_and_type_for_item(field.did);\n-        self.encode_def_key(field.did);\n-\n+        let def_id = field.did;\n         let variant_id = tcx.map.as_local_node_id(variant.did).unwrap();\n         let variant_data = tcx.map.expect_variant_data(variant_id);\n-        self.encode_attributes(&variant_data.fields()[field_index].attrs);\n-        self.encode_stability(field.did);\n+\n+        Entry {\n+            kind: EntryKind::Field,\n+            visibility: field.vis.simplify(),\n+            def_key: self.encode_def_key(def_id),\n+            attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+\n+            ast: None,\n+            mir: None\n+        }\n     }\n \n-    fn encode_struct_ctor(&mut self, ctor_def_id: DefId) {\n-        self.encode_def_key(ctor_def_id);\n-        self.encode_family(Family::Struct);\n-        self.encode_visibility(ty::Visibility::Public);\n-        self.encode_bounds_and_type_for_item(ctor_def_id);\n+    fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId))\n+                          -> Entry<'tcx> {\n+        let variant = self.tcx.lookup_adt_def(adt_def_id).struct_variant();\n \n-        self.encode_stability(ctor_def_id);\n+        let data = VariantData {\n+            kind: variant.kind,\n+            disr: variant.disr_val.to_u64_unchecked(),\n+            struct_ctor: Some(def_id.index)\n+        };\n+\n+        Entry {\n+            kind: EntryKind::Struct(self.lazy(&data)),\n+            visibility: ty::Visibility::Public,\n+            def_key: self.encode_def_key(def_id),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+\n+            ast: None,\n+            mir: None\n+        }\n     }\n \n-    fn encode_generics(&mut self,\n-                       generics: &ty::Generics<'tcx>,\n-                       predicates: &ty::GenericPredicates<'tcx>)\n-    {\n-        self.start_tag(item_tag::generics);\n-        generics.encode(self).unwrap();\n-        self.end_tag();\n-        self.encode_predicates(predicates, item_tag::predicates);\n+    fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics<'tcx>> {\n+        let tcx = self.tcx;\n+        self.lazy(tcx.lookup_generics(def_id))\n     }\n \n-    fn encode_predicates(&mut self,\n-                         predicates: &ty::GenericPredicates<'tcx>,\n-                         tag: usize) {\n-        self.start_tag(tag);\n-        predicates.parent.encode(self).unwrap();\n-        self.seq(&predicates.predicates, |ecx, predicate| {\n-            ecx.encode_with_shorthand(predicate, predicate,\n-                                      |ecx| &mut ecx.predicate_shorthands).unwrap()\n-        });\n-        self.end_tag();\n+    fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+        let tcx = self.tcx;\n+        self.lazy(&tcx.lookup_predicates(def_id))\n     }\n \n-    fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n+    fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n         let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = tcx.map.expect_trait_item(node_id);\n         let trait_item = tcx.impl_or_trait_item(def_id);\n-        let (family, has_default, typed_data) = match trait_item {\n-            ty::ConstTraitItem(ref associated_const) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n \n-                let trait_def_id = trait_item.container().id();\n-                encode_inlined_item(self,\n-                                    InlinedItemRef::TraitItem(trait_def_id, ast_item));\n+        let container = |has_body| if has_body {\n+            AssociatedContainer::TraitWithDefault\n+        } else {\n+            AssociatedContainer::TraitRequired\n+        };\n \n-                (Family::AssociatedConst,\n-                associated_const.has_value,\n-                 EntryTypedData::Other)\n+        let kind = match trait_item {\n+            ty::ConstTraitItem(ref associated_const) => {\n+                EntryKind::AssociatedConst(container(associated_const.has_value))\n             }\n             ty::MethodTraitItem(ref method_ty) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n-\n-                (Family::Method,\n-                 method_ty.has_body,\n-                 EntryTypedData::Method(MethodTypedData {\n-                    explicit_self: method_ty.explicit_self\n-                 }))\n+                let fn_data = if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n+                    FnData {\n+                        constness: hir::Constness::NotConst,\n+                        arg_names: self.encode_fn_arg_names(&sig.decl)\n+                    }\n+                } else {\n+                    bug!()\n+                };\n+                let data = MethodData {\n+                    fn_data: fn_data,\n+                    container: container(method_ty.has_body),\n+                    explicit_self: self.lazy(&method_ty.explicit_self)\n+                };\n+                EntryKind::Method(self.lazy(&data))\n             }\n-            ty::TypeTraitItem(ref associated_type) => {\n-                if let Some(ty) = associated_type.ty {\n-                    self.encode_type(ty);\n-                }\n-\n-                (Family::AssociatedType, false, EntryTypedData::Other)\n+            ty::TypeTraitItem(_) => {\n+                EntryKind::AssociatedType(container(false))\n             }\n         };\n \n-        self.encode_def_key(def_id);\n-        self.encode_family(family);\n-        self.encode_visibility(trait_item.vis());\n-\n-        self.encode_stability(def_id);\n-        self.encode_attributes(&ast_item.attrs);\n-        if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n-            self.encode_fn_arg_names(&sig.decl);\n-        };\n-\n-        self.start_tag(item_tag::data);\n-        EntryData::TraitAssociated(TraitAssociatedData {\n-            has_default: has_default\n-        }).encode(self).unwrap();\n-        self.end_tag();\n-\n-        self.start_tag(item_tag::typed_data);\n-        typed_data.encode(self).unwrap();\n-        self.end_tag();\n+        Entry {\n+            kind: kind,\n+            visibility: trait_item.vis().simplify(),\n+            def_key: self.encode_def_key(def_id),\n+            attributes: self.encode_attributes(&ast_item.attrs),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: match trait_item {\n+                ty::ConstTraitItem(_) |\n+                ty::MethodTraitItem(_) => {\n+                    Some(self.encode_item_type(def_id))\n+                }\n+                ty::TypeTraitItem(ref associated_type) => {\n+                    associated_type.ty.map(|ty| self.lazy(&ty))\n+                }\n+            },\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n \n-        self.encode_mir(def_id);\n+            ast: if let ty::ConstTraitItem(_) = trait_item {\n+                let trait_def_id = trait_item.container().id();\n+                Some(self.encode_inlined_item(InlinedItemRef::TraitItem(trait_def_id, ast_item)))\n+            } else {\n+                None\n+            },\n+            mir: self.encode_mir(def_id)\n+        }\n     }\n \n-    fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n+    fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.map.expect_impl_item(node_id);\n         let impl_item = self.tcx.impl_or_trait_item(def_id);\n         let impl_def_id = impl_item.container().id();\n-        let (family, typed_data) = match impl_item {\n-            ty::ConstTraitItem(_) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n \n-                encode_inlined_item(self,\n-                                    InlinedItemRef::ImplItem(impl_def_id, ast_item));\n-                self.encode_mir(def_id);\n+        let container = match ast_item.defaultness {\n+            hir::Defaultness::Default => AssociatedContainer::ImplDefault,\n+            hir::Defaultness::Final => AssociatedContainer::ImplFinal\n+        };\n \n-                (Family::AssociatedConst, EntryTypedData::Other)\n+        let kind = match impl_item {\n+            ty::ConstTraitItem(_) => {\n+                EntryKind::AssociatedConst(container)\n             }\n-            ty::MethodTraitItem(ref method_type) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n-\n-                (Family::Method,\n-                 EntryTypedData::Method(MethodTypedData {\n-                    explicit_self: method_type.explicit_self\n-                 }))\n+            ty::MethodTraitItem(ref method_ty) => {\n+                let fn_data = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n+                    FnData {\n+                        constness: sig.constness,\n+                        arg_names: self.encode_fn_arg_names(&sig.decl)\n+                    }\n+                } else {\n+                    bug!()\n+                };\n+                let data = MethodData {\n+                    fn_data: fn_data,\n+                    container: container,\n+                    explicit_self: self.lazy(&method_ty.explicit_self)\n+                };\n+                EntryKind::Method(self.lazy(&data))\n             }\n-            ty::TypeTraitItem(ref associated_type) => {\n-                if let Some(ty) = associated_type.ty {\n-                    self.encode_type(ty);\n-                }\n-\n-                (Family::AssociatedType, EntryTypedData::Other)\n+            ty::TypeTraitItem(_) => {\n+                EntryKind::AssociatedType(container)\n             }\n         };\n \n-        self.encode_def_key(def_id);\n-        self.encode_family(family);\n-        self.encode_visibility(impl_item.vis());\n-        self.encode_attributes(&ast_item.attrs);\n-        self.encode_stability(def_id);\n-\n-        let constness = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n-            if sig.constness == hir::Constness::Const {\n-                encode_inlined_item(\n-                    self,\n-                    InlinedItemRef::ImplItem(impl_def_id, ast_item));\n-            }\n-\n+        let (ast, mir) = if let ty::ConstTraitItem(_) = impl_item {\n+            (true, true)\n+        } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n             let generics = self.tcx.lookup_generics(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n             let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n-            if needs_inline || sig.constness == hir::Constness::Const {\n-                self.encode_mir(def_id);\n-            }\n-            self.encode_fn_arg_names(&sig.decl);\n-            sig.constness\n+            let is_const_fn = sig.constness == hir::Constness::Const;\n+            (is_const_fn, needs_inline || is_const_fn)\n         } else {\n-            hir::Constness::NotConst\n+            (false, false)\n         };\n \n-        self.start_tag(item_tag::data);\n-        EntryData::ImplAssociated(ImplAssociatedData {\n-            defaultness: ast_item.defaultness,\n-            constness:constness\n-        }).encode(self).unwrap();\n-        self.end_tag();\n-\n-        self.start_tag(item_tag::typed_data);\n-        typed_data.encode(self).unwrap();\n-        self.end_tag();\n+        Entry {\n+            kind: kind,\n+            visibility: impl_item.vis().simplify(),\n+            def_key: self.encode_def_key(def_id),\n+            attributes: self.encode_attributes(&ast_item.attrs),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: match impl_item {\n+                ty::ConstTraitItem(_) |\n+                ty::MethodTraitItem(_) => {\n+                    Some(self.encode_item_type(def_id))\n+                }\n+                ty::TypeTraitItem(ref associated_type) => {\n+                    associated_type.ty.map(|ty| self.lazy(&ty))\n+                }\n+            },\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+\n+            ast: if ast {\n+                Some(self.encode_inlined_item(InlinedItemRef::ImplItem(impl_def_id, ast_item)))\n+            } else {\n+                None\n+            },\n+            mir: if mir {\n+                self.encode_mir(def_id)\n+            } else {\n+                None\n+            }\n+        }\n     }\n \n-    fn encode_fn_arg_names(&mut self,\n-                                    decl: &hir::FnDecl) {\n-        self.start_tag(item_tag::fn_arg_names);\n-\n-        self.seq(&decl.inputs, |_, arg| {\n+    fn encode_fn_arg_names(&mut self, decl: &hir::FnDecl) -> LazySeq<ast::Name> {\n+        self.lazy_seq(decl.inputs.iter().map(|arg| {\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n                 path1.node\n             } else {\n                 syntax::parse::token::intern(\"\")\n             }\n-        });\n-\n-        self.end_tag();\n+        }))\n     }\n \n-    fn encode_mir(&mut self, def_id: DefId) {\n-        if let Some(mir) = self.mir_map.map.get(&def_id) {\n-            self.start_tag(item_tag::mir as usize);\n-            mir.encode(self);\n-            self.end_tag();\n-        }\n+    fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::repr::Mir<'tcx>>> {\n+        self.mir_map.map.get(&def_id).map(|mir| self.lazy(mir))\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n-    fn encode_inherent_implementations(&mut self, def_id: DefId) {\n-        self.start_tag(item_tag::inherent_impls);\n+    fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n         match self.tcx.inherent_impls.borrow().get(&def_id) {\n-            None => <[DefId]>::encode(&[], self).unwrap(),\n-            Some(implementations) => implementations.encode(self).unwrap()\n+            None => LazySeq::empty(),\n+            Some(implementations) => {\n+                self.lazy_seq(implementations.iter().map(|&def_id| {\n+                    assert!(def_id.is_local());\n+                    def_id.index\n+                }))\n+            }\n         }\n-        self.end_tag();\n     }\n \n-    fn encode_stability(&mut self, def_id: DefId) {\n-        self.tcx.lookup_stability(def_id).map(|stab| {\n-            self.start_tag(item_tag::stability);\n-            stab.encode(self).unwrap();\n-            self.end_tag();\n-        });\n-        self.tcx.lookup_deprecation(def_id).map(|depr| {\n-            self.start_tag(item_tag::deprecation);\n-            depr.encode(self).unwrap();\n-            self.end_tag();\n-        });\n+    fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n+        self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n+    }\n+\n+    fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n+        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n     fn encode_info_for_item(&mut self,\n-                            (def_id, item): (DefId, &hir::Item)) {\n+                            (def_id, item): (DefId, &hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n         debug!(\"encoding info for item at {}\",\n                tcx.sess.codemap().span_to_string(item.span));\n \n-        let (family, data, typed_data) = match item.node {\n-            hir::ItemStatic(_, m, _) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n-\n-                if m == hir::MutMutable {\n-                    (Family::MutStatic, EntryData::Other, EntryTypedData::Other)\n-                } else {\n-                    (Family::ImmStatic, EntryData::Other, EntryTypedData::Other)\n-                }\n-            }\n-            hir::ItemConst(..) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n-                encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(def_id);\n-\n-                (Family::Const, EntryData::Other, EntryTypedData::Other)\n-            }\n-            hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-                let tps_len = generics.ty_params.len();\n-                self.encode_bounds_and_type_for_item(def_id);\n-                let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n-                if constness == hir::Constness::Const {\n-                    encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n-                }\n-                if needs_inline || constness == hir::Constness::Const {\n-                    self.encode_mir(def_id);\n-                }\n-                self.encode_fn_arg_names(&decl);\n+        let kind = match item.node {\n+            hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n+            hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n+            hir::ItemConst(..) => EntryKind::Const,\n+            hir::ItemFn(ref decl, _, constness, ..) => {\n+                let data = FnData {\n+                    constness: constness,\n+                    arg_names: self.encode_fn_arg_names(&decl)\n+                };\n \n-                (Family::Fn, EntryData::Fn(FnData {\n-                    constness: constness\n-                 }), EntryTypedData::Other)\n+                EntryKind::Fn(self.lazy(&data))\n             }\n             hir::ItemMod(ref m) => {\n-                self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, &item.vis)));\n-                return;\n-            }\n-            hir::ItemForeignMod(ref fm) => {\n-                // Encode all the items in self module.\n-                self.start_tag(item_tag::children);\n-                self.seq(&fm.items, |_, foreign_item| {\n-                    tcx.map.local_def_id(foreign_item.id).index\n-                });\n-                self.end_tag();\n-\n-                (Family::ForeignMod, EntryData::Other, EntryTypedData::Other)\n-            }\n-            hir::ItemTy(..) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n-\n-                (Family::Type, EntryData::Other, EntryTypedData::Other)\n-            }\n-            hir::ItemEnum(ref enum_definition, _) => {\n-                self.encode_item_variances(def_id);\n-                self.encode_bounds_and_type_for_item(def_id);\n-\n-                self.start_tag(item_tag::children);\n-                self.seq(&enum_definition.variants, |_, v| {\n-                    tcx.map.local_def_id(v.node.data.id()).index\n-                });\n-                self.end_tag();\n-\n-                // Encode inherent implementations for self enumeration.\n-                self.encode_inherent_implementations(def_id);\n-\n-                (Family::Enum, EntryData::Other, EntryTypedData::Other)\n+                return self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, &item.vis)));\n             }\n+            hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n+            hir::ItemTy(..) => EntryKind::Type,\n+            hir::ItemEnum(..) => EntryKind::Enum,\n             hir::ItemStruct(ref struct_def, _) => {\n-                let def = tcx.lookup_adt_def(def_id);\n-                let variant = def.struct_variant();\n-\n-                self.encode_bounds_and_type_for_item(def_id);\n-\n-                self.encode_item_variances(def_id);\n+                let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n                 /* Encode def_ids for each field and method\n                 for methods, write all the stuff get_trait_method\n@@ -665,38 +628,32 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     None\n                 };\n-                let data = self.encode_variant(variant, struct_ctor);\n-\n-                // Encode inherent implementations for self structure.\n-                self.encode_inherent_implementations(def_id);\n-\n-                (Family::Struct, data, EntryTypedData::Other)\n+                EntryKind::Struct(self.lazy(&VariantData {\n+                    kind: variant.kind,\n+                    disr: variant.disr_val.to_u64_unchecked(),\n+                    struct_ctor: struct_ctor\n+                }))\n             }\n             hir::ItemUnion(..) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n+                let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n-                self.encode_item_variances(def_id);\n-\n-                /* Encode def_ids for each field and method\n-                for methods, write all the stuff get_trait_method\n-                needs to know*/\n-                let def = self.tcx.lookup_adt_def(def_id);\n-                let data = self.encode_variant(def.struct_variant(), None);\n-\n-                // Encode inherent implementations for self union.\n-                self.encode_inherent_implementations(def_id);\n-\n-                (Family::Union, data, EntryTypedData::Other)\n+                EntryKind::Union(self.lazy(&VariantData {\n+                    kind: variant.kind,\n+                    disr: variant.disr_val.to_u64_unchecked(),\n+                    struct_ctor: None\n+                }))\n             }\n             hir::ItemDefaultImpl(..) => {\n-                (Family::DefaultImpl, EntryData::Other,\n-                 EntryTypedData::Impl(ImplTypedData {\n-                    trait_ref: tcx.impl_trait_ref(def_id)\n-                 }))\n+                let data = ImplData {\n+                    polarity: hir::ImplPolarity::Positive,\n+                    parent_impl: None,\n+                    coerce_unsized_kind: None,\n+                    trait_ref: tcx.impl_trait_ref(def_id).map(|trait_ref| self.lazy(&trait_ref))\n+                };\n+\n+                EntryKind::DefaultImpl(self.lazy(&data))\n             }\n             hir::ItemImpl(_, polarity, ..) => {\n-                self.encode_bounds_and_type_for_item(def_id);\n-\n                 let trait_ref = tcx.impl_trait_ref(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n@@ -710,71 +667,146 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     None\n                 };\n \n-                self.start_tag(item_tag::children);\n-                self.seq(&tcx.impl_or_trait_items(def_id)[..], |_, &def_id| {\n-                    assert!(def_id.is_local());\n-                    def_id.index\n-                });\n-                self.end_tag();\n-\n-                (Family::Impl,\n-                 EntryData::Impl(ImplData {\n+                let data = ImplData {\n                     polarity: polarity,\n                     parent_impl: parent,\n                     coerce_unsized_kind: tcx.custom_coerce_unsized_kinds.borrow()\n-                                            .get(&def_id).cloned()\n-                 }),\n-                 EntryTypedData::Impl(ImplTypedData {\n-                    trait_ref: trait_ref\n-                 }))\n+                                            .get(&def_id).cloned(),\n+                    trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref))\n+                };\n+\n+                EntryKind::Impl(self.lazy(&data))\n             }\n             hir::ItemTrait(..) => {\n-                self.encode_item_variances(def_id);\n                 let trait_def = tcx.lookup_trait_def(def_id);\n-                let trait_predicates = tcx.lookup_predicates(def_id);\n-\n-                self.encode_generics(&trait_def.generics, &trait_predicates);\n-                self.encode_predicates(&tcx.lookup_super_predicates(def_id),\n-                                       item_tag::super_predicates);\n-\n-                self.start_tag(item_tag::children);\n-                self.seq(&tcx.impl_or_trait_items(def_id)[..], |_, &def_id| {\n-                    assert!(def_id.is_local());\n-                    def_id.index\n-                });\n-                self.end_tag();\n-\n-                // Encode inherent implementations for self trait.\n-                self.encode_inherent_implementations(def_id);\n-\n-                (Family::Trait,\n-                 EntryData::Trait(TraitData {\n+                let data = TraitData {\n                     unsafety: trait_def.unsafety,\n                     paren_sugar: trait_def.paren_sugar,\n-                    has_default_impl: tcx.trait_has_default_impl(def_id)\n-                 }),\n-                 EntryTypedData::Trait(TraitTypedData {\n-                    trait_ref: trait_def.trait_ref\n-                 }))\n+                    has_default_impl: tcx.trait_has_default_impl(def_id),\n+                    trait_ref: self.lazy(&trait_def.trait_ref),\n+                    super_predicates: self.lazy(&tcx.lookup_super_predicates(def_id))\n+                };\n+\n+                EntryKind::Trait(self.lazy(&data))\n             }\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n                 bug!(\"cannot encode info for item {:?}\", item)\n             }\n         };\n \n-        self.encode_family(family);\n-        self.encode_def_key(def_id);\n-        self.encode_visibility(&item.vis);\n-        self.encode_attributes(&item.attrs);\n-        self.encode_stability(def_id);\n-\n-        self.start_tag(item_tag::data);\n-        data.encode(self).unwrap();\n-        self.end_tag();\n+        Entry {\n+            kind: kind,\n+            visibility: item.vis.simplify(),\n+            def_key: self.encode_def_key(def_id),\n+            attributes: self.encode_attributes(&item.attrs),\n+            children: match item.node {\n+                hir::ItemForeignMod(ref fm) => {\n+                    self.lazy_seq(fm.items.iter().map(|foreign_item| {\n+                        tcx.map.local_def_id(foreign_item.id).index\n+                    }))\n+                }\n+                hir::ItemEnum(..) => {\n+                    let def = self.tcx.lookup_adt_def(def_id);\n+                    self.lazy_seq(def.variants.iter().map(|v| {\n+                        assert!(v.did.is_local());\n+                        v.did.index\n+                    }))\n+                }\n+                hir::ItemStruct(..) |\n+                hir::ItemUnion(..) => {\n+                    let def = self.tcx.lookup_adt_def(def_id);\n+                    self.lazy_seq(def.struct_variant().fields.iter().map(|f| {\n+                        assert!(f.did.is_local());\n+                        f.did.index\n+                    }))\n+                }\n+                hir::ItemImpl(..) |\n+                hir::ItemTrait(..) => {\n+                    self.lazy_seq(tcx.impl_or_trait_items(def_id).iter().map(|&def_id| {\n+                        assert!(def_id.is_local());\n+                        def_id.index\n+                    }))\n+                }\n+                _ => LazySeq::empty()\n+            },\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: match item.node {\n+                hir::ItemStatic(..) |\n+                hir::ItemConst(..) |\n+                hir::ItemFn(..) |\n+                hir::ItemTy(..) |\n+                hir::ItemEnum(..) |\n+                hir::ItemStruct(..) |\n+                hir::ItemUnion(..) |\n+                hir::ItemImpl(..) => {\n+                    Some(self.encode_item_type(def_id))\n+                }\n+                _ => None\n+            },\n+            inherent_impls: self.encode_inherent_implementations(def_id),\n+            variances: match item.node {\n+                hir::ItemEnum(..) |\n+                hir::ItemStruct(..) |\n+                hir::ItemUnion(..) |\n+                hir::ItemTrait(..) => {\n+                    self.encode_item_variances(def_id)\n+                }\n+                _ => LazySeq::empty()\n+            },\n+            generics: match item.node {\n+                hir::ItemStatic(..) |\n+                hir::ItemConst(..) |\n+                hir::ItemFn(..) |\n+                hir::ItemTy(..) |\n+                hir::ItemEnum(..) |\n+                hir::ItemStruct(..) |\n+                hir::ItemUnion(..) |\n+                hir::ItemImpl(..) |\n+                hir::ItemTrait(..) => {\n+                    Some(self.encode_generics(def_id))\n+                }\n+                _ => None\n+            },\n+            predicates: match item.node {\n+                hir::ItemStatic(..) |\n+                hir::ItemConst(..) |\n+                hir::ItemFn(..) |\n+                hir::ItemTy(..) |\n+                hir::ItemEnum(..) |\n+                hir::ItemStruct(..) |\n+                hir::ItemUnion(..) |\n+                hir::ItemImpl(..) |\n+                hir::ItemTrait(..) => {\n+                    Some(self.encode_predicates(def_id))\n+                }\n+                _ => None\n+            },\n \n-        self.start_tag(item_tag::typed_data);\n-        typed_data.encode(self).unwrap();\n-        self.end_tag();\n+            ast: match item.node {\n+                hir::ItemConst(..) |\n+                hir::ItemFn(_, _, hir::Constness::Const, ..) => {\n+                    Some(self.encode_inlined_item(InlinedItemRef::Item(def_id, item)))\n+                }\n+                _ => None\n+            },\n+            mir: match item.node {\n+                hir::ItemConst(..) => {\n+                    self.encode_mir(def_id)\n+                }\n+                hir::ItemFn(_, _, constness, _, ref generics, _) => {\n+                    let tps_len = generics.ty_params.len();\n+                    let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n+                    if needs_inline || constness == hir::Constness::Const {\n+                        self.encode_mir(def_id)\n+                    } else {\n+                        None\n+                    }\n+                }\n+                _ => None\n+            }\n+        }\n     }\n }\n \n@@ -822,7 +854,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                         let ctor_def_id = self.tcx.map.local_def_id(struct_def.id());\n                         self.record(ctor_def_id,\n                                     EncodeContext::encode_struct_ctor,\n-                                    ctor_def_id);\n+                                    (def_id, ctor_def_id));\n                     }\n                 }\n             }\n@@ -849,35 +881,42 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_foreign_item(&mut self,\n-                                    (def_id, nitem): (DefId, &hir::ForeignItem)) {\n+                                    (def_id, nitem): (DefId, &hir::ForeignItem))\n+                                    -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n         debug!(\"writing foreign item {}\", tcx.node_path_str(nitem.id));\n \n-        self.encode_def_key(def_id);\n-        self.encode_visibility(&nitem.vis);\n-        self.encode_bounds_and_type_for_item(def_id);\n-        let family = match nitem.node {\n+        let kind = match nitem.node {\n             hir::ForeignItemFn(ref fndecl, _) => {\n-                self.encode_fn_arg_names(&fndecl);\n-\n-                Family::ForeignFn\n+                let data = FnData {\n+                    constness: hir::Constness::NotConst,\n+                    arg_names: self.encode_fn_arg_names(&fndecl)\n+                };\n+                EntryKind::ForeignFn(self.lazy(&data))\n             }\n-            hir::ForeignItemStatic(_, true) => Family::ForeignMutStatic,\n-            hir::ForeignItemStatic(_, false) => Family::ForeignImmStatic\n+            hir::ForeignItemStatic(_, true) => EntryKind::ForeignMutStatic,\n+            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic\n         };\n-        self.encode_family(family);\n-\n-        self.start_tag(item_tag::data);\n-        EntryData::Other.encode(self).unwrap();\n-        self.end_tag();\n \n-        self.start_tag(item_tag::typed_data);\n-        EntryTypedData::Other.encode(self).unwrap();\n-        self.end_tag();\n-\n-        self.encode_attributes(&nitem.attrs);\n-        self.encode_stability(def_id);\n+        Entry {\n+            kind: kind,\n+            visibility: nitem.vis.simplify(),\n+            def_key: self.encode_def_key(def_id),\n+            attributes: self.encode_attributes(&nitem.attrs),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+\n+            ast: None,\n+            mir: None\n+        }\n     }\n }\n \n@@ -938,68 +977,73 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_info_for_anon_ty(&mut self, def_id: DefId) {\n-        self.encode_def_key(def_id);\n-        self.encode_bounds_and_type_for_item(def_id);\n+    fn encode_info_for_anon_ty(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        Entry {\n+            kind: EntryKind::Type,\n+            visibility: ty::Visibility::Public,\n+            def_key: self.encode_def_key(def_id),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+\n+            ast: None,\n+            mir: None\n+        }\n     }\n \n-    fn encode_info_for_closure(&mut self, def_id: DefId) {\n+    fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        self.encode_def_key(def_id);\n-        self.encode_family(Family::Closure);\n-\n-        self.start_tag(item_tag::data);\n-        EntryData::Closure(ClosureData {\n-            kind: tcx.closure_kind(def_id)\n-        }).encode(self).unwrap();\n-        self.end_tag();\n-\n-        self.start_tag(item_tag::typed_data);\n-        EntryTypedData::Closure(ClosureTypedData {\n-            ty: tcx.tables.borrow().closure_tys[&def_id].clone()\n-        }).encode(self).unwrap();\n-        self.end_tag();\n-\n-        assert!(self.mir_map.map.contains_key(&def_id));\n-        self.encode_mir(def_id);\n-    }\n \n-    fn encode_info_for_items(&mut self) -> IndexData {\n-        let krate = self.tcx.map.krate();\n-\n-        // FIXME(eddyb) Avoid wrapping the items in a doc.\n-        self.start_tag(0).unwrap();\n-\n-        let items = {\n-            let mut index = IndexBuilder::new(self);\n-            index.record(DefId::local(CRATE_DEF_INDEX),\n-                        EncodeContext::encode_info_for_mod,\n-                        FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n-            let mut visitor = EncodeVisitor {\n-                index: index,\n-            };\n-            krate.visit_all_items(&mut visitor);\n-            visitor.index.into_items()\n+        let data = ClosureData {\n+            kind: tcx.closure_kind(def_id),\n+            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id])\n         };\n \n-        self.end_tag();\n-\n-        items\n+        Entry {\n+            kind: EntryKind::Closure(self.lazy(&data)),\n+            visibility: ty::Visibility::Public,\n+            def_key: self.encode_def_key(def_id),\n+            attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n+\n+            ty: None,\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: None,\n+            predicates: None,\n+\n+            ast: None,\n+            mir: self.encode_mir(def_id)\n+        }\n     }\n \n-    fn encode_item_index(&mut self, index: IndexData) {\n-        self.start_tag(root_tag::index);\n-        index.write_index(&mut self.opaque.cursor);\n-        self.end_tag();\n+    fn encode_info_for_items(&mut self) -> Index {\n+        let krate = self.tcx.map.krate();\n+        let mut index = IndexBuilder::new(self);\n+        index.record(DefId::local(CRATE_DEF_INDEX),\n+                     EncodeContext::encode_info_for_mod,\n+                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n+        let mut visitor = EncodeVisitor {\n+            index: index,\n+        };\n+        krate.visit_all_items(&mut visitor);\n+        visitor.index.into_items()\n     }\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) {\n-        self.start_tag(item_tag::attributes);\n-        attrs.encode(self).unwrap();\n-        self.end_tag();\n+    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n+        self.lazy_seq_ref(attrs)\n     }\n \n-    fn encode_crate_deps(&mut self) {\n+    fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n         fn get_ordered_deps(cstore: &cstore::CStore)\n                             -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n             // Pull the cnums and name,vers,hash out of cstore\n@@ -1025,96 +1069,71 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        self.start_tag(root_tag::crate_deps);\n         let deps = get_ordered_deps(self.cstore);\n-        self.seq(&deps, |_, &(_, ref dep)| {\n-            (dep.name(), dep.hash(), dep.explicitly_linked.get())\n-        });\n-        self.end_tag();\n+        self.lazy_seq(deps.iter().map(|&(_, ref dep)| {\n+            CrateDep {\n+                name: syntax::parse::token::intern(dep.name()),\n+                hash: dep.hash(),\n+                explicitly_linked: dep.explicitly_linked.get()\n+            }\n+        }))\n     }\n \n-    fn encode_lang_items(&mut self) {\n+    fn encode_lang_items(&mut self)\n+                         -> (LazySeq<(DefIndex, usize)>, LazySeq<lang_items::LangItem>) {\n         let tcx = self.tcx;\n-        let lang_items = || {\n-            tcx.lang_items.items().iter().enumerate().filter_map(|(i, &opt_def_id)| {\n-                if let Some(def_id) = opt_def_id {\n-                    if def_id.is_local() {\n-                        return Some((def_id.index, i));\n-                    }\n+        let lang_items = tcx.lang_items.items().iter();\n+        (self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n+            if let Some(def_id) = opt_def_id {\n+                if def_id.is_local() {\n+                    return Some((def_id.index, i));\n                 }\n-                None\n-            })\n-        };\n-\n-        let count = lang_items().count();\n-        let mut lang_items = lang_items();\n-\n-        self.start_tag(root_tag::lang_items);\n-        self.seq(0..count, |_, _| lang_items.next().unwrap());\n-        self.end_tag();\n-\n-        self.start_tag(root_tag::lang_items_missing);\n-        tcx.lang_items.missing.encode(self).unwrap();\n-        self.end_tag();\n+            }\n+            None\n+        })), self.lazy_seq_ref(&tcx.lang_items.missing))\n     }\n \n-    fn encode_native_libraries(&mut self) {\n+    fn encode_native_libraries(&mut self) -> LazySeq<(NativeLibraryKind, String)> {\n         let used_libraries = self.tcx.sess.cstore.used_libraries();\n-        let libs = || {\n-            used_libraries.iter().filter_map(|&(ref lib, kind)| {\n-                match kind {\n-                    cstore::NativeStatic => None, // these libraries are not propagated\n-                    cstore::NativeFramework | cstore::NativeUnknown => {\n-                        Some((kind, lib))\n-                    }\n+        self.lazy_seq(used_libraries.into_iter().filter_map(|(lib, kind)| {\n+            match kind {\n+                cstore::NativeStatic => None, // these libraries are not propagated\n+                cstore::NativeFramework | cstore::NativeUnknown => {\n+                    Some((kind, lib))\n                 }\n-            })\n-        };\n-\n-        let count = libs().count();\n-        let mut libs = libs();\n-\n-        self.start_tag(root_tag::native_libraries);\n-        self.seq(0..count, |_, _| libs.next().unwrap());\n-        self.end_tag();\n+            }\n+        }))\n     }\n \n-    fn encode_codemap(&mut self) {\n+    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n         let codemap = self.tcx.sess.codemap();\n         let all_filemaps = codemap.files.borrow();\n-        let filemaps = || {\n+        self.lazy_seq_ref(all_filemaps.iter().filter(|filemap| {\n             // No need to export empty filemaps, as they can't contain spans\n             // that need translation.\n             // Also no need to re-export imported filemaps, as any downstream\n             // crate will import them from their original source.\n-            all_filemaps.iter().filter(|filemap| {\n-                !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n-            })\n-        };\n-\n-        let count = filemaps().count();\n-        let mut filemaps = filemaps();\n-\n-        self.start_tag(root_tag::codemap);\n-        self.seq(0..count, |_, _| filemaps.next().unwrap());\n-        self.end_tag();\n+            !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n+        }).map(|filemap| &**filemap))\n     }\n \n     /// Serialize the text of the exported macros\n-    fn encode_macro_defs(&mut self) {\n+    fn encode_macro_defs(&mut self) -> LazySeq<MacroDef> {\n         let tcx = self.tcx;\n-        self.start_tag(root_tag::macro_defs);\n-        self.seq(&tcx.map.krate().exported_macros, |_, def| {\n-            let body = ::syntax::print::pprust::tts_to_string(&def.body);\n-            (def.name, &def.attrs, def.span, body)\n-        });\n-        self.end_tag();\n+        self.lazy_seq(tcx.map.krate().exported_macros.iter().map(|def| {\n+            MacroDef {\n+                name: def.name,\n+                attrs: def.attrs.to_vec(),\n+                span: def.span,\n+                body: ::syntax::print::pprust::tts_to_string(&def.body)\n+            }\n+        }))\n     }\n }\n \n struct ImplVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impls: FnvHashMap<DefId, Vec<DefId>>\n+    impls: FnvHashMap<DefId, Vec<DefIndex>>\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n@@ -1124,30 +1143,29 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls.entry(trait_ref.def_id)\n                     .or_insert(vec![])\n-                    .push(impl_id);\n+                    .push(impl_id.index);\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self) {\n+    fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n         let mut visitor = ImplVisitor {\n             tcx: self.tcx,\n             impls: FnvHashMap()\n         };\n         self.tcx.map.krate().visit_all_items(&mut visitor);\n \n-        self.start_tag(root_tag::impls);\n-        for (trait_def_id, trait_impls) in visitor.impls {\n-            // FIXME(eddyb) Avoid wrapping the entries in docs.\n-            self.start_tag(0);\n-            (trait_def_id.krate.as_u32(), trait_def_id.index).encode(self).unwrap();\n-            trait_impls.encode(self).unwrap();\n-            self.end_tag();\n-        }\n-        self.end_tag();\n+        let all_impls: Vec<_> = visitor.impls.into_iter().map(|(trait_def_id, impls)| {\n+            TraitImpls {\n+                trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n+                impls: self.lazy_seq(impls)\n+            }\n+        }).collect();\n+\n+        self.lazy_seq(all_impls)\n     }\n \n     // Encodes all reachable symbols in this crate into the metadata.\n@@ -1156,51 +1174,171 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     // middle::reachable module but filters out items that either don't have a\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n-    fn encode_reachable(&mut self) {\n-        self.start_tag(root_tag::reachable_ids);\n-\n+    fn encode_reachable(&mut self) -> LazySeq<DefIndex> {\n         let reachable = self.reachable;\n-        self.seq(reachable, |ecx, &id| ecx.tcx.map.local_def_id(id).index);\n-\n-        self.end_tag();\n+        let tcx = self.tcx;\n+        self.lazy_seq(reachable.iter().map(|&id| tcx.map.local_def_id(id).index))\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self) {\n-        self.start_tag(root_tag::dylib_dependency_formats);\n+    fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n         match self.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n             Some(arr) => {\n-                self.seq(arr, |_, slot| {\n+                self.lazy_seq(arr.iter().map(|slot| {\n                     match *slot {\n                         Linkage::NotLinked |\n                         Linkage::IncludedFromDylib => None,\n \n                         Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n                         Linkage::Static => Some(LinkagePreference::RequireStatic),\n                     }\n-                });\n+                }))\n             }\n-            None => {\n-                <[Option<LinkagePreference>]>::encode(&[], self).unwrap();\n+            None => LazySeq::empty()\n+        }\n+    }\n+\n+    fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n+        let mut i = self.position();\n+        let crate_deps = self.encode_crate_deps();\n+        let dylib_dependency_formats = self.encode_dylib_dependency_formats();\n+        let dep_bytes = self.position() - i;\n+\n+        // Encode the language items.\n+        i = self.position();\n+        let (lang_items, lang_items_missing) = self.encode_lang_items();\n+        let lang_item_bytes = self.position() - i;\n+\n+        // Encode the native libraries used\n+        i = self.position();\n+        let native_libraries = self.encode_native_libraries();\n+        let native_lib_bytes = self.position() - i;\n+\n+        // Encode codemap\n+        i = self.position();\n+        let codemap = self.encode_codemap();\n+        let codemap_bytes = self.position() - i;\n+\n+        // Encode macro definitions\n+        i = self.position();\n+        let macro_defs = self.encode_macro_defs();\n+        let macro_defs_bytes = self.position() - i;\n+\n+        // Encode the def IDs of impls, for coherence checking.\n+        i = self.position();\n+        let impls = self.encode_impls();\n+        let impl_bytes = self.position() - i;\n+\n+        // Encode reachability info.\n+        i = self.position();\n+        let reachable_ids = self.encode_reachable();\n+        let reachable_bytes = self.position() - i;\n+\n+        // Encode and index the items.\n+        i = self.position();\n+        let items = self.encode_info_for_items();\n+        let item_bytes = self.position() - i;\n+\n+        i = self.position();\n+        let index = items.write_index(&mut self.opaque.cursor);\n+        let index_bytes = self.position() - i;\n+\n+        let tcx = self.tcx;\n+        let link_meta = self.link_meta;\n+        let is_rustc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeRustcMacro);\n+        let root = self.lazy(&CrateRoot {\n+            rustc_version: RUSTC_VERSION.to_string(),\n+            name: link_meta.crate_name.clone(),\n+            triple: tcx.sess.opts.target_triple.clone(),\n+            hash: link_meta.crate_hash,\n+            disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n+            panic_strategy: tcx.sess.opts.cg.panic.clone(),\n+            plugin_registrar_fn: tcx.sess.plugin_registrar_fn.get().map(|id| {\n+                tcx.map.local_def_id(id).index\n+            }),\n+            macro_derive_registrar: if is_rustc_macro {\n+                let id = tcx.sess.derive_registrar_fn.get().unwrap();\n+                Some(tcx.map.local_def_id(id).index)\n+            } else {\n+                None\n+            },\n+\n+            index: index,\n+            crate_deps: crate_deps,\n+            dylib_dependency_formats: dylib_dependency_formats,\n+            native_libraries: native_libraries,\n+            lang_items: lang_items,\n+            lang_items_missing: lang_items_missing,\n+            impls: impls,\n+            reachable_ids: reachable_ids,\n+            macro_defs: macro_defs,\n+            codemap: codemap\n+        });\n+\n+        let total_bytes = self.position();\n+\n+        if self.tcx.sess.meta_stats() {\n+            let mut zero_bytes = 0;\n+            for e in self.opaque.cursor.get_ref() {\n+                if *e == 0 {\n+                    zero_bytes += 1;\n+                }\n             }\n+\n+            println!(\"metadata stats:\");\n+            println!(\"             dep bytes: {}\", dep_bytes);\n+            println!(\"       lang item bytes: {}\", lang_item_bytes);\n+            println!(\"          native bytes: {}\", native_lib_bytes);\n+            println!(\"         codemap bytes: {}\", codemap_bytes);\n+            println!(\"       macro def bytes: {}\", macro_defs_bytes);\n+            println!(\"            impl bytes: {}\", impl_bytes);\n+            println!(\"       reachable bytes: {}\", reachable_bytes);\n+            println!(\"            item bytes: {}\", item_bytes);\n+            println!(\"           index bytes: {}\", index_bytes);\n+            println!(\"            zero bytes: {}\", zero_bytes);\n+            println!(\"           total bytes: {}\", total_bytes);\n         }\n-        self.end_tag();\n+\n+        root\n     }\n }\n \n+// NOTE(eddyb) The following comment was preserved for posterity, even\n+// though it's no longer relevant as EBML (which uses nested & tagged\n+// \"documents\") was replaced with a scheme that can't go out of bounds.\n+//\n+// And here we run into yet another obscure archive bug: in which metadata\n+// loaded from archives may have trailing garbage bytes. Awhile back one of\n+// our tests was failing sporadically on the OSX 64-bit builders (both nopt\n+// and opt) by having ebml generate an out-of-bounds panic when looking at\n+// metadata.\n+//\n+// Upon investigation it turned out that the metadata file inside of an rlib\n+// (and ar archive) was being corrupted. Some compilations would generate a\n+// metadata file which would end in a few extra bytes, while other\n+// compilations would not have these extra bytes appended to the end. These\n+// extra bytes were interpreted by ebml as an extra tag, so they ended up\n+// being interpreted causing the out-of-bounds.\n+//\n+// The root cause of why these extra bytes were appearing was never\n+// discovered, and in the meantime the solution we're employing is to insert\n+// the length of the metadata to the start of the metadata. Later on this\n+// will allow us to slice the metadata to the precise length that we just\n+// generated regardless of trailing bytes that end up in it.\n+\n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  cstore: &cstore::CStore,\n                                  reexports: &def::ExportMap,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet,\n                                  mir_map: &MirMap<'tcx>) -> Vec<u8> {\n     let mut cursor = Cursor::new(vec![]);\n-    cursor.write_all(&[0, 0, 0, 0]).unwrap();\n-    cursor.write_all(metadata_encoding_version).unwrap();\n-    // Will be filed with the length after encoding the crate.\n+    cursor.write_all(METADATA_HEADER).unwrap();\n+\n+    // Will be filed with the root position after encoding everything.\n     cursor.write_all(&[0, 0, 0, 0]).unwrap();\n \n-    encode_metadata_inner(&mut EncodeContext {\n-        rbml_w: rbml::writer::Encoder::new(&mut cursor),\n+    let root = EncodeContext {\n+        opaque: opaque::Encoder::new(&mut cursor),\n         tcx: tcx,\n         reexports: reexports,\n         link_meta: link_meta,\n@@ -1209,138 +1347,16 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         mir_map: mir_map,\n         type_shorthands: Default::default(),\n         predicate_shorthands: Default::default()\n-    });\n-\n-    // RBML compacts the encoded bytes whenever appropriate,\n-    // so there are some garbages left after the end of the data.\n-    let meta_len = cursor.position() as usize;\n-    cursor.get_mut().truncate(meta_len);\n-\n-    // And here we run into yet another obscure archive bug: in which metadata\n-    // loaded from archives may have trailing garbage bytes. Awhile back one of\n-    // our tests was failing sporadically on the OSX 64-bit builders (both nopt\n-    // and opt) by having rbml generate an out-of-bounds panic when looking at\n-    // metadata.\n-    //\n-    // Upon investigation it turned out that the metadata file inside of an rlib\n-    // (and ar archive) was being corrupted. Some compilations would generate a\n-    // metadata file which would end in a few extra bytes, while other\n-    // compilations would not have these extra bytes appended to the end. These\n-    // extra bytes were interpreted by rbml as an extra tag, so they ended up\n-    // being interpreted causing the out-of-bounds.\n-    //\n-    // The root cause of why these extra bytes were appearing was never\n-    // discovered, and in the meantime the solution we're employing is to insert\n-    // the length of the metadata to the start of the metadata. Later on this\n-    // will allow us to slice the metadata to the precise length that we just\n-    // generated regardless of trailing bytes that end up in it.\n-    //\n-    // We also need to store the metadata encoding version here, because\n-    // rlibs don't have it. To get older versions of rustc to ignore\n-    // this metadata, there are 4 zero bytes at the start, which are\n-    // treated as a length of 0 by old compilers.\n-\n-    let meta_start = 8 + ::common::metadata_encoding_version.len();\n-    let len = meta_len - meta_start;\n+    }.encode_crate_root();\n     let mut result = cursor.into_inner();\n-    result[meta_start - 4] = (len >> 24) as u8;\n-    result[meta_start - 3] = (len >> 16) as u8;\n-    result[meta_start - 2] = (len >>  8) as u8;\n-    result[meta_start - 1] = (len >>  0) as u8;\n-    result\n-}\n \n-fn encode_metadata_inner(ecx: &mut EncodeContext) {\n-    ecx.wr_tagged_str(root_tag::rustc_version, &rustc_version());\n-\n-    let tcx = ecx.tcx;\n-    let link_meta = ecx.link_meta;\n-\n-    ecx.start_tag(root_tag::crate_info);\n-    let is_rustc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeRustcMacro);\n-    CrateInfo {\n-        name: link_meta.crate_name.clone(),\n-        triple: tcx.sess.opts.target_triple.clone(),\n-        hash: link_meta.crate_hash,\n-        disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n-        panic_strategy: tcx.sess.opts.cg.panic.clone(),\n-        plugin_registrar_fn: tcx.sess.plugin_registrar_fn.get().map(|id| {\n-            tcx.map.local_def_id(id).index\n-        }),\n-        macro_derive_registrar: if is_rustc_macro {\n-            let id = tcx.sess.derive_registrar_fn.get().unwrap();\n-            Some(tcx.map.local_def_id(id).index)\n-        } else {\n-            None\n-        }\n-    }.encode(ecx).unwrap();\n-    ecx.end_tag();\n-\n-    let mut i = ecx.position();\n-    ecx.encode_crate_deps();\n-    ecx.encode_dylib_dependency_formats();\n-    let dep_bytes = ecx.position() - i;\n-\n-    // Encode the language items.\n-    i = ecx.position();\n-    ecx.encode_lang_items();\n-    let lang_item_bytes = ecx.position() - i;\n-\n-    // Encode the native libraries used\n-    i = ecx.position();\n-    ecx.encode_native_libraries();\n-    let native_lib_bytes = ecx.position() - i;\n-\n-    // Encode codemap\n-    i = ecx.position();\n-    ecx.encode_codemap();\n-    let codemap_bytes = ecx.position() - i;\n-\n-    // Encode macro definitions\n-    i = ecx.position();\n-    ecx.encode_macro_defs();\n-    let macro_defs_bytes = ecx.position() - i;\n-\n-    // Encode the def IDs of impls, for coherence checking.\n-    i = ecx.position();\n-    ecx.encode_impls();\n-    let impl_bytes = ecx.position() - i;\n-\n-    // Encode reachability info.\n-    i = ecx.position();\n-    ecx.encode_reachable();\n-    let reachable_bytes = ecx.position() - i;\n-\n-    // Encode and index the items.\n-    i = ecx.position();\n-    let items = ecx.encode_info_for_items();\n-    let item_bytes = ecx.position() - i;\n-\n-    i = ecx.position();\n-    ecx.encode_item_index(items);\n-    let index_bytes = ecx.position() - i;\n-\n-    let total_bytes = ecx.position();\n-\n-    if ecx.tcx.sess.meta_stats() {\n-        let mut zero_bytes = 0;\n-        for e in ecx.opaque.cursor.get_ref() {\n-            if *e == 0 {\n-                zero_bytes += 1;\n-            }\n-        }\n+    // Encode the root position.\n+    let header = METADATA_HEADER.len();\n+    let pos = root.position;\n+    result[header + 0] = (pos >> 24) as u8;\n+    result[header + 1] = (pos >> 16) as u8;\n+    result[header + 2] = (pos >>  8) as u8;\n+    result[header + 3] = (pos >>  0) as u8;\n \n-        println!(\"metadata stats:\");\n-        println!(\"             dep bytes: {}\", dep_bytes);\n-        println!(\"       lang item bytes: {}\", lang_item_bytes);\n-        println!(\"          native bytes: {}\", native_lib_bytes);\n-        println!(\"         codemap bytes: {}\", codemap_bytes);\n-        println!(\"       macro def bytes: {}\", macro_defs_bytes);\n-        println!(\"            impl bytes: {}\", impl_bytes);\n-        println!(\"       reachable bytes: {}\", reachable_bytes);\n-        println!(\"            item bytes: {}\", item_bytes);\n-        println!(\"           index bytes: {}\", index_bytes);\n-        println!(\"            zero bytes: {}\", zero_bytes);\n-        println!(\"           total bytes: {}\", total_bytes);\n-    }\n+    result\n }"}, {"sha": "ef83251f51e8d18ed725b411528bc3b5f0516493", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 51, "deletions": 67, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -8,93 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use schema::*;\n+\n use rustc::hir::def_id::{DefId, DefIndex};\n-use rbml;\n use std::io::{Cursor, Write};\n use std::slice;\n use std::u32;\n \n-/// As part of the metadata, we generate an index that stores, for\n-/// each DefIndex, the position of the corresponding RBML document (if\n-/// any).  This is just a big `[u32]` slice, where an entry of\n-/// `u32::MAX` indicates that there is no RBML document. This little\n-/// struct just stores the offsets within the metadata of the start\n-/// and end of this slice. These are actually part of an RBML\n-/// document, but for looking things up in the metadata, we just\n-/// discard the RBML positioning and jump directly to the data.\n-pub struct Index {\n-    data_start: usize,\n-    data_end: usize,\n-}\n-\n-impl Index {\n-    /// Given the RBML doc representing the index, save the offests\n-    /// for later.\n-    pub fn from_rbml(index: rbml::Doc) -> Index {\n-        Index { data_start: index.start, data_end: index.end }\n-    }\n-\n-    /// Given the metadata, extract out the offset of a particular\n-    /// DefIndex (if any).\n-    #[inline(never)]\n-    pub fn lookup_item(&self, bytes: &[u8], def_index: DefIndex) -> Option<u32> {\n-        let words = bytes_to_words(&bytes[self.data_start..self.data_end]);\n-        let index = def_index.as_usize();\n-\n-        debug!(\"lookup_item: index={:?} words.len={:?}\",\n-               index, words.len());\n-\n-        let position = u32::from_le(words[index]);\n-        if position == u32::MAX {\n-            debug!(\"lookup_item: position=u32::MAX\");\n-            None\n-        } else {\n-            debug!(\"lookup_item: position={:?}\", position);\n-            Some(position)\n-        }\n-    }\n-\n-    pub fn iter_enumerated<'a>(&self, bytes: &'a [u8])\n-                               -> impl Iterator<Item=(DefIndex, u32)> + 'a {\n-        let words = bytes_to_words(&bytes[self.data_start..self.data_end]);\n-        words.iter().enumerate().filter_map(|(index, &position)| {\n-            if position == u32::MAX {\n-                None\n-            } else {\n-                Some((DefIndex::new(index), u32::from_le(position)))\n-            }\n-        })\n-    }\n-}\n-\n /// While we are generating the metadata, we also track the position\n /// of each DefIndex. It is not required that all definitions appear\n /// in the metadata, nor that they are serialized in order, and\n /// therefore we first allocate the vector here and fill it with\n /// `u32::MAX`. Whenever an index is visited, we fill in the\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n-pub struct IndexData {\n+pub struct Index {\n     positions: Vec<u32>,\n }\n \n-impl IndexData {\n-    pub fn new(max_index: usize) -> IndexData {\n-        IndexData {\n+impl Index {\n+    pub fn new(max_index: usize) -> Index {\n+        Index {\n             positions: vec![u32::MAX; max_index]\n         }\n     }\n \n-    pub fn record(&mut self, def_id: DefId, position: usize) {\n+    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry>) {\n         assert!(def_id.is_local());\n-        self.record_index(def_id.index, position);\n+        self.record_index(def_id.index, entry);\n     }\n \n-    pub fn record_index(&mut self, item: DefIndex, position: usize) {\n+    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry>) {\n         let item = item.as_usize();\n \n-        assert!(position < (u32::MAX as usize));\n-        let position = position as u32;\n+        assert!(entry.position < (u32::MAX as usize));\n+        let position = entry.position as u32;\n \n         assert!(self.positions[item] == u32::MAX,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n@@ -103,16 +51,52 @@ impl IndexData {\n         self.positions[item] = position.to_le();\n     }\n \n-    pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) {\n+    pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) -> LazySeq<Index> {\n+        let pos = buf.position();\n         buf.write_all(words_to_bytes(&self.positions)).unwrap();\n+        LazySeq::with_position_and_length(pos as usize, self.positions.len())\n+    }\n+}\n+\n+impl<'tcx> LazySeq<Index> {\n+    /// Given the metadata, extract out the offset of a particular\n+    /// DefIndex (if any).\n+    #[inline(never)]\n+    pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n+        let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n+        let index = def_index.as_usize();\n+\n+        debug!(\"Index::lookup: index={:?} words.len={:?}\",\n+               index, words.len());\n+\n+        let position = u32::from_le(words[index]);\n+        if position == u32::MAX {\n+            debug!(\"Index::lookup: position=u32::MAX\");\n+            None\n+        } else {\n+            debug!(\"Index::lookup: position={:?}\", position);\n+            Some(Lazy::with_position(position as usize))\n+        }\n+    }\n+\n+    pub fn iter_enumerated<'a>(&self, bytes: &'a [u8])\n+                               -> impl Iterator<Item=(DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n+        let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n+        words.iter().enumerate().filter_map(|(index, &position)| {\n+            if position == u32::MAX {\n+                None\n+            } else {\n+                let position = u32::from_le(position) as usize;\n+                Some((DefIndex::new(index), Lazy::with_position(position)))\n+            }\n+        })\n     }\n }\n \n fn bytes_to_words(b: &[u8]) -> &[u32] {\n-    assert!(b.len() % 4 == 0);\n-    unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len()/4) }\n+    unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len() / 4) }\n }\n \n fn words_to_bytes(w: &[u32]) -> &[u8] {\n-    unsafe { slice::from_raw_parts(w.as_ptr() as *const u8, w.len()*4) }\n+    unsafe { slice::from_raw_parts(w.as_ptr() as *const u8, w.len() * 4) }\n }"}, {"sha": "aeb6f63252c6efde1076d36680c82b6f0564d455", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -56,7 +56,9 @@\n //! easily control precisely what data is given to that fn.\n \n use encoder::EncodeContext;\n-use index::IndexData;\n+use index::Index;\n+use schema::*;\n+\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -68,7 +70,7 @@ use std::ops::{Deref, DerefMut};\n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n-    items: IndexData,\n+    items: Index,\n     pub ecx: &'a mut EncodeContext<'b, 'tcx>,\n }\n \n@@ -88,16 +90,16 @@ impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n-            items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n+            items: Index::new(ecx.tcx.map.num_local_def_ids()),\n             ecx: ecx,\n         }\n     }\n \n     /// Emit the data for a def-id to the metadata. The function to\n     /// emit the data is `op`, and it will be given `data` as\n-    /// arguments. This `record` function will start/end an RBML tag\n-    /// and record the current offset for use in the index, calling\n-    /// `op` to generate the data in the RBML tag.\n+    /// arguments. This `record` function will call `op` to generate\n+    /// the `Entry` (which may point to other encoded information)\n+    /// and will then record the `Lazy<Entry>` for use in the index.\n     ///\n     /// In addition, it will setup a dep-graph task to track what data\n     /// `op` accesses to generate the metadata, which is later used by\n@@ -112,21 +114,17 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// content system.\n     pub fn record<DATA>(&mut self,\n                         id: DefId,\n-                        op: fn(&mut EncodeContext<'b, 'tcx>, DATA),\n+                        op: fn(&mut EncodeContext<'b, 'tcx>, DATA) -> Entry<'tcx>,\n                         data: DATA)\n         where DATA: DepGraphRead\n     {\n-        let position = self.ecx.mark_stable_position();\n-        self.items.record(id, position);\n         let _task = self.tcx.dep_graph.in_task(DepNode::MetaData(id));\n-        // FIXME(eddyb) Avoid wrapping the entries in docs.\n-        self.ecx.start_tag(0).unwrap();\n         data.read(self.tcx);\n-        op(&mut self.ecx, data);\n-        self.ecx.end_tag().unwrap();\n+        let entry = op(&mut self.ecx, data);\n+        self.items.record(id, self.ecx.lazy(&entry));\n     }\n \n-    pub fn into_items(self) -> IndexData {\n+    pub fn into_items(self) -> Index {\n         self.items\n     }\n }"}, {"sha": "4fc5a46762d1215136d9e4291537c2a30c250e12", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -29,11 +29,9 @@\n #![feature(rustc_private)]\n #![feature(specialization)]\n #![feature(staged_api)]\n-#![cfg_attr(test, feature(test))]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n-#[macro_use] #[no_link] extern crate rustc_bitflags;\n extern crate syntax_pos;\n extern crate flate;\n extern crate serialize as rustc_serialize; // used by deriving\n@@ -48,24 +46,15 @@ extern crate rustc_llvm;\n extern crate rustc_macro;\n extern crate rustc_const_math;\n \n-#[cfg(test)]\n-extern crate test;\n-\n-mod rbml {\n-    pub mod writer;\n-    pub mod reader;\n-    pub use self::reader::Doc;\n-}\n-\n mod diagnostics;\n \n mod astencode;\n-mod common;\n mod index_builder;\n mod index;\n mod encoder;\n mod decoder;\n mod csearch;\n+mod schema;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "fc94cec916aad146be7f830c77cc64040aa7912b", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -212,8 +212,8 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::loader or metadata::creader for all the juicy details!\n \n-use cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n-use common::{metadata_encoding_version, rustc_version};\n+use cstore::MetadataBlob;\n+use schema::{METADATA_HEADER, RUSTC_VERSION};\n \n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n@@ -382,7 +382,7 @@ impl<'a> Context<'a> {\n         }\n         if !self.rejected_via_version.is_empty() {\n             err.help(&format!(\"please recompile that crate using this compiler ({})\",\n-                              rustc_version()));\n+                              RUSTC_VERSION));\n             let mismatches = self.rejected_via_version.iter();\n             for (i, &CrateMismatch { ref path, ref got }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}` path #{}: {} compiled by {:?}\",\n@@ -510,8 +510,7 @@ impl<'a> Context<'a> {\n                     if let Some((ref p, _)) = lib.rlib {\n                         err.note(&format!(\"path: {}\", p.display()));\n                     }\n-                    let crate_info = lib.metadata.get_crate_info();\n-                    note_crate_name(&mut err, &crate_info.name);\n+                    note_crate_name(&mut err, &lib.metadata.get_root().name);\n                 }\n                 err.emit();\n                 None\n@@ -597,38 +596,37 @@ impl<'a> Context<'a> {\n     }\n \n     fn crate_matches(&mut self, metadata: &MetadataBlob, libpath: &Path) -> Option<Svh> {\n-        let crate_rustc_version = metadata.crate_rustc_version();\n-        if crate_rustc_version != Some(rustc_version()) {\n-            let message = crate_rustc_version.unwrap_or(format!(\"an unknown compiler\"));\n-            info!(\"Rejecting via version: expected {} got {}\", rustc_version(), message);\n+        let root = metadata.get_root();\n+        if root.rustc_version != RUSTC_VERSION {\n+            info!(\"Rejecting via version: expected {} got {}\",\n+                  RUSTC_VERSION, root.rustc_version);\n             self.rejected_via_version.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: message\n+                got: root.rustc_version\n             });\n             return None;\n         }\n \n-        let crate_info = metadata.get_crate_info();\n         if self.should_match_name {\n-            if self.crate_name != crate_info.name {\n+            if self.crate_name != root.name {\n                 info!(\"Rejecting via crate name\"); return None;\n             }\n         }\n \n-        if crate_info.triple != self.triple {\n+        if root.triple != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\",\n-                  self.triple, crate_info.triple);\n+                  self.triple, root.triple);\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: crate_info.triple\n+                got: root.triple\n             });\n             return None;\n         }\n \n         if let Some(myhash) = self.hash {\n-            if *myhash != crate_info.hash {\n+            if *myhash != root.hash {\n                 info!(\"Rejecting via hash: expected {} got {}\",\n-                      *myhash, crate_info.hash);\n+                      *myhash, root.hash);\n                 self.rejected_via_hash.push(CrateMismatch {\n                     path: libpath.to_path_buf(),\n                     got: myhash.to_string()\n@@ -637,7 +635,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n-        Some(crate_info.hash)\n+        Some(root.hash)\n     }\n \n \n@@ -758,11 +756,7 @@ impl ArchiveMetadata {\n fn verify_decompressed_encoding_version(blob: &MetadataBlob, filename: &Path)\n                                         -> Result<(), String>\n {\n-    let data = blob.as_slice_raw();\n-    if data.len() < 4+metadata_encoding_version.len() ||\n-        !<[u8]>::eq(&data[..4], &[0, 0, 0, 0]) ||\n-        &data[4..4+metadata_encoding_version.len()] != metadata_encoding_version\n-    {\n+    if !blob.is_compatible() {\n         Err((format!(\"incompatible metadata version found: '{}'\",\n                      filename.display())))\n     } else {\n@@ -797,7 +791,7 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                                    filename.display()));\n             }\n         };\n-        return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n+        return match ArchiveMetadata::new(archive).map(|ar| MetadataBlob::Archive(ar)) {\n             None => Err(format!(\"failed to read rlib metadata: '{}'\",\n                                 filename.display())),\n             Some(blob) => {\n@@ -832,12 +826,12 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n-                let vlen = metadata_encoding_version.len();\n+                let vlen = METADATA_HEADER.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let buf0 = slice::from_raw_parts(cvbuf, minsz);\n-                let version_ok = buf0 == metadata_encoding_version;\n+                let version_ok = buf0 == METADATA_HEADER;\n                 if !version_ok {\n                     return Err((format!(\"incompatible metadata version found: '{}'\",\n                                         filename.display())));\n@@ -849,7 +843,7 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n                     Ok(inflated) => {\n-                        let blob = MetadataVec(inflated);\n+                        let blob = MetadataBlob::Inflated(inflated);\n                         verify_decompressed_encoding_version(&blob, filename)?;\n                         return Ok(blob);\n                     }"}, {"sha": "c4cfc32d63306140ca3d918e7eef2f4f511fa101", "filename": "src/librustc_metadata/rbml/reader.rs", "status": "removed", "additions": 0, "deletions": 411, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/24aef24e1aa732115c1a98feb06510de372fcf0c/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aef24e1aa732115c1a98feb06510de372fcf0c/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Freader.rs?ref=24aef24e1aa732115c1a98feb06510de372fcf0c", "patch": "@@ -1,411 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Really Bad Markup Language (rbml) is an internal serialization format of rustc.\n-//! This is not intended to be used by users.\n-//!\n-//! Originally based on the Extensible Binary Markup Language\n-//! (ebml; http://www.matroska.org/technical/specs/rfc/index.html),\n-//! it is now a separate format tuned for the rust object metadata.\n-//!\n-//! # Encoding\n-//!\n-//! RBML document consists of the tag, length and data.\n-//! The encoded data can contain multiple RBML documents concatenated.\n-//!\n-//! **Tags** are a hint for the following data.\n-//! Tags are a number from 0x000 to 0xfff, where 0xf0 through 0xff is reserved.\n-//! Tags less than 0xf0 are encoded in one literal byte.\n-//! Tags greater than 0xff are encoded in two big-endian bytes,\n-//! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n-//!\n-//! **Lengths** encode the length of the following data.\n-//! It is a variable-length unsigned isize, and one of the following forms:\n-//!\n-//! - `80` through `fe` for lengths up to 0x7e;\n-//! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n-//! - `20 40 00` through `3f ff ff` for lengths up to 0x1fffff;\n-//! - `10 20 00 00` through `1f ff ff ff` for lengths up to 0xfffffff.\n-//!\n-//! The \"overlong\" form is allowed so that the length can be encoded\n-//! without the prior knowledge of the encoded data.\n-//! For example, the length 0 can be represented either by `80`, `40 00`,\n-//! `20 00 00` or `10 00 00 00`.\n-//! The encoder tries to minimize the length if possible.\n-//! Also, some predefined tags listed below are so commonly used that\n-//! their lengths are omitted (\"implicit length\").\n-//!\n-//! **Data** can be either binary bytes or zero or more nested RBML documents.\n-//! Nested documents cannot overflow, and should be entirely contained\n-//! within a parent document.\n-\n-#[cfg(test)]\n-use test::Bencher;\n-\n-use std::fmt;\n-use std::str;\n-\n-macro_rules! try_or {\n-    ($e:expr, $r:expr) => (\n-        match $e {\n-            Ok(x) => x,\n-            Err(_) => return $r\n-        }\n-    )\n-}\n-\n-#[derive(Clone, Copy)]\n-pub struct Doc<'a> {\n-    pub data: &'a [u8],\n-    pub start: usize,\n-    pub end: usize,\n-}\n-\n-impl<'doc> Doc<'doc> {\n-    pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n-        Doc {\n-            data: data,\n-            start: 0,\n-            end: data.len(),\n-        }\n-    }\n-\n-    pub fn at(data: &'doc [u8], start: usize) -> Doc<'doc> {\n-        let elt_tag = tag_at(data, start).unwrap();\n-        let elt_size = tag_len_at(data, elt_tag.next).unwrap();\n-        let end = elt_size.next + elt_size.val;\n-        Doc {\n-            data: data,\n-            start: elt_size.next,\n-            end: end,\n-        }\n-    }\n-\n-    pub fn maybe_child(&self, tag: usize) -> Option<Doc<'doc>> {\n-        let mut pos = self.start;\n-        while pos < self.end {\n-            let elt_tag = try_or!(tag_at(self.data, pos), None);\n-            let elt_size = try_or!(tag_len_at(self.data, elt_tag.next), None);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tag {\n-                return Some(Doc {\n-                    data: self.data,\n-                    start: elt_size.next,\n-                    end: pos,\n-                });\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn child(&self, tag: usize) -> Doc<'doc> {\n-        match self.maybe_child(tag) {\n-            Some(d) => d,\n-            None => {\n-                bug!(\"failed to find child with tag {:?}\", tag);\n-            }\n-        }\n-    }\n-\n-    pub fn children_of(&self, tag: usize) -> DocsIterator<'doc> {\n-        DocsIterator { d: self.child(tag) }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub enum Error {\n-    IntTooBig(usize),\n-    InvalidTag(usize)\n-}\n-\n-impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME: this should be a more useful display form\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Res {\n-    val: usize,\n-    next: usize,\n-}\n-\n-fn tag_at(data: &[u8], start: usize) -> Result<Res, Error> {\n-    let v = data[start] as usize;\n-    if v < 0xf0 {\n-        Ok(Res {\n-            val: v,\n-            next: start + 1,\n-        })\n-    } else if v > 0xf0 {\n-        Ok(Res {\n-            val: ((v & 0xf) << 8) | data[start + 1] as usize,\n-            next: start + 2,\n-        })\n-    } else {\n-        // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n-        Err(Error::InvalidTag(v))\n-    }\n-}\n-\n-#[inline(never)]\n-fn vuint_at_slow(data: &[u8], start: usize) -> Result<Res, Error> {\n-    let a = data[start];\n-    if a & 0x80 != 0 {\n-        return Ok(Res {\n-            val: (a & 0x7f) as usize,\n-            next: start + 1,\n-        });\n-    }\n-    if a & 0x40 != 0 {\n-        return Ok(Res {\n-            val: ((a & 0x3f) as usize) << 8 | (data[start + 1] as usize),\n-            next: start + 2,\n-        });\n-    }\n-    if a & 0x20 != 0 {\n-        return Ok(Res {\n-            val: ((a & 0x1f) as usize) << 16 | (data[start + 1] as usize) << 8 |\n-                 (data[start + 2] as usize),\n-            next: start + 3,\n-        });\n-    }\n-    if a & 0x10 != 0 {\n-        return Ok(Res {\n-            val: ((a & 0x0f) as usize) << 24 | (data[start + 1] as usize) << 16 |\n-                 (data[start + 2] as usize) << 8 |\n-                 (data[start + 3] as usize),\n-            next: start + 4,\n-        });\n-    }\n-    Err(Error::IntTooBig(a as usize))\n-}\n-\n-fn vuint_at(data: &[u8], start: usize) -> Result<Res, Error> {\n-    if data.len() - start < 4 {\n-        return vuint_at_slow(data, start);\n-    }\n-\n-    // Lookup table for parsing EBML Element IDs as per\n-    // http://ebml.sourceforge.net/specs/ The Element IDs are parsed by\n-    // reading a big endian u32 positioned at data[start].  Using the four\n-    // most significant bits of the u32 we lookup in the table below how\n-    // the element ID should be derived from it.\n-    //\n-    // The table stores tuples (shift, mask) where shift is the number the\n-    // u32 should be right shifted with and mask is the value the right\n-    // shifted value should be masked with.  If for example the most\n-    // significant bit is set this means it's a class A ID and the u32\n-    // should be right shifted with 24 and masked with 0x7f. Therefore we\n-    // store (24, 0x7f) at index 0x8 - 0xF (four bit numbers where the most\n-    // significant bit is set).\n-    //\n-    // By storing the number of shifts and masks in a table instead of\n-    // checking in order if the most significant bit is set, the second\n-    // most significant bit is set etc. we can replace up to three\n-    // \"and+branch\" with a single table lookup which gives us a measured\n-    // speedup of around 2x on x86_64.\n-    static SHIFT_MASK_TABLE: [(usize, u32); 16] = [(0, 0x0),\n-                                                   (0, 0x0fffffff),\n-                                                   (8, 0x1fffff),\n-                                                   (8, 0x1fffff),\n-                                                   (16, 0x3fff),\n-                                                   (16, 0x3fff),\n-                                                   (16, 0x3fff),\n-                                                   (16, 0x3fff),\n-                                                   (24, 0x7f),\n-                                                   (24, 0x7f),\n-                                                   (24, 0x7f),\n-                                                   (24, 0x7f),\n-                                                   (24, 0x7f),\n-                                                   (24, 0x7f),\n-                                                   (24, 0x7f),\n-                                                   (24, 0x7f)];\n-\n-    unsafe {\n-        let ptr = data.as_ptr().offset(start as isize) as *const u32;\n-        let val = u32::from_be(*ptr);\n-\n-        let i = (val >> 28) as usize;\n-        let (shift, mask) = SHIFT_MASK_TABLE[i];\n-        Ok(Res {\n-            val: ((val >> shift) & mask) as usize,\n-            next: start + ((32 - shift) >> 3),\n-        })\n-    }\n-}\n-\n-fn tag_len_at(data: &[u8], next: usize) -> Result<Res, Error> {\n-    vuint_at(data, next)\n-}\n-\n-pub struct DocsIterator<'a> {\n-    d: Doc<'a>,\n-}\n-\n-impl<'a> Iterator for DocsIterator<'a> {\n-    type Item = Doc<'a>;\n-\n-    fn next(&mut self) -> Option<Doc<'a>> {\n-        if self.d.start >= self.d.end {\n-            return None;\n-        }\n-\n-        let elt_tag = try_or!(tag_at(self.d.data, self.d.start), {\n-            self.d.start = self.d.end;\n-            None\n-        });\n-        let elt_size = try_or!(tag_len_at(self.d.data, elt_tag.next), {\n-            self.d.start = self.d.end;\n-            None\n-        });\n-\n-        let end = elt_size.next + elt_size.val;\n-        let doc = Doc {\n-            data: self.d.data,\n-            start: elt_size.next,\n-            end: end,\n-        };\n-\n-        self.d.start = end;\n-        return Some(doc);\n-    }\n-}\n-\n-#[test]\n-fn test_vuint_at() {\n-    let data = &[\n-        0x80,\n-        0xff,\n-        0x40, 0x00,\n-        0x7f, 0xff,\n-        0x20, 0x00, 0x00,\n-        0x3f, 0xff, 0xff,\n-        0x10, 0x00, 0x00, 0x00,\n-        0x1f, 0xff, 0xff, 0xff\n-    ];\n-\n-    let mut res: Res;\n-\n-    // Class A\n-    res = vuint_at(data, 0).unwrap();\n-    assert_eq!(res.val, 0);\n-    assert_eq!(res.next, 1);\n-    res = vuint_at(data, res.next).unwrap();\n-    assert_eq!(res.val, (1 << 7) - 1);\n-    assert_eq!(res.next, 2);\n-\n-    // Class B\n-    res = vuint_at(data, res.next).unwrap();\n-    assert_eq!(res.val, 0);\n-    assert_eq!(res.next, 4);\n-    res = vuint_at(data, res.next).unwrap();\n-    assert_eq!(res.val, (1 << 14) - 1);\n-    assert_eq!(res.next, 6);\n-\n-    // Class C\n-    res = vuint_at(data, res.next).unwrap();\n-    assert_eq!(res.val, 0);\n-    assert_eq!(res.next, 9);\n-    res = vuint_at(data, res.next).unwrap();\n-    assert_eq!(res.val, (1 << 21) - 1);\n-    assert_eq!(res.next, 12);\n-\n-    // Class D\n-    res = vuint_at(data, res.next).unwrap();\n-    assert_eq!(res.val, 0);\n-    assert_eq!(res.next, 16);\n-    res = vuint_at(data, res.next).unwrap();\n-    assert_eq!(res.val, (1 << 28) - 1);\n-    assert_eq!(res.next, 20);\n-}\n-\n-#[bench]\n-pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-    let data = (0..4 * 100)\n-                   .map(|i| {\n-                       match i % 2 {\n-                           0 => 0x80,\n-                           _ => i as u8,\n-                       }\n-                   })\n-                   .collect::<Vec<_>>();\n-    let mut sum = 0;\n-    b.iter(|| {\n-        let mut i = 0;\n-        while i < data.len() {\n-            sum += vuint_at(&data, i).unwrap().val;\n-            i += 4;\n-        }\n-    });\n-}\n-\n-#[bench]\n-pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-    let data = (0..4 * 100 + 1)\n-                   .map(|i| {\n-                       match i % 2 {\n-                           1 => 0x80,\n-                           _ => i as u8,\n-                       }\n-                   })\n-                   .collect::<Vec<_>>();\n-    let mut sum = 0;\n-    b.iter(|| {\n-        let mut i = 1;\n-        while i < data.len() {\n-            sum += vuint_at(&data, i).unwrap().val;\n-            i += 4;\n-        }\n-    });\n-}\n-\n-#[bench]\n-pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-    let data = (0..4 * 100)\n-                   .map(|i| {\n-                       match i % 4 {\n-                           0 => 0x10,\n-                           3 => i as u8,\n-                           _ => 0,\n-                       }\n-                   })\n-                   .collect::<Vec<_>>();\n-    let mut sum = 0;\n-    b.iter(|| {\n-        let mut i = 0;\n-        while i < data.len() {\n-            sum += vuint_at(&data, i).unwrap().val;\n-            i += 4;\n-        }\n-    });\n-}\n-\n-#[bench]\n-pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-    let data = (0..4 * 100 + 1)\n-                   .map(|i| {\n-                       match i % 4 {\n-                           1 => 0x10,\n-                           0 => i as u8,\n-                           _ => 0,\n-                       }\n-                   })\n-                   .collect::<Vec<_>>();\n-    let mut sum = 0;\n-    b.iter(|| {\n-        let mut i = 1;\n-        while i < data.len() {\n-            sum += vuint_at(&data, i).unwrap().val;\n-            i += 4;\n-        }\n-    });\n-}"}, {"sha": "46b63cb134031ac413b396dd6d7f7f44bb8d4a5e", "filename": "src/librustc_metadata/rbml/writer.rs", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/24aef24e1aa732115c1a98feb06510de372fcf0c/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24aef24e1aa732115c1a98feb06510de372fcf0c/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs?ref=24aef24e1aa732115c1a98feb06510de372fcf0c", "patch": "@@ -1,134 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io::prelude::*;\n-use std::io::{self, SeekFrom, Cursor};\n-\n-use rustc_serialize::opaque;\n-\n-pub type EncodeResult = io::Result<()>;\n-\n-// rbml writing\n-pub struct Encoder<'a> {\n-    pub opaque: opaque::Encoder<'a>,\n-    size_positions: Vec<usize>,\n-    relax_limit: usize, // do not move encoded bytes before this position\n-}\n-\n-const NUM_TAGS: usize = 0x1000;\n-\n-fn write_tag<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-    if n < 0xf0 {\n-        w.write_all(&[n as u8])\n-    } else if 0x100 <= n && n < NUM_TAGS {\n-        w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n-    } else {\n-        Err(io::Error::new(io::ErrorKind::Other, &format!(\"invalid tag: {}\", n)[..]))\n-    }\n-}\n-\n-fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n-    match size {\n-        1 => w.write_all(&[0x80 | (n as u8)]),\n-        2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n-        3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8, n as u8]),\n-        4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8, (n >> 8) as u8, n as u8]),\n-        _ => Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..])),\n-    }\n-}\n-\n-pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-    if n < 0x7f {\n-        return write_sized_vuint(w, n, 1);\n-    }\n-    if n < 0x4000 {\n-        return write_sized_vuint(w, n, 2);\n-    }\n-    if n < 0x200000 {\n-        return write_sized_vuint(w, n, 3);\n-    }\n-    if n < 0x10000000 {\n-        return write_sized_vuint(w, n, 4);\n-    }\n-    Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n-}\n-\n-impl<'a> Encoder<'a> {\n-    pub fn new(cursor: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n-        Encoder {\n-            opaque: opaque::Encoder::new(cursor),\n-            size_positions: vec![],\n-            relax_limit: 0,\n-        }\n-    }\n-\n-    pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n-        debug!(\"Start tag {:?}\", tag_id);\n-\n-        // Write the enum ID:\n-        write_tag(&mut self.opaque.cursor, tag_id)?;\n-\n-        // Write a placeholder four-byte size.\n-        let cur_pos = self.position();\n-        self.size_positions.push(cur_pos);\n-        self.opaque.cursor.write_all(&[0, 0, 0, 0])\n-    }\n-\n-    pub fn end_tag(&mut self) -> EncodeResult {\n-        let last_size_pos = self.size_positions.pop().unwrap();\n-        let cur_pos = self.position();\n-        self.opaque.cursor.seek(SeekFrom::Start(last_size_pos as u64))?;\n-        let size = cur_pos - last_size_pos - 4;\n-\n-        // relax the size encoding for small tags (bigger tags are costly to move).\n-        // we should never try to move the stable positions, however.\n-        const RELAX_MAX_SIZE: usize = 0x100;\n-        if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n-            // we can't alter the buffer in place, so have a temporary buffer\n-            let mut buf = [0u8; RELAX_MAX_SIZE];\n-            {\n-                let data = &self.opaque.cursor.get_ref()[last_size_pos + 4..cur_pos];\n-                buf[..size].copy_from_slice(data);\n-            }\n-\n-            // overwrite the size and data and continue\n-            write_vuint(&mut self.opaque.cursor, size)?;\n-            self.opaque.cursor.write_all(&buf[..size])?;\n-        } else {\n-            // overwrite the size with an overlong encoding and skip past the data\n-            write_sized_vuint(&mut self.opaque.cursor, size, 4)?;\n-            self.opaque.cursor.seek(SeekFrom::Start(cur_pos as u64))?;\n-        }\n-\n-        debug!(\"End tag (size = {:?})\", size);\n-        Ok(())\n-    }\n-\n-    pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n-        write_tag(&mut self.opaque.cursor, tag_id)?;\n-        write_vuint(&mut self.opaque.cursor, v.len())?;\n-        self.opaque.cursor.write_all(v.as_bytes())\n-    }\n-\n-    pub fn position(&mut self) -> usize {\n-        self.opaque.position() as usize\n-    }\n-\n-    /// Returns the current position while marking it stable, i.e.\n-    /// generated bytes so far wouldn't be affected by relaxation.\n-    pub fn mark_stable_position(&mut self) -> usize {\n-        let pos = self.position();\n-        if self.relax_limit < pos {\n-            self.relax_limit = pos;\n-        }\n-        let meta_start = 8 + ::common::metadata_encoding_version.len();\n-        pos - meta_start\n-    }\n-}"}, {"sha": "b4ea2b19bf08adf22082b556834f20506c4b565b", "filename": "src/librustc_metadata/schema.rs", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -0,0 +1,299 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use astencode;\n+use index;\n+\n+use rustc::hir;\n+use rustc::hir::def;\n+use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::middle::cstore::{LinkagePreference, NativeLibraryKind};\n+use rustc::middle::lang_items;\n+use rustc::mir;\n+use rustc::ty::{self, Ty};\n+use rustc::session::config::PanicStrategy;\n+\n+use rustc_serialize as serialize;\n+use syntax::{ast, attr};\n+use syntax_pos::{self, Span};\n+\n+use std::marker::PhantomData;\n+\n+pub const RUSTC_VERSION: &'static str = concat!(\"rustc \", env!(\"CFG_VERSION\"));\n+\n+/// Metadata encoding version.\n+/// NB: increment this if you change the format of metadata such that\n+/// the rustc version can't be found to compare with `RUSTC_VERSION`.\n+pub const METADATA_VERSION: u8 = 3;\n+\n+/// Metadata header which includes `METADATA_VERSION`.\n+/// To get older versions of rustc to ignore this metadata,\n+/// there are 4 zero bytes at the start, which are treated\n+/// as a length of 0 by old compilers.\n+///\n+/// This header is followed by the position of the `CrateRoot`.\n+pub const METADATA_HEADER: &'static [u8; 12] = &[\n+    0, 0, 0, 0,\n+    b'r', b'u', b's', b't',\n+    0, 0, 0, METADATA_VERSION\n+];\n+\n+/// The shorthand encoding uses an enum's variant index `usize`\n+/// and is offset by this value so it never matches a real variant.\n+/// This offset is also chosen so that the first byte is never < 0x80.\n+pub const SHORTHAND_OFFSET: usize = 0x80;\n+\n+/// A value of type T referred to by its absolute position\n+/// in the metadata, and which can be decoded lazily.\n+#[must_use]\n+pub struct Lazy<T> {\n+    pub position: usize,\n+    _marker: PhantomData<T>\n+}\n+\n+impl<T> Lazy<T> {\n+    pub fn with_position(position: usize) -> Lazy<T> {\n+        Lazy {\n+            position: position,\n+            _marker: PhantomData\n+        }\n+    }\n+}\n+\n+impl<T> Copy for Lazy<T> {}\n+impl<T> Clone for Lazy<T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+impl<T> serialize::UseSpecializedEncodable for Lazy<T> {}\n+impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n+\n+/// A sequence of type T referred to by its absolute position\n+/// in the metadata and length, and which can be decoded lazily.\n+///\n+/// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n+/// position, not at the position, which means that the length\n+/// doesn't need to be known before encoding all the elements.\n+#[must_use]\n+pub struct LazySeq<T> {\n+    pub len: usize,\n+    pub position: usize,\n+    _marker: PhantomData<T>\n+}\n+\n+impl<T> LazySeq<T> {\n+    pub fn empty() -> LazySeq<T> {\n+        LazySeq::with_position_and_length(0, 0)\n+    }\n+\n+    pub fn with_position_and_length(position: usize, len: usize) -> LazySeq<T> {\n+        LazySeq {\n+            len: len,\n+            position: position,\n+            _marker: PhantomData\n+        }\n+    }\n+}\n+\n+impl<T> Copy for LazySeq<T> {}\n+impl<T> Clone for LazySeq<T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n+impl<T> serialize::UseSpecializedDecodable for LazySeq<T> {}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct CrateRoot {\n+    pub rustc_version: String,\n+    pub name: String,\n+    pub triple: String,\n+    pub hash: hir::svh::Svh,\n+    pub disambiguator: String,\n+    pub panic_strategy: PanicStrategy,\n+    pub plugin_registrar_fn: Option<DefIndex>,\n+    pub macro_derive_registrar: Option<DefIndex>,\n+\n+    pub index: LazySeq<index::Index>,\n+    pub crate_deps: LazySeq<CrateDep>,\n+    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n+    pub native_libraries: LazySeq<(NativeLibraryKind, String)>,\n+    pub lang_items: LazySeq<(DefIndex, usize)>,\n+    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n+    pub impls: LazySeq<TraitImpls>,\n+    pub reachable_ids: LazySeq<DefIndex>,\n+    pub macro_defs: LazySeq<MacroDef>,\n+    pub codemap: LazySeq<syntax_pos::FileMap>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct CrateDep {\n+    pub name: ast::Name,\n+    pub hash: hir::svh::Svh,\n+    pub explicitly_linked: bool\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct TraitImpls {\n+    pub trait_id: (u32, DefIndex),\n+    pub impls: LazySeq<DefIndex>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct MacroDef {\n+    pub name: ast::Name,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub span: Span,\n+    pub body: String\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Entry<'tcx> {\n+    pub kind: EntryKind<'tcx>,\n+    pub visibility: ty::Visibility,\n+    pub def_key: Lazy<hir::map::DefKey>,\n+    pub attributes: LazySeq<ast::Attribute>,\n+    pub children: LazySeq<DefIndex>,\n+    pub stability: Option<Lazy<attr::Stability>>,\n+    pub deprecation: Option<Lazy<attr::Deprecation>>,\n+\n+    pub ty: Option<Lazy<Ty<'tcx>>>,\n+    pub inherent_impls: LazySeq<DefIndex>,\n+    pub variances: LazySeq<ty::Variance>,\n+    pub generics: Option<Lazy<ty::Generics<'tcx>>>,\n+    pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n+\n+    pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n+    pub mir: Option<Lazy<mir::repr::Mir<'tcx>>>\n+}\n+\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub enum EntryKind<'tcx> {\n+    Const,\n+    ImmStatic,\n+    MutStatic,\n+    ForeignImmStatic,\n+    ForeignMutStatic,\n+    ForeignMod,\n+    Type,\n+    Enum,\n+    Field,\n+    Variant(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>),\n+    Union(Lazy<VariantData>),\n+    Fn(Lazy<FnData>),\n+    ForeignFn(Lazy<FnData>),\n+    Mod(Lazy<ModData>),\n+    Closure(Lazy<ClosureData<'tcx>>),\n+    Trait(Lazy<TraitData<'tcx>>),\n+    Impl(Lazy<ImplData<'tcx>>),\n+    DefaultImpl(Lazy<ImplData<'tcx>>),\n+    Method(Lazy<MethodData<'tcx>>),\n+    AssociatedType(AssociatedContainer),\n+    AssociatedConst(AssociatedContainer)\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ModData {\n+    pub reexports: LazySeq<def::Export>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct FnData {\n+    pub constness: hir::Constness,\n+    pub arg_names: LazySeq<ast::Name>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct VariantData {\n+    pub kind: ty::VariantKind,\n+    pub disr: u64,\n+\n+    /// If this is a struct's only variant, this\n+    /// is the index of the \"struct ctor\" item.\n+    pub struct_ctor: Option<DefIndex>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct TraitData<'tcx> {\n+    pub unsafety: hir::Unsafety,\n+    pub paren_sugar: bool,\n+    pub has_default_impl: bool,\n+    pub trait_ref: Lazy<ty::TraitRef<'tcx>>,\n+    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ImplData<'tcx> {\n+    pub polarity: hir::ImplPolarity,\n+    pub parent_impl: Option<DefId>,\n+    pub coerce_unsized_kind: Option<ty::adjustment::CustomCoerceUnsized>,\n+    pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>\n+}\n+\n+/// Describes whether the container of an associated item\n+/// is a trait or an impl and whether, in a trait, it has\n+/// a default, or an in impl, whether it's marked \"default\".\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub enum AssociatedContainer {\n+    TraitRequired,\n+    TraitWithDefault,\n+    ImplDefault,\n+    ImplFinal\n+}\n+\n+impl AssociatedContainer {\n+    pub fn with_def_id(&self, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n+        match *self {\n+            AssociatedContainer::TraitRequired |\n+            AssociatedContainer::TraitWithDefault => {\n+                ty::TraitContainer(def_id)\n+            }\n+\n+            AssociatedContainer::ImplDefault |\n+            AssociatedContainer::ImplFinal => {\n+                ty::ImplContainer(def_id)\n+            }\n+        }\n+    }\n+\n+    pub fn has_body(&self) -> bool {\n+        match *self {\n+            AssociatedContainer::TraitRequired => false,\n+\n+            AssociatedContainer::TraitWithDefault |\n+            AssociatedContainer::ImplDefault |\n+            AssociatedContainer::ImplFinal => true\n+        }\n+    }\n+\n+    pub fn defaultness(&self) -> hir::Defaultness {\n+        match *self {\n+            AssociatedContainer::TraitRequired |\n+            AssociatedContainer::TraitWithDefault |\n+            AssociatedContainer::ImplDefault => hir::Defaultness::Default,\n+\n+            AssociatedContainer::ImplFinal => hir::Defaultness::Final\n+        }\n+    }\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct MethodData<'tcx> {\n+    pub fn_data: FnData,\n+    pub container: AssociatedContainer,\n+    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ClosureData<'tcx> {\n+    pub kind: ty::ClosureKind,\n+    pub ty: Lazy<ty::ClosureTy<'tcx>>\n+}"}, {"sha": "e5d4d4a9dae2ccaaf83b754206204c4f66fd5407", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -674,6 +674,13 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      defaultness: hir::Defaultness,\n                                      ty: Option<Ty<'tcx>>)\n {\n+    let predicates = ty::GenericPredicates {\n+        parent: Some(container.id()),\n+        predicates: vec![]\n+    };\n+    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n+                                           predicates);\n+\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: name,\n         vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n@@ -831,6 +838,9 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Convert all the associated types.\n             for impl_item in impl_items {\n                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n+                    let type_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n+                    generics_of_def_id(ccx, type_def_id);\n+\n                     if opt_trait_ref.is_none() {\n                         span_err!(tcx.sess, impl_item.span, E0202,\n                                   \"associated types are not allowed in inherent impls\");\n@@ -898,6 +908,9 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Convert all the associated types.\n             for trait_item in trait_items {\n                 if let hir::TypeTraitItem(_, ref opt_ty) = trait_item.node {\n+                    let type_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n+                    generics_of_def_id(ccx, type_def_id);\n+\n                     let typ = opt_ty.as_ref().map({\n                         |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n                     });"}, {"sha": "0ae059509bd1057a6ba16d3b4d5c1f1d9a7f9353", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -1168,7 +1168,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n                     Argument {\n                         type_: t.clean(cx),\n                         id: ast::CRATE_NODE_ID,\n-                        name: names.next().unwrap_or(\"\".to_string()),\n+                        name: names.next().map_or(\"\".to_string(), |name| name.to_string()),\n                     }\n                 }).collect(),\n             },"}, {"sha": "69e3eab22e91291cf1e2305ca1c5ca57ec9d575a", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -219,7 +219,6 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n- \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "914e3dd4932488b7f8c3dbb49e58b50e4a83c3aa", "filename": "src/test/run-pass-fulldeps/issue-11881.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96abca2a4ec14df912b7ebee69dbeac19d630c4/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-11881.rs?ref=a96abca2a4ec14df912b7ebee69dbeac19d630c4", "patch": "@@ -34,14 +34,14 @@ struct Bar {\n \n enum WireProtocol {\n     JSON,\n-    RBML,\n+    Opaque,\n     // ...\n }\n \n fn encode_json<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n     write!(wr, \"{}\", json::as_json(val));\n }\n-fn encode_rbml<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n+fn encode_opaque<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n     let mut encoder = opaque::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n@@ -52,6 +52,6 @@ pub fn main() {\n     let proto = WireProtocol::JSON;\n     match proto {\n         WireProtocol::JSON => encode_json(&target, &mut wr),\n-        WireProtocol::RBML => encode_rbml(&target, &mut wr)\n+        WireProtocol::Opaque => encode_opaque(&target, &mut wr)\n     }\n }"}]}