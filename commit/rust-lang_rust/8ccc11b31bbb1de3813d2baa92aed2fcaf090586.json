{"sha": "8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjY2MxMWIzMWJiYjFkZTM4MTNkMmJhYTkyYWVkMmZjYWYwOTA1ODY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-18T03:12:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-18T03:12:23Z"}, "message": "Rollup merge of #35765 - KiChjang:e0053-bonus, r=jonathandturner\n\nAdditional span info for E0053\n\nPart of #35233.\nFixes #35212.\n\nr? @jonathandturner", "tree": {"sha": "811987ed9e3f941613cacc19d2a23862f278a07d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/811987ed9e3f941613cacc19d2a23862f278a07d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "html_url": "https://github.com/rust-lang/rust/commit/8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3601d40ecdb3c6626919c5baf1851fad24e3d47", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3601d40ecdb3c6626919c5baf1851fad24e3d47", "html_url": "https://github.com/rust-lang/rust/commit/c3601d40ecdb3c6626919c5baf1851fad24e3d47"}, {"sha": "31d56cb144ead0811935a09d32d7b2febc5b42de", "url": "https://api.github.com/repos/rust-lang/rust/commits/31d56cb144ead0811935a09d32d7b2febc5b42de", "html_url": "https://github.com/rust-lang/rust/commit/31d56cb144ead0811935a09d32d7b2febc5b42de"}], "stats": {"total": 185, "additions": 158, "deletions": 27}, "files": [{"sha": "04031fabc58667ecde8602b9fd83f9adf6760d4e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "patch": "@@ -569,6 +569,13 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn expect_impl_item(&self, id: NodeId) -> &'ast ImplItem {\n+        match self.find(id) {\n+            Some(NodeImplItem(item)) => item,\n+            _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n+        }\n+    }\n+\n     pub fn expect_trait_item(&self, id: NodeId) -> &'ast TraitItem {\n         match self.find(id) {\n             Some(NodeTraitItem(item)) => item,"}, {"sha": "1e053d6bfdab22b3f57d2c47c3a9135db7407692", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "patch": "@@ -523,6 +523,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_type_err(&self,\n                          diag: &mut DiagnosticBuilder<'tcx>,\n                          origin: TypeOrigin,\n+                         secondary_span: Option<(Span, String)>,\n                          values: Option<ValuePairs<'tcx>>,\n                          terr: &TypeError<'tcx>)\n     {\n@@ -553,6 +554,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         diag.span_label(span, &terr);\n+        if let Some((sp, msg)) = secondary_span {\n+            diag.span_label(sp, &msg);\n+        }\n \n         self.note_error_origin(diag, &origin);\n         self.check_and_note_conflicting_crates(diag, terr, span);\n@@ -569,7 +573,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.sess, trace.origin.span(), E0308,\n             \"{}\", trace.origin.as_failure_str()\n         );\n-        self.note_type_err(&mut diag, trace.origin, Some(trace.values), terr);\n+        self.note_type_err(&mut diag, trace.origin, None, Some(trace.values), terr);\n         diag\n     }\n "}, {"sha": "d6f263fcebeb088f739bc5d3f55e164dc2e2df4c", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx.sess, origin.span(), E0271,\n                 \"type mismatch resolving `{}`\", predicate\n             );\n-            self.note_type_err(&mut diag, origin, values, err);\n+            self.note_type_err(&mut diag, origin, None, values, err);\n             self.note_obligation_cause(&mut diag, obligation);\n             diag.emit();\n         });"}, {"sha": "043883df035d0378ed7b34a52b4bd558aaa81cc8", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 85, "deletions": 21, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "patch": "@@ -12,10 +12,9 @@ use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, Reveal};\n-use rustc::ty::error::ExpectedFound;\n+use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::hir::map::Node;\n-use rustc::hir::{ImplItemKind, TraitItem_};\n+use rustc::hir::{ImplItemKind, TraitItem_, Ty_};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -300,6 +299,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &impl_sig);\n+        let impl_args = impl_sig.inputs.clone();\n         let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: impl_m.fty.unsafety,\n             abi: impl_m.fty.abi,\n@@ -318,6 +318,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &trait_sig);\n+        let trait_args = trait_sig.inputs.clone();\n         let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: trait_m.fty.unsafety,\n             abi: trait_m.fty.abi,\n@@ -331,16 +332,82 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                    impl_fty,\n                    trait_fty);\n \n+            let impl_m_iter = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+                ImplItemKind::Method(ref impl_m_sig, _) => impl_m_sig.decl.inputs.iter(),\n+                _ => bug!(\"{:?} is not a method\", impl_m)\n+            };\n+\n+            let (impl_err_span, trait_err_span) = match terr {\n+                TypeError::Mutability => {\n+                    if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+                        let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                            TraitItem_::MethodTraitItem(ref trait_m_sig, _) =>\n+                                trait_m_sig.decl.inputs.iter(),\n+                            _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m)\n+                        };\n+\n+                        impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n+                            match (&impl_arg.ty.node, &trait_arg.ty.node) {\n+                                (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n+                                (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) =>\n+                                    impl_mt.mutbl != trait_mt.mutbl,\n+                                _ => false\n+                            }\n+                        }).map(|(ref impl_arg, ref trait_arg)| {\n+                            match (impl_arg.to_self(), trait_arg.to_self()) {\n+                                (Some(impl_self), Some(trait_self)) =>\n+                                    (impl_self.span, Some(trait_self.span)),\n+                                (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n+                                _ => bug!(\"impl and trait fns have different first args, \\\n+                                           impl: {:?}, trait: {:?}\", impl_arg, trait_arg)\n+                            }\n+                        }).unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n+                    } else {\n+                        (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                    }\n+                }\n+                TypeError::Sorts(ExpectedFound { expected, found }) => {\n+                    if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+                        let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                            TraitItem_::MethodTraitItem(ref trait_m_sig, _) =>\n+                                trait_m_sig.decl.inputs.iter(),\n+                            _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m)\n+                        };\n+                        let impl_iter = impl_args.iter();\n+                        let trait_iter = trait_args.iter();\n+                        let arg_idx = impl_iter.zip(trait_iter)\n+                                               .position(|(impl_arg_ty, trait_arg_ty)| {\n+                                                *impl_arg_ty == found && *trait_arg_ty == expected\n+                                               }).unwrap();\n+                        impl_m_iter.zip(trait_m_iter)\n+                                   .nth(arg_idx)\n+                                   .map(|(impl_arg, trait_arg)|\n+                                        (impl_arg.ty.span, Some(trait_arg.ty.span)))\n+                                   .unwrap_or(\n+                                    (origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n+                    } else {\n+                        (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                    }\n+                }\n+                _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+            };\n+\n+            let origin = TypeOrigin::MethodCompatCheck(impl_err_span);\n+\n             let mut diag = struct_span_err!(\n                 tcx.sess, origin.span(), E0053,\n                 \"method `{}` has an incompatible type for trait\", trait_m.name\n             );\n+\n             infcx.note_type_err(\n-                &mut diag, origin,\n+                &mut diag,\n+                origin,\n+                trait_err_span.map(|sp| (sp, format!(\"original trait requirement\"))),\n                 Some(infer::ValuePairs::Types(ExpectedFound {\n-                    expected: trait_fty,\n-                    found: impl_fty\n-                })), &terr\n+                     expected: trait_fty,\n+                     found: impl_fty\n+                })),\n+                &terr\n             );\n             diag.emit();\n             return\n@@ -487,12 +554,9 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                    trait_ty);\n \n             // Locate the Span containing just the type of the offending impl\n-            if let Some(impl_trait_node) = tcx.map.get_if_local(impl_c.def_id) {\n-                if let Node::NodeImplItem(impl_trait_item) = impl_trait_node {\n-                    if let ImplItemKind::Const(ref ty, _) = impl_trait_item.node {\n-                        origin = TypeOrigin::Misc(ty.span);\n-                    }\n-                }\n+            match tcx.map.expect_impl_item(impl_c_node_id).node {\n+                ImplItemKind::Const(ref ty, _) => origin = TypeOrigin::Misc(ty.span),\n+                _ => bug!(\"{:?} is not a impl const\", impl_c)\n             }\n \n             let mut diag = struct_span_err!(\n@@ -502,16 +566,16 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             );\n \n             // Add a label to the Span containing just the type of the item\n-            if let Some(orig_trait_node) = tcx.map.get_if_local(trait_c.def_id) {\n-                if let Node::NodeTraitItem(orig_trait_item) = orig_trait_node {\n-                    if let TraitItem_::ConstTraitItem(ref ty, _) = orig_trait_item.node {\n-                        diag.span_label(ty.span, &format!(\"original trait requirement\"));\n-                    }\n-                }\n-            }\n+            let trait_c_node_id = tcx.map.as_local_node_id(trait_c.def_id).unwrap();\n+            let trait_c_span = match tcx.map.expect_trait_item(trait_c_node_id).node {\n+                TraitItem_::ConstTraitItem(ref ty, _) => ty.span,\n+                _ => bug!(\"{:?} is not a trait const\", trait_c)\n+            };\n \n             infcx.note_type_err(\n-                &mut diag, origin,\n+                &mut diag,\n+                origin,\n+                Some((trait_c_span, format!(\"original trait requirement\"))),\n                 Some(infer::ValuePairs::Types(ExpectedFound {\n                     expected: trait_ty,\n                     found: impl_ty"}, {"sha": "7022010714aa77ed380d5ad5110ae56740150a94", "filename": "src/test/compile-fail/E0053.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Ftest%2Fcompile-fail%2FE0053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Ftest%2Fcompile-fail%2FE0053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0053.rs?ref=8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "patch": "@@ -9,15 +9,21 @@\n // except according to those terms.\n \n trait Foo {\n-    fn foo(x: u16);\n-    fn bar(&self);\n+    fn foo(x: u16); //~ NOTE original trait requirement\n+    fn bar(&self); //~ NOTE original trait requirement\n }\n \n struct Bar;\n \n impl Foo for Bar {\n-    fn foo(x: i16) { } //~ ERROR E0053\n-    fn bar(&mut self) { } //~ ERROR E0053\n+    fn foo(x: i16) { }\n+    //~^ ERROR method `foo` has an incompatible type for trait\n+    //~| NOTE expected u16\n+    fn bar(&mut self) { }\n+    //~^ ERROR method `bar` has an incompatible type for trait\n+    //~| NOTE values differ in mutability\n+    //~| NOTE expected type `fn(&Bar)`\n+    //~| NOTE found type `fn(&mut Bar)`\n }\n \n fn main() {"}, {"sha": "099c8699e493bcc67c4f7b18d20f76ee1d9333cc", "filename": "src/test/ui/mismatched_types/trait-impl-fn-incompatibility.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.rs?ref=8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+trait Foo {\n+    fn foo(x: u16);\n+    fn bar(&mut self, bar: &mut Bar);\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn foo(x: i16) { }\n+    fn bar(&mut self, bar: &Bar) { }\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "e5dfdc8e910df0264be602e05992ee9827ce80d3", "filename": "src/test/ui/mismatched_types/trait-impl-fn-incompatibility.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc11b31bbb1de3813d2baa92aed2fcaf090586/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr?ref=8ccc11b31bbb1de3813d2baa92aed2fcaf090586", "patch": "@@ -0,0 +1,23 @@\n+error[E0053]: method `foo` has an incompatible type for trait\n+  --> $DIR/trait-impl-fn-incompatibility.rs:21:15\n+   |\n+14 |     fn foo(x: u16);\n+   |               --- original trait requirement\n+...\n+21 |     fn foo(x: i16) { }\n+   |               ^^^ expected u16, found i16\n+\n+error[E0053]: method `bar` has an incompatible type for trait\n+  --> $DIR/trait-impl-fn-incompatibility.rs:22:28\n+   |\n+15 |     fn bar(&mut self, bar: &mut Bar);\n+   |                            -------- original trait requirement\n+...\n+22 |     fn bar(&mut self, bar: &Bar) { }\n+   |                            ^^^^ values differ in mutability\n+   |\n+   = note: expected type `fn(&mut Bar, &mut Bar)`\n+   = note:    found type `fn(&mut Bar, &Bar)`\n+\n+error: aborting due to 2 previous errors\n+"}]}