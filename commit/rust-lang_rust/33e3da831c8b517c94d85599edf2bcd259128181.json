{"sha": "33e3da831c8b517c94d85599edf2bcd259128181", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZTNkYTgzMWM4YjUxN2M5NGQ4NTU5OWVkZjJiY2QyNTkxMjgxODE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-15T20:50:30Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-15T22:55:19Z"}, "message": "Use the macro namespace for custom derives.", "tree": {"sha": "b25e5b75bd810796d51d3c1bcea4e896971b57a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b25e5b75bd810796d51d3c1bcea4e896971b57a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33e3da831c8b517c94d85599edf2bcd259128181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33e3da831c8b517c94d85599edf2bcd259128181", "html_url": "https://github.com/rust-lang/rust/commit/33e3da831c8b517c94d85599edf2bcd259128181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33e3da831c8b517c94d85599edf2bcd259128181/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d902963b6d58b8b79ec3e29a508b2b9e86716293", "url": "https://api.github.com/repos/rust-lang/rust/commits/d902963b6d58b8b79ec3e29a508b2b9e86716293", "html_url": "https://github.com/rust-lang/rust/commit/d902963b6d58b8b79ec3e29a508b2b9e86716293"}], "stats": {"total": 109, "additions": 62, "deletions": 47}, "files": [{"sha": "b54862ae0ade6c2f4be2e08d2b2a963b54e79a49", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=33e3da831c8b517c94d85599edf2bcd259128181", "patch": "@@ -35,7 +35,6 @@ use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::MultiItemModifier;\n@@ -425,7 +424,7 @@ pub struct LoadedMacro {\n \n pub enum LoadedMacroKind {\n     Def(ast::MacroDef),\n-    CustomDerive(String, Rc<MultiItemModifier>),\n+    CustomDerive(String, Box<MultiItemModifier>),\n }\n \n pub trait CrateLoader {"}, {"sha": "3b1b2a4cd27e432c13763072f7640cc4e2857d2c", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=33e3da831c8b517c94d85599edf2bcd259128181", "patch": "@@ -11,7 +11,6 @@\n //! Used by `rustc` when loading a crate with exported macros.\n \n use std::collections::HashSet;\n-use std::rc::Rc;\n use std::env;\n use std::mem;\n \n@@ -212,7 +211,7 @@ impl<'a> CrateLoader<'a> {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream) {\n-                let derive = Rc::new(CustomDerive::new(expand));\n+                let derive = Box::new(CustomDerive::new(expand));\n                 self.0.push(LoadedMacro {\n                     kind: LoadedMacroKind::CustomDerive(trait_name.to_string(), derive),\n                     import_site: self.1,"}, {"sha": "dac9e57be32994c7967fe3ada5806a29f2873a5b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=33e3da831c8b517c94d85599edf2bcd259128181", "patch": "@@ -36,7 +36,7 @@ use syntax::parse::token;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ext::base::{MultiItemModifier, Resolver as SyntaxResolver};\n+use syntax::ext::base::{SyntaxExtension, Resolver as SyntaxResolver};\n use syntax::ext::hygiene::Mark;\n use syntax::feature_gate::{self, emit_feature_err};\n use syntax::ext::tt::macro_rules;\n@@ -195,33 +195,45 @@ impl<'b> Resolver<'b> {\n                 // We need to error on `#[macro_use] extern crate` when it isn't at the\n                 // crate root, because `$crate` won't work properly.\n                 let is_crate_root = self.current_module.parent.is_none();\n+                let import_macro = |this: &mut Self, name, ext, span| {\n+                    let shadowing = this.builtin_macros.insert(name, Rc::new(ext)).is_some();\n+                    if shadowing && expansion != Mark::root() {\n+                        let msg = format!(\"`{}` is already in scope\", name);\n+                        this.session.struct_span_err(span, &msg)\n+                            .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n+                                   existing macros (see RFC 1560)\")\n+                            .emit();\n+                    }\n+                };\n+\n+                let mut custom_derive_crate = false;\n                 for loaded_macro in self.crate_loader.load_macros(item, is_crate_root) {\n                     match loaded_macro.kind {\n                         LoadedMacroKind::Def(mut def) => {\n-                            let name = def.ident.name;\n                             if def.use_locally {\n-                                let ext =\n-                                    Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n-                                if self.builtin_macros.insert(name, ext).is_some() &&\n-                                   expansion != Mark::root() {\n-                                    let msg = format!(\"`{}` is already in scope\", name);\n-                                    self.session.struct_span_err(loaded_macro.import_site, &msg)\n-                                        .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n-                                               existing macros (see RFC 1560)\")\n-                                        .emit();\n-                                }\n-                                self.macro_names.insert(name);\n+                                self.macro_names.insert(def.ident.name);\n+                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n+                                import_macro(self, def.ident.name, ext, loaded_macro.import_site);\n                             }\n                             if def.export {\n                                 def.id = self.next_node_id();\n                                 self.exported_macros.push(def);\n                             }\n                         }\n                         LoadedMacroKind::CustomDerive(name, ext) => {\n-                            self.insert_custom_derive(&name, ext, item.span);\n+                            custom_derive_crate = true;\n+                            let ext = SyntaxExtension::CustomDerive(ext);\n+                            import_macro(self, token::intern(&name), ext, loaded_macro.import_site);\n                         }\n                     }\n                 }\n+\n+                if custom_derive_crate && !self.session.features.borrow().proc_macro {\n+                    let issue = feature_gate::GateIssue::Language;\n+                    let msg = \"loading custom derive macro crates is experimentally supported\";\n+                    emit_feature_err(&self.session.parse_sess, \"proc_macro\", item.span, issue, msg);\n+                }\n+\n                 self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n@@ -504,17 +516,6 @@ impl<'b> Resolver<'b> {\n \n         false\n     }\n-\n-    fn insert_custom_derive(&mut self, name: &str, ext: Rc<MultiItemModifier>, sp: Span) {\n-        if !self.session.features.borrow().proc_macro {\n-            let sess = &self.session.parse_sess;\n-            let msg = \"loading custom derive macro crates is experimentally supported\";\n-            emit_feature_err(sess, \"proc_macro\", sp, feature_gate::GateIssue::Language, msg);\n-        }\n-        if self.derive_modes.insert(token::intern(name), ext).is_some() {\n-            self.session.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n-        }\n-    }\n }\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {"}, {"sha": "21641a17bbfdec3f319e3ee018255cbb4e573bfe", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=33e3da831c8b517c94d85599edf2bcd259128181", "patch": "@@ -53,7 +53,6 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n@@ -1080,7 +1079,6 @@ pub struct Resolver<'a> {\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n-    pub derive_modes: FnvHashMap<Name, Rc<MultiItemModifier>>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n     builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n@@ -1271,7 +1269,6 @@ impl<'a> Resolver<'a> {\n             new_import_semantics: session.features.borrow().item_like_imports,\n \n             exported_macros: Vec::new(),\n-            derive_modes: FnvHashMap(),\n             crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n             builtin_macros: FnvHashMap(),"}, {"sha": "cf5ea236b3ec7e845eee8d9bcd01c1d5c3b0bf30", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=33e3da831c8b517c94d85599edf2bcd259128181", "patch": "@@ -17,7 +17,7 @@ use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator, MultiItemModifier};\n+use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n@@ -186,10 +186,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         })\n     }\n-\n-    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>> {\n-        self.derive_modes.get(&ident.name).cloned()\n-    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "11c6f87a655295b3230f837baf0322be2b86f40e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=33e3da831c8b517c94d85599edf2bcd259128181", "patch": "@@ -508,6 +508,8 @@ pub enum SyntaxExtension {\n     /// the block.\n     ///\n     IdentTT(Box<IdentMacroExpander>, Option<Span>, bool),\n+\n+    CustomDerive(Box<MultiItemModifier>),\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -524,7 +526,6 @@ pub trait Resolver {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n-    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -545,7 +546,6 @@ impl Resolver for DummyResolver {\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n-    fn resolve_derive_mode(&mut self, _ident: ast::Ident) -> Option<Rc<MultiItemModifier>> { None }\n     fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "6aeb46fd52276126f5d91aca2812a36be174128e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=33e3da831c8b517c94d85599edf2bcd259128181", "patch": "@@ -364,7 +364,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n                 self.parse_expansion(tok_result, kind, name, attr.span)\n             }\n-            _ => unreachable!(),\n+            SyntaxExtension::CustomDerive(_) => {\n+                self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", name));\n+                kind.dummy(attr.span)\n+            }\n+            _ => {\n+                let msg = &format!(\"macro `{}` may not be used in attributes\", name);\n+                self.cx.span_err(attr.span, &msg);\n+                kind.dummy(attr.span)\n+            }\n         }\n     }\n \n@@ -439,6 +447,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 return kind.dummy(span);\n             }\n \n+            SyntaxExtension::CustomDerive(..) => {\n+                self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", extname));\n+                return kind.dummy(span);\n+            }\n+\n             SyntaxExtension::ProcMacro(ref expandfun) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg ="}, {"sha": "07401d59a15db2678321832b809035b20808756d", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e3da831c8b517c94d85599edf2bcd259128181/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=33e3da831c8b517c94d85599edf2bcd259128181", "patch": "@@ -12,7 +12,7 @@\n \n use syntax::ast::{self, MetaItem};\n use syntax::attr::HasAttrs;\n-use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::codemap;\n@@ -158,10 +158,14 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         let tword = titem.word().unwrap();\n         let tname = tword.name();\n \n-        let derive_mode = ast::Ident::with_empty_ctxt(intern(&tname));\n-        let derive_mode = cx.resolver.resolve_derive_mode(derive_mode);\n-        if is_builtin_trait(&tname) || derive_mode.is_some() {\n-            return true\n+        if is_builtin_trait(&tname) || {\n+            let derive_mode =\n+                ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(intern(&tname)));\n+            cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n+                if let SyntaxExtension::CustomDerive(_) = *ext { true } else { false }\n+            }).unwrap_or(false)\n+        } {\n+            return true;\n         }\n \n         if !cx.ecfg.enable_custom_derive() {\n@@ -216,7 +220,9 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                  .next();\n     if let Some((i, titem)) = macros_11_derive {\n         let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n-        let ext = cx.resolver.resolve_derive_mode(tname).unwrap();\n+        let path = ast::Path::from_ident(titem.span, tname);\n+        let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n+\n         traits.remove(i);\n         if traits.len() > 0 {\n             item = item.map(|mut i| {\n@@ -232,7 +238,11 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                  intern_and_get_ident(\"derive\"),\n                                  vec![titem]);\n         let item = Annotatable::Item(item);\n-        return ext.expand(cx, mitem.span, &mitem, item)\n+        if let SyntaxExtension::CustomDerive(ref ext) = *ext {\n+            return ext.expand(cx, mitem.span, &mitem, item);\n+        } else {\n+            unreachable!()\n+        }\n     }\n \n     // Ok, at this point we know that there are no old-style `#[derive_Foo]` nor"}]}