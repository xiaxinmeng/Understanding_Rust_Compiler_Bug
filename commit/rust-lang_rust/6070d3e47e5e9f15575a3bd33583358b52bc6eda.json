{"sha": "6070d3e47e5e9f15575a3bd33583358b52bc6eda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNzBkM2U0N2U1ZTlmMTU1NzVhM2JkMzM1ODMzNThiNTJiYzZlZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-24T07:55:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-24T07:55:34Z"}, "message": "Auto merge of #48476 - Manishearth:rollup, r=Manishearth\n\nRollup of 12 pull requests\n\n- Successful merges: #47933, #48072, #48083, #48123, #48157, #48219, #48221, #48245, #48429, #48436, #48438, #48472\n- Failed merges:", "tree": {"sha": "1277310a9582461e3b0dbe8db1ceb6f5f173f3c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1277310a9582461e3b0dbe8db1ceb6f5f173f3c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6070d3e47e5e9f15575a3bd33583358b52bc6eda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6070d3e47e5e9f15575a3bd33583358b52bc6eda", "html_url": "https://github.com/rust-lang/rust/commit/6070d3e47e5e9f15575a3bd33583358b52bc6eda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6070d3e47e5e9f15575a3bd33583358b52bc6eda/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0a8620ed639d5085d7e1cca3626681a6e4e328e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a8620ed639d5085d7e1cca3626681a6e4e328e", "html_url": "https://github.com/rust-lang/rust/commit/b0a8620ed639d5085d7e1cca3626681a6e4e328e"}, {"sha": "b26442a3cb12e988f70d9805b8bbfae52fd20d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b26442a3cb12e988f70d9805b8bbfae52fd20d7d", "html_url": "https://github.com/rust-lang/rust/commit/b26442a3cb12e988f70d9805b8bbfae52fd20d7d"}], "stats": {"total": 1348, "additions": 1035, "deletions": 313}, "files": [{"sha": "8f25820d3a5278a4d5a866b17033bcbccceea5c6", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -1623,7 +1623,9 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc_macro 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\","}, {"sha": "ec579e3fd68d68d17e56bcdccdc213b8f5d7d1de", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -747,8 +747,8 @@ impl<T> LinkedList<T> {\n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n     ///\n     /// If the closure returns true, then the element is removed and yielded.\n-    /// If the closure returns false, it will try again, and call the closure on the next element,\n-    /// seeing if it passes the test.\n+    /// If the closure returns false, the element will remain in the list and will not be yielded\n+    /// by the iterator.\n     ///\n     /// Note that `drain_filter` lets you mutate every element in the filter closure, regardless of\n     /// whether you choose to keep or remove it."}, {"sha": "409d2ab287e7c7ed899907f358f403aba874f542", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -364,7 +364,7 @@ impl String {\n     ///\n     /// Given that the `String` is empty, this will not allocate any initial\n     /// buffer. While that means that this initial operation is very\n-    /// inexpensive, but may cause excessive allocation later, when you add\n+    /// inexpensive, it may cause excessive allocation later when you add\n     /// data. If you have an idea of how much data the `String` will hold,\n     /// consider the [`with_capacity`] method to prevent excessive\n     /// re-allocation."}, {"sha": "3c9b6b94b44053c7879c6ff7537494af8ea2aa04", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -1966,8 +1966,8 @@ impl<T> Vec<T> {\n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n     ///\n     /// If the closure returns true, then the element is removed and yielded.\n-    /// If the closure returns false, it will try again, and call the closure\n-    /// on the next element, seeing if it passes the test.\n+    /// If the closure returns false, the element will remain in the vector and will not be yielded\n+    /// by the iterator.\n     ///\n     /// Using this method is equivalent to the following code:\n     ///"}, {"sha": "877793cb3c57cfd9b1c8a93027cbb5fb2a574191", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -1366,9 +1366,9 @@ pub trait Iterator {\n     ///\n     /// In particular, try to have this call `try_fold()` on the internal parts\n     /// from which this iterator is composed.  If multiple calls are needed,\n-    /// the `?` operator be convenient for chaining the accumulator value along,\n-    /// but beware any invariants that need to be upheld before those early\n-    /// returns.  This is a `&mut self` method, so iteration needs to be\n+    /// the `?` operator may be convenient for chaining the accumulator value\n+    /// along, but beware any invariants that need to be upheld before those\n+    /// early returns.  This is a `&mut self` method, so iteration needs to be\n     /// resumable after hitting an error here.\n     ///\n     /// # Examples\n@@ -1414,6 +1414,42 @@ pub trait Iterator {\n         Try::from_ok(accum)\n     }\n \n+    /// An iterator method that applies a fallible function to each item in the\n+    /// iterator, stopping at the first error and returning that error.\n+    ///\n+    /// This can also be thought of as the fallible form of [`for_each()`]\n+    /// or as the stateless version of [`try_fold()`].\n+    ///\n+    /// [`for_each()`]: #method.for_each\n+    /// [`try_fold()`]: #method.try_fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// use std::fs::rename;\n+    /// use std::io::{stdout, Write};\n+    /// use std::path::Path;\n+    ///\n+    /// let data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];\n+    ///\n+    /// let res = data.iter().try_for_each(|x| writeln!(stdout(), \"{}\", x));\n+    /// assert!(res.is_ok());\n+    ///\n+    /// let mut it = data.iter().cloned();\n+    /// let res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));\n+    /// assert!(res.is_err());\n+    /// // It short-circuited, so the remaining items are still in the iterator:\n+    /// assert_eq!(it.next(), Some(\"stale_bread.json\"));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    fn try_for_each<F, R>(&mut self, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n+    {\n+        self.try_fold((), move |(), x| f(x))\n+    }\n+\n     /// An iterator method that applies a function, producing a single, final value.\n     ///\n     /// `fold()` takes two arguments: an initial value, and a closure with two\n@@ -1532,7 +1568,7 @@ pub trait Iterator {\n     fn all<F>(&mut self, mut f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        self.try_fold((), move |(), x| {\n+        self.try_for_each(move |x| {\n             if f(x) { LoopState::Continue(()) }\n             else { LoopState::Break(()) }\n         }) == LoopState::Continue(())\n@@ -1581,7 +1617,7 @@ pub trait Iterator {\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        self.try_fold((), move |(), x| {\n+        self.try_for_each(move |x| {\n             if f(x) { LoopState::Break(()) }\n             else { LoopState::Continue(()) }\n         }) == LoopState::Break(())\n@@ -1635,7 +1671,7 @@ pub trait Iterator {\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        self.try_fold((), move |(), x| {\n+        self.try_for_each(move |x| {\n             if predicate(&x) { LoopState::Break(x) }\n             else { LoopState::Continue(()) }\n         }).break_value()"}, {"sha": "878a536836d23a4450e092fa3505a20c6a706248", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -844,6 +844,12 @@ pub mod __internal {\n         })\n     }\n \n+    pub fn in_sess() -> bool\n+    {\n+        let p = CURRENT_SESS.with(|p| p.get());\n+        !p.0.is_null()\n+    }\n+\n     pub fn with_sess<F, R>(f: F) -> R\n         where F: FnOnce((&ParseSess, Mark)) -> R\n     {"}, {"sha": "7e84a69dd7913b99356acd128321d93a0cf5602e", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -14,7 +14,9 @@ bitflags = \"1.0\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n+lazy_static = \"1.0.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+proc_macro = { path = \"../libproc_macro\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "2e7bf4d001d267259a09996c6492f337fcb7ba7a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -60,6 +60,7 @@\n #![feature(never_type)]\n #![feature(non_exhaustive)]\n #![feature(nonzero)]\n+#![feature(proc_macro_internals)]\n #![feature(quote)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n@@ -81,6 +82,7 @@ extern crate core;\n extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n+#[macro_use] extern crate lazy_static;\n #[cfg(windows)]\n extern crate libc;\n extern crate rustc_back;\n@@ -92,6 +94,7 @@ extern crate rustc_errors as errors;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n extern crate jobserver;\n+extern crate proc_macro;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "5201df2119dac8703de1aa9560586a813cbdf49c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 71, "deletions": 11, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -270,6 +270,19 @@ enum Scope<'a> {\n         /// we should use for an early-bound region?\n         next_early_index: u32,\n \n+        /// Whether or not this binder would serve as the parent\n+        /// binder for abstract types introduced within. For example:\n+        ///\n+        ///     fn foo<'a>() -> impl for<'b> Trait<Item = impl Trait2<'a>>\n+        ///\n+        /// Here, the abstract types we create for the `impl Trait`\n+        /// and `impl Trait2` references will both have the `foo` item\n+        /// as their parent. When we get to `impl Trait2`, we find\n+        /// that it is nested within the `for<>` binder -- this flag\n+        /// allows us to skip that when looking for the parent binder\n+        /// of the resulting abstract type.\n+        abstract_type_parent: bool,\n+\n         s: ScopeRef<'a>,\n     },\n \n@@ -498,6 +511,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n+                    abstract_type_parent: true,\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -541,6 +555,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         .collect(),\n                     s: self.scope,\n                     next_early_index,\n+                    abstract_type_parent: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -614,7 +629,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref generics,\n                     ref bounds,\n                 } = *exist_ty;\n-                let mut index = self.next_early_index();\n+\n+                // We want to start our early-bound indices at the end of the parent scope,\n+                // not including any parent `impl Trait`s.\n+                let mut index = self.next_early_index_for_abstract_type();\n                 debug!(\"visit_ty: index = {}\", index);\n \n                 let mut elision = None;\n@@ -638,7 +656,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         s: self.scope\n                     };\n                     self.with(scope, |_old_scope, this| {\n-                        let scope = Scope::Binder { lifetimes, next_early_index, s: this.scope };\n+                        let scope = Scope::Binder {\n+                            lifetimes,\n+                            next_early_index,\n+                            s: this.scope,\n+                            abstract_type_parent: false,\n+                        };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n                             for bound in bounds {\n@@ -647,7 +670,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         });\n                     });\n                 } else {\n-                    let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                    let scope = Scope::Binder {\n+                        lifetimes,\n+                        next_early_index,\n+                        s: self.scope,\n+                        abstract_type_parent: false,\n+                    };\n                     self.with(scope, |_old_scope, this| {\n                         this.visit_generics(generics);\n                         for bound in bounds {\n@@ -681,7 +709,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .collect();\n \n                 let next_early_index = index + generics.ty_params().count() as u32;\n-                let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                let scope = Scope::Binder {\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                    abstract_type_parent: true,\n+                };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n                     for bound in bounds {\n@@ -721,7 +754,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .collect();\n \n                 let next_early_index = index + generics.ty_params().count() as u32;\n-                let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                let scope = Scope::Binder {\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                    abstract_type_parent: true,\n+                };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n@@ -792,6 +830,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 .collect(),\n                             s: self.scope,\n                             next_early_index,\n+                            abstract_type_parent: false,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n@@ -853,6 +892,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .collect(),\n                 s: self.scope,\n                 next_early_index,\n+                abstract_type_parent: false,\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n@@ -1046,6 +1086,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                     ref lifetimes,\n                     s,\n                     next_early_index: _,\n+                    abstract_type_parent: _,\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n@@ -1303,32 +1344,49 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             lifetimes,\n             next_early_index,\n             s: self.scope,\n+            abstract_type_parent: true,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_params(old_scope, &generics.params);\n             this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n         });\n     }\n \n-    /// Returns the next index one would use for an early-bound-region\n-    /// if extending the current scope.\n-    fn next_early_index(&self) -> u32 {\n+    fn next_early_index_helper(&self, only_abstract_type_parent: bool) -> u32 {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n                 Scope::Root => return 0,\n \n                 Scope::Binder {\n-                    next_early_index, ..\n-                } => return next_early_index,\n+                    next_early_index,\n+                    abstract_type_parent,\n+                    ..\n+                } if (!only_abstract_type_parent || abstract_type_parent)\n+                => return next_early_index,\n \n-                Scope::Body { s, .. }\n+                Scope::Binder { s, .. }\n+                | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n             }\n         }\n     }\n \n+    /// Returns the next index one would use for an early-bound-region\n+    /// if extending the current scope.\n+    fn next_early_index(&self) -> u32 {\n+        self.next_early_index_helper(true)\n+    }\n+\n+    /// Returns the next index one would use for an `impl Trait` that\n+    /// is being converted into an `abstract type`. This will be the\n+    /// next early index from the enclosing item, for the most\n+    /// part. See the `abstract_type_parent` field for more info.\n+    fn next_early_index_for_abstract_type(&self) -> u32 {\n+        self.next_early_index_helper(false)\n+    }\n+\n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_lifetime_ref(lifetime_ref={:?})\", lifetime_ref);\n         // Walk up the scope chain, tracking the number of fn scopes\n@@ -1353,6 +1411,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     ref lifetimes,\n                     s,\n                     next_early_index: _,\n+                    abstract_type_parent: _,\n                 } => {\n                     if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n                         break Some(def.shifted(late_depth));\n@@ -2102,6 +2161,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     ref lifetimes,\n                     s,\n                     next_early_index: _,\n+                    abstract_type_parent: _,\n                 } => {\n                     if let Some(&def) = lifetimes.get(&lifetime.name) {\n                         let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();"}, {"sha": "12d8d6f3d7481f15fa82ec8b42bb493ec21191b6", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -747,7 +747,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ty::TyTuple(ref tys, _) => tys.iter()\n                         .map(|t| match t.sty {\n                             ty::TypeVariants::TyTuple(ref tys, _) => ArgKind::Tuple(\n-                                span,\n+                                Some(span),\n                                 tys.iter()\n                                     .map(|ty| (\"_\".to_owned(), format!(\"{}\", ty.sty)))\n                                     .collect::<Vec<_>>()\n@@ -815,7 +815,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    pub fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n         match node {\n             hir::map::NodeExpr(&hir::Expr {\n                 node: hir::ExprClosure(_, ref _decl, id, span, _),\n@@ -829,7 +833,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             ..\n                         } = arg.pat.clone().into_inner() {\n                             ArgKind::Tuple(\n-                                span,\n+                                Some(span),\n                                 args.iter().map(|pat| {\n                                     let snippet = self.tcx.sess.codemap()\n                                         .span_to_snippet(pat.span).unwrap();\n@@ -862,7 +866,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n                         .map(|arg| match arg.clone().into_inner().node {\n                     hir::TyTup(ref tys) => ArgKind::Tuple(\n-                        arg.span,\n+                        Some(arg.span),\n                         tys.iter()\n                             .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n                             .collect::<Vec<_>>(),\n@@ -874,7 +878,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn report_arg_count_mismatch(\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    pub fn report_arg_count_mismatch(\n         &self,\n         span: Span,\n         found_span: Option<Span>,\n@@ -1385,13 +1392,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-enum ArgKind {\n+/// Summarizes information\n+pub enum ArgKind {\n+    /// An argument of non-tuple type. Parameters are (name, ty)\n     Arg(String, String),\n-    Tuple(Span, Vec<(String, String)>),\n+\n+    /// An argument of tuple type. For a \"found\" argument, the span is\n+    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// argument, it will be None. The vector is a list of (name, ty)\n+    /// strings for the components of the tuple.\n+    Tuple(Option<Span>, Vec<(String, String)>),\n }\n \n impl ArgKind {\n     fn empty() -> ArgKind {\n         ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n     }\n+\n+    /// Creates an `ArgKind` from the expected type of an\n+    /// argument. This has no name (`_`) and no source spans..\n+    pub fn from_expected_ty(t: Ty<'_>) -> ArgKind {\n+        match t.sty {\n+            ty::TyTuple(ref tys, _) => ArgKind::Tuple(\n+                None,\n+                tys.iter()\n+                   .map(|ty| (\"_\".to_owned(), format!(\"{}\", ty.sty)))\n+                   .collect::<Vec<_>>()\n+            ),\n+            _ => ArgKind::Arg(\"_\".to_owned(), format!(\"{}\", t.sty)),\n+        }\n+    }\n }"}, {"sha": "520b997882e07afe8c5e3c4f2f7673ecd459ea88", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -49,7 +49,7 @@ pub use self::util::SupertraitDefIds;\n pub use self::util::transitive_bounds;\n \n mod coherence;\n-mod error_reporting;\n+pub mod error_reporting;\n mod fulfill;\n mod project;\n mod object_safety;"}, {"sha": "55e9a98e7ef1329e4b12cf397699ebc46dc8b4c1", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -16,13 +16,16 @@ use std::ffi::CString;\n use std::fmt::Debug;\n use std::hash::{Hash, BuildHasher};\n use std::iter::repeat;\n+use std::panic;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n use ty::maps::{QueryMsg};\n use dep_graph::{DepNode};\n+use proc_macro;\n+use lazy_static;\n \n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n@@ -34,6 +37,24 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n+lazy_static! {\n+    static ref DEFAULT_HOOK: Box<Fn(&panic::PanicInfo) + Sync + Send + 'static> = {\n+        let hook = panic::take_hook();\n+        panic::set_hook(Box::new(panic_hook));\n+        hook\n+    };\n+}\n+\n+fn panic_hook(info: &panic::PanicInfo) {\n+    if !proc_macro::__internal::in_sess() {\n+        (*DEFAULT_HOOK)(info)\n+    }\n+}\n+\n+pub fn install_panic_hook() {\n+    lazy_static::initialize(&DEFAULT_HOOK);\n+}\n+\n /// Initialized for -Z profile-queries\n thread_local!(static PROFQ_CHAN: RefCell<Option<Sender<ProfileQueriesMsg>>> = RefCell::new(None));\n "}, {"sha": "54565afa4c6c7be4154cd9c5f15529c4b61c41d1", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 245, "deletions": 33, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -8,19 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::BTreeMap;\n+use std::collections::btree_map::Entry;\n+use std::marker::PhantomData;\n use std::iter::FromIterator;\n+use indexed_vec::{Idx, IndexVec};\n+\n+type Word = u128;\n+const WORD_BITS: usize = 128;\n \n /// A very simple BitVector type.\n #[derive(Clone, Debug, PartialEq)]\n pub struct BitVector {\n-    data: Vec<u64>,\n+    data: Vec<Word>,\n }\n \n impl BitVector {\n     #[inline]\n     pub fn new(num_bits: usize) -> BitVector {\n-        let num_words = u64s(num_bits);\n-        BitVector { data: vec![0; num_words] }\n+        let num_words = words(num_bits);\n+        BitVector {\n+            data: vec![0; num_words],\n+        }\n     }\n \n     #[inline]\n@@ -78,7 +87,7 @@ impl BitVector {\n \n     #[inline]\n     pub fn grow(&mut self, num_bits: usize) {\n-        let num_words = u64s(num_bits);\n+        let num_words = words(num_bits);\n         if self.data.len() < num_words {\n             self.data.resize(num_words, 0)\n         }\n@@ -96,8 +105,8 @@ impl BitVector {\n }\n \n pub struct BitVectorIter<'a> {\n-    iter: ::std::slice::Iter<'a, u64>,\n-    current: u64,\n+    iter: ::std::slice::Iter<'a, Word>,\n+    current: Word,\n     idx: usize,\n }\n \n@@ -107,10 +116,10 @@ impl<'a> Iterator for BitVectorIter<'a> {\n         while self.current == 0 {\n             self.current = if let Some(&i) = self.iter.next() {\n                 if i == 0 {\n-                    self.idx += 64;\n+                    self.idx += WORD_BITS;\n                     continue;\n                 } else {\n-                    self.idx = u64s(self.idx) * 64;\n+                    self.idx = words(self.idx) * WORD_BITS;\n                     i\n                 }\n             } else {\n@@ -126,12 +135,15 @@ impl<'a> Iterator for BitVectorIter<'a> {\n }\n \n impl FromIterator<bool> for BitVector {\n-    fn from_iter<I>(iter: I) -> BitVector where I: IntoIterator<Item=bool> {\n+    fn from_iter<I>(iter: I) -> BitVector\n+    where\n+        I: IntoIterator<Item = bool>,\n+    {\n         let iter = iter.into_iter();\n         let (len, _) = iter.size_hint();\n-        // Make the minimum length for the bitvector 64 bits since that's\n+        // Make the minimum length for the bitvector WORD_BITS bits since that's\n         // the smallest non-zero size anyway.\n-        let len = if len < 64 { 64 } else { len };\n+        let len = if len < WORD_BITS { WORD_BITS } else { len };\n         let mut bv = BitVector::new(len);\n         for (idx, val) in iter.enumerate() {\n             if idx > len {\n@@ -152,32 +164,32 @@ impl FromIterator<bool> for BitVector {\n #[derive(Clone, Debug)]\n pub struct BitMatrix {\n     columns: usize,\n-    vector: Vec<u64>,\n+    vector: Vec<Word>,\n }\n \n impl BitMatrix {\n     /// Create a new `rows x columns` matrix, initially empty.\n     pub fn new(rows: usize, columns: usize) -> BitMatrix {\n         // For every element, we need one bit for every other\n-        // element. Round up to an even number of u64s.\n-        let u64s_per_row = u64s(columns);\n+        // element. Round up to an even number of words.\n+        let words_per_row = words(columns);\n         BitMatrix {\n             columns,\n-            vector: vec![0; rows * u64s_per_row],\n+            vector: vec![0; rows * words_per_row],\n         }\n     }\n \n     /// The range of bits for a given row.\n     fn range(&self, row: usize) -> (usize, usize) {\n-        let u64s_per_row = u64s(self.columns);\n-        let start = row * u64s_per_row;\n-        (start, start + u64s_per_row)\n+        let words_per_row = words(self.columns);\n+        let start = row * words_per_row;\n+        (start, start + words_per_row)\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, add\n     /// `column` to the bitset for `row`.\n     ///\n-    /// Returns true if this changed the matrix, and false otherwies.\n+    /// Returns true if this changed the matrix, and false otherwise.\n     pub fn add(&mut self, row: usize, column: usize) -> bool {\n         let (start, _) = self.range(row);\n         let (word, mask) = word_mask(column);\n@@ -208,12 +220,12 @@ impl BitMatrix {\n         let mut result = Vec::with_capacity(self.columns);\n         for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n             let mut v = self.vector[i] & self.vector[j];\n-            for bit in 0..64 {\n+            for bit in 0..WORD_BITS {\n                 if v == 0 {\n                     break;\n                 }\n                 if v & 0x1 != 0 {\n-                    result.push(base * 64 + bit);\n+                    result.push(base * WORD_BITS + bit);\n                 }\n                 v >>= 1;\n             }\n@@ -254,15 +266,214 @@ impl BitMatrix {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub struct SparseBitMatrix<R, C>\n+where\n+    R: Idx,\n+    C: Idx,\n+{\n+    vector: IndexVec<R, SparseBitSet<C>>,\n+}\n+\n+impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n+    /// Create a new `rows x columns` matrix, initially empty.\n+    pub fn new(rows: R, _columns: C) -> SparseBitMatrix<R, C> {\n+        SparseBitMatrix {\n+            vector: IndexVec::from_elem_n(SparseBitSet::new(), rows.index()),\n+        }\n+    }\n+\n+    /// Sets the cell at `(row, column)` to true. Put another way, insert\n+    /// `column` to the bitset for `row`.\n+    ///\n+    /// Returns true if this changed the matrix, and false otherwise.\n+    pub fn add(&mut self, row: R, column: C) -> bool {\n+        self.vector[row].insert(column)\n+    }\n+\n+    /// Do the bits from `row` contain `column`? Put another way, is\n+    /// the matrix cell at `(row, column)` true?  Put yet another way,\n+    /// if the matrix represents (transitive) reachability, can\n+    /// `row` reach `column`?\n+    pub fn contains(&self, row: R, column: C) -> bool {\n+        self.vector[row].contains(column)\n+    }\n+\n+    /// Add the bits from row `read` to the bits from row `write`,\n+    /// return true if anything changed.\n+    ///\n+    /// This is used when computing transitive reachability because if\n+    /// you have an edge `write -> read`, because in that case\n+    /// `write` can reach everything that `read` can (and\n+    /// potentially more).\n+    pub fn merge(&mut self, read: R, write: R) -> bool {\n+        let mut changed = false;\n+\n+        if read != write {\n+            let (bit_set_read, bit_set_write) = self.vector.pick2_mut(read, write);\n+\n+            for read_val in bit_set_read.iter() {\n+                changed = changed | bit_set_write.insert(read_val);\n+            }\n+        }\n+\n+        changed\n+    }\n+\n+    /// Iterates through all the columns set to true in a given row of\n+    /// the matrix.\n+    pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n+        self.vector[row].iter()\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct SparseBitSet<I: Idx> {\n+    chunk_bits: BTreeMap<u32, Word>,\n+    _marker: PhantomData<I>,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct SparseChunk<I> {\n+    key: u32,\n+    bits: Word,\n+    _marker: PhantomData<I>,\n+}\n+\n+impl<I: Idx> SparseChunk<I> {\n+    pub fn one(index: I) -> Self {\n+        let index = index.index();\n+        let key_usize = index / 128;\n+        let key = key_usize as u32;\n+        assert_eq!(key as usize, key_usize);\n+        SparseChunk {\n+            key,\n+            bits: 1 << (index % 128),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    pub fn any(&self) -> bool {\n+        self.bits != 0\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = I> {\n+        let base = self.key as usize * 128;\n+        let mut bits = self.bits;\n+        (0..128)\n+            .map(move |i| {\n+                let current_bits = bits;\n+                bits >>= 1;\n+                (i, current_bits)\n+            })\n+            .take_while(|&(_, bits)| bits != 0)\n+            .filter_map(move |(i, bits)| {\n+                if (bits & 1) != 0 {\n+                    Some(I::new(base + i))\n+                } else {\n+                    None\n+                }\n+            })\n+    }\n+}\n+\n+impl<I: Idx> SparseBitSet<I> {\n+    pub fn new() -> Self {\n+        SparseBitSet {\n+            chunk_bits: BTreeMap::new(),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.chunk_bits.len() * 128\n+    }\n+\n+    pub fn contains_chunk(&self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        SparseChunk {\n+            bits: self.chunk_bits\n+                .get(&chunk.key)\n+                .map_or(0, |bits| bits & chunk.bits),\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn insert_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        if chunk.bits == 0 {\n+            return chunk;\n+        }\n+        let bits = self.chunk_bits.entry(chunk.key).or_insert(0);\n+        let old_bits = *bits;\n+        let new_bits = old_bits | chunk.bits;\n+        *bits = new_bits;\n+        let changed = new_bits ^ old_bits;\n+        SparseChunk {\n+            bits: changed,\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn remove_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        if chunk.bits == 0 {\n+            return chunk;\n+        }\n+        let changed = match self.chunk_bits.entry(chunk.key) {\n+            Entry::Occupied(mut bits) => {\n+                let old_bits = *bits.get();\n+                let new_bits = old_bits & !chunk.bits;\n+                if new_bits == 0 {\n+                    bits.remove();\n+                } else {\n+                    bits.insert(new_bits);\n+                }\n+                new_bits ^ old_bits\n+            }\n+            Entry::Vacant(_) => 0,\n+        };\n+        SparseChunk {\n+            bits: changed,\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        self.chunk_bits.clear();\n+    }\n+\n+    pub fn chunks<'a>(&'a self) -> impl Iterator<Item = SparseChunk<I>> + 'a {\n+        self.chunk_bits.iter().map(|(&key, &bits)| SparseChunk {\n+            key,\n+            bits,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    pub fn contains(&self, index: I) -> bool {\n+        self.contains_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn insert(&mut self, index: I) -> bool {\n+        self.insert_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn remove(&mut self, index: I) -> bool {\n+        self.remove_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = I> + 'a {\n+        self.chunks().flat_map(|chunk| chunk.iter())\n+    }\n+}\n+\n #[inline]\n-fn u64s(elements: usize) -> usize {\n-    (elements + 63) / 64\n+fn words(elements: usize) -> usize {\n+    (elements + WORD_BITS - 1) / WORD_BITS\n }\n \n #[inline]\n-fn word_mask(index: usize) -> (usize, u64) {\n-    let word = index / 64;\n-    let mask = 1 << (index % 64);\n+fn word_mask(index: usize) -> (usize, Word) {\n+    let word = index / WORD_BITS;\n+    let mask = 1 << (index % WORD_BITS);\n     (word, mask)\n }\n \n@@ -278,11 +489,12 @@ fn bitvec_iter_works() {\n     bitvec.insert(65);\n     bitvec.insert(66);\n     bitvec.insert(99);\n-    assert_eq!(bitvec.iter().collect::<Vec<_>>(),\n-               [1, 10, 19, 62, 63, 64, 65, 66, 99]);\n+    assert_eq!(\n+        bitvec.iter().collect::<Vec<_>>(),\n+        [1, 10, 19, 62, 63, 64, 65, 66, 99]\n+    );\n }\n \n-\n #[test]\n fn bitvec_iter_works_2() {\n     let mut bitvec = BitVector::new(319);\n@@ -314,24 +526,24 @@ fn union_two_vecs() {\n #[test]\n fn grow() {\n     let mut vec1 = BitVector::new(65);\n-    for index in 0 .. 65 {\n+    for index in 0..65 {\n         assert!(vec1.insert(index));\n         assert!(!vec1.insert(index));\n     }\n     vec1.grow(128);\n \n     // Check if the bits set before growing are still set\n-    for index in 0 .. 65 {\n+    for index in 0..65 {\n         assert!(vec1.contains(index));\n     }\n \n     // Check if the new bits are all un-set\n-    for index in 65 .. 128 {\n+    for index in 65..128 {\n         assert!(!vec1.contains(index));\n     }\n \n     // Check that we can set all new bits without running out of bounds\n-    for index in 65 .. 128 {\n+    for index in 65..128 {\n         assert!(vec1.insert(index));\n         assert!(!vec1.insert(index));\n     }"}, {"sha": "3e94b3f4d302a95029b495b1887b65e6573a753e", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -482,6 +482,21 @@ impl<I: Idx, T> IndexVec<I, T> {\n     pub fn get_mut(&mut self, index: I) -> Option<&mut T> {\n         self.raw.get_mut(index.index())\n     }\n+\n+    /// Return mutable references to two distinct elements, a and b. Panics if a == b.\n+    #[inline]\n+    pub fn pick2_mut(&mut self, a: I, b: I) -> (&mut T, &mut T) {\n+        let (ai, bi) = (a.index(), b.index());\n+        assert!(ai != bi);\n+\n+        if ai < bi {\n+            let (c1, c2) = self.raw.split_at_mut(bi);\n+            (&mut c1[ai], &mut c2[0])\n+        } else {\n+            let (c2, c1) = self.pick2_mut(b, a);\n+            (c1, c2)\n+        }\n+    }\n }\n \n impl<I: Idx, T: Clone> IndexVec<I, T> {"}, {"sha": "eb67c9ce4b7d8be2e614f59df1ff71bb87823e11", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -24,7 +24,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, Resolutions, AllArenas};\n use rustc::traits;\n-use rustc::util::common::{ErrorReported, time};\n+use rustc::util::common::{ErrorReported, time, install_panic_hook};\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_incremental;\n@@ -123,6 +123,8 @@ pub fn compile_input(trans: Box<TransCrate>,\n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n         let crate_name =\n             ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n+        install_panic_hook();\n+\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n             phase_2_configure_and_expand(\n                 sess,"}, {"sha": "ef9b3d38c637cc509cb1a74512b4e32096ba52e9", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 104, "deletions": 136, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -10,7 +10,6 @@\n \n #![allow(non_snake_case)]\n \n-use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n@@ -26,7 +25,6 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::attr;\n use syntax_pos::Span;\n use syntax::codemap;\n \n@@ -353,13 +351,14 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n }\n \n-enum FfiResult {\n+enum FfiResult<'tcx> {\n     FfiSafe,\n-    FfiPhantom,\n-    FfiUnsafe(&'static str),\n-    FfiBadStruct(DefId, &'static str),\n-    FfiBadUnion(DefId, &'static str),\n-    FfiBadEnum(DefId, &'static str),\n+    FfiPhantom(Ty<'tcx>),\n+    FfiUnsafe {\n+        ty: Ty<'tcx>,\n+        reason: &'static str,\n+        help: Option<&'static str>,\n+    },\n }\n \n /// Check if this enum can be safely exported based on the\n@@ -397,23 +396,12 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     false\n }\n \n-fn is_ffi_safe(ty: attr::IntType) -> bool {\n-    match ty {\n-        attr::SignedInt(ast::IntTy::I8) | attr::UnsignedInt(ast::UintTy::U8) |\n-        attr::SignedInt(ast::IntTy::I16) | attr::UnsignedInt(ast::UintTy::U16) |\n-        attr::SignedInt(ast::IntTy::I32) | attr::UnsignedInt(ast::UintTy::U32) |\n-        attr::SignedInt(ast::IntTy::I64) | attr::UnsignedInt(ast::UintTy::U64) |\n-        attr::SignedInt(ast::IntTy::I128) | attr::UnsignedInt(ast::UintTy::U128) => true,\n-        attr::SignedInt(ast::IntTy::Isize) | attr::UnsignedInt(ast::UintTy::Usize) => false\n-    }\n-}\n-\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n     fn check_type_for_ffi(&self,\n                           cache: &mut FxHashSet<Ty<'tcx>>,\n-                          ty: Ty<'tcx>) -> FfiResult {\n+                          ty: Ty<'tcx>) -> FfiResult<'tcx> {\n         use self::FfiResult::*;\n \n         let cx = self.cx.tcx;\n@@ -429,19 +417,25 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         match ty.sty {\n             ty::TyAdt(def, substs) => {\n                 if def.is_phantom_data() {\n-                    return FfiPhantom;\n+                    return FfiPhantom(ty);\n                 }\n                 match def.adt_kind() {\n                     AdtKind::Struct => {\n                         if !def.repr.c() && !def.repr.transparent() {\n-                            return FfiUnsafe(\"found struct without foreign-function-safe \\\n-                                              representation annotation in foreign module, \\\n-                                              consider adding a #[repr(C)] attribute to the type\");\n+                            return FfiUnsafe {\n+                                ty: ty,\n+                                reason: \"this struct has unspecified layout\",\n+                                help: Some(\"consider adding a #[repr(C)] or #[repr(transparent)] \\\n+                                            attribute to this struct\"),\n+                            };\n                         }\n \n                         if def.non_enum_variant().fields.is_empty() {\n-                            return FfiUnsafe(\"found zero-size struct in foreign module, consider \\\n-                                              adding a member to this struct\");\n+                            return FfiUnsafe {\n+                                ty: ty,\n+                                reason: \"this struct has no fields\",\n+                                help: Some(\"consider adding a member to this struct\"),\n+                            };\n                         }\n \n                         // We can't completely trust repr(C) and repr(transparent) markings;\n@@ -467,28 +461,30 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                 FfiSafe => {\n                                     all_phantom = false;\n                                 }\n-                                FfiPhantom => {}\n-                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                FfiPhantom(..) => {}\n+                                FfiUnsafe { .. } => {\n                                     return r;\n                                 }\n-                                FfiUnsafe(s) => {\n-                                    return FfiBadStruct(def.did, s);\n-                                }\n                             }\n                         }\n \n-                        if all_phantom { FfiPhantom } else { FfiSafe }\n+                        if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n                     }\n                     AdtKind::Union => {\n                         if !def.repr.c() {\n-                            return FfiUnsafe(\"found union without foreign-function-safe \\\n-                                              representation annotation in foreign module, \\\n-                                              consider adding a #[repr(C)] attribute to the type\");\n+                            return FfiUnsafe {\n+                                ty: ty,\n+                                reason: \"this union has unspecified layout\",\n+                                help: Some(\"consider adding a #[repr(C)] attribute to this union\"),\n+                            };\n                         }\n \n                         if def.non_enum_variant().fields.is_empty() {\n-                            return FfiUnsafe(\"found zero-size union in foreign module, consider \\\n-                                              adding a member to this union\");\n+                            return FfiUnsafe {\n+                                ty: ty,\n+                                reason: \"this union has no fields\",\n+                                help: Some(\"consider adding a field to this union\"),\n+                            };\n                         }\n \n                         let mut all_phantom = true;\n@@ -501,17 +497,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                 FfiSafe => {\n                                     all_phantom = false;\n                                 }\n-                                FfiPhantom => {}\n-                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                FfiPhantom(..) => {}\n+                                FfiUnsafe { .. } => {\n                                     return r;\n                                 }\n-                                FfiUnsafe(s) => {\n-                                    return FfiBadUnion(def.did, s);\n-                                }\n                             }\n                         }\n \n-                        if all_phantom { FfiPhantom } else { FfiSafe }\n+                        if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n                     }\n                     AdtKind::Enum => {\n                         if def.variants.is_empty() {\n@@ -524,25 +517,13 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if !def.repr.c() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n                             if !is_repr_nullable_ptr(cx, def, substs) {\n-                                return FfiUnsafe(\"found enum without foreign-function-safe \\\n-                                                  representation annotation in foreign \\\n-                                                  module, consider adding a #[repr(...)] \\\n-                                                  attribute to the type\");\n-                            }\n-                        }\n-\n-                        if let Some(int_ty) = def.repr.int {\n-                            if !is_ffi_safe(int_ty) {\n-                                // FIXME: This shouldn't be reachable: we should check\n-                                // this earlier.\n-                                return FfiUnsafe(\"enum has unexpected #[repr(...)] attribute\");\n+                                return FfiUnsafe {\n+                                    ty: ty,\n+                                    reason: \"enum has no representation hint\",\n+                                    help: Some(\"consider adding a #[repr(...)] attribute \\\n+                                                to this enum\"),\n+                                };\n                             }\n-\n-                            // Enum with an explicitly sized discriminant; either\n-                            // a C-style enum or a discriminated union.\n-\n-                            // The layout of enum variants is implicitly repr(C).\n-                            // FIXME: Is that correct?\n                         }\n \n                         // Check the contained variants.\n@@ -554,15 +535,15 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                 let r = self.check_type_for_ffi(cache, arg);\n                                 match r {\n                                     FfiSafe => {}\n-                                    FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                    FfiUnsafe { .. } => {\n                                         return r;\n                                     }\n-                                    FfiPhantom => {\n-                                        return FfiBadEnum(def.did,\n-                                                          \"Found phantom data in enum variant\");\n-                                    }\n-                                    FfiUnsafe(s) => {\n-                                        return FfiBadEnum(def.did, s);\n+                                    FfiPhantom(..) => {\n+                                        return FfiUnsafe {\n+                                            ty: ty,\n+                                            reason: \"this enum contains a PhantomData field\",\n+                                            help: None,\n+                                        };\n                                     }\n                                 }\n                             }\n@@ -572,45 +553,44 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyChar => {\n-                FfiUnsafe(\"found Rust type `char` in foreign module, while \\\n-                           `u32` or `libc::wchar_t` should be used\")\n-            }\n+            ty::TyChar => FfiUnsafe {\n+                ty: ty,\n+                reason: \"the `char` type has no C equivalent\",\n+                help: Some(\"consider using `u32` or `libc::wchar_t` instead\"),\n+            },\n \n-            ty::TyInt(ast::IntTy::I128) => {\n-                FfiUnsafe(\"found Rust type `i128` in foreign module, but \\\n-                           128-bit integers don't currently have a known \\\n-                           stable ABI\")\n-            }\n-\n-            ty::TyUint(ast::UintTy::U128) => {\n-                FfiUnsafe(\"found Rust type `u128` in foreign module, but \\\n-                           128-bit integers don't currently have a known \\\n-                           stable ABI\")\n-            }\n+            ty::TyInt(ast::IntTy::I128) | ty::TyUint(ast::UintTy::U128) => FfiUnsafe {\n+                ty: ty,\n+                reason: \"128-bit integers don't currently have a known stable ABI\",\n+                help: None,\n+            },\n \n             // Primitive types with a stable representation.\n             ty::TyBool | ty::TyInt(..) | ty::TyUint(..) | ty::TyFloat(..) | ty::TyNever => FfiSafe,\n \n-            ty::TySlice(_) => {\n-                FfiUnsafe(\"found Rust slice type in foreign module, \\\n-                           consider using a raw pointer instead\")\n-            }\n-\n-            ty::TyDynamic(..) => {\n-                FfiUnsafe(\"found Rust trait type in foreign module, \\\n-                           consider using a raw pointer instead\")\n-            }\n-\n-            ty::TyStr => {\n-                FfiUnsafe(\"found Rust type `str` in foreign module; \\\n-                           consider using a `*const libc::c_char`\")\n-            }\n-\n-            ty::TyTuple(..) => {\n-                FfiUnsafe(\"found Rust tuple type in foreign module; \\\n-                           consider using a struct instead\")\n-            }\n+            ty::TySlice(_) => FfiUnsafe {\n+                ty: ty,\n+                reason: \"slices have no C equivalent\",\n+                help: Some(\"consider using a raw pointer instead\"),\n+            },\n+\n+            ty::TyDynamic(..) => FfiUnsafe {\n+                ty: ty,\n+                reason: \"trait objects have no C equivalent\",\n+                help: None,\n+            },\n+\n+            ty::TyStr => FfiUnsafe {\n+                ty: ty,\n+                reason: \"string slices have no C equivalent\",\n+                help: Some(\"consider using `*const u8` and a length instead\"),\n+            },\n+\n+            ty::TyTuple(..) => FfiUnsafe {\n+                ty: ty,\n+                reason: \"tuples have unspecified layout\",\n+                help: Some(\"consider using a struct instead\"),\n+            },\n \n             ty::TyRawPtr(ref m) |\n             ty::TyRef(_, ref m) => self.check_type_for_ffi(cache, m.ty),\n@@ -620,9 +600,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::TyFnPtr(sig) => {\n                 match sig.abi() {\n                     Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n-                        return FfiUnsafe(\"found function pointer with Rust calling convention in \\\n-                                          foreign module; consider using an `extern` function \\\n-                                          pointer\")\n+                        return FfiUnsafe {\n+                            ty: ty,\n+                            reason: \"this function pointer has Rust-specific calling convention\",\n+                            help: Some(\"consider using an `fn \\\"extern\\\"(...) -> ...` \\\n+                                        function pointer instead\"),\n+                        }\n                     }\n                     _ => {}\n                 }\n@@ -670,40 +653,25 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         match self.check_type_for_ffi(&mut FxHashSet(), ty) {\n             FfiResult::FfiSafe => {}\n-            FfiResult::FfiPhantom => {\n-                self.cx.span_lint(IMPROPER_CTYPES,\n-                                  sp,\n-                                  &format!(\"found zero-sized type composed only \\\n-                                            of phantom-data in a foreign-function.\"));\n-            }\n-            FfiResult::FfiUnsafe(s) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, sp, s);\n-            }\n-            FfiResult::FfiBadStruct(_, s) => {\n-                // FIXME: This diagnostic is difficult to read, and doesn't\n-                // point at the relevant field.\n+            FfiResult::FfiPhantom(ty) => {\n                 self.cx.span_lint(IMPROPER_CTYPES,\n                                   sp,\n-                                  &format!(\"found non-foreign-function-safe member in struct \\\n-                                            marked #[repr(C)]: {}\",\n-                                           s));\n+                                  &format!(\"`extern` block uses type `{}` which is not FFI-safe: \\\n+                                            composed only of PhantomData\", ty));\n             }\n-            FfiResult::FfiBadUnion(_, s) => {\n-                // FIXME: This diagnostic is difficult to read, and doesn't\n-                // point at the relevant field.\n-                self.cx.span_lint(IMPROPER_CTYPES,\n-                                  sp,\n-                                  &format!(\"found non-foreign-function-safe member in union \\\n-                                            marked #[repr(C)]: {}\",\n-                                           s));\n-            }\n-            FfiResult::FfiBadEnum(_, s) => {\n-                // FIXME: This diagnostic is difficult to read, and doesn't\n-                // point at the relevant variant.\n-                self.cx.span_lint(IMPROPER_CTYPES,\n-                                  sp,\n-                                  &format!(\"found non-foreign-function-safe member in enum: {}\",\n-                                           s));\n+            FfiResult::FfiUnsafe { ty: unsafe_ty, reason, help } => {\n+                let msg = format!(\"`extern` block uses type `{}` which is not FFI-safe: {}\",\n+                                  unsafe_ty, reason);\n+                let mut diag = self.cx.struct_span_lint(IMPROPER_CTYPES, sp, &msg);\n+                if let Some(s) = help {\n+                    diag.help(s);\n+                }\n+                if let ty::TyAdt(def, _) = unsafe_ty.sty {\n+                    if let Some(sp) = self.cx.tcx.hir.span_if_local(def.did) {\n+                        diag.span_note(sp, \"type defined here\");\n+                    }\n+                }\n+                diag.emit();\n             }\n         }\n     }"}, {"sha": "e6f2a43bfc8f79d74ec021fc051b935836c7aa29", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::rc::Rc;\n-use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::bitvec::SparseBitMatrix;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -69,9 +69,7 @@ impl RegionValueElements {\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n     pub(super) fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        (0..self.num_points).map(move |i| {\n-            RegionElementIndex::new(i + self.num_universal_regions)\n-        })\n+        (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n     }\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n@@ -132,7 +130,7 @@ impl RegionValueElements {\n }\n \n /// A newtype for the integers that represent one of the possible\n-/// elements in a region. These are the rows in the `BitMatrix` that\n+/// elements in a region. These are the rows in the `SparseBitMatrix` that\n /// is used to store the values of all regions. They have the following\n /// convention:\n ///\n@@ -154,7 +152,6 @@ pub(super) enum RegionElement {\n     UniversalRegion(RegionVid),\n }\n \n-\n pub(super) trait ToElementIndex {\n     fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n }\n@@ -184,18 +181,18 @@ impl ToElementIndex for RegionElementIndex {\n }\n \n /// Stores the values for a set of regions. These are stored in a\n-/// compact `BitMatrix` representation, with one row per region\n+/// compact `SparseBitMatrix` representation, with one row per region\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n #[derive(Clone)]\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n-    matrix: BitMatrix,\n+    matrix: SparseBitMatrix<RegionVid, RegionElementIndex>,\n \n     /// If cause tracking is enabled, maps from a pair (r, e)\n     /// consisting of a region `r` that contains some element `e` to\n     /// the reason that the element is contained. There should be an\n-    /// entry for every bit set to 1 in `BitMatrix`.\n+    /// entry for every bit set to 1 in `SparseBitMatrix`.\n     causes: Option<CauseMap>,\n }\n \n@@ -214,7 +211,10 @@ impl RegionValues {\n \n         Self {\n             elements: elements.clone(),\n-            matrix: BitMatrix::new(num_region_variables, elements.num_elements()),\n+            matrix: SparseBitMatrix::new(\n+                RegionVid::new(num_region_variables),\n+                RegionElementIndex::new(elements.num_elements()),\n+            ),\n             causes: if track_causes.0 {\n                 Some(CauseMap::default())\n             } else {\n@@ -238,7 +238,7 @@ impl RegionValues {\n     where\n         F: FnOnce(&CauseMap) -> Cause,\n     {\n-        if self.matrix.add(r.index(), i.index()) {\n+        if self.matrix.add(r, i) {\n             debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n \n             if let Some(causes) = &mut self.causes {\n@@ -289,13 +289,12 @@ impl RegionValues {\n         constraint_location: Location,\n         constraint_span: Span,\n     ) -> bool {\n-        // We could optimize this by improving `BitMatrix::merge` so\n+        // We could optimize this by improving `SparseBitMatrix::merge` so\n         // it does not always merge an entire row. That would\n         // complicate causal tracking though.\n         debug!(\n             \"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n-            from_region,\n-            to_region\n+            from_region, to_region\n         );\n         let mut changed = false;\n         for elem in self.elements.all_universal_region_indices() {\n@@ -315,7 +314,7 @@ impl RegionValues {\n     /// True if the region `r` contains the given element.\n     pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n         let i = self.elements.index(elem);\n-        self.matrix.contains(r.index(), i.index())\n+        self.matrix.contains(r, i)\n     }\n \n     /// Iterate over the value of the region `r`, yielding up element\n@@ -325,9 +324,7 @@ impl RegionValues {\n         &'a self,\n         r: RegionVid,\n     ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        self.matrix\n-            .iter(r.index())\n-            .map(move |i| RegionElementIndex::new(i))\n+        self.matrix.iter(r).map(move |i| i)\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n@@ -415,9 +412,7 @@ impl RegionValues {\n             assert_eq!(location1.block, location2.block);\n             str.push_str(&format!(\n                 \"{:?}[{}..={}]\",\n-                location1.block,\n-                location1.statement_index,\n-                location2.statement_index\n+                location1.block, location1.statement_index, location2.statement_index\n             ));\n         }\n     }"}, {"sha": "3f9e9191cf0332b25fa877126477696572a7ec24", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -122,8 +122,9 @@ pub(crate) fn run(cgcx: &CodegenContext,\n             None\n         }\n     };\n-\n-    let mut symbol_white_list = cgcx.exported_symbols[&LOCAL_CRATE]\n+    let exported_symbols = cgcx.exported_symbols\n+        .as_ref().expect(\"needs exported symbols for LTO\");\n+    let mut symbol_white_list = exported_symbols[&LOCAL_CRATE]\n         .iter()\n         .filter_map(symbol_filter)\n         .collect::<Vec<CString>>();\n@@ -156,8 +157,10 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         }\n \n         for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n+            let exported_symbols = cgcx.exported_symbols\n+                .as_ref().expect(\"needs exported symbols for LTO\");\n             symbol_white_list.extend(\n-                cgcx.exported_symbols[&cnum]\n+                exported_symbols[&cnum]\n                     .iter()\n                     .filter_map(symbol_filter));\n "}, {"sha": "af5178eb565dbdd658d88520f766def7c50afbe2", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -333,7 +333,7 @@ pub struct CodegenContext {\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n     pub fewer_names: bool,\n-    pub exported_symbols: Arc<ExportedSymbols>,\n+    pub exported_symbols: Option<Arc<ExportedSymbols>>,\n     pub opts: Arc<config::Options>,\n     pub crate_types: Vec<config::CrateType>,\n     pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n@@ -1394,14 +1394,25 @@ fn start_executing_work(tcx: TyCtxt,\n                         allocator_config: Arc<ModuleConfig>)\n                         -> thread::JoinHandle<Result<CompiledModules, ()>> {\n     let coordinator_send = tcx.tx_to_llvm_workers.clone();\n-    let mut exported_symbols = FxHashMap();\n-    exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n-    for &cnum in tcx.crates().iter() {\n-        exported_symbols.insert(cnum, tcx.exported_symbols(cnum));\n-    }\n-    let exported_symbols = Arc::new(exported_symbols);\n     let sess = tcx.sess;\n \n+    let exported_symbols = match sess.lto() {\n+        Lto::No => None,\n+        Lto::ThinLocal => {\n+            let mut exported_symbols = FxHashMap();\n+            exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n+            Some(Arc::new(exported_symbols))\n+        }\n+        Lto::Yes | Lto::Fat | Lto::Thin => {\n+            let mut exported_symbols = FxHashMap();\n+            exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n+            for &cnum in tcx.crates().iter() {\n+                exported_symbols.insert(cnum, tcx.exported_symbols(cnum));\n+            }\n+            Some(Arc::new(exported_symbols))\n+        }\n+    };\n+\n     // First up, convert our jobserver into a helper thread so we can use normal\n     // mpsc channels to manage our messages and such.\n     // After we've requested tokens then we'll, when we can,"}, {"sha": "794d466ee7cdbf5b47d206efea90f9d90b5a3903", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 139, "deletions": 43, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -17,14 +17,24 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n+use rustc::traits::error_reporting::ArgKind;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use rustc::ty::subst::Substs;\n use rustc::ty::TypeFoldable;\n use std::cmp;\n use std::iter;\n use syntax::abi::Abi;\n+use syntax::codemap::Span;\n use rustc::hir;\n \n+/// What signature do we *expect* the closure to have from context?\n+#[derive(Debug)]\n+struct ExpectedSig<'tcx> {\n+    /// Span that gave us this expectation, if we know that.\n+    cause_span: Option<Span>,\n+    sig: ty::FnSig<'tcx>,\n+}\n+\n struct ClosureSignatures<'tcx> {\n     bound_sig: ty::PolyFnSig<'tcx>,\n     liberated_sig: ty::FnSig<'tcx>,\n@@ -42,8 +52,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     ) -> Ty<'tcx> {\n         debug!(\n             \"check_expr_closure(expr={:?},expected={:?})\",\n-            expr,\n-            expected\n+            expr, expected\n         );\n \n         // It's always helpful for inference if we know the kind of\n@@ -64,12 +73,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         decl: &'gcx hir::FnDecl,\n         body: &'gcx hir::Body,\n         gen: Option<hir::GeneratorMovability>,\n-        expected_sig: Option<ty::FnSig<'tcx>>,\n+        expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> Ty<'tcx> {\n         debug!(\n             \"check_closure(opt_kind={:?}, expected_sig={:?})\",\n-            opt_kind,\n-            expected_sig\n+            opt_kind, expected_sig\n         );\n \n         let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n@@ -109,19 +117,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n         if let Some(GeneratorTypes { yield_ty, interior }) = generator_types {\n-            self.demand_eqtype(expr.span,\n-                               yield_ty,\n-                               substs.generator_yield_ty(expr_def_id, self.tcx));\n-            self.demand_eqtype(expr.span,\n-                               liberated_sig.output(),\n-                               substs.generator_return_ty(expr_def_id, self.tcx));\n+            self.demand_eqtype(\n+                expr.span,\n+                yield_ty,\n+                substs.generator_yield_ty(expr_def_id, self.tcx),\n+            );\n+            self.demand_eqtype(\n+                expr.span,\n+                liberated_sig.output(),\n+                substs.generator_return_ty(expr_def_id, self.tcx),\n+            );\n             return self.tcx.mk_generator(expr_def_id, substs, interior);\n         }\n \n         debug!(\n             \"check_closure: expr.id={:?} closure_type={:?}\",\n-            expr.id,\n-            closure_type\n+            expr.id, closure_type\n         );\n \n         // Tuple up the arguments and insert the resulting function type into\n@@ -138,29 +149,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"check_closure: expr_def_id={:?}, sig={:?}, opt_kind={:?}\",\n-            expr_def_id,\n-            sig,\n-            opt_kind\n+            expr_def_id, sig, opt_kind\n         );\n \n         let sig_fn_ptr_ty = self.tcx.mk_fn_ptr(sig);\n-        self.demand_eqtype(expr.span,\n-                           sig_fn_ptr_ty,\n-                           substs.closure_sig_ty(expr_def_id, self.tcx));\n+        self.demand_eqtype(\n+            expr.span,\n+            sig_fn_ptr_ty,\n+            substs.closure_sig_ty(expr_def_id, self.tcx),\n+        );\n \n         if let Some(kind) = opt_kind {\n-            self.demand_eqtype(expr.span,\n-                               kind.to_ty(self.tcx),\n-                               substs.closure_kind_ty(expr_def_id, self.tcx));\n+            self.demand_eqtype(\n+                expr.span,\n+                kind.to_ty(self.tcx),\n+                substs.closure_kind_ty(expr_def_id, self.tcx),\n+            );\n         }\n \n         closure_type\n     }\n \n+    /// Given the expected type, figures out what it can about this closure we\n+    /// are about to type check:\n     fn deduce_expectations_from_expected_type(\n         &self,\n         expected_ty: Ty<'tcx>,\n-    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+    ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         debug!(\n             \"deduce_expectations_from_expected_type(expected_ty={:?})\",\n             expected_ty\n@@ -172,7 +187,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .projection_bounds()\n                     .filter_map(|pb| {\n                         let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n-                        self.deduce_sig_from_projection(&pb)\n+                        self.deduce_sig_from_projection(None, &pb)\n                     })\n                     .next();\n                 let kind = object_type\n@@ -181,15 +196,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n-            ty::TyFnPtr(sig) => (Some(sig.skip_binder().clone()), Some(ty::ClosureKind::Fn)),\n+            ty::TyFnPtr(sig) => {\n+                let expected_sig = ExpectedSig {\n+                    cause_span: None,\n+                    sig: sig.skip_binder().clone(),\n+                };\n+                (Some(expected_sig), Some(ty::ClosureKind::Fn))\n+            }\n             _ => (None, None),\n         }\n     }\n \n     fn deduce_expectations_from_obligations(\n         &self,\n         expected_vid: ty::TyVid,\n-    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+    ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let fulfillment_cx = self.fulfillment_cx.borrow();\n         // Here `expected_ty` is known to be a type inference variable.\n \n@@ -209,7 +230,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::Projection(ref proj_predicate) => {\n                         let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n                         self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                            .and_then(|_| self.deduce_sig_from_projection(proj_predicate))\n+                            .and_then(|_| {\n+                                self.deduce_sig_from_projection(\n+                                    Some(obligation.cause.span),\n+                                    proj_predicate,\n+                                )\n+                            })\n                     }\n                     _ => None,\n                 }\n@@ -259,10 +285,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n     /// everything we need to know about a closure.\n+    ///\n+    /// The `cause_span` should be the span that caused us to\n+    /// have this expected signature, or `None` if we can't readily\n+    /// know that.\n     fn deduce_sig_from_projection(\n         &self,\n+        cause_span: Option<Span>,\n         projection: &ty::PolyProjectionPredicate<'tcx>,\n-    ) -> Option<ty::FnSig<'tcx>> {\n+    ) -> Option<ExpectedSig<'tcx>> {\n         let tcx = self.tcx;\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n@@ -294,16 +325,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ret_param_ty\n         );\n \n-        let fn_sig = self.tcx.mk_fn_sig(\n+        let sig = self.tcx.mk_fn_sig(\n             input_tys.cloned(),\n             ret_param_ty,\n             false,\n             hir::Unsafety::Normal,\n             Abi::Rust,\n         );\n-        debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n+        debug!(\"deduce_sig_from_projection: sig {:?}\", sig);\n \n-        Some(fn_sig)\n+        Some(ExpectedSig { cause_span, sig })\n     }\n \n     fn self_type_matches_expected_vid(\n@@ -314,8 +345,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let self_ty = self.shallow_resolve(trait_ref.self_ty());\n         debug!(\n             \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n-            trait_ref,\n-            self_ty\n+            trait_ref, self_ty\n         );\n         match self_ty.sty {\n             ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n@@ -328,7 +358,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n         body: &hir::Body,\n-        expected_sig: Option<ty::FnSig<'tcx>>,\n+        expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n         if let Some(e) = expected_sig {\n             self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n@@ -404,7 +434,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n         body: &hir::Body,\n-        expected_sig: ty::FnSig<'tcx>,\n+        expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\n             \"sig_of_closure_with_expectation(expected_sig={:?})\",\n@@ -414,20 +444,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Watch out for some surprises and just ignore the\n         // expectation if things don't see to match up with what we\n         // expect.\n-        if expected_sig.variadic != decl.variadic {\n-            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n-        } else if expected_sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n-            // we could probably handle this case more gracefully\n+        if expected_sig.sig.variadic != decl.variadic {\n             return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+        } else if expected_sig.sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n+            return self.sig_of_closure_with_mismatched_number_of_arguments(\n+                expr_def_id,\n+                decl,\n+                body,\n+                expected_sig,\n+            );\n         }\n \n         // Create a `PolyFnSig`. Note the oddity that late bound\n         // regions appearing free in `expected_sig` are now bound up\n         // in this binder we are creating.\n-        assert!(!expected_sig.has_regions_escaping_depth(1));\n+        assert!(!expected_sig.sig.has_regions_escaping_depth(1));\n         let bound_sig = ty::Binder(self.tcx.mk_fn_sig(\n-            expected_sig.inputs().iter().cloned(),\n-            expected_sig.output(),\n+            expected_sig.sig.inputs().iter().cloned(),\n+            expected_sig.sig.output(),\n             decl.variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,\n@@ -453,6 +487,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         closure_sigs\n     }\n \n+    fn sig_of_closure_with_mismatched_number_of_arguments(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+        expected_sig: ExpectedSig<'tcx>,\n+    ) -> ClosureSignatures<'tcx> {\n+        let expr_map_node = self.tcx.hir.get_if_local(expr_def_id).unwrap();\n+        let expected_args: Vec<_> = expected_sig\n+            .sig\n+            .inputs()\n+            .iter()\n+            .map(|ty| ArgKind::from_expected_ty(ty))\n+            .collect();\n+        let (closure_span, found_args) = self.get_fn_like_arguments(expr_map_node);\n+        let expected_span = expected_sig.cause_span.unwrap_or(closure_span);\n+        self.report_arg_count_mismatch(\n+            expected_span,\n+            Some(closure_span),\n+            expected_args,\n+            found_args,\n+            true,\n+        ).emit();\n+\n+        let error_sig = self.error_sig_of_closure(decl);\n+\n+        self.closure_sigs(expr_def_id, body, error_sig)\n+    }\n+\n     /// Enforce the user's types against the expectation.  See\n     /// `sig_of_closure_with_expectation` for details on the overall\n     /// strategy.\n@@ -558,13 +621,46 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n+    /// Converts the types that the user supplied, in case that doing\n+    /// so should yield an error, but returns back a signature where\n+    /// all parameters are of type `TyErr`.\n+    fn error_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n+        let astconv: &AstConv = self;\n+\n+        let supplied_arguments = decl.inputs.iter().map(|a| {\n+            // Convert the types that the user supplied (if any), but ignore them.\n+            astconv.ast_ty_to_ty(a);\n+            self.tcx.types.err\n+        });\n+\n+        match decl.output {\n+            hir::Return(ref output) => {\n+                astconv.ast_ty_to_ty(&output);\n+            }\n+            hir::DefaultReturn(_) => {}\n+        }\n+\n+        let result = ty::Binder(self.tcx.mk_fn_sig(\n+            supplied_arguments,\n+            self.tcx.types.err,\n+            decl.variadic,\n+            hir::Unsafety::Normal,\n+            Abi::RustCall,\n+        ));\n+\n+        debug!(\"supplied_sig_of_closure: result={:?}\", result);\n+\n+        result\n+    }\n+\n     fn closure_sigs(\n         &self,\n         expr_def_id: DefId,\n         body: &hir::Body,\n         bound_sig: ty::PolyFnSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let liberated_sig = self.tcx().liberate_late_bound_regions(expr_def_id, &bound_sig);\n+        let liberated_sig = self.tcx()\n+            .liberate_late_bound_regions(expr_def_id, &bound_sig);\n         let liberated_sig = self.inh.normalize_associated_types_in(\n             body.value.span,\n             body.value.id,"}, {"sha": "f7cebed5f62cd078045be870344e8d4aa0369f79", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -186,7 +186,7 @@ declare_features! (\n     (active, rustc_attrs, \"1.0.0\", Some(29642)),\n \n     // Allows the use of non lexical lifetimes; RFC 2094\n-    (active, nll, \"1.0.0\", Some(44928)),\n+    (active, nll, \"1.0.0\", Some(43234)),\n \n     // Allows the use of #[allow_internal_unstable]. This is an\n     // attribute on macro_rules! and can't use the attribute handling"}, {"sha": "1a33de844298290f11b3b8dc9f4c50112e6a6a6f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -2630,8 +2630,7 @@ impl<'a> Parser<'a> {\n                     // A tuple index may not have a suffix\n                     self.expect_no_suffix(sp, \"tuple index\", suf);\n \n-                    let dot_span = self.prev_span;\n-                    hi = self.span;\n+                    let idx_span = self.span;\n                     self.bump();\n \n                     let invalid_msg = \"invalid tuple or struct index\";\n@@ -2646,9 +2645,8 @@ impl<'a> Parser<'a> {\n                                                     n.to_string());\n                                 err.emit();\n                             }\n-                            let id = respan(dot_span.to(hi), n);\n-                            let field = self.mk_tup_field(e, id);\n-                            e = self.mk_expr(lo.to(hi), field, ThinVec::new());\n+                            let field = self.mk_tup_field(e, respan(idx_span, n));\n+                            e = self.mk_expr(lo.to(idx_span), field, ThinVec::new());\n                         }\n                         None => {\n                             let prev_span = self.prev_span;"}, {"sha": "f76fa3e4a8ecec2f2029951958a52861b13d851d", "filename": "src/test/compile-fail/issue-14309.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -37,13 +37,13 @@ struct D {\n }\n \n extern \"C\" {\n-    fn foo(x: A); //~ ERROR found struct without foreign-function-safe\n-    fn bar(x: B); //~ ERROR foreign-function-safe\n+    fn foo(x: A); //~ ERROR type `A` which is not FFI-safe\n+    fn bar(x: B); //~ ERROR type `A`\n     fn baz(x: C);\n-    fn qux(x: A2); //~ ERROR foreign-function-safe\n-    fn quux(x: B2); //~ ERROR foreign-function-safe\n+    fn qux(x: A2); //~ ERROR type `A`\n+    fn quux(x: B2); //~ ERROR type `A`\n     fn corge(x: C2);\n-    fn fred(x: D); //~ ERROR foreign-function-safe\n+    fn fred(x: D); //~ ERROR type `A`\n }\n \n fn main() { }"}, {"sha": "f9d01003005e4c045dc6cf16586eb46ae4566216", "filename": "src/test/compile-fail/issue-16250.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fcompile-fail%2Fissue-16250.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fcompile-fail%2Fissue-16250.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16250.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -13,7 +13,7 @@\n pub struct Foo;\n \n extern {\n-    pub fn foo(x: (Foo)); //~ ERROR found struct without\n+    pub fn foo(x: (Foo)); //~ ERROR unspecified layout\n }\n \n fn main() {"}, {"sha": "7b7ffd8fc107cfe108cc1395654bdcf7a296f97c", "filename": "src/test/compile-fail/lint-ctypes-enum.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -16,11 +16,23 @@ enum U { A }\n enum B { C, D }\n enum T { E, F, G }\n \n+#[repr(C)]\n+enum ReprC { A, B, C }\n+\n+#[repr(u8)]\n+enum U8 { A, B, C }\n+\n+#[repr(isize)]\n+enum Isize { A, B, C }\n+\n extern {\n    fn zf(x: Z);\n-   fn uf(x: U); //~ ERROR found enum without foreign-function-safe\n-   fn bf(x: B); //~ ERROR found enum without foreign-function-safe\n-   fn tf(x: T); //~ ERROR found enum without foreign-function-safe\n+   fn uf(x: U); //~ ERROR enum has no representation hint\n+   fn bf(x: B); //~ ERROR enum has no representation hint\n+   fn tf(x: T); //~ ERROR enum has no representation hint\n+   fn reprc(x: ReprC);\n+   fn u8(x: U8);\n+   fn isize(x: Isize);\n }\n \n pub fn main() { }"}, {"sha": "36c42ce1104e0bfbc08ed5ab99b2e1a5171410cf", "filename": "src/test/compile-fail/union/union-repr-c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fcompile-fail%2Funion%2Funion-repr-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fcompile-fail%2Funion%2Funion-repr-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-repr-c.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -22,7 +22,7 @@ union W {\n \n extern \"C\" {\n     static FOREIGN1: U; // OK\n-    static FOREIGN2: W; //~ ERROR found union without foreign-function-safe representation\n+    static FOREIGN2: W; //~ ERROR union has unspecified layout\n }\n \n fn main() {}"}, {"sha": "5e83f3808d8ccd9699eafa8da0b9f35f55ea248d", "filename": "src/test/run-pass/hygiene/issue-47312.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Frun-pass%2Fhygiene%2Fissue-47312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Frun-pass%2Fhygiene%2Fissue-47312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fissue-47312.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+#![allow(unused)]\n+\n+mod foo {\n+    pub macro m($s:tt, $i:tt) {\n+        $s.$i\n+    }\n+}\n+\n+mod bar {\n+    struct S(i32);\n+    fn f() {\n+        let s = S(0);\n+        ::foo::m!(s, 0);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "213a46ded8e765d6ea782b4ed54de1b59de1eec1", "filename": "src/test/run-pass/impl-trait/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -50,6 +50,14 @@ fn closure_hr_elided_return() -> impl Fn(&u32) -> &u32 { |x| x }\n fn closure_pass_through_elided_return(x: impl Fn(&u32) -> &u32) -> impl Fn(&u32) -> &u32 { x }\n fn closure_pass_through_reference_elided(x: &impl Fn(&u32) -> &u32) -> &impl Fn(&u32) -> &u32 { x }\n \n+fn nested_lifetime<'a>(input: &'a str)\n+    -> impl Iterator<Item = impl Iterator<Item = i32> + 'a> + 'a\n+{\n+    input.lines().map(|line| {\n+        line.split_whitespace().map(|cell| cell.parse().unwrap())\n+    })\n+}\n+\n fn pass_through_elision(x: &u32) -> impl Into<&u32> { x }\n fn pass_through_elision_with_fn_ptr(x: &fn(&u32) -> &u32) -> impl Into<&fn(&u32) -> &u32> { x }\n "}, {"sha": "462eaf0341704a66987eb650cb621df47f5acaf0", "filename": "src/test/ui-fulldeps/proc-macro/load-panic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // aux-build:derive-panic.rs\n+// compile-flags:--error-format human\n \n #[macro_use]\n extern crate derive_panic;"}, {"sha": "ab2ab84315a9390a84ecd646fe430c901568b876", "filename": "src/test/ui-fulldeps/proc-macro/load-panic.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.stderr?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -1,7 +1,7 @@\n error: proc-macro derive panicked\n-  --> $DIR/load-panic.rs:16:10\n+  --> $DIR/load-panic.rs:17:10\n    |\n-16 | #[derive(A)]\n+17 | #[derive(A)]\n    |          ^\n    |\n    = help: message: nope!"}, {"sha": "77cb1ef0f5130a29197a9cc53a0d1d3bf61f41fd", "filename": "src/test/ui/lint-ctypes.rs", "status": "renamed", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint-ctypes.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -51,27 +51,27 @@ pub struct TransparentCustomZst(i32, ZeroSize);\n pub struct ZeroSizeWithPhantomData(::std::marker::PhantomData<i32>);\n \n extern {\n-    pub fn ptr_type1(size: *const Foo); //~ ERROR: found struct without\n-    pub fn ptr_type2(size: *const Foo); //~ ERROR: found struct without\n-    pub fn slice_type(p: &[u32]); //~ ERROR: found Rust slice type\n-    pub fn str_type(p: &str); //~ ERROR: found Rust type\n-    pub fn box_type(p: Box<u32>); //~ ERROR found struct without\n-    pub fn char_type(p: char); //~ ERROR found Rust type\n-    pub fn i128_type(p: i128); //~ ERROR found Rust type\n-    pub fn u128_type(p: u128); //~ ERROR found Rust type\n-    pub fn trait_type(p: &Clone); //~ ERROR found Rust trait type\n-    pub fn tuple_type(p: (i32, i32)); //~ ERROR found Rust tuple type\n-    pub fn tuple_type2(p: I32Pair); //~ ERROR found Rust tuple type\n-    pub fn zero_size(p: ZeroSize); //~ ERROR found zero-size struct\n-    pub fn zero_size_phantom(p: ZeroSizeWithPhantomData); //~ ERROR found zero-sized type\n+    pub fn ptr_type1(size: *const Foo); //~ ERROR: uses type `Foo`\n+    pub fn ptr_type2(size: *const Foo); //~ ERROR: uses type `Foo`\n+    pub fn slice_type(p: &[u32]); //~ ERROR: uses type `[u32]`\n+    pub fn str_type(p: &str); //~ ERROR: uses type `str`\n+    pub fn box_type(p: Box<u32>); //~ ERROR uses type `std::boxed::Box<u32>`\n+    pub fn char_type(p: char); //~ ERROR uses type `char`\n+    pub fn i128_type(p: i128); //~ ERROR uses type `i128`\n+    pub fn u128_type(p: u128); //~ ERROR uses type `u128`\n+    pub fn trait_type(p: &Clone); //~ ERROR uses type `std::clone::Clone`\n+    pub fn tuple_type(p: (i32, i32)); //~ ERROR uses type `(i32, i32)`\n+    pub fn tuple_type2(p: I32Pair); //~ ERROR uses type `(i32, i32)`\n+    pub fn zero_size(p: ZeroSize); //~ ERROR struct has no fields\n+    pub fn zero_size_phantom(p: ZeroSizeWithPhantomData); //~ ERROR composed only of PhantomData\n     pub fn zero_size_phantom_toplevel()\n-        -> ::std::marker::PhantomData<bool>; //~ ERROR: found zero-sized type\n-    pub fn fn_type(p: RustFn); //~ ERROR found function pointer with Rust\n-    pub fn fn_type2(p: fn()); //~ ERROR found function pointer with Rust\n-    pub fn fn_contained(p: RustBadRet); //~ ERROR: found struct without\n-    pub fn transparent_i128(p: TransparentI128); //~ ERROR: found Rust type `i128`\n-    pub fn transparent_str(p: TransparentStr); //~ ERROR: found Rust type `str`\n-    pub fn transparent_fn(p: TransparentBadFn); //~ ERROR: found struct without\n+        -> ::std::marker::PhantomData<bool>; //~ ERROR: composed only of PhantomData\n+    pub fn fn_type(p: RustFn); //~ ERROR function pointer has Rust-specific\n+    pub fn fn_type2(p: fn()); //~ ERROR function pointer has Rust-specific\n+    pub fn fn_contained(p: RustBadRet); //~ ERROR: uses type `std::boxed::Box<u32>`\n+    pub fn transparent_i128(p: TransparentI128); //~ ERROR: uses type `i128`\n+    pub fn transparent_str(p: TransparentStr); //~ ERROR: uses type `str`\n+    pub fn transparent_fn(p: TransparentBadFn); //~ ERROR: uses type `std::boxed::Box<u32>`\n \n     pub fn good3(fptr: Option<extern fn()>);\n     pub fn good4(aptr: &[u8; 4 as usize]);", "previous_filename": "src/test/compile-fail/lint-ctypes.rs"}, {"sha": "748c311055fa93df6df287aa79186429fd3e7f3f", "filename": "src/test/ui/lint-ctypes.stderr", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Flint-ctypes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Flint-ctypes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint-ctypes.stderr?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -0,0 +1,170 @@\n+error: `extern` block uses type `Foo` which is not FFI-safe: this struct has unspecified layout\n+  --> $DIR/lint-ctypes.rs:54:28\n+   |\n+54 |     pub fn ptr_type1(size: *const Foo); //~ ERROR: uses type `Foo`\n+   |                            ^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-ctypes.rs:11:9\n+   |\n+11 | #![deny(improper_ctypes)]\n+   |         ^^^^^^^^^^^^^^^\n+   = help: consider adding a #[repr(C)] or #[repr(transparent)] attribute to this struct\n+note: type defined here\n+  --> $DIR/lint-ctypes.rs:32:1\n+   |\n+32 | pub struct Foo;\n+   | ^^^^^^^^^^^^^^^\n+\n+error: `extern` block uses type `Foo` which is not FFI-safe: this struct has unspecified layout\n+  --> $DIR/lint-ctypes.rs:55:28\n+   |\n+55 |     pub fn ptr_type2(size: *const Foo); //~ ERROR: uses type `Foo`\n+   |                            ^^^^^^^^^^\n+   |\n+   = help: consider adding a #[repr(C)] or #[repr(transparent)] attribute to this struct\n+note: type defined here\n+  --> $DIR/lint-ctypes.rs:32:1\n+   |\n+32 | pub struct Foo;\n+   | ^^^^^^^^^^^^^^^\n+\n+error: `extern` block uses type `[u32]` which is not FFI-safe: slices have no C equivalent\n+  --> $DIR/lint-ctypes.rs:56:26\n+   |\n+56 |     pub fn slice_type(p: &[u32]); //~ ERROR: uses type `[u32]`\n+   |                          ^^^^^^\n+   |\n+   = help: consider using a raw pointer instead\n+\n+error: `extern` block uses type `str` which is not FFI-safe: string slices have no C equivalent\n+  --> $DIR/lint-ctypes.rs:57:24\n+   |\n+57 |     pub fn str_type(p: &str); //~ ERROR: uses type `str`\n+   |                        ^^^^\n+   |\n+   = help: consider using `*const u8` and a length instead\n+\n+error: `extern` block uses type `std::boxed::Box<u32>` which is not FFI-safe: this struct has unspecified layout\n+  --> $DIR/lint-ctypes.rs:58:24\n+   |\n+58 |     pub fn box_type(p: Box<u32>); //~ ERROR uses type `std::boxed::Box<u32>`\n+   |                        ^^^^^^^^\n+   |\n+   = help: consider adding a #[repr(C)] or #[repr(transparent)] attribute to this struct\n+\n+error: `extern` block uses type `char` which is not FFI-safe: the `char` type has no C equivalent\n+  --> $DIR/lint-ctypes.rs:59:25\n+   |\n+59 |     pub fn char_type(p: char); //~ ERROR uses type `char`\n+   |                         ^^^^\n+   |\n+   = help: consider using `u32` or `libc::wchar_t` instead\n+\n+error: `extern` block uses type `i128` which is not FFI-safe: 128-bit integers don't currently have a known stable ABI\n+  --> $DIR/lint-ctypes.rs:60:25\n+   |\n+60 |     pub fn i128_type(p: i128); //~ ERROR uses type `i128`\n+   |                         ^^^^\n+\n+error: `extern` block uses type `u128` which is not FFI-safe: 128-bit integers don't currently have a known stable ABI\n+  --> $DIR/lint-ctypes.rs:61:25\n+   |\n+61 |     pub fn u128_type(p: u128); //~ ERROR uses type `u128`\n+   |                         ^^^^\n+\n+error: `extern` block uses type `std::clone::Clone` which is not FFI-safe: trait objects have no C equivalent\n+  --> $DIR/lint-ctypes.rs:62:26\n+   |\n+62 |     pub fn trait_type(p: &Clone); //~ ERROR uses type `std::clone::Clone`\n+   |                          ^^^^^^\n+\n+error: `extern` block uses type `(i32, i32)` which is not FFI-safe: tuples have unspecified layout\n+  --> $DIR/lint-ctypes.rs:63:26\n+   |\n+63 |     pub fn tuple_type(p: (i32, i32)); //~ ERROR uses type `(i32, i32)`\n+   |                          ^^^^^^^^^^\n+   |\n+   = help: consider using a struct instead\n+\n+error: `extern` block uses type `(i32, i32)` which is not FFI-safe: tuples have unspecified layout\n+  --> $DIR/lint-ctypes.rs:64:27\n+   |\n+64 |     pub fn tuple_type2(p: I32Pair); //~ ERROR uses type `(i32, i32)`\n+   |                           ^^^^^^^\n+   |\n+   = help: consider using a struct instead\n+\n+error: `extern` block uses type `ZeroSize` which is not FFI-safe: this struct has no fields\n+  --> $DIR/lint-ctypes.rs:65:25\n+   |\n+65 |     pub fn zero_size(p: ZeroSize); //~ ERROR struct has no fields\n+   |                         ^^^^^^^^\n+   |\n+   = help: consider adding a member to this struct\n+note: type defined here\n+  --> $DIR/lint-ctypes.rs:28:1\n+   |\n+28 | pub struct ZeroSize;\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `extern` block uses type `ZeroSizeWithPhantomData` which is not FFI-safe: composed only of PhantomData\n+  --> $DIR/lint-ctypes.rs:66:33\n+   |\n+66 |     pub fn zero_size_phantom(p: ZeroSizeWithPhantomData); //~ ERROR composed only of PhantomData\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `extern` block uses type `std::marker::PhantomData<bool>` which is not FFI-safe: composed only of PhantomData\n+  --> $DIR/lint-ctypes.rs:68:12\n+   |\n+68 |         -> ::std::marker::PhantomData<bool>; //~ ERROR: composed only of PhantomData\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `extern` block uses type `fn()` which is not FFI-safe: this function pointer has Rust-specific calling convention\n+  --> $DIR/lint-ctypes.rs:69:23\n+   |\n+69 |     pub fn fn_type(p: RustFn); //~ ERROR function pointer has Rust-specific\n+   |                       ^^^^^^\n+   |\n+   = help: consider using an `fn \"extern\"(...) -> ...` function pointer instead\n+\n+error: `extern` block uses type `fn()` which is not FFI-safe: this function pointer has Rust-specific calling convention\n+  --> $DIR/lint-ctypes.rs:70:24\n+   |\n+70 |     pub fn fn_type2(p: fn()); //~ ERROR function pointer has Rust-specific\n+   |                        ^^^^\n+   |\n+   = help: consider using an `fn \"extern\"(...) -> ...` function pointer instead\n+\n+error: `extern` block uses type `std::boxed::Box<u32>` which is not FFI-safe: this struct has unspecified layout\n+  --> $DIR/lint-ctypes.rs:71:28\n+   |\n+71 |     pub fn fn_contained(p: RustBadRet); //~ ERROR: uses type `std::boxed::Box<u32>`\n+   |                            ^^^^^^^^^^\n+   |\n+   = help: consider adding a #[repr(C)] or #[repr(transparent)] attribute to this struct\n+\n+error: `extern` block uses type `i128` which is not FFI-safe: 128-bit integers don't currently have a known stable ABI\n+  --> $DIR/lint-ctypes.rs:72:32\n+   |\n+72 |     pub fn transparent_i128(p: TransparentI128); //~ ERROR: uses type `i128`\n+   |                                ^^^^^^^^^^^^^^^\n+\n+error: `extern` block uses type `str` which is not FFI-safe: string slices have no C equivalent\n+  --> $DIR/lint-ctypes.rs:73:31\n+   |\n+73 |     pub fn transparent_str(p: TransparentStr); //~ ERROR: uses type `str`\n+   |                               ^^^^^^^^^^^^^^\n+   |\n+   = help: consider using `*const u8` and a length instead\n+\n+error: `extern` block uses type `std::boxed::Box<u32>` which is not FFI-safe: this struct has unspecified layout\n+  --> $DIR/lint-ctypes.rs:74:30\n+   |\n+74 |     pub fn transparent_fn(p: TransparentBadFn); //~ ERROR: uses type `std::boxed::Box<u32>`\n+   |                              ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a #[repr(C)] or #[repr(transparent)] attribute to this struct\n+\n+error: aborting due to 20 previous errors\n+"}, {"sha": "b6463ca067b7f5c7eb1faba7e36f396e7ca3e8c8", "filename": "src/test/ui/mismatched_types/closure-arg-count-expected-type-issue-47244.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #47244: in this specific scenario, when the\n+// expected type indicated 1 argument but the closure takes two, we\n+// would (early on) create type variables for the type of `b`. If the\n+// user then attempts to invoke a method on `b`, we would get an error\n+// saying that the type of `b` must be known, which was not very\n+// helpful.\n+\n+use std::collections::HashMap;\n+fn main() {\n+\n+    let m = HashMap::new();\n+    m.insert( \"foo\", \"bar\" );\n+\n+    m.iter().map( |_, b| {\n+        //~^ ERROR closure is expected to take a single 2-tuple\n+\n+        b.to_string()\n+    });\n+}"}, {"sha": "34934b8d19598c43e07d750c32dadc2f68746682", "filename": "src/test/ui/mismatched_types/closure-arg-count-expected-type-issue-47244.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -0,0 +1,14 @@\n+error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count-expected-type-issue-47244.rs:24:14\n+   |\n+24 |     m.iter().map( |_, b| {\n+   |              ^^^  ------ takes 2 distinct arguments\n+   |              |\n+   |              expected closure that takes a single 2-tuple as argument\n+help: change the closure to accept a tuple instead of individual arguments\n+   |\n+24 |     m.iter().map( |(_, b)| {\n+   |                   ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d5e233a720495c52af25d8f6dcc9e55e1193beb9", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -1 +1 @@\n-Subproject commit ce47e529d29f0bf19b31ae80b37b467e42fb97e2\n+Subproject commit d5e233a720495c52af25d8f6dcc9e55e1193beb9"}]}