{"sha": "dd1558f33719facb84726f9489ee9e2abb279e8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMTU1OGYzMzcxOWZhY2I4NDcyNmY5NDg5ZWU5ZTJhYmIyNzllOGI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-19T14:07:40Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-22T14:48:09Z"}, "message": "rustc update and be very selective about what we accept on a deref", "tree": {"sha": "3624c366d0dd0a79ad78f85a2659f2e8019c336c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3624c366d0dd0a79ad78f85a2659f2e8019c336c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd1558f33719facb84726f9489ee9e2abb279e8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1558f33719facb84726f9489ee9e2abb279e8b", "html_url": "https://github.com/rust-lang/rust/commit/dd1558f33719facb84726f9489ee9e2abb279e8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd1558f33719facb84726f9489ee9e2abb279e8b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ae1b9bfeab22038a6c4674be8adb9b0606dea16", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae1b9bfeab22038a6c4674be8adb9b0606dea16", "html_url": "https://github.com/rust-lang/rust/commit/1ae1b9bfeab22038a6c4674be8adb9b0606dea16"}], "stats": {"total": 282, "additions": 207, "deletions": 75}, "files": [{"sha": "6ca64356ff9f20a27ce4b98506b8bfec047269d4", "filename": "src/lib.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -434,7 +434,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn memory_deallocated(\n-        alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        alloc: &mut Allocation<Borrow, Self::AllocExtra>,\n         ptr: Pointer<Borrow>,\n     ) -> EvalResult<'tcx> {\n         alloc.extra.memory_deallocated(ptr)\n@@ -443,32 +443,38 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn tag_reference(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n-        pointee_size: Size,\n+        place: MemPlace<Borrow>,\n+        ty: Ty<'tcx>,\n+        size: Size,\n         mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Borrow> {\n-        if !ecx.machine.validate {\n+    ) -> EvalResult<'tcx, MemPlace<Borrow>> {\n+        if !ecx.machine.validate || size == Size::ZERO {\n             // No tracking\n-            Ok(Borrow::default())\n+            Ok(place)\n         } else {\n-            ecx.tag_reference(ptr, pointee_ty, pointee_size, mutability)\n+            let ptr = place.ptr.to_ptr()?;\n+            let tag = ecx.tag_reference(ptr, ty, size, mutability.into())?;\n+            let ptr = Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag));\n+            Ok(MemPlace { ptr, ..place })\n         }\n     }\n \n     #[inline(always)]\n     fn tag_dereference(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n-        pointee_size: Size,\n+        place: MemPlace<Borrow>,\n+        ty: Ty<'tcx>,\n+        size: Size,\n         mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Borrow> {\n-        if !ecx.machine.validate {\n+    ) -> EvalResult<'tcx, MemPlace<Borrow>> {\n+        if !ecx.machine.validate || size == Size::ZERO {\n             // No tracking\n-            Ok(Borrow::default())\n+            Ok(place)\n         } else {\n-            ecx.tag_dereference(ptr, pointee_ty, pointee_size, mutability)\n+            let ptr = place.ptr.to_ptr()?;\n+            let tag = ecx.tag_dereference(ptr, ty, size, mutability.into())?;\n+            let ptr = Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag));\n+            Ok(MemPlace { ptr, ..place })\n         }\n     }\n }"}, {"sha": "3ed3f6d9540f525f50384d7d1cfe158715f9ba8d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 164, "deletions": 40, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -1,7 +1,6 @@\n use std::cell::{Cell, RefCell};\n \n-use rustc::ty::{self, Ty, layout::Size};\n-use rustc::mir;\n+use rustc::ty::{Ty, layout::Size};\n use rustc::hir;\n \n use super::{\n@@ -65,6 +64,24 @@ impl Default for Borrow {\n     }\n }\n \n+/// What kind of reference are we talking about?\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum RefKind {\n+    Mut,\n+    Shr,\n+    Raw,\n+}\n+\n+impl From<Option<hir::Mutability>> for RefKind {\n+    fn from(mutbl: Option<hir::Mutability>) -> Self {\n+        match mutbl {\n+            None => RefKind::Raw,\n+            Some(hir::MutMutable) => RefKind::Mut,\n+            Some(hir::MutImmutable) => RefKind::Shr,\n+        }\n+    }\n+}\n+\n /// Extra global machine state\n #[derive(Clone, Debug)]\n pub struct State {\n@@ -101,6 +118,9 @@ pub struct Stacks {\n \n /// Core operations\n impl<'tcx> Stack {\n+    /// Check if `bor` is currently active.  We accept a `Raw` on a frozen location\n+    /// because this could be a shared (re)borrow.  If you want to mutate, this\n+    /// is not the right function to call!\n     fn check(&self, bor: Borrow) -> bool {\n         match bor {\n             Borrow::Frz(acc_t) =>\n@@ -116,8 +136,33 @@ impl<'tcx> Stack {\n         }\n     }\n \n+    /// Check if `bor` could be activated by unfreezing and popping.\n+    /// This should be in sync with `reactivate`!\n+    fn reactivatable(&self, bor: Borrow) -> bool {\n+        if self.check(bor) {\n+            return true;\n+        }\n+\n+        let acc_m = match bor {\n+            Borrow::Frz(_) => return false,\n+            Borrow::Mut(acc_m) => acc_m\n+        };\n+        // This is where we would unfreeze.\n+        for &itm in self.borrows.iter().rev() {\n+            match itm {\n+                BorStackItem::FnBarrier(_) => return false,\n+                BorStackItem::Mut(loc_m) => {\n+                    if loc_m == acc_m { return true; }\n+                    // Go on looking.\n+                }\n+            }\n+        }\n+        // Simulate a \"virtual raw\" element at the bottom of the stack.\n+        acc_m.is_raw()\n+    }\n+\n     /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n-    /// unfreeze this location (because we are about to push a `Uniq`).\n+    /// unfreeze this location (because we are about to mutate, so a frozen `Raw` is not okay).\n     fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n         // Unless mutation is bound to happen, do NOT change anything if `bor` is already active.\n         // In particular, if it is a `Mut(Raw)` and we are frozen, this should be a NOP.\n@@ -126,15 +171,25 @@ impl<'tcx> Stack {\n         }\n \n         let acc_m = match bor {\n-            Borrow::Frz(_) =>\n+            Borrow::Frz(since) =>\n                 if force_mut {\n                     return err!(MachineError(format!(\"Using a shared borrow for mutation\")))\n                 } else {\n-                    return err!(MachineError(format!(\"Location should be frozen but it is not\")))\n+                    return err!(MachineError(format!(\n+                        \"Location should be frozen since {} but {}\",\n+                        since,\n+                        match self.frozen_since {\n+                            None => format!(\"it is not frozen at all\"),\n+                            Some(since) => format!(\"it is only frozen since {}\", since),\n+                        }\n+                    )))\n                 }\n             Borrow::Mut(acc_m) => acc_m,\n         };\n         // We definitely have to unfreeze this, even if we use the topmost item.\n+        if self.frozen_since.is_some() {\n+            trace!(\"reactivate: Unfreezing\");\n+        }\n         self.frozen_since = None;\n         // Pop until we see the one we are looking for.\n         while let Some(&itm) = self.borrows.last() {\n@@ -157,21 +212,33 @@ impl<'tcx> Stack {\n         }\n     }\n \n+    /// Initiate `bor`; mostly this means freezing or pushing.\n     fn initiate(&mut self, bor: Borrow) -> EvalResult<'tcx> {\n         match bor {\n             Borrow::Frz(t) => {\n-                trace!(\"initiate: Freezing\");\n                 match self.frozen_since {\n-                    None => self.frozen_since = Some(t),\n-                    Some(since) => assert!(since <= t),\n+                    None => {\n+                        trace!(\"initiate: Freezing\");\n+                        self.frozen_since = Some(t);\n+                    }\n+                    Some(since) => {\n+                        trace!(\"initiate: Already frozen\");\n+                        assert!(since <= t);\n+                    }\n                 }\n             }\n             Borrow::Mut(m) => {\n-                trace!(\"initiate: Pushing {:?}\", bor);\n                 match self.frozen_since {\n-                    None => self.borrows.push(BorStackItem::Mut(m)),\n+                    None => {\n+                        trace!(\"initiate: Pushing {:?}\", bor);\n+                        self.borrows.push(BorStackItem::Mut(m))\n+                    }\n+                    Some(_) if m.is_raw() =>\n+                        // We only ever initiate right after activating the ref we come from.\n+                        // If the source ref is fine being frozen, then a raw ref we create\n+                        // from it is fine with this as well.\n+                        trace!(\"initiate: Initiating a raw on a frozen location, not doing a thing\"),\n                     Some(_) =>\n-                        // FIXME: Do we want an exception for raw borrows?\n                         return err!(MachineError(format!(\"Trying to mutate frozen location\")))\n                 }\n             }\n@@ -223,13 +290,17 @@ impl<'tcx> Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n         new_bor: Borrow,\n+        permit_redundant: bool,\n     ) -> EvalResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            if stack.check(new_bor) {\n+            if permit_redundant && stack.check(new_bor) {\n                 // The new borrow is already active!  This can happen when creating multiple\n                 // shared references from the same mutable reference.  Do nothing.\n+                trace!(\"reborrow: New borrow {:?} is already active, not doing a thing\", new_bor);\n             } else {\n+                // If we are creating a uniq ref, we certainly want to unfreeze.\n+                // Even if we are doing so from a raw.\n                 // FIXME: The blog post says we should `reset` if this is a local.\n                 stack.reactivate(ptr.tag, /*force_mut*/new_bor.is_uniq())?;\n                 stack.initiate(new_bor)?;\n@@ -241,39 +312,40 @@ impl<'tcx> Stacks {\n }\n \n pub trait EvalContextExt<'tcx> {\n+    fn tag_for_pointee(\n+        &self,\n+        pointee_ty: Ty<'tcx>,\n+        ref_kind: RefKind,\n+    ) -> Borrow;\n+\n     fn tag_reference(\n-        &mut self,\n+        &self,\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        mutability: Option<hir::Mutability>,\n+        ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow>;\n \n+\n     fn tag_dereference(\n         &self,\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        mutability: Option<hir::Mutability>,\n+        ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow>;\n-\n-    fn tag_for_pointee(\n-        &self,\n-        pointee_ty: Ty<'tcx>,\n-        borrow_kind: Option<hir::Mutability>,\n-    ) -> Borrow;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn tag_for_pointee(\n         &self,\n         pointee_ty: Ty<'tcx>,\n-        borrow_kind: Option<hir::Mutability>,\n+        ref_kind: RefKind,\n     ) -> Borrow {\n         let time = self.machine.stacked_borrows.increment_clock();\n-        match borrow_kind {\n-            Some(hir::MutMutable) => Borrow::Mut(Mut::Uniq(time)),\n-            Some(hir::MutImmutable) =>\n+        match ref_kind {\n+            RefKind::Mut => Borrow::Mut(Mut::Uniq(time)),\n+            RefKind::Shr =>\n                 // FIXME This does not do enough checking when only part of the data has\n                 // interior mutability. When the type is `(i32, Cell<i32>)`, we want the\n                 // first field to be frozen but not the second.\n@@ -283,48 +355,100 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     // Shared reference with interior mutability.\n                     Borrow::Mut(Mut::Raw)\n                 },\n-            None => Borrow::Mut(Mut::Raw),\n+            RefKind::Raw => Borrow::Mut(Mut::Raw),\n         }\n     }\n \n     /// Called for place-to-value conversion.\n     fn tag_reference(\n-        &mut self,\n+        &self,\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        mutability: Option<hir::Mutability>,\n+        ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow> {\n-        let new_bor = self.tag_for_pointee(pointee_ty, mutability);\n+        let new_bor = self.tag_for_pointee(pointee_ty, ref_kind);\n         trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}, size {}): {:?}\",\n-            mutability, ptr, pointee_ty, size.bytes(), new_bor);\n+            ref_kind, ptr, pointee_ty, size.bytes(), new_bor);\n \n         // Make sure this reference is not dangling or so\n         self.memory.check_bounds(ptr, size, false)?;\n \n         // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n         // memory.\n         let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        alloc.extra.reborrow(ptr, size, new_bor)?;\n+        let permit_redundant = ref_kind == RefKind::Shr; // redundant shared refs are okay\n+        alloc.extra.reborrow(ptr, size, new_bor, permit_redundant)?;\n \n         Ok(new_bor)\n     }\n \n     /// Called for value-to-place conversion.\n+    ///\n+    /// Note that this does NOT mean that all this memory will actually get accessed/referenced!\n+    /// We could be in the middle of `&(*var).1`.\n     fn tag_dereference(\n         &self,\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        mutability: Option<hir::Mutability>,\n+        ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow> {\n-        // If this is a raw situation, forget about the tag.\n-        Ok(if mutability.is_none() {\n-            trace!(\"tag_dereference: Erasing tag for {:?} (pointee {})\", ptr, pointee_ty);\n-            Borrow::Mut(Mut::Raw)\n-        } else {\n-            // FIXME: Do we want to adjust the tag if it does not match the type?\n-            ptr.tag\n-        })\n+        // In principle we should not have to do anything here.  However, with transmutes involved,\n+        // it can happen that the tag of `ptr` does not actually match `ref_kind`, and we\n+        // should adjust for that.\n+        // Notably, the compiler can introduce such transmutes by optimizing away `&[mut]*`.\n+        // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n+        match (ref_kind, ptr.tag) {\n+            (RefKind::Raw, Borrow::Mut(Mut::Raw)) |\n+            (RefKind::Mut, Borrow::Mut(Mut::Uniq(_))) |\n+            (RefKind::Shr, Borrow::Frz(_)) |\n+            (RefKind::Shr, Borrow::Mut(Mut::Raw)) => {\n+                // Expected combinations.  Nothing to do.\n+                // FIXME: We probably shouldn't accept this if we got a raw shr without\n+                // interior mutability.\n+            }\n+            (_, Borrow::Mut(Mut::Raw)) => {\n+                // Raw transmuted to (shr/mut) ref.  Keep this as raw access.\n+                // We cannot reborrow here; there might be a raw in `&(*var).1` where\n+                // `var` is an `&mut`.  The other field of the struct might be already frozen,\n+                // also using `var`, and that would be okay.\n+            }\n+            (RefKind::Raw, _) => {\n+                // Someone transmuted a ref to a raw.  Treat this like a ref, their fault.\n+            }\n+            (RefKind::Shr, Borrow::Mut(Mut::Uniq(_))) => {\n+                // A mut got transmuted to shr.  High time we freeze this location!\n+                // Make this a delayed reborrow.  Redundant reborows to shr are okay,\n+                // so we do not have to be worried about doing too much.\n+                trace!(\"tag_dereference: Lazy freezing of {:?}\", ptr);\n+                return self.tag_reference(ptr, pointee_ty, size, ref_kind);\n+            }\n+            (RefKind::Mut, Borrow::Frz(_)) => {\n+                // This is just invalid.\n+                // If we ever allow this, we have to consider what we do when a turn a\n+                // `Raw`-tagged `&mut` into a raw pointer pointing to a frozen location.\n+                // We probably do not want to allow that, but we have to allow\n+                // turning a `Raw`-tagged `&` into a raw ptr to a frozen location.\n+                return err!(MachineError(format!(\"Encountered mutable reference with frozen tag {:?}\", ptr.tag)))\n+            }\n+        }\n+        // Even if we don't touch the tag, this operation is only okay if we *could*\n+        // activate it.  Also it must not be dangling.\n+        self.memory.check_bounds(ptr, size, false)?;\n+        let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let mut stacks = alloc.extra.stacks.borrow_mut();\n+        // We need `iter_mut` because `iter` would skip gaps!\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            // We accept &mut to a frozen location here, that is just normal.  There might\n+            // be shared reborrows that we are about to invalidate with this access.\n+            // We cannot invalidate them aggressively here because the deref might also be\n+            // to just create more shared refs.\n+            if !stack.reactivatable(ptr.tag) {\n+                return err!(MachineError(format!(\"Encountered {:?} reference with non-reactivatable tag {:?}\", ref_kind, ptr.tag)))\n+            }\n+        }\n+        // All is good.\n+        Ok(ptr.tag)\n     }\n }"}, {"sha": "3fcf20e156256177f057f50d3934b1e9a36b3cee", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -11,5 +11,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR should be frozen\n+    let _val = *target_alias; //~ ERROR Shr reference with non-reactivatable tag Frz\n }"}, {"sha": "5f729af30bbe618708f7c4cc5c9147a1dcb3ac6d", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     let v = vec![0,1,2];\n     let v1 = safe::as_mut_slice(&v);\n     let v2 = safe::as_mut_slice(&v);\n-    v1[1] = 5; //~ ERROR does not exist on the stack\n+    v1[1] = 5; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n     v1[1] = 6;\n }"}, {"sha": "0a890b1cebaa1381d250ab914393845e6d2dfe8e", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -11,6 +11,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n+            //~^ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }\n@@ -19,6 +20,6 @@ mod safe {\n fn main() {\n     let mut array = [1,2,3,4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n-    a[1] = 5; //~ ERROR does not exist on the stack\n+    a[1] = 5;\n     b[1] = 6;\n }"}, {"sha": "6a7ccc84012c667e0bcadff5bc1635b57ea9e11c", "filename": "tests/compile-fail/stacked_borrows/illegal_write.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ae1b9bfeab22038a6c4674be8adb9b0606dea16/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae1b9bfeab22038a6c4674be8adb9b0606dea16/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs?ref=1ae1b9bfeab22038a6c4674be8adb9b0606dea16", "patch": "@@ -1,11 +0,0 @@\n-fn evil(x: &u32) {\n-    let x : &mut u32 = unsafe { &mut *(x as *const _ as *mut _) };\n-    *x = 42; // mutating shared ref without `UnsafeCell`\n-}\n-\n-fn main() {\n-    let target = 42;\n-    let ref_ = &target;\n-    evil(ref_); // invalidates shared ref\n-    let _x = *ref_; //~ ERROR should be frozen\n-}"}, {"sha": "22648ba71184d981d6f1f9fafac6e9eb0e5719e9", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     drop(&mut *target); // reborrow\n     // Now make sure our ref is still the only one\n     unsafe { *target2 = 13; } // invalidate our ref\n-    let _val = *target; //~ ERROR does not exist on the stack\n+    let _val = *target; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n }"}, {"sha": "678b9b21ba8c40f017408fc33b96da359ca9350e", "filename": "tests/compile-fail/stacked_borrows/pointer_smuggling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -18,5 +18,5 @@ fn main() {\n     fun1(val);\n     *val = 2; // this invalidates any raw ptrs `fun1` might have created.\n     fun2(); // if they now use a raw ptr they break our reference\n-    *val = 3; //~ ERROR does not exist on the stack\n+    *val = 3; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n }"}, {"sha": "5098f493ccd737cebf29602419140c4bf1fd70ad", "filename": "tests/compile-fail/stacked_borrows/shared_confusion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -13,7 +13,7 @@ fn test(r: &mut RefCell<i32>) {\n     }\n     // Our old raw should be dead by now\n     unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n-    *x_inner = 12; //~ ERROR does not exist on the stack\n+    *x_inner = 12; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n }\n \n fn main() {"}, {"sha": "c758926458651c30b11dcd313de3d597ed3069bb", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -1,3 +1,6 @@\n+// Validation detects that we are casting & to &mut and so it changes why we fail\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n static X: usize = 5;\n \n #[allow(mutable_transmutes)]"}, {"sha": "c9857b20592e4410207eed01c322aabf857c8338", "filename": "tests/compile-fail/static_memory_modification2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -1,5 +1,5 @@\n // Validation detects that we are casting & to &mut and so it changes why we fail\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n use std::mem::transmute;\n "}, {"sha": "41a62787296f066a54c37772fc4676ecd5bbbded", "filename": "tests/compile-fail/static_memory_modification3.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -1,3 +1,6 @@\n+// Validation detects that we are casting & to &mut and so it changes why we fail\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n use std::mem::transmute;\n \n #[allow(mutable_transmutes)]"}, {"sha": "47317afd36ec9899fa19e0446fe920978b4cc28c", "filename": "tests/compile-fail/unaligned_ptr_cast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -1,3 +1,6 @@\n+// This should fail even without validation\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n fn main() {\n     let x = &2u16;\n     let x = x as *const _ as *const u32;"}, {"sha": "d146f21dfe60fd7e50820ac0d35c7abe063f829f", "filename": "tests/compile-fail/unaligned_ptr_cast2.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -1,3 +1,6 @@\n+// This should fail even without validation\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n fn main() {\n     let x = &2u16;\n     let x = x as *const _ as *const *const u8;"}, {"sha": "f86fef9454e82891f1b8e15a3450788b18b1a3fa", "filename": "tests/compile-fail/validity/undef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -1,5 +1,5 @@\n #![allow(unused_variables)]\n-// error-pattern: encountered undefined data in pointer\n+// error-pattern: encountered undefined address in pointer\n \n use std::mem;\n "}, {"sha": "0f4c945c85b498bfba891b2ed17dfd91e1d61ce0", "filename": "tests/compile-fail/zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1558f33719facb84726f9489ee9e2abb279e8b/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=dd1558f33719facb84726f9489ee9e2abb279e8b", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x = &() as *const () as *const i32;\n-    let _ = unsafe { *x }; //~ ERROR tried to access memory with alignment 1, but alignment 4 is required\n+    let _ = unsafe { *x }; //~ ERROR outside bounds of allocation\n }"}]}