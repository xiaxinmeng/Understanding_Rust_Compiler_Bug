{"sha": "a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNzBiODAxNGNiZDNhZjZlMDNmN2Y4MDhhMmZlYTFlOWYyMmVkODg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-10-21T20:18:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-11-03T00:57:28Z"}, "message": "rustbuild: Rewrite user-facing interface\n\nThis commit is a rewrite of the user-facing interface to the rustbuild build\nsystem. The intention here is to make it much easier to compile/test the project\nwithout having to remember weird rule names and such. An overall view of the new\ninterface is:\n\n    # build everything\n    ./x.py build\n\n    # document everyting\n    ./x.py doc\n\n    # test everything\n    ./x.py test\n\n    # test libstd\n    ./x.py test src/libstd\n\n    # build libcore stage0\n    ./x.py build src/libcore --stage 0\n\n    # run stage1 run-pass tests\n    ./x.py test src/test/run-pass --stage 1\n\nThe `src/bootstrap/bootstrap.py` script is now aliased as a top-level `x.py`\nscript. This `x` was chosen to be both short and easily tab-completable (no\ncollisions in that namespace!). The build system now accepts a \"subcommand\" of\nwhat to do next, the main ones being build/doc/test.\n\nEach subcommand then receives an optional list of arguments. These arguments are\npaths in the source repo of what to work with. That is, if you want to test a\ndirectory, you just pass that directory as an argument.\n\nThe purpose of this rewrite is to do away with all of the arcane renames like\n\"rpass\" is the \"run-pass\" suite, \"cfail\" is the \"compile-fail\" suite, etc. By\nsimply working with directories and files it's much more intuitive of how to run\na test (just pass it as an argument).\n\nThe rustbuild step/dependency management was also rewritten along the way to\nmake this easy to work with and define, but that's largely just a refactoring of\nwhat was there before.\n\nThe *intention* is that this support is extended for arbitrary files (e.g.\n`src/test/run-pass/my-test-case.rs`), but that isn't quite implemented just yet.\nInstead directories work for now but we can follow up with stricter path\nfiltering logic to plumb through all the arguments.", "tree": {"sha": "4bfaccfb9f5457555ea87fbbd67039328aa74563", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bfaccfb9f5457555ea87fbbd67039328aa74563"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "html_url": "https://github.com/rust-lang/rust/commit/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5665bdf3e3953a3fe67e047794913a0c88a83bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/5665bdf3e3953a3fe67e047794913a0c88a83bde", "html_url": "https://github.com/rust-lang/rust/commit/5665bdf3e3953a3fe67e047794913a0c88a83bde"}], "stats": {"total": 2121, "additions": 1136, "deletions": 985}, "files": [{"sha": "7360651095bb581d01a575b071c7a91ba8db7585", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -127,7 +127,7 @@ ones from MSYS if you have it installed). You'll also need Visual Studio 2013 or\n newer with the C++ tools. Then all you need to do is to kick off rustbuild.\n \n ```\n-python .\\src\\bootstrap\\bootstrap.py\n+python x.py build\n ```\n \n Currently rustbuild only works with some known versions of Visual Studio. If you\n@@ -137,7 +137,7 @@ by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```\n CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n-python .\\src\\bootstrap\\bootstrap.py\n+python x.py build\n ```\n \n ## Building Documentation"}, {"sha": "c3a8923c6de5671bfc1439ca3e38a612d4eaeb77", "filename": "src/Cargo.lock", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -40,9 +40,9 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -63,7 +63,7 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.17\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -131,11 +131,6 @@ dependencies = [\n name = \"fmt_macros\"\n version = \"0.0.0\"\n \n-[[package]]\n-name = \"gcc\"\n-version = \"0.3.38\"\n-source = \"git+https://github.com/alexcrichton/gcc-rs#be620ac6d3ddb498cd0c700d5312c6a4c3c19597\"\n-\n [[package]]\n name = \"gcc\"\n version = \"0.3.38\"\n@@ -189,7 +184,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"linkchecker\"\n version = \"0.1.0\"\n dependencies = [\n- \"url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -725,7 +720,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"url\"\n-version = \"1.2.2\"\n+version = \"1.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -743,10 +738,9 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n-\"checksum cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dfcf5bcece56ef953b8ea042509e9dcbdfe97820b7e20d86beb53df30ed94978\"\n+\"checksum cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\" = \"<none>\"\n \"checksum gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1053236e00ce4f668aeca4a769a09b3bf5a682d802abd6f3cb39374f6b162c11\"\n@@ -760,6 +754,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n \"checksum unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1f7ceb96afdfeedee42bade65a0d585a6a0106f681b6749c8ff4daa8df30b3f\"\n \"checksum unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"26643a2f83bac55f1976fb716c10234485f9202dcd65cfbdf9da49867b271172\"\n-\"checksum url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ba5a45db1d2e0effb7a1c00cc73ffc63a973da8c7d1fcd5b46f24285ade6c54\"\n+\"checksum url 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48ccf7bd87a81b769cf84ad556e034541fb90e1cd6d4bc375c822ed9500cd9d7\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "9d44ca033e45dfc936776189201c213aa739e398", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -27,7 +27,7 @@ num_cpus = \"0.2\"\n toml = \"0.1\"\n getopts = \"0.2\"\n rustc-serialize = \"0.3\"\n-gcc = { git = \"https://github.com/alexcrichton/gcc-rs\" }\n+gcc = \"0.3.36\"\n libc = \"0.2\"\n md5 = \"0.1\"\n "}, {"sha": "f73f41ffae29df50716f05e79b207ff759a88465", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -10,24 +10,72 @@ system.\n \n ## Using rustbuild\n \n-When configuring Rust via `./configure`, pass the following to enable building\n-via this build system:\n+The rustbuild build system has a primary entry point, a top level `x.py` script:\n \n ```\n-./configure --enable-rustbuild\n-make\n+python ./x.py build\n ```\n \n-Afterwards the `Makefile` which is generated will have a few commands like\n-`make check`, `make tidy`, etc. For finer-grained control, the\n-`bootstrap.py` entry point can be used:\n+Note that if you're on Unix you should be able to execute the script directly:\n \n ```\n-python src/bootstrap/bootstrap.py\n+./x.py build\n ```\n \n-This accepts a number of options like `--stage` and `--step` which can configure\n-what's actually being done.\n+The script accepts commands, flags, and filters to determine what to do:\n+\n+* `build` - a general purpose command for compiling code. Alone `build` will\n+  bootstrap the entire compiler, and otherwise arguments passed indicate what to\n+  build. For example:\n+\n+  ```\n+  # build the whole compiler\n+  ./x.py build\n+\n+  # build the stage1 compier\n+  ./x.py build --stage 1\n+\n+  # build stage0 libstd\n+  ./x.py build --stage 0 src/libstd\n+\n+  # build a particular crate in stage0\n+  ./x.py build --stage 0 src/libtest\n+  ```\n+\n+* `test` - a command for executing unit tests. Like the `build` command this\n+  will execute the entire test suite by default, and otherwise it can be used to\n+  select which test suite is run:\n+\n+  ```\n+  # run all unit tests\n+  ./x.py test\n+\n+  # execute the run-pass test suite\n+  ./x.py test src/test/run-pass\n+\n+  # execute only some tests in the run-pass test suite\n+  ./x.py test src/test/run-pass --filter my-filter\n+\n+  # execute tests in the standard library in stage0\n+  ./x.py test --stage 0 src/libstd\n+\n+  # execute all doc tests\n+  ./x.py test src/doc\n+  ```\n+\n+* `doc` - a command for building documentation. Like above can take arguments\n+  for what to document.\n+\n+If you're more used to `./configure` and `make`, however, then you can also\n+configure the build system to use rustbuild instead of the old makefiles:\n+\n+```\n+./configure --enable-rustbuild\n+make\n+```\n+\n+Afterwards the `Makefile` which is generated will have a few commands like\n+`make check`, `make tidy`, etc.\n \n ## Configuring rustbuild\n \n@@ -47,7 +95,7 @@ being invoked manually (via the python script).\n The rustbuild build system goes through a few phases to actually build the\n compiler. What actually happens when you invoke rustbuild is:\n \n-1. The entry point script, `src/bootstrap/bootstrap.py` is run. This script is\n+1. The entry point script, `x.py` is run. This script is\n    responsible for downloading the stage0 compiler/Cargo binaries, and it then\n    compiles the build system itself (this folder). Finally, it then invokes the\n    actual `bootstrap` binary build system."}, {"sha": "76bbb9d22e08217bbac1725f8f25bcb979472585", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -399,12 +399,10 @@ def main():\n \n     # Run the bootstrap\n     args = [os.path.join(rb.build_dir, \"bootstrap/debug/bootstrap\")]\n-    args.append('--src')\n-    args.append(rb.rust_root)\n-    args.append('--build')\n-    args.append(rb.build)\n     args.extend(sys.argv[1:])\n     env = os.environ.copy()\n+    env[\"BUILD\"] = rb.build\n+    env[\"SRC\"] = rb.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     rb.run(args, env)\n "}, {"sha": "e5b666ab3b6890bc36415b40d373c6b14a1dd7a1", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 25, "deletions": 66, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -13,44 +13,19 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashSet;\n use std::env;\n use std::fs;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use build_helper::output;\n-use rustc_serialize::json;\n \n use {Build, Compiler, Mode};\n use util::{self, dylib_path, dylib_path_var};\n \n const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n \n-#[derive(RustcDecodable)]\n-struct Output {\n-    packages: Vec<Package>,\n-    resolve: Resolve,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct Package {\n-    id: String,\n-    name: String,\n-    source: Option<String>,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct Resolve {\n-    nodes: Vec<ResolveNode>,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct ResolveNode {\n-    id: String,\n-    dependencies: Vec<String>,\n-}\n-\n /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` will verify the validity of all our links in the\n@@ -181,7 +156,7 @@ pub fn compiletest(build: &Build,\n     let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n     cmd.arg(\"--llvm-version\").arg(llvm_version);\n \n-    cmd.args(&build.flags.args);\n+    cmd.args(&build.flags.cmd.test_args());\n \n     if build.config.verbose || build.flags.verbose {\n         cmd.arg(\"--verbose\");\n@@ -282,7 +257,7 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n \n-    let mut test_args = build.flags.args.join(\" \");\n+    let mut test_args = build.flags.cmd.test_args().join(\" \");\n     if build.config.quiet_tests {\n         test_args.push_str(\" --quiet\");\n     }\n@@ -302,7 +277,8 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n pub fn krate(build: &Build,\n              compiler: &Compiler,\n              target: &str,\n-             mode: Mode) {\n+             mode: Mode,\n+             krate: Option<&str>) {\n     let (name, path, features, root) = match mode {\n         Mode::Libstd => {\n             (\"libstd\", \"src/rustc/std_shim\", build.std_features(), \"std_shim\")\n@@ -318,24 +294,6 @@ pub fn krate(build: &Build,\n     println!(\"Testing {} stage{} ({} -> {})\", name, compiler.stage,\n              compiler.host, target);\n \n-    // Run `cargo metadata` to figure out what crates we're testing.\n-    //\n-    // Down below we're going to call `cargo test`, but to test the right set\n-    // of packages we're going to have to know what `-p` arguments to pass it\n-    // to know what crates to test. Here we run `cargo metadata` to learn about\n-    // the dependency graph and what `-p` arguments there are.\n-    let mut cargo = Command::new(&build.cargo);\n-    cargo.arg(\"metadata\")\n-         .arg(\"--manifest-path\").arg(build.src.join(path).join(\"Cargo.toml\"));\n-    let output = output(&mut cargo);\n-    let output: Output = json::decode(&output).unwrap();\n-    let id2pkg = output.packages.iter()\n-                        .map(|pkg| (&pkg.id, pkg))\n-                        .collect::<HashMap<_, _>>();\n-    let id2deps = output.resolve.nodes.iter()\n-                        .map(|node| (&node.id, &node.dependencies))\n-                        .collect::<HashMap<_, _>>();\n-\n     // Build up the base `cargo test` command.\n     //\n     // Pass in some standard flags then iterate over the graph we've discovered\n@@ -346,24 +304,25 @@ pub fn krate(build: &Build,\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n \n-    let mut visited = HashSet::new();\n-    let root_pkg = output.packages.iter().find(|p| p.name == root).unwrap();\n-    let mut next = vec![&root_pkg.id];\n-    while let Some(id) = next.pop() {\n-        // Skip any packages with sources listed, as these come from crates.io\n-        // and we shouldn't be testing them.\n-        if id2pkg[id].source.is_some() {\n-            continue\n-        }\n-        // Right now jemalloc is our only target-specific crate in the sense\n-        // that it's not present on all platforms. Custom skip it here for now,\n-        // but if we add more this probably wants to get more generalized.\n-        if !id.contains(\"jemalloc\") {\n-            cargo.arg(\"-p\").arg(&id2pkg[id].name);\n+    match krate {\n+        Some(krate) => {\n+            cargo.arg(\"-p\").arg(krate);\n         }\n-        for dep in id2deps[id] {\n-            if visited.insert(dep) {\n-                next.push(dep);\n+        None => {\n+            let mut visited = HashSet::new();\n+            let mut next = vec![root];\n+            while let Some(name) = next.pop() {\n+                // Right now jemalloc is our only target-specific crate in the sense\n+                // that it's not present on all platforms. Custom skip it here for now,\n+                // but if we add more this probably wants to get more generalized.\n+                if !name.contains(\"jemalloc\") {\n+                    cargo.arg(\"-p\").arg(name);\n+                }\n+                for dep in build.crates[name].deps.iter() {\n+                    if visited.insert(dep) {\n+                        next.push(dep);\n+                    }\n+                }\n             }\n         }\n     }\n@@ -389,7 +348,7 @@ pub fn krate(build: &Build,\n         build.run(cargo.arg(\"--no-run\"));\n         krate_emscripten(build, compiler, target, mode);\n     } else {\n-        cargo.args(&build.flags.args);\n+        cargo.args(&build.flags.cmd.test_args());\n         build.run(&mut cargo);\n     }\n }\n@@ -421,7 +380,7 @@ fn krate_android(build: &Build,\n                               target = target,\n                               test = test_file_name,\n                               log = log,\n-                              args = build.flags.args.join(\" \"));\n+                              args = build.flags.cmd.test_args().join(\" \"));\n \n         let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n         println!(\"{}\", output);"}, {"sha": "3d338cf4f94d8cb38e42460ca77069eb2f727031", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -25,17 +25,17 @@ pub fn clean(build: &Build) {\n     rm_rf(build, &build.out.join(\"tmp\"));\n \n     for host in build.config.host.iter() {\n-\n-        let out = build.out.join(host);\n-\n-        rm_rf(build, &out.join(\"doc\"));\n-\n-        for stage in 0..4 {\n-            rm_rf(build, &out.join(format!(\"stage{}\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-std\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-rustc\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-tools\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-test\", stage)));\n+        let entries = match build.out.join(host).read_dir() {\n+            Ok(iter) => iter,\n+            Err(_) => continue,\n+        };\n+\n+        for entry in entries {\n+            let entry = t!(entry);\n+            if entry.file_name().to_str() == Some(\"llvm\") {\n+                continue\n+            }\n+            t!(fs::remove_dir_all(&entry.path()));\n         }\n     }\n }"}, {"sha": "5fc4f006729d3e6e397c25d0113ddc35af7b4593", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -64,8 +64,8 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     }\n \n     build.run(&mut cargo);\n-    update_mtime(&libstd_stamp(build, compiler, target));\n-    std_link(build, target, compiler, compiler.host);\n+    update_mtime(&libstd_stamp(build, &compiler, target));\n+    std_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n@@ -74,11 +74,12 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn std_link(build: &Build,\n                 target: &str,\n-                compiler: &Compiler,\n+                stage: u32,\n                 host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Libstd, target);\n \n     // If we're linking one compiler host's output into another, then we weren't\n     // called from the `std` method above. In that case we clean out what's\n@@ -146,7 +147,7 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n     update_mtime(&libtest_stamp(build, compiler, target));\n-    test_link(build, target, compiler, compiler.host);\n+    test_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libtest rlibs/dylibs into the sysroot location.\n@@ -155,11 +156,12 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn test_link(build: &Build,\n                  target: &str,\n-                 compiler: &Compiler,\n+                 stage: u32,\n                  host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Libtest, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n@@ -218,7 +220,7 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     }\n     build.run(&mut cargo);\n \n-    rustc_link(build, target, compiler, compiler.host);\n+    rustc_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all librustc rlibs/dylibs into the sysroot location.\n@@ -227,11 +229,12 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn rustc_link(build: &Build,\n                   target: &str,\n-                  compiler: &Compiler,\n+                  stage: u32,\n                   host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n@@ -259,7 +262,10 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n /// must have been previously produced by the `stage - 1` build.config.build\n /// compiler.\n pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n-    assert!(stage > 0, \"the stage0 compiler isn't assembled, it's downloaded\");\n+    // nothing to do in stage0\n+    if stage == 0 {\n+        return\n+    }\n     // The compiler that we're assembling\n     let target_compiler = Compiler::new(stage, host);\n "}, {"sha": "30c7fefad87453bedfbfd4855aa50346c0e66a67", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -19,7 +19,6 @@\n \n use std::fs::{self, File};\n use std::io::prelude::*;\n-use std::path::Path;\n use std::process::Command;\n \n use {Build, Compiler, Mode};\n@@ -30,8 +29,9 @@ use util::{up_to_date, cp_r};\n ///\n /// This will not actually generate any documentation if the documentation has\n /// already been generated.\n-pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str, out: &Path) {\n-    t!(fs::create_dir_all(out));\n+pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str) {\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n \n     let out = out.join(name);\n     let compiler = Compiler::new(stage, &build.config.build);\n@@ -57,9 +57,10 @@ pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str, out: &Path)\n /// `STAMP` alongw ith providing the various header/footer HTML we've cutomized.\n ///\n /// In the end, this is just a glorified wrapper around rustdoc!\n-pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn standalone(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} standalone ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n \n     let compiler = Compiler::new(stage, &build.config.build);\n \n@@ -109,7 +110,7 @@ pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n            .arg(\"--html-in-header\").arg(&favicon)\n            .arg(\"--markdown-playground-url\")\n            .arg(\"https://play.rust-lang.org/\")\n-           .arg(\"-o\").arg(out)\n+           .arg(\"-o\").arg(&out)\n            .arg(&path);\n \n         if filename == \"reference.md\" {\n@@ -131,9 +132,10 @@ pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n ///\n /// This will generate all documentation for the standard library and its\n /// dependencies. This is largely just a wrapper around `cargo doc`.\n-pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn std(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} std ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                        .join(target).join(\"doc\");\n@@ -146,16 +148,17 @@ pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"))\n          .arg(\"--features\").arg(build.std_features());\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Compile all libtest documentation.\n ///\n /// This will generate all documentation for libtest and its dependencies. This\n /// is largely just a wrapper around `cargo doc`.\n-pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn test(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} test ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Libtest)\n                        .join(target).join(\"doc\");\n@@ -167,16 +170,17 @@ pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Generate all compiler documentation.\n ///\n /// This will generate all documentation for the compiler libraries and their\n /// dependencies. This is largely just a wrapper around `cargo doc`.\n-pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn rustc(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} compiler ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(target).join(\"doc\");\n@@ -189,14 +193,15 @@ pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n          .arg(\"--features\").arg(build.rustc_features());\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Generates the HTML rendered error-index by running the\n /// `error_index_generator` tool.\n-pub fn error_index(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn error_index(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} error index ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n     index.arg(\"html\");"}, {"sha": "d7516954f12d50fe20c0dfb4f1a8e9d2892f7dc1", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 202, "deletions": 37, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -13,60 +13,224 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n+use std::env;\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n-use std::slice;\n \n-use getopts::Options;\n+use getopts::{Matches, Options};\n+\n+use Build;\n+use config::Config;\n+use metadata;\n+use step;\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: bool,\n     pub stage: Option<u32>,\n     pub build: String,\n-    pub host: Filter,\n-    pub target: Filter,\n-    pub step: Vec<String>,\n+    pub host: Vec<String>,\n+    pub target: Vec<String>,\n     pub config: Option<PathBuf>,\n     pub src: Option<PathBuf>,\n     pub jobs: Option<u32>,\n-    pub args: Vec<String>,\n-    pub clean: bool,\n+    pub cmd: Subcommand,\n }\n \n-pub struct Filter {\n-    values: Vec<String>,\n+pub enum Subcommand {\n+    Build {\n+        paths: Vec<PathBuf>,\n+    },\n+    Doc {\n+        paths: Vec<PathBuf>,\n+    },\n+    Test {\n+        paths: Vec<PathBuf>,\n+        test_args: Vec<String>,\n+    },\n+    Clean,\n+    Dist {\n+        install: bool,\n+    },\n }\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut opts = Options::new();\n         opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n         opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n+        opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n         opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n-        opts.reqopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n-        opts.optmulti(\"\", \"target\", \"targets to build\", \"TARGET\");\n-        opts.optmulti(\"s\", \"step\", \"build step to execute\", \"STEP\");\n+        opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n-        opts.optopt(\"\", \"src\", \"path to repo root\", \"DIR\");\n+        opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n-        opts.optflag(\"\", \"clean\", \"clean output directory\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n \n-        let usage = |n| -> ! {\n-            let brief = format!(\"Usage: rust.py [options]\");\n-            print!(\"{}\", opts.usage(&brief));\n+        let usage = |n, opts: &Options| -> ! {\n+            let command = args.get(0).map(|s| &**s);\n+            let brief = format!(\"Usage: x.py {} [options] [<args>...]\",\n+                                command.unwrap_or(\"<command>\"));\n+\n+            println!(\"{}\", opts.usage(&brief));\n+            match command {\n+                Some(\"build\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories to\n+    the crates and/or artifacts to compile. For example:\n+\n+        ./x.py build src/libcore\n+        ./x.py build src/libproc_macro\n+        ./x.py build src/libstd --stage 1\n+\n+    If no arguments are passed then the complete artifacts for that stage are\n+    also compiled.\n+\n+        ./x.py build\n+        ./x.py build --stage 1\n+\n+    For a quick build with a usable compile, you can pass:\n+\n+        ./x.py build --stage 1 src/libtest\n+\");\n+                }\n+\n+                Some(\"test\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories to\n+    tests that should be compiled and run. For example:\n+\n+        ./x.py test src/test/run-pass\n+        ./x.py test src/test/run-pass/assert-*\n+        ./x.py test src/libstd --test-args hash_map\n+        ./x.py test src/libstd --stage 0\n+\n+    If no arguments are passed then the complete artifacts for that stage are\n+    compiled and tested.\n+\n+        ./x.py test\n+        ./x.py test --stage 1\n+\");\n+                }\n+\n+                Some(\"doc\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories of\n+    documentation to build. For example:\n+\n+        ./x.py doc src/doc/book\n+        ./x.py doc src/doc/nomicon\n+        ./x.py doc src/libstd\n+\n+    If no arguments are passed then everything is documented:\n+\n+        ./x.py doc\n+        ./x.py doc --stage 1\n+\");\n+                }\n+\n+                _ => {}\n+            }\n+\n+            if let Some(command) = command {\n+                if command == \"build\" ||\n+                   command == \"dist\" ||\n+                   command == \"doc\" ||\n+                   command == \"test\" ||\n+                   command == \"clean\"  {\n+                    println!(\"Available invocations:\");\n+                    if args.iter().any(|a| a == \"-v\") {\n+                        let flags = Flags::parse(&[\"build\".to_string()]);\n+                        let mut config = Config::default();\n+                        config.build = flags.build.clone();\n+                        let mut build = Build::new(flags, config);\n+                        metadata::build(&mut build);\n+                        step::build_rules(&build).print_help(command);\n+                    } else {\n+                        println!(\"    ... elided, run `./x.py {} -h -v` to see\",\n+                                 command);\n+                    }\n+\n+                    println!(\"\");\n+                }\n+            }\n+\n+println!(\"\\\n+Subcommands:\n+    build       Compile either the compiler or libraries\n+    test        Build and run some test suites\n+    doc         Build documentation\n+    clean       Clean out build directories\n+    dist        Build and/or install distribution artifacts\n+\n+To learn more about a subcommand, run `./x.py <command> -h`\n+\");\n+\n             process::exit(n);\n         };\n-\n-        let m = opts.parse(args).unwrap_or_else(|e| {\n-            println!(\"failed to parse options: {}\", e);\n-            usage(1);\n-        });\n-        if m.opt_present(\"h\") {\n-            usage(0);\n+        if args.len() == 0 {\n+            println!(\"a command must be passed\");\n+            usage(1, &opts);\n         }\n+        let parse = |opts: &Options| {\n+            let m = opts.parse(&args[1..]).unwrap_or_else(|e| {\n+                println!(\"failed to parse options: {}\", e);\n+                usage(1, opts);\n+            });\n+            if m.opt_present(\"h\") {\n+                usage(0, opts);\n+            }\n+            return m\n+        };\n+\n+        let cwd = t!(env::current_dir());\n+        let remaining_as_path = |m: &Matches| {\n+            m.free.iter().map(|p| cwd.join(p)).collect::<Vec<_>>()\n+        };\n+\n+        let m: Matches;\n+        let cmd = match &args[0][..] {\n+            \"build\" => {\n+                m = parse(&opts);\n+                Subcommand::Build { paths: remaining_as_path(&m) }\n+            }\n+            \"doc\" => {\n+                m = parse(&opts);\n+                Subcommand::Doc { paths: remaining_as_path(&m) }\n+            }\n+            \"test\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+                m = parse(&opts);\n+                Subcommand::Test {\n+                    paths: remaining_as_path(&m),\n+                    test_args: m.opt_strs(\"test-args\"),\n+                }\n+            }\n+            \"clean\" => {\n+                m = parse(&opts);\n+                if m.free.len() > 0 {\n+                    println!(\"clean takes no arguments\");\n+                    usage(1, &opts);\n+                }\n+                Subcommand::Clean\n+            }\n+            \"dist\" => {\n+                opts.optflag(\"\", \"install\", \"run installer as well\");\n+                m = parse(&opts);\n+                Subcommand::Dist {\n+                    install: m.opt_present(\"install\"),\n+                }\n+            }\n+            cmd => {\n+                println!(\"unknown command: {}\", cmd);\n+                usage(1, &opts);\n+            }\n+        };\n+\n \n         let cfg_file = m.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -78,26 +242,27 @@ impl Flags {\n \n         Flags {\n             verbose: m.opt_present(\"v\"),\n-            clean: m.opt_present(\"clean\"),\n             stage: m.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n-            build: m.opt_str(\"build\").unwrap(),\n-            host: Filter { values: m.opt_strs(\"host\") },\n-            target: Filter { values: m.opt_strs(\"target\") },\n-            step: m.opt_strs(\"step\"),\n+            build: m.opt_str(\"build\").unwrap_or_else(|| {\n+                env::var(\"BUILD\").unwrap()\n+            }),\n+            host: m.opt_strs(\"host\"),\n+            target: m.opt_strs(\"target\"),\n             config: cfg_file,\n             src: m.opt_str(\"src\").map(PathBuf::from),\n             jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n-            args: m.free.clone(),\n+            cmd: cmd,\n         }\n     }\n }\n \n-impl Filter {\n-    pub fn contains(&self, name: &str) -> bool {\n-        self.values.len() == 0 || self.values.iter().any(|s| s == name)\n-    }\n-\n-    pub fn iter(&self) -> slice::Iter<String> {\n-        self.values.iter()\n+impl Subcommand {\n+    pub fn test_args(&self) -> Vec<&str> {\n+        match *self {\n+            Subcommand::Test { ref test_args, .. } => {\n+                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            }\n+            _ => Vec::new(),\n+        }\n     }\n }"}, {"sha": "e4af4621206065a6a021932134739b44f670d658", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 26, "deletions": 245, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -57,6 +57,7 @@ mod channel;\n mod check;\n mod clean;\n mod compile;\n+mod metadata;\n mod config;\n mod dist;\n mod doc;\n@@ -76,7 +77,7 @@ mod job {\n }\n \n pub use config::Config;\n-pub use flags::Flags;\n+pub use flags::{Flags, Subcommand};\n \n /// A structure representing a Rust compiler.\n ///\n@@ -130,6 +131,17 @@ pub struct Build {\n     // Runtime state filled in later on\n     cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n     cxx: HashMap<String, gcc::Tool>,\n+    crates: HashMap<String, Crate>,\n+}\n+\n+#[derive(Debug)]\n+struct Crate {\n+    name: String,\n+    deps: Vec<String>,\n+    path: PathBuf,\n+    doc_step: String,\n+    build_step: String,\n+    test_step: String,\n }\n \n /// The various \"modes\" of invoking Cargo.\n@@ -162,7 +174,9 @@ impl Build {\n     /// By default all build output will be placed in the current directory.\n     pub fn new(flags: Flags, config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n-        let src = flags.src.clone().unwrap_or(cwd.clone());\n+        let src = flags.src.clone().or_else(|| {\n+            env::var_os(\"SRC\").map(|x| x.into())\n+        }).unwrap_or(cwd.clone());\n         let out = cwd.join(\"build\");\n \n         let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n@@ -196,6 +210,7 @@ impl Build {\n             package_vers: String::new(),\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n+            crates: HashMap::new(),\n             gdb_version: None,\n             lldb_version: None,\n             lldb_python_dir: None,\n@@ -204,13 +219,11 @@ impl Build {\n \n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n-        use step::Source::*;\n-\n         unsafe {\n             job::setup();\n         }\n \n-        if self.flags.clean {\n+        if let Subcommand::Clean = self.flags.cmd {\n             return clean::clean(self);\n         }\n \n@@ -232,247 +245,10 @@ impl Build {\n         }\n         self.verbose(\"updating submodules\");\n         self.update_submodules();\n+        self.verbose(\"learning about cargo\");\n+        metadata::build(self);\n \n-        // The main loop of the build system.\n-        //\n-        // The `step::all` function returns a topographically sorted list of all\n-        // steps that need to be executed as part of this build. Each step has a\n-        // corresponding entry in `step.rs` and indicates some unit of work that\n-        // needs to be done as part of the build.\n-        //\n-        // Almost all of these are simple one-liners that shell out to the\n-        // corresponding functionality in the extra modules, where more\n-        // documentation can be found.\n-        let steps = step::all(self);\n-\n-        self.verbose(\"bootstrap build plan:\");\n-        for step in &steps {\n-            self.verbose(&format!(\"{:?}\", step));\n-        }\n-\n-        for target in steps {\n-            let doc_out = self.out.join(&target.target).join(\"doc\");\n-            match target.src {\n-                Llvm { _dummy } => {\n-                    native::llvm(self, target.target);\n-                }\n-                TestHelpers { _dummy } => {\n-                    native::test_helpers(self, target.target);\n-                }\n-                Libstd { compiler } => {\n-                    compile::std(self, target.target, &compiler);\n-                }\n-                Libtest { compiler } => {\n-                    compile::test(self, target.target, &compiler);\n-                }\n-                Librustc { compiler } => {\n-                    compile::rustc(self, target.target, &compiler);\n-                }\n-                LibstdLink { compiler, host } => {\n-                    compile::std_link(self, target.target, &compiler, host);\n-                }\n-                LibtestLink { compiler, host } => {\n-                    compile::test_link(self, target.target, &compiler, host);\n-                }\n-                LibrustcLink { compiler, host } => {\n-                    compile::rustc_link(self, target.target, &compiler, host);\n-                }\n-                Rustc { stage: 0 } => {\n-                    // nothing to do...\n-                }\n-                Rustc { stage } => {\n-                    compile::assemble_rustc(self, stage, target.target);\n-                }\n-                ToolLinkchecker { stage } => {\n-                    compile::tool(self, stage, target.target, \"linkchecker\");\n-                }\n-                ToolRustbook { stage } => {\n-                    compile::tool(self, stage, target.target, \"rustbook\");\n-                }\n-                ToolErrorIndex { stage } => {\n-                    compile::tool(self, stage, target.target,\n-                                  \"error_index_generator\");\n-                }\n-                ToolCargoTest { stage } => {\n-                    compile::tool(self, stage, target.target, \"cargotest\");\n-                }\n-                ToolTidy { stage } => {\n-                    compile::tool(self, stage, target.target, \"tidy\");\n-                }\n-                ToolCompiletest { stage } => {\n-                    compile::tool(self, stage, target.target, \"compiletest\");\n-                }\n-                DocBook { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"book\", &doc_out);\n-                }\n-                DocNomicon { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"nomicon\",\n-                                  &doc_out);\n-                }\n-                DocStandalone { stage } => {\n-                    doc::standalone(self, stage, target.target, &doc_out);\n-                }\n-                DocStd { stage } => {\n-                    doc::std(self, stage, target.target, &doc_out);\n-                }\n-                DocTest { stage } => {\n-                    doc::test(self, stage, target.target, &doc_out);\n-                }\n-                DocRustc { stage } => {\n-                    doc::rustc(self, stage, target.target, &doc_out);\n-                }\n-                DocErrorIndex { stage } => {\n-                    doc::error_index(self, stage, target.target, &doc_out);\n-                }\n-\n-                CheckLinkcheck { stage } => {\n-                    check::linkcheck(self, stage, target.target);\n-                }\n-                CheckCargoTest { stage } => {\n-                    check::cargotest(self, stage, target.target);\n-                }\n-                CheckTidy { stage } => {\n-                    check::tidy(self, stage, target.target);\n-                }\n-                CheckRPass { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass\", \"run-pass\");\n-                }\n-                CheckRPassFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass\", \"run-pass-fulldeps\");\n-                }\n-                CheckCFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"compile-fail\", \"compile-fail\");\n-                }\n-                CheckCFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"compile-fail\", \"compile-fail-fulldeps\")\n-                }\n-                CheckPFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"parse-fail\", \"parse-fail\");\n-                }\n-                CheckRFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-fail\", \"run-fail\");\n-                }\n-                CheckRFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-fail\", \"run-fail-fulldeps\");\n-                }\n-                CheckPretty { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"pretty\");\n-                }\n-                CheckPrettyRPass { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass\");\n-                }\n-                CheckPrettyRPassFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass-fulldeps\");\n-                }\n-                CheckPrettyRFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-fail\");\n-                }\n-                CheckPrettyRFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-fail-fulldeps\");\n-                }\n-                CheckPrettyRPassValgrind { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass-valgrind\");\n-                }\n-                CheckMirOpt { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"mir-opt\", \"mir-opt\");\n-                }\n-                CheckCodegen { compiler } => {\n-                    if self.config.codegen_tests {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"codegen\", \"codegen\");\n-                    }\n-                }\n-                CheckCodegenUnits { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"codegen-units\", \"codegen-units\");\n-                }\n-                CheckIncremental { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"incremental\", \"incremental\");\n-                }\n-                CheckUi { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"ui\", \"ui\");\n-                }\n-                CheckDebuginfo { compiler } => {\n-                    if target.target.contains(\"msvc\") {\n-                        // nothing to do\n-                    } else if target.target.contains(\"apple\") {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"debuginfo-lldb\", \"debuginfo\");\n-                    } else {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"debuginfo-gdb\", \"debuginfo\");\n-                    }\n-                }\n-                CheckRustdoc { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"rustdoc\", \"rustdoc\");\n-                }\n-                CheckRPassValgrind { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass-valgrind\", \"run-pass-valgrind\");\n-                }\n-                CheckDocs { compiler } => {\n-                    check::docs(self, &compiler);\n-                }\n-                CheckErrorIndex { compiler } => {\n-                    check::error_index(self, &compiler);\n-                }\n-                CheckRMake { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-make\", \"run-make\")\n-                }\n-                CheckCrateStd { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Libstd)\n-                }\n-                CheckCrateTest { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Libtest)\n-                }\n-                CheckCrateRustc { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Librustc)\n-                }\n-\n-                DistDocs { stage } => dist::docs(self, stage, target.target),\n-                DistMingw { _dummy } => dist::mingw(self, target.target),\n-                DistRustc { stage } => dist::rustc(self, stage, target.target),\n-                DistStd { compiler } => dist::std(self, &compiler, target.target),\n-                DistSrc { _dummy } => dist::rust_src(self),\n-\n-                Install { stage } => install::install(self, stage, target.target),\n-\n-                DebuggerScripts { stage } => {\n-                    let compiler = Compiler::new(stage, target.target);\n-                    dist::debugger_scripts(self,\n-                                           &self.sysroot(&compiler),\n-                                           target.target);\n-                }\n-\n-                AndroidCopyLibs { compiler } => {\n-                    check::android_copy_libs(self, &compiler, target.target);\n-                }\n-\n-                // pseudo-steps\n-                Dist { .. } |\n-                Doc { .. } |\n-                CheckTarget { .. } |\n-                Check { .. } => {}\n-            }\n-        }\n+        step::run(self);\n     }\n \n     /// Updates all git submodules that we have.\n@@ -812,6 +588,11 @@ impl Build {\n         self.out.join(target).join(\"llvm\")\n     }\n \n+    /// Output directory for all documentation for a target\n+    fn doc_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"doc\")\n+    }\n+\n     /// Returns true if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used."}, {"sha": "bf5cc6a4ad838a057cc5fa3a04a4a0fe1cadb8f7", "filename": "src/bootstrap/metadata.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::process::Command;\n+use std::path::PathBuf;\n+\n+use build_helper::output;\n+use rustc_serialize::json;\n+\n+use {Build, Crate};\n+\n+#[derive(RustcDecodable)]\n+struct Output {\n+    packages: Vec<Package>,\n+    resolve: Resolve,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct Package {\n+    id: String,\n+    name: String,\n+    source: Option<String>,\n+    manifest_path: String,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct Resolve {\n+    nodes: Vec<ResolveNode>,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct ResolveNode {\n+    id: String,\n+    dependencies: Vec<String>,\n+}\n+\n+pub fn build(build: &mut Build) {\n+    build_krate(build, \"src/rustc/std_shim\");\n+    build_krate(build, \"src/rustc/test_shim\");\n+    build_krate(build, \"src/rustc\");\n+}\n+\n+fn build_krate(build: &mut Build, krate: &str) {\n+    // Run `cargo metadata` to figure out what crates we're testing.\n+    //\n+    // Down below we're going to call `cargo test`, but to test the right set\n+    // of packages we're going to have to know what `-p` arguments to pass it\n+    // to know what crates to test. Here we run `cargo metadata` to learn about\n+    // the dependency graph and what `-p` arguments there are.\n+    let mut cargo = Command::new(&build.cargo);\n+    cargo.arg(\"metadata\")\n+         .arg(\"--manifest-path\").arg(build.src.join(krate).join(\"Cargo.toml\"));\n+    let output = output(&mut cargo);\n+    let output: Output = json::decode(&output).unwrap();\n+    let mut id2name = HashMap::new();\n+    for package in output.packages {\n+        if package.source.is_none() {\n+            id2name.insert(package.id, package.name.clone());\n+            let mut path = PathBuf::from(package.manifest_path);\n+            path.pop();\n+            build.crates.insert(package.name.clone(), Crate {\n+                build_step: format!(\"build-crate-{}\", package.name),\n+                doc_step: format!(\"doc-crate-{}\", package.name),\n+                test_step: format!(\"test-crate-{}\", package.name),\n+                name: package.name,\n+                deps: Vec::new(),\n+                path: path,\n+            });\n+        }\n+    }\n+\n+    for node in output.resolve.nodes {\n+        let name = match id2name.get(&node.id) {\n+            Some(name) => name,\n+            None => continue,\n+        };\n+\n+        let krate = build.crates.get_mut(name).unwrap();\n+        for dep in node.dependencies.iter() {\n+            let dep = match id2name.get(dep) {\n+                Some(dep) => dep,\n+                None => continue,\n+            };\n+            krate.deps.push(dep.clone());\n+        }\n+    }\n+}"}, {"sha": "d4031077639c50d0be477ca4b062594c0e032829", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -17,47 +17,46 @@ else\n BOOTSTRAP_ARGS :=\n endif\n \n-BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py $(BOOTSTRAP_ARGS)\n+BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n-\t$(Q)$(BOOTSTRAP)\n+\t$(Q)$(BOOTSTRAP) build $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n \n # Don\u2019t use $(Q) here, always show how to invoke the bootstrap script directly\n help:\n \t$(BOOTSTRAP) --help\n \n clean:\n-\t$(Q)$(BOOTSTRAP) --clean\n+\t$(Q)$(BOOTSTRAP) clean $(BOOTSTRAP_ARGS)\n \n rustc-stage1:\n-\t$(Q)$(BOOTSTRAP) --step libtest --stage 1\n+\t$(Q)$(BOOTSTRAP) build --stage 1 src/libtest $(BOOTSTRAP_ARGS)\n rustc-stage2:\n-\t$(Q)$(BOOTSTRAP) --step libtest --stage 2\n+\t$(Q)$(BOOTSTRAP) build --stage 2 src/libtest $(BOOTSTRAP_ARGS)\n \n docs: doc\n doc:\n-\t$(Q)$(BOOTSTRAP) --step doc\n-style:\n-\t$(Q)$(BOOTSTRAP) --step doc-style\n+\t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n nomicon:\n-\t$(Q)$(BOOTSTRAP) --step doc-nomicon\n+\t$(Q)$(BOOTSTRAP) doc src/doc/nomicon $(BOOTSTRAP_ARGS)\n book:\n-\t$(Q)$(BOOTSTRAP) --step doc-book\n+\t$(Q)$(BOOTSTRAP) doc src/doc/book $(BOOTSTRAP_ARGS)\n standalone-docs:\n-\t$(Q)$(BOOTSTRAP) --step doc-standalone\n+\t$(Q)$(BOOTSTRAP) doc src/doc $(BOOTSTRAP_ARGS)\n check:\n-\t$(Q)$(BOOTSTRAP) --step check\n+\t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-cargotest:\n-\t$(Q)$(BOOTSTRAP) --step check-cargotest\n+\t$(Q)$(BOOTSTRAP) test src/tools/cargotest $(BOOTSTRAP_ARGS)\n dist:\n-\t$(Q)$(BOOTSTRAP) --step dist\n+\t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n install:\n ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n \t$(Q)echo \"'sudo make install' is not supported currently.\"\n else\n-\t$(Q)$(BOOTSTRAP) --step install\n+\t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n endif\n tidy:\n-\t$(Q)$(BOOTSTRAP) --step check-tidy --stage 0\n+\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS)\n \n .PHONY: dist"}, {"sha": "4a7cfa1cc6a3eeb3fbef89fe79ca8c16ec2badfa", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 631, "deletions": 548, "changes": 1179, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -8,600 +8,683 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Major workhorse of rustbuild, definition and dependencies between stages of\n-//! the copmile.\n-//!\n-//! The primary purpose of this module is to define the various `Step`s of\n-//! execution of the build. Each `Step` has a corresponding `Source` indicating\n-//! what it's actually doing along with a number of dependencies which must be\n-//! executed first.\n-//!\n-//! This module will take the CLI as input and calculate the steps required for\n-//! the build requested, ensuring that all intermediate pieces are in place.\n-//! Essentially this module is a `make`-replacement, but not as good.\n-\n-use std::collections::HashSet;\n-\n-use {Build, Compiler};\n-\n-#[derive(Hash, Eq, PartialEq, Clone, Debug)]\n-pub struct Step<'a> {\n-    pub src: Source<'a>,\n-    pub target: &'a str,\n+use std::collections::{HashMap, HashSet};\n+use std::mem;\n+\n+use check;\n+use compile;\n+use dist;\n+use doc;\n+use flags::Subcommand;\n+use install;\n+use native;\n+use {Compiler, Build, Mode};\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+struct Step<'a> {\n+    name: &'a str,\n+    stage: u32,\n+    host: &'a str,\n+    target: &'a str,\n }\n \n-/// Macro used to iterate over all targets that are recognized by the build\n-/// system.\n-///\n-/// Whenever a new step is added it will involve adding an entry here, updating\n-/// the dependencies section below, and then adding an implementation of the\n-/// step in `build/mod.rs`.\n-///\n-/// This macro takes another macro as an argument and then calls that macro with\n-/// all steps that the build system knows about.\n-macro_rules! targets {\n-    ($m:ident) => {\n-        $m! {\n-            // Step representing building the stageN compiler. This is just the\n-            // compiler executable itself, not any of the support libraries\n-            (rustc, Rustc { stage: u32 }),\n-\n-            // Steps for the two main cargo builds. These are parameterized over\n-            // the compiler which is producing the artifact.\n-            (libstd, Libstd { compiler: Compiler<'a> }),\n-            (libtest, Libtest { compiler: Compiler<'a> }),\n-            (librustc, Librustc { compiler: Compiler<'a> }),\n-\n-            // Links the target produced by the compiler provided into the\n-            // host's directory also provided.\n-            (libstd_link, LibstdLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-            (libtest_link, LibtestLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-            (librustc_link, LibrustcLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-\n-            // Various tools that we can build as part of the build.\n-            (tool_linkchecker, ToolLinkchecker { stage: u32 }),\n-            (tool_rustbook, ToolRustbook { stage: u32 }),\n-            (tool_error_index, ToolErrorIndex { stage: u32 }),\n-            (tool_cargotest, ToolCargoTest { stage: u32 }),\n-            (tool_tidy, ToolTidy { stage: u32 }),\n-            (tool_compiletest, ToolCompiletest { stage: u32 }),\n-\n-            // Steps for long-running native builds. Ideally these wouldn't\n-            // actually exist and would be part of build scripts, but for now\n-            // these are here.\n-            //\n-            // There aren't really any parameters to this, but empty structs\n-            // with braces are unstable so we just pick something that works.\n-            (llvm, Llvm { _dummy: () }),\n-            (test_helpers, TestHelpers { _dummy: () }),\n-            (debugger_scripts, DebuggerScripts { stage: u32 }),\n-\n-            // Steps for various pieces of documentation that we can generate,\n-            // the 'doc' step is just a pseudo target to depend on a bunch of\n-            // others.\n-            (doc, Doc { stage: u32 }),\n-            (doc_book, DocBook { stage: u32 }),\n-            (doc_nomicon, DocNomicon { stage: u32 }),\n-            (doc_standalone, DocStandalone { stage: u32 }),\n-            (doc_std, DocStd { stage: u32 }),\n-            (doc_test, DocTest { stage: u32 }),\n-            (doc_rustc, DocRustc { stage: u32 }),\n-            (doc_error_index, DocErrorIndex { stage: u32 }),\n-\n-            // Steps for running tests. The 'check' target is just a pseudo\n-            // target to depend on a bunch of others.\n-            (check, Check { stage: u32, compiler: Compiler<'a> }),\n-            (check_target, CheckTarget { stage: u32, compiler: Compiler<'a> }),\n-            (check_linkcheck, CheckLinkcheck { stage: u32 }),\n-            (check_cargotest, CheckCargoTest { stage: u32 }),\n-            (check_tidy, CheckTidy { stage: u32 }),\n-            (check_rpass, CheckRPass { compiler: Compiler<'a> }),\n-            (check_rpass_full, CheckRPassFull { compiler: Compiler<'a> }),\n-            (check_rpass_valgrind, CheckRPassValgrind { compiler: Compiler<'a> }),\n-            (check_rfail, CheckRFail { compiler: Compiler<'a> }),\n-            (check_rfail_full, CheckRFailFull { compiler: Compiler<'a> }),\n-            (check_cfail, CheckCFail { compiler: Compiler<'a> }),\n-            (check_cfail_full, CheckCFailFull { compiler: Compiler<'a> }),\n-            (check_pfail, CheckPFail { compiler: Compiler<'a> }),\n-            (check_pretty, CheckPretty { compiler: Compiler<'a> }),\n-            (check_pretty_rpass, CheckPrettyRPass { compiler: Compiler<'a> }),\n-            (check_pretty_rpass_full, CheckPrettyRPassFull { compiler: Compiler<'a> }),\n-            (check_pretty_rfail, CheckPrettyRFail { compiler: Compiler<'a> }),\n-            (check_pretty_rfail_full, CheckPrettyRFailFull { compiler: Compiler<'a> }),\n-            (check_pretty_rpass_valgrind, CheckPrettyRPassValgrind { compiler: Compiler<'a> }),\n-            (check_codegen, CheckCodegen { compiler: Compiler<'a> }),\n-            (check_codegen_units, CheckCodegenUnits { compiler: Compiler<'a> }),\n-            (check_incremental, CheckIncremental { compiler: Compiler<'a> }),\n-            (check_ui, CheckUi { compiler: Compiler<'a> }),\n-            (check_mir_opt, CheckMirOpt { compiler: Compiler<'a> }),\n-            (check_debuginfo, CheckDebuginfo { compiler: Compiler<'a> }),\n-            (check_rustdoc, CheckRustdoc { compiler: Compiler<'a> }),\n-            (check_docs, CheckDocs { compiler: Compiler<'a> }),\n-            (check_error_index, CheckErrorIndex { compiler: Compiler<'a> }),\n-            (check_rmake, CheckRMake { compiler: Compiler<'a> }),\n-            (check_crate_std, CheckCrateStd { compiler: Compiler<'a> }),\n-            (check_crate_test, CheckCrateTest { compiler: Compiler<'a> }),\n-            (check_crate_rustc, CheckCrateRustc { compiler: Compiler<'a> }),\n-\n-            // Distribution targets, creating tarballs\n-            (dist, Dist { stage: u32 }),\n-            (dist_docs, DistDocs { stage: u32 }),\n-            (dist_mingw, DistMingw { _dummy: () }),\n-            (dist_rustc, DistRustc { stage: u32 }),\n-            (dist_std, DistStd { compiler: Compiler<'a> }),\n-            (dist_src, DistSrc { _dummy: () }),\n-\n-            // install target\n-            (install, Install { stage: u32 }),\n-\n-            // Misc targets\n-            (android_copy_libs, AndroidCopyLibs { compiler: Compiler<'a> }),\n-        }\n+impl<'a> Step<'a> {\n+    fn name(&self, name: &'a str) -> Step<'a> {\n+        Step { name: name, ..*self }\n     }\n-}\n \n-// Define the `Source` enum by iterating over all the steps and peeling out just\n-// the types that we want to define.\n+    fn stage(&self, stage: u32) -> Step<'a> {\n+        Step { stage: stage, ..*self }\n+    }\n \n-macro_rules! item { ($a:item) => ($a) }\n+    fn host(&self, host: &'a str) -> Step<'a> {\n+        Step { host: host, ..*self }\n+    }\n \n-macro_rules! define_source {\n-    ($(($short:ident, $name:ident { $($args:tt)* }),)*) => {\n-        item! {\n-            #[derive(Hash, Eq, PartialEq, Clone, Debug)]\n-            pub enum Source<'a> {\n-                $($name { $($args)* }),*\n-            }\n-        }\n+    fn target(&self, target: &'a str) -> Step<'a> {\n+        Step { target: target, ..*self }\n     }\n-}\n \n-targets!(define_source);\n-\n-/// Calculate a list of all steps described by `build`.\n-///\n-/// This will inspect the flags passed in on the command line and use that to\n-/// build up a list of steps to execute. These steps will then be transformed\n-/// into a topologically sorted list which when executed left-to-right will\n-/// correctly sequence the entire build.\n-pub fn all(build: &Build) -> Vec<Step> {\n-    build.verbose(\"inferred build steps:\");\n-\n-    let mut ret = Vec::new();\n-    let mut all = HashSet::new();\n-    for target in top_level(build) {\n-        fill(build, &target, &mut ret, &mut all);\n-    }\n-    return ret;\n-\n-    fn fill<'a>(build: &'a Build,\n-                target: &Step<'a>,\n-                ret: &mut Vec<Step<'a>>,\n-                set: &mut HashSet<Step<'a>>) {\n-        if set.insert(target.clone()) {\n-            for dep in target.deps(build) {\n-                build.verbose(&format!(\"{:?}\\n  -> {:?}\", target, dep));\n-                fill(build, &dep, ret, set);\n-            }\n-            ret.push(target.clone());\n-        }\n+    fn compiler(&self) -> Compiler<'a> {\n+        Compiler::new(self.stage, self.host)\n     }\n }\n \n-/// Determines what top-level targets are requested as part of this build,\n-/// returning them as a list.\n-fn top_level(build: &Build) -> Vec<Step> {\n-    let mut targets = Vec::new();\n-    let stage = build.flags.stage.unwrap_or(2);\n+pub fn run(build: &Build) {\n+    let rules = build_rules(build);\n+    let steps = rules.plan();\n+    rules.run(&steps);\n+}\n \n-    let host = Step {\n-        src: Source::Llvm { _dummy: () },\n-        target: build.flags.host.iter().next()\n-                     .unwrap_or(&build.config.build),\n-    };\n-    let target = Step {\n-        src: Source::Llvm { _dummy: () },\n-        target: build.flags.target.iter().next().map(|x| &x[..])\n-                     .unwrap_or(host.target)\n+pub fn build_rules(build: &Build) -> Rules {\n+    let mut rules: Rules = Rules::new(build);\n+    // dummy rule to do nothing, useful when a dep maps to no deps\n+    rules.build(\"dummy\", \"path/to/nowhere\");\n+    fn dummy<'a>(s: &Step<'a>, build: &'a Build) -> Step<'a> {\n+        s.name(\"dummy\").stage(0)\n+         .target(&build.config.build)\n+         .host(&build.config.build)\n+    }\n+\n+    // Helper for loading an entire DAG of crates, rooted at `name`\n+    let krates = |name: &str| {\n+        let mut ret = Vec::new();\n+        let mut list = vec![name];\n+        let mut visited = HashSet::new();\n+        while let Some(krate) = list.pop() {\n+            let default = krate == name;\n+            let krate = &build.crates[krate];\n+            let path = krate.path.strip_prefix(&build.src).unwrap();\n+            ret.push((krate, path.to_str().unwrap(), default));\n+            for dep in krate.deps.iter() {\n+                if visited.insert(dep) && dep != \"build_helper\" {\n+                    list.push(dep);\n+                }\n+            }\n+        }\n+        return ret\n     };\n \n-    // First, try to find steps on the command line.\n-    add_steps(build, stage, &host, &target, &mut targets);\n+    rules.build(\"rustc\", \"path/to/nowhere\")\n+         .dep(move |s| {\n+             if s.stage == 0 {\n+                 dummy(s, build)\n+             } else {\n+                 s.name(\"librustc\")\n+                  .host(&build.config.build)\n+                  .stage(s.stage - 1)\n+             }\n+         })\n+         .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n+    rules.build(\"llvm\", \"src/llvm\")\n+         .host(true)\n+         .run(move |s| native::llvm(build, s.target));\n+\n+    // ========================================================================\n+    // Crate compilations\n+    //\n+    // Tools used during the build system but not shipped\n+    rules.build(\"libstd\", \"src/libstd\")\n+         .dep(|s| s.name(\"build-crate-std_shim\"));\n+    rules.build(\"libtest\", \"src/libtest\")\n+         .dep(|s| s.name(\"build-crate-test_shim\"));\n+    rules.build(\"librustc\", \"src/librustc\")\n+         .dep(|s| s.name(\"build-crate-rustc-main\"));\n+    for (krate, path, _default) in krates(\"std_shim\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"rustc\").target(s.host))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::std(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::std_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n+    for (krate, path, default) in krates(\"test_shim\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"libstd\"))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .default(default)\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::test(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::test_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n+    for (krate, path, default) in krates(\"rustc-main\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .host(true)\n+             .default(default)\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::rustc(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::rustc_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n \n-    // If none are specified, then build everything.\n-    if targets.len() == 0 {\n-        let t = Step {\n-            src: Source::Llvm { _dummy: () },\n-            target: &build.config.build,\n+    // ========================================================================\n+    // Test targets\n+    //\n+    // Various unit tests and tests suites we can run\n+    {\n+        let mut suite = |name, path, dir, mode| {\n+            rules.test(name, path)\n+                 .dep(|s| s.name(\"libtest\"))\n+                 .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+                 .dep(|s| s.name(\"test-helpers\"))\n+                 .dep(move |s| {\n+                     if s.target.contains(\"android\") {\n+                         s.name(\"android-copy-libs\")\n+                     } else {\n+                         dummy(s, build)\n+                     }\n+                 })\n+                 .default(true)\n+                 .run(move |s| {\n+                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                 });\n         };\n-        if build.config.docs {\n-          targets.push(t.doc(stage));\n-        }\n-        for host in build.config.host.iter() {\n-            if !build.flags.host.contains(host) {\n-                continue\n-            }\n-            let host = t.target(host);\n-            if host.target == build.config.build {\n-                targets.push(host.librustc(host.compiler(stage)));\n-            } else {\n-                targets.push(host.librustc_link(t.compiler(stage), host.target));\n-            }\n-            for target in build.config.target.iter() {\n-                if !build.flags.target.contains(target) {\n-                    continue\n-                }\n \n-                if host.target == build.config.build {\n-                    targets.push(host.target(target)\n-                                     .libtest(host.compiler(stage)));\n-                } else {\n-                    targets.push(host.target(target)\n-                                     .libtest_link(t.compiler(stage), host.target));\n-                }\n-            }\n+        suite(\"check-rpass\", \"src/test/run-pass\", \"run-pass\", \"run-pass\");\n+        suite(\"check-cfail\", \"src/test/compile-fail\", \"compile-fail\", \"compile-fail\");\n+        suite(\"check-pfail\", \"src/test/parse-fail\", \"parse-fail\", \"parse-fail\");\n+        suite(\"check-rfail\", \"src/test/run-fail\", \"run-fail\", \"run-fail\");\n+        suite(\"check-rpass-valgrind\", \"src/test/run-pass-valgrind\",\n+              \"run-pass-valgrind\", \"run-pass-valgrind\");\n+        suite(\"check-mir-opt\", \"src/test/mir-opt\", \"mir-opt\", \"mir-opt\");\n+        if build.config.codegen_tests {\n+            suite(\"check-codegen\", \"src/test/codegen\", \"codegen\", \"codegen\");\n         }\n+        suite(\"check-codegen-units\", \"src/test/codegen-units\", \"codegen-units\",\n+              \"codegen-units\");\n+        suite(\"check-incremental\", \"src/test/incremental\", \"incremental\",\n+              \"incremental\");\n+        suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n+        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n+        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n+              \"run-pass\");\n+        suite(\"check-pretty-rfail\", \"src/test/run-pass/pretty\", \"pretty\",\n+              \"run-fail\");\n+        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind\", \"pretty\",\n+              \"run-pass-valgrind\");\n     }\n \n-    targets\n-}\n+    if build.config.build.contains(\"msvc\") {\n+        // nothing to do for debuginfo tests\n+    } else if build.config.build.contains(\"apple\") {\n+        rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"test-helpers\"))\n+             .dep(|s| s.name(\"debugger-scripts\"))\n+             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n+                                         \"debuginfo-lldb\", \"debuginfo\"));\n+    } else {\n+        rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"test-helpers\"))\n+             .dep(|s| s.name(\"debugger-scripts\"))\n+             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n+                                         \"debuginfo-gdb\", \"debuginfo\"));\n+    }\n \n-fn add_steps<'a>(build: &'a Build,\n-                 stage: u32,\n-                 host: &Step<'a>,\n-                 target: &Step<'a>,\n-                 targets: &mut Vec<Step<'a>>) {\n-    struct Context<'a> {\n-        stage: u32,\n-        compiler: Compiler<'a>,\n-        _dummy: (),\n-        host: &'a str,\n-    }\n-    for step in build.flags.step.iter() {\n-\n-        // The macro below insists on hygienic access to all local variables, so\n-        // we shove them all in a struct and subvert hygiene by accessing struct\n-        // fields instead,\n-        let cx = Context {\n-            stage: stage,\n-            compiler: host.target(&build.config.build).compiler(stage),\n-            _dummy: (),\n-            host: host.target,\n+    rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n+         .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n+                                         s.target));\n+\n+    {\n+        let mut suite = |name, path, dir, mode| {\n+            rules.test(name, path)\n+                 .dep(|s| s.name(\"librustc\"))\n+                 .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+                 .default(true)\n+                 .host(true)\n+                 .run(move |s| {\n+                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                 });\n         };\n-        macro_rules! add_step {\n-            ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => ({$(\n-                let name = stringify!($short).replace(\"_\", \"-\");\n-                if &step[..] == &name[..] {\n-                    targets.push(target.$short($(cx.$arg),*));\n-                    continue\n-                }\n-                drop(name);\n-            )*})\n+\n+        suite(\"check-rpass-full\", \"src/test/run-pass-fulldeps\",\n+              \"run-pass\", \"run-pass-fulldeps\");\n+        suite(\"check-cfail-full\", \"src/test/compile-fail-fulldeps\",\n+              \"compile-fail\", \"compile-fail-fulldeps\");\n+        suite(\"check-rmake\", \"src/test/run-make\", \"run-make\", \"run-make\");\n+        suite(\"check-rustdoc\", \"src/test/rustdoc\", \"rustdoc\", \"rustdoc\");\n+        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps\",\n+              \"pretty\", \"run-pass-fulldeps\");\n+        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps\",\n+              \"pretty\", \"run-fail-fulldeps\");\n+    }\n+\n+    for (krate, path, _default) in krates(\"std_shim\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Libstd, Some(&krate.name)));\n+    }\n+    rules.test(\"check-std-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Libstd,\n+                               None));\n+    for (krate, path, _default) in krates(\"test_shim\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Libtest, Some(&krate.name)));\n+    }\n+    rules.test(\"check-test-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Libtest,\n+                               None));\n+    for (krate, path, _default) in krates(\"rustc-main\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .host(true)\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Librustc, Some(&krate.name)));\n+    }\n+    rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+             .host(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Librustc,\n+                               None));\n+\n+    rules.test(\"check-linkchecker\", \"src/tools/linkchecker\")\n+         .dep(|s| s.name(\"tool-linkchecker\"))\n+         .dep(|s| s.name(\"default:doc\"))\n+         .default(true)\n+         .run(move |s| check::linkcheck(build, s.stage, s.target));\n+    rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n+         .dep(|s| s.name(\"tool-cargotest\"))\n+         .dep(|s| s.name(\"librustc\"))\n+         .run(move |s| check::cargotest(build, s.stage, s.target));\n+    rules.test(\"check-tidy\", \"src/tools/tidy\")\n+         .dep(|s| s.name(\"tool-tidy\"))\n+         .default(true)\n+         .run(move |s| check::tidy(build, s.stage, s.target));\n+    rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"tool-error-index\").host(s.host))\n+         .default(true)\n+         .run(move |s| check::error_index(build, &s.compiler()));\n+    rules.test(\"check-docs\", \"src/doc\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .run(move |s| check::docs(build, &s.compiler()));\n+\n+    rules.build(\"test-helpers\", \"src/rt/rust_test_helpers.c\")\n+         .run(move |s| native::test_helpers(build, s.target));\n+    rules.test(\"android-copy-libs\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .run(move |s| check::android_copy_libs(build, &s.compiler(), s.target));\n+\n+    // ========================================================================\n+    // Build tools\n+    //\n+    // Tools used during the build system but not shipped\n+    rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n+    rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n+    rules.build(\"tool-tidy\", \"src/tools/tidy\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n+    rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n+    rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n+    rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+\n+    // ========================================================================\n+    // Documentation targets\n+    rules.doc(\"doc-book\", \"src/doc/book\")\n+         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::rustbook(build, s.stage, s.target, \"book\"));\n+    rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n+         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::rustbook(build, s.stage, s.target, \"nomicon\"));\n+    rules.doc(\"doc-standalone\", \"src/doc\")\n+         .dep(move |s| s.name(\"rustc\").target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::standalone(build, s.stage, s.target));\n+    rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n+         .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::error_index(build, s.stage, s.target));\n+    for (krate, path, default) in krates(\"std_shim\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"libstd\"))\n+             .default(default && build.config.docs)\n+             .run(move |s| doc::std(build, s.stage, s.target));\n+    }\n+    for (krate, path, default) in krates(\"test_shim\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .default(default && build.config.docs)\n+             .run(move |s| doc::test(build, s.stage, s.target));\n+    }\n+    for (krate, path, default) in krates(\"rustc-main\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"librustc\"))\n+             .host(true)\n+             .default(default && build.config.compiler_docs)\n+             .run(move |s| doc::rustc(build, s.stage, s.target));\n+    }\n+\n+    // ========================================================================\n+    // Distribution targets\n+    rules.dist(\"dist-rustc\", \"src/librustc\")\n+         .dep(|s| s.name(\"rustc\"))\n+         .host(true)\n+         .default(true)\n+         .run(move |s| dist::rustc(build, s.stage, s.target));\n+    rules.dist(\"dist-std\", \"src/libstd\")\n+         .dep(move |s| {\n+             // We want to package up as many target libraries as possible\n+             // for the `rust-std` package, so if this is a host target we\n+             // depend on librustc and otherwise we just depend on libtest.\n+             if build.config.host.iter().any(|t| t == s.target) {\n+                 s.name(\"librustc\")\n+             } else {\n+                 s.name(\"libtest\")\n+             }\n+         })\n+         .default(true)\n+         .run(move |s| dist::std(build, &s.compiler(), s.target));\n+    rules.dist(\"dist-mingw\", \"path/to/nowhere\")\n+         .run(move |s| dist::mingw(build, s.target));\n+    rules.dist(\"dist-src\", \"src\")\n+         .default(true)\n+         .host(true)\n+         .run(move |_| dist::rust_src(build));\n+    rules.dist(\"dist-docs\", \"src/doc\")\n+         .dep(|s| s.name(\"default:doc\"))\n+         .run(move |s| dist::docs(build, s.stage, s.target));\n+    rules.dist(\"install\", \"src\")\n+         .dep(|s| s.name(\"default:dist\"))\n+         .run(move |s| install::install(build, s.stage, s.target));\n+\n+    rules.verify();\n+    return rules\n+}\n+\n+struct Rule<'a> {\n+    name: &'a str,\n+    path: &'a str,\n+    kind: Kind,\n+    deps: Vec<Box<Fn(&Step<'a>) -> Step<'a> + 'a>>,\n+    run: Box<Fn(&Step<'a>) + 'a>,\n+    default: bool,\n+    host: bool,\n+}\n+\n+#[derive(PartialEq)]\n+enum Kind {\n+    Build,\n+    Test,\n+    Dist,\n+    Doc,\n+}\n+\n+impl<'a> Rule<'a> {\n+    fn new(name: &'a str, path: &'a str, kind: Kind) -> Rule<'a> {\n+        Rule {\n+            name: name,\n+            deps: Vec::new(),\n+            run: Box::new(|_| ()),\n+            path: path,\n+            kind: kind,\n+            default: false,\n+            host: false,\n         }\n+    }\n+}\n+\n+struct RuleBuilder<'a: 'b, 'b> {\n+    rules: &'b mut Rules<'a>,\n+    rule: Rule<'a>,\n+}\n \n-        targets!(add_step);\n+impl<'a, 'b> RuleBuilder<'a, 'b> {\n+    fn dep<F>(&mut self, f: F) -> &mut Self\n+        where F: Fn(&Step<'a>) -> Step<'a> + 'a,\n+    {\n+        self.rule.deps.push(Box::new(f));\n+        self\n+    }\n+\n+    fn run<F>(&mut self, f: F) -> &mut Self\n+        where F: Fn(&Step<'a>) + 'a,\n+    {\n+        self.rule.run = Box::new(f);\n+        self\n+    }\n+\n+    fn default(&mut self, default: bool) -> &mut Self {\n+        self.rule.default = default;\n+        self\n+    }\n \n-        panic!(\"unknown step: {}\", step);\n+    fn host(&mut self, host: bool) -> &mut Self {\n+        self.rule.host = host;\n+        self\n     }\n }\n \n-macro_rules! constructors {\n-    ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => {$(\n-        fn $short(&self, $($arg: $t),*) -> Step<'a> {\n-            Step {\n-                src: Source::$name { $($arg: $arg),* },\n-                target: self.target,\n-            }\n+impl<'a, 'b> Drop for RuleBuilder<'a, 'b> {\n+    fn drop(&mut self) {\n+        let rule = mem::replace(&mut self.rule, Rule::new(\"\", \"\", Kind::Build));\n+        let prev = self.rules.rules.insert(rule.name, rule);\n+        if let Some(prev) = prev {\n+            panic!(\"duplicate rule named: {}\", prev.name);\n         }\n-    )*}\n+    }\n }\n \n-impl<'a> Step<'a> {\n-    fn compiler(&self, stage: u32) -> Compiler<'a> {\n-        Compiler::new(stage, self.target)\n+pub struct Rules<'a> {\n+    build: &'a Build,\n+    sbuild: Step<'a>,\n+    rules: HashMap<&'a str, Rule<'a>>,\n+}\n+\n+impl<'a> Rules<'a> {\n+    fn new(build: &'a Build) -> Rules<'a> {\n+        Rules {\n+            build: build,\n+            sbuild: Step {\n+                stage: build.flags.stage.unwrap_or(2),\n+                target: &build.config.build,\n+                host: &build.config.build,\n+                name: \"\",\n+            },\n+            rules: HashMap::new(),\n+        }\n     }\n \n-    fn target(&self, target: &'a str) -> Step<'a> {\n-        Step { target: target, src: self.src.clone() }\n+    fn build<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                 -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Build)\n     }\n \n-    // Define ergonomic constructors for each step defined above so they can be\n-    // easily constructed.\n-    targets!(constructors);\n+    fn test<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Test)\n+    }\n \n-    /// Mapping of all dependencies for rustbuild.\n-    ///\n-    /// This function receives a step, the build that we're building for, and\n-    /// then returns a list of all the dependencies of that step.\n-    pub fn deps(&self, build: &'a Build) -> Vec<Step<'a>> {\n-        match self.src {\n-            Source::Rustc { stage: 0 } => {\n-                Vec::new()\n-            }\n-            Source::Rustc { stage } => {\n-                let compiler = Compiler::new(stage - 1, &build.config.build);\n-                vec![self.librustc(compiler)]\n-            }\n-            Source::Librustc { compiler } => {\n-                vec![self.libtest(compiler), self.llvm(())]\n-            }\n-            Source::Libtest { compiler } => {\n-                vec![self.libstd(compiler)]\n-            }\n-            Source::Libstd { compiler } => {\n-                vec![self.rustc(compiler.stage).target(compiler.host)]\n-            }\n-            Source::LibrustcLink { compiler, host } => {\n-                vec![self.librustc(compiler),\n-                     self.libtest_link(compiler, host)]\n-            }\n-            Source::LibtestLink { compiler, host } => {\n-                vec![self.libtest(compiler), self.libstd_link(compiler, host)]\n-            }\n-            Source::LibstdLink { compiler, host } => {\n-                vec![self.libstd(compiler),\n-                     self.target(host).rustc(compiler.stage)]\n-            }\n-            Source::Llvm { _dummy } => Vec::new(),\n-            Source::TestHelpers { _dummy } => Vec::new(),\n-            Source::DebuggerScripts { stage: _ } => Vec::new(),\n-\n-            // Note that all doc targets depend on artifacts from the build\n-            // architecture, not the target (which is where we're generating\n-            // docs into).\n-            Source::DocStd { stage } => {\n-                let compiler = self.target(&build.config.build).compiler(stage);\n-                vec![self.libstd(compiler)]\n-            }\n-            Source::DocTest { stage } => {\n-                let compiler = self.target(&build.config.build).compiler(stage);\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::DocBook { stage } |\n-            Source::DocNomicon { stage } => {\n-                vec![self.target(&build.config.build).tool_rustbook(stage)]\n-            }\n-            Source::DocErrorIndex { stage } => {\n-                vec![self.target(&build.config.build).tool_error_index(stage)]\n-            }\n-            Source::DocStandalone { stage } => {\n-                vec![self.target(&build.config.build).rustc(stage)]\n-            }\n-            Source::DocRustc { stage } => {\n-                vec![self.doc_test(stage)]\n-            }\n-            Source::Doc { stage } => {\n-                let mut deps = vec![\n-                    self.doc_book(stage), self.doc_nomicon(stage),\n-                    self.doc_standalone(stage), self.doc_std(stage),\n-                    self.doc_error_index(stage),\n-                ];\n-\n-                if build.config.compiler_docs {\n-                    deps.push(self.doc_rustc(stage));\n-                }\n+    fn doc<'b>(&'b mut self, name: &'a str, path: &'a str)\n+               -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Doc)\n+    }\n \n-                deps\n-            }\n-            Source::Check { stage, compiler } => {\n-                // Check is just a pseudo step which means check all targets,\n-                // so just depend on checking all targets.\n-                build.config.target.iter().map(|t| {\n-                    self.target(t).check_target(stage, compiler)\n-                }).collect()\n-            }\n-            Source::CheckTarget { stage, compiler } => {\n-                // CheckTarget here means run all possible test suites for this\n-                // target. Most of the time, however, we can't actually run\n-                // anything if we're not the build triple as we could be cross\n-                // compiling.\n-                //\n-                // As a result, the base set of targets here is quite stripped\n-                // down from the standard set of targets. These suites have\n-                // their own internal logic to run in cross-compiled situations\n-                // if they'll run at all. For example compiletest knows that\n-                // when testing Android targets we ship artifacts to the\n-                // emulator.\n-                //\n-                // When in doubt the rule of thumb for adding to this list is\n-                // \"should this test suite run on the android bot?\"\n-                let mut base = vec![\n-                    self.check_rpass(compiler),\n-                    self.check_rfail(compiler),\n-                    self.check_crate_std(compiler),\n-                    self.check_crate_test(compiler),\n-                    self.check_debuginfo(compiler),\n-                ];\n-\n-                // If we're testing the build triple, then we know we can\n-                // actually run binaries and such, so we run all possible tests\n-                // that we know about.\n-                if self.target == build.config.build {\n-                    base.extend(vec![\n-                        // docs-related\n-                        self.check_docs(compiler),\n-                        self.check_error_index(compiler),\n-                        self.check_rustdoc(compiler),\n-\n-                        // UI-related\n-                        self.check_cfail(compiler),\n-                        self.check_pfail(compiler),\n-                        self.check_ui(compiler),\n-\n-                        // codegen-related\n-                        self.check_incremental(compiler),\n-                        self.check_codegen(compiler),\n-                        self.check_codegen_units(compiler),\n-\n-                        // misc compiletest-test suites\n-                        self.check_rpass_full(compiler),\n-                        self.check_rfail_full(compiler),\n-                        self.check_cfail_full(compiler),\n-                        self.check_pretty_rpass_full(compiler),\n-                        self.check_pretty_rfail_full(compiler),\n-                        self.check_rpass_valgrind(compiler),\n-                        self.check_rmake(compiler),\n-                        self.check_mir_opt(compiler),\n-\n-                        // crates\n-                        self.check_crate_rustc(compiler),\n-\n-                        // pretty\n-                        self.check_pretty(compiler),\n-                        self.check_pretty_rpass(compiler),\n-                        self.check_pretty_rfail(compiler),\n-                        self.check_pretty_rpass_valgrind(compiler),\n-\n-                        // misc\n-                        self.check_linkcheck(stage),\n-                        self.check_tidy(stage),\n-\n-                        // can we make the distributables?\n-                        self.dist(stage),\n-                    ]);\n-                }\n-                base\n-            }\n-            Source::CheckLinkcheck { stage } => {\n-                vec![self.tool_linkchecker(stage), self.doc(stage)]\n-            }\n-            Source::CheckCargoTest { stage } => {\n-                vec![self.tool_cargotest(stage),\n-                     self.librustc(self.compiler(stage))]\n-            }\n-            Source::CheckTidy { stage } => {\n-                vec![self.tool_tidy(stage)]\n-            }\n-            Source::CheckMirOpt { compiler} |\n-            Source::CheckPrettyRPass { compiler } |\n-            Source::CheckPrettyRFail { compiler } |\n-            Source::CheckRFail { compiler } |\n-            Source::CheckPFail { compiler } |\n-            Source::CheckCodegen { compiler } |\n-            Source::CheckCodegenUnits { compiler } |\n-            Source::CheckIncremental { compiler } |\n-            Source::CheckUi { compiler } |\n-            Source::CheckPretty { compiler } |\n-            Source::CheckCFail { compiler } |\n-            Source::CheckRPassValgrind { compiler } |\n-            Source::CheckRPass { compiler } => {\n-                let mut base = vec![\n-                    self.libtest(compiler),\n-                    self.target(compiler.host).tool_compiletest(compiler.stage),\n-                    self.test_helpers(()),\n-                ];\n-                if self.target.contains(\"android\") {\n-                    base.push(self.android_copy_libs(compiler));\n-                }\n-                base\n-            }\n-            Source::CheckDebuginfo { compiler } => {\n-                vec![\n-                    self.libtest(compiler),\n-                    self.target(compiler.host).tool_compiletest(compiler.stage),\n-                    self.test_helpers(()),\n-                    self.debugger_scripts(compiler.stage),\n-                ]\n-            }\n-            Source::CheckRustdoc { compiler } |\n-            Source::CheckRPassFull { compiler } |\n-            Source::CheckRFailFull { compiler } |\n-            Source::CheckCFailFull { compiler } |\n-            Source::CheckPrettyRPassFull { compiler } |\n-            Source::CheckPrettyRFailFull { compiler } |\n-            Source::CheckPrettyRPassValgrind { compiler } |\n-            Source::CheckRMake { compiler } => {\n-                vec![self.librustc(compiler),\n-                     self.target(compiler.host).tool_compiletest(compiler.stage)]\n-            }\n-            Source::CheckDocs { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckErrorIndex { compiler } => {\n-                vec![self.libstd(compiler),\n-                     self.target(compiler.host).tool_error_index(compiler.stage)]\n-            }\n-            Source::CheckCrateStd { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckCrateTest { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckCrateRustc { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n+    fn dist<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Dist)\n+    }\n \n-            Source::ToolLinkchecker { stage } |\n-            Source::ToolTidy { stage } => {\n-                vec![self.libstd(self.compiler(stage))]\n-            }\n-            Source::ToolErrorIndex { stage } |\n-            Source::ToolRustbook { stage } => {\n-                vec![self.librustc(self.compiler(stage))]\n-            }\n-            Source::ToolCargoTest { stage } => {\n-                vec![self.libstd(self.compiler(stage))]\n-            }\n-            Source::ToolCompiletest { stage } => {\n-                vec![self.libtest(self.compiler(stage))]\n-            }\n+    fn rule<'b>(&'b mut self,\n+                name: &'a str,\n+                path: &'a str,\n+                kind: Kind) -> RuleBuilder<'a, 'b> {\n+        RuleBuilder {\n+            rules: self,\n+            rule: Rule::new(name, path, kind),\n+        }\n+    }\n+\n+    /// Verify the dependency graph defined by all our rules are correct, e.g.\n+    /// everything points to a valid something else.\n+    fn verify(&self) {\n+        for rule in self.rules.values() {\n+            for dep in rule.deps.iter() {\n+                let dep = dep(&self.sbuild.name(rule.name));\n+                if self.rules.contains_key(&dep.name) || dep.name.starts_with(\"default:\") {\n+                    continue }\n+                panic!(\"\\\n+\n+invalid rule dependency graph detected, was a rule added and maybe typo'd?\n+\n+    `{}` depends on `{}` which does not exist\n \n-            Source::DistDocs { stage } => vec![self.doc(stage)],\n-            Source::DistMingw { _dummy: _ } => Vec::new(),\n-            Source::DistRustc { stage } => {\n-                vec![self.rustc(stage)]\n+\", rule.name, dep.name);\n             }\n-            Source::DistStd { compiler } => {\n-                // We want to package up as many target libraries as possible\n-                // for the `rust-std` package, so if this is a host target we\n-                // depend on librustc and otherwise we just depend on libtest.\n-                if build.config.host.iter().any(|t| t == self.target) {\n-                    vec![self.librustc(compiler)]\n+        }\n+    }\n+\n+    pub fn print_help(&self, command: &str) {\n+        let kind = match command {\n+            \"build\" => Kind::Build,\n+            \"doc\" => Kind::Doc,\n+            \"test\" => Kind::Test,\n+            \"dist\" => Kind::Dist,\n+            _ => return,\n+        };\n+        let rules = self.rules.values().filter(|r| r.kind == kind);\n+        let rules = rules.filter(|r| !r.path.contains(\"nowhere\"));\n+        let mut rules = rules.collect::<Vec<_>>();\n+        rules.sort_by_key(|r| r.path);\n+\n+        println!(\"Available paths:\\n\");\n+        for rule in rules {\n+            print!(\"    ./x.py {} {}\", command, rule.path);\n+\n+            println!(\"\");\n+        }\n+    }\n+\n+    /// Construct the top-level build steps that we're going to be executing,\n+    /// given the subcommand that our build is performing.\n+    fn plan(&self) -> Vec<Step<'a>> {\n+        let (kind, paths) = match self.build.flags.cmd {\n+            Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n+            Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n+            Subcommand::Test { ref paths, test_args: _ } => (Kind::Test, &paths[..]),\n+            Subcommand::Dist { install } => {\n+                if install {\n+                    return vec![self.sbuild.name(\"install\")]\n                 } else {\n-                    vec![self.libtest(compiler)]\n-                }\n-            }\n-            Source::DistSrc { _dummy: _ } => Vec::new(),\n-\n-            Source::Dist { stage } => {\n-                let mut base = Vec::new();\n-\n-                for host in build.config.host.iter() {\n-                    let host = self.target(host);\n-                    base.push(host.dist_src(()));\n-                    base.push(host.dist_rustc(stage));\n-                    if host.target.contains(\"windows-gnu\") {\n-                        base.push(host.dist_mingw(()));\n-                    }\n-\n-                    let compiler = self.compiler(stage);\n-                    for target in build.config.target.iter() {\n-                        let target = self.target(target);\n-                        if build.config.docs {\n-                            base.push(target.dist_docs(stage));\n-                        }\n-                        base.push(target.dist_std(compiler));\n-                    }\n+                    (Kind::Dist, &[][..])\n                 }\n-                base\n             }\n+            Subcommand::Clean => panic!(),\n+        };\n \n-            Source::Install { stage } => {\n-                vec![self.dist(stage)]\n-            }\n+        self.rules.values().filter(|rule| rule.kind == kind).filter(|rule| {\n+            (paths.len() == 0 && rule.default) || paths.iter().any(|path| {\n+                path.ends_with(rule.path)\n+            })\n+        }).flat_map(|rule| {\n+            let hosts = if self.build.flags.host.len() > 0 {\n+                &self.build.flags.host\n+            } else {\n+                &self.build.config.host\n+            };\n+            let targets = if self.build.flags.target.len() > 0 {\n+                &self.build.flags.target\n+            } else {\n+                &self.build.config.target\n+            };\n+            let arr = if rule.host {hosts} else {targets};\n+\n+            hosts.iter().flat_map(move |host| {\n+                arr.iter().map(move |target| {\n+                    self.sbuild.name(rule.name).target(target).host(host)\n+                })\n+            })\n+        }).collect()\n+    }\n+\n+    /// Execute all top-level targets indicated by `steps`.\n+    ///\n+    /// This will take the list returned by `plan` and then execute each step\n+    /// along with all required dependencies as it goes up the chain.\n+    fn run(&self, steps: &[Step<'a>]) {\n+        self.build.verbose(\"bootstrap top targets:\");\n+        for step in steps.iter() {\n+            self.build.verbose(&format!(\"\\t{:?}\", step));\n+        }\n+\n+        // Using `steps` as the top-level targets, make a topological ordering\n+        // of what we need to do.\n+        let mut order = Vec::new();\n+        let mut added = HashSet::new();\n+        for step in steps.iter().cloned() {\n+            self.fill(step, &mut order, &mut added);\n+        }\n \n-            Source::AndroidCopyLibs { compiler } => {\n-                vec![self.libtest(compiler)]\n+        // Print out what we're doing for debugging\n+        self.build.verbose(\"bootstrap build plan:\");\n+        for step in order.iter() {\n+            self.build.verbose(&format!(\"\\t{:?}\", step));\n+        }\n+\n+        // And finally, iterate over everything and execute it.\n+        for step in order.iter() {\n+            (self.rules[step.name].run)(step);\n+        }\n+    }\n+\n+    fn fill(&self,\n+            step: Step<'a>,\n+            order: &mut Vec<Step<'a>>,\n+            added: &mut HashSet<Step<'a>>) {\n+        if !added.insert(step.clone()) {\n+            return\n+        }\n+        for dep in self.rules[step.name].deps.iter() {\n+            let dep = dep(&step);\n+            if dep.name.starts_with(\"default:\") {\n+                let kind = match &dep.name[8..] {\n+                    \"doc\" => Kind::Doc,\n+                    \"dist\" => Kind::Dist,\n+                    kind => panic!(\"unknown kind: `{}`\", kind),\n+                };\n+                let rules = self.rules.values().filter(|r| r.default);\n+                for rule in rules.filter(|r| r.kind == kind) {\n+                    self.fill(dep.name(rule.name), order, added);\n+                }\n+            } else {\n+                self.fill(dep, order, added);\n             }\n         }\n+        order.push(step);\n     }\n }"}, {"sha": "d552f5928a929f9c69bac722cc0e8b5279093dc3", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -57,8 +57,7 @@ pub fn cp_r(src: &Path, dst: &Path) {\n         let name = path.file_name().unwrap();\n         let dst = dst.join(name);\n         if t!(f.file_type()).is_dir() {\n-            let _ = fs::remove_dir_all(&dst);\n-            t!(fs::create_dir(&dst));\n+            t!(fs::create_dir_all(&dst));\n             cp_r(&path, &dst);\n         } else {\n             let _ = fs::remove_file(&dst);"}, {"sha": "c92e4d8f5aba563c35cbb876c7c449f5e59b38c6", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -11,4 +11,4 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "54148b0d2b29de511ff955d3d2a5e46d04f5326e", "filename": "x.py", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/x.py", "raw_url": "https://github.com/rust-lang/rust/raw/a270b8014cbd3af6e03f7f808a2fea1e9f22ed88/x.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/x.py?ref=a270b8014cbd3af6e03f7f808a2fea1e9f22ed88", "patch": "@@ -0,0 +1,19 @@\n+#!/usr/bin/env python\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+import os\n+dir = os.path.dirname(__file__)\n+sys.path.append(os.path.abspath(os.path.join(dir, \"src\", \"bootstrap\")))\n+\n+import bootstrap\n+\n+bootstrap.main()"}]}