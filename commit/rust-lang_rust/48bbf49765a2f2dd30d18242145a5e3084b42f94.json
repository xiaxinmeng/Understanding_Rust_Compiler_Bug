{"sha": "48bbf49765a2f2dd30d18242145a5e3084b42f94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YmJmNDk3NjVhMmYyZGQzMGQxODI0MjE0NWE1ZTMwODRiNDJmOTQ=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-06T21:49:53Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-15T10:58:32Z"}, "message": "const generics work!", "tree": {"sha": "a970bcc72abb88ec91614b80c6fc5f34f4d1b11b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a970bcc72abb88ec91614b80c6fc5f34f4d1b11b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48bbf49765a2f2dd30d18242145a5e3084b42f94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48bbf49765a2f2dd30d18242145a5e3084b42f94", "html_url": "https://github.com/rust-lang/rust/commit/48bbf49765a2f2dd30d18242145a5e3084b42f94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48bbf49765a2f2dd30d18242145a5e3084b42f94/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b615b98f33c73670731c7e681a45a8335049492e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b615b98f33c73670731c7e681a45a8335049492e", "html_url": "https://github.com/rust-lang/rust/commit/b615b98f33c73670731c7e681a45a8335049492e"}], "stats": {"total": 442, "additions": 301, "deletions": 141}, "files": [{"sha": "be153758a2a0c0d0e76e2a1bb676148ef7388d2d", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -112,7 +112,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         })\n     }\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n-    promoted_mir => { cdata.get_promoted_mir(tcx, def_id.index) }\n+    promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }"}, {"sha": "b77aca4d6348d6d5bce06aba9f82fe1b5208aa63", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -31,10 +31,20 @@ macro_rules! arena_types {\n                         rustc_middle::mir::Body<$tcx>\n                     >\n                 >;\n+            [] promoted:\n+                rustc_index::vec::IndexVec<\n+                    rustc_middle::mir::Promoted,\n+                    rustc_middle::mir::Body<$tcx>\n+                >,\n+                rustc_index::vec::IndexVec<\n+                    rustc_middle::mir::Promoted,\n+                    rustc_middle::mir::Body<'_x>\n+                >;\n             [decode] tables: rustc_middle::ty::TypeckTables<$tcx>, rustc_middle::ty::TypeckTables<'_x>;\n             [decode] borrowck_result:\n                 rustc_middle::mir::BorrowCheckResult<$tcx>,\n                 rustc_middle::mir::BorrowCheckResult<'_x>;\n+            [] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult, rustc_middle::mir::UnsafetyCheckResult;\n             [] const_allocs: rustc_middle::mir::interpret::Allocation, rustc_middle::mir::interpret::Allocation;\n             // Required for the incremental on-disk cache\n             [few, decode] mir_keys: rustc_hir::def_id::DefIdSet, rustc_hir::def_id::DefIdSet;"}, {"sha": "f1deb6388af5940a820ffa26c30d2e942be1d6e1", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -208,19 +208,27 @@ rustc_queries! {\n             desc { |tcx| \"const checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n+        query mir_const_qualif_const_arg(\n+            key: ty::WithOptParam<LocalDefId>\n+        ) -> mir::ConstQualifs {\n+            desc {\n+                |tcx| \"const checking the potential const argument `{}`\",\n+                tcx.def_path_str(key.did.to_def_id())\n+            }\n+        }\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(key: LocalDefId) -> &'tcx Steal<mir::Body<'tcx>> {\n-            desc { |tcx| \"building MIR for `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        query mir_built(key: ty::WithOptParam<LocalDefId>) -> &'tcx Steal<mir::Body<'tcx>> {\n+            desc { |tcx| \"building MIR for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n         }\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const qualification.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(key: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n-            desc { |tcx| \"processing MIR for `{}`\", tcx.def_path_str(key) }\n+        query mir_const(key: ty::WithOptParam<LocalDefId>) -> &'tcx Steal<mir::Body<'tcx>> {\n+            desc { |tcx| \"processing MIR for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n             no_hash\n         }\n \n@@ -231,13 +239,16 @@ rustc_queries! {\n             desc { |tcx| \"elaborating drops for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n         }\n \n-        query mir_validated(key: LocalDefId) ->\n+        query mir_validated(key: ty::WithOptParam<LocalDefId>) ->\n             (\n                 &'tcx Steal<mir::Body<'tcx>>,\n                 &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n             ) {\n             no_hash\n-            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            desc {\n+                |tcx| \"processing the potential const argument `{}`\",\n+                tcx.def_path_str(key.did.to_def_id())\n+            }\n         }\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n@@ -261,11 +272,18 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n-        query promoted_mir(key: DefId) -> IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n             desc { |tcx| \"optimizing promoted MIR for `{}`\", tcx.def_path_str(key) }\n-            storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n         }\n+        query promoted_mir_of_const_arg(\n+            key: ty::WithOptParam<LocalDefId>\n+        ) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+            desc {\n+                |tcx| \"optimizing promoted MIR for the potential const argument `{}`\",\n+                tcx.def_path_str(key.did.to_def_id()),\n+            }\n+        }\n     }\n \n     TypeChecking {\n@@ -473,11 +491,13 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        /// The result of unsafety-checking this `DefId`.\n-        query unsafety_check_result(key: LocalDefId) -> mir::UnsafetyCheckResult {\n+        /// The result of unsafety-checking this `LocalDefId`.\n+        query unsafety_check_result(key: LocalDefId) -> &'tcx mir::UnsafetyCheckResult {\n             desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if { true }\n-            storage(ArenaCacheSelector<'tcx>)\n+        }\n+        query unsafety_check_result_const_arg(key: ty::WithOptParam<LocalDefId>) -> &'tcx mir::UnsafetyCheckResult {\n+            desc { |tcx| \"unsafety-checking the potential const arg `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n         }\n \n         /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error.\n@@ -601,13 +621,18 @@ rustc_queries! {\n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n         query mir_borrowck(key: LocalDefId) -> &'tcx mir::BorrowCheckResult<'tcx> {\n-            storage(ArenaCacheSelector<'tcx>)\n             desc { |tcx| \"borrow-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if(tcx, opt_result) {\n                 tcx.is_closure(key.to_def_id())\n                     || opt_result.map_or(false, |r| !r.concrete_opaque_types.is_empty())\n             }\n         }\n+        query mir_borrowck_const_arg(key: ty::WithOptParam<LocalDefId>) -> &'tcx mir::BorrowCheckResult<'tcx> {\n+            desc {\n+                |tcx| \"borrow-checking the potential const argument`{}`\",\n+                tcx.def_path_str(key.did.to_def_id())\n+            }\n+        }\n     }\n \n     TypeChecking {"}, {"sha": "9ebf1ed60e2ffb1905c37903bd74ee8f61b1b831", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -1600,13 +1600,21 @@ impl WithOptParam<DefId> {\n         self.did.as_local().map(|did| WithOptParam { did, param_did: self.param_did })\n     }\n \n+    pub fn expect_local(self) -> WithOptParam<LocalDefId> {\n+        self.as_local().unwrap()\n+    }\n+\n     pub fn is_local(self) -> bool {\n         self.did.is_local()\n     }\n \n     pub fn ty_def_id(self) -> DefId {\n         self.param_did.unwrap_or(self.did)\n     }\n+\n+    pub fn init_me_bby(tcx: TyCtxt<'_>, did: DefId) -> WithOptParam<DefId> {\n+        WithOptParam { did, param_did: did.as_local().and_then(|did| tcx.opt_const_param_of(did)) }\n+    }\n }\n \n /// When type checking, we use the `ParamEnv` to track"}, {"sha": "ae2820b460fe3d3a629efe5b9545b8d0718ed684", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -578,12 +578,12 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n \n         // FIXME(const_generics): this is wrong, as it is a projection\n         (\n-            ty::ConstKind::Unevaluated(a_def_id, a_substs, a_promoted),\n-            ty::ConstKind::Unevaluated(b_def_id, b_substs, b_promoted),\n-        ) if a_def_id == b_def_id && a_promoted == b_promoted => {\n+            ty::ConstKind::Unevaluated(a_def, a_substs, a_promoted),\n+            ty::ConstKind::Unevaluated(b_def, b_substs, b_promoted),\n+        ) if a_def == b_def && a_promoted == b_promoted => {\n             let substs =\n                 relation.relate_with_variance(ty::Variance::Invariant, a_substs, b_substs)?;\n-            Ok(ty::ConstKind::Unevaluated(a_def_id, substs, a_promoted))\n+            Ok(ty::ConstKind::Unevaluated(a_def, substs, a_promoted))\n         }\n         _ => Err(TypeError::ConstMismatch(expected_found(relation, a, b))),\n     };"}, {"sha": "b4ddda5c03d0c5f8d9b540048717bcf70b2af4a9", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, InstanceDef, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n \n@@ -87,17 +87,32 @@ crate struct Upvar {\n const DEREF_PROJECTION: &[PlaceElem<'_>; 1] = &[ProjectionElem::Deref];\n \n pub fn provide(providers: &mut Providers) {\n-    *providers = Providers { mir_borrowck, ..*providers };\n+    *providers = Providers {\n+        mir_borrowck: |tcx, did| mir_borrowck(tcx, ty::WithOptParam::dummy(did)),\n+        mir_borrowck_const_arg: |tcx, def| {\n+            if def.param_did.is_none() { tcx.mir_borrowck(def.did) } else { mir_borrowck(tcx, def) }\n+        },\n+        ..*providers\n+    };\n }\n \n-fn mir_borrowck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx BorrowCheckResult<'tcx> {\n-    let (input_body, promoted) = tcx.mir_validated(def_id);\n-    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id.to_def_id()));\n+fn mir_borrowck<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptParam<LocalDefId>,\n+) -> &'tcx BorrowCheckResult<'tcx> {\n+    if def.param_did.is_none() {\n+        if let param_did @ Some(_) = tcx.opt_const_param_of(def.did) {\n+            return tcx.mir_borrowck_const_arg(ty::WithOptParam { param_did, ..def });\n+        }\n+    }\n+\n+    let (input_body, promoted) = tcx.mir_validated(def);\n+    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        do_mir_borrowck(&infcx, input_body, promoted, def_id)\n+        do_mir_borrowck(&infcx, input_body, promoted, def)\n     });\n     debug!(\"mir_borrowck done\");\n \n@@ -108,13 +123,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n-    def_id: LocalDefId,\n+    def: ty::WithOptParam<LocalDefId>,\n ) -> BorrowCheckResult<'tcx> {\n-    debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n+    debug!(\"do_mir_borrowck(def = {:?})\", def);\n \n     let tcx = infcx.tcx;\n-    let param_env = tcx.param_env(def_id);\n-    let id = tcx.hir().as_local_hir_id(def_id);\n+    let param_env = tcx.param_env(def.did);\n+    let id = tcx.hir().as_local_hir_id(def.did);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n     for var_debug_info in &input_body.var_debug_info {\n@@ -135,13 +150,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     }\n \n     // Gather the upvars of a closure, if any.\n-    let tables = tcx.typeck_tables_of(def_id);\n+    let tables = tcx.typeck_tables_of_const_arg(def);\n     if let Some(ErrorReported) = tables.tainted_by_errors {\n         infcx.set_tainted_by_errors();\n     }\n     let upvars: Vec<_> = tables\n         .closure_captures\n-        .get(&def_id.to_def_id())\n+        .get(&def.did.to_def_id())\n         .into_iter()\n         .flat_map(|v| v.values())\n         .map(|upvar_id| {\n@@ -171,8 +186,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // will have a lifetime tied to the inference context.\n     let mut body = input_body.clone();\n     let mut promoted = input_promoted.clone();\n-    let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n+    let free_regions = nll::replace_regions_in_mir(infcx, def, param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n \n     let location_table = &LocationTable::new(&body);\n@@ -190,7 +204,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mdpe = MoveDataParamEnv { move_data, param_env };\n \n     let mut flow_inits = MaybeInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id.to_def_id())\n+        .into_engine(tcx, &body, def.did.to_def_id())\n         .iterate_to_fixpoint()\n         .into_results_cursor(&body);\n \n@@ -207,7 +221,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         nll_errors,\n     } = nll::compute_regions(\n         infcx,\n-        def_id,\n+        def.did,\n         free_regions,\n         body,\n         &promoted,\n@@ -223,7 +237,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // write unit-tests, as well as helping with debugging.\n     nll::dump_mir_results(\n         infcx,\n-        MirSource::item(def_id.to_def_id()),\n+        MirSource { instance: InstanceDef::Item(def.to_global()), promoted: None },\n         &body,\n         &regioncx,\n         &opt_closure_req,\n@@ -234,7 +248,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     nll::dump_annotation(\n         infcx,\n         &body,\n-        def_id.to_def_id(),\n+        def.did.to_def_id(),\n         &regioncx,\n         &opt_closure_req,\n         &opaque_type_values,\n@@ -249,13 +263,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let regioncx = Rc::new(regioncx);\n \n     let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n-        .into_engine(tcx, &body, def_id.to_def_id())\n+        .into_engine(tcx, &body, def.did.to_def_id())\n         .iterate_to_fixpoint();\n     let flow_uninits = MaybeUninitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id.to_def_id())\n+        .into_engine(tcx, &body, def.did.to_def_id())\n         .iterate_to_fixpoint();\n     let flow_ever_inits = EverInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id.to_def_id())\n+        .into_engine(tcx, &body, def.did.to_def_id())\n         .iterate_to_fixpoint();\n \n     let movable_generator = match tcx.hir().get(id) {\n@@ -274,7 +288,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             let mut promoted_mbcx = MirBorrowckCtxt {\n                 infcx,\n                 body: promoted_body,\n-                mir_def_id: def_id,\n+                mir_def_id: def.did,\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n@@ -307,7 +321,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n         body,\n-        mir_def_id: def_id,\n+        mir_def_id: def.did,\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,"}, {"sha": "f1e7f4c26f4b455a914a2b9a348d27787740a608", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, RegionKind, RegionVid};\n+use rustc_middle::ty::{self, InstanceDef, RegionKind, RegionVid};\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;\n@@ -59,20 +59,20 @@ crate struct NllOutput<'tcx> {\n /// `compute_regions`.\n pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def_id: LocalDefId,\n+    def: ty::WithOptParam<LocalDefId>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n-    debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n+    debug!(\"replace_regions_in_mir(def={:?})\", def);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n-    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n+    let universal_regions = UniversalRegions::new(infcx, def, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);\n \n-    let source = MirSource::item(def_id.to_def_id());\n+    let source = MirSource { instance: InstanceDef::Item(def.to_global()), promoted: None };\n     mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n \n     universal_regions"}, {"sha": "1e2d94a1df41e5460b9795a36a79a167c9534d68", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -227,12 +227,12 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// known between those regions.\n     pub fn new(\n         infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: LocalDefId,\n+        mir_def: ty::WithOptParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let tcx = infcx.tcx;\n-        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id);\n-        UniversalRegionsBuilder { infcx, mir_def_id, mir_hir_id, param_env }.build()\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def.did);\n+        UniversalRegionsBuilder { infcx, mir_def, mir_hir_id, param_env }.build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values\n@@ -388,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    mir_def_id: LocalDefId,\n+    mir_def: ty::WithOptParam<LocalDefId>,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n@@ -397,7 +397,7 @@ const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n \n impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     fn build(self) -> UniversalRegions<'tcx> {\n-        debug!(\"build(mir_def_id={:?})\", self.mir_def_id);\n+        debug!(\"build(mir_def={:?})\", self.mir_def);\n \n         let param_env = self.param_env;\n         debug!(\"build: param_env={:?}\", param_env);\n@@ -417,16 +417,17 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let mut indices = self.compute_indices(fr_static, defining_ty);\n         debug!(\"build: indices={:?}\", indices);\n \n-        let closure_base_def_id = self.infcx.tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n+        let closure_base_def_id = self.infcx.tcx.closure_base_def_id(self.mir_def.did.to_def_id());\n \n         // If this is a closure or generator, then the late-bound regions from the enclosing\n         // function are actually external regions to us. For example, here, 'a is not local\n         // to the closure c (although it is local to the fn foo):\n         // fn foo<'a>() {\n         //     let c = || { let x: &'a u32 = ...; }\n         // }\n-        if self.mir_def_id.to_def_id() != closure_base_def_id {\n-            self.infcx.replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices)\n+        if self.mir_def.did.to_def_id() != closure_base_def_id {\n+            self.infcx\n+                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def.did, &mut indices)\n         }\n \n         let bound_inputs_and_output = self.compute_inputs_and_output(&indices, defining_ty);\n@@ -436,15 +437,15 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let first_local_index = self.infcx.num_region_vars();\n         let inputs_and_output = self.infcx.replace_bound_regions_with_nll_infer_vars(\n             FR,\n-            self.mir_def_id,\n+            self.mir_def.did,\n             &bound_inputs_and_output,\n             &mut indices,\n         );\n         // Converse of above, if this is a function then the late-bound regions declared on its\n         // signature are local to the fn.\n-        if self.mir_def_id.to_def_id() == closure_base_def_id {\n+        if self.mir_def.did.to_def_id() == closure_base_def_id {\n             self.infcx\n-                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices);\n+                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def.did, &mut indices);\n         }\n \n         let (unnormalized_output_ty, mut unnormalized_input_tys) =\n@@ -456,7 +457,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             if self.infcx.tcx.fn_sig(def_id).c_variadic() {\n                 let va_list_did = self.infcx.tcx.require_lang_item(\n                     lang_items::VaListTypeLangItem,\n-                    Some(self.infcx.tcx.def_span(self.mir_def_id)),\n+                    Some(self.infcx.tcx.def_span(self.mir_def.did)),\n                 );\n                 let region = self\n                     .infcx\n@@ -507,14 +508,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     /// see `DefiningTy` for details.\n     fn defining_ty(&self) -> DefiningTy<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def.did.to_def_id());\n \n         match tcx.hir().body_owner_kind(self.mir_hir_id) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = if self.mir_def_id.to_def_id() == closure_base_def_id {\n+                let defining_ty = if self.mir_def.did.to_def_id() == closure_base_def_id {\n                     tcx.type_of(closure_base_def_id)\n                 } else {\n-                    let tables = tcx.typeck_tables_of(self.mir_def_id);\n+                    let tables = tcx.typeck_tables_of(self.mir_def.did);\n                     tables.node_type(self.mir_hir_id)\n                 };\n \n@@ -530,20 +531,20 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     }\n                     ty::FnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n                     _ => span_bug!(\n-                        tcx.def_span(self.mir_def_id),\n+                        tcx.def_span(self.mir_def.did),\n                         \"expected defining type for `{:?}`: `{:?}`\",\n-                        self.mir_def_id,\n+                        self.mir_def.did,\n                         defining_ty\n                     ),\n                 }\n             }\n \n             BodyOwnerKind::Const | BodyOwnerKind::Static(..) => {\n-                assert_eq!(self.mir_def_id.to_def_id(), closure_base_def_id);\n+                assert_eq!(self.mir_def.did.to_def_id(), closure_base_def_id);\n                 let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n                 let substs =\n                     self.infcx.replace_free_regions_with_nll_infer_vars(FR, &identity_substs);\n-                DefiningTy::Const(self.mir_def_id.to_def_id(), substs)\n+                DefiningTy::Const(self.mir_def.did.to_def_id(), substs)\n             }\n         }\n     }\n@@ -558,7 +559,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def.did.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, ref substs) | DefiningTy::Generator(_, ref substs, _) => {\n@@ -592,7 +593,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n-                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n+                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n                 let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n@@ -616,7 +617,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n-                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n+                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let resume_ty = substs.as_generator().resume_ty();\n                 let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n@@ -634,8 +635,8 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             DefiningTy::Const(def_id, _) => {\n                 // For a constant body, there are no inputs, and one\n                 // \"output\" (the type of the constant).\n-                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n-                let ty = tcx.type_of(def_id);\n+                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n+                let ty = tcx.type_of(self.mir_def.ty_def_id());\n                 let ty = indices.fold_to_region_vids(tcx, &ty);\n                 ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n             }"}, {"sha": "c3f992877ead65f6411b933b4121cd1f4330054a", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -359,7 +359,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                     // deny-by-default lint\n                     _ => {\n                         if let Some(p) = cid.promoted {\n-                            let span = tcx.promoted_mir(def.did)[p].span;\n+                            let span = tcx.promoted_mir_of_const_arg(def)[p].span;\n                             if let err_inval!(ReferencedConstant) = err.error {\n                                 err.report_as_error(\n                                     tcx.at(span),"}, {"sha": "bfef9c1b3535a0f4ef233d12157a024fc6ef70a8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -406,7 +406,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         if let Some(promoted) = promoted {\n-            return Ok(&self.tcx.promoted_mir(def.did)[promoted]);\n+            return if let Some(def) = def.as_local() {\n+                Ok(&self.tcx.promoted_mir_of_const_arg(def)[promoted])\n+            } else {\n+                Ok(&self.tcx.promoted_mir(def.did)[promoted])\n+            };\n         }\n         match instance {\n             ty::InstanceDef::Item(def) => {"}, {"sha": "a03d3fbb68ed963a15a411757082bd520b67cf8b", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -248,7 +248,12 @@ where\n         assert!(promoted.is_none());\n         // Don't peek inside trait associated constants.\n         if cx.tcx.trait_of_item(def.did).is_none() {\n-            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def.did);\n+            let qualifs = if let Some(def) = def.as_local() {\n+                cx.tcx.at(constant.span).mir_const_qualif_const_arg(def)\n+            } else {\n+                cx.tcx.at(constant.span).mir_const_qualif(def.did)\n+            };\n+\n             if !Q::in_qualifs(&qualifs) {\n                 return false;\n             }"}, {"sha": "6d270a9c68428f62507337dbc2a5b17492019c8e", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -489,7 +489,20 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n }\n \n pub(crate) fn provide(providers: &mut Providers) {\n-    *providers = Providers { unsafety_check_result, unsafe_derive_on_repr_packed, ..*providers };\n+    *providers = Providers {\n+        unsafety_check_result: |tcx, def_id| {\n+            unsafety_check_result(tcx, ty::WithOptParam::dummy(def_id))\n+        },\n+        unsafety_check_result_const_arg: |tcx, def| {\n+            if def.param_did.is_none() {\n+                tcx.unsafety_check_result(def.did)\n+            } else {\n+                unsafety_check_result(tcx, def)\n+            }\n+        },\n+        unsafe_derive_on_repr_packed,\n+        ..*providers\n+    };\n }\n \n struct UnusedUnsafeVisitor<'a> {\n@@ -535,32 +548,42 @@ fn check_unused_unsafe(\n     intravisit::Visitor::visit_body(&mut visitor, body);\n }\n \n-fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: LocalDefId) -> UnsafetyCheckResult {\n-    debug!(\"unsafety_violations({:?})\", def_id);\n+fn unsafety_check_result<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptParam<LocalDefId>,\n+) -> &'tcx UnsafetyCheckResult {\n+    if def.param_did.is_none() {\n+        if let param_did @ Some(_) = tcx.opt_const_param_of(def.did) {\n+            return tcx.unsafety_check_result_const_arg(ty::WithOptParam { param_did, ..def });\n+        }\n+    }\n+\n+    debug!(\"unsafety_violations({:?})\", def);\n \n     // N.B., this borrow is valid because all the consumers of\n     // `mir_built` force this.\n-    let body = &tcx.mir_built(def_id).borrow();\n+    let body = &tcx.mir_built(def).borrow();\n \n-    let param_env = tcx.param_env(def_id);\n+    let param_env = tcx.param_env(def.did);\n \n-    let id = tcx.hir().as_local_hir_id(def_id);\n+    let id = tcx.hir().as_local_hir_id(def.did);\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n         hir::BodyOwnerKind::Fn => {\n-            (tcx.is_const_fn_raw(def_id.to_def_id()), is_min_const_fn(tcx, def_id.to_def_id()))\n+            (tcx.is_const_fn_raw(def.did.to_def_id()), is_min_const_fn(tcx, def.did.to_def_id()))\n         }\n         hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n     let mut checker =\n-        UnsafetyChecker::new(const_context, min_const_fn, body, def_id, tcx, param_env);\n+        UnsafetyChecker::new(const_context, min_const_fn, body, def.did, tcx, param_env);\n     checker.visit_body(&body);\n \n-    check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);\n-    UnsafetyCheckResult {\n+    check_unused_unsafe(tcx, def.did, &checker.used_unsafe, &mut checker.inherited_blocks);\n+\n+    tcx.arena.alloc(UnsafetyCheckResult {\n         violations: checker.violations.into(),\n         unsafe_blocks: checker.inherited_blocks.into(),\n-    }\n+    })\n }\n \n fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {"}, {"sha": "8259e1288bb824bf766414581c9375fa3aa01e4a", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 89, "deletions": 31, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -48,13 +48,31 @@ pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         mir_keys,\n         mir_const,\n-        mir_const_qualif,\n+        mir_const_qualif: |tcx, did| {\n+            mir_const_qualif(tcx, ty::WithOptParam::dummy(did.expect_local()))\n+        },\n+        mir_const_qualif_const_arg: |tcx, def| {\n+            if def.param_did.is_none() {\n+                tcx.mir_const_qualif(def.did.to_def_id())\n+            } else {\n+                mir_const_qualif(tcx, def)\n+            }\n+        },\n         mir_validated,\n         mir_drops_elaborated_and_const_checked,\n         optimized_mir,\n         optimized_mir_of_const_arg,\n         is_mir_available,\n-        promoted_mir,\n+        promoted_mir: |tcx, def_id| {\n+            promoted_mir(tcx, ty::WithOptParam::dummy(def_id.expect_local()))\n+        },\n+        promoted_mir_of_const_arg: |tcx, def| {\n+            if def.param_did.is_none() {\n+                tcx.promoted_mir(def.did.to_def_id())\n+            } else {\n+                promoted_mir(tcx, def)\n+            }\n+        },\n         ..*providers\n     };\n     instrument_coverage::provide(providers);\n@@ -120,6 +138,10 @@ impl<'tcx> MirSource<'tcx> {\n         MirSource { instance: InstanceDef::Item(ty::WithOptParam::dummy(def_id)), promoted: None }\n     }\n \n+    pub fn with_opt_param(self) -> ty::WithOptParam<DefId> {\n+        self.instance.with_opt_param()\n+    }\n+\n     #[inline]\n     pub fn def_id(&self) -> DefId {\n         self.instance.def_id()\n@@ -203,9 +225,14 @@ pub fn run_passes(\n     }\n }\n \n-fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n-    let def_id = def_id.expect_local();\n-    let const_kind = tcx.hir().body_const_context(def_id);\n+fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptParam<LocalDefId>) -> ConstQualifs {\n+    if def.param_did.is_none() {\n+        if let param_did @ Some(_) = tcx.opt_const_param_of(def.did) {\n+            return tcx.mir_const_qualif_const_arg(ty::WithOptParam { param_did, ..def });\n+        }\n+    }\n+\n+    let const_kind = tcx.hir().body_const_context(def.did);\n \n     // No need to const-check a non-const `fn`.\n     if const_kind.is_none() {\n@@ -216,15 +243,20 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n     // performing the steal.\n-    let body = &tcx.mir_const(def_id.to_def_id()).borrow();\n+    let body = &tcx.mir_const(def).borrow();\n \n     if body.return_ty().references_error() {\n         tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n         return Default::default();\n     }\n \n-    let ccx =\n-        check_consts::ConstCx { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n+    let ccx = check_consts::ConstCx {\n+        body,\n+        tcx,\n+        def_id: def.did,\n+        const_kind,\n+        param_env: tcx.param_env(def.did),\n+    };\n \n     let mut validator = check_consts::validation::Validator::new(&ccx);\n     validator.check_body();\n@@ -235,22 +267,35 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n }\n \n /// Make MIR ready for const evaluation. This is run on all MIR, not just on consts!\n-fn mir_const<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n-    let def_id = def_id.expect_local();\n+fn mir_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptParam<LocalDefId>,\n+) -> &'tcx Steal<Body<'tcx>> {\n+    if def.param_did.is_none() {\n+        if let param_did @ Some(_) = tcx.opt_const_param_of(def.did) {\n+            return tcx.mir_const(ty::WithOptParam { param_did, ..def });\n+        }\n+    }\n \n     // Unsafety check uses the raw mir, so make sure it is run.\n-    let _ = tcx.unsafety_check_result(def_id);\n+    let _ = tcx.unsafety_check_result_const_arg(def);\n \n-    let mut body = tcx.mir_built(def_id).steal();\n+    let mut body = tcx.mir_built(def).steal();\n \n-    util::dump_mir(tcx, None, \"mir_map\", &0, MirSource::item(def_id.to_def_id()), &body, |_, _| {\n-        Ok(())\n-    });\n+    util::dump_mir(\n+        tcx,\n+        None,\n+        \"mir_map\",\n+        &0,\n+        MirSource { instance: InstanceDef::Item(def.to_global()), promoted: None },\n+        &body,\n+        |_, _| Ok(()),\n+    );\n \n     run_passes(\n         tcx,\n         &mut body,\n-        InstanceDef::Item(ty::WithOptParam::dummy(def_id.to_def_id())),\n+        InstanceDef::Item(def.to_global()),\n         None,\n         MirPhase::Const,\n         &[&[\n@@ -266,13 +311,19 @@ fn mir_const<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>>\n \n fn mir_validated(\n     tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n+    def: ty::WithOptParam<LocalDefId>,\n ) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n+    if def.param_did.is_none() {\n+        if let param_did @ Some(_) = tcx.opt_const_param_of(def.did) {\n+            return tcx.mir_validated(ty::WithOptParam { param_did, ..def });\n+        }\n+    }\n+\n     // Ensure that we compute the `mir_const_qualif` for constants at\n     // this point, before we steal the mir-const result.\n-    let _ = tcx.mir_const_qualif(def_id.to_def_id());\n+    let _ = tcx.mir_const_qualif_const_arg(def);\n \n-    let mut body = tcx.mir_const(def_id.to_def_id()).steal();\n+    let mut body = tcx.mir_const(def).steal();\n \n     let mut required_consts = Vec::new();\n     let mut required_consts_visitor = RequiredConstsVisitor::new(&mut required_consts);\n@@ -285,7 +336,7 @@ fn mir_validated(\n     run_passes(\n         tcx,\n         &mut body,\n-        InstanceDef::Item(ty::WithOptParam::dummy(def_id.to_def_id())),\n+        InstanceDef::Item(def.to_global()),\n         None,\n         MirPhase::Validated,\n         &[&[\n@@ -316,9 +367,9 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n \n     // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n     // execute before we can steal.\n-    tcx.ensure().mir_borrowck(def.did);\n+    tcx.ensure().mir_borrowck_const_arg(def);\n \n-    let (body, _) = tcx.mir_validated(def.did);\n+    let (body, _) = tcx.mir_validated(def);\n     let mut body = body.steal();\n \n     run_post_borrowck_cleanup_passes(tcx, &mut body, def.did, None);\n@@ -473,23 +524,30 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, def: ty::WithOptParam<LocalDefId>) -> Bo\n     body\n }\n \n-fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> IndexVec<Promoted, Body<'_>> {\n-    if tcx.is_constructor(def_id) {\n-        return IndexVec::new();\n+fn promoted_mir<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptParam<LocalDefId>,\n+) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n+    if def.param_did.is_none() {\n+        if let param_did @ Some(_) = tcx.opt_const_param_of(def.did) {\n+            return tcx.promoted_mir_of_const_arg(ty::WithOptParam { param_did, ..def });\n+        }\n     }\n \n-    let def_id = def_id.expect_local();\n+    if tcx.is_constructor(def.did.to_def_id()) {\n+        return tcx.arena.alloc(IndexVec::new());\n+    }\n \n-    tcx.ensure().mir_borrowck(def_id);\n-    let (_, promoted) = tcx.mir_validated(def_id);\n+    tcx.ensure().mir_borrowck_const_arg(def);\n+    let (_, promoted) = tcx.mir_validated(def);\n     let mut promoted = promoted.steal();\n \n     for (p, mut body) in promoted.iter_enumerated_mut() {\n-        run_post_borrowck_cleanup_passes(tcx, &mut body, def_id, Some(p));\n-        run_optimization_passes(tcx, &mut body, def_id, Some(p));\n+        run_post_borrowck_cleanup_passes(tcx, &mut body, def.did, Some(p));\n+        run_optimization_passes(tcx, &mut body, def.did, Some(p));\n     }\n \n     debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");\n \n-    promoted\n+    tcx.arena.alloc(promoted)\n }"}, {"sha": "292ff17f4c598e71a52e97fe48a98d0dd436d027", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -60,16 +60,15 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n             return;\n         }\n \n-        let def_id = src.def_id().expect_local();\n+        let def = src.with_opt_param().expect_local();\n \n         let mut rpo = traversal::reverse_postorder(body);\n-        let ccx = ConstCx::new(tcx, def_id, body);\n+        let ccx = ConstCx::new(tcx, def.did, body);\n         let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n         let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);\n \n-        let promoted =\n-            promote_candidates(def_id.to_def_id(), body, tcx, temps, promotable_candidates);\n+        let promoted = promote_candidates(def.to_global(), body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n     }\n }\n@@ -937,7 +936,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n     fn promote_candidate(\n         mut self,\n-        def_id: DefId,\n+        def: ty::WithOptParam<DefId>,\n         candidate: Candidate,\n         next_promoted_id: usize,\n     ) -> Option<Body<'tcx>> {\n@@ -955,8 +954,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     literal: tcx.mk_const(ty::Const {\n                         ty,\n                         val: ty::ConstKind::Unevaluated(\n-                            ty::WithOptParam::dummy(def_id),\n-                            InternalSubsts::for_item(tcx, def_id, |param, _| {\n+                            def,\n+                            InternalSubsts::for_item(tcx, def.did, |param, _| {\n                                 if let ty::GenericParamDefKind::Lifetime = param.kind {\n                                     tcx.lifetimes.re_erased.into()\n                                 } else {\n@@ -1100,7 +1099,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n }\n \n pub fn promote_candidates<'tcx>(\n-    def_id: DefId,\n+    def: ty::WithOptParam<DefId>,\n     body: &mut Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     mut temps: IndexVec<Local, TempState>,\n@@ -1157,7 +1156,7 @@ pub fn promote_candidates<'tcx>(\n         };\n \n         //FIXME(oli-obk): having a `maybe_push()` method on `IndexVec` might be nice\n-        if let Some(promoted) = promoter.promote_candidate(def_id, candidate, promotions.len()) {\n+        if let Some(promoted) = promoter.promote_candidate(def, candidate, promotions.len()) {\n             promotions.push(promoted);\n         }\n     }"}, {"sha": "4aa3e87d4152998d2d605ba4dff53b6681d1445d", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -21,13 +21,19 @@ use rustc_target::spec::PanicStrategy;\n \n use super::lints;\n \n-crate fn mir_built<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx ty::steal::Steal<Body<'tcx>> {\n-    tcx.alloc_steal_mir(mir_build(tcx, def_id))\n+crate fn mir_built<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptParam<LocalDefId>) -> &'tcx ty::steal::Steal<Body<'tcx>> {\n+    if def.param_did.is_none() {\n+        if let param_did @ Some(_) = tcx.opt_const_param_of(def.did) {\n+            return tcx.mir_built(ty::WithOptParam { param_did, ..def });\n+        }\n+    }\n+\n+    tcx.alloc_steal_mir(mir_build(tcx, def))\n }\n \n /// Construct the MIR for a given `DefId`.\n-fn mir_build(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Body<'_> {\n-    let id = tcx.hir().as_local_hir_id(def_id);\n+fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptParam<LocalDefId>) -> Body<'_> {\n+    let id = tcx.hir().as_local_hir_id(def.did);\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n@@ -57,11 +63,11 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Body<'_> {\n         }) => (*body_id, ty.span),\n         Node::AnonConst(hir::AnonConst { body, hir_id, .. }) => (*body, tcx.hir().span(*hir_id)),\n \n-        _ => span_bug!(tcx.hir().span(id), \"can't build MIR for {:?}\", def_id),\n+        _ => span_bug!(tcx.hir().span(id), \"can't build MIR for {:?}\", def.did),\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let cx = Cx::new(&infcx, id);\n+        let cx = Cx::new(&infcx, def, id);\n         let body = if let Some(ErrorReported) = cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)\n         } else if cx.body_owner_kind.is_fn_or_closure() {\n@@ -181,7 +187,7 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Body<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        lints::check(tcx, &body, def_id);\n+        lints::check(tcx, &body, def.did);\n \n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here."}, {"sha": "e5f9f7328b89cbef3304ca7108b0f7a566b8f5d5", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -601,7 +601,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                             let substs = InternalSubsts::identity_for_item(cx.tcx(), did);\n                             let lhs = mk_const(cx.tcx().mk_const(ty::Const {\n                                 val: ty::ConstKind::Unevaluated(\n-                                    ty::WithOptParam::dummy(did),\n+                                    ty::WithOptParam::init_me_bby(cx.tcx(), did),\n                                     substs,\n                                     None,\n                                 ),\n@@ -800,7 +800,11 @@ fn convert_path_expr<'a, 'tcx>(\n             debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const(ty::Const {\n-                    val: ty::ConstKind::Unevaluated(ty::WithOptParam::dummy(def_id), substs, None),\n+                    val: ty::ConstKind::Unevaluated(\n+                        ty::WithOptParam::init_me_bby(cx.tcx, def_id),\n+                        substs,\n+                        None,\n+                    ),\n                     ty: cx.tables().node_type(expr.hir_id),\n                 }),\n                 user_ty,"}, {"sha": "5505559fc8e5571b5c4b9b7b732b587e783d89c9", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48bbf49765a2f2dd30d18242145a5e3084b42f94/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=48bbf49765a2f2dd30d18242145a5e3084b42f94", "patch": "@@ -1,4 +1,4 @@\n-//! This module contains the fcuntaiontliy to convert from the wacky tcx data\n+//! This module contains the functionality to convert from the wacky tcx data\n //! structures into the HAIR. The `builder` is generally ignorant of the tcx,\n //! etc., and instead goes through the `Cx` for most of its work.\n \n@@ -8,7 +8,7 @@ use crate::hair::*;\n use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n@@ -50,10 +50,13 @@ crate struct Cx<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    crate fn new(infcx: &'a InferCtxt<'a, 'tcx>, src_id: hir::HirId) -> Cx<'a, 'tcx> {\n+    crate fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        def: ty::WithOptParam<LocalDefId>,\n+        src_id: hir::HirId,\n+    ) -> Cx<'a, 'tcx> {\n         let tcx = infcx.tcx;\n-        let src_def_id = tcx.hir().local_def_id(src_id);\n-        let tables = tcx.typeck_tables_of(src_def_id);\n+        let tables = tcx.typeck_tables_of_const_arg(def);\n         let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n \n         let constness = match body_owner_kind {\n@@ -78,12 +81,12 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             tcx,\n             infcx,\n             root_lint_level: src_id,\n-            param_env: tcx.param_env(src_def_id),\n-            identity_substs: InternalSubsts::identity_for_item(tcx, src_def_id.to_def_id()),\n-            region_scope_tree: tcx.region_scope_tree(src_def_id),\n+            param_env: tcx.param_env(def.did),\n+            identity_substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n+            region_scope_tree: tcx.region_scope_tree(def.did),\n             tables,\n             constness,\n-            body_owner: src_def_id.to_def_id(),\n+            body_owner: def.did.to_def_id(),\n             body_owner_kind,\n             check_overflow,\n         }"}]}