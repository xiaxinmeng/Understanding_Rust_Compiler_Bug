{"sha": "fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZjBjMWIzNTMzOTNmZjM0YjFkZWU2ZWRmYmZlY2UxM2Y3YzMwOTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-11T19:45:54Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-11T19:47:32Z"}, "message": "core: Newtype a bunch of types in libcore", "tree": {"sha": "8b2801f2f3ce11e49e56a0e7d131fc725d2ed3eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b2801f2f3ce11e49e56a0e7d131fc725d2ed3eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "html_url": "https://github.com/rust-lang/rust/commit/fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0961bb88fe274795725c871871d7053429ae22e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0961bb88fe274795725c871871d7053429ae22e", "html_url": "https://github.com/rust-lang/rust/commit/c0961bb88fe274795725c871871d7053429ae22e"}], "stats": {"total": 162, "additions": 141, "deletions": 21}, "files": [{"sha": "f9bb58380b2dc0d8897e7481a0bd069115628fea", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "patch": "@@ -46,28 +46,32 @@ export unwrap;\n  * pointers achieved about 103 million pushes/second.  Using an option\n  * type could only produce 47 million pushes/second.\n  */\n-type dvec<A> = {\n+type dvec_<A> = {\n     mut data: ~[mut A]\n };\n \n+enum dvec<A> {\n+    dvec_(dvec_<A>)\n+}\n+\n /// Creates a new, empty dvec\n fn dvec<A>() -> dvec<A> {\n-    {mut data: ~[mut]}\n+    dvec_({mut data: ~[mut]})\n }\n \n /// Creates a new dvec with a single element\n fn from_elem<A>(+e: A) -> dvec<A> {\n-    {mut data: ~[mut e]}\n+    dvec_({mut data: ~[mut e]})\n }\n \n /// Creates a new dvec with the contents of a vector\n fn from_vec<A>(+v: ~[mut A]) -> dvec<A> {\n-    {mut data: v}\n+    dvec_({mut data: v})\n }\n \n /// Consumes the vector and returns its contents\n fn unwrap<A>(-d: dvec<A>) -> ~[mut A] {\n-    let {data: v} <- d;\n+    let dvec_({data: v}) <- d;\n     ret v;\n }\n "}, {"sha": "80b81753af817bfba2df001b4ef40878b7ffb7bc", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "patch": "@@ -21,7 +21,7 @@ impl extensions<A> of iter::base_iter<A> for IMPL_T<A> {\n     }\n }\n \n-impl extensions<A:copy> for IMPL_T<A> {\n+impl extensions<A:copy> of iter::copyable_iter<A> for IMPL_T<A> {\n     fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }"}, {"sha": "31e47d19c8f63e715c2b1ea8ee8944f7e70c57c3", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "patch": "@@ -7,6 +7,15 @@ iface times {\n     fn times(it: fn() -> bool);\n }\n \n+trait copyable_iter<A:copy> {\n+    fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n+    fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n+    fn to_vec() -> ~[A];\n+    fn min() -> A;\n+    fn max() -> A;\n+    fn find(p: fn(A) -> bool) -> option<A>;\n+}\n+\n fn eachi<A,IA:base_iter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n     let mut i = 0u;\n     for self.each |a| {"}, {"sha": "2b17a8a787471fbe7f8a4881c38665ed96bf8eba", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "patch": "@@ -11,16 +11,24 @@ enum state {\n     terminated\n }\n \n-type packet_header = {\n+type packet_header_ = {\n     mut state: state,\n     mut blocked_task: option<*rust_task>,\n };\n \n-type packet<T: send> = {\n+enum packet_header {\n+    packet_header_(packet_header_)\n+}\n+\n+type packet_<T:send> = {\n     header: packet_header,\n     mut payload: option<T>\n };\n \n+enum packet<T:send> {\n+    packet_(packet_<T>)\n+}\n+\n fn packet<T: send>() -> *packet<T> unsafe {\n     let p: *packet<T> = unsafe::transmute(~{\n         header: {\n@@ -428,8 +436,17 @@ proto! streamp {\n     }\n }\n \n-type chan<T:send> = { mut endp: option<streamp::client::open<T>> };\n-type port<T:send> = { mut endp: option<streamp::server::open<T>> };\n+type chan_<T:send> = { mut endp: option<streamp::client::open<T>> };\n+\n+enum chan<T:send> {\n+    chan_(chan_<T>)\n+}\n+\n+type port_<T:send> = { mut endp: option<streamp::server::open<T>> };\n+\n+enum port<T:send> {\n+    port_(port_<T>)\n+}\n \n fn stream<T:send>() -> (chan<T>, port<T>) {\n     let (c, s) = streamp::init();\n@@ -439,7 +456,7 @@ fn stream<T:send>() -> (chan<T>, port<T>) {\n          unsafe { let y <- *ptr::addr_of(x); y }]\n     ];\n \n-    ({ mut endp: some(c) }, { mut endp: some(s) })\n+    (chan_({ mut endp: some(c) }), port_({ mut endp: some(s) }))\n }\n \n impl chan<T: send> for chan<T> {"}, {"sha": "97795103f52de39d9d4b1dea935ae28d285bef0f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "patch": "@@ -123,8 +123,13 @@ unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n     libc_::memset(dst as *c_void, c as libc::c_int, n as size_t);\n }\n \n+trait ptr {\n+    pure fn is_null() -> bool;\n+    pure fn is_not_null() -> bool;\n+}\n+\n /// Extension methods for pointers\n-impl extensions<T> for *T {\n+impl extensions<T> of ptr for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n     pure fn is_null() -> bool { is_null(self) }\n "}, {"sha": "cd17247656398a00dfd7840a86392ee6b280bad8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "patch": "@@ -1882,8 +1882,15 @@ mod unsafe {\n \n }\n \n+trait unique_str {\n+    fn trim() -> self;\n+    fn trim_left() -> self;\n+    fn trim_right() -> self;\n+    pure fn +(rhs: str/&) -> self;\n+}\n+\n /// Extension methods for strings\n-impl extensions for str {\n+impl extensions of unique_str for str {\n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n     fn trim() -> str { trim(self) }\n@@ -1901,8 +1908,35 @@ impl extensions for str {\n     }\n }\n \n+trait str_slice {\n+    fn all(it: fn(char) -> bool) -> bool;\n+    fn any(it: fn(char) -> bool) -> bool;\n+    fn contains(needle: str/&a) -> bool;\n+    fn contains_char(needle: char) -> bool;\n+    fn each(it: fn(u8) -> bool);\n+    fn eachi(it: fn(uint, u8) -> bool);\n+    fn each_char(it: fn(char) -> bool);\n+    fn each_chari(it: fn(uint, char) -> bool);\n+    fn ends_with(needle: str/&) -> bool;\n+    fn is_empty() -> bool;\n+    fn is_not_empty() -> bool;\n+    fn is_whitespace() -> bool;\n+    fn is_alphanumeric() -> bool;\n+    pure fn len() -> uint;\n+    fn slice(begin: uint, end: uint) -> str;\n+    fn split(sepfn: fn(char) -> bool) -> ~[str];\n+    fn split_char(sep: char) -> ~[str];\n+    fn split_str(sep: str/&a) -> ~[str];\n+    fn starts_with(needle: str/&a) -> bool;\n+    fn substr(begin: uint, n: uint) -> str;\n+    fn to_lower() -> str;\n+    fn to_upper() -> str;\n+    fn escape_default() -> str;\n+    fn escape_unicode() -> str;\n+}\n+\n /// Extension methods for strings\n-impl extensions/& for str/& {\n+impl extensions/& of str_slice for str/& {\n     /**\n      * Return true if a predicate matches all characters or if the string\n      * contains no characters"}, {"sha": "a4bc4d66999af1673e370bd840966c690ee7fb54", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf0c1b353393ff34b1dee6edfbfece13f7c3093/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=fdf0c1b353393ff34b1dee6edfbfece13f7c3093", "patch": "@@ -1181,22 +1181,32 @@ pure fn unpack_mut_slice<T,U>(s: &[mut T],\n     }\n }\n \n-impl extensions<T: copy> for ~[T] {\n+trait vec_concat<T> {\n+    pure fn +(rhs: &[const T]) -> self;\n+}\n+\n+impl extensions<T: copy> of vec_concat<T> for ~[T] {\n     #[inline(always)]\n     pure fn +(rhs: &[const T]) -> ~[T] {\n         append(self, rhs)\n     }\n }\n \n-impl extensions<T: copy> for ~[mut T] {\n+impl extensions<T: copy> of vec_concat<T> for ~[mut T] {\n     #[inline(always)]\n     pure fn +(rhs: &[const T]) -> ~[mut T] {\n         append_mut(self, rhs)\n     }\n }\n \n+trait const_vector {\n+    pure fn is_empty() -> bool;\n+    pure fn is_not_empty() -> bool;\n+    pure fn len() -> uint;\n+}\n+\n /// Extension methods for vectors\n-impl extensions/&<T> for &[const T] {\n+impl extensions/&<T> of const_vector for &[const T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     pure fn is_empty() -> bool { is_empty(self) }\n@@ -1208,8 +1218,16 @@ impl extensions/&<T> for &[const T] {\n     pure fn len() -> uint { len(self) }\n }\n \n+trait copyable_vector<T> {\n+    pure fn head() -> T;\n+    pure fn init() -> ~[T];\n+    pure fn last() -> T;\n+    pure fn slice(start: uint, end: uint) -> ~[T];\n+    pure fn tail() -> ~[T];\n+}\n+\n /// Extension methods for vectors\n-impl extensions/&<T: copy> for &[const T] {\n+impl extensions/&<T: copy> of copyable_vector<T> for &[const T] {\n     /// Returns the first element of a vector\n     #[inline]\n     pure fn head() -> T { head(self) }\n@@ -1227,8 +1245,26 @@ impl extensions/&<T: copy> for &[const T] {\n     pure fn tail() -> ~[T] { tail(self) }\n }\n \n+trait immutable_vector/&<T> {\n+    pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U;\n+    pure fn iter(f: fn(T));\n+    pure fn iteri(f: fn(uint, T));\n+    pure fn position(f: fn(T) -> bool) -> option<uint>;\n+    pure fn position_elem(x: T) -> option<uint>;\n+    pure fn riter(f: fn(T));\n+    pure fn riteri(f: fn(uint, T));\n+    pure fn rposition(f: fn(T) -> bool) -> option<uint>;\n+    pure fn rposition_elem(x: T) -> option<uint>;\n+    pure fn map<U>(f: fn(T) -> U) -> ~[U];\n+    pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U];\n+    fn map_r<U>(f: fn(x: &self.T) -> U) -> ~[U];\n+    pure fn alli(f: fn(uint, T) -> bool) -> bool;\n+    pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U];\n+    pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> ~[U];\n+}\n+\n /// Extension methods for vectors\n-impl extensions/&<T> for &[T] {\n+impl extensions/&<T> of immutable_vector<T> for &[T] {\n     /// Reduce a vector from right to left\n     #[inline]\n     pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n@@ -1336,8 +1372,14 @@ impl extensions/&<T> for &[T] {\n     }\n }\n \n+trait immutable_copyable_vector<T> {\n+    pure fn filter(f: fn(T) -> bool) -> ~[T];\n+    pure fn find(f: fn(T) -> bool) -> option<T>;\n+    pure fn rfind(f: fn(T) -> bool) -> option<T>;\n+}\n+\n /// Extension methods for vectors\n-impl extensions/&<T: copy> for &[T] {\n+impl extensions/&<T: copy> of immutable_copyable_vector<T> for &[T] {\n     /**\n      * Construct a new vector from the elements of a vector for which some\n      * predicate holds.\n@@ -1510,7 +1552,16 @@ impl extensions/&<A> of iter::base_iter<A> for &[const A] {\n     fn contains(x: A) -> bool { iter::contains(self, x) }\n     fn count(x: A) -> uint { iter::count(self, x) }\n }\n-impl extensions/&<A:copy> for &[const A] {\n+\n+trait iter_trait_extensions<A> {\n+    fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n+    fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n+    fn to_vec() -> ~[A];\n+    fn min() -> A;\n+    fn max() -> A;\n+}\n+\n+impl extensions/&<A:copy> of iter_trait_extensions<A> for &[const A] {\n     fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }"}]}