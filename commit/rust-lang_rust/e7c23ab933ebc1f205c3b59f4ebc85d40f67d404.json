{"sha": "e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YzIzYWI5MzNlYmMxZjIwNWMzYjU5ZjRlYmM4NWQ0MGY2N2Q0MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-20T10:20:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-20T10:20:42Z"}, "message": "Auto merge of #82124 - tmiasko:op-ty-ref, r=oli-obk\n\nPass large interpreter types by reference, not value\n\nr? `@ghost`", "tree": {"sha": "1449e3261ec571dacf37aca88c0c2f0fa1b76e09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1449e3261ec571dacf37aca88c0c2f0fa1b76e09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "html_url": "https://github.com/rust-lang/rust/commit/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da5f7f10936198bad22c370118bad1ac332d2f46", "url": "https://api.github.com/repos/rust-lang/rust/commits/da5f7f10936198bad22c370118bad1ac332d2f46", "html_url": "https://github.com/rust-lang/rust/commit/da5f7f10936198bad22c370118bad1ac332d2f46"}, {"sha": "f2da425bfff80bb0bf47921c873b5e89ed5597a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2da425bfff80bb0bf47921c873b5e89ed5597a9", "html_url": "https://github.com/rust-lang/rust/commit/f2da425bfff80bb0bf47921c873b5e89ed5597a9"}], "stats": {"total": 759, "additions": 401, "deletions": 358}, "files": [{"sha": "de898460368b8427a73b178b9ae651372f00743f", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -56,7 +56,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.push_stack_frame(\n         cid.instance,\n         body,\n-        Some(ret.into()),\n+        Some(&ret.into()),\n         StackPopCleanup::None { cleanup: false },\n     )?;\n \n@@ -72,7 +72,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n-    intern_const_alloc_recursive(ecx, intern_kind, ret)?;\n+    intern_const_alloc_recursive(ecx, intern_kind, &ret)?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -105,7 +105,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n /// type system.\n pub(super) fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n-    op: OpTy<'tcx>,\n+    op: &OpTy<'tcx>,\n ) -> ConstValue<'tcx> {\n     // We do not have value optimizations for everything.\n     // Only scalars and slices, since they are very common.\n@@ -137,7 +137,7 @@ pub(super) fn op_to_const<'tcx>(\n         op.try_as_mplace(ecx)\n     };\n \n-    let to_const_value = |mplace: MPlaceTy<'_>| match mplace.ptr {\n+    let to_const_value = |mplace: &MPlaceTy<'_>| match mplace.ptr {\n         Scalar::Ptr(ptr) => {\n             let alloc = ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory();\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n@@ -155,12 +155,12 @@ pub(super) fn op_to_const<'tcx>(\n         }\n     };\n     match immediate {\n-        Ok(mplace) => to_const_value(mplace),\n+        Ok(ref mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n         Err(imm) => match *imm {\n             Immediate::Scalar(x) => match x {\n                 ScalarMaybeUninit::Scalar(s) => ConstValue::Scalar(s),\n-                ScalarMaybeUninit::Uninit => to_const_value(op.assert_mem_place(ecx)),\n+                ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place(ecx)),\n             },\n             Immediate::ScalarPair(a, b) => {\n                 let (data, start) = match a.check_init().unwrap() {\n@@ -201,7 +201,7 @@ fn turn_into_const_value<'tcx>(\n         \"the `eval_to_const_value_raw` query should not be used for statics, use `eval_to_allocation` instead\"\n     );\n     // Turn this into a proper constant.\n-    op_to_const(&ecx, mplace.into())\n+    op_to_const(&ecx, &mplace.into())\n }\n \n pub fn eval_to_const_value_raw_provider<'tcx>(\n@@ -348,7 +348,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                         Some(_) => CtfeValidationMode::Regular, // a `static`\n                         None => CtfeValidationMode::Const { inner, allow_static_ptrs: false },\n                     };\n-                    ecx.const_validate_operand(mplace.into(), path, &mut ref_tracking, mode)?;\n+                    ecx.const_validate_operand(&mplace.into(), path, &mut ref_tracking, mode)?;\n                     inner = true;\n                 }\n             };"}, {"sha": "61785a52729d5d091b4f98f9d8347cbd4e66c7b3", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -39,8 +39,8 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n             // &str\n             assert!(args.len() == 1);\n \n-            let msg_place = self.deref_operand(args[0])?;\n-            let msg = Symbol::intern(self.read_str(msg_place)?);\n+            let msg_place = self.deref_operand(&args[0])?;\n+            let msg = Symbol::intern(self.read_str(&msg_place)?);\n             let span = self.find_closest_untracked_caller_location();\n             let (file, line, col) = self.location_triple_for_span(span);\n             Err(ConstEvalErrKind::Panic { msg, file, line, col }.into())\n@@ -222,7 +222,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         instance: ty::Instance<'tcx>,\n         _abi: Abi,\n         args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _ret: Option<(&PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n@@ -262,7 +262,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         // Shared intrinsics.\n@@ -284,8 +284,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         };\n         match intrinsic_name {\n             sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                let a = ecx.read_immediate(args[0])?.to_scalar()?;\n-                let b = ecx.read_immediate(args[1])?.to_scalar()?;\n+                let a = ecx.read_immediate(&args[0])?.to_scalar()?;\n+                let b = ecx.read_immediate(&args[1])?.to_scalar()?;\n                 let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n                     ecx.guaranteed_eq(a, b)\n                 } else {\n@@ -294,8 +294,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n             }\n             sym::const_allocate => {\n-                let size = ecx.read_scalar(args[0])?.to_machine_usize(ecx)?;\n-                let align = ecx.read_scalar(args[1])?.to_machine_usize(ecx)?;\n+                let size = ecx.read_scalar(&args[0])?.to_machine_usize(ecx)?;\n+                let align = ecx.read_scalar(&args[1])?.to_machine_usize(ecx)?;\n \n                 let align = match Align::from_bytes(align) {\n                     Ok(a) => a,\n@@ -330,7 +330,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         use rustc_middle::mir::AssertKind::*;\n         // Convert `AssertKind<Operand>` to `AssertKind<Scalar>`.\n         let eval_to_int =\n-            |op| ecx.read_immediate(ecx.eval_operand(op, None)?).map(|x| x.to_const_int());\n+            |op| ecx.read_immediate(&ecx.eval_operand(op, None)?).map(|x| x.to_const_int());\n         let err = match msg {\n             BoundsCheck { ref len, ref index } => {\n                 let len = eval_to_int(len)?;\n@@ -358,15 +358,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     fn binary_ptr_op(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        _left: ImmTy<'tcx>,\n-        _right: ImmTy<'tcx>,\n+        _left: &ImmTy<'tcx>,\n+        _right: &ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _dest: PlaceTy<'tcx>,\n+        _dest: &PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n         Err(ConstEvalErrKind::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n     }"}, {"sha": "a4e1cd2faa3c0244f0c1238d2c787e1b85e3e3ee", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place).is_err() {\n+    if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &loc_place).is_err() {\n         bug!(\"intern_const_alloc_recursive should not error in this case\")\n     }\n     ConstValue::Scalar(loc_place.ptr)\n@@ -55,17 +55,17 @@ pub(crate) fn destructure_const<'tcx>(\n             return mir::DestructuredConst { variant: None, fields: &[] };\n         }\n         ty::Adt(def, _) => {\n-            let variant = ecx.read_discriminant(op).unwrap().1;\n-            let down = ecx.operand_downcast(op, variant).unwrap();\n+            let variant = ecx.read_discriminant(&op).unwrap().1;\n+            let down = ecx.operand_downcast(&op, variant).unwrap();\n             (def.variants[variant].fields.len(), Some(variant), down)\n         }\n         ty::Tuple(substs) => (substs.len(), None, op),\n         _ => bug!(\"cannot destructure constant {:?}\", val),\n     };\n \n     let fields_iter = (0..field_count).map(|i| {\n-        let field_op = ecx.operand_field(down, i).unwrap();\n-        let val = op_to_const(&ecx, field_op);\n+        let field_op = ecx.operand_field(&down, i).unwrap();\n+        let val = op_to_const(&ecx, &field_op);\n         ty::Const::from_value(tcx, val, field_op.layout.ty)\n     });\n     let fields = tcx.arena.alloc_from_iter(fields_iter);\n@@ -81,7 +81,7 @@ pub(crate) fn deref_const<'tcx>(\n     trace!(\"deref_const: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     let op = ecx.const_to_op(val, None).unwrap();\n-    let mplace = ecx.deref_operand(op).unwrap();\n+    let mplace = ecx.deref_operand(&op).unwrap();\n     if let Scalar::Ptr(ptr) = mplace.ptr {\n         assert_eq!(\n             ecx.memory.get_raw(ptr.alloc_id).unwrap().mutability,\n@@ -106,5 +106,5 @@ pub(crate) fn deref_const<'tcx>(\n         },\n     };\n \n-    tcx.mk_const(ty::Const { val: ty::ConstKind::Value(op_to_const(&ecx, mplace.into())), ty })\n+    tcx.mk_const(ty::Const { val: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n }"}, {"sha": "2d9e6df0ab86073729c3d9892369191761cc4cc9", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -17,10 +17,10 @@ use super::{\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n         cast_kind: CastKind,\n         cast_ty: Ty<'tcx>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::CastKind::*;\n         // FIXME: In which cases should we trigger UB when the source is uninit?\n@@ -32,7 +32,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Misc => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.misc_cast(src, cast_ty)?;\n+                let res = self.misc_cast(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n@@ -107,7 +107,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn misc_cast(\n         &self,\n-        src: ImmTy<'tcx, M::PointerTag>,\n+        src: &ImmTy<'tcx, M::PointerTag>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n         use rustc_middle::ty::TyKind::*;\n@@ -158,13 +158,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let dest_layout = self.layout_of(cast_ty)?;\n             if dest_layout.size == src.layout.size {\n                 // Thin or fat pointer that just hast the ptr kind of target type changed.\n-                return Ok(*src);\n+                return Ok(**src);\n             } else {\n                 // Casting the metadata away from a fat ptr.\n                 assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n                 assert_eq!(dest_layout.size, self.memory.pointer_size());\n                 assert!(src.layout.ty.is_unsafe_ptr());\n-                return match *src {\n+                return match **src {\n                     Immediate::ScalarPair(data, _) => Ok(data.into()),\n                     Immediate::Scalar(..) => span_bug!(\n                         self.cur_span(),\n@@ -259,8 +259,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn unsize_into_ptr(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n         // The pointee types\n         source_ty: Ty<'tcx>,\n         cast_ty: Ty<'tcx>,\n@@ -300,9 +300,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn unsize_into(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n         cast_ty: TyAndLayout<'tcx>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"Unsizing {:?} of type {} into {:?}\", *src, src.layout.ty, cast_ty.ty);\n         match (&src.layout.ty.kind(), &cast_ty.ty.kind()) {\n@@ -340,9 +340,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let src_field = self.operand_field(src, i)?;\n                     let dst_field = self.place_field(dest, i)?;\n                     if src_field.layout.ty == cast_ty_field.ty {\n-                        self.copy_op(src_field, dst_field)?;\n+                        self.copy_op(&src_field, &dst_field)?;\n                     } else {\n-                        self.unsize_into(src_field, cast_ty_field, dst_field)?;\n+                        self.unsize_into(&src_field, cast_ty_field, &dst_field)?;\n                     }\n                 }\n                 Ok(())"}, {"sha": "1ba87358b1c3d4b9bd7df15726d3feed6044cd4c", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -548,8 +548,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of(\n         &self,\n-        metadata: MemPlaceMeta<M::PointerTag>,\n-        layout: TyAndLayout<'tcx>,\n+        metadata: &MemPlaceMeta<M::PointerTag>,\n+        layout: &TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n             return Ok(Some((layout.size, layout.align.abi)));\n@@ -577,24 +577,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1)?;\n-                let (unsized_size, unsized_align) = match self.size_and_align_of(metadata, field)? {\n-                    Some(size_and_align) => size_and_align,\n-                    None => {\n-                        // A field with extern type.  If this field is at offset 0, we behave\n-                        // like the underlying extern type.\n-                        // FIXME: Once we have made decisions for how to handle size and alignment\n-                        // of `extern type`, this should be adapted.  It is just a temporary hack\n-                        // to get some code to work that probably ought to work.\n-                        if sized_size == Size::ZERO {\n-                            return Ok(None);\n-                        } else {\n-                            span_bug!(\n-                                self.cur_span(),\n-                                \"Fields cannot be extern types, unless they are at offset 0\"\n-                            )\n+                let (unsized_size, unsized_align) =\n+                    match self.size_and_align_of(metadata, &field)? {\n+                        Some(size_and_align) => size_and_align,\n+                        None => {\n+                            // A field with extern type.  If this field is at offset 0, we behave\n+                            // like the underlying extern type.\n+                            // FIXME: Once we have made decisions for how to handle size and alignment\n+                            // of `extern type`, this should be adapted.  It is just a temporary hack\n+                            // to get some code to work that probably ought to work.\n+                            if sized_size == Size::ZERO {\n+                                return Ok(None);\n+                            } else {\n+                                span_bug!(\n+                                    self.cur_span(),\n+                                    \"Fields cannot be extern types, unless they are at offset 0\"\n+                                )\n+                            }\n                         }\n-                    }\n-                };\n+                    };\n \n                 // FIXME (#26403, #27023): We should be adding padding\n                 // to `sized_size` (to accommodate the `unsized_align`\n@@ -645,24 +646,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn size_and_align_of_mplace(\n         &self,\n-        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n-        self.size_and_align_of(mplace.meta, mplace.layout)\n+        self.size_and_align_of(&mplace.meta, &mplace.layout)\n     }\n \n     pub fn push_stack_frame(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         body: &'mir mir::Body<'tcx>,\n-        return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n+        return_place: Option<&PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n             loc: Err(body.span), // Span used for errors caused during preamble.\n             return_to_block,\n-            return_place,\n+            return_place: return_place.copied(),\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n@@ -777,10 +778,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         if !unwinding {\n             // Copy the return value to the caller's stack frame.\n-            if let Some(return_place) = frame.return_place {\n+            if let Some(ref return_place) = frame.return_place {\n                 let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n-                self.copy_op_transmute(op, return_place)?;\n-                trace!(\"{:?}\", self.dump_place(*return_place));\n+                self.copy_op_transmute(&op, return_place)?;\n+                trace!(\"{:?}\", self.dump_place(**return_place));\n             } else {\n                 throw_ub!(Unreachable);\n             }"}, {"sha": "59438661cac7d3dbe1f180bcf7b67f5fcc66b42c", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -167,7 +167,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n \n     fn visit_aggregate(\n         &mut self,\n-        mplace: MPlaceTy<'tcx>,\n+        mplace: &MPlaceTy<'tcx>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n         // ZSTs cannot contain pointers, so we can skip them.\n@@ -191,14 +191,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n         self.walk_aggregate(mplace, fields)\n     }\n \n-    fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n+    fn visit_value(&mut self, mplace: &MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n         let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, ref_mutability) = *ty.kind() {\n-            let value = self.ecx.read_immediate(mplace.into())?;\n-            let mplace = self.ecx.ref_to_mplace(value)?;\n+            let value = self.ecx.read_immediate(&(*mplace).into())?;\n+            let mplace = self.ecx.ref_to_mplace(&value)?;\n             assert_eq!(mplace.layout.ty, referenced_ty);\n             // Handle trait object vtables.\n             if let ty::Dynamic(..) =\n@@ -296,7 +296,7 @@ pub enum InternKind {\n pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx, const_eval::MemoryKind>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n-    ret: MPlaceTy<'tcx>,\n+    ret: &MPlaceTy<'tcx>,\n ) -> Result<(), ErrorReported>\n where\n     'tcx: 'mir,\n@@ -328,7 +328,7 @@ where\n         Some(ret.layout.ty),\n     );\n \n-    ref_tracking.track((ret, base_intern_mode), || ());\n+    ref_tracking.track((*ret, base_intern_mode), || ());\n \n     while let Some(((mplace, mode), _)) = ref_tracking.todo.pop() {\n         let res = InternVisitor {\n@@ -338,7 +338,7 @@ where\n             leftover_allocations,\n             inside_unsafe_cell: false,\n         }\n-        .visit_value(mplace);\n+        .visit_value(&mplace);\n         // We deliberately *ignore* interpreter errors here.  When there is a problem, the remaining\n         // references are \"leftover\"-interned, and later validation will show a proper error\n         // and point at the right part of the value causing the problem.\n@@ -435,11 +435,11 @@ impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx, !>>\n         layout: TyAndLayout<'tcx>,\n         f: impl FnOnce(\n             &mut InterpCx<'mir, 'tcx, M>,\n-            MPlaceTy<'tcx, M::PointerTag>,\n+            &MPlaceTy<'tcx, M::PointerTag>,\n         ) -> InterpResult<'tcx, ()>,\n     ) -> InterpResult<'tcx, &'tcx Allocation> {\n         let dest = self.allocate(layout, MemoryKind::Stack);\n-        f(self, dest)?;\n+        f(self, &dest)?;\n         let ptr = dest.ptr.assert_ptr();\n         assert_eq!(ptr.offset, Size::ZERO);\n         let mut alloc = self.memory.alloc_map.remove(&ptr.alloc_id).unwrap().1;"}, {"sha": "c4039f2f15e940b5f41c7b082a5e07f07ebf46ce", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -115,7 +115,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n         let intrinsic_name = self.tcx.item_name(instance.def_id());\n@@ -143,9 +143,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::min_align_of_val | sym::size_of_val => {\n                 // Avoid `deref_operand` -- this is not a deref, the ptr does not have to be\n                 // dereferencable!\n-                let place = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let place = self.ref_to_mplace(&self.read_immediate(&args[0])?)?;\n                 let (size, align) = self\n-                    .size_and_align_of_mplace(place)?\n+                    .size_and_align_of_mplace(&place)?\n                     .ok_or_else(|| err_unsup_format!(\"`extern type` does not have known layout\"))?;\n \n                 let result = match intrinsic_name {\n@@ -177,7 +177,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.tcx.const_eval_global_id(self.param_env, gid, Some(self.tcx.span))?;\n                 let const_ = ty::Const { val: ty::ConstKind::Value(val), ty };\n                 let val = self.const_to_op(&const_, None)?;\n-                self.copy_op(val, dest)?;\n+                self.copy_op(&val, dest)?;\n             }\n \n             sym::ctpop\n@@ -189,7 +189,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::bitreverse => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n-                let val = self.read_scalar(args[0])?.check_init()?;\n+                let val = self.read_scalar(&args[0])?.check_init()?;\n                 let bits = self.force_bits(val, layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     Abi::Scalar(ref scalar) => scalar.value,\n@@ -212,22 +212,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(out_val, dest)?;\n             }\n             sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-                let lhs = self.read_immediate(args[0])?;\n-                let rhs = self.read_immediate(args[1])?;\n+                let lhs = self.read_immediate(&args[0])?;\n+                let rhs = self.read_immediate(&args[1])?;\n                 let bin_op = match intrinsic_name {\n                     sym::add_with_overflow => BinOp::Add,\n                     sym::sub_with_overflow => BinOp::Sub,\n                     sym::mul_with_overflow => BinOp::Mul,\n                     _ => bug!(\"Already checked for int ops\"),\n                 };\n-                self.binop_with_overflow(bin_op, lhs, rhs, dest)?;\n+                self.binop_with_overflow(bin_op, &lhs, &rhs, dest)?;\n             }\n             sym::saturating_add | sym::saturating_sub => {\n-                let l = self.read_immediate(args[0])?;\n-                let r = self.read_immediate(args[1])?;\n+                let l = self.read_immediate(&args[0])?;\n+                let r = self.read_immediate(&args[1])?;\n                 let is_add = intrinsic_name == sym::saturating_add;\n-                let (val, overflowed, _ty) =\n-                    self.overflowing_binary_op(if is_add { BinOp::Add } else { BinOp::Sub }, l, r)?;\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(\n+                    if is_add { BinOp::Add } else { BinOp::Sub },\n+                    &l,\n+                    &r,\n+                )?;\n                 let val = if overflowed {\n                     let num_bits = l.layout.size.bits();\n                     if l.layout.abi.is_signed() {\n@@ -269,8 +272,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(val, dest)?;\n             }\n             sym::discriminant_value => {\n-                let place = self.deref_operand(args[0])?;\n-                let discr_val = self.read_discriminant(place.into())?.0;\n+                let place = self.deref_operand(&args[0])?;\n+                let discr_val = self.read_discriminant(&place.into())?.0;\n                 self.write_scalar(discr_val, dest)?;\n             }\n             sym::unchecked_shl\n@@ -280,8 +283,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::unchecked_mul\n             | sym::unchecked_div\n             | sym::unchecked_rem => {\n-                let l = self.read_immediate(args[0])?;\n-                let r = self.read_immediate(args[1])?;\n+                let l = self.read_immediate(&args[0])?;\n+                let r = self.read_immediate(&args[1])?;\n                 let bin_op = match intrinsic_name {\n                     sym::unchecked_shl => BinOp::Shl,\n                     sym::unchecked_shr => BinOp::Shr,\n@@ -292,7 +295,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     sym::unchecked_rem => BinOp::Rem,\n                     _ => bug!(\"Already checked for int ops\"),\n                 };\n-                let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, &l, &r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = self.force_bits(r.to_scalar()?, layout.size)?;\n@@ -308,9 +311,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n-                let val = self.read_scalar(args[0])?.check_init()?;\n+                let val = self.read_scalar(&args[0])?.check_init()?;\n                 let val_bits = self.force_bits(val, layout.size)?;\n-                let raw_shift = self.read_scalar(args[1])?.check_init()?;\n+                let raw_shift = self.read_scalar(&args[1])?.check_init()?;\n                 let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n                 let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n@@ -327,15 +330,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::copy | sym::copy_nonoverlapping => {\n                 let elem_ty = instance.substs.type_at(0);\n                 let elem_layout = self.layout_of(elem_ty)?;\n-                let count = self.read_scalar(args[2])?.to_machine_usize(self)?;\n+                let count = self.read_scalar(&args[2])?.to_machine_usize(self)?;\n                 let elem_align = elem_layout.align.abi;\n \n                 let size = elem_layout.size.checked_mul(count, self).ok_or_else(|| {\n                     err_ub_format!(\"overflow computing total size of `{}`\", intrinsic_name)\n                 })?;\n-                let src = self.read_scalar(args[0])?.check_init()?;\n+                let src = self.read_scalar(&args[0])?.check_init()?;\n                 let src = self.memory.check_ptr_access(src, size, elem_align)?;\n-                let dest = self.read_scalar(args[1])?.check_init()?;\n+                let dest = self.read_scalar(&args[1])?.check_init()?;\n                 let dest = self.memory.check_ptr_access(dest, size, elem_align)?;\n \n                 if let (Some(src), Some(dest)) = (src, dest) {\n@@ -348,16 +351,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n             sym::offset => {\n-                let ptr = self.read_scalar(args[0])?.check_init()?;\n-                let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n+                let ptr = self.read_scalar(&args[0])?.check_init()?;\n+                let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n-                let ptr = self.read_scalar(args[0])?.check_init()?;\n-                let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n+                let ptr = self.read_scalar(&args[0])?.check_init()?;\n+                let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n@@ -366,8 +369,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n             sym::ptr_offset_from => {\n-                let a = self.read_immediate(args[0])?.to_scalar()?;\n-                let b = self.read_immediate(args[1])?.to_scalar()?;\n+                let a = self.read_immediate(&args[0])?.to_scalar()?;\n+                let b = self.read_immediate(&args[1])?.to_scalar()?;\n \n                 // Special case: if both scalars are *equal integers*\n                 // and not NULL, we pretend there is an allocation of size 0 right there,\n@@ -406,16 +409,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n                     let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n                     let (val, _overflowed, _ty) =\n-                        self.overflowing_binary_op(BinOp::Sub, a_offset, b_offset)?;\n+                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n                     let pointee_layout = self.layout_of(substs.type_at(0))?;\n                     let val = ImmTy::from_scalar(val, isize_layout);\n                     let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n-                    self.exact_div(val, size, dest)?;\n+                    self.exact_div(&val, &size, dest)?;\n                 }\n             }\n \n             sym::transmute => {\n-                self.copy_op_transmute(args[0], dest)?;\n+                self.copy_op_transmute(&args[0], dest)?;\n             }\n             sym::assert_inhabited => {\n                 let ty = instance.substs.type_at(0);\n@@ -434,9 +437,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n             sym::simd_insert => {\n-                let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n-                let elem = args[2];\n-                let input = args[0];\n+                let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n+                let elem = &args[2];\n+                let input = &args[0];\n                 let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n@@ -458,12 +461,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 for i in 0..len {\n                     let place = self.place_index(dest, i)?;\n-                    let value = if i == index { elem } else { self.operand_index(input, i)? };\n-                    self.copy_op(value, place)?;\n+                    let value = if i == index { *elem } else { self.operand_index(input, i)? };\n+                    self.copy_op(&value, &place)?;\n                 }\n             }\n             sym::simd_extract => {\n-                let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n+                let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n                 let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n@@ -477,36 +480,36 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"Return type `{}` must match vector element type `{}`\",\n                     dest.layout.ty, e_ty\n                 );\n-                self.copy_op(self.operand_index(args[0], index)?, dest)?;\n+                self.copy_op(&self.operand_index(&args[0], index)?, dest)?;\n             }\n             sym::likely | sym::unlikely => {\n                 // These just return their argument\n-                self.copy_op(args[0], dest)?;\n+                self.copy_op(&args[0], dest)?;\n             }\n             sym::assume => {\n-                let cond = self.read_scalar(args[0])?.check_init()?.to_bool()?;\n+                let cond = self.read_scalar(&args[0])?.check_init()?.to_bool()?;\n                 if !cond {\n                     throw_ub_format!(\"`assume` intrinsic called with `false`\");\n                 }\n             }\n             _ => return Ok(false),\n         }\n \n-        trace!(\"{:?}\", self.dump_place(*dest));\n+        trace!(\"{:?}\", self.dump_place(**dest));\n         self.go_to_block(ret);\n         Ok(true)\n     }\n \n     pub fn exact_div(\n         &mut self,\n-        a: ImmTy<'tcx, M::PointerTag>,\n-        b: ImmTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        a: &ImmTy<'tcx, M::PointerTag>,\n+        b: &ImmTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Performs an exact division, resulting in undefined behavior where\n         // `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`.\n         // First, check x % y != 0 (or if that computation overflows).\n-        let (res, overflow, _ty) = self.overflowing_binary_op(BinOp::Rem, a, b)?;\n+        let (res, overflow, _ty) = self.overflowing_binary_op(BinOp::Rem, &a, &b)?;\n         if overflow || res.assert_bits(a.layout.size) != 0 {\n             // Then, check if `b` is -1, which is the \"MIN / -1\" case.\n             let minus1 = Scalar::from_int(-1, dest.layout.size);\n@@ -518,7 +521,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n         // `Rem` says this is all right, so we can let `Div` do its job.\n-        self.binop_ignore_overflow(BinOp::Div, a, b, dest)\n+        self.binop_ignore_overflow(BinOp::Div, &a, &b, dest)\n     }\n \n     /// Offsets a pointer by some multiple of its type, returning an error if the pointer leaves its"}, {"sha": "4dfdc08b875c04fee49a5dbf11e9a1d414d3b849", "filename": "compiler/rustc_mir/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -92,11 +92,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation);\n \n         // Initialize fields.\n-        self.write_immediate(file.to_ref(), self.mplace_field(location, 0).unwrap().into())\n+        self.write_immediate(file.to_ref(), &self.mplace_field(&location, 0).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n-        self.write_scalar(line, self.mplace_field(location, 1).unwrap().into())\n+        self.write_scalar(line, &self.mplace_field(&location, 1).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n-        self.write_scalar(col, self.mplace_field(location, 2).unwrap().into())\n+        self.write_scalar(col, &self.mplace_field(&location, 2).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n \n         location"}, {"sha": "65869f956397f16ab79a89e5e5d5867bd4dc68f6", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -157,7 +157,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         instance: ty::Instance<'tcx>,\n         abi: Abi,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n@@ -168,7 +168,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         fn_val: Self::ExtraFnVal,\n         abi: Abi,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n@@ -178,7 +178,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n@@ -200,14 +200,14 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn binary_ptr_op(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Self::PointerTag>,\n-        right: ImmTy<'tcx, Self::PointerTag>,\n+        left: &ImmTy<'tcx, Self::PointerTag>,\n+        right: &ImmTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool, Ty<'tcx>)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx, Self::PointerTag>,\n+        dest: &PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx>;\n \n     /// Called to read the specified `local` from the `frame`.\n@@ -327,7 +327,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn retag(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n-        _place: PlaceTy<'tcx, Self::PointerTag>,\n+        _place: &PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -420,7 +420,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         fn_val: !,\n         _abi: Abi,\n         _args: &[OpTy<$tcx>],\n-        _ret: Option<(PlaceTy<$tcx>, mir::BasicBlock)>,\n+        _ret: Option<(&PlaceTy<$tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<$tcx> {\n         match fn_val {}"}, {"sha": "f85191f459fa950c5e0b86efd1cf28f5329db72c", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -32,6 +32,9 @@ pub enum Immediate<Tag = ()> {\n     ScalarPair(ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>),\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(Immediate, 56);\n+\n impl<Tag> From<ScalarMaybeUninit<Tag>> for Immediate<Tag> {\n     #[inline(always)]\n     fn from(val: ScalarMaybeUninit<Tag>) -> Self {\n@@ -92,6 +95,9 @@ pub struct ImmTy<'tcx, Tag = ()> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n+\n impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         /// Helper function for printing a scalar to a FmtPrinter\n@@ -156,6 +162,9 @@ pub struct OpTy<'tcx, Tag = ()> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(OpTy<'_, ()>, 80);\n+\n impl<'tcx, Tag> std::ops::Deref for OpTy<'tcx, Tag> {\n     type Target = Operand<Tag>;\n     #[inline(always)]\n@@ -171,6 +180,13 @@ impl<'tcx, Tag: Copy> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     }\n }\n \n+impl<'tcx, Tag: Copy> From<&'_ MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+    #[inline(always)]\n+    fn from(mplace: &MPlaceTy<'tcx, Tag>) -> Self {\n+        OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout }\n+    }\n+}\n+\n impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(val: ImmTy<'tcx, Tag>) -> Self {\n@@ -222,7 +238,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn force_op_ptr(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         match op.try_as_mplace(self) {\n             Ok(mplace) => Ok(self.force_mplace_ptr(mplace)?.into()),\n@@ -234,7 +250,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace(\n         &self,\n-        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n@@ -295,14 +311,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// in a `Immediate`, not on which data is stored there currently.\n     pub(crate) fn try_read_immediate(\n         &self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace(self) {\n-            Ok(mplace) => {\n+            Ok(ref mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n                 } else {\n-                    Err(mplace)\n+                    Err(*mplace)\n                 }\n             }\n             Err(val) => Ok(val),\n@@ -313,7 +329,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn read_immediate(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         if let Ok(imm) = self.try_read_immediate(op)? {\n             Ok(imm)\n@@ -325,13 +341,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Read a scalar from a place\n     pub fn read_scalar(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n         Ok(self.read_immediate(op)?.to_scalar_or_uninit())\n     }\n \n     // Turn the wide MPlace into a string (must already be dereferenced!)\n-    pub fn read_str(&self, mplace: MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n+    pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n         let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n@@ -341,11 +357,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Projection functions\n     pub fn operand_field(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace(self) {\n-            Ok(mplace) => {\n+            Ok(ref mplace) => {\n                 // We can reuse the mplace field computation logic for indirect operands.\n                 let field = self.mplace_field(mplace, field)?;\n                 return Ok(field.into());\n@@ -379,7 +395,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn operand_index(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         index: u64,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         if let Ok(index) = usize::try_from(index) {\n@@ -388,28 +404,28 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         } else {\n             // Indexing into a big array. This must be an mplace.\n             let mplace = op.assert_mem_place(self);\n-            Ok(self.mplace_index(mplace, index)?.into())\n+            Ok(self.mplace_index(&mplace, index)?.into())\n         }\n     }\n \n     pub fn operand_downcast(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         Ok(match op.try_as_mplace(self) {\n-            Ok(mplace) => self.mplace_downcast(mplace, variant)?.into(),\n+            Ok(ref mplace) => self.mplace_downcast(mplace, variant)?.into(),\n             Err(..) => {\n                 let layout = op.layout.for_variant(self, variant);\n-                OpTy { layout, ..op }\n+                OpTy { layout, ..*op }\n             }\n         })\n     }\n \n     pub fn operand_projection(\n         &self,\n-        base: OpTy<'tcx, M::PointerTag>,\n+        base: &OpTy<'tcx, M::PointerTag>,\n         proj_elem: mir::PlaceElem<'tcx>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n@@ -421,7 +437,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n                 let mplace = base.assert_mem_place(self);\n-                self.mplace_projection(mplace, proj_elem)?.into()\n+                self.mplace_projection(&mplace, proj_elem)?.into()\n             }\n         })\n     }\n@@ -453,9 +469,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn place_to_op(\n         &self,\n-        place: PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = match *place {\n+        let op = match **place {\n             Place::Ptr(mplace) => Operand::Indirect(mplace),\n             Place::Local { frame, local } => {\n                 *self.access_local(&self.stack()[frame], local, None)?\n@@ -480,7 +496,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let op = place\n             .projection\n             .iter()\n-            .try_fold(base_op, |op, elem| self.operand_projection(op, elem))?;\n+            .try_fold(base_op, |op, elem| self.operand_projection(&op, elem))?;\n \n         trace!(\"eval_place_to_op: got {:?}\", *op);\n         // Sanity-check the type we ended up with.\n@@ -590,7 +606,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Read discriminant, return the runtime value as well as the variant index.\n     pub fn read_discriminant(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", op.layout);\n         // Get type and layout of the discriminant.\n@@ -636,7 +652,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(self.operand_field(op, tag_field)?)?;\n+        let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;\n         assert_eq!(tag_layout.size, tag_val.layout.size);\n         assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n         let tag_val = tag_val.to_scalar()?;\n@@ -690,7 +706,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n                         let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                         let variant_index_relative_val =\n-                            self.binary_op(mir::BinOp::Sub, tag_val, niche_start_val)?;\n+                            self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n                         let variant_index_relative = variant_index_relative_val\n                             .to_scalar()?\n                             .assert_bits(tag_val.layout.size);"}, {"sha": "3737f8781c7ae2a333dc02cfd9405717f4eeabaa", "filename": "compiler/rustc_mir/src/interpret/operator.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -14,11 +14,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: ImmTy<'tcx, M::PointerTag>,\n-        right: ImmTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::PointerTag>,\n+        right: &ImmTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (val, overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n+        let (val, overflowed, ty) = self.overflowing_binary_op(op, &left, &right)?;\n         debug_assert_eq!(\n             self.tcx.intern_tup(&[ty, self.tcx.types.bool]),\n             dest.layout.ty,\n@@ -34,9 +34,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn binop_ignore_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: ImmTy<'tcx, M::PointerTag>,\n-        right: ImmTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::PointerTag>,\n+        right: &ImmTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let (val, _overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n         assert_eq!(ty, dest.layout.ty, \"type mismatch for result of {:?}\", op);\n@@ -269,8 +269,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn overflowing_binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, M::PointerTag>,\n-        right: ImmTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::PointerTag>,\n+        right: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         trace!(\n             \"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n@@ -347,8 +347,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, M::PointerTag>,\n-        right: ImmTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::PointerTag>,\n+        right: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         let (val, _overflow, ty) = self.overflowing_binary_op(bin_op, left, right)?;\n         Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n@@ -359,7 +359,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn overflowing_unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: ImmTy<'tcx, M::PointerTag>,\n+        val: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         use rustc_middle::mir::UnOp::*;\n \n@@ -409,7 +409,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: ImmTy<'tcx, M::PointerTag>,\n+        val: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         let (val, _overflow, ty) = self.overflowing_unary_op(un_op, val)?;\n         Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))"}, {"sha": "392f739e84fd6dfb2429fc05d7bd9cc9f6f3ab9b", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 82, "deletions": 67, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -33,6 +33,9 @@ pub enum MemPlaceMeta<Tag = ()> {\n     Poison,\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(MemPlaceMeta, 24);\n+\n impl<Tag> MemPlaceMeta<Tag> {\n     pub fn unwrap_meta(self) -> Scalar<Tag> {\n         match self {\n@@ -71,6 +74,9 @@ pub struct MemPlace<Tag = ()> {\n     pub meta: MemPlaceMeta<Tag>,\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(MemPlace, 56);\n+\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n pub enum Place<Tag = ()> {\n     /// A place referring to a value allocated in the `Memory` system.\n@@ -81,12 +87,18 @@ pub enum Place<Tag = ()> {\n     Local { frame: usize, local: mir::Local },\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(Place, 64);\n+\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag = ()> {\n     place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(PlaceTy<'_>, 80);\n+\n impl<'tcx, Tag> std::ops::Deref for PlaceTy<'tcx, Tag> {\n     type Target = Place<Tag>;\n     #[inline(always)]\n@@ -102,6 +114,9 @@ pub struct MPlaceTy<'tcx, Tag = ()> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 72);\n+\n impl<'tcx, Tag> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     type Target = MemPlace<Tag>;\n     #[inline(always)]\n@@ -168,7 +183,7 @@ impl<Tag> MemPlace<Tag> {\n     }\n }\n \n-impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n     pub fn dangling(layout: TyAndLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n@@ -180,13 +195,13 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n \n     /// Replace ptr tag, maintain vtable tag (if any)\n     #[inline]\n-    pub fn replace_tag(self, new_tag: Tag) -> Self {\n+    pub fn replace_tag(&self, new_tag: Tag) -> Self {\n         MPlaceTy { mplace: self.mplace.replace_tag(new_tag), layout: self.layout }\n     }\n \n     #[inline]\n     pub fn offset(\n-        self,\n+        &self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n         layout: TyAndLayout<'tcx>,\n@@ -201,7 +216,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn len(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n+    pub(super) fn len(&self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind() {\n@@ -219,7 +234,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn vtable(self) -> Scalar<Tag> {\n+    pub(super) fn vtable(&self) -> Scalar<Tag> {\n         match self.layout.ty.kind() {\n             ty::Dynamic(..) => self.mplace.meta.unwrap_meta(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n@@ -233,10 +248,10 @@ impl<'tcx, Tag: Debug + Copy> OpTy<'tcx, Tag> {\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n     pub fn try_as_mplace(\n-        self,\n+        &self,\n         cx: &impl HasDataLayout,\n     ) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n-        match *self {\n+        match **self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n             Operand::Immediate(_) if self.layout.is_zst() => {\n                 Ok(MPlaceTy::dangling(self.layout, cx))\n@@ -248,7 +263,7 @@ impl<'tcx, Tag: Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n-    pub fn assert_mem_place(self, cx: &impl HasDataLayout) -> MPlaceTy<'tcx, Tag> {\n+    pub fn assert_mem_place(&self, cx: &impl HasDataLayout) -> MPlaceTy<'tcx, Tag> {\n         self.try_as_mplace(cx).unwrap()\n     }\n }\n@@ -288,12 +303,12 @@ where\n     /// Generally prefer `deref_operand`.\n     pub fn ref_to_mplace(\n         &self,\n-        val: ImmTy<'tcx, M::PointerTag>,\n+        val: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let pointee_type =\n             val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n-        let (ptr, meta) = match *val {\n+        let (ptr, meta) = match **val {\n             Immediate::Scalar(ptr) => (ptr.check_init()?, MemPlaceMeta::None),\n             Immediate::ScalarPair(ptr, meta) => {\n                 (ptr.check_init()?, MemPlaceMeta::Meta(meta.check_init()?))\n@@ -316,11 +331,11 @@ where\n     /// will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n     pub fn deref_operand(\n         &self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        let place = self.ref_to_mplace(val)?;\n+        let place = self.ref_to_mplace(&val)?;\n         self.mplace_access_checked(place, None)\n     }\n \n@@ -333,7 +348,7 @@ where\n     #[inline]\n     pub(super) fn check_mplace_access(\n         &self,\n-        place: MPlaceTy<'tcx, M::PointerTag>,\n+        place: &MPlaceTy<'tcx, M::PointerTag>,\n         size: Option<Size>,\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         let size = size.unwrap_or_else(|| {\n@@ -355,13 +370,13 @@ where\n         force_align: Option<Align>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let (size, align) = self\n-            .size_and_align_of_mplace(place)?\n+            .size_and_align_of_mplace(&place)?\n             .unwrap_or((place.layout.size, place.layout.align.abi));\n         assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n         // Check (stricter) dynamic alignment, unless forced otherwise.\n         place.mplace.align = force_align.unwrap_or(align);\n         // When dereferencing a pointer, it must be non-NULL, aligned, and live.\n-        if let Some(ptr) = self.check_mplace_access(place, Some(size))? {\n+        if let Some(ptr) = self.check_mplace_access(&place, Some(size))? {\n             place.mplace.ptr = ptr.into();\n         }\n         Ok(place)\n@@ -386,7 +401,7 @@ where\n     #[inline(always)]\n     pub fn mplace_field(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         field: usize,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let offset = base.layout.fields.offset(field);\n@@ -397,7 +412,7 @@ where\n             // Re-use parent metadata to determine dynamic field layout.\n             // With custom DSTS, this *will* execute user-defined code, but the same\n             // happens at run-time so that's okay.\n-            let align = match self.size_and_align_of(base.meta, field_layout)? {\n+            let align = match self.size_and_align_of(&base.meta, &field_layout)? {\n                 Some((_, align)) => align,\n                 None if offset == Size::ZERO => {\n                     // An extern type at offset 0, we fall back to its static alignment.\n@@ -427,7 +442,7 @@ where\n     #[inline(always)]\n     pub fn mplace_index(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         index: u64,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Not using the layout method because we want to compute on u64\n@@ -457,8 +472,8 @@ where\n     // same by repeatedly calling `mplace_array`.\n     pub(super) fn mplace_array_fields(\n         &self,\n-        base: MPlaceTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n+        base: &'a MPlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n@@ -473,7 +488,7 @@ where\n \n     fn mplace_subslice(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n         to: u64,\n         from_end: bool,\n@@ -518,30 +533,30 @@ where\n \n     pub(super) fn mplace_downcast(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         assert!(!base.meta.has_meta());\n-        Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n+        Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..*base })\n     }\n \n     /// Project into an mplace\n     pub(super) fn mplace_projection(\n         &self,\n-        base: MPlaceTy<'tcx, M::PointerTag>,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: mir::PlaceElem<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n             Field(field, _) => self.mplace_field(base, field.index())?,\n             Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n-            Deref => self.deref_operand(base.into())?,\n+            Deref => self.deref_operand(&base.into())?,\n \n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.access_local(self.frame(), local, Some(layout))?;\n-                let n = self.read_scalar(n)?;\n+                let n = self.read_scalar(&n)?;\n                 let n = u64::try_from(\n                     self.force_bits(n.check_init()?, self.tcx.data_layout.pointer_size)?,\n                 )\n@@ -577,57 +592,57 @@ where\n     /// into the field of a local `ScalarPair`, we have to first allocate it.\n     pub fn place_field(\n         &mut self,\n-        base: PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n         field: usize,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n         // entire place.\n         let mplace = self.force_allocation(base)?;\n-        Ok(self.mplace_field(mplace, field)?.into())\n+        Ok(self.mplace_field(&mplace, field)?.into())\n     }\n \n     pub fn place_index(\n         &mut self,\n-        base: PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n         index: u64,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         let mplace = self.force_allocation(base)?;\n-        Ok(self.mplace_index(mplace, index)?.into())\n+        Ok(self.mplace_index(&mplace, index)?.into())\n     }\n \n     pub fn place_downcast(\n         &self,\n-        base: PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n         Ok(match base.place {\n             Place::Ptr(mplace) => {\n-                self.mplace_downcast(MPlaceTy { mplace, layout: base.layout }, variant)?.into()\n+                self.mplace_downcast(&MPlaceTy { mplace, layout: base.layout }, variant)?.into()\n             }\n             Place::Local { .. } => {\n                 let layout = base.layout.for_variant(self, variant);\n-                PlaceTy { layout, ..base }\n+                PlaceTy { layout, ..*base }\n             }\n         })\n     }\n \n     /// Projects into a place.\n     pub fn place_projection(\n         &mut self,\n-        base: PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n         &proj_elem: &mir::ProjectionElem<mir::Local, Ty<'tcx>>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n             Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n-            Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n+            Deref => self.deref_operand(&self.place_to_op(base)?)?.into(),\n             // For the other variants, we have to force an allocation.\n             // This matches `operand_projection`.\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n                 let mplace = self.force_allocation(base)?;\n-                self.mplace_projection(mplace, proj_elem)?.into()\n+                self.mplace_projection(&mplace, proj_elem)?.into()\n             }\n         })\n     }\n@@ -645,7 +660,7 @@ where\n         };\n \n         for elem in place.projection.iter() {\n-            place_ty = self.place_projection(place_ty, &elem)?\n+            place_ty = self.place_projection(&place_ty, &elem)?\n         }\n \n         trace!(\"{:?}\", self.dump_place(place_ty.place));\n@@ -666,7 +681,7 @@ where\n     pub fn write_scalar(\n         &mut self,\n         val: impl Into<ScalarMaybeUninit<M::PointerTag>>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate(Immediate::Scalar(val.into()), dest)\n     }\n@@ -676,13 +691,13 @@ where\n     pub fn write_immediate(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate_no_validate(src, dest)?;\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?)?;\n+            self.validate_operand(&self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -693,13 +708,13 @@ where\n     pub fn write_immediate_to_mplace(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n-        dest: MPlaceTy<'tcx, M::PointerTag>,\n+        dest: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate_to_mplace_no_validate(src, dest)?;\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into())?;\n+            self.validate_operand(&dest.into())?;\n         }\n \n         Ok(())\n@@ -711,7 +726,7 @@ where\n     fn write_immediate_no_validate(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         if cfg!(debug_assertions) {\n             // This is a very common path, avoid some checks in release mode\n@@ -754,7 +769,7 @@ where\n         let dest = MPlaceTy { mplace, layout: dest.layout };\n \n         // This is already in memory, write there.\n-        self.write_immediate_to_mplace_no_validate(src, dest)\n+        self.write_immediate_to_mplace_no_validate(src, &dest)\n     }\n \n     /// Write an immediate to memory.\n@@ -763,7 +778,7 @@ where\n     fn write_immediate_to_mplace_no_validate(\n         &mut self,\n         value: Immediate<M::PointerTag>,\n-        dest: MPlaceTy<'tcx, M::PointerTag>,\n+        dest: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Note that it is really important that the type here is the right one, and matches the\n         // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n@@ -828,14 +843,14 @@ where\n     #[inline(always)]\n     pub fn copy_op(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.copy_op_no_validate(src, dest)?;\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?)?;\n+            self.validate_operand(&self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -847,8 +862,8 @@ where\n     /// right type.\n     fn copy_op_no_validate(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n@@ -888,10 +903,10 @@ where\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n         let src = self\n-            .check_mplace_access(src, Some(size))\n+            .check_mplace_access(&src, Some(size))\n             .expect(\"places should be checked on creation\");\n         let dest = self\n-            .check_mplace_access(dest, Some(size))\n+            .check_mplace_access(&dest, Some(size))\n             .expect(\"places should be checked on creation\");\n         let (src_ptr, dest_ptr) = match (src, dest) {\n             (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n@@ -906,8 +921,8 @@ where\n     /// have the same size.\n     pub fn copy_op_transmute(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n@@ -944,12 +959,12 @@ where\n         let dest = self.force_allocation(dest)?;\n         self.copy_op_no_validate(\n             src,\n-            PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout }),\n+            &PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout }),\n         )?;\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into())?;\n+            self.validate_operand(&dest.into())?;\n         }\n \n         Ok(())\n@@ -965,7 +980,7 @@ where\n     /// version.\n     pub fn force_allocation_maybe_sized(\n         &mut self,\n-        place: PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::PointerTag>,\n         meta: MemPlaceMeta<M::PointerTag>,\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n@@ -981,7 +996,7 @@ where\n                             self.layout_of_local(&self.stack()[frame], local, None)?;\n                         // We also need to support unsized types, and hence cannot use `allocate`.\n                         let (size, align) = self\n-                            .size_and_align_of(meta, local_layout)?\n+                            .size_and_align_of(&meta, &local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n                         let ptr = self.memory.allocate(size, align, MemoryKind::Stack);\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n@@ -990,7 +1005,7 @@ where\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type.\n                             let mplace = MPlaceTy { mplace, layout: local_layout };\n-                            self.write_immediate_to_mplace_no_validate(value, mplace)?;\n+                            self.write_immediate_to_mplace_no_validate(value, &mplace)?;\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n@@ -1010,7 +1025,7 @@ where\n     #[inline(always)]\n     pub fn force_allocation(\n         &mut self,\n-        place: PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         Ok(self.force_allocation_maybe_sized(place, MemPlaceMeta::None)?.0)\n     }\n@@ -1046,7 +1061,7 @@ where\n     pub fn write_discriminant(\n         &mut self,\n         variant_index: VariantIdx,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Layout computation excludes uninhabited variants from consideration\n         // therefore there's no way to represent those variants in the given layout.\n@@ -1077,7 +1092,7 @@ where\n                 let tag_val = size.truncate(discr_val);\n \n                 let tag_dest = self.place_field(dest, tag_field)?;\n-                self.write_scalar(Scalar::from_uint(tag_val, size), tag_dest)?;\n+                self.write_scalar(Scalar::from_uint(tag_val, size), &tag_dest)?;\n             }\n             Variants::Multiple {\n                 tag_encoding:\n@@ -1103,12 +1118,12 @@ where\n                         ImmTy::from_uint(variant_index_relative, tag_layout);\n                     let tag_val = self.binary_op(\n                         mir::BinOp::Add,\n-                        variant_index_relative_val,\n-                        niche_start_val,\n+                        &variant_index_relative_val,\n+                        &niche_start_val,\n                     )?;\n                     // Write result.\n                     let niche_dest = self.place_field(dest, tag_field)?;\n-                    self.write_immediate(*tag_val, niche_dest)?;\n+                    self.write_immediate(*tag_val, &niche_dest)?;\n                 }\n             }\n         }\n@@ -1131,7 +1146,7 @@ where\n     /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(\n         &self,\n-        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+        mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n         let vtable = mplace.vtable(); // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n@@ -1145,7 +1160,7 @@ where\n             assert_eq!(align, layout.align.abi);\n         }\n \n-        let mplace = MPlaceTy { mplace: MemPlace { meta: MemPlaceMeta::None, ..*mplace }, layout };\n+        let mplace = MPlaceTy { mplace: MemPlace { meta: MemPlaceMeta::None, ..**mplace }, layout };\n         Ok((instance, mplace))\n     }\n }"}, {"sha": "64d7c8ef2c719daa16d3e11e8e77f188f5d3ba1c", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -90,7 +90,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             SetDiscriminant { place, variant_index } => {\n                 let dest = self.eval_place(**place)?;\n-                self.write_discriminant(*variant_index, dest)?;\n+                self.write_discriminant(*variant_index, &dest)?;\n             }\n \n             // Mark locals as alive\n@@ -110,7 +110,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Stacked Borrows.\n             Retag(kind, place) => {\n                 let dest = self.eval_place(**place)?;\n-                M::retag(self, *kind, dest)?;\n+                M::retag(self, *kind, &dest)?;\n             }\n \n             // Statements we do not track.\n@@ -156,45 +156,45 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ThreadLocalRef(did) => {\n                 let id = M::thread_local_static_alloc_id(self, did)?;\n                 let val = self.global_base_pointer(id.into())?;\n-                self.write_scalar(val, dest)?;\n+                self.write_scalar(val, &dest)?;\n             }\n \n             Use(ref operand) => {\n                 // Avoid recomputing the layout\n                 let op = self.eval_operand(operand, Some(dest.layout))?;\n-                self.copy_op(op, dest)?;\n+                self.copy_op(&op, &dest)?;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n                 let layout = binop_left_homogeneous(bin_op).then_some(dest.layout);\n-                let left = self.read_immediate(self.eval_operand(left, layout)?)?;\n+                let left = self.read_immediate(&self.eval_operand(left, layout)?)?;\n                 let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n-                let right = self.read_immediate(self.eval_operand(right, layout)?)?;\n-                self.binop_ignore_overflow(bin_op, left, right, dest)?;\n+                let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n+                self.binop_ignore_overflow(bin_op, &left, &right, &dest)?;\n             }\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n                 // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n-                let left = self.read_immediate(self.eval_operand(left, None)?)?;\n+                let left = self.read_immediate(&self.eval_operand(left, None)?)?;\n                 let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n-                let right = self.read_immediate(self.eval_operand(right, layout)?)?;\n-                self.binop_with_overflow(bin_op, left, right, dest)?;\n+                let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n+                self.binop_with_overflow(bin_op, &left, &right, &dest)?;\n             }\n \n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n-                let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n-                let val = self.unary_op(un_op, val)?;\n+                let val = self.read_immediate(&self.eval_operand(operand, Some(dest.layout))?)?;\n+                let val = self.unary_op(un_op, &val)?;\n                 assert_eq!(val.layout, dest.layout, \"layout mismatch for result of {:?}\", un_op);\n-                self.write_immediate(*val, dest)?;\n+                self.write_immediate(*val, &dest)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        self.write_discriminant(variant_index, dest)?;\n+                        self.write_discriminant(variant_index, &dest)?;\n                         if adt_def.is_enum() {\n-                            (self.place_downcast(dest, variant_index)?, active_field_index)\n+                            (self.place_downcast(&dest, variant_index)?, active_field_index)\n                         } else {\n                             (dest, active_field_index)\n                         }\n@@ -207,21 +207,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Ignore zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        let field_dest = self.place_field(dest, field_index)?;\n-                        self.copy_op(op, field_dest)?;\n+                        let field_dest = self.place_field(&dest, field_index)?;\n+                        self.copy_op(&op, &field_dest)?;\n                     }\n                 }\n             }\n \n             Repeat(ref operand, _) => {\n                 let op = self.eval_operand(operand, None)?;\n-                let dest = self.force_allocation(dest)?;\n+                let dest = self.force_allocation(&dest)?;\n                 let length = dest.len(self)?;\n \n-                if let Some(first_ptr) = self.check_mplace_access(dest, None)? {\n+                if let Some(first_ptr) = self.check_mplace_access(&dest, None)? {\n                     // Write the first.\n-                    let first = self.mplace_field(dest, 0)?;\n-                    self.copy_op(op, first.into())?;\n+                    let first = self.mplace_field(&dest, 0)?;\n+                    self.copy_op(&op, &first.into())?;\n \n                     if length > 1 {\n                         let elem_size = first.layout.size;\n@@ -242,23 +242,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Len(place) => {\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n-                let mplace = self.force_allocation(src)?;\n+                let mplace = self.force_allocation(&src)?;\n                 let len = mplace.len(self)?;\n-                self.write_scalar(Scalar::from_machine_usize(len, self), dest)?;\n+                self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n             }\n \n             AddressOf(_, place) | Ref(_, _, place) => {\n                 let src = self.eval_place(place)?;\n-                let place = self.force_allocation(src)?;\n+                let place = self.force_allocation(&src)?;\n                 if place.layout.size.bytes() > 0 {\n                     // definitely not a ZST\n                     assert!(place.ptr.is_ptr(), \"non-ZST places should be normalized to `Pointer`\");\n                 }\n-                self.write_immediate(place.to_ref(), dest)?;\n+                self.write_immediate(place.to_ref(), &dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {\n-                M::box_alloc(self, dest)?;\n+                M::box_alloc(self, &dest)?;\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n@@ -272,19 +272,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     );\n                     throw_inval!(SizeOfUnsizedType(ty));\n                 }\n-                self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), dest)?;\n+                self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), &dest)?;\n             }\n \n             Cast(cast_kind, ref operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n                 let cast_ty = self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty);\n-                self.cast(src, cast_kind, cast_ty, dest)?;\n+                self.cast(&src, cast_kind, cast_ty, &dest)?;\n             }\n \n             Discriminant(place) => {\n                 let op = self.eval_place_to_op(place, None)?;\n-                let discr_val = self.read_discriminant(op)?.0;\n-                self.write_scalar(discr_val, dest)?;\n+                let discr_val = self.read_discriminant(&op)?.0;\n+                self.write_scalar(discr_val, &dest)?;\n             }\n         }\n "}, {"sha": "0807949a2d91beed6efc23ba86b7b8ddbf76a058", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -25,7 +25,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Goto { target } => self.go_to_block(target),\n \n             SwitchInt { ref discr, ref targets, switch_ty } => {\n-                let discr = self.read_immediate(self.eval_operand(discr, None)?)?;\n+                let discr = self.read_immediate(&self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n                 assert_eq!(discr.layout.ty, switch_ty);\n \n@@ -38,8 +38,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let res = self\n                         .overflowing_binary_op(\n                             mir::BinOp::Eq,\n-                            discr,\n-                            ImmTy::from_uint(const_int, discr.layout),\n+                            &discr,\n+                            &ImmTy::from_uint(const_int, discr.layout),\n                         )?\n                         .0;\n                     if res.to_bool()? {\n@@ -58,7 +58,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (fn_val, abi) = match *func.layout.ty.kind() {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n-                        let fn_ptr = self.read_scalar(func)?.check_init()?;\n+                        let fn_ptr = self.read_scalar(&func)?.check_init()?;\n                         let fn_val = self.memory.get_fn(fn_ptr)?;\n                         (fn_val, caller_abi)\n                     }\n@@ -78,8 +78,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ),\n                 };\n                 let args = self.eval_operands(args)?;\n+                let dest_place;\n                 let ret = match destination {\n-                    Some((dest, ret)) => Some((self.eval_place(dest)?, ret)),\n+                    Some((dest, ret)) => {\n+                        dest_place = self.eval_place(dest)?;\n+                        Some((&dest_place, ret))\n+                    }\n                     None => None,\n                 };\n                 self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n@@ -96,12 +100,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", place, ty);\n \n                 let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n-                self.drop_in_place(place, instance, target, unwind)?;\n+                self.drop_in_place(&place, instance, target, unwind)?;\n             }\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let cond_val =\n-                    self.read_immediate(self.eval_operand(cond, None)?)?.to_scalar()?.to_bool()?;\n+                    self.read_immediate(&self.eval_operand(cond, None)?)?.to_scalar()?.to_bool()?;\n                 if expected == cond_val {\n                     self.go_to_block(target);\n                 } else {\n@@ -180,7 +184,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         rust_abi: bool,\n         caller_arg: &mut impl Iterator<Item = OpTy<'tcx, M::PointerTag>>,\n-        callee_arg: PlaceTy<'tcx, M::PointerTag>,\n+        callee_arg: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         if rust_abi && callee_arg.layout.is_zst() {\n             // Nothing to do.\n@@ -202,7 +206,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )\n         }\n         // We allow some transmutes here\n-        self.copy_op_transmute(caller_arg, callee_arg)\n+        self.copy_op_transmute(&caller_arg, callee_arg)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments.\n@@ -211,7 +215,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n@@ -314,7 +318,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let caller_args: Cow<'_, [OpTy<'tcx, M::PointerTag>]> =\n                         if caller_abi == Abi::RustCall && !args.is_empty() {\n                             // Untuple\n-                            let (&untuple_arg, args) = args.split_last().unwrap();\n+                            let (untuple_arg, args) = args.split_last().unwrap();\n                             trace!(\"eval_fn_call: Will pass last argument by untupling\");\n                             Cow::from(\n                                 args.iter()\n@@ -344,12 +348,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n-                                let dest = self.place_field(dest, i)?;\n-                                self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n+                                let dest = self.place_field(&dest, i)?;\n+                                self.pass_argument(rust_abi, &mut caller_iter, &dest)?;\n                             }\n                         } else {\n                             // Normal argument\n-                            self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n+                            self.pass_argument(rust_abi, &mut caller_iter, &dest)?;\n                         }\n                     }\n                     // Now we should have no more caller args\n@@ -397,7 +401,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let receiver_place = match args[0].layout.ty.builtin_deref(true) {\n                     Some(_) => {\n                         // Built-in pointer.\n-                        self.deref_operand(args[0])?\n+                        self.deref_operand(&args[0])?\n                     }\n                     None => {\n                         // Unsized self.\n@@ -426,7 +430,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn drop_in_place(\n         &mut self,\n-        place: PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::PointerTag>,\n         instance: ty::Instance<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n@@ -440,7 +444,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (instance, place) = match place.layout.ty.kind() {\n             ty::Dynamic(..) => {\n                 // Dropping a trait object.\n-                self.unpack_dyn_trait(place)?\n+                self.unpack_dyn_trait(&place)?\n             }\n             _ => (instance, place),\n         };\n@@ -457,7 +461,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             FnVal::Instance(instance),\n             Abi::Rust,\n             &[arg.into()],\n-            Some((dest.into(), target)),\n+            Some((&dest.into(), target)),\n             unwind,\n         )\n     }"}, {"sha": "2d2799f81e392ffd4e3770e36f16138c6be9783d", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -378,7 +378,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     /// Check a reference or `Box`.\n     fn check_safe_pointer(\n         &mut self,\n-        value: OpTy<'tcx, M::PointerTag>,\n+        value: &OpTy<'tcx, M::PointerTag>,\n         kind: &str,\n     ) -> InterpResult<'tcx> {\n         let value = try_validation!(\n@@ -389,7 +389,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // Handle wide pointers.\n         // Check metadata early, for better diagnostics\n         let place = try_validation!(\n-            self.ecx.ref_to_mplace(value),\n+            self.ecx.ref_to_mplace(&value),\n             self.path,\n             err_ub!(InvalidUninitBytes(None)) => { \"uninitialized {}\", kind },\n         );\n@@ -398,7 +398,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         }\n         // Make sure this is dereferenceable and all.\n         let size_and_align = try_validation!(\n-            self.ecx.size_and_align_of_mplace(place),\n+            self.ecx.size_and_align_of_mplace(&place),\n             self.path,\n             err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n         );\n@@ -494,7 +494,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn read_scalar(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n         Ok(try_validation!(\n             self.ecx.read_scalar(op),\n@@ -507,7 +507,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     /// at that type.  Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n         &mut self,\n-        value: OpTy<'tcx, M::PointerTag>,\n+        value: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, bool> {\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n@@ -555,7 +555,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n                 let place = try_validation!(\n-                    self.ecx.read_immediate(value).and_then(|i| self.ecx.ref_to_mplace(i)),\n+                    self.ecx.read_immediate(value).and_then(|ref i| self.ecx.ref_to_mplace(i)),\n                     self.path,\n                     err_ub!(InvalidUninitBytes(None)) => { \"uninitialized raw pointer\" },\n                     err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n@@ -634,7 +634,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn visit_scalar(\n         &mut self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         scalar_layout: &Scalar,\n     ) -> InterpResult<'tcx> {\n         let value = self.read_scalar(op)?;\n@@ -708,7 +708,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n     fn read_discriminant(\n         &mut self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, VariantIdx> {\n         self.with_elem(PathElem::EnumTag, move |this| {\n             Ok(try_validation!(\n@@ -728,9 +728,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline]\n     fn visit_field(\n         &mut self,\n-        old_op: OpTy<'tcx, M::PointerTag>,\n+        old_op: &OpTy<'tcx, M::PointerTag>,\n         field: usize,\n-        new_op: OpTy<'tcx, M::PointerTag>,\n+        new_op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let elem = self.aggregate_field_path_elem(old_op.layout, field);\n         self.with_elem(elem, move |this| this.visit_value(new_op))\n@@ -739,9 +739,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline]\n     fn visit_variant(\n         &mut self,\n-        old_op: OpTy<'tcx, M::PointerTag>,\n+        old_op: &OpTy<'tcx, M::PointerTag>,\n         variant_id: VariantIdx,\n-        new_op: OpTy<'tcx, M::PointerTag>,\n+        new_op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let name = match old_op.layout.ty.kind() {\n             ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n@@ -755,14 +755,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline(always)]\n     fn visit_union(\n         &mut self,\n-        _op: OpTy<'tcx, M::PointerTag>,\n+        _op: &OpTy<'tcx, M::PointerTag>,\n         _fields: NonZeroUsize,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     #[inline]\n-    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    fn visit_value(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n \n         // Check primitive types -- the leafs of our recursive descend.\n@@ -819,7 +819,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n     fn visit_aggregate(\n         &mut self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.kind() {\n@@ -921,7 +921,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn validate_operand_internal(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n         ctfe_mode: Option<CtfeValidationMode>,\n@@ -932,10 +932,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let mut visitor = ValidityVisitor { path, ref_tracking, ctfe_mode, ecx: self };\n \n         // Try to cast to ptr *once* instead of all the time.\n-        let op = self.force_op_ptr(op).unwrap_or(op);\n+        let op = self.force_op_ptr(&op).unwrap_or(*op);\n \n         // Run it.\n-        match visitor.visit_value(op) {\n+        match visitor.visit_value(&op) {\n             Ok(()) => Ok(()),\n             // Pass through validation failures.\n             Err(err) if matches!(err.kind(), err_ub!(ValidationFailure { .. })) => Err(err),\n@@ -963,7 +963,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn const_validate_operand(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n         ctfe_mode: CtfeValidationMode,\n@@ -975,7 +975,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// `op` is assumed to cover valid memory if it is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     #[inline(always)]\n-    pub fn validate_operand(&self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    pub fn validate_operand(&self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         self.validate_operand_internal(op, vec![], None, None)\n     }\n }"}, {"sha": "32edca6f3dff9629ce15ede2cea11c8f811a4abb", "filename": "compiler/rustc_mir/src/interpret/visitor.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -18,21 +18,25 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     fn layout(&self) -> TyAndLayout<'tcx>;\n \n     /// Makes this into an `OpTy`.\n-    fn to_op(self, ecx: &InterpCx<'mir, 'tcx, M>) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+    fn to_op(&self, ecx: &InterpCx<'mir, 'tcx, M>)\n+    -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n     fn from_mem_place(mplace: MPlaceTy<'tcx, M::PointerTag>) -> Self;\n \n     /// Projects to the given enum variant.\n     fn project_downcast(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: usize)\n-    -> InterpResult<'tcx, Self>;\n+    fn project_field(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self>;\n }\n \n // Operands and memory-places are both values.\n@@ -45,10 +49,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n \n     #[inline(always)]\n     fn to_op(\n-        self,\n+        &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(self)\n+        Ok(*self)\n     }\n \n     #[inline(always)]\n@@ -58,7 +62,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n \n     #[inline(always)]\n     fn project_downcast(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n@@ -67,7 +71,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n \n     #[inline(always)]\n     fn project_field(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         field: usize,\n     ) -> InterpResult<'tcx, Self> {\n@@ -85,10 +89,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n \n     #[inline(always)]\n     fn to_op(\n-        self,\n+        &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(self.into())\n+        Ok((*self).into())\n     }\n \n     #[inline(always)]\n@@ -98,7 +102,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n \n     #[inline(always)]\n     fn project_downcast(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n@@ -107,7 +111,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n \n     #[inline(always)]\n     fn project_field(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         field: usize,\n     ) -> InterpResult<'tcx, Self> {\n@@ -129,21 +133,21 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn read_discriminant(\n                 &mut self,\n-                op: OpTy<'tcx, M::PointerTag>,\n+                op: &OpTy<'tcx, M::PointerTag>,\n             ) -> InterpResult<'tcx, VariantIdx> {\n                 Ok(self.ecx().read_discriminant(op)?.1)\n             }\n \n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors.\n             #[inline(always)]\n-            fn visit_value(&mut self, v: Self::V) -> InterpResult<'tcx>\n+            fn visit_value(&mut self, v: &Self::V) -> InterpResult<'tcx>\n             {\n                 self.walk_value(v)\n             }\n             /// Visits the given value as a union. No automatic recursion can happen here.\n             #[inline(always)]\n-            fn visit_union(&mut self, _v: Self::V, _fields: NonZeroUsize) -> InterpResult<'tcx>\n+            fn visit_union(&mut self, _v: &Self::V, _fields: NonZeroUsize) -> InterpResult<'tcx>\n             {\n                 Ok(())\n             }\n@@ -153,7 +157,7 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn visit_aggregate(\n                 &mut self,\n-                v: Self::V,\n+                v: &Self::V,\n                 fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n             ) -> InterpResult<'tcx> {\n                 self.walk_aggregate(v, fields)\n@@ -167,9 +171,9 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn visit_field(\n                 &mut self,\n-                _old_val: Self::V,\n+                _old_val: &Self::V,\n                 _field: usize,\n-                new_val: Self::V,\n+                new_val: &Self::V,\n             ) -> InterpResult<'tcx> {\n                 self.visit_value(new_val)\n             }\n@@ -179,26 +183,26 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn visit_variant(\n                 &mut self,\n-                _old_val: Self::V,\n+                _old_val: &Self::V,\n                 _variant: VariantIdx,\n-                new_val: Self::V,\n+                new_val: &Self::V,\n             ) -> InterpResult<'tcx> {\n                 self.visit_value(new_val)\n             }\n \n             // Default recursors. Not meant to be overloaded.\n             fn walk_aggregate(\n                 &mut self,\n-                v: Self::V,\n+                v: &Self::V,\n                 fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n             ) -> InterpResult<'tcx> {\n                 // Now iterate over it.\n                 for (idx, field_val) in fields.enumerate() {\n-                    self.visit_field(v, idx, field_val?)?;\n+                    self.visit_field(v, idx, &field_val?)?;\n                 }\n                 Ok(())\n             }\n-            fn walk_value(&mut self, v: Self::V) -> InterpResult<'tcx>\n+            fn walk_value(&mut self, v: &Self::V) -> InterpResult<'tcx>\n             {\n                 trace!(\"walk_value: type: {}\", v.layout().ty);\n \n@@ -208,10 +212,10 @@ macro_rules! make_value_visitor {\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n                         let dest = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n-                        let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n+                        let inner = self.ecx().unpack_dyn_trait(&dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n-                        return self.visit_field(v, 0, Value::from_mem_place(inner));\n+                        return self.visit_field(&v, 0, &Value::from_mem_place(inner));\n                     },\n                     // Slices do not need special handling here: they have `Array` field\n                     // placement with length 0, so we enter the `Array` case below which\n@@ -241,7 +245,7 @@ macro_rules! make_value_visitor {\n                         // Now we can go over all the fields.\n                         // This uses the *run-time length*, i.e., if we are a slice,\n                         // the dynamic info from the metadata is used.\n-                        let iter = self.ecx().mplace_array_fields(mplace)?\n+                        let iter = self.ecx().mplace_array_fields(&mplace)?\n                             .map(|f| f.and_then(|f| {\n                                 Ok(Value::from_mem_place(f))\n                             }));\n@@ -254,11 +258,11 @@ macro_rules! make_value_visitor {\n                     // with *its* fields.\n                     Variants::Multiple { .. } => {\n                         let op = v.to_op(self.ecx())?;\n-                        let idx = self.read_discriminant(op)?;\n+                        let idx = self.read_discriminant(&op)?;\n                         let inner = v.project_downcast(self.ecx(), idx)?;\n                         trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n                         // recurse with the inner type\n-                        self.visit_variant(v, idx, inner)\n+                        self.visit_variant(v, idx, &inner)\n                     }\n                     // For single-variant layouts, we already did anything there is to do.\n                     Variants::Single { .. } => Ok(())"}, {"sha": "5384dbcb8a6a17eff9d37b355c6307b3621a60bc", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -197,7 +197,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _instance: ty::Instance<'tcx>,\n         _abi: Abi,\n         _args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n+        _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n         Ok(None)\n@@ -207,7 +207,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n+        _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n@@ -228,16 +228,16 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     fn binary_ptr_op(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: BinOp,\n-        _left: ImmTy<'tcx>,\n-        _right: ImmTy<'tcx>,\n+        _left: &ImmTy<'tcx>,\n+        _right: &ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         // We can't do this because aliasing of memory can differ between const eval and llvm\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _dest: PlaceTy<'tcx>,\n+        _dest: &PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n         throw_machine_stop_str!(\"can't const prop heap allocations\")\n     }\n@@ -392,12 +392,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             .filter(|ret_layout| {\n                 !ret_layout.is_zst() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n             })\n-            .map(|ret_layout| ecx.allocate(ret_layout, MemoryKind::Stack));\n+            .map(|ret_layout| ecx.allocate(ret_layout, MemoryKind::Stack).into());\n \n         ecx.push_stack_frame(\n             Instance::new(def_id, substs),\n             dummy_body,\n-            ret.map(Into::into),\n+            ret.as_ref(),\n             StackPopCleanup::None { cleanup: false },\n         )\n         .expect(\"failed to push initial stack frame\");\n@@ -426,7 +426,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.try_read_immediate(op) {\n+        Some(match self.ecx.try_read_immediate(&op) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })\n@@ -548,8 +548,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<()> {\n         if let (val, true) = self.use_ecx(|this| {\n-            let val = this.ecx.read_immediate(this.ecx.eval_operand(arg, None)?)?;\n-            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, val)?;\n+            let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n+            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n             Ok((val, overflow))\n         })? {\n             // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n@@ -573,8 +573,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         right: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        let r = self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(right, None)?));\n-        let l = self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(left, None)?));\n+        let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n+        let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n             let r = r?;\n@@ -609,7 +609,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             }\n         }\n \n-        if let (Some(l), Some(r)) = (l, r) {\n+        if let (Some(l), Some(r)) = (&l, &r) {\n             // The remaining operators are handled through `overflowing_binary_op`.\n             if self.use_ecx(|this| {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n@@ -630,7 +630,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         match *operand {\n             Operand::Copy(l) | Operand::Move(l) => {\n                 if let Some(value) = self.get_const(l) {\n-                    if self.should_const_prop(value) {\n+                    if self.should_const_prop(&value) {\n                         // FIXME(felix91gr): this code only handles `Scalar` cases.\n                         // For now, we're not handling `ScalarPair` cases because\n                         // doing so here would require a lot of code duplication.\n@@ -745,7 +745,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     let r = this.ecx.eval_operand(right, None);\n \n                     let const_arg = match (l, r) {\n-                        (Ok(x), Err(_)) | (Err(_), Ok(x)) => this.ecx.read_immediate(x)?,\n+                        (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n                         (Err(e), Err(_)) => return Err(e),\n                         (Ok(_), Ok(_)) => {\n                             this.ecx.eval_rvalue_into_place(rvalue, place)?;\n@@ -760,14 +760,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     match op {\n                         BinOp::BitAnd => {\n                             if arg_value == 0 {\n-                                this.ecx.write_immediate(*const_arg, dest)?;\n+                                this.ecx.write_immediate(*const_arg, &dest)?;\n                             }\n                         }\n                         BinOp::BitOr => {\n                             if arg_value == const_arg.layout.size.truncate(u128::MAX)\n                                 || (const_arg.layout.ty.is_bool() && arg_value == 1)\n                             {\n-                                this.ecx.write_immediate(*const_arg, dest)?;\n+                                this.ecx.write_immediate(*const_arg, &dest)?;\n                             }\n                         }\n                         BinOp::Mul => {\n@@ -777,9 +777,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                                         const_arg.to_scalar()?.into(),\n                                         Scalar::from_bool(false).into(),\n                                     );\n-                                    this.ecx.write_immediate(val, dest)?;\n+                                    this.ecx.write_immediate(val, &dest)?;\n                                 } else {\n-                                    this.ecx.write_immediate(*const_arg, dest)?;\n+                                    this.ecx.write_immediate(*const_arg, &dest)?;\n                                 }\n                             }\n                         }\n@@ -809,7 +809,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn replace_with_const(\n         &mut self,\n         rval: &mut Rvalue<'tcx>,\n-        value: OpTy<'tcx>,\n+        value: &OpTy<'tcx>,\n         source_info: SourceInfo,\n     ) {\n         if let Rvalue::Use(Operand::Constant(c)) = rval {\n@@ -902,7 +902,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Returns `true` if and only if this `op` should be const-propagated into.\n-    fn should_const_prop(&mut self, op: OpTy<'tcx>) -> bool {\n+    fn should_const_prop(&mut self, op: &OpTy<'tcx>) -> bool {\n         let mir_opt_level = self.tcx.sess.opts.debugging_opts.mir_opt_level;\n \n         if mir_opt_level == 0 {\n@@ -913,7 +913,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return false;\n         }\n \n-        match *op {\n+        match **op {\n             interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUninit::Scalar(s))) => {\n                 s.is_bits()\n             }\n@@ -1094,7 +1094,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 // This will return None if the above `const_prop` invocation only \"wrote\" a\n                 // type whose creation requires no write. E.g. a generator whose initial state\n                 // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                if let Some(value) = self.get_const(place) {\n+                if let Some(ref value) = self.get_const(place) {\n                     if self.should_const_prop(value) {\n                         trace!(\"replacing {:?} with {:?}\", rval, value);\n                         self.replace_with_const(rval, value, source_info);\n@@ -1177,10 +1177,10 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         self.super_terminator(terminator, location);\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref msg, ref mut cond, .. } => {\n-                if let Some(value) = self.eval_operand(&cond, source_info) {\n+                if let Some(ref value) = self.eval_operand(&cond, source_info) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = ScalarMaybeUninit::from(Scalar::from_bool(*expected));\n-                    let value_const = self.ecx.read_scalar(value).unwrap();\n+                    let value_const = self.ecx.read_scalar(&value).unwrap();\n                     if expected != value_const {\n                         enum DbgVal<T> {\n                             Val(T),\n@@ -1198,9 +1198,9 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             // This can be `None` if the lhs wasn't const propagated and we just\n                             // triggered the assert on the value of the rhs.\n                             match self.eval_operand(op, source_info) {\n-                                Some(op) => {\n-                                    DbgVal::Val(self.ecx.read_immediate(op).unwrap().to_const_int())\n-                                }\n+                                Some(op) => DbgVal::Val(\n+                                    self.ecx.read_immediate(&op).unwrap().to_const_int(),\n+                                ),\n                                 None => DbgVal::Underscore,\n                             }\n                         };"}]}