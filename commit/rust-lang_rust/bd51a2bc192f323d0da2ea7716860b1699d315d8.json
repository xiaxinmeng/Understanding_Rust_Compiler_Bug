{"sha": "bd51a2bc192f323d0da2ea7716860b1699d315d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNTFhMmJjMTkyZjMyM2QwZGEyZWE3NzE2ODYwYjE2OTlkMzE1ZDg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-17T01:42:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:31Z"}, "message": "rustc: move size/alignment from Layout into layout::Abi.", "tree": {"sha": "67183938e89ad580214c020de42451531341bdc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67183938e89ad580214c020de42451531341bdc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd51a2bc192f323d0da2ea7716860b1699d315d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd51a2bc192f323d0da2ea7716860b1699d315d8", "html_url": "https://github.com/rust-lang/rust/commit/bd51a2bc192f323d0da2ea7716860b1699d315d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd51a2bc192f323d0da2ea7716860b1699d315d8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd86f3739e76484e410ec5e651ab3ee9049f31ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd86f3739e76484e410ec5e651ab3ee9049f31ba", "html_url": "https://github.com/rust-lang/rust/commit/bd86f3739e76484e410ec5e651ab3ee9049f31ba"}], "stats": {"total": 471, "additions": 257, "deletions": 214}, "files": [{"sha": "eb22b6f2ce990fdc0e2832aaa942076b0c13ac57", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 199, "deletions": 160, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -25,7 +25,7 @@ use std::fmt;\n use std::i64;\n use std::iter;\n use std::mem;\n-use std::ops::{Deref, Add, Sub, Mul, AddAssign, RangeInclusive};\n+use std::ops::{Add, Sub, Mul, AddAssign, RangeInclusive};\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -856,7 +856,7 @@ impl<'a, 'tcx> Struct {\n             // Is this the NonZero lang item wrapping a pointer or integer type?\n             (_, &ty::TyAdt(def, _)) if Some(def.did) == tcx.lang_items().non_zero() => {\n                 let field = layout.field(cx, 0)?;\n-                match *field {\n+                match *field.layout {\n                     Scalar(value) => {\n                         Ok(Some((layout.fields.offset(0), value)))\n                     }\n@@ -965,7 +965,7 @@ impl<'a, 'tcx> Union {\n                  fields: I,\n                  scapegoat: Ty<'tcx>)\n                  -> Result<(), LayoutError<'tcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n+    where I: Iterator<Item=Result<FullLayout<'a>, LayoutError<'tcx>>> {\n         for (index, field) in fields.enumerate() {\n             let field = field?;\n             if field.is_unsized() {\n@@ -1061,8 +1061,80 @@ impl<'a> FieldPlacement<'a> {\n #[derive(Copy, Clone, Debug)]\n pub enum Abi {\n     Scalar(Primitive),\n-    Vector,\n-    Aggregate\n+    Vector {\n+        element: Primitive,\n+        count: u64\n+    },\n+    Aggregate {\n+        /// If true, the size is exact, otherwise it's only a lower bound.\n+        sized: bool,\n+        align: Align,\n+        primitive_align: Align,\n+        size: Size\n+    }\n+}\n+\n+impl Abi {\n+    /// Returns true if the layout corresponds to an unsized type.\n+    pub fn is_unsized(&self) -> bool {\n+        match *self {\n+            Abi::Scalar(_) | Abi::Vector {..} => false,\n+            Abi::Aggregate { sized, .. } => !sized\n+        }\n+    }\n+\n+    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n+        let dl = cx.data_layout();\n+\n+        match *self {\n+            Abi::Scalar(value) => value.size(dl),\n+\n+            Abi::Vector { element, count } => {\n+                let element_size = element.size(dl);\n+                let vec_size = match element_size.checked_mul(count, dl) {\n+                    Some(size) => size,\n+                    None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n+                                 self, element_size.bytes(), count)\n+                };\n+                vec_size.abi_align(self.align(dl))\n+            }\n+\n+            Abi::Aggregate { size, .. } => size\n+        }\n+    }\n+\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+\n+        match *self {\n+            Abi::Scalar(value) => value.align(dl),\n+\n+            Abi::Vector { element, count } => {\n+                let elem_size = element.size(dl);\n+                let vec_size = match elem_size.checked_mul(count, dl) {\n+                    Some(size) => size,\n+                    None => bug!(\"Layout::align({:?}): {} * {} overflowed\",\n+                                 self, elem_size.bytes(), count)\n+                };\n+                dl.vector_align(vec_size)\n+            }\n+\n+            Abi::Aggregate { align, .. } => align\n+        }\n+    }\n+\n+    pub fn size_and_align<C: HasDataLayout>(&self, cx: C) -> (Size, Align) {\n+        (self.size(cx), self.align(cx))\n+    }\n+\n+    /// Returns alignment before repr alignment is applied\n+    pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        match *self {\n+            Abi::Aggregate { primitive_align, .. } => primitive_align,\n+\n+            _ => self.align(cx.data_layout())\n+        }\n+    }\n }\n \n /// Type layout, from which size and alignment can be cheaply computed.\n@@ -1247,19 +1319,63 @@ impl<'a, 'tcx> Layout {\n             };\n             let abi = match *layout {\n                 Scalar(value) => Abi::Scalar(value),\n-                Vector { .. } => Abi::Vector,\n+                Vector { element, count } => Abi::Vector { element, count },\n+\n+                Array { sized, align, primitive_align, element_size, count, .. } => {\n+                    let size = match element_size.checked_mul(count, dl) {\n+                        Some(size) => size,\n+                        None => return Err(LayoutError::SizeOverflow(ty))\n+                    };\n+                    Abi::Aggregate {\n+                        sized,\n+                        align,\n+                        primitive_align,\n+                        size\n+                    }\n+                }\n \n-                Array { .. } |\n-                FatPointer { .. } |\n-                Univariant(_) |\n-                UntaggedUnion(_) => Abi::Aggregate,\n+                FatPointer(metadata) => {\n+                    // Effectively a (ptr, meta) tuple.\n+                    let align = Pointer.align(dl).max(metadata.align(dl));\n+                    Abi::Aggregate {\n+                        sized: true,\n+                        align,\n+                        primitive_align: align,\n+                        size: (Pointer.size(dl).abi_align(metadata.align(dl)) +\n+                               metadata.size(dl))\n+                            .abi_align(align)\n+                    }\n+                }\n \n-                General { discr, .. } |\n-                NullablePointer { discr, .. } => {\n-                    if fields.offset(0).bytes() == 0 && discr.size(cx) == layout.size(cx) {\n+                Univariant(ref st) => {\n+                    Abi::Aggregate {\n+                        sized: st.sized,\n+                        align: st.align,\n+                        primitive_align: st.primitive_align,\n+                        size: st.stride()\n+                    }\n+                }\n+\n+                UntaggedUnion(ref un ) => {\n+                    Abi::Aggregate {\n+                        sized: true,\n+                        align: un.align,\n+                        primitive_align: un.primitive_align,\n+                        size: un.stride()\n+                    }\n+                }\n+\n+                General { discr, align, primitive_align, size, .. } |\n+                NullablePointer { discr, align, primitive_align, size, .. } => {\n+                    if fields.offset(0).bytes() == 0 && discr.size(cx) == size {\n                         Abi::Scalar(discr)\n                     } else {\n-                        Abi::Aggregate\n+                        Abi::Aggregate {\n+                            sized: true,\n+                            align,\n+                            primitive_align,\n+                            size\n+                        }\n                     }\n                 }\n             };\n@@ -1330,9 +1446,6 @@ impl<'a, 'tcx> Layout {\n                 let element = cx.layout_of(element)?;\n                 let element_size = element.size(dl);\n                 let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n-                if element_size.checked_mul(count, dl).is_none() {\n-                    return Err(LayoutError::SizeOverflow(ty));\n-                }\n                 Array {\n                     sized: true,\n                     align: element.align(dl),\n@@ -1408,8 +1521,8 @@ impl<'a, 'tcx> Layout {\n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n                 let element = ty.simd_type(tcx);\n-                match *cx.layout_of(element)? {\n-                    Scalar(value) => {\n+                match cx.layout_of(element)?.abi {\n+                    Abi::Scalar(value) => {\n                         return success(Vector {\n                             element: value,\n                             count: ty.simd_size(tcx) as u64\n@@ -1459,7 +1572,7 @@ impl<'a, 'tcx> Layout {\n \n                     let layout = if def.is_union() {\n                         let mut un = Union::new(dl, &def.repr);\n-                        un.extend(dl, variants[0].iter().map(|&f| Ok(f.layout)), ty)?;\n+                        un.extend(dl, variants[0].iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion(un)\n                     } else {\n                         Univariant(Struct::new(dl, &variants[0], &def.repr, kind, ty)?)\n@@ -1648,112 +1761,13 @@ impl<'a, 'tcx> Layout {\n         success(layout)\n     }\n \n-    /// Returns true if the layout corresponds to an unsized type.\n-    pub fn is_unsized(&self) -> bool {\n-        match *self {\n-            Scalar(_) | Vector {..} | FatPointer {..} |\n-            UntaggedUnion {..} | General {..} |\n-            NullablePointer {..} => false,\n-\n-            Array { sized, .. } |\n-            Univariant(Struct { sized, .. }) => !sized\n-        }\n-    }\n-\n-    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n-        let dl = cx.data_layout();\n-\n-        match *self {\n-            Scalar(value) => {\n-                value.size(dl)\n-            }\n-\n-            Vector { element, count } => {\n-                let element_size = element.size(dl);\n-                let vec_size = match element_size.checked_mul(count, dl) {\n-                    Some(size) => size,\n-                    None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n-                                 self, element_size.bytes(), count)\n-                };\n-                vec_size.abi_align(self.align(dl))\n-            }\n-\n-            Array { element_size, count, .. } => {\n-                match element_size.checked_mul(count, dl) {\n-                    Some(size) => size,\n-                    None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n-                                 self, element_size.bytes(), count)\n-                }\n-            }\n-\n-            FatPointer(metadata) => {\n-                // Effectively a (ptr, meta) tuple.\n-                (Pointer.size(dl).abi_align(metadata.align(dl)) +\n-                 metadata.size(dl)).abi_align(self.align(dl))\n-            }\n-\n-            NullablePointer { size, .. } |\n-            General { size, .. } => size,\n-            UntaggedUnion(ref un) => un.stride(),\n-            Univariant(ref variant) => variant.stride()\n-        }\n-    }\n-\n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        let dl = cx.data_layout();\n-\n-        match *self {\n-            Scalar(value) => {\n-                value.align(dl)\n-            }\n-\n-            Vector { element, count } => {\n-                let elem_size = element.size(dl);\n-                let vec_size = match elem_size.checked_mul(count, dl) {\n-                    Some(size) => size,\n-                    None => bug!(\"Layout::align({:?}): {} * {} overflowed\",\n-                                 self, elem_size.bytes(), count)\n-                };\n-                dl.vector_align(vec_size)\n-            }\n-\n-            FatPointer(metadata) => {\n-                // Effectively a (ptr, meta) tuple.\n-                Pointer.align(dl).max(metadata.align(dl))\n-            }\n-\n-            Array { align, .. } |\n-            NullablePointer { align, .. } |\n-            General { align, .. } => align,\n-            UntaggedUnion(ref un) => un.align,\n-            Univariant(ref variant) => variant.align\n-        }\n-    }\n-\n-    pub fn size_and_align<C: HasDataLayout>(&self, cx: C) -> (Size, Align) {\n-        (self.size(cx), self.align(cx))\n-    }\n-\n-    /// Returns alignment before repr alignment is applied\n-    pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        match *self {\n-            Array { primitive_align, .. } |\n-            NullablePointer { primitive_align, .. } |\n-            General { primitive_align, .. } => primitive_align,\n-\n-            Univariant(ref variant) => variant.primitive_align,\n-\n-            _ => self.align(cx.data_layout())\n-        }\n-    }\n-\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline]\n     fn record_layout_for_printing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   ty: Ty<'tcx>,\n                                   param_env: ty::ParamEnv<'tcx>,\n-                                  layout: &Layout) {\n+                                  layout: FullLayout) {\n         // If we are running with `-Zprint-type-sizes`, record layouts for\n         // dumping later. Ignore layouts that are done with non-empty\n         // environments or non-monomorphic layouts, as the user only wants\n@@ -1773,7 +1787,7 @@ impl<'a, 'tcx> Layout {\n     fn record_layout_for_printing_outlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            ty: Ty<'tcx>,\n                                            param_env: ty::ParamEnv<'tcx>,\n-                                           layout: &Layout) {\n+                                           layout: FullLayout) {\n         // (delay format until we actually need it)\n         let record = |kind, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", ty);\n@@ -1843,7 +1857,7 @@ impl<'a, 'tcx> Layout {\n             }\n         };\n \n-        match *layout {\n+        match *layout.layout {\n             Layout::Univariant(ref variant_layout) => {\n                 let variant_names = || {\n                     adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n@@ -1888,7 +1902,7 @@ impl<'a, 'tcx> Layout {\n                                                            variant_layout)\n                                     })\n                                     .collect();\n-                record(adt_kind.into(), match *layout {\n+                record(adt_kind.into(), match *layout.layout {\n                     Layout::General { discr, .. } => Some(discr.size(tcx)),\n                     _ => None\n                 }, variant_infos);\n@@ -2075,13 +2089,6 @@ pub struct FullLayout<'tcx> {\n     pub abi: Abi,\n }\n \n-impl<'tcx> Deref for FullLayout<'tcx> {\n-    type Target = Layout;\n-    fn deref(&self) -> &Layout {\n-        self.layout\n-    }\n-}\n-\n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n }\n@@ -2127,22 +2134,23 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx\n \n         let ty = tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n         let cached = tcx.layout_raw(param_env.reveal_all().and(ty))?;\n+        let layout = FullLayout {\n+            ty,\n+            variant_index: None,\n+            layout: cached.layout,\n+            fields: cached.fields,\n+            abi: cached.abi\n+        };\n \n         // NB: This recording is normally disabled; when enabled, it\n         // can however trigger recursive invocations of `layout_of`.\n         // Therefore, we execute it *after* the main query has\n         // completed, to avoid problems around recursive structures\n         // and the like. (Admitedly, I wasn't able to reproduce a problem\n         // here, but it seems like the right thing to do. -nmatsakis)\n-        Layout::record_layout_for_printing(tcx, ty, param_env, cached.layout);\n+        Layout::record_layout_for_printing(tcx, ty, param_env, layout);\n \n-        Ok(FullLayout {\n-            ty,\n-            variant_index: None,\n-            layout: cached.layout,\n-            fields: cached.fields,\n-            abi: cached.abi\n-        })\n+        Ok(layout)\n     }\n }\n \n@@ -2158,22 +2166,23 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n \n         let ty = tcx_at.tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n         let cached = tcx_at.layout_raw(param_env.reveal_all().and(ty))?;\n+        let layout = FullLayout {\n+            ty,\n+            variant_index: None,\n+            layout: cached.layout,\n+            fields: cached.fields,\n+            abi: cached.abi\n+        };\n \n         // NB: This recording is normally disabled; when enabled, it\n         // can however trigger recursive invocations of `layout_of`.\n         // Therefore, we execute it *after* the main query has\n         // completed, to avoid problems around recursive structures\n         // and the like. (Admitedly, I wasn't able to reproduce a problem\n         // here, but it seems like the right thing to do. -nmatsakis)\n-        Layout::record_layout_for_printing(tcx_at.tcx, ty, param_env, cached.layout);\n+        Layout::record_layout_for_printing(tcx_at.tcx, ty, param_env, layout);\n \n-        Ok(FullLayout {\n-            ty,\n-            variant_index: None,\n-            layout: cached.layout,\n-            fields: cached.fields,\n-            abi: cached.abi\n-        })\n+        Ok(layout)\n     }\n }\n \n@@ -2189,27 +2198,29 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n             variants[variant_index].fields.len()\n         };\n \n-        let fields = match *self.layout {\n-            Univariant(ref variant) => {\n-                FieldPlacement::Arbitrary {\n-                    offsets: &variant.offsets\n-                }\n-            }\n+        let (fields, abi) = match *self.layout {\n+            Univariant(_) => (self.fields, self.abi),\n \n             NullablePointer { ref variants, .. } |\n             General { ref variants, .. } => {\n-                FieldPlacement::Arbitrary {\n-                    offsets: &variants[variant_index].offsets\n-                }\n+                let variant = &variants[variant_index];\n+                (FieldPlacement::Arbitrary {\n+                    offsets: &variant.offsets\n+                }, Abi::Aggregate {\n+                    sized: true,\n+                    align: variant.align,\n+                    primitive_align: variant.primitive_align,\n+                    size: variant.stride(),\n+                })\n             }\n \n-            _ => FieldPlacement::union(count)\n+            _ => (FieldPlacement::union(count), self.abi)\n         };\n \n         FullLayout {\n             variant_index: Some(variant_index),\n             fields,\n-            abi: Abi::Aggregate,\n+            abi,\n             ..*self\n         }\n     }\n@@ -2313,6 +2324,28 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                                                           -> C::FullLayout {\n         cx.layout_of(self.field_type_unnormalized(cx.tcx(), i))\n     }\n+\n+    /// Returns true if the layout corresponds to an unsized type.\n+    pub fn is_unsized(&self) -> bool {\n+        self.abi.is_unsized()\n+    }\n+\n+    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n+        self.abi.size(cx)\n+    }\n+\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        self.abi.align(cx)\n+    }\n+\n+    pub fn size_and_align<C: HasDataLayout>(&self, cx: C) -> (Size, Align) {\n+        self.abi.size_and_align(cx)\n+    }\n+\n+    /// Returns alignment before repr alignment is applied\n+    pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        self.abi.primitive_align(cx)\n+    }\n }\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n@@ -2411,12 +2444,18 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            Scalar(value) => {\n+            Scalar(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            Vector => {\n+            Vector { ref element, count } => {\n+                element.hash_stable(hcx, hasher);\n+                count.hash_stable(hcx, hasher);\n             }\n-            Aggregate => {\n+            Aggregate { sized, size, align, primitive_align } => {\n+                sized.hash_stable(hcx, hasher);\n+                size.hash_stable(hcx, hasher);\n+                align.hash_stable(hcx, hasher);\n+                primitive_align.hash_stable(hcx, hasher);\n             }\n         }\n     }"}, {"sha": "b993b161877a025b6059a1af8b0565af8e00012b", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -753,7 +753,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n \n-                if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n+                if let Layout::General { ref variants, size, discr, .. } = *layout.layout {\n                     let discr_size = discr.size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\","}, {"sha": "712108bf437bc63c6ea680cb4b717e64622540bc", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -278,8 +278,8 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n     fn is_aggregate(&self) -> bool {\n         match self.abi {\n             layout::Abi::Scalar(_) |\n-            layout::Abi::Vector => false,\n-            layout::Abi::Aggregate => true\n+            layout::Abi::Vector { .. } => false,\n+            layout::Abi::Aggregate { .. } => true\n         }\n     }\n \n@@ -299,14 +299,14 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n                 })\n             }\n \n-            layout::Abi::Vector => {\n+            layout::Abi::Vector { .. } => {\n                 Some(Reg {\n                     kind: RegKind::Vector,\n                     size: self.size(ccx)\n                 })\n             }\n \n-            layout::Abi::Aggregate => {\n+            layout::Abi::Aggregate { .. } => {\n                 if let Layout::Array { count, .. } = *self.layout {\n                     if count > 0 {\n                         return self.field(ccx, 0).homogeneous_aggregate(ccx);\n@@ -767,7 +767,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         for ty in inputs.iter().chain(extra_args.iter()) {\n             let mut arg = arg_of(ty, false);\n \n-            if let ty::layout::FatPointer { .. } = *arg.layout {\n+            if let ty::layout::FatPointer { .. } = *arg.layout.layout {\n                 let mut data = ArgType::new(arg.layout.field(ccx, 0));\n                 let mut info = ArgType::new(arg.layout.field(ccx, 1));\n \n@@ -809,7 +809,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             let fixup = |arg: &mut ArgType<'tcx>| {\n                 match arg.layout.abi {\n-                    layout::Abi::Aggregate => {}\n+                    layout::Abi::Aggregate { .. } => {}\n                     _ => return\n                 }\n "}, {"sha": "314d929fe8c37bd39541a6692f09cf2bbf122687", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -71,7 +71,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     if let layout::Abi::Scalar(_) = l.abi {\n         return;\n     }\n-    match *l {\n+    match *l.layout {\n         layout::NullablePointer { .. } |\n         layout::General { .. } |\n         layout::UntaggedUnion { .. } => { }\n@@ -101,7 +101,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     if let layout::Abi::Scalar(value) = l.abi {\n         return cx.llvm_type_of(value.to_ty(cx.tcx()));\n     }\n-    match *l {\n+    match *l.layout {\n         layout::Univariant(ref variant) => {\n             match name {\n                 None => {"}, {"sha": "2766edb59c1d84b98a24385fdfb1b0dad3641047", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -29,7 +29,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match layout.abi {\n         layout::Abi::Scalar(layout::F32) |\n         layout::Abi::Scalar(layout::F64) => true,\n-        layout::Abi::Aggregate => {\n+        layout::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(ccx, layout.field(ccx, 0))\n             } else {"}, {"sha": "7d3621d53e0dd4194b116eba79da76745ed6385c", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -24,7 +24,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match layout.abi {\n         layout::Abi::Scalar(layout::F32) |\n         layout::Abi::Scalar(layout::F64) => true,\n-        layout::Abi::Aggregate => {\n+        layout::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(ccx, layout.field(ccx, 0))\n             } else {"}, {"sha": "d6d46307a4ff539b6dc646a0c709ee67e5725dda", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -75,22 +75,22 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                 unify(cls, off, reg);\n             }\n \n-            layout::Abi::Vector => {\n+            layout::Abi::Vector { element, count } => {\n                 unify(cls, off, Class::Sse);\n \n                 // everything after the first one is the upper\n                 // half of a register.\n-                let eltsz = layout.field(ccx, 0).size(ccx);\n-                for i in 1..layout.fields.count() {\n+                let eltsz = element.size(ccx);\n+                for i in 1..count {\n                     unify(cls, off + eltsz * (i as u64), Class::SseUp);\n                 }\n             }\n \n-            layout::Abi::Aggregate => {\n+            layout::Abi::Aggregate { .. } => {\n                 // FIXME(eddyb) have to work around Rust enums for now.\n                 // Fix is either guarantee no data where there is no field,\n                 // by putting variants in fields, or be more clever.\n-                match *layout {\n+                match *layout.layout {\n                     Layout::General { .. } |\n                     Layout::NullablePointer { .. } => return Err(Memory),\n                     _ => {}"}, {"sha": "b27ccc98861aafb963fcb4da4b4c0b5af9040cc6", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -8,32 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, LayoutExt, Reg};\n+use abi::{ArgType, FnType, Reg};\n use common::CrateContext;\n \n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let fixup = |a: &mut ArgType<'tcx>| {\n         let size = a.layout.size(ccx);\n-        if a.layout.is_aggregate() {\n-            match size.bits() {\n-                8 => a.cast_to(Reg::i8()),\n-                16 => a.cast_to(Reg::i16()),\n-                32 => a.cast_to(Reg::i32()),\n-                64 => a.cast_to(Reg::i64()),\n-                _ => a.make_indirect(ccx)\n-            };\n-        } else {\n-            if let Layout::Vector { .. } = *a.layout {\n+        match a.layout.abi {\n+            layout::Abi::Aggregate { .. } => {\n+                match size.bits() {\n+                    8 => a.cast_to(Reg::i8()),\n+                    16 => a.cast_to(Reg::i16()),\n+                    32 => a.cast_to(Reg::i32()),\n+                    64 => a.cast_to(Reg::i64()),\n+                    _ => a.make_indirect(ccx)\n+                }\n+            }\n+            layout::Abi::Vector { .. } => {\n                 // FIXME(eddyb) there should be a size cap here\n                 // (probably what clang calls \"illegal vectors\").\n-            } else if size.bytes() > 8 {\n-                a.make_indirect(ccx);\n-            } else {\n-                a.extend_integer_width_to(32);\n+            }\n+            layout::Abi::Scalar(_) => {\n+                if size.bytes() > 8 {\n+                    a.make_indirect(ccx);\n+                } else {\n+                    a.extend_integer_width_to(32);\n+                }\n             }\n         }\n     };"}, {"sha": "bc6ddef0e7206103e4ced9992245bf220db306e2", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -41,7 +41,7 @@ use syntax_pos::{Span, DUMMY_SP};\n pub use context::{CrateContext, SharedCrateContext};\n \n pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    if let Layout::FatPointer { .. } = *ccx.layout_of(ty) {\n+    if let Layout::FatPointer { .. } = *ccx.layout_of(ty).layout {\n         true\n     } else {\n         false\n@@ -51,9 +51,9 @@ pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     let layout = ccx.layout_of(ty);\n     match layout.abi {\n-        layout::Abi::Scalar(_) | layout::Abi::Vector => true,\n+        layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => true,\n \n-        layout::Abi::Aggregate => {\n+        layout::Abi::Aggregate { .. } => {\n             !layout.is_unsized() && layout.size(ccx).bytes() == 0\n         }\n     }\n@@ -63,7 +63,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> bool {\n     let layout = ccx.layout_of(ty);\n-    match *layout {\n+    match *layout.layout {\n         Layout::FatPointer { .. } => true,\n         Layout::Univariant(ref variant) => {\n             // There must be only 2 fields."}, {"sha": "6ab89f5c3eb674614cd37630b794431cf51030b6", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -941,7 +941,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n         let layout = cx.layout_of(self.ty);\n \n         let tmp;\n-        let offsets = match *layout {\n+        let offsets = match *layout.layout {\n             layout::Univariant(ref variant) => &variant.offsets,\n             layout::Vector { element, count } => {\n                 let element_size = element.size(cx).bytes();\n@@ -1022,7 +1022,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n-        let offsets = if let layout::Univariant(ref variant) = *layout {\n+        let offsets = if let layout::Univariant(ref variant) = *layout.layout {\n             &variant.offsets\n         } else {\n             bug!(\"{} is not a tuple\", self.ty);\n@@ -1339,7 +1339,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    span: Span)\n                                    -> (DICompositeType, MemberDescriptionFactory<'tcx>) {\n     let layout = cx.layout_of(enum_type);\n-    let maybe_discr = match *layout {\n+    let maybe_discr = match *layout.layout {\n         layout::General { .. } => Some(layout.field(cx, 0).ty),\n         _ => None,\n     };\n@@ -1491,7 +1491,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let type_rep = cx.layout_of(enum_type);\n \n-    let discriminant_type_metadata = match *type_rep {\n+    let discriminant_type_metadata = match *type_rep.layout {\n         layout::NullablePointer { .. } | layout::Univariant { .. } => None,\n         layout::General { discr, .. } => Some(discriminant_type_metadata(discr)),\n         ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)"}, {"sha": "209083a8e25d6331770f3b8a42f188c56e2b6c1f", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -58,7 +58,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let layout = ccx.layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n-            let (sized_size, sized_align) = match *layout {\n+            let (sized_size, sized_align) = match *layout.layout {\n                 ty::layout::Layout::Univariant(ref variant) => {\n                     (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align.abi())\n                 }"}, {"sha": "c64333fc044354bbd2335ac76ae543f2036c7815", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -1090,7 +1090,7 @@ fn trans_const_adt<'a, 'tcx>(\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n     };\n-    match *l {\n+    match *l.layout {\n         layout::General { ref variants, .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {"}, {"sha": "00c76bee1a8e47b66dfaf1b0806d93c5a70f9b8b", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -208,10 +208,10 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let field = l.field(ccx, ix);\n         let offset = l.fields.offset(ix).bytes();\n \n-        let alignment = self.alignment | Alignment::from(&*l);\n+        let alignment = self.alignment | Alignment::from(l.layout);\n \n         // Unions and newtypes only use an offset of 0.\n-        match *l {\n+        match *l.layout {\n             // FIXME(eddyb) The fields of a fat pointer aren't correct, especially\n             // to unsized structs, we can't represent their pointee types in `Ty`.\n             Layout::FatPointer { .. } => {}\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         }\n \n         // Discriminant field of enums.\n-        match *l {\n+        match *l.layout {\n             layout::NullablePointer { .. } if l.variant_index.is_none() => {\n                 let ty = ccx.llvm_type_of(field.ty);\n                 let size = field.size(ccx).bytes();\n@@ -271,7 +271,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         };\n \n         // Check whether the variant being used is packed, if applicable.\n-        let is_packed = match (&*l, l.variant_index) {\n+        let is_packed = match (l.layout, l.variant_index) {\n             (&layout::Univariant(ref variant), _) => variant.packed,\n             (&layout::NullablePointer { ref variants, .. }, Some(v)) |\n             (&layout::General { ref variants, .. }, Some(v)) => variants[v].packed,\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let l = bcx.ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n \n         let cast_to = bcx.ccx.immediate_llvm_type_of(cast_to);\n-        match *l {\n+        match *l.layout {\n             layout::Univariant { .. } |\n             layout::UntaggedUnion { .. } => return C_uint(cast_to, 0),\n             _ => {}\n@@ -366,7 +366,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             layout::Abi::Scalar(discr) => discr,\n             _ => bug!(\"discriminant not scalar: {:#?}\", discr_layout)\n         };\n-        let (min, max) = match *l {\n+        let (min, max) = match *l.layout {\n             layout::General { ref discr_range, .. } => (discr_range.start, discr_range.end),\n             _ => (0, u64::max_value()),\n         };\n@@ -392,7 +392,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 bcx.load(discr.llval, discr.alignment.non_abi())\n             }\n         };\n-        match *l {\n+        match *l.layout {\n             layout::General { .. } => {\n                 let signed = match discr_scalar {\n                     layout::Int(_, signed) => signed,\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let to = l.ty.ty_adt_def().unwrap()\n             .discriminant_for_variant(bcx.tcx(), variant_index)\n             .to_u128_unchecked() as u64;\n-        match *l {\n+        match *l.layout {\n             layout::General { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n                 bcx.store(C_int(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx())), to as i64),\n@@ -471,7 +471,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n             // If this is an enum, cast to the appropriate variant struct type.\n             let layout = bcx.ccx.layout_of(ty).for_variant(variant_index);\n-            match *layout {\n+            match *layout.layout {\n                 layout::NullablePointer { ref variants, .. } |\n                 layout::General { ref variants, .. } => {\n                     let st = &variants[variant_index];"}, {"sha": "a71bcf4783801eece8ac24e4f53b431b0269659d", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -576,7 +576,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             };\n \n             let layout = bcx.ccx.layout_of(closure_ty);\n-            let offsets = match *layout {\n+            let offsets = match *layout.layout {\n                 layout::Univariant(ref variant) => &variant.offsets[..],\n                 _ => bug!(\"Closures are only supposed to be Univariant\")\n             };"}, {"sha": "518f36a77b5fc668b44225dcaee8c37d32fa6a65", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -277,7 +277,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let llval = operand.immediate();\n                         let l = bcx.ccx.layout_of(operand.ty);\n \n-                        if let Layout::General { ref discr_range, .. } = *l {\n+                        if let Layout::General { ref discr_range, .. } = *l.layout {\n                             if discr_range.end > discr_range.start {\n                                 // We want `table[e as usize]` to not\n                                 // have bound checks, and this is the most"}, {"sha": "b829d33600c820df4f7a7fe7140286d6bffcc875", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd51a2bc192f323d0da2ea7716860b1699d315d8/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=bd51a2bc192f323d0da2ea7716860b1699d315d8", "patch": "@@ -240,7 +240,7 @@ impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n         if let layout::Abi::Scalar(_) = self.abi {\n             bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self);\n         }\n-        match **self {\n+        match *self.layout {\n             Layout::Scalar { .. } |\n             Layout::UntaggedUnion { .. } => {\n                 bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)"}]}