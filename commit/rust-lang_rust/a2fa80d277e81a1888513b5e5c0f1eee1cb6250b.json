{"sha": "a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZmE4MGQyNzdlODFhMTg4ODUxM2I1ZTVjMGYxZWVlMWNiNjI1MGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-06T19:12:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-06T19:12:16Z"}, "message": "Auto merge of #1641 - JCTyblaidd:update_release_sequences, r=RalfJung\n\nWeaken release sequences to match the C++20 memory model\n\nSee [Weaken Release Sequences](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html), since the exception for relaxed writes on the same thread as a release write not blocking release sequences was removed in the C++20 memory model compared to the C11 memory model the paper was based on. The implementation can be updated and simplified to match this.  [Rust is currently specified to use the C++20 memory model](https://doc.rust-lang.org/std/sync/atomic/index.html).", "tree": {"sha": "9dfb39a9d94bee3c17580f59c944b3ab734aeb16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dfb39a9d94bee3c17580f59c944b3ab734aeb16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "html_url": "https://github.com/rust-lang/rust/commit/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6a2623b4eb5eef95bb30bd6cd72a49027a6ca58", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6a2623b4eb5eef95bb30bd6cd72a49027a6ca58", "html_url": "https://github.com/rust-lang/rust/commit/d6a2623b4eb5eef95bb30bd6cd72a49027a6ca58"}, {"sha": "6db821537f6900bfce2d46911c5243043d5700a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db821537f6900bfce2d46911c5243043d5700a0", "html_url": "https://github.com/rust-lang/rust/commit/6db821537f6900bfce2d46911c5243043d5700a0"}], "stats": {"total": 319, "additions": 90, "deletions": 229}, "files": [{"sha": "aec22dadc1b6b623c17eaf7a56bd2135b145dda4", "filename": "src/data_race.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "patch": "@@ -1,13 +1,18 @@\n //! Implementation of a data-race detector using Lamport Timestamps / Vector-clocks\n-//! based on the Dyamic Race Detection for C++:\n+//! based on the Dynamic Race Detection for C++:\n //! https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf\n //! which does not report false-positives when fences are used, and gives better\n //! accuracy in presence of read-modify-write operations.\n //!\n+//! The implementation contains modifications to correctly model the changes to the memory model in C++20\n+//! regarding the weakening of release sequences: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html.\n+//! Relaxed stores now unconditionally block all currently active release sequences and so per-thread tracking of release\n+//! sequences is not needed.\n+//!\n //! This does not explore weak memory orders and so can still miss data-races\n //! but should not report false-positives\n //!\n-//! Data-race definiton from(https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races):\n+//! Data-race definition from(https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races):\n //! a data race occurs between two memory accesses if they are on different threads, at least one operation\n //! is non-atomic, at least one operation is a write and neither access happens-before the other. Read the link\n //! for full definition.\n@@ -21,7 +26,7 @@\n //! This means that the thread-index can be safely re-used, starting on the next timestamp for the newly created\n //! thread.\n //!\n-//! The sequentially consistant ordering corresponds to the ordering that the threads\n+//! The sequentially consistent ordering corresponds to the ordering that the threads\n //! are currently scheduled, this means that the data-race detector has no additional\n //! logic for sequentially consistent accesses at the moment since they are indistinguishable\n //! from acquire/release operations. If weak memory orderings are explored then this\n@@ -67,7 +72,7 @@ use rustc_target::abi::Size;\n \n use crate::{\n     ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MiriEvalContext, MiriEvalContextExt,\n-    OpTy, Pointer, RangeMap, ScalarMaybeUninit, Tag, ThreadId, VClock, VSmallClockMap, VTimestamp,\n+    OpTy, Pointer, RangeMap, ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp,\n     VectorIdx,\n };\n \n@@ -122,7 +127,7 @@ struct ThreadClockSet {\n     /// thread once it performs an acquire fence.\n     fence_acquire: VClock,\n \n-    /// The last timesamp of happens-before relations that\n+    /// The last timestamp of happens-before relations that\n     /// have been released by this thread by a fence.\n     fence_release: VClock,\n }\n@@ -185,13 +190,6 @@ struct AtomicMemoryCellClocks {\n     /// happen-before a thread if an acquire-load is\n     /// performed on the data.\n     sync_vector: VClock,\n-\n-    /// The Hash-Map of all threads for which a release\n-    /// sequence exists in the memory cell, required\n-    /// since read-modify-write operations do not\n-    /// invalidate existing release sequences.\n-    /// See page 6 of linked paper.\n-    release_sequences: VSmallClockMap,\n }\n \n /// Memory Cell vector clock metadata\n@@ -207,7 +205,7 @@ struct MemoryCellClocks {\n     write_index: VectorIdx,\n \n     /// The vector-clock of the timestamp of the last read operation\n-    /// performed by a thread since the last write operation occured.\n+    /// performed by a thread since the last write operation occurred.\n     /// It is reset to zero on each write operation.\n     read: VClock,\n \n@@ -231,6 +229,7 @@ impl Default for MemoryCellClocks {\n }\n \n impl MemoryCellClocks {\n+    \n     /// Load the internal atomic memory cells if they exist.\n     #[inline]\n     fn atomic(&self) -> Option<&AtomicMemoryCellClocks> {\n@@ -283,21 +282,20 @@ impl MemoryCellClocks {\n         self.atomic_write_detect(clocks, index)?;\n         let atomic = self.atomic_mut();\n         atomic.sync_vector.clone_from(&clocks.clock);\n-        atomic.release_sequences.clear();\n-        atomic.release_sequences.insert(index, &clocks.clock);\n         Ok(())\n     }\n \n     /// Update the memory cell data-race tracking for atomic\n     /// store relaxed semantics.\n     fn store_relaxed(&mut self, clocks: &ThreadClockSet, index: VectorIdx) -> Result<(), DataRace> {\n         self.atomic_write_detect(clocks, index)?;\n+        \n+        // The handling of release sequences was changed in C++20 and so\n+        // the code here is different to the paper since now all relaxed\n+        // stores block release sequences. The exception for same-thread\n+        // relaxed stores has been removed.\n         let atomic = self.atomic_mut();\n         atomic.sync_vector.clone_from(&clocks.fence_release);\n-        if let Some(release) = atomic.release_sequences.get(index) {\n-            atomic.sync_vector.join(release);\n-        }\n-        atomic.release_sequences.retain_index(index);\n         Ok(())\n     }\n \n@@ -307,7 +305,6 @@ impl MemoryCellClocks {\n         self.atomic_write_detect(clocks, index)?;\n         let atomic = self.atomic_mut();\n         atomic.sync_vector.join(&clocks.clock);\n-        atomic.release_sequences.insert(index, &clocks.clock);\n         Ok(())\n     }\n \n@@ -523,7 +520,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         // Failure ordering cannot be stronger than success ordering, therefore first attempt\n-        // to read with the failure ordering and if successfull then try again with the success\n+        // to read with the failure ordering and if successful then try again with the success\n         // read ordering and write in the success case.\n         // Read as immediate for the sake of `binary_op()`\n         let old = this.allow_data_races_mut(|this| this.read_immediate(place.into()))?;\n@@ -546,7 +543,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         Ok(res)\n     }\n \n-    /// Update the data-race detector for an atomic read occuring at the\n+    /// Update the data-race detector for an atomic read occurring at the\n     /// associated memory-place and on the current thread.\n     fn validate_atomic_load(\n         &self,\n@@ -568,7 +565,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         )\n     }\n \n-    /// Update the data-race detector for an atomic write occuring at the\n+    /// Update the data-race detector for an atomic write occurring at the\n     /// associated memory-place and on the current thread.\n     fn validate_atomic_store(\n         &mut self,\n@@ -590,7 +587,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         )\n     }\n \n-    /// Update the data-race detector for an atomic read-modify-write occuring\n+    /// Update the data-race detector for an atomic read-modify-write occurring\n     /// at the associated memory place and on the current thread.\n     fn validate_atomic_rmw(\n         &mut self,\n@@ -694,9 +691,9 @@ impl VClockAlloc {\n \n     /// Report a data-race found in the program.\n     /// This finds the two racing threads and the type\n-    /// of data-race that occured. This will also\n+    /// of data-race that occurred. This will also\n     /// return info about the memory location the data-race\n-    /// occured in.\n+    /// occurred in.\n     #[cold]\n     #[inline(never)]\n     fn report_data_race<'tcx>(\n@@ -762,7 +759,7 @@ impl VClockAlloc {\n         )\n     }\n \n-    /// Detect data-races for an unsychronized read operation, will not perform\n+    /// Detect data-races for an unsynchronized read operation, will not perform\n     /// data-race detection if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation for which data-race detection is handled separately, for example\n@@ -818,15 +815,15 @@ impl VClockAlloc {\n         }\n     }\n \n-    /// Detect data-races for an unsychronized write operation, will not perform\n+    /// Detect data-races for an unsynchronized write operation, will not perform\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n         self.unique_access(pointer, len, \"Write\")\n     }\n \n-    /// Detect data-races for an unsychronized deallocate operation, will not perform\n+    /// Detect data-races for an unsynchronized deallocate operation, will not perform\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n@@ -838,7 +835,7 @@ impl VClockAlloc {\n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     // Temporarily allow data-races to occur, this should only be\n-    // used if either one of the appropiate `validate_atomic` functions\n+    // used if either one of the appropriate `validate_atomic` functions\n     // will be called to treat a memory access as atomic or if the memory\n     // being accessed should be treated as internal state, that cannot be\n     // accessed by the interpreted program.\n@@ -1000,7 +997,7 @@ pub struct GlobalState {\n     /// if a vector index is re-assigned to a new thread.\n     vector_info: RefCell<IndexVec<VectorIdx, ThreadId>>,\n \n-    /// The mapping of a given thread to assocaited thread metadata.\n+    /// The mapping of a given thread to associated thread metadata.\n     thread_info: RefCell<IndexVec<ThreadId, ThreadExtraState>>,\n \n     /// The current vector index being executed.\n@@ -1017,7 +1014,7 @@ pub struct GlobalState {\n \n     /// Counts the number of threads that are currently active\n     /// if the number of active threads reduces to 1 and then\n-    /// a join operation occures with the remaining main thread\n+    /// a join operation occurs with the remaining main thread\n     /// then multi-threaded execution may be disabled.\n     active_thread_count: Cell<usize>,\n \n@@ -1160,7 +1157,7 @@ impl GlobalState {\n     }\n \n     /// Hook on a thread join to update the implicit happens-before relation\n-    /// between the joined thead and the current thread.\n+    /// between the joined thread and the current thread.\n     #[inline]\n     pub fn thread_joined(&self, current_thread: ThreadId, join_thread: ThreadId) {\n         let mut clocks_vec = self.vector_clocks.borrow_mut();\n@@ -1194,7 +1191,7 @@ impl GlobalState {\n                 .iter_enumerated()\n                 .all(|(idx, clocks)| clocks.clock[idx] <= current_clock.clock[idx])\n             {\n-                // The all thread termations happen-before the current clock\n+                // All thread terminations happen-before the current clock\n                 // therefore no data-races can be reported until a new thread\n                 // is created, so disable multi-threaded execution.\n                 self.multi_threaded.set(false);\n@@ -1213,7 +1210,7 @@ impl GlobalState {\n     /// On thread termination, the vector-clock may re-used\n     /// in the future once all remaining thread-clocks catch\n     /// up with the time index of the terminated thread.\n-    /// This assiges thread termination with a unique index\n+    /// This assigns thread termination with a unique index\n     /// which will be used to join the thread\n     /// This should be called strictly before any calls to\n     /// `thread_joined`.\n@@ -1318,8 +1315,8 @@ impl GlobalState {\n     /// Release a lock handle, express that this happens-before\n     /// any subsequent calls to `validate_lock_acquire`.\n     /// For normal locks this should be equivalent to `validate_lock_release_shared`\n-    /// since an acquire operation should have occured before, however\n-    /// for futex & cond-var operations this is not the case and this\n+    /// since an acquire operation should have occurred before, however\n+    /// for futex & condvar operations this is not the case and this\n     /// operation must be used.\n     pub fn validate_lock_release(&self, lock: &mut VClock, thread: ThreadId) {\n         let (index, mut clocks) = self.load_thread_state_mut(thread);"}, {"sha": "581da0976e512fe096b9c206c9cdd4a3c464edd6", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "patch": "@@ -81,7 +81,7 @@ pub use crate::sync::{\n     EvalContextExt as SyncEvalContextExt, CondvarId, MutexId, RwLockId\n };\n pub use crate::vector_clock::{\n-    VClock, VSmallClockMap, VectorIdx, VTimestamp\n+    VClock, VectorIdx, VTimestamp\n };\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be"}, {"sha": "1ce6511ee4aebf5acc97da7985c4b7431c26c4b5", "filename": "src/vector_clock.rs", "status": "modified", "additions": 2, "deletions": 187, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/src%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/src%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvector_clock.rs?ref=a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "patch": "@@ -1,11 +1,9 @@\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n use smallvec::SmallVec;\n use std::{\n     cmp::Ordering,\n     convert::TryFrom,\n-    fmt::{self, Debug},\n-    mem,\n+    fmt::Debug,\n     ops::Index,\n };\n \n@@ -43,160 +41,6 @@ impl From<u32> for VectorIdx {\n     }\n }\n \n-/// A sparse mapping of vector index values to vector clocks, this\n-/// is optimized for the common case with only one element stored\n-/// inside the map.\n-/// This is used to store the set of currently active release\n-/// sequences at a given memory location, since RMW operations\n-/// allow for multiple release sequences to be active at once\n-/// and to be collapsed back to one active release sequence\n-/// once a non RMW atomic store operation occurs.\n-/// An all zero vector is considered to be equal to no\n-/// element stored internally since it will never be\n-/// stored and has no meaning as a release sequence\n-/// vector clock.\n-#[derive(Clone)]\n-pub struct VSmallClockMap(VSmallClockMapInner);\n-\n-#[derive(Clone)]\n-enum VSmallClockMapInner {\n-    /// Zero or 1 vector elements, common\n-    /// case for the sparse set.\n-    /// The all zero vector clock is treated\n-    /// as equal to the empty element.\n-    Small(VectorIdx, VClock),\n-\n-    /// Hash-map of vector clocks.\n-    Large(FxHashMap<VectorIdx, VClock>),\n-}\n-\n-impl VSmallClockMap {\n-    /// Remove all clock vectors from the map, setting them\n-    /// to the zero vector.\n-    pub fn clear(&mut self) {\n-        match &mut self.0 {\n-            VSmallClockMapInner::Small(_, clock) => clock.set_zero_vector(),\n-            VSmallClockMapInner::Large(hash_map) => {\n-                hash_map.clear();\n-            }\n-        }\n-    }\n-\n-    /// Remove all clock vectors except for the clock vector\n-    /// stored at the given index, which is retained.\n-    pub fn retain_index(&mut self, index: VectorIdx) {\n-        match &mut self.0 {\n-            VSmallClockMapInner::Small(small_idx, clock) => {\n-                if index != *small_idx {\n-                    // The zero-vector is considered to equal\n-                    // the empty element.\n-                    clock.set_zero_vector()\n-                }\n-            }\n-            VSmallClockMapInner::Large(hash_map) => {\n-                let value = hash_map.remove(&index).unwrap_or_default();\n-                self.0 = VSmallClockMapInner::Small(index, value);\n-            }\n-        }\n-    }\n-\n-    /// Insert the vector clock into the associated vector\n-    /// index.\n-    pub fn insert(&mut self, index: VectorIdx, clock: &VClock) {\n-        match &mut self.0 {\n-            VSmallClockMapInner::Small(small_idx, small_clock) => {\n-                if small_clock.is_zero_vector() {\n-                    *small_idx = index;\n-                    small_clock.clone_from(clock);\n-                } else if !clock.is_zero_vector() {\n-                    // Convert to using the hash-map representation.\n-                    let mut hash_map = FxHashMap::default();\n-                    hash_map.insert(*small_idx, mem::take(small_clock));\n-                    hash_map.insert(index, clock.clone());\n-                    self.0 = VSmallClockMapInner::Large(hash_map);\n-                }\n-            }\n-            VSmallClockMapInner::Large(hash_map) =>\n-                if !clock.is_zero_vector() {\n-                    hash_map.insert(index, clock.clone());\n-                },\n-        }\n-    }\n-\n-    /// Try to load the vector clock associated with the current\n-    ///  vector index.\n-    pub fn get(&self, index: VectorIdx) -> Option<&VClock> {\n-        match &self.0 {\n-            VSmallClockMapInner::Small(small_idx, small_clock) => {\n-                if *small_idx == index && !small_clock.is_zero_vector() {\n-                    Some(small_clock)\n-                } else {\n-                    None\n-                }\n-            }\n-            VSmallClockMapInner::Large(hash_map) => hash_map.get(&index),\n-        }\n-    }\n-}\n-\n-impl Default for VSmallClockMap {\n-    #[inline]\n-    fn default() -> Self {\n-        VSmallClockMap(VSmallClockMapInner::Small(VectorIdx::new(0), VClock::default()))\n-    }\n-}\n-\n-impl Debug for VSmallClockMap {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Print the contents of the small vector clock set as the map\n-        // of vector index to vector clock that they represent.\n-        let mut map = f.debug_map();\n-        match &self.0 {\n-            VSmallClockMapInner::Small(small_idx, small_clock) =>\n-                if !small_clock.is_zero_vector() {\n-                    map.entry(&small_idx, &small_clock);\n-                },\n-            VSmallClockMapInner::Large(hash_map) =>\n-                for (idx, elem) in hash_map.iter() {\n-                    map.entry(idx, elem);\n-                },\n-        }\n-        map.finish()\n-    }\n-}\n-\n-impl PartialEq for VSmallClockMap {\n-    fn eq(&self, other: &Self) -> bool {\n-        use VSmallClockMapInner::*;\n-        match (&self.0, &other.0) {\n-            (Small(i1, c1), Small(i2, c2)) => {\n-                if c1.is_zero_vector() {\n-                    // Either they are both zero or they are non-equal\n-                    c2.is_zero_vector()\n-                } else {\n-                    // At least one is non-zero, so the full comparison is correct\n-                    i1 == i2 && c1 == c2\n-                }\n-            }\n-            (Small(idx, clock), Large(hash_map)) | (Large(hash_map), Small(idx, clock)) => {\n-                if hash_map.len() == 0 {\n-                    // Equal to the empty hash-map\n-                    clock.is_zero_vector()\n-                } else if hash_map.len() == 1 {\n-                    // Equal to the hash-map with one element\n-                    let (hash_idx, hash_clock) = hash_map.iter().next().unwrap();\n-                    hash_idx == idx && hash_clock == clock\n-                } else {\n-                    false\n-                }\n-            }\n-            (Large(map1), Large(map2)) => map1 == map2,\n-        }\n-    }\n-}\n-\n-impl Eq for VSmallClockMap {}\n-\n /// The size of the vector-clock to store inline\n /// clock vectors larger than this will be stored on the heap\n const SMALL_VECTOR: usize = 4;\n@@ -484,7 +328,7 @@ impl Index<VectorIdx> for VClock {\n #[cfg(test)]\n mod tests {\n \n-    use super::{VClock, VSmallClockMap, VTimestamp, VectorIdx};\n+    use super::{VClock, VTimestamp, VectorIdx};\n     use std::cmp::Ordering;\n \n     #[test]\n@@ -628,33 +472,4 @@ mod tests {\n             r\n         );\n     }\n-\n-    #[test]\n-    pub fn test_vclock_set() {\n-        let mut map = VSmallClockMap::default();\n-        let v1 = from_slice(&[3, 0, 1]);\n-        let v2 = from_slice(&[4, 2, 3]);\n-        let v3 = from_slice(&[4, 8, 3]);\n-        map.insert(VectorIdx(0), &v1);\n-        assert_eq!(map.get(VectorIdx(0)), Some(&v1));\n-        map.insert(VectorIdx(5), &v2);\n-        assert_eq!(map.get(VectorIdx(0)), Some(&v1));\n-        assert_eq!(map.get(VectorIdx(5)), Some(&v2));\n-        map.insert(VectorIdx(53), &v3);\n-        assert_eq!(map.get(VectorIdx(0)), Some(&v1));\n-        assert_eq!(map.get(VectorIdx(5)), Some(&v2));\n-        assert_eq!(map.get(VectorIdx(53)), Some(&v3));\n-        map.retain_index(VectorIdx(53));\n-        assert_eq!(map.get(VectorIdx(0)), None);\n-        assert_eq!(map.get(VectorIdx(5)), None);\n-        assert_eq!(map.get(VectorIdx(53)), Some(&v3));\n-        map.clear();\n-        assert_eq!(map.get(VectorIdx(0)), None);\n-        assert_eq!(map.get(VectorIdx(5)), None);\n-        assert_eq!(map.get(VectorIdx(53)), None);\n-        map.insert(VectorIdx(53), &v3);\n-        assert_eq!(map.get(VectorIdx(0)), None);\n-        assert_eq!(map.get(VectorIdx(5)), None);\n-        assert_eq!(map.get(VectorIdx(53)), Some(&v3));\n-    }\n }"}, {"sha": "d64b80dbd84c6effc1e1fc2fdae4968a536d397f", "filename": "tests/compile-fail/data_race/release_seq_race_same_thread.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "patch": "@@ -0,0 +1,50 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::spawn;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+static SYNC: AtomicUsize = AtomicUsize::new(0);\n+\n+pub fn main() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, the sleep operations currently\n+    // force the desired ordering:\n+    //  1. store release : 1\n+    //  2. store relaxed : 2\n+    //  3. load acquire : 2\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0 = 1;\n+            SYNC.store(1, Ordering::Release);\n+\n+            // C++20 update to release sequences\n+            // makes this block the release sequence\n+            // despite the being on the same thread\n+            // as the release store.\n+            SYNC.store(2, Ordering::Relaxed);\n+        });\n+\n+        let j2 = spawn(move || {\n+            if SYNC.load(Ordering::Acquire) == 2 {\n+                *c.0 //~ ERROR Data race\n+            } else {\n+                0\n+            }\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "b53acc2691ff61d57ade2ff53c64ea49f4165ba7", "filename": "tests/run-pass/concurrency/data_race.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/tests%2Frun-pass%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fa80d277e81a1888513b5e5c0f1eee1cb6250b/tests%2Frun-pass%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fdata_race.rs?ref=a2fa80d277e81a1888513b5e5c0f1eee1cb6250b", "patch": "@@ -89,7 +89,7 @@ pub fn test_rmw_no_block() {\n     }\n }\n \n-pub fn test_release_no_block() {\n+pub fn test_simple_release() {\n     let mut a = 0u32;\n     let b = &mut a as *mut u32;\n     let c = EvilSend(b);\n@@ -98,11 +98,10 @@ pub fn test_release_no_block() {\n         let j1 = spawn(move || {\n             *c.0 = 1;\n             SYNC.store(1, Ordering::Release);\n-            SYNC.store(3, Ordering::Relaxed);\n         });\n \n         let j2 = spawn(move || {\n-            if SYNC.load(Ordering::Acquire) == 3 {\n+            if SYNC.load(Ordering::Acquire) == 1 {\n                 *c.0\n             } else {\n                 0\n@@ -118,5 +117,5 @@ pub fn main() {\n     test_fence_sync();\n     test_multiple_reads();\n     test_rmw_no_block();\n-    test_release_no_block();\n+    test_simple_release();\n }"}]}