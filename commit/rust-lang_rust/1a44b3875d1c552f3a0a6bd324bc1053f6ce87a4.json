{"sha": "1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNDRiMzg3NWQxYzU1MmYzYTBhNmJkMzI0YmMxMDUzZjZjZTg3YTQ=", "commit": {"author": {"name": "John Gallagher", "email": "jgallagher@bignerdranch.com", "date": "2015-04-08T03:25:33Z"}, "committer": {"name": "John Gallagher", "email": "jgallagher@bignerdranch.com", "date": "2015-04-08T12:53:48Z"}, "message": "Add Homogenous Aggregates for AArch64 codegen\n\nCloses #24154", "tree": {"sha": "1fb818861ba62d6912e570c7f3ee12fddaf4b9b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fb818861ba62d6912e570c7f3ee12fddaf4b9b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4", "html_url": "https://github.com/rust-lang/rust/commit/1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4/comments", "author": {"login": "hydhknn", "id": 62813007, "node_id": "MDQ6VXNlcjYyODEzMDA3", "avatar_url": "https://avatars.githubusercontent.com/u/62813007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hydhknn", "html_url": "https://github.com/hydhknn", "followers_url": "https://api.github.com/users/hydhknn/followers", "following_url": "https://api.github.com/users/hydhknn/following{/other_user}", "gists_url": "https://api.github.com/users/hydhknn/gists{/gist_id}", "starred_url": "https://api.github.com/users/hydhknn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hydhknn/subscriptions", "organizations_url": "https://api.github.com/users/hydhknn/orgs", "repos_url": "https://api.github.com/users/hydhknn/repos", "events_url": "https://api.github.com/users/hydhknn/events{/privacy}", "received_events_url": "https://api.github.com/users/hydhknn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hydhknn", "id": 62813007, "node_id": "MDQ6VXNlcjYyODEzMDA3", "avatar_url": "https://avatars.githubusercontent.com/u/62813007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hydhknn", "html_url": "https://github.com/hydhknn", "followers_url": "https://api.github.com/users/hydhknn/followers", "following_url": "https://api.github.com/users/hydhknn/following{/other_user}", "gists_url": "https://api.github.com/users/hydhknn/gists{/gist_id}", "starred_url": "https://api.github.com/users/hydhknn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hydhknn/subscriptions", "organizations_url": "https://api.github.com/users/hydhknn/orgs", "repos_url": "https://api.github.com/users/hydhknn/repos", "events_url": "https://api.github.com/users/hydhknn/events{/privacy}", "received_events_url": "https://api.github.com/users/hydhknn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "html_url": "https://github.com/rust-lang/rust/commit/d9146bf8ba0bdf98a46c4656899e54802e96ac0c"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "57dd22233882867a4b32f54aae8c2ee8da8be398", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4", "patch": "@@ -86,11 +86,91 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n+fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n+    fn check_array(ty: Type) -> Option<(Type, u64)> {\n+        let len = ty.array_length() as u64;\n+        if len == 0 {\n+            return None\n+        }\n+        let elt = ty.element_type();\n+\n+        // if our element is an HFA/HVA, so are we; multiply members by our len\n+        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n+    }\n+\n+    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n+        let str_tys = ty.field_types();\n+        if str_tys.len() == 0 {\n+            return None\n+        }\n+\n+        let mut prev_base_ty = None;\n+        let mut members = 0;\n+        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n+            match (prev_base_ty, opt_homog_agg) {\n+                // field isn't itself an HFA, so we aren't either\n+                (_, None) => return None,\n+\n+                // first field - store its type and number of members\n+                (None, Some((field_ty, field_members))) => {\n+                    prev_base_ty = Some(field_ty);\n+                    members = field_members;\n+                },\n+\n+                // 2nd or later field - give up if it's a different type; otherwise incr. members\n+                (Some(prev_ty), Some((field_ty, field_members))) => {\n+                    if prev_ty != field_ty {\n+                        return None;\n+                    }\n+                    members += field_members;\n+                }\n+            }\n+        }\n+\n+        // Because of previous checks, we know prev_base_ty is Some(...) because\n+        //   1. str_tys has at least one element; and\n+        //   2. prev_base_ty was filled in (or we would've returned early)\n+        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n+\n+        // Ensure there is no padding.\n+        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n+            Some((base_ty, members))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    let homog_agg = match ty.kind() {\n+        Float  => Some((ty, 1)),\n+        Double => Some((ty, 1)),\n+        Array  => check_array(ty),\n+        Struct => check_struct(ty),\n+        Vector => match ty_size(ty) {\n+            4|8 => Some((ty, 1)),\n+            _   => None\n+        },\n+        _ => None\n+    };\n+\n+    // Ensure we have at most four uniquely addressable members\n+    homog_agg.and_then(|(base_ty, members)| {\n+        if members > 0 && members <= 4 {\n+            Some((base_ty, members))\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n         let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n+        let llty = Type::array(&base_ty, members);\n+        return ArgType::direct(ty, Some(llty), None, None);\n+    }\n     let size = ty_size(ty);\n     if size <= 16 {\n         let llty = if size <= 1 {\n@@ -114,6 +194,10 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n+        let llty = Type::array(&base_ty, members);\n+        return ArgType::direct(ty, Some(llty), None, None);\n+    }\n     let size = ty_size(ty);\n     if size <= 16 {\n         let llty = if size == 0 {"}]}