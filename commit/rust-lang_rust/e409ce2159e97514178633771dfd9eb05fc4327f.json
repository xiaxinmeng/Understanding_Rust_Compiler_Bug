{"sha": "e409ce2159e97514178633771dfd9eb05fc4327f", "node_id": "C_kwDOAAsO6NoAKGU0MDljZTIxNTllOTc1MTQxNzg2MzM3NzFkZmQ5ZWIwNWZjNDMyN2Y", "commit": {"author": {"name": "beetrees", "email": "b@beetr.ee", "date": "2022-09-29T17:50:10Z"}, "committer": {"name": "beetrees", "email": "b@beetr.ee", "date": "2022-09-29T22:06:22Z"}, "message": "Fix integer overflow in `format!(\"{:.0?}\", Duration::MAX)`", "tree": {"sha": "0aa0786e1e85d6e956ada887ecae559e5f82bcf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aa0786e1e85d6e956ada887ecae559e5f82bcf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e409ce2159e97514178633771dfd9eb05fc4327f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQT9oej+Slbzs/bk2IuHkb11QZHr1gUCYzYW3gAKCRCHkb11QZHr\n1jymAQDhgS1+jo36xZPaoScFOJyh6j4JsaaUBVEOBm6RBs6gMQEA48iE28elTt9K\ndFRFajSitltkNlwINtTIdpbFPfYOgQs=\n=hWbc\n-----END PGP SIGNATURE-----", "payload": "tree 0aa0786e1e85d6e956ada887ecae559e5f82bcf1\nparent 65445a571c11f07f4ca1ed0f63bad247ae295bd0\nauthor beetrees <b@beetr.ee> 1664473810 +0100\ncommitter beetrees <b@beetr.ee> 1664489182 +0100\n\nFix integer overflow in `format!(\"{:.0?}\", Duration::MAX)`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e409ce2159e97514178633771dfd9eb05fc4327f", "html_url": "https://github.com/rust-lang/rust/commit/e409ce2159e97514178633771dfd9eb05fc4327f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e409ce2159e97514178633771dfd9eb05fc4327f/comments", "author": {"login": "beetrees", "id": 107947675, "node_id": "U_kgDOBm8mmw", "avatar_url": "https://avatars.githubusercontent.com/u/107947675?v=4", "gravatar_id": "", "url": "https://api.github.com/users/beetrees", "html_url": "https://github.com/beetrees", "followers_url": "https://api.github.com/users/beetrees/followers", "following_url": "https://api.github.com/users/beetrees/following{/other_user}", "gists_url": "https://api.github.com/users/beetrees/gists{/gist_id}", "starred_url": "https://api.github.com/users/beetrees/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/beetrees/subscriptions", "organizations_url": "https://api.github.com/users/beetrees/orgs", "repos_url": "https://api.github.com/users/beetrees/repos", "events_url": "https://api.github.com/users/beetrees/events{/privacy}", "received_events_url": "https://api.github.com/users/beetrees/received_events", "type": "User", "site_admin": false}, "committer": {"login": "beetrees", "id": 107947675, "node_id": "U_kgDOBm8mmw", "avatar_url": "https://avatars.githubusercontent.com/u/107947675?v=4", "gravatar_id": "", "url": "https://api.github.com/users/beetrees", "html_url": "https://github.com/beetrees", "followers_url": "https://api.github.com/users/beetrees/followers", "following_url": "https://api.github.com/users/beetrees/following{/other_user}", "gists_url": "https://api.github.com/users/beetrees/gists{/gist_id}", "starred_url": "https://api.github.com/users/beetrees/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/beetrees/subscriptions", "organizations_url": "https://api.github.com/users/beetrees/orgs", "repos_url": "https://api.github.com/users/beetrees/repos", "events_url": "https://api.github.com/users/beetrees/events{/privacy}", "received_events_url": "https://api.github.com/users/beetrees/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65445a571c11f07f4ca1ed0f63bad247ae295bd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/65445a571c11f07f4ca1ed0f63bad247ae295bd0", "html_url": "https://github.com/rust-lang/rust/commit/65445a571c11f07f4ca1ed0f63bad247ae295bd0"}], "stats": {"total": 63, "additions": 52, "deletions": 11}, "files": [{"sha": "1d0c51c3c8368fb69b4fd22127945a155dc11015", "filename": "library/core/src/time.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e409ce2159e97514178633771dfd9eb05fc4327f/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e409ce2159e97514178633771dfd9eb05fc4327f/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=e409ce2159e97514178633771dfd9eb05fc4327f", "patch": "@@ -1043,7 +1043,7 @@ impl fmt::Debug for Duration {\n         /// to the formatter's `width`, if specified.\n         fn fmt_decimal(\n             f: &mut fmt::Formatter<'_>,\n-            mut integer_part: u64,\n+            integer_part: u64,\n             mut fractional_part: u32,\n             mut divisor: u32,\n             prefix: &str,\n@@ -1075,7 +1075,7 @@ impl fmt::Debug for Duration {\n             // normal floating point numbers. However, we only need to do work\n             // when rounding up. This happens if the first digit of the\n             // remaining ones is >= 5.\n-            if fractional_part > 0 && fractional_part >= divisor * 5 {\n+            let integer_part = if fractional_part > 0 && fractional_part >= divisor * 5 {\n                 // Round up the number contained in the buffer. We go through\n                 // the buffer backwards and keep track of the carry.\n                 let mut rev_pos = pos;\n@@ -1099,9 +1099,18 @@ impl fmt::Debug for Duration {\n                 // the whole buffer to '0's and need to increment the integer\n                 // part.\n                 if carry {\n-                    integer_part += 1;\n+                    // If `integer_part == u64::MAX` and precision < 9, any\n+                    // carry of the overflow during rounding of the\n+                    // `fractional_part` into the `integer_part` will cause the\n+                    // `integer_part` itself to overflow. Avoid this by using an\n+                    // `Option<u64>`, with `None` representing `u64::MAX + 1`.\n+                    integer_part.checked_add(1)\n+                } else {\n+                    Some(integer_part)\n                 }\n-            }\n+            } else {\n+                Some(integer_part)\n+            };\n \n             // Determine the end of the buffer: if precision is set, we just\n             // use as many digits from the buffer (capped to 9). If it isn't\n@@ -1111,7 +1120,12 @@ impl fmt::Debug for Duration {\n             // This closure emits the formatted duration without emitting any\n             // padding (padding is calculated below).\n             let emit_without_padding = |f: &mut fmt::Formatter<'_>| {\n-                write!(f, \"{}{}\", prefix, integer_part)?;\n+                if let Some(integer_part) = integer_part {\n+                    write!(f, \"{}{}\", prefix, integer_part)?;\n+                } else {\n+                    // u64::MAX + 1 == 18446744073709551616\n+                    write!(f, \"{}18446744073709551616\", prefix)?;\n+                }\n \n                 // Write the decimal point and the fractional part (if any).\n                 if end > 0 {\n@@ -1141,12 +1155,17 @@ impl fmt::Debug for Duration {\n                     // 2. The postfix: can be \"\u00b5s\" so we have to count UTF8 characters.\n                     let mut actual_w = prefix.len() + postfix.chars().count();\n                     // 3. The integer part:\n-                    if let Some(log) = integer_part.checked_ilog10() {\n-                        // integer_part is > 0, so has length log10(x)+1\n-                        actual_w += 1 + log as usize;\n+                    if let Some(integer_part) = integer_part {\n+                        if let Some(log) = integer_part.checked_ilog10() {\n+                            // integer_part is > 0, so has length log10(x)+1\n+                            actual_w += 1 + log as usize;\n+                        } else {\n+                            // integer_part is 0, so has length 1.\n+                            actual_w += 1;\n+                        }\n                     } else {\n-                        // integer_part is 0, so has length 1.\n-                        actual_w += 1;\n+                        // integer_part is u64::MAX + 1, so has length 20\n+                        actual_w += 20;\n                     }\n                     // 4. The fractional part (if any):\n                     if end > 0 {"}, {"sha": "697bf33a8b0daeba0ac2177b9e7a8185bbc16ea1", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e409ce2159e97514178633771dfd9eb05fc4327f/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e409ce2159e97514178633771dfd9eb05fc4327f/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=e409ce2159e97514178633771dfd9eb05fc4327f", "patch": "@@ -197,9 +197,31 @@ fn correct_sum() {\n #[test]\n fn debug_formatting_extreme_values() {\n     assert_eq!(\n-        format!(\"{:?}\", Duration::new(18_446_744_073_709_551_615, 123_456_789)),\n+        format!(\"{:?}\", Duration::new(u64::MAX, 123_456_789)),\n         \"18446744073709551615.123456789s\"\n     );\n+    assert_eq!(format!(\"{:.0?}\", Duration::MAX), \"18446744073709551616s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(u64::MAX, 500_000_000)), \"18446744073709551616s\");\n+    assert_eq!(format!(\"{:.0?}\", Duration::new(u64::MAX, 499_999_999)), \"18446744073709551615s\");\n+    assert_eq!(\n+        format!(\"{:.3?}\", Duration::new(u64::MAX, 999_500_000)),\n+        \"18446744073709551616.000s\"\n+    );\n+    assert_eq!(\n+        format!(\"{:.3?}\", Duration::new(u64::MAX, 999_499_999)),\n+        \"18446744073709551615.999s\"\n+    );\n+    assert_eq!(\n+        format!(\"{:.8?}\", Duration::new(u64::MAX, 999_999_995)),\n+        \"18446744073709551616.00000000s\"\n+    );\n+    assert_eq!(\n+        format!(\"{:.8?}\", Duration::new(u64::MAX, 999_999_994)),\n+        \"18446744073709551615.99999999s\"\n+    );\n+    assert_eq!(format!(\"{:21.0?}\", Duration::MAX), \"18446744073709551616s\");\n+    assert_eq!(format!(\"{:22.0?}\", Duration::MAX), \"18446744073709551616s \");\n+    assert_eq!(format!(\"{:24.0?}\", Duration::MAX), \"18446744073709551616s   \");\n }\n \n #[test]"}]}