{"sha": "8f65e25aec6d42e049346aae52f8fec2fa508c38", "node_id": "C_kwDOAAsO6NoAKDhmNjVlMjVhZWM2ZDQyZTA0OTM0NmFhZTUyZjhmZWMyZmE1MDhjMzg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-15T20:30:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-15T20:30:56Z"}, "message": "Rollup merge of #108010 - compiler-errors:can_eq-returns-bool, r=lcnr\n\nMake `InferCtxt::can_eq` and `InferCtxt::can_sub` return booleans\n\nNobody matches on the result, nor does the result return anything useful...", "tree": {"sha": "008842d751188bfae1dbf787236e09bc786f828d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/008842d751188bfae1dbf787236e09bc786f828d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f65e25aec6d42e049346aae52f8fec2fa508c38", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj7UEACRBK7hj4Ov3rIwAAGo0IAIjkKadAwwsUHr4geYfWWgZM\nITs6Bl12DQIaNZDBUVksgjuQZrfSNfrcjDXWmIJN3T1NIA9jjgrZChE97dfsNQ5E\nNn2KFo2Whcm/bhtNEonMnqIZIA/yeP8jzOxRfnozeZIzeFcYjNvQ4jBJzUAqQ9BD\n8VhhvRB59xNDdE6EdtqGWGVQulNqlqTSVQADpfPtQd/WlQawTz3k7kMM0Oy244SF\nRpCDletDrR8/JuHGYH0lO3Pcvic0X+4GsPM+/fmHxzsGrpSSFM/erC7RWHxmo2gN\nbG6ZQXp0H0vksZrD1RO2kpmtlcXwJrGiXl9MBn+8gTtViel1J+s2MKLCNJzn5jQ=\n=n+nz\n-----END PGP SIGNATURE-----\n", "payload": "tree 008842d751188bfae1dbf787236e09bc786f828d\nparent d40c13ae02900e7bdef494d0212eb99335b7616c\nparent eb286dd07082b35be7532984054204a3d9fd5617\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676493056 +0100\ncommitter GitHub <noreply@github.com> 1676493056 +0100\n\nRollup merge of #108010 - compiler-errors:can_eq-returns-bool, r=lcnr\n\nMake `InferCtxt::can_eq` and `InferCtxt::can_sub` return booleans\n\nNobody matches on the result, nor does the result return anything useful...\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f65e25aec6d42e049346aae52f8fec2fa508c38", "html_url": "https://github.com/rust-lang/rust/commit/8f65e25aec6d42e049346aae52f8fec2fa508c38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f65e25aec6d42e049346aae52f8fec2fa508c38/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d40c13ae02900e7bdef494d0212eb99335b7616c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d40c13ae02900e7bdef494d0212eb99335b7616c", "html_url": "https://github.com/rust-lang/rust/commit/d40c13ae02900e7bdef494d0212eb99335b7616c"}, {"sha": "eb286dd07082b35be7532984054204a3d9fd5617", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb286dd07082b35be7532984054204a3d9fd5617", "html_url": "https://github.com/rust-lang/rust/commit/eb286dd07082b35be7532984054204a3d9fd5617"}], "stats": {"total": 76, "additions": 33, "deletions": 43}, "files": [{"sha": "c4e4e0517ece3f73a0c1bf0f1a1c4334ea2499e9", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -1144,7 +1144,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 LateBoundRegionConversionTime::FnCall,\n                                 tcx.fn_sig(method_did).subst(tcx, method_substs).input(0),\n                             )\n-                            && infcx.can_eq(self.param_env, ty, self_ty).is_ok()\n+                            && infcx.can_eq(self.param_env, ty, self_ty)\n                         {\n                             err.span_suggestion_verbose(\n                                 fn_call_span.shrink_to_lo(),"}, {"sha": "0a243b47b5c71e81bc7b6ff72c90661f64baeb51", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -2232,7 +2232,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                         tcx.erase_regions(impl_.self_ty()),\n                                         tcx.erase_regions(qself_ty),\n                                     )\n-                                    .is_ok()\n                             })\n                             && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n                         })"}, {"sha": "6b0eade2d32666b726a461f1afa1995727de4966", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -1106,7 +1106,7 @@ fn compare_self_type<'tcx>(\n \n         let infcx = tcx.infer_ctxt().build();\n         let self_arg_ty = tcx.liberate_late_bound_regions(method.def_id, self_arg_ty);\n-        let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n+        let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty);\n         match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n             ExplicitSelf::ByValue => \"self\".to_owned(),\n             ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),"}, {"sha": "c64d507f82848772c1bf8480a5d5b9c8cabe3e86", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -1716,7 +1716,7 @@ fn receiver_is_valid<'tcx>(\n     let cause =\n         ObligationCause::new(span, wfcx.body_def_id, traits::ObligationCauseCode::MethodReceiver);\n \n-    let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty).is_ok();\n+    let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty);\n \n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {"}, {"sha": "149c7dbef22f5d0dbdb8cac7024abb7495b02fa9", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut param_args = FxHashMap::default();\n                 let mut param_expected = FxHashMap::default();\n                 let mut param_found = FxHashMap::default();\n-                if self.can_eq(self.param_env, ty, found).is_ok() {\n+                if self.can_eq(self.param_env, ty, found) {\n                     // We only point at the first place where the found type was inferred.\n                     for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n                         if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 for (param, (arg, arg_ty)) in param_args.iter() {\n                     let Some(expected) = param_expected.get(param) else { continue; };\n                     let Some(found) = param_found.get(param) else { continue; };\n-                    if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n+                    if !self.can_eq(self.param_env, *arg_ty, *found) { continue; }\n                     self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n                 }\n \n@@ -379,7 +379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if ty != prev\n                     && param_args.is_empty()\n-                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                    && self.can_eq(self.param_env, ty, found)\n                 {\n                     // We only point at the first place where the found type was inferred.\n                     if !segment.ident.span.overlaps(mismatch_span) {\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if ty != prev\n                     && let Some(span) = prev_span\n-                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                    && self.can_eq(self.param_env, ty, found)\n                 {\n                     // We only point at the first place where the found type was inferred.\n                     // We use the *previous* span because if the type is known *here* it means\n@@ -764,7 +764,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let ty::Adt(expected_adt, substs) = expected.kind() {\n             if let hir::ExprKind::Field(base, ident) = expr.kind {\n                 let base_ty = self.typeck_results.borrow().expr_ty(base);\n-                if self.can_eq(self.param_env, base_ty, expected).is_ok()\n+                if self.can_eq(self.param_env, base_ty, expected)\n                     && let Some(base_span) = base.span.find_ancestor_inside(expr.span)\n                 {\n                     err.span_suggestion_verbose(\n@@ -1357,7 +1357,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n                 _,\n                 &ty::Ref(_, checked, _),\n-            ) if self.can_sub(self.param_env, checked, expected).is_ok() => {\n+            ) if self.can_sub(self.param_env, checked, expected) => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n@@ -2003,7 +2003,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         let hir::StmtKind::Semi(tail_expr) = stmt.kind else { return; };\n         let Some(ty) = self.node_ty_opt(tail_expr.hir_id) else { return; };\n-        if self.can_eq(self.param_env, expected_ty, ty).is_ok() {\n+        if self.can_eq(self.param_env, expected_ty, ty) {\n             err.span_suggestion_short(\n                 stmt.span.with_lo(tail_expr.span.hi()),\n                 \"remove this semicolon\","}, {"sha": "7ce721e94cb238d938403bac1b78e48404051f31", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -1015,7 +1015,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let expr_inner_ty = substs.type_at(0);\n             let expected_inner_ty = expected_substs.type_at(0);\n             if let ty::Ref(_, ty, hir::Mutability::Not) = expr_inner_ty.kind()\n-                && self.can_eq(self.param_env, *ty, expected_inner_ty).is_ok()\n+                && self.can_eq(self.param_env, *ty, expected_inner_ty)\n             {\n                 let def_path = self.tcx.def_path_str(adt_def.did());\n                 if self.type_is_copy_modulo_regions(self.param_env, *ty, expr.span) {\n@@ -1054,7 +1054,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(result_did) = self.tcx.get_diagnostic_item(sym::Result)\n             && adt_def.did() == result_did\n             // Check that the error types are equal\n-            && self.can_eq(self.param_env, substs.type_at(1), expected_substs.type_at(1)).is_ok()\n+            && self.can_eq(self.param_env, substs.type_at(1), expected_substs.type_at(1))\n         {\n             return suggest_copied_or_cloned();\n         } else if let Some(option_did) = self.tcx.get_diagnostic_item(sym::Option)"}, {"sha": "287a5bf0067c39f15b648a32758cdd41626bf936", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -936,7 +936,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         return false;\n                     }\n                 }\n-                self.can_sub(self.param_env, fty.output(), expected).is_ok()\n+                self.can_sub(self.param_env, fty.output(), expected)\n             }),\n             _ => false,\n         }"}, {"sha": "3881efe87db5c4030cd11920b9f73210c718db2d", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)?;\n         if let Some(expr) = ti.origin_expr {\n             self.suggest_fn_call(&mut diag, expr, expected, |output| {\n-                self.can_eq(self.param_env, output, actual).is_ok()\n+                self.can_eq(self.param_env, output, actual)\n             });\n         }\n         Some(diag)\n@@ -675,7 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         match (expected.kind(), actual.kind(), ba) {\n             (ty::Ref(_, inner_ty, _), _, hir::BindingAnnotation::NONE)\n-                if self.can_eq(self.param_env, *inner_ty, actual).is_ok() =>\n+                if self.can_eq(self.param_env, *inner_ty, actual) =>\n             {\n                 err.span_suggestion_verbose(\n                     span.shrink_to_lo(),\n@@ -685,7 +685,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n             (_, ty::Ref(_, inner_ty, _), hir::BindingAnnotation::REF)\n-                if self.can_eq(self.param_env, expected, *inner_ty).is_ok() =>\n+                if self.can_eq(self.param_env, expected, *inner_ty) =>\n             {\n                 err.span_suggestion_verbose(\n                     span.with_hi(span.lo() + BytePos(4)),"}, {"sha": "c3fe41586189a99fc84655721dfe1f1b28774f36", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -576,7 +576,7 @@ fn foo(&self) -> Self::T { String::new() }\n                                 tcx.impl_defaultness(item.id.owner_id)\n                             {\n                                 let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n-                                if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                                if self.infcx.can_eq(param_env, assoc_ty, found) {\n                                     diag.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n@@ -598,7 +598,7 @@ fn foo(&self) -> Self::T { String::new() }\n                     if let hir::AssocItemKind::Type = item.kind {\n                         let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n \n-                        if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                        if self.infcx.can_eq(param_env, assoc_ty, found) {\n                             diag.span_label(item.span, \"expected this associated type\");\n                             return true;\n                         }"}, {"sha": "17e734f0700321bfd4abbaae605029566968106b", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -880,30 +880,20 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n     }\n \n-    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n+        self.probe(|_| self.at(origin, param_env).sub(a, b).is_ok())\n     }\n \n-    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n+        self.probe(|_| self.at(origin, param_env).eq(a, b).is_ok())\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "cecacfa1b3e0830dd157809d8990421b80f3bf41", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -1628,7 +1628,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n                 let param_env = ty::ParamEnv::empty();\n-                if self.can_sub(param_env, error, implication).is_ok() {\n+                if self.can_sub(param_env, error, implication) {\n                     debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n                     return true;\n                 }"}, {"sha": "39241696a34c57337dd2a20b2c7fa509c3e278d8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n             let impl_self_ty = impl_trait_ref.self_ty();\n \n-            if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n+            if self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n                 self_match_impls.push((def_id, impl_substs));\n \n                 if iter::zip("}, {"sha": "135232d1b2089da0b49b139e285ab7942379d008", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f65e25aec6d42e049346aae52f8fec2fa508c38/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=8f65e25aec6d42e049346aae52f8fec2fa508c38", "patch": "@@ -748,10 +748,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let real_ty = real_trait_pred.self_ty();\n             // We `erase_late_bound_regions` here because `make_subregion` does not handle\n             // `ReLateBound`, and we don't particularly care about the regions.\n-            if self\n-                .can_eq(obligation.param_env, self.tcx.erase_late_bound_regions(real_ty), arg_ty)\n-                .is_err()\n-            {\n+            if !self.can_eq(\n+                obligation.param_env,\n+                self.tcx.erase_late_bound_regions(real_ty),\n+                arg_ty,\n+            ) {\n                 continue;\n             }\n \n@@ -3690,7 +3691,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     let Some((span, (assoc, ty))) = entry else { continue; };\n                     if primary_spans.is_empty() || type_diffs.iter().any(|diff| {\n                         let Sorts(expected_found) = diff else { return false; };\n-                        self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                        self.can_eq(param_env, expected_found.found, ty)\n                     }) {\n                         // FIXME: this doesn't quite work for `Iterator::collect`\n                         // because we have `Vec<i32>` and `()`, but we'd want `i32`\n@@ -3717,10 +3718,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(ty));\n \n                         let assoc = with_forced_trimmed_paths!(self.tcx.def_path_str(assoc));\n-                        if self.can_eq(param_env, ty, *prev_ty).is_err() {\n+                        if !self.can_eq(param_env, ty, *prev_ty) {\n                             if type_diffs.iter().any(|diff| {\n                                 let Sorts(expected_found) = diff else { return false; };\n-                                self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                                self.can_eq(param_env, expected_found.found, ty)\n                             }) {\n                                 primary_spans.push(span);\n                             }\n@@ -3868,7 +3869,7 @@ fn hint_missing_borrow<'tcx>(\n         let (found_ty, found_refs) = get_deref_type_and_refs(*found_arg);\n         let (expected_ty, expected_refs) = get_deref_type_and_refs(*expected_arg);\n \n-        if infcx.can_eq(param_env, found_ty, expected_ty).is_ok() {\n+        if infcx.can_eq(param_env, found_ty, expected_ty) {\n             // FIXME: This could handle more exotic cases like mutability mismatches too!\n             if found_refs.len() < expected_refs.len()\n                 && found_refs[..] == expected_refs[expected_refs.len() - found_refs.len()..]"}]}