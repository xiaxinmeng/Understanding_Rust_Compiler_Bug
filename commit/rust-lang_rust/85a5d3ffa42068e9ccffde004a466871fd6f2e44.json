{"sha": "85a5d3ffa42068e9ccffde004a466871fd6f2e44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YTVkM2ZmYTQyMDY4ZTljY2ZmZGUwMDRhNDY2ODcxZmQ2ZjJlNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-23T05:10:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-23T05:10:53Z"}, "message": "Auto merge of #44784 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 14 pull requests\n\n- Successful merges: #44554, #44648, #44658, #44712, #44717, #44726, #44745, #44746, #44749, #44759, #44770, #44773, #44776, #44778\n- Failed merges:", "tree": {"sha": "5d133e5934fe4d587a75fb7c1c7a73f4913efac9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d133e5934fe4d587a75fb7c1c7a73f4913efac9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85a5d3ffa42068e9ccffde004a466871fd6f2e44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85a5d3ffa42068e9ccffde004a466871fd6f2e44", "html_url": "https://github.com/rust-lang/rust/commit/85a5d3ffa42068e9ccffde004a466871fd6f2e44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85a5d3ffa42068e9ccffde004a466871fd6f2e44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ad67e9fc34d796e73f39970f513a78f69d21819", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad67e9fc34d796e73f39970f513a78f69d21819", "html_url": "https://github.com/rust-lang/rust/commit/9ad67e9fc34d796e73f39970f513a78f69d21819"}, {"sha": "2aa42ef2336758bcae335c38c94b84377fea1f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa42ef2336758bcae335c38c94b84377fea1f60", "html_url": "https://github.com/rust-lang/rust/commit/2aa42ef2336758bcae335c38c94b84377fea1f60"}], "stats": {"total": 367, "additions": 309, "deletions": 58}, "files": [{"sha": "3834c54d6c4f72b203463d02dc7fc676ccfc613f", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -461,6 +461,7 @@ For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information\n are:\n \n+* [Rust Forge][rustforge] contains additional documentation, including write-ups of how to achieve common tasks\n * The [Rust Internals forum][rif], a place to ask questions and\n   discuss Rust's internals\n * The [generated documentation for rust's compiler][gdfrustc]\n@@ -476,6 +477,7 @@ are:\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org\n [rr]: https://doc.rust-lang.org/book/README.html\n+[rustforge]: https://forge.rust-lang.org/\n [tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n [ro]: http://www.rustaceans.org/\n [rctd]: ./src/test/COMPILER_TESTS.md"}, {"sha": "3b7dbd813cf05ddfd022861cb1fdeb52977f71de", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -72,13 +72,13 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// first: after all, isn't the point of `Arc<T>` thread safety? The key is\n /// this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n /// data, but it  doesn't add thread safety to its data. Consider\n-/// `Arc<RefCell<T>>`. `RefCell<T>` isn't [`Sync`], and if `Arc<T>` was always\n-/// [`Send`], `Arc<RefCell<T>>` would be as well. But then we'd have a problem:\n-/// `RefCell<T>` is not thread safe; it keeps track of the borrowing count using\n+/// `Arc<`[`RefCell<T>`]`>`. [`RefCell<T>`] isn't [`Sync`], and if `Arc<T>` was always\n+/// [`Send`], `Arc<`[`RefCell<T>`]`>` would be as well. But then we'd have a problem:\n+/// [`RefCell<T>`] is not thread safe; it keeps track of the borrowing count using\n /// non-atomic operations.\n ///\n /// In the end, this means that you may need to pair `Arc<T>` with some sort of\n-/// `std::sync` type, usually `Mutex<T>`.\n+/// [`std::sync`] type, usually [`Mutex<T>`][mutex].\n ///\n /// ## Breaking cycles with `Weak`\n ///\n@@ -106,7 +106,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// // a and b both point to the same memory location as foo.\n /// ```\n ///\n-/// The `Arc::clone(&from)` syntax is the most idiomatic because it conveys more explicitly\n+/// The [`Arc::clone(&from)`] syntax is the most idiomatic because it conveys more explicitly\n /// the meaning of the code. In the example above, this syntax makes it easier to see that\n /// this code is creating a new reference rather than copying the whole content of foo.\n ///\n@@ -141,6 +141,9 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// [upgrade]: struct.Weak.html#method.upgrade\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n /// [assoc]: ../../book/first-edition/method-syntax.html#associated-functions\n+/// [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n+/// [`std::sync`]: ../../std/sync/index.html\n+/// [`Arc::clone(&from)`]: #method.clone\n ///\n /// # Examples\n ///"}, {"sha": "b84a1deb61144adc062dd605e77962192532a2eb", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -1700,8 +1700,18 @@ impl<T: ?Sized + Debug> Debug for RefCell<T> {\n                     .finish()\n             }\n             Err(_) => {\n+                // The RefCell is mutably borrowed so we can't look at its value\n+                // here. Show a placeholder instead.\n+                struct BorrowedPlaceholder;\n+\n+                impl Debug for BorrowedPlaceholder {\n+                    fn fmt(&self, f: &mut Formatter) -> Result {\n+                        f.write_str(\"<borrowed>\")\n+                    }\n+                }\n+\n                 f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &\"<borrowed>\")\n+                    .field(\"value\", &BorrowedPlaceholder)\n                     .finish()\n             }\n         }"}, {"sha": "669b93120cf45b2c5b96a672bec619609d8f5529", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -177,15 +177,59 @@ pub fn forget<T>(t: T) {\n \n /// Returns the size of a type in bytes.\n ///\n-/// More specifically, this is the offset in bytes between successive\n-/// items of the same type, including alignment padding.\n+/// More specifically, this is the offset in bytes between successive elements\n+/// in an array with that item type including alignment padding. Thus, for any\n+/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n+///\n+/// In general, the size of a type is not stable across compilations, but\n+/// specific types such as primitives are.\n+///\n+/// The following table gives the size for primitives.\n+///\n+/// Type | size_of::\\<Type>()\n+/// ---- | ---------------\n+/// () | 0\n+/// u8 | 1\n+/// u16 | 2\n+/// u32 | 4\n+/// u64 | 8\n+/// i8 | 1\n+/// i16 | 2\n+/// i32 | 4\n+/// i64 | 8\n+/// f32 | 4\n+/// f64 | 8\n+/// char | 4\n+///\n+/// Furthermore, `usize` and `isize` have the same size.\n+///\n+/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n+/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n+///\n+/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n+/// have the same size. Likewise for `*const T` and `*mut T`.\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n+/// // Some primitives\n /// assert_eq!(4, mem::size_of::<i32>());\n+/// assert_eq!(8, mem::size_of::<f64>());\n+/// assert_eq!(0, mem::size_of::<()>());\n+///\n+/// // Some arrays\n+/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n+/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n+/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n+///\n+///\n+/// // Pointer size equality\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n+/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5d0cefa1013359c7163d3f5bd3f11477d2741f07", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -1399,9 +1399,6 @@ Section: Comparing strings\n */\n \n /// Bytewise slice equality\n-/// NOTE: This function is (ab)used in rustc::middle::trans::_match\n-/// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n-#[lang = \"str_eq\"]\n #[inline]\n fn eq_slice(a: &str, b: &str) -> bool {\n     a.as_bytes() == b.as_bytes()"}, {"sha": "87de284d011b3a0db99a96efbb3528f851856206", "filename": "src/librustc/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -37,7 +37,7 @@ incremental improves that may change.)\n \n The dependency structure of these crates is roughly a diamond:\n \n-````\n+```\n                   rustc_driver\n                 /      |       \\\n               /        |         \\"}, {"sha": "fd3050f9b9edaa2a5b91e6d9d1cdc0dcee792d7b", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -65,7 +65,7 @@ use syntax::codemap::{self, respan, Spanned, CompilerDesugaringKind};\n use syntax::std_inject;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::{TokenStream, TokenTree, Delimited};\n-use syntax::parse::token::{Token, DelimToken};\n+use syntax::parse::token::Token;\n use syntax::util::small_vector::SmallVector;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n@@ -606,10 +606,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n-        tokens.into_trees().map(|tree| self.lower_token_tree(tree)).collect()\n+        tokens.into_trees()\n+            .flat_map(|tree| self.lower_token_tree(tree).into_trees())\n+            .collect()\n     }\n \n-    fn lower_token_tree(&mut self, tree: TokenTree) -> TokenTree {\n+    fn lower_token_tree(&mut self, tree: TokenTree) -> TokenStream {\n         match tree {\n             TokenTree::Token(span, token) => {\n                 self.lower_token(token, span)\n@@ -618,23 +620,19 @@ impl<'a> LoweringContext<'a> {\n                 TokenTree::Delimited(span, Delimited {\n                     delim: delimited.delim,\n                     tts: self.lower_token_stream(delimited.tts.into()).into(),\n-                })\n+                }).into()\n             }\n         }\n     }\n \n-    fn lower_token(&mut self, token: Token, span: Span) -> TokenTree {\n+    fn lower_token(&mut self, token: Token, span: Span) -> TokenStream {\n         match token {\n             Token::Interpolated(_) => {}\n-            other => return TokenTree::Token(span, other),\n+            other => return TokenTree::Token(span, other).into(),\n         }\n \n         let tts = token.interpolated_to_tokenstream(&self.sess.parse_sess, span);\n-        let tts = self.lower_token_stream(tts);\n-        TokenTree::Delimited(span, Delimited {\n-            delim: DelimToken::NoDelim,\n-            tts: tts.into(),\n-        })\n+        self.lower_token_stream(tts)\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {"}, {"sha": "679c4f17a6c03f55cc589b0f90604042a0697014", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -280,8 +280,6 @@ language_item_table! {\n     EqTraitLangItem,                 \"eq\",                      eq_trait;\n     OrdTraitLangItem,                \"ord\",                     ord_trait;\n \n-    StrEqFnLangItem,                 \"str_eq\",                  str_eq_fn;\n-\n     // A number of panic-related lang items. The `panic` item corresponds to\n     // divide-by-zero and various panic cases with `match`. The\n     // `panic_bounds_check` item is for indexing arrays."}, {"sha": "e87443619ece796245ab423a05074ec5668b3e6b", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -411,7 +411,8 @@ impl Session {\n     }\n     pub fn emit_end_regions(&self) -> bool {\n         self.opts.debugging_opts.emit_end_regions ||\n-            (self.opts.debugging_opts.mir_emit_validate > 0)\n+            (self.opts.debugging_opts.mir_emit_validate > 0) ||\n+            self.opts.debugging_opts.borrowck_mir\n     }\n     pub fn lto(&self) -> bool {\n         self.opts.cg.lto"}, {"sha": "5133e528b099ae3fc84b79eec3d4c2a72859a754", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -419,7 +419,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             self.each_borrow_involving_path(\n                 context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n                     if !borrow.compatible_with(BorrowKind::Shared) {\n-                        this.report_use_while_mutably_borrowed(context, lvalue_span);\n+                        this.report_use_while_mutably_borrowed(context, lvalue_span, borrow);\n                         Control::Break\n                     } else {\n                         Control::Continue\n@@ -914,11 +914,17 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_use_while_mutably_borrowed(&mut self,\n                                          _context: Context,\n-                                         (lvalue, span): (&Lvalue, Span)) {\n+                                         (lvalue, span): (&Lvalue, Span),\n+                                         borrow : &BorrowData) {\n+        let described_lvalue = self.describe_lvalue(lvalue);\n+        let borrow_span = self.retrieve_borrow_span(borrow);\n+\n         let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n-        // FIXME 2: add span_label for \"use of `{}` occurs here\"\n+            span, &described_lvalue, Origin::Mir);\n+\n+        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", described_lvalue));\n+        err.span_label(span, format!(\"use of borrowed `{}`\", described_lvalue));\n+\n         err.emit();\n     }\n \n@@ -998,7 +1004,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                     ProjectionElem::Downcast(..) =>\n                         (\"\",   format!(\"\"), None), // (dont emit downcast info)\n                     ProjectionElem::Field(field, _ty) =>\n-                        (\"\",   format!(\".{}\", field.index()), None),\n+                        (\"\",   format!(\".{}\", field.index()), None), // FIXME: report name of field\n                     ProjectionElem::Index(index) =>\n                         (\"\",   format!(\"\"), Some(index)),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n@@ -1024,6 +1030,13 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n     }\n+\n+    // Retrieve span of given borrow from the current MIR representation\n+    fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n+        self.mir.basic_blocks()[borrow.location.block]\n+            .statements[borrow.location.statement_index]\n+            .source_info.span\n+    }\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {"}, {"sha": "485e75443fe0851003358eb82f5c7d8908a8f985", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -2621,7 +2621,8 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                 href(did).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n             }\n         };\n-        let mut head_len = format!(\"{}{}{:#}fn {}{:#}\",\n+        let mut head_len = format!(\"{}{}{}{:#}fn {}{:#}\",\n+                                   VisSpace(&meth.visibility),\n                                    ConstnessSpace(constness),\n                                    UnsafetySpace(unsafety),\n                                    AbiSpace(abi),\n@@ -2633,8 +2634,9 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n         } else {\n             (0, true)\n         };\n-        write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n+        write!(w, \"{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n+               VisSpace(&meth.visibility),\n                ConstnessSpace(constness),\n                UnsafetySpace(unsafety),\n                AbiSpace(abi),"}, {"sha": "91600b01298a44ec724981216c2260134abfca4c", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -1595,9 +1595,9 @@ pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// Notable exception is made for situations where any of the directories\n /// specified in the `path` could not be created as it was being created concurrently.\n-/// Such cases are considered success. In other words: calling `create_dir_all`\n-/// concurrently from multiple threads or processes is guaranteed to not fail\n-/// due to race itself.\n+/// Such cases are considered to be successful. That is, calling `create_dir_all`\n+/// concurrently from multiple threads or processes is guaranteed not to fail\n+/// due to a race condition with itself.\n ///\n /// # Examples\n ///"}, {"sha": "45d281ee34acdb619ad38d1ff15ccc5f9378484f", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -40,9 +40,10 @@ use mem;\n ///\n /// io::copy(&mut reader, &mut writer)?;\n ///\n-/// assert_eq!(reader, &writer[..]);\n+/// assert_eq!(&b\"hello\"[..], &writer[..]);\n /// # Ok(())\n /// # }\n+/// # foo().unwrap();\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>"}, {"sha": "1edb35d8fe74120fee2f05fc346bb23a0174ebdd", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -710,6 +710,10 @@ mod prim_u128 { }\n //\n /// The pointer-sized signed integer type.\n ///\n+/// The size of this primitive is how many bytes it takes to reference any\n+/// location in memory. For example, on a 32 bit target, this is 4 bytes\n+/// and on a 64 bit target, this is 8 bytes.\n+///\n /// *[See also the `std::isize` module](isize/index.html).*\n ///\n /// However, please note that examples are shared between primitive integer\n@@ -722,6 +726,10 @@ mod prim_isize { }\n //\n /// The pointer-sized unsigned integer type.\n ///\n+/// The size of this primitive is how many bytes it takes to reference any\n+/// location in memory. For example, on a 32 bit target, this is 4 bytes\n+/// and on a 64 bit target, this is 8 bytes.\n+///\n /// *[See also the `std::usize` module](usize/index.html).*\n ///\n /// However, please note that examples are shared between primitive integer"}, {"sha": "4757faabfb873aee9118656509e8f3734c296478", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 120, "deletions": 13, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -24,19 +24,24 @@ use sys_common::rwlock as sys;\n /// of the underlying data (exclusive access) and the read portion of this lock\n /// typically allows for read-only access (shared access).\n ///\n+/// In comparison, a [`Mutex`] does not distinguish between readers or writers\n+/// that aquire the lock, therefore blocking any threads waiting for the lock to\n+/// become available. An `RwLock` will allow any number of readers to aquire the\n+/// lock as long as a writer is not holding the lock.\n+///\n /// The priority policy of the lock is dependent on the underlying operating\n /// system's implementation, and this type does not guarantee that any\n /// particular policy will be used.\n ///\n /// The type parameter `T` represents the data that this lock protects. It is\n-/// required that `T` satisfies `Send` to be shared across threads and `Sync` to\n-/// allow concurrent access through readers. The RAII guards returned from the\n-/// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n-/// to allow access to the contained of the lock.\n+/// required that `T` satisfies [`Send`] to be shared across threads and\n+/// [`Sync`] to allow concurrent access through readers. The RAII guards\n+/// returned from the locking methods implement [`Deref`][] (and [`DerefMut`]\n+/// for the `write` methods) to allow access to the contained of the lock.\n ///\n /// # Poisoning\n ///\n-/// An `RwLock`, like `Mutex`, will become poisoned on a panic. Note, however,\n+/// An `RwLock`, like [`Mutex`], will become poisoned on a panic. Note, however,\n /// that an `RwLock` may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n@@ -63,6 +68,12 @@ use sys_common::rwlock as sys;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n+///\n+/// [`Deref`]: ../../std/ops/trait.Deref.html\n+/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n+/// [`Send`]: ../../std/marker/trait.Send.html\n+/// [`Sync`]: ../../std/marker/trait.Sync.html\n+/// [`Mutex`]: struct.Mutex.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLock<T: ?Sized> {\n     inner: Box<sys::RWLock>,\n@@ -154,6 +165,24 @@ impl<T: ?Sized> RwLock<T> {\n     /// # Panics\n     ///\n     /// This function might panic when called if the lock is already held by the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, RwLock};\n+    /// use std::thread;\n+    ///\n+    /// let lock = Arc::new(RwLock::new(1));\n+    /// let c_lock = lock.clone();\n+    ///\n+    /// let n = lock.read().unwrap();\n+    /// assert_eq!(*n, 1);\n+    ///\n+    /// thread::spawn(move || {\n+    ///     let r = c_lock.read();\n+    ///     assert!(r.is_ok());\n+    /// }).join().unwrap();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n@@ -180,6 +209,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// match lock.try_read() {\n+    ///     Ok(n) => assert_eq!(*n, 1),\n+    ///     Err(_) => unreachable!(),\n+    /// };\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n@@ -210,6 +252,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// # Panics\n     ///\n     /// This function might panic when called if the lock is already held by the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// let mut n = lock.write().unwrap();\n+    /// *n = 2;\n+    ///\n+    /// assert!(lock.try_read().is_err());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n@@ -236,6 +291,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// let n = lock.read().unwrap();\n+    /// assert_eq!(*n, 1);\n+    ///\n+    /// assert!(lock.try_write().is_err());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n@@ -253,6 +321,22 @@ impl<T: ?Sized> RwLock<T> {\n     /// If another thread is active, the lock can still become poisoned at any\n     /// time.  You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, RwLock};\n+    /// use std::thread;\n+    ///\n+    /// let lock = Arc::new(RwLock::new(0));\n+    /// let c_lock = lock.clone();\n+    ///\n+    /// let _ = thread::spawn(move || {\n+    ///     let _lock = c_lock.write().unwrap();\n+    ///     panic!(); // the lock gets poisoned\n+    /// }).join();\n+    /// assert_eq!(lock.is_poisoned(), true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n@@ -267,6 +351,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(String::new());\n+    /// {\n+    ///     let mut s = lock.write().unwrap();\n+    ///     *s = \"modified\".to_owned();\n+    /// }\n+    /// assert_eq!(lock.into_inner().unwrap(), \"modified\");\n+    /// ```\n     #[stable(feature = \"rwlock_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n@@ -282,7 +379,7 @@ impl<T: ?Sized> RwLock<T> {\n                 (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.destroy();  // Keep in sync with the `Drop` impl.\n+            inner.destroy(); // Keep in sync with the `Drop` impl.\n             drop(inner);\n \n             poison::map_result(poison.borrow(), |_| data.into_inner())\n@@ -300,6 +397,16 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let mut lock = RwLock::new(0);\n+    /// *lock.get_mut().unwrap() = 10;\n+    /// assert_eq!(*lock.read().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n@@ -486,7 +593,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -498,7 +605,7 @@ mod tests {\n         let arc = Arc::new(RwLock::new(1));\n         assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -510,7 +617,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.read().unwrap();\n             panic!();\n         }).join();\n@@ -521,7 +628,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.read().unwrap();\n             panic!()\n         }).join();\n@@ -535,7 +642,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut lock = arc2.write().unwrap();\n             for _ in 0..10 {\n                 let tmp = *lock;\n@@ -550,7 +657,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0..5 {\n             let arc3 = arc.clone();\n-            children.push(thread::spawn(move|| {\n+            children.push(thread::spawn(move || {\n                 let lock = arc3.read().unwrap();\n                 assert!(*lock >= 0);\n             }));\n@@ -571,7 +678,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = thread::spawn(move|| -> () {\n+        let _ = thread::spawn(move || -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<isize>>,\n             }"}, {"sha": "3829be40a1e3facd424fcc8bc90208e3b5e938b2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -2632,7 +2632,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, self.mk_unary(UnOp::Not, e))\n+                (lo.to(span), self.mk_unary(UnOp::Not, e))\n             }\n             // Suggest `!` for bitwise negation when encountering a `~`\n             token::Tilde => {\n@@ -2645,26 +2645,26 @@ impl<'a> Parser<'a> {\n                 err.span_label(span_of_tilde, \"did you mean `!`?\");\n                 err.help(\"use `!` instead of `~` if you meant to perform bitwise negation\");\n                 err.emit();\n-                (span, self.mk_unary(UnOp::Not, e))\n+                (lo.to(span), self.mk_unary(UnOp::Not, e))\n             }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, self.mk_unary(UnOp::Neg, e))\n+                (lo.to(span), self.mk_unary(UnOp::Neg, e))\n             }\n             token::BinOp(token::Star) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, self.mk_unary(UnOp::Deref, e))\n+                (lo.to(span), self.mk_unary(UnOp::Deref, e))\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 self.expect_and()?;\n                 let m = self.parse_mutability();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, ExprKind::AddrOf(m, e))\n+                (lo.to(span), ExprKind::AddrOf(m, e))\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n@@ -2675,13 +2675,13 @@ impl<'a> Parser<'a> {\n                 let blk = self.parse_block()?;\n                 let span = blk.span;\n                 let blk_expr = self.mk_expr(span, ExprKind::Block(blk), ThinVec::new());\n-                (span, ExprKind::InPlace(place, blk_expr))\n+                (lo.to(span), ExprKind::InPlace(place, blk_expr))\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, ExprKind::Box(e))\n+                (lo.to(span), ExprKind::Box(e))\n             }\n             _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };"}, {"sha": "08e9990511fbbe90f49e568e6d6e79526dbb68a5", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -13,6 +13,7 @@\n #![allow(unused_features)]\n #![feature(box_syntax)]\n \n+use std::cell::RefCell;\n use std::fmt::{self, Write};\n use std::usize;\n \n@@ -240,6 +241,8 @@ pub fn main() {\n     // test that trailing commas are acceptable\n     format!(\"{}\", \"test\",);\n     format!(\"{foo}\", foo=\"test\",);\n+\n+    test_refcell();\n }\n \n // Basic test to make sure that we can invoke the `write!` macro with an\n@@ -319,3 +322,12 @@ fn test_once() {\n     assert_eq!(format!(\"{0} {0} {0} {a} {a} {a}\", foo(), a=foo()),\n                \"1 1 1 2 2 2\".to_string());\n }\n+\n+fn test_refcell() {\n+    let refcell = RefCell::new(5);\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n+    let borrow = refcell.borrow_mut();\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: <borrowed> }\");\n+    drop(borrow);\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n+}"}, {"sha": "6e8aba012552eb3eda0a96f1b243ed54cb049a39", "filename": "src/test/run-pass/issue-44730.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Ftest%2Frun-pass%2Fissue-44730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Ftest%2Frun-pass%2Fissue-44730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-44730.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! dox\n+\n+#![deny(missing_docs)]\n+\n+macro_rules! doc {\n+    ($e:expr) => (\n+        #[doc = $e]\n+        pub struct Foo;\n+    )\n+}\n+\n+doc!(\"a\");\n+\n+fn main() {}"}, {"sha": "5998734e4a20c7fd610e885cc5889b2c62a23c1b", "filename": "src/test/rustdoc/pub-method.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Ftest%2Frustdoc%2Fpub-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a5d3ffa42068e9ccffde004a466871fd6f2e44/src%2Ftest%2Frustdoc%2Fpub-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fpub-method.rs?ref=85a5d3ffa42068e9ccffde004a466871fd6f2e44", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: --no-defaults --passes collapse-docs --passes unindent-comments --passes strip-priv-imports\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/fn.bar.html\n+// @has - '//*[@class=\"rust fn\"]' 'pub fn bar() -> '\n+/// foo\n+pub fn bar() -> usize {\n+    2\n+}\n+\n+// @has foo/struct.Foo.html\n+// @has - '//*[@class=\"method\"]' 'pub fn new()'\n+// @has - '//*[@class=\"method\"]' 'fn not_pub()'\n+pub struct Foo(usize);\n+\n+impl Foo {\n+    pub fn new() -> Foo { Foo(0) }\n+    fn not_pub() {}\n+}"}]}