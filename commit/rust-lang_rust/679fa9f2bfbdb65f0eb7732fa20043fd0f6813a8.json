{"sha": "679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "node_id": "C_kwDOAAsO6NoAKDY3OWZhOWYyYmZiZGI2NWYwZWI3NzMyZmEyMDA0M2ZkMGY2ODEzYTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-14T15:45:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-14T15:45:17Z"}, "message": "Auto merge of #9187 - sgued:iter-once, r=flip1995\n\nAdd lint recommending using `std::iter::once` and `std::iter::empty`\n\n```\nchangelog: [`iter_once`]: add new lint\nchangelog: [`iter_empty`]: add new lint\n```\n\nfixes #9186\n\n- \\[ ] Followed [lint naming conventions][lint_naming]\n- \\[x] Added passing UI tests (including committed `.stderr` file)\n- \\[x] `cargo test` passes locally\n- \\[x] Executed `cargo dev update_lints`\n- \\[x] Added lint documentation\n- \\[x] Run `cargo dev fmt`\n\n[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n\nThe lint doesn't really follow the naming conventions. I don't have any better idea so I'm open to suggestions.", "tree": {"sha": "1fdc393afba2956ddf6d313bb72424d3c68409f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fdc393afba2956ddf6d313bb72424d3c68409f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "html_url": "https://github.com/rust-lang/rust/commit/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84df61c06eb36602022e758878afe66479ba0769", "url": "https://api.github.com/repos/rust-lang/rust/commits/84df61c06eb36602022e758878afe66479ba0769", "html_url": "https://github.com/rust-lang/rust/commit/84df61c06eb36602022e758878afe66479ba0769"}, {"sha": "af4885c0cde76bf1faace76dc8fb53d3d4791422", "url": "https://api.github.com/repos/rust-lang/rust/commits/af4885c0cde76bf1faace76dc8fb53d3d4791422", "html_url": "https://github.com/rust-lang/rust/commit/af4885c0cde76bf1faace76dc8fb53d3d4791422"}], "stats": {"total": 529, "additions": 524, "deletions": 5}, "files": [{"sha": "a372f9ea81161cba02c32b927b07221f12f58b08", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -3802,6 +3802,8 @@ Released 2018-09-13\n [`iter_not_returning_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_not_returning_iterator\n [`iter_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth\n [`iter_nth_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth_zero\n+[`iter_on_empty_collections`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_on_empty_collections\n+[`iter_on_single_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_on_single_items\n [`iter_overeager_cloned`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_overeager_cloned\n [`iter_skip_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_skip_next\n [`iter_with_drain`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_with_drain"}, {"sha": "e0b94f7190af31c6d03c0fc41fd208e848c76614", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -760,7 +760,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                     .and_then(|subs| subs.get(1..))\n                                 {\n                                     Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n-                                    None => cx.tcx.mk_substs([].iter()),\n+                                    None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n                                 } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n                                     // Trait methods taking `&self`\n                                     sub_ty"}, {"sha": "9ca443b7dff6cbe67a24c5008dee96d2d09be293", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -516,7 +516,10 @@ fn param_env_for_derived_eq(tcx: TyCtxt<'_>, did: DefId, eq_trait_id: DefId) ->\n         tcx.mk_predicates(ty_predicates.iter().map(|&(p, _)| p).chain(\n             params.iter().filter(|&&(_, needs_eq)| needs_eq).map(|&(param, _)| {\n                 tcx.mk_predicate(Binder::dummy(PredicateKind::Trait(TraitPredicate {\n-                    trait_ref: TraitRef::new(eq_trait_id, tcx.mk_substs([tcx.mk_param_from_def(param)].into_iter())),\n+                    trait_ref: TraitRef::new(\n+                        eq_trait_id,\n+                        tcx.mk_substs(std::iter::once(tcx.mk_param_from_def(param))),\n+                    ),\n                     constness: BoundConstness::NotConst,\n                     polarity: ImplPolarity::Positive,\n                 })))"}, {"sha": "665e3277cb57d102b5e819cfce270a2d5907506f", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -315,6 +315,8 @@ store.register_lints(&[\n     methods::ITER_NEXT_SLICE,\n     methods::ITER_NTH,\n     methods::ITER_NTH_ZERO,\n+    methods::ITER_ON_EMPTY_COLLECTIONS,\n+    methods::ITER_ON_SINGLE_ITEMS,\n     methods::ITER_OVEREAGER_CLONED,\n     methods::ITER_SKIP_NEXT,\n     methods::ITER_WITH_DRAIN,"}, {"sha": "d6590192655303b284ed4bff93a5148ceebb8c5a", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -14,6 +14,8 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(index_refutable_slice::INDEX_REFUTABLE_SLICE),\n     LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n     LintId::of(matches::SIGNIFICANT_DROP_IN_SCRUTINEE),\n+    LintId::of(methods::ITER_ON_EMPTY_COLLECTIONS),\n+    LintId::of(methods::ITER_ON_SINGLE_ITEMS),\n     LintId::of(methods::ITER_WITH_DRAIN),\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),"}, {"sha": "cea7b0d82ff3f0f071161c94bacd1af86e51a59c", "filename": "clippy_lints/src/methods/iter_on_single_or_empty_collections.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -0,0 +1,107 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{get_expr_use_or_unification_node, is_lang_ctor, is_no_std_crate};\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{Expr, ExprKind, Node};\n+use rustc_lint::LateContext;\n+\n+use super::{ITER_ON_EMPTY_COLLECTIONS, ITER_ON_SINGLE_ITEMS};\n+\n+enum IterType {\n+    Iter,\n+    IterMut,\n+    IntoIter,\n+}\n+\n+impl IterType {\n+    fn ref_prefix(&self) -> &'static str {\n+        match self {\n+            Self::Iter => \"&\",\n+            Self::IterMut => \"&mut \",\n+            Self::IntoIter => \"\",\n+        }\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, method_name: &str, recv: &Expr<'_>) {\n+    let item = match &recv.kind {\n+        ExprKind::Array(v) if v.len() <= 1 => v.first(),\n+        ExprKind::Path(p) => {\n+            if is_lang_ctor(cx, p, OptionNone) {\n+                None\n+            } else {\n+                return;\n+            }\n+        },\n+        ExprKind::Call(f, some_args) if some_args.len() == 1 => {\n+            if let ExprKind::Path(p) = &f.kind {\n+                if is_lang_ctor(cx, p, OptionSome) {\n+                    Some(&some_args[0])\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                return;\n+            }\n+        },\n+        _ => return,\n+    };\n+    let iter_type = match method_name {\n+        \"iter\" => IterType::Iter,\n+        \"iter_mut\" => IterType::IterMut,\n+        \"into_iter\" => IterType::IntoIter,\n+        _ => return,\n+    };\n+\n+    let is_unified = match get_expr_use_or_unification_node(cx.tcx, expr) {\n+        Some((Node::Expr(parent), child_id)) => match parent.kind {\n+            ExprKind::If(e, _, _) | ExprKind::Match(e, _, _) if e.hir_id == child_id => false,\n+            ExprKind::If(_, _, _)\n+            | ExprKind::Match(_, _, _)\n+            | ExprKind::Closure(_)\n+            | ExprKind::Ret(_)\n+            | ExprKind::Break(_, _) => true,\n+            _ => false,\n+        },\n+        Some((Node::Stmt(_) | Node::Local(_), _)) => false,\n+        _ => true,\n+    };\n+\n+    if is_unified {\n+        return;\n+    }\n+\n+    if let Some(i) = item {\n+        let sugg = format!(\n+            \"{}::iter::once({}{})\",\n+            if is_no_std_crate(cx) { \"core\" } else { \"std\" },\n+            iter_type.ref_prefix(),\n+            snippet(cx, i.span, \"...\")\n+        );\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_ON_SINGLE_ITEMS,\n+            expr.span,\n+            &format!(\"`{method_name}` call on a collection with only one item\"),\n+            \"try\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    } else {\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_ON_EMPTY_COLLECTIONS,\n+            expr.span,\n+            &format!(\"`{method_name}` call on an empty collection\"),\n+            \"try\",\n+            if is_no_std_crate(cx) {\n+                \"core::iter::empty()\".to_string()\n+            } else {\n+                \"std::iter::empty()\".to_string()\n+            },\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}"}, {"sha": "99aae5800ff7c06d6bdd2c46a626ca341c87c84a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -33,6 +33,7 @@ mod iter_count;\n mod iter_next_slice;\n mod iter_nth;\n mod iter_nth_zero;\n+mod iter_on_single_or_empty_collections;\n mod iter_overeager_cloned;\n mod iter_skip_next;\n mod iter_with_drain;\n@@ -2304,6 +2305,69 @@ declare_clippy_lint! {\n     more clearly with `if .. else ..`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for calls to `iter`, `iter_mut` or `into_iter` on collections containing a single item\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// It is simpler to use the once function from the standard library:\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let a = [123].iter();\n+    /// let b = Some(123).into_iter();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::iter;\n+    /// let a = iter::once(&123);\n+    /// let b = iter::once(123);\n+    /// ```\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// The type of the resulting iterator might become incompatible with its usage\n+    #[clippy::version = \"1.64.0\"]\n+    pub ITER_ON_SINGLE_ITEMS,\n+    nursery,\n+    \"Iterator for array of length 1\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for calls to `iter`, `iter_mut` or `into_iter` on empty collections\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// It is simpler to use the empty function from the standard library:\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// use std::{slice, option};\n+    /// let a: slice::Iter<i32> = [].iter();\n+    /// let f: option::IntoIter<i32> = None.into_iter();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::iter;\n+    /// let a: iter::Empty<i32> = iter::empty();\n+    /// let b: iter::Empty<i32> = iter::empty();\n+    /// ```\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// The type of the resulting iterator might become incompatible with its usage\n+    #[clippy::version = \"1.64.0\"]\n+    pub ITER_ON_EMPTY_COLLECTIONS,\n+    nursery,\n+    \"Iterator for empty array\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2406,6 +2470,8 @@ impl_lint_pass!(Methods => [\n     NEEDLESS_OPTION_TAKE,\n     NO_EFFECT_REPLACE,\n     OBFUSCATED_IF_ELSE,\n+    ITER_ON_SINGLE_ITEMS,\n+    ITER_ON_EMPTY_COLLECTIONS\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2708,6 +2774,9 @@ impl Methods {\n                 (\"is_digit\", [radix]) => is_digit_ascii_radix::check(cx, expr, recv, radix, self.msrv),\n                 (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n                 (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n+                (\"iter\" | \"iter_mut\" | \"into_iter\", []) => {\n+                    iter_on_single_or_empty_collections::check(cx, expr, name, recv);\n+                },\n                 (\"join\", [join_arg]) => {\n                     if let Some((\"collect\", _, span)) = method_call(recv) {\n                         unnecessary_join::check(cx, expr, recv, join_arg, span);"}, {"sha": "8693ca9af83003f2492158e481fae972649e5276", "filename": "clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -11,6 +11,8 @@ use rustc_middle::ty::adjustment::{Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::subst::GenericArg;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n+use std::iter;\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for redundant slicing expressions which use the full range, and\n@@ -134,7 +136,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n                 } else if let Some(target_id) = cx.tcx.lang_items().deref_target() {\n                     if let Ok(deref_ty) = cx.tcx.try_normalize_erasing_regions(\n                         cx.param_env,\n-                        cx.tcx.mk_projection(target_id, cx.tcx.mk_substs([GenericArg::from(indexed_ty)].into_iter())),\n+                        cx.tcx.mk_projection(target_id, cx.tcx.mk_substs(iter::once(GenericArg::from(indexed_ty)))),\n                     ) {\n                         if deref_ty == expr_ty {\n                             let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;"}, {"sha": "47b72f4783e32bd7525b5524c36889822f9c546e", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -350,7 +350,7 @@ define_Conf! {\n     /// Lint: DISALLOWED_SCRIPT_IDENTS.\n     ///\n     /// The list of unicode scripts allowed to be used in the scope.\n-    (allowed_scripts: Vec<String> = [\"Latin\"].iter().map(ToString::to_string).collect()),\n+    (allowed_scripts: Vec<String> = vec![\"Latin\".to_string()]),\n     /// Lint: NON_SEND_FIELDS_IN_SEND_TY.\n     ///\n     /// Whether to apply the raw pointer heuristic to determine if a type is `Send`."}, {"sha": "b1148bccc2a283d025cb530f18197437bfbe9079", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -797,7 +797,7 @@ fn get_lint_group_and_level_or_lint(\n     let result = cx.lint_store.check_lint_name(\n         lint_name,\n         Some(sym::clippy),\n-        &[Ident::with_dummy_span(sym::clippy)].into_iter().collect(),\n+        &std::iter::once(Ident::with_dummy_span(sym::clippy)).collect(),\n     );\n     if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n         if let Some(group) = get_lint_group(cx, lint_lst[0]) {"}, {"sha": "bd9b07aefbfb85afd0a64ea4d96f1436a7f9d87b", "filename": "tests/ui/iter_on_empty_collections.fixed", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_empty_collections.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_empty_collections.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_on_empty_collections.fixed?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+#![warn(clippy::iter_on_empty_collections)]\n+#![allow(clippy::iter_next_slice, clippy::redundant_clone)]\n+\n+fn array() {\n+    assert_eq!(std::iter::empty().next(), Option::<i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<&mut i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<&i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<&mut i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<&i32>::None);\n+\n+    // Don't trigger on non-iter methods\n+    let _: Option<String> = None.clone();\n+    let _: [String; 0] = [].clone();\n+\n+    // Don't trigger on match or if branches\n+    let _ = match 123 {\n+        123 => [].iter(),\n+        _ => [\"test\"].iter(),\n+    };\n+\n+    let _ = if false { [\"test\"].iter() } else { [].iter() };\n+}\n+\n+macro_rules! in_macros {\n+    () => {\n+        assert_eq!([].into_iter().next(), Option::<i32>::None);\n+        assert_eq!([].iter_mut().next(), Option::<&mut i32>::None);\n+        assert_eq!([].iter().next(), Option::<&i32>::None);\n+        assert_eq!(None.into_iter().next(), Option::<i32>::None);\n+        assert_eq!(None.iter_mut().next(), Option::<&mut i32>::None);\n+        assert_eq!(None.iter().next(), Option::<&i32>::None);\n+    };\n+}\n+\n+// Don't trigger on a `None` that isn't std's option\n+mod custom_option {\n+    #[allow(unused)]\n+    enum CustomOption {\n+        Some(i32),\n+        None,\n+    }\n+\n+    impl CustomOption {\n+        fn iter(&self) {}\n+        fn iter_mut(&mut self) {}\n+        fn into_iter(self) {}\n+    }\n+    use CustomOption::*;\n+\n+    pub fn custom_option() {\n+        None.iter();\n+        None.iter_mut();\n+        None.into_iter();\n+    }\n+}\n+\n+fn main() {\n+    array();\n+    custom_option::custom_option();\n+    in_macros!();\n+}"}, {"sha": "e15ba94bd465528d9147ef1f83a66f0b2bf9d6b3", "filename": "tests/ui/iter_on_empty_collections.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_on_empty_collections.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+#![warn(clippy::iter_on_empty_collections)]\n+#![allow(clippy::iter_next_slice, clippy::redundant_clone)]\n+\n+fn array() {\n+    assert_eq!([].into_iter().next(), Option::<i32>::None);\n+    assert_eq!([].iter_mut().next(), Option::<&mut i32>::None);\n+    assert_eq!([].iter().next(), Option::<&i32>::None);\n+    assert_eq!(None.into_iter().next(), Option::<i32>::None);\n+    assert_eq!(None.iter_mut().next(), Option::<&mut i32>::None);\n+    assert_eq!(None.iter().next(), Option::<&i32>::None);\n+\n+    // Don't trigger on non-iter methods\n+    let _: Option<String> = None.clone();\n+    let _: [String; 0] = [].clone();\n+\n+    // Don't trigger on match or if branches\n+    let _ = match 123 {\n+        123 => [].iter(),\n+        _ => [\"test\"].iter(),\n+    };\n+\n+    let _ = if false { [\"test\"].iter() } else { [].iter() };\n+}\n+\n+macro_rules! in_macros {\n+    () => {\n+        assert_eq!([].into_iter().next(), Option::<i32>::None);\n+        assert_eq!([].iter_mut().next(), Option::<&mut i32>::None);\n+        assert_eq!([].iter().next(), Option::<&i32>::None);\n+        assert_eq!(None.into_iter().next(), Option::<i32>::None);\n+        assert_eq!(None.iter_mut().next(), Option::<&mut i32>::None);\n+        assert_eq!(None.iter().next(), Option::<&i32>::None);\n+    };\n+}\n+\n+// Don't trigger on a `None` that isn't std's option\n+mod custom_option {\n+    #[allow(unused)]\n+    enum CustomOption {\n+        Some(i32),\n+        None,\n+    }\n+\n+    impl CustomOption {\n+        fn iter(&self) {}\n+        fn iter_mut(&mut self) {}\n+        fn into_iter(self) {}\n+    }\n+    use CustomOption::*;\n+\n+    pub fn custom_option() {\n+        None.iter();\n+        None.iter_mut();\n+        None.into_iter();\n+    }\n+}\n+\n+fn main() {\n+    array();\n+    custom_option::custom_option();\n+    in_macros!();\n+}"}, {"sha": "cbd611769569670ab06ce18c3fbde8bba2308ddb", "filename": "tests/ui/iter_on_empty_collections.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_empty_collections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_empty_collections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_on_empty_collections.stderr?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -0,0 +1,40 @@\n+error: `into_iter` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:6:16\n+   |\n+LL |     assert_eq!([].into_iter().next(), Option::<i32>::None);\n+   |                ^^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+   |\n+   = note: `-D clippy::iter-on-empty-collections` implied by `-D warnings`\n+\n+error: `iter_mut` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:7:16\n+   |\n+LL |     assert_eq!([].iter_mut().next(), Option::<&mut i32>::None);\n+   |                ^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: `iter` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:8:16\n+   |\n+LL |     assert_eq!([].iter().next(), Option::<&i32>::None);\n+   |                ^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: `into_iter` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:9:16\n+   |\n+LL |     assert_eq!(None.into_iter().next(), Option::<i32>::None);\n+   |                ^^^^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: `iter_mut` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:10:16\n+   |\n+LL |     assert_eq!(None.iter_mut().next(), Option::<&mut i32>::None);\n+   |                ^^^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: `iter` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:11:16\n+   |\n+LL |     assert_eq!(None.iter().next(), Option::<&i32>::None);\n+   |                ^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "1fa4b03641bc73334438a452644037a410b6cbcc", "filename": "tests/ui/iter_on_single_items.fixed", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_single_items.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_single_items.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_on_single_items.fixed?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+#![warn(clippy::iter_on_single_items)]\n+#![allow(clippy::iter_next_slice, clippy::redundant_clone)]\n+\n+fn array() {\n+    assert_eq!(std::iter::once(123).next(), Some(123));\n+    assert_eq!(std::iter::once(&mut 123).next(), Some(&mut 123));\n+    assert_eq!(std::iter::once(&123).next(), Some(&123));\n+    assert_eq!(std::iter::once(123).next(), Some(123));\n+    assert_eq!(std::iter::once(&mut 123).next(), Some(&mut 123));\n+    assert_eq!(std::iter::once(&123).next(), Some(&123));\n+\n+    // Don't trigger on non-iter methods\n+    let _: Option<String> = Some(\"test\".to_string()).clone();\n+    let _: [String; 1] = [\"test\".to_string()].clone();\n+\n+    // Don't trigger on match or if branches\n+    let _ = match 123 {\n+        123 => [].iter(),\n+        _ => [\"test\"].iter(),\n+    };\n+\n+    let _ = if false { [\"test\"].iter() } else { [].iter() };\n+}\n+\n+macro_rules! in_macros {\n+    () => {\n+        assert_eq!([123].into_iter().next(), Some(123));\n+        assert_eq!([123].iter_mut().next(), Some(&mut 123));\n+        assert_eq!([123].iter().next(), Some(&123));\n+        assert_eq!(Some(123).into_iter().next(), Some(123));\n+        assert_eq!(Some(123).iter_mut().next(), Some(&mut 123));\n+        assert_eq!(Some(123).iter().next(), Some(&123));\n+    };\n+}\n+\n+// Don't trigger on a `Some` that isn't std's option\n+mod custom_option {\n+    #[allow(unused)]\n+    enum CustomOption {\n+        Some(i32),\n+        None,\n+    }\n+\n+    impl CustomOption {\n+        fn iter(&self) {}\n+        fn iter_mut(&mut self) {}\n+        fn into_iter(self) {}\n+    }\n+    use CustomOption::*;\n+\n+    pub fn custom_option() {\n+        Some(3).iter();\n+        Some(3).iter_mut();\n+        Some(3).into_iter();\n+    }\n+}\n+\n+fn main() {\n+    array();\n+    custom_option::custom_option();\n+    in_macros!();\n+}"}, {"sha": "ea96d8066c568588ce493bb1394705e5b313a4dd", "filename": "tests/ui/iter_on_single_items.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_single_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_single_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_on_single_items.rs?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+#![warn(clippy::iter_on_single_items)]\n+#![allow(clippy::iter_next_slice, clippy::redundant_clone)]\n+\n+fn array() {\n+    assert_eq!([123].into_iter().next(), Some(123));\n+    assert_eq!([123].iter_mut().next(), Some(&mut 123));\n+    assert_eq!([123].iter().next(), Some(&123));\n+    assert_eq!(Some(123).into_iter().next(), Some(123));\n+    assert_eq!(Some(123).iter_mut().next(), Some(&mut 123));\n+    assert_eq!(Some(123).iter().next(), Some(&123));\n+\n+    // Don't trigger on non-iter methods\n+    let _: Option<String> = Some(\"test\".to_string()).clone();\n+    let _: [String; 1] = [\"test\".to_string()].clone();\n+\n+    // Don't trigger on match or if branches\n+    let _ = match 123 {\n+        123 => [].iter(),\n+        _ => [\"test\"].iter(),\n+    };\n+\n+    let _ = if false { [\"test\"].iter() } else { [].iter() };\n+}\n+\n+macro_rules! in_macros {\n+    () => {\n+        assert_eq!([123].into_iter().next(), Some(123));\n+        assert_eq!([123].iter_mut().next(), Some(&mut 123));\n+        assert_eq!([123].iter().next(), Some(&123));\n+        assert_eq!(Some(123).into_iter().next(), Some(123));\n+        assert_eq!(Some(123).iter_mut().next(), Some(&mut 123));\n+        assert_eq!(Some(123).iter().next(), Some(&123));\n+    };\n+}\n+\n+// Don't trigger on a `Some` that isn't std's option\n+mod custom_option {\n+    #[allow(unused)]\n+    enum CustomOption {\n+        Some(i32),\n+        None,\n+    }\n+\n+    impl CustomOption {\n+        fn iter(&self) {}\n+        fn iter_mut(&mut self) {}\n+        fn into_iter(self) {}\n+    }\n+    use CustomOption::*;\n+\n+    pub fn custom_option() {\n+        Some(3).iter();\n+        Some(3).iter_mut();\n+        Some(3).into_iter();\n+    }\n+}\n+\n+fn main() {\n+    array();\n+    custom_option::custom_option();\n+    in_macros!();\n+}"}, {"sha": "d6c547116363af8d77aee5d37feda615d0ac2541", "filename": "tests/ui/iter_on_single_items.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_single_items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8/tests%2Fui%2Fiter_on_single_items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_on_single_items.stderr?ref=679fa9f2bfbdb65f0eb7732fa20043fd0f6813a8", "patch": "@@ -0,0 +1,40 @@\n+error: `into_iter` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:6:16\n+   |\n+LL |     assert_eq!([123].into_iter().next(), Some(123));\n+   |                ^^^^^^^^^^^^^^^^^ help: try: `std::iter::once(123)`\n+   |\n+   = note: `-D clippy::iter-on-single-items` implied by `-D warnings`\n+\n+error: `iter_mut` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:7:16\n+   |\n+LL |     assert_eq!([123].iter_mut().next(), Some(&mut 123));\n+   |                ^^^^^^^^^^^^^^^^ help: try: `std::iter::once(&mut 123)`\n+\n+error: `iter` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:8:16\n+   |\n+LL |     assert_eq!([123].iter().next(), Some(&123));\n+   |                ^^^^^^^^^^^^ help: try: `std::iter::once(&123)`\n+\n+error: `into_iter` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:9:16\n+   |\n+LL |     assert_eq!(Some(123).into_iter().next(), Some(123));\n+   |                ^^^^^^^^^^^^^^^^^^^^^ help: try: `std::iter::once(123)`\n+\n+error: `iter_mut` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:10:16\n+   |\n+LL |     assert_eq!(Some(123).iter_mut().next(), Some(&mut 123));\n+   |                ^^^^^^^^^^^^^^^^^^^^ help: try: `std::iter::once(&mut 123)`\n+\n+error: `iter` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:11:16\n+   |\n+LL |     assert_eq!(Some(123).iter().next(), Some(&123));\n+   |                ^^^^^^^^^^^^^^^^ help: try: `std::iter::once(&123)`\n+\n+error: aborting due to 6 previous errors\n+"}]}