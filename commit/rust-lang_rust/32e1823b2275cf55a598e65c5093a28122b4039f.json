{"sha": "32e1823b2275cf55a598e65c5093a28122b4039f", "node_id": "C_kwDOAAsO6NoAKDMyZTE4MjNiMjI3NWNmNTVhNTk4ZTY1YzUwOTNhMjgxMjJiNDAzOWY", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-08-23T23:03:49Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-08-31T16:56:42Z"}, "message": "port creader.rs to SessionDiagnostics", "tree": {"sha": "c07c80d856cd9829f5bd35b9a41bac27b966b229", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c07c80d856cd9829f5bd35b9a41bac27b966b229"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32e1823b2275cf55a598e65c5093a28122b4039f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32e1823b2275cf55a598e65c5093a28122b4039f", "html_url": "https://github.com/rust-lang/rust/commit/32e1823b2275cf55a598e65c5093a28122b4039f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32e1823b2275cf55a598e65c5093a28122b4039f/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "f7e462a6c7faaea4bfce236fb94b4622ea8260ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7e462a6c7faaea4bfce236fb94b4622ea8260ef", "html_url": "https://github.com/rust-lang/rust/commit/f7e462a6c7faaea4bfce236fb94b4622ea8260ef"}], "stats": {"total": 136, "additions": 102, "deletions": 34}, "files": [{"sha": "3ce1275a89919fd01dc4297467194d2ba9d176cc", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32e1823b2275cf55a598e65c5093a28122b4039f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/32e1823b2275cf55a598e65c5093a28122b4039f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=32e1823b2275cf55a598e65c5093a28122b4039f", "patch": "@@ -130,3 +130,31 @@ metadata_fail_seek_file =\n \n metadata_fail_write_file =\n     failed to write to the file: {$err}\n+\n+metadata_crate_not_panic_runtime =\n+    the crate `{$crate_name}` is not a panic runtime\n+\n+metadata_no_panic_strategy =\n+    the crate `{$crate_name}` does not have the panic strategy `{$strategy}`\n+\n+metadata_profiler_builtins_needs_core =\n+    `profiler_builtins` crate (required by compiler options) is not compatible with crate attribute `#![no_core]`\n+\n+metadata_not_profiler_runtime =\n+    the crate `{$crate_name}` is not a profiler runtime\n+\n+metadata_no_multiple_global_alloc =\n+    cannot define multiple global allocators\n+    .label = cannot define a new global allocator\n+\n+metadata_prev_global_alloc =\n+    previous global allocator defined here\n+\n+metadata_conflicting_global_alloc =\n+    the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n+\n+metadata_global_alloc_required =\n+    no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n+\n+metadata_no_transitive_needs_dep =\n+    the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`"}, {"sha": "f9aa3733f6a37129a29c7f381fa645df6821526f", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/32e1823b2275cf55a598e65c5093a28122b4039f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e1823b2275cf55a598e65c5093a28122b4039f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=32e1823b2275cf55a598e65c5093a28122b4039f", "patch": "@@ -1,5 +1,9 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n+use crate::errors::{\n+    ConflictingGlobalAlloc, CrateNotPanicRuntime, GlobalAllocRequired, NoMultipleGlobalAlloc,\n+    NoPanicStrategy, NoTransitiveNeedsDep, NotProfilerRuntime, ProfilerBuiltinsNeedsCore,\n+};\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n@@ -746,15 +750,13 @@ impl<'a> CrateLoader<'a> {\n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n         if !data.is_panic_runtime() {\n-            self.sess.err(&format!(\"the crate `{}` is not a panic runtime\", name));\n+            self.sess.emit_err(CrateNotPanicRuntime { crate_name: name.to_string() });\n         }\n         if data.required_panic_strategy() != Some(desired_strategy) {\n-            self.sess.err(&format!(\n-                \"the crate `{}` does not have the panic \\\n-                                    strategy `{}`\",\n-                name,\n-                desired_strategy.desc()\n-            ));\n+            self.sess.emit_err(NoPanicStrategy {\n+                crate_name: name.to_string(),\n+                strategy: desired_strategy.desc().to_string(),\n+            });\n         }\n \n         self.cstore.injected_panic_runtime = Some(cnum);\n@@ -774,29 +776,22 @@ impl<'a> CrateLoader<'a> {\n \n         let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);\n         if name == sym::profiler_builtins && self.sess.contains_name(&krate.attrs, sym::no_core) {\n-            self.sess.err(\n-                \"`profiler_builtins` crate (required by compiler options) \\\n-                        is not compatible with crate attribute `#![no_core]`\",\n-            );\n+            self.sess.emit_err(ProfilerBuiltinsNeedsCore);\n         }\n \n         let Some(cnum) = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit) else { return; };\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n         if !data.is_profiler_runtime() {\n-            self.sess.err(&format!(\"the crate `{}` is not a profiler runtime\", name));\n+            self.sess.emit_err(NotProfilerRuntime { crate_name: name.to_string() });\n         }\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n         self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n-                self.sess\n-                    .struct_span_err(*span2, \"cannot define multiple global allocators\")\n-                    .span_label(*span2, \"cannot define a new global allocator\")\n-                    .span_label(*span1, \"previous global allocator defined here\")\n-                    .emit();\n+                self.sess.emit_err(NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n@@ -832,11 +827,10 @@ impl<'a> CrateLoader<'a> {\n             if data.has_global_allocator() {\n                 match global_allocator {\n                     Some(other_crate) => {\n-                        self.sess.err(&format!(\n-                        \"the `#[global_allocator]` in {} conflicts with global allocator in: {}\",\n-                        other_crate,\n-                        data.name()\n-                    ));\n+                        self.sess.emit_err(ConflictingGlobalAlloc {\n+                            crate_name: data.name().to_string(),\n+                            other_crate_name: other_crate.to_string(),\n+                        });\n                     }\n                     None => global_allocator = Some(data.name()),\n                 }\n@@ -855,10 +849,7 @@ impl<'a> CrateLoader<'a> {\n         if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n             && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n         {\n-            self.sess.err(\n-                \"no global memory allocator found but one is required; link to std or add \\\n-                 `#[global_allocator]` to a static item that implements the GlobalAlloc trait\",\n-            );\n+            self.sess.emit_err(GlobalAllocRequired);\n         }\n         self.cstore.allocator_kind = Some(AllocatorKind::Default);\n     }\n@@ -882,14 +873,11 @@ impl<'a> CrateLoader<'a> {\n         for dep in self.cstore.crate_dependencies_in_reverse_postorder(krate) {\n             let data = self.cstore.get_crate_data(dep);\n             if needs_dep(&data) {\n-                self.sess.err(&format!(\n-                    \"the crate `{}` cannot depend \\\n-                                        on a crate that needs {}, but \\\n-                                        it depends on `{}`\",\n-                    self.cstore.get_crate_data(krate).name(),\n-                    what,\n-                    data.name()\n-                ));\n+                self.sess.emit_err(NoTransitiveNeedsDep {\n+                    crate_name: self.cstore.get_crate_data(krate).name().to_string(),\n+                    needs_crate_name: what.to_string(),\n+                    deps_crate_name: data.name().to_string(),\n+                });\n             }\n         }\n "}, {"sha": "3d025e89857c9c210936eeaf254e09c07ce47fab", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/32e1823b2275cf55a598e65c5093a28122b4039f/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e1823b2275cf55a598e65c5093a28122b4039f/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=32e1823b2275cf55a598e65c5093a28122b4039f", "patch": "@@ -300,3 +300,55 @@ pub struct FailSeekFile {\n pub struct FailWriteFile {\n     pub err: String,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::crate_not_panic_runtime)]\n+pub struct CrateNotPanicRuntime {\n+    pub crate_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_panic_strategy)]\n+pub struct NoPanicStrategy {\n+    pub crate_name: String,\n+    pub strategy: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::profiler_builtins_needs_core)]\n+pub struct ProfilerBuiltinsNeedsCore;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::not_profiler_runtime)]\n+pub struct NotProfilerRuntime {\n+    pub crate_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_multiple_global_alloc)]\n+pub struct NoMultipleGlobalAlloc {\n+    #[primary_span]\n+    #[label]\n+    pub span2: Span,\n+    #[label(metadata::prev_global_alloc)]\n+    pub span1: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::conflicting_global_alloc)]\n+pub struct ConflictingGlobalAlloc {\n+    pub crate_name: String,\n+    pub other_crate_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::global_alloc_required)]\n+pub struct GlobalAllocRequired;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_transitive_needs_dep)]\n+pub struct NoTransitiveNeedsDep {\n+    pub crate_name: String,\n+    pub needs_crate_name: String,\n+    pub deps_crate_name: String,\n+}"}]}