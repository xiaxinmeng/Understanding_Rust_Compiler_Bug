{"sha": "89c76bb1426539f2c6ea2b7c5892296efc96df9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5Yzc2YmIxNDI2NTM5ZjJjNmVhMmI3YzU4OTIyOTZlZmM5NmRmOWE=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-06-08T16:30:03Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-06-08T17:29:55Z"}, "message": "Implement Hash for Bitv and BitvSet\n\nCloses #14744", "tree": {"sha": "aa70e7ee34cc543423934376869b245841c25c72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa70e7ee34cc543423934376869b245841c25c72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89c76bb1426539f2c6ea2b7c5892296efc96df9a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89c76bb1426539f2c6ea2b7c5892296efc96df9a", "html_url": "https://github.com/rust-lang/rust/commit/89c76bb1426539f2c6ea2b7c5892296efc96df9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89c76bb1426539f2c6ea2b7c5892296efc96df9a/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17ba0cf4289d6da632aab4cf242ad74dea94fe37", "url": "https://api.github.com/repos/rust-lang/rust/commits/17ba0cf4289d6da632aab4cf242ad74dea94fe37", "html_url": "https://github.com/rust-lang/rust/commit/17ba0cf4289d6da632aab4cf242ad74dea94fe37"}], "stats": {"total": 73, "additions": 48, "deletions": 25}, "files": [{"sha": "79e0c2ffea877772a93700e26780ee0a0adc2f39", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/89c76bb1426539f2c6ea2b7c5892296efc96df9a/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c76bb1426539f2c6ea2b7c5892296efc96df9a/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=89c76bb1426539f2c6ea2b7c5892296efc96df9a", "patch": "@@ -18,6 +18,7 @@ use core::iter::{Enumerate, Repeat, Map, Zip};\n use core::ops;\n use core::slice;\n use core::uint;\n+use std::hash;\n \n use vec::Vec;\n \n@@ -34,12 +35,12 @@ fn small_mask(nbits: uint) -> uint {\n }\n \n impl SmallBitv {\n-    pub fn new(bits: uint) -> SmallBitv {\n+    fn new(bits: uint) -> SmallBitv {\n         SmallBitv {bits: bits}\n     }\n \n     #[inline]\n-    pub fn bits_op(&mut self,\n+    fn bits_op(&mut self,\n                    right_bits: uint,\n                    nbits: uint,\n                    f: |uint, uint| -> uint)\n@@ -52,32 +53,32 @@ impl SmallBitv {\n     }\n \n     #[inline]\n-    pub fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n \n     #[inline]\n-    pub fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n \n     #[inline]\n-    pub fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n \n     #[inline]\n-    pub fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n     }\n \n     #[inline]\n-    pub fn get(&self, i: uint) -> bool {\n+    fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n     #[inline]\n-    pub fn set(&mut self, i: uint, x: bool) {\n+    fn set(&mut self, i: uint, x: bool) {\n         if x {\n             self.bits |= 1<<i;\n         }\n@@ -87,29 +88,29 @@ impl SmallBitv {\n     }\n \n     #[inline]\n-    pub fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n+    fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n \n     #[inline]\n-    pub fn clear(&mut self) { self.bits = 0; }\n+    fn clear(&mut self) { self.bits = 0; }\n \n     #[inline]\n-    pub fn set_all(&mut self) { self.bits = !0; }\n+    fn set_all(&mut self) { self.bits = !0; }\n \n     #[inline]\n-    pub fn all(&self, nbits: uint) -> bool {\n+    fn all(&self, nbits: uint) -> bool {\n         small_mask(nbits) & !self.bits == 0\n     }\n \n     #[inline]\n-    pub fn none(&self, nbits: uint) -> bool {\n+    fn none(&self, nbits: uint) -> bool {\n         small_mask(nbits) & self.bits == 0\n     }\n \n     #[inline]\n-    pub fn negate(&mut self) { self.bits = !self.bits; }\n+    fn negate(&mut self) { self.bits = !self.bits; }\n }\n \n #[deriving(Clone)]\n@@ -134,12 +135,12 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n }\n \n impl BigBitv {\n-    pub fn new(storage: Vec<uint>) -> BigBitv {\n+    fn new(storage: Vec<uint>) -> BigBitv {\n         BigBitv {storage: storage}\n     }\n \n     #[inline]\n-    pub fn process(&mut self,\n+    fn process(&mut self,\n                    b: &BigBitv,\n                    nbits: uint,\n                    op: |uint, uint| -> uint)\n@@ -163,45 +164,45 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn each_storage(&mut self, op: |v: &mut uint| -> bool) -> bool {\n+    fn each_storage(&mut self, op: |v: &mut uint| -> bool) -> bool {\n         self.storage.mut_iter().advance(|elt| op(elt))\n     }\n \n     #[inline]\n-    pub fn negate(&mut self) {\n+    fn negate(&mut self) {\n         self.each_storage(|w| { *w = !*w; true });\n     }\n \n     #[inline]\n-    pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 | w2)\n     }\n \n     #[inline]\n-    pub fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & w2)\n     }\n \n     #[inline]\n-    pub fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |_, w| w)\n     }\n \n     #[inline]\n-    pub fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & !w2)\n     }\n \n     #[inline]\n-    pub fn get(&self, i: uint) -> bool {\n+    fn get(&self, i: uint) -> bool {\n         let w = i / uint::BITS;\n         let b = i % uint::BITS;\n         let x = 1 & self.storage.get(w) >> b;\n         x == 1\n     }\n \n     #[inline]\n-    pub fn set(&mut self, i: uint, x: bool) {\n+    fn set(&mut self, i: uint, x: bool) {\n         let w = i / uint::BITS;\n         let b = i % uint::BITS;\n         let flag = 1 << b;\n@@ -210,7 +211,7 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n+    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         for (i, elt) in b.storage.iter().enumerate() {\n             let mask = big_mask(nbits, i);\n             if mask & *self.storage.get(i) != mask & *elt {\n@@ -596,6 +597,20 @@ impl fmt::Show for Bitv {\n     }\n }\n \n+impl<S: hash::Writer> hash::Hash<S> for Bitv {\n+    fn hash(&self, state: &mut S) {\n+        self.nbits.hash(state);\n+        match self.rep {\n+            Small(ref s) => (s.bits & small_mask(self.nbits)).hash(state),\n+            Big(ref b) => {\n+                for (i, ele) in b.storage.iter().enumerate() {\n+                    (ele & big_mask(self.nbits, i)).hash(state);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[inline]\n fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n     if bits == 0 {\n@@ -834,6 +849,14 @@ impl fmt::Show for BitvSet {\n     }\n }\n \n+impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n+    fn hash(&self, state: &mut S) {\n+        for pos in self.iter() {\n+            pos.hash(state);\n+        }\n+    }\n+}\n+\n impl Container for BitvSet {\n     #[inline]\n     fn len(&self) -> uint { self.size }"}]}