{"sha": "3e52a0acdec93357806771eb04f0f479873a637b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNTJhMGFjZGVjOTMzNTc4MDY3NzFlYjA0ZjBmNDc5ODczYTYzN2I=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-18T02:12:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-18T02:12:08Z"}, "message": "Initial sketch of path2 module, starting with WindowsPath.", "tree": {"sha": "992ac7fa36f21556a46fc31221f89488b1bbc22f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/992ac7fa36f21556a46fc31221f89488b1bbc22f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e52a0acdec93357806771eb04f0f479873a637b", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e52a0acdec93357806771eb04f0f479873a637b", "html_url": "https://github.com/rust-lang/rust/commit/3e52a0acdec93357806771eb04f0f479873a637b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e52a0acdec93357806771eb04f0f479873a637b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19b8598c098630e4031e32046867aaca9681b4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/19b8598c098630e4031e32046867aaca9681b4cf", "html_url": "https://github.com/rust-lang/rust/commit/19b8598c098630e4031e32046867aaca9681b4cf"}], "stats": {"total": 311, "additions": 311, "deletions": 0}, "files": [{"sha": "c6b25476b96d43c6f85b8b60605be096db6d06f1", "filename": "src/libcore/path2.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/3e52a0acdec93357806771eb04f0f479873a637b/src%2Flibcore%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e52a0acdec93357806771eb04f0f479873a637b/src%2Flibcore%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath2.rs?ref=3e52a0acdec93357806771eb04f0f479873a637b", "patch": "@@ -0,0 +1,311 @@\n+extern mod std;\n+\n+struct WindowsPath {\n+    host: option<~str>;\n+    device: option<~str>;\n+    is_absolute: bool;\n+    components: ~[~str];\n+}\n+\n+struct PosixPath {\n+    is_absolute: bool;\n+    components: ~[~str];\n+}\n+\n+trait Path {\n+\n+    static fn from_str((&str)) -> self;\n+    fn to_str() -> ~str;\n+\n+    fn dirname() -> ~str;\n+    fn filename() -> option<~str>;\n+    fn filestem() -> option<~str>;\n+    fn filetype() -> option<~str>;\n+\n+    fn with_dirname((&str)) -> self;\n+    fn with_filename((&str)) -> self;\n+    fn with_filestem((&str)) -> self;\n+    fn with_filetype((&str)) -> self;\n+\n+    fn push_components((&[~str])) -> self;\n+    fn pop_component() -> self;\n+}\n+\n+\n+impl WindowsPath : Path {\n+\n+    fn to_str() -> ~str {\n+        match self.filename() {\n+          none => self.dirname(),\n+          some(ref f) =>\n+          if (self.components.len() == 1 &&\n+              !self.is_absolute &&\n+              self.host == none &&\n+              self.device == none) {\n+            copy *f\n+          } else {\n+            self.dirname() + \"\\\\\" + *f\n+          }\n+        }\n+    }\n+\n+    static fn from_str(s: &str) -> WindowsPath {\n+        let host;\n+        let device;\n+        let rest;\n+\n+        match windows::extract_drive_prefix(s) {\n+          some((ref d, ref r)) => {\n+            host = none;\n+            device = some(copy *d);\n+            rest = copy *r;\n+          }\n+          none => {\n+            match windows::extract_unc_prefix(s) {\n+              some((ref h, ref r)) => {\n+                host = some(copy *h);\n+                device = none;\n+                rest = copy *r;\n+              }\n+              none => {\n+                host = none;\n+                device = none;\n+                rest = str::from_slice(s);\n+              }\n+            }\n+          }\n+        }\n+\n+        let mut components =\n+            str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n+        let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n+        return WindowsPath { host: host,\n+                             device: device,\n+                             is_absolute: is_absolute,\n+                            components: components }\n+    }\n+\n+    fn dirname() -> ~str {\n+        let mut s = ~\"\";\n+        match self.host {\n+          some(h) => { s += \"\\\\\\\\\"; s += h; }\n+          none => { }\n+        }\n+        match self.device {\n+          some(d) => { s += d; s += \":\"; }\n+          none => { }\n+        }\n+        if self.is_absolute {\n+            s += \"\\\\\";\n+        }\n+        let mut d = copy self.components;\n+        if d.len() != 0 {\n+            vec::pop(d);\n+        }\n+        s += str::connect(d, \"\\\\\");\n+        if s.len() == 0 {\n+            s = ~\".\";\n+        }\n+        return s;\n+    }\n+\n+    fn filename() -> option<~str> {\n+        match self.components.len() {\n+          0 => none,\n+          1 => some(copy self.components[0]),\n+          n => some(copy self.components[n - 1])\n+        }\n+    }\n+\n+    fn filestem() -> option<~str> {\n+        match self.filename() {\n+          none => none,\n+          some(ref f) => {\n+            match str::rfind_char(*f, '.') {\n+              some(p) => some(f.slice(0, p)),\n+              none => some(copy *f)\n+            }\n+          }\n+        }\n+    }\n+\n+    fn filetype() -> option<~str> {\n+        match self.filename() {\n+          none => none,\n+          some(ref f) => {\n+            match str::rfind_char(*f, '.') {\n+              some(p) if p+1 < f.len() => some(f.slice(p+1, f.len())),\n+              _ => none\n+            }\n+          }\n+        }\n+    }\n+\n+    fn with_dirname(d: &str) -> WindowsPath {\n+        let dpath = from_str::<WindowsPath>(d);\n+        match self.filename() {\n+          some(ref f) => dpath.push_components(~[copy *f]),\n+          none => dpath\n+        }\n+    }\n+\n+    fn with_filename(f: &str) -> WindowsPath {\n+        assert ! str::any(f, |c| windows::is_sep(c as u8));\n+        self.dir_path().push_components(~[str::from_slice(f)])\n+    }\n+\n+    fn with_filestem(s: &str) -> WindowsPath {\n+        match self.filetype() {\n+          none => self.with_filename(s),\n+          some(ref t) =>\n+          self.with_filename(str::from_slice(s) + \".\" + *t)\n+        }\n+    }\n+\n+    fn with_filetype(t: &str) -> WindowsPath {\n+        let t = ~\".\" + str::from_slice(t);\n+        match self.filestem() {\n+          none => self.with_filename(t),\n+          some(ref s) =>\n+          self.with_filename(*s + t)\n+        }\n+    }\n+\n+    fn dir_path() -> WindowsPath {\n+        if self.components.len() != 0 {\n+            self.pop_component()\n+        } else {\n+            copy self\n+        }\n+    }\n+\n+    fn file_path() -> WindowsPath {\n+        let cs = match self.filename() {\n+          none => ~[],\n+          some(ref f) => ~[copy *f]\n+        };\n+        return WindowsPath { host: none,\n+                             device: none,\n+                             is_absolute: false,\n+                             components: cs }\n+    }\n+\n+    fn push_components(cs: &[~str]) -> WindowsPath {\n+        return WindowsPath { components: self.components + cs, ..self }\n+    }\n+\n+    fn pop_component() -> WindowsPath {\n+        let mut cs = copy self.components;\n+        if cs.len() != 0 {\n+            vec::pop(cs);\n+        }\n+        return WindowsPath { components: cs, ..self }\n+    }\n+}\n+\n+// Various windows helpers, and tests for the impl.\n+mod windows {\n+\n+    #[inline(always)]\n+    fn is_sep(u: u8) -> bool {\n+        u == '/' as u8 || u == '\\\\' as u8\n+    }\n+\n+    fn extract_unc_prefix(s: &str) -> option<(~str,~str)> {\n+        if (s.len() > 1 &&\n+            s[0] == '\\\\' as u8 &&\n+            s[1] == '\\\\' as u8) {\n+            let mut i = 2;\n+            while i < s.len() {\n+                if s[i] == '\\\\' as u8 {\n+                    let pre = s.slice(2, i);\n+                    let rest = s.slice(i, s.len());\n+                    return some((pre, rest));\n+                }\n+                i += 1;\n+            }\n+        }\n+        none\n+    }\n+\n+    fn extract_drive_prefix(s: &str) -> option<(~str,~str)> {\n+        if (s.len() > 1 &&\n+            libc::isalpha(s[0] as libc::c_int) != 0 &&\n+            s[1] == ':' as u8) {\n+            let rest = if s.len() == 2 { ~\"\" } else { s.slice(2, s.len()) };\n+            return some((s.slice(0,1), rest));\n+        }\n+        none\n+    }\n+\n+    #[test]\n+    fn test_extract_unc_prefixes() {\n+        assert extract_unc_prefix(\"\\\\\\\\\") == none;\n+        assert extract_unc_prefix(\"\\\\\\\\hi\") == none;\n+        assert extract_unc_prefix(\"\\\\\\\\hi\\\\\") == some((~\"hi\", ~\"\\\\\"));\n+        assert extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n+            some((~\"hi\", ~\"\\\\there\"));\n+        assert extract_unc_prefix(\"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n+            some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n+    }\n+\n+    #[test]\n+    fn test_extract_drive_prefixes() {\n+        assert extract_drive_prefix(\"c\") == none;\n+        assert extract_drive_prefix(\"c:\") == some((~\"c\", ~\"\"));\n+        assert extract_drive_prefix(\"d:\") == some((~\"d\", ~\"\"));\n+        assert extract_drive_prefix(\"z:\") == some((~\"z\", ~\"\"));\n+        assert extract_drive_prefix(\"c:\\\\hi\") == some((~\"c\", ~\"\\\\hi\"));\n+        assert extract_drive_prefix(\"d:hi\") == some((~\"d\", ~\"hi\"));\n+        assert extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n+            some((~\"c\", ~\"hi\\\\there.txt\"));\n+        assert extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n+            some((~\"c\", ~\"\\\\hi\\\\there.txt\"));\n+    }\n+\n+    #[test]\n+    fn test_windows_paths() {\n+        fn mk(s: &str) -> WindowsPath { from_str::<WindowsPath>(s) }\n+        fn t(wp: &WindowsPath, s: &str) {\n+            let ss = wp.to_str();\n+            let sss = str::from_slice(s);\n+            if (ss != sss) {\n+                debug!(\"got %s\", ss);\n+                debug!(\"expected %s\", sss);\n+                assert ss == sss;\n+            }\n+        }\n+\n+        t(&(mk(\"hi\")), \"hi\");\n+        t(&(mk(\"hi/there\")), \"hi\\\\there\");\n+        t(&(mk(\"hi/there.txt\")), \"hi\\\\there.txt\");\n+\n+        t(&(mk(\"there.txt\")\n+            .with_filetype(\"o\")), \"there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")), \"hi\\\\there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"c:\\\\program files A\")),\n+          \"c:\\\\program files A\\\\there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"c:\\\\program files B\\\\\")),\n+          \"c:\\\\program files B\\\\there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"c:\\\\program files C\\\\/\")),\n+            \"c:\\\\program files C\\\\there.o\");\n+\n+        t(&(mk(\"c:\\\\program files (x86)\\\\rust\")\n+            .push_components([~\"lib\", ~\"thingy.dll\"])\n+            .with_filename(\"librustc.dll\")),\n+          \"c:\\\\program files (x86)\\\\rust\\\\lib\\\\librustc.dll\");\n+\n+    }\n+\n+}"}]}