{"sha": "2d691170885b32502b391b8b1a0d54d2419a5653", "node_id": "C_kwDOAAsO6NoAKDJkNjkxMTcwODg1YjMyNTAyYjM5MWI4YjFhMGQ1NGQyNDE5YTU2NTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-14T13:24:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-14T13:24:34Z"}, "message": "Auto merge of #96345 - petrochenkov:linclean, r=notriddle\n\nrustdoc: Cleanup doc link resolution\n\nSee individual commits for specific changes", "tree": {"sha": "f9303fed0a9aa8d25c32da76be940043a6239e9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9303fed0a9aa8d25c32da76be940043a6239e9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d691170885b32502b391b8b1a0d54d2419a5653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d691170885b32502b391b8b1a0d54d2419a5653", "html_url": "https://github.com/rust-lang/rust/commit/2d691170885b32502b391b8b1a0d54d2419a5653", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d691170885b32502b391b8b1a0d54d2419a5653/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8019fa0dc08bb0e26d28ce29c3983408ffb2feac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8019fa0dc08bb0e26d28ce29c3983408ffb2feac", "html_url": "https://github.com/rust-lang/rust/commit/8019fa0dc08bb0e26d28ce29c3983408ffb2feac"}, {"sha": "9ba5281c7606c232fb0a9519f2aeda2018fffad4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba5281c7606c232fb0a9519f2aeda2018fffad4", "html_url": "https://github.com/rust-lang/rust/commit/9ba5281c7606c232fb0a9519f2aeda2018fffad4"}], "stats": {"total": 763, "additions": 248, "deletions": 515}, "files": [{"sha": "dffec44ddbcc301b94e5f3cdea63fe78236bd4d9", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d691170885b32502b391b8b1a0d54d2419a5653/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d691170885b32502b391b8b1a0d54d2419a5653/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=2d691170885b32502b391b8b1a0d54d2419a5653", "patch": "@@ -1268,7 +1268,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             };\n             let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n             self.r.set_binding_parent_module(binding, parent_scope.module);\n-            self.r.all_macro_rules.insert(ident.name, res);\n             if is_macro_export {\n                 let module = self.r.graph_root;\n                 self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));"}, {"sha": "6c0148a17a1b828655d5cfc54356daa4ce5d9add", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d691170885b32502b391b8b1a0d54d2419a5653/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d691170885b32502b391b8b1a0d54d2419a5653/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=2d691170885b32502b391b8b1a0d54d2419a5653", "patch": "@@ -59,7 +59,7 @@ use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n-use std::{cmp, fmt, mem, ptr};\n+use std::{cmp, fmt, ptr};\n use tracing::debug;\n \n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n@@ -966,8 +966,6 @@ pub struct Resolver<'a> {\n     registered_attrs: FxHashSet<Ident>,\n     registered_tools: RegisteredTools,\n     macro_use_prelude: FxHashMap<Symbol, &'a NameBinding<'a>>,\n-    /// FIXME: The only user of this is a doc link resolution hack for rustdoc.\n-    all_macro_rules: FxHashMap<Symbol, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n@@ -1360,7 +1358,6 @@ impl<'a> Resolver<'a> {\n             registered_attrs,\n             registered_tools,\n             macro_use_prelude: FxHashMap::default(),\n-            all_macro_rules: Default::default(),\n             macro_map: FxHashMap::default(),\n             dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n@@ -1912,11 +1909,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    // For rustdoc.\n-    pub fn take_all_macro_rules(&mut self) -> FxHashMap<Symbol, Res> {\n-        mem::take(&mut self.all_macro_rules)\n-    }\n-\n     /// For rustdoc.\n     /// For local modules returns only reexports, for external modules returns all children.\n     pub fn module_children_or_reexports(&self, def_id: DefId) -> Vec<ModChild> {\n@@ -1928,8 +1920,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// For rustdoc.\n-    pub fn macro_rules_scope(&self, def_id: LocalDefId) -> MacroRulesScopeRef<'a> {\n-        *self.macro_rules_scopes.get(&def_id).expect(\"not a `macro_rules` item\")\n+    pub fn macro_rules_scope(&self, def_id: LocalDefId) -> (MacroRulesScopeRef<'a>, Res) {\n+        let scope = *self.macro_rules_scopes.get(&def_id).expect(\"not a `macro_rules` item\");\n+        match scope.get() {\n+            MacroRulesScope::Binding(mb) => (scope, mb.binding.res()),\n+            _ => unreachable!(),\n+        }\n     }\n \n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate."}, {"sha": "c25a0d3b149971a78372dfd0b2451c7ad6f332d3", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 229, "deletions": 491, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/2d691170885b32502b391b8b1a0d54d2419a5653/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d691170885b32502b391b8b1a0d54d2419a5653/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2d691170885b32502b391b8b1a0d54d2419a5653", "patch": "@@ -11,12 +11,12 @@ use rustc_hir::def::{DefKind, Namespace, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n-use rustc_middle::{bug, span_bug, ty};\n+use rustc_middle::{bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{BytePos, DUMMY_SP};\n+use rustc_span::BytePos;\n use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n@@ -48,18 +48,6 @@ fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     krate\n }\n \n-/// Top-level errors emitted by this pass.\n-enum ErrorKind<'a> {\n-    Resolve(Box<ResolutionFailure<'a>>),\n-    AnchorFailure(AnchorFailure),\n-}\n-\n-impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n-    fn from(err: ResolutionFailure<'a>) -> Self {\n-        ErrorKind::Resolve(box err)\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, Hash)]\n enum Res {\n     Def(DefKind, DefId),\n@@ -97,12 +85,8 @@ impl Res {\n         }\n     }\n \n-    fn as_hir_res(self) -> Option<rustc_hir::def::Res> {\n-        match self {\n-            Res::Def(kind, id) => Some(rustc_hir::def::Res::Def(kind, id)),\n-            // FIXME: maybe this should handle the subset of PrimitiveType that fits into hir::PrimTy?\n-            Res::Primitive(_) => None,\n-        }\n+    fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Res {\n+        Res::Def(tcx.def_kind(def_id), def_id)\n     }\n \n     /// Used for error reporting.\n@@ -160,8 +144,25 @@ impl TryFrom<ResolveRes> for Res {\n     }\n }\n \n-/// A link failed to resolve.\n-#[derive(Clone, Debug)]\n+/// The link failed to resolve. [`resolution_failure`] should look to see if there's\n+/// a more helpful error that can be given.\n+#[derive(Debug)]\n+struct UnresolvedPath<'a> {\n+    /// Item on which the link is resolved, used for resolving `Self`.\n+    item_id: ItemId,\n+    /// The scope the link was resolved in.\n+    module_id: DefId,\n+    /// If part of the link resolved, this has the `Res`.\n+    ///\n+    /// In `[std::io::Error::x]`, `std::io::Error` would be a partial resolution.\n+    partial_res: Option<Res>,\n+    /// The remaining unresolved path segments.\n+    ///\n+    /// In `[std::io::Error::x]`, `x` would be unresolved.\n+    unresolved: Cow<'a, str>,\n+}\n+\n+#[derive(Debug)]\n enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n     WrongNamespace {\n@@ -173,35 +174,10 @@ enum ResolutionFailure<'a> {\n         /// even though `Result`'s actual namespace is [`Namespace::TypeNS`].\n         expected_ns: Namespace,\n     },\n-    /// The link failed to resolve. [`resolution_failure`] should look to see if there's\n-    /// a more helpful error that can be given.\n-    NotResolved {\n-        /// Item on which the link is resolved, used for resolving `Self`.\n-        item_id: ItemId,\n-        /// The scope the link was resolved in.\n-        module_id: DefId,\n-        /// If part of the link resolved, this has the `Res`.\n-        ///\n-        /// In `[std::io::Error::x]`, `std::io::Error` would be a partial resolution.\n-        partial_res: Option<Res>,\n-        /// The remaining unresolved path segments.\n-        ///\n-        /// In `[std::io::Error::x]`, `x` would be unresolved.\n-        unresolved: Cow<'a, str>,\n-    },\n-    /// This happens when rustdoc can't determine the parent scope for an item.\n-    /// It is always a bug in rustdoc.\n-    NoParentItem,\n-    /// This link has malformed generic parameters; e.g., the angle brackets are unbalanced.\n-    MalformedGenerics(MalformedGenerics),\n-    /// Used to communicate that this should be ignored, but shouldn't be reported to the user.\n-    ///\n-    /// This happens when there is no disambiguator and one of the namespaces\n-    /// failed to resolve.\n-    Dummy,\n+    NotResolved(UnresolvedPath<'a>),\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n enum MalformedGenerics {\n     /// This link has unbalanced angle brackets.\n     ///\n@@ -242,35 +218,6 @@ enum MalformedGenerics {\n     EmptyAngleBrackets,\n }\n \n-impl ResolutionFailure<'_> {\n-    /// This resolved fully (not just partially) but is erroneous for some other reason\n-    ///\n-    /// Returns the full resolution of the link, if present.\n-    fn full_res(&self) -> Option<Res> {\n-        match self {\n-            Self::WrongNamespace { res, expected_ns: _ } => Some(*res),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-enum AnchorFailure {\n-    /// User error: `[std#x#y]` is not valid\n-    MultipleAnchors,\n-    /// The anchor provided by the user conflicts with Rustdoc's generated anchor.\n-    ///\n-    /// This is an unfortunate state of affairs. Not every item that can be\n-    /// linked to has its own page; sometimes it is a subheading within a page,\n-    /// like for associated items. In those cases, rustdoc uses an anchor to\n-    /// link to the subheading. Since you can't have two anchors for the same\n-    /// link, Rustdoc disallows having a user-specified anchor.\n-    ///\n-    /// Most of the time this is fine, because you can just link to the page of\n-    /// the item if you want to provide your own anchor.\n-    RustdocAnchorConflict(Res),\n-}\n-\n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n crate enum UrlFragment {\n     Item(ItemFragment),\n@@ -302,24 +249,32 @@ crate enum FragmentKind {\n     VariantField,\n }\n \n-impl ItemFragment {\n-    /// Create a fragment for an associated item.\n-    #[instrument(level = \"debug\")]\n-    fn from_assoc_item(item: &ty::AssocItem) -> Self {\n-        let def_id = item.def_id;\n-        match item.kind {\n-            ty::AssocKind::Fn => {\n-                if item.defaultness.has_value() {\n-                    ItemFragment(FragmentKind::Method, def_id)\n+impl FragmentKind {\n+    fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> FragmentKind {\n+        match tcx.def_kind(def_id) {\n+            DefKind::AssocFn => {\n+                if tcx.associated_item(def_id).defaultness.has_value() {\n+                    FragmentKind::Method\n                 } else {\n-                    ItemFragment(FragmentKind::TyMethod, def_id)\n+                    FragmentKind::TyMethod\n                 }\n             }\n-            ty::AssocKind::Const => ItemFragment(FragmentKind::AssociatedConstant, def_id),\n-            ty::AssocKind::Type => ItemFragment(FragmentKind::AssociatedType, def_id),\n+            DefKind::AssocConst => FragmentKind::AssociatedConstant,\n+            DefKind::AssocTy => FragmentKind::AssociatedType,\n+            DefKind::Variant => FragmentKind::Variant,\n+            DefKind::Field => {\n+                if tcx.def_kind(tcx.parent(def_id)) == DefKind::Variant {\n+                    FragmentKind::VariantField\n+                } else {\n+                    FragmentKind::StructField\n+                }\n+            }\n+            kind => bug!(\"unexpected associated item kind: {:?}\", kind),\n         }\n     }\n+}\n \n+impl ItemFragment {\n     /// Render the fragment, including the leading `#`.\n     crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n         write!(s, \"#\")?;\n@@ -389,9 +344,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         item_id: ItemId,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n+    ) -> Result<(Res, DefId), UnresolvedPath<'path>> {\n         let tcx = self.cx.tcx;\n-        let no_res = || ResolutionFailure::NotResolved {\n+        let no_res = || UnresolvedPath {\n             item_id,\n             module_id,\n             partial_res: None,\n@@ -418,42 +373,27 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let ty_res = self.resolve_path(&path, TypeNS, item_id, module_id).ok_or_else(no_res)?;\n \n         match ty_res {\n-            Res::Def(DefKind::Enum, did) => {\n-                if tcx\n-                    .inherent_impls(did)\n-                    .iter()\n-                    .flat_map(|imp| tcx.associated_items(*imp).in_definition_order())\n-                    .any(|item| item.name == variant_name)\n-                {\n-                    // This is just to let `fold_item` know that this shouldn't be considered;\n-                    // it's a bug for the error to make it to the user\n-                    return Err(ResolutionFailure::Dummy.into());\n-                }\n-                match tcx.type_of(did).kind() {\n-                    ty::Adt(def, _) if def.is_enum() => {\n-                        if let Some(field) = def.all_fields().find(|f| f.name == variant_field_name)\n-                        {\n-                            Ok((ty_res, Some(ItemFragment(FragmentKind::VariantField, field.did))))\n-                        } else {\n-                            Err(ResolutionFailure::NotResolved {\n-                                item_id,\n-                                module_id,\n-                                partial_res: Some(Res::Def(DefKind::Enum, def.did())),\n-                                unresolved: variant_field_name.to_string().into(),\n-                            }\n-                            .into())\n-                        }\n+            Res::Def(DefKind::Enum, did) => match tcx.type_of(did).kind() {\n+                ty::Adt(def, _) if def.is_enum() => {\n+                    if let Some(field) = def.all_fields().find(|f| f.name == variant_field_name) {\n+                        Ok((ty_res, field.did))\n+                    } else {\n+                        Err(UnresolvedPath {\n+                            item_id,\n+                            module_id,\n+                            partial_res: Some(Res::Def(DefKind::Enum, def.did())),\n+                            unresolved: variant_field_name.to_string().into(),\n+                        })\n                     }\n-                    _ => unreachable!(),\n                 }\n-            }\n-            _ => Err(ResolutionFailure::NotResolved {\n+                _ => unreachable!(),\n+            },\n+            _ => Err(UnresolvedPath {\n                 item_id,\n                 module_id,\n                 partial_res: Some(ty_res),\n                 unresolved: variant_name.to_string().into(),\n-            }\n-            .into()),\n+            }),\n         }\n     }\n \n@@ -463,35 +403,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, ItemFragment)> {\n+    ) -> Option<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n         prim_ty.impls(tcx).find_map(|impl_| {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n-                .map(|item| {\n-                    let fragment = ItemFragment::from_assoc_item(item);\n-                    (Res::Primitive(prim_ty), fragment)\n-                })\n-        })\n-    }\n-\n-    /// Resolves a string as a macro.\n-    ///\n-    /// FIXME(jynelson): Can this be unified with `resolve()`?\n-    fn resolve_macro(\n-        &self,\n-        path_str: &'a str,\n-        item_id: ItemId,\n-        module_id: DefId,\n-    ) -> Result<Res, ResolutionFailure<'a>> {\n-        self.resolve_path(path_str, MacroNS, item_id, module_id).ok_or_else(|| {\n-            ResolutionFailure::NotResolved {\n-                item_id,\n-                module_id,\n-                partial_res: None,\n-                unresolved: path_str.into(),\n-            }\n+                .map(|item| (Res::Primitive(prim_ty), item.def_id))\n         })\n     }\n \n@@ -585,43 +503,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         item_id: ItemId,\n         module_id: DefId,\n-        user_fragment: &Option<String>,\n-    ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n-        let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, item_id, module_id)?;\n-        let chosen_fragment = match (user_fragment, rustdoc_fragment) {\n-            (Some(_), Some(r_frag)) => {\n-                let diag_res = match r_frag {\n-                    ItemFragment(_, did) => Res::Def(self.cx.tcx.def_kind(did), did),\n-                };\n-                let failure = AnchorFailure::RustdocAnchorConflict(diag_res);\n-                return Err(ErrorKind::AnchorFailure(failure));\n-            }\n-            (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n-            (None, Some(r_frag)) => Some(UrlFragment::Item(r_frag)),\n-            (None, None) => None,\n-        };\n-        Ok((res, chosen_fragment))\n-    }\n-\n-    fn resolve_inner<'path>(\n-        &mut self,\n-        path_str: &'path str,\n-        ns: Namespace,\n-        item_id: ItemId,\n-        module_id: DefId,\n-    ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n+    ) -> Result<(Res, Option<DefId>), UnresolvedPath<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n-            match res {\n-                // FIXME(#76467): make this fallthrough to lookup the associated\n-                // item a separate function.\n-                Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => assert_eq!(ns, ValueNS),\n-                Res::Def(DefKind::AssocTy, _) => assert_eq!(ns, TypeNS),\n-                Res::Def(DefKind::Variant, _) => {\n-                    return handle_variant(self.cx, res);\n-                }\n-                // Not a trait item; just return what we found.\n-                _ => return Ok((res, None)),\n-            }\n+            return Ok(match res {\n+                Res::Def(\n+                    DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Variant,\n+                    def_id,\n+                ) => (Res::from_def_id(self.cx.tcx, self.cx.tcx.parent(def_id)), Some(def_id)),\n+                _ => ((res, None)),\n+            });\n+        } else if ns == MacroNS {\n+            return Err(UnresolvedPath {\n+                item_id,\n+                module_id,\n+                partial_res: None,\n+                unresolved: path_str.into(),\n+            });\n         }\n \n         // Try looking for methods and associated items.\n@@ -637,7 +534,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n             .ok_or_else(|| {\n                 debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n-                ResolutionFailure::NotResolved {\n+                UnresolvedPath {\n                     item_id,\n                     module_id,\n                     partial_res: None,\n@@ -652,24 +549,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, item_id, module_id))\n             .and_then(|ty_res| {\n-                let (res, fragment) =\n-                    self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n-\n-                Some(Ok((res, Some(fragment))))\n+                self.resolve_associated_item(ty_res, item_name, ns, module_id).map(Ok)\n             })\n             .unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, item_id, module_id)\n                 } else {\n-                    Err(ResolutionFailure::NotResolved {\n+                    Err(UnresolvedPath {\n                         item_id,\n                         module_id,\n                         partial_res: None,\n                         unresolved: path_root.into(),\n-                    }\n-                    .into())\n+                    })\n                 }\n             })\n+            .map(|(res, def_id)| (res, Some(def_id)))\n     }\n \n     /// Convert a DefId to a Res, where possible.\n@@ -694,7 +588,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ty::FnPtr(_) => Res::Primitive(Fn),\n             ty::Never => Res::Primitive(Never),\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did, .. }, _)), _) | ty::Foreign(did) => {\n-                Res::Def(self.cx.tcx.def_kind(did), did)\n+                Res::from_def_id(self.cx.tcx, did)\n             }\n             ty::Projection(_)\n             | ty::Closure(..)\n@@ -751,23 +645,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, ItemFragment)> {\n+    ) -> Option<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n             Res::Primitive(prim) => {\n                 self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n-                    let assoc_item = self\n-                        .primitive_type_to_ty(prim)\n+                    self.primitive_type_to_ty(prim)\n                         .map(|ty| {\n                             resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n                         })\n-                        .flatten();\n-\n-                    assoc_item.map(|item| {\n-                        let fragment = ItemFragment::from_assoc_item(&item);\n-                        (root_res, fragment)\n-                    })\n+                        .flatten()\n+                        .map(|item| (root_res, item.def_id))\n                 })\n             }\n             Res::Def(DefKind::TyAlias, did) => {\n@@ -788,10 +677,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::Adt(adt_def, _) => {\n                             for variant in adt_def.variants() {\n                                 if variant.name == item_name {\n-                                    return Some((\n-                                        root_res,\n-                                        ItemFragment(FragmentKind::Variant, variant.def_id),\n-                                    ));\n+                                    return Some((root_res, variant.def_id));\n                                 }\n                             }\n                         }\n@@ -832,8 +718,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 debug!(\"got associated item {:?}\", assoc_item);\n \n                 if let Some(item) = assoc_item {\n-                    let fragment = ItemFragment::from_assoc_item(&item);\n-                    return Some((root_res, fragment));\n+                    return Some((root_res, item.def_id));\n                 }\n \n                 if ns != Namespace::ValueNS {\n@@ -861,59 +746,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 };\n                 let field =\n                     def.non_enum_variant().fields.iter().find(|item| item.name == item_name)?;\n-                Some((root_res, ItemFragment(FragmentKind::StructField, field.did)))\n+                Some((root_res, field.did))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n-                    let fragment = ItemFragment::from_assoc_item(item);\n                     let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                    (res, fragment)\n+                    (res, item.def_id)\n                 }),\n             _ => None,\n         }\n     }\n+}\n \n-    /// Used for reporting better errors.\n-    ///\n-    /// Returns whether the link resolved 'fully' in another namespace.\n-    /// 'fully' here means that all parts of the link resolved, not just some path segments.\n-    /// This returns the `Res` even if it was erroneous for some reason\n-    /// (such as having invalid URL fragments or being in the wrong namespace).\n-    fn check_full_res(\n-        &mut self,\n-        ns: Namespace,\n-        path_str: &str,\n-        item_id: ItemId,\n-        module_id: DefId,\n-        extra_fragment: &Option<String>,\n-    ) -> Option<Res> {\n-        // resolve() can't be used for macro namespace\n-        let result = match ns {\n-            Namespace::MacroNS => self\n-                .resolve_macro(path_str, item_id, module_id)\n-                .map(|res| (res, None))\n-                .map_err(ErrorKind::from),\n-            Namespace::TypeNS | Namespace::ValueNS => {\n-                self.resolve(path_str, ns, item_id, module_id, extra_fragment)\n-            }\n-        };\n-\n-        let res = match result {\n-            Ok((res, frag)) => {\n-                if let Some(UrlFragment::Item(ItemFragment(_, id))) = frag {\n-                    Some(Res::Def(self.cx.tcx.def_kind(id), id))\n-                } else {\n-                    Some(res)\n-                }\n-            }\n-            Err(ErrorKind::Resolve(box kind)) => kind.full_res(),\n-            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res))) => Some(res),\n-            Err(ErrorKind::AnchorFailure(AnchorFailure::MultipleAnchors)) => None,\n-        };\n-        res\n-    }\n+fn full_res(tcx: TyCtxt<'_>, (base, assoc_item): (Res, Option<DefId>)) -> Res {\n+    assoc_item.map_or(base, |def_id| Res::from_def_id(tcx, def_id))\n }\n \n /// Look to see if a resolved item has an associated item named `item_name`.\n@@ -1093,14 +941,23 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n }\n \n enum PreprocessingError {\n-    Anchor(AnchorFailure),\n+    /// User error: `[std#x#y]` is not valid\n+    MultipleAnchors,\n     Disambiguator(Range<usize>, String),\n-    Resolution(ResolutionFailure<'static>, String, Option<Disambiguator>),\n+    MalformedGenerics(MalformedGenerics, String),\n }\n \n-impl From<AnchorFailure> for PreprocessingError {\n-    fn from(err: AnchorFailure) -> Self {\n-        Self::Anchor(err)\n+impl PreprocessingError {\n+    fn report(&self, cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n+        match self {\n+            PreprocessingError::MultipleAnchors => report_multiple_anchors(cx, diag_info),\n+            PreprocessingError::Disambiguator(range, msg) => {\n+                disambiguator_error(cx, diag_info, range.clone(), msg)\n+            }\n+            PreprocessingError::MalformedGenerics(err, path_str) => {\n+                report_malformed_generics(cx, diag_info, *err, path_str)\n+            }\n+        }\n     }\n }\n \n@@ -1145,7 +1002,7 @@ fn preprocess_link(\n     let extra_fragment = parts.next();\n     if parts.next().is_some() {\n         // A valid link can't have multiple #'s\n-        return Some(Err(AnchorFailure::MultipleAnchors.into()));\n+        return Some(Err(PreprocessingError::MultipleAnchors));\n     }\n \n     // Parse and strip the disambiguator from the link, if present.\n@@ -1173,13 +1030,9 @@ fn preprocess_link(\n     let path_str = if path_str.contains(['<', '>'].as_slice()) {\n         match strip_generics_from_path(path_str) {\n             Ok(path) => path,\n-            Err(err_kind) => {\n+            Err(err) => {\n                 debug!(\"link has malformed generics: {}\", path_str);\n-                return Some(Err(PreprocessingError::Resolution(\n-                    err_kind,\n-                    path_str.to_owned(),\n-                    disambiguator,\n-                )));\n+                return Some(Err(PreprocessingError::MalformedGenerics(err, path_str.to_owned())));\n             }\n         }\n     } else {\n@@ -1229,32 +1082,10 @@ impl LinkCollector<'_, '_> {\n             link_range: ori_link.range.clone(),\n         };\n \n-        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } = match pp_link\n-        {\n-            Ok(x) => x,\n-            Err(err) => {\n-                match err {\n-                    PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, *err),\n-                    PreprocessingError::Disambiguator(range, msg) => {\n-                        disambiguator_error(self.cx, diag_info, range.clone(), msg)\n-                    }\n-                    PreprocessingError::Resolution(err, path_str, disambiguator) => {\n-                        resolution_failure(\n-                            self,\n-                            diag_info,\n-                            path_str,\n-                            *disambiguator,\n-                            smallvec![err.clone()],\n-                        );\n-                    }\n-                }\n-                return None;\n-            }\n-        };\n+        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } =\n+            pp_link.as_ref().map_err(|err| err.report(self.cx, diag_info.clone())).ok()?;\n         let disambiguator = *disambiguator;\n \n-        let inner_docs = item.inner_docs(self.cx.tcx);\n-\n         // In order to correctly resolve intra-doc links we need to\n         // pick a base AST node to work from.  If the documentation for\n         // this module came from an inner comment (//!) then we anchor\n@@ -1266,21 +1097,10 @@ impl LinkCollector<'_, '_> {\n         // we've already pushed this node onto the resolution stack but\n         // for outer comments we explicitly try and resolve against the\n         // parent_node first.\n+        let inner_docs = item.inner_docs(self.cx.tcx);\n         let base_node =\n             if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n-\n-        let Some(module_id) = base_node else {\n-            // This is a bug.\n-            debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-            resolution_failure(\n-                self,\n-                diag_info,\n-                path_str,\n-                disambiguator,\n-                smallvec![ResolutionFailure::NoParentItem],\n-            );\n-            return None;\n-        };\n+        let module_id = base_node.expect(\"doc link without parent module\");\n \n         let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n@@ -1504,7 +1324,21 @@ impl LinkCollector<'_, '_> {\n             }\n         }\n \n-        let res = self.resolve_with_disambiguator(&key, diag);\n+        let res = self.resolve_with_disambiguator(&key, diag.clone()).and_then(|(res, def_id)| {\n+            let fragment = match (&key.extra_fragment, def_id) {\n+                (Some(_), Some(def_id)) => {\n+                    report_anchor_conflict(self.cx, diag, Res::from_def_id(self.cx.tcx, def_id));\n+                    return None;\n+                }\n+                (Some(u_frag), None) => Some(UrlFragment::UserWritten(u_frag.clone())),\n+                (None, Some(def_id)) => Some(UrlFragment::Item(ItemFragment(\n+                    FragmentKind::from_def_id(self.cx.tcx, def_id),\n+                    def_id,\n+                ))),\n+                (None, None) => None,\n+            };\n+            Some((res, fragment))\n+        });\n \n         // Cache only if resolved successfully - don't silence duplicate errors\n         if let Some(res) = res {\n@@ -1529,103 +1363,59 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-    ) -> Option<(Res, Option<UrlFragment>)> {\n+    ) -> Option<(Res, Option<DefId>)> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n         let item_id = key.item_id;\n         let base_node = key.module_id;\n-        let extra_fragment = &key.extra_fragment;\n \n         match disambiguator.map(Disambiguator::ns) {\n-            Some(expected_ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, expected_ns, item_id, base_node, extra_fragment) {\n+            Some(expected_ns) => {\n+                match self.resolve(path_str, expected_ns, item_id, base_node) {\n                     Ok(res) => Some(res),\n-                    Err(ErrorKind::Resolve(box mut kind)) => {\n+                    Err(err) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n-                        if kind.full_res().is_none() {\n-                            let other_ns = if expected_ns == ValueNS { TypeNS } else { ValueNS };\n-                            // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n-                            // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n-                            for new_ns in [other_ns, MacroNS] {\n-                                if let Some(res) = self.check_full_res(\n-                                    new_ns,\n-                                    path_str,\n-                                    item_id,\n-                                    base_node,\n-                                    extra_fragment,\n-                                ) {\n-                                    kind = ResolutionFailure::WrongNamespace { res, expected_ns };\n+                        // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`.\n+                        // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach.\n+                        let mut err = ResolutionFailure::NotResolved(err);\n+                        for other_ns in [TypeNS, ValueNS, MacroNS] {\n+                            if other_ns != expected_ns {\n+                                if let Ok(res) =\n+                                    self.resolve(path_str, other_ns, item_id, base_node)\n+                                {\n+                                    err = ResolutionFailure::WrongNamespace {\n+                                        res: full_res(self.cx.tcx, res),\n+                                        expected_ns,\n+                                    };\n                                     break;\n                                 }\n                             }\n                         }\n-                        resolution_failure(self, diag, path_str, disambiguator, smallvec![kind]);\n+                        resolution_failure(self, diag, path_str, disambiguator, smallvec![err]);\n                         // This could just be a normal link or a broken link\n                         // we could potentially check if something is\n                         // \"intra-doc-link-like\" and warn in that case.\n                         None\n                     }\n-                    Err(ErrorKind::AnchorFailure(msg)) => {\n-                        anchor_failure(self.cx, diag, msg);\n-                        None\n-                    }\n                 }\n             }\n             None => {\n                 // Try everything!\n-                let mut candidates = PerNS {\n-                    macro_ns: self\n-                        .resolve_macro(path_str, item_id, base_node)\n-                        .map(|res| (res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n-                    type_ns: match self.resolve(\n-                        path_str,\n-                        TypeNS,\n-                        item_id,\n-                        base_node,\n-                        extra_fragment,\n-                    ) {\n-                        Ok(res) => {\n-                            debug!(\"got res in TypeNS: {:?}\", res);\n-                            Ok(res)\n-                        }\n-                        Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, diag, msg);\n-                            return None;\n-                        }\n-                        Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                    },\n-                    value_ns: match self.resolve(\n-                        path_str,\n-                        ValueNS,\n-                        item_id,\n-                        base_node,\n-                        extra_fragment,\n-                    ) {\n-                        Ok(res) => Ok(res),\n-                        Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, diag, msg);\n-                            return None;\n-                        }\n-                        Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                    }\n-                    .and_then(|(res, fragment)| {\n-                        // Constructors are picked up in the type namespace.\n+                let mut candidate = |ns| {\n+                    self.resolve(path_str, ns, item_id, base_node)\n+                        .map_err(ResolutionFailure::NotResolved)\n+                };\n+\n+                let candidates = PerNS {\n+                    macro_ns: candidate(MacroNS),\n+                    type_ns: candidate(TypeNS),\n+                    value_ns: candidate(ValueNS).and_then(|(res, def_id)| {\n                         match res {\n+                            // Constructors are picked up in the type namespace.\n                             Res::Def(DefKind::Ctor(..), _) => {\n                                 Err(ResolutionFailure::WrongNamespace { res, expected_ns: TypeNS })\n                             }\n-                            _ => {\n-                                match (fragment, extra_fragment.clone()) {\n-                                    (Some(fragment), Some(_)) => {\n-                                        // Shouldn't happen but who knows?\n-                                        Ok((res, Some(fragment)))\n-                                    }\n-                                    (fragment, None) => Ok((res, fragment)),\n-                                    (None, fragment) => {\n-                                        Ok((res, fragment.map(UrlFragment::UserWritten)))\n-                                    }\n-                                }\n-                            }\n+                            _ => Ok((res, def_id)),\n                         }\n                     }),\n                 };\n@@ -1649,38 +1439,17 @@ impl LinkCollector<'_, '_> {\n                 } else if len == 2 && is_derive_trait_collision(&candidates) {\n                     Some(candidates.type_ns.unwrap())\n                 } else {\n-                    if is_derive_trait_collision(&candidates) {\n-                        candidates.macro_ns = Err(ResolutionFailure::Dummy);\n-                    }\n+                    let ignore_macro = is_derive_trait_collision(&candidates);\n                     // If we're reporting an ambiguity, don't mention the namespaces that failed\n-                    let candidates = candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n+                    let mut candidates =\n+                        candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n+                    if ignore_macro {\n+                        candidates.macro_ns = None;\n+                    }\n                     ambiguity_error(self.cx, diag, path_str, candidates.present_items().collect());\n                     None\n                 }\n             }\n-            Some(MacroNS) => {\n-                match self.resolve_macro(path_str, item_id, base_node) {\n-                    Ok(res) => Some((res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n-                    Err(mut kind) => {\n-                        // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n-                        for ns in [TypeNS, ValueNS] {\n-                            if let Some(res) = self.check_full_res(\n-                                ns,\n-                                path_str,\n-                                item_id,\n-                                base_node,\n-                                extra_fragment,\n-                            ) {\n-                                kind =\n-                                    ResolutionFailure::WrongNamespace { res, expected_ns: MacroNS };\n-                                break;\n-                            }\n-                        }\n-                        resolution_failure(self, diag, path_str, disambiguator, smallvec![kind]);\n-                        None\n-                    }\n-                }\n-            }\n         }\n     }\n }\n@@ -1995,12 +1764,12 @@ fn resolution_failure(\n                 }\n                 variants_seen.push(variant);\n \n-                if let ResolutionFailure::NotResolved {\n+                if let ResolutionFailure::NotResolved(UnresolvedPath {\n                     item_id,\n                     module_id,\n                     partial_res,\n                     unresolved,\n-                } = &mut failure\n+                }) = &mut failure\n                 {\n                     use DefKind::*;\n \n@@ -2026,11 +1795,9 @@ fn resolution_failure(\n                         };\n                         name = start;\n                         for ns in [TypeNS, ValueNS, MacroNS] {\n-                            if let Some(res) =\n-                                collector.check_full_res(ns, start, item_id, module_id, &None)\n-                            {\n+                            if let Ok(res) = collector.resolve(start, ns, item_id, module_id) {\n                                 debug!(\"found partial_res={:?}\", res);\n-                                *partial_res = Some(res);\n+                                *partial_res = Some(full_res(collector.cx.tcx, res));\n                                 *unresolved = end.into();\n                                 break 'outer;\n                             }\n@@ -2130,7 +1897,6 @@ fn resolution_failure(\n                 }\n                 let note = match failure {\n                     ResolutionFailure::NotResolved { .. } => unreachable!(\"handled above\"),\n-                    ResolutionFailure::Dummy => continue,\n                     ResolutionFailure::WrongNamespace { res, expected_ns } => {\n                         suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n \n@@ -2140,38 +1906,6 @@ fn resolution_failure(\n                             expected_ns.descr()\n                         )\n                     }\n-                    ResolutionFailure::NoParentItem => {\n-                        // FIXME(eddyb) this doesn't belong here, whatever made\n-                        // the `ResolutionFailure::NoParentItem` should emit an\n-                        // immediate or delayed `span_bug` about the issue.\n-                        tcx.sess.delay_span_bug(\n-                            sp.unwrap_or(DUMMY_SP),\n-                            \"intra-doc link missing parent item\",\n-                        );\n-\n-                        \"BUG: all intra-doc links should have a parent item\".to_owned()\n-                    }\n-                    ResolutionFailure::MalformedGenerics(variant) => match variant {\n-                        MalformedGenerics::UnbalancedAngleBrackets => {\n-                            String::from(\"unbalanced angle brackets\")\n-                        }\n-                        MalformedGenerics::MissingType => {\n-                            String::from(\"missing type for generic parameters\")\n-                        }\n-                        MalformedGenerics::HasFullyQualifiedSyntax => {\n-                            diag.note(\"see https://github.com/rust-lang/rust/issues/74563 for more information\");\n-                            String::from(\"fully-qualified syntax is unsupported\")\n-                        }\n-                        MalformedGenerics::InvalidPathSeparator => {\n-                            String::from(\"has invalid path separator\")\n-                        }\n-                        MalformedGenerics::TooManyAngleBrackets => {\n-                            String::from(\"too many angle brackets\")\n-                        }\n-                        MalformedGenerics::EmptyAngleBrackets => {\n-                            String::from(\"empty angle brackets\")\n-                        }\n-                    },\n                 };\n                 if let Some(span) = sp {\n                     diag.span_label(span, &note);\n@@ -2183,22 +1917,24 @@ fn resolution_failure(\n     );\n }\n \n-/// Report an anchor failure.\n-fn anchor_failure(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, failure: AnchorFailure) {\n-    let (msg, anchor_idx) = match failure {\n-        AnchorFailure::MultipleAnchors => {\n-            (format!(\"`{}` contains multiple anchors\", diag_info.ori_link), 1)\n-        }\n-        AnchorFailure::RustdocAnchorConflict(res) => (\n-            format!(\n-                \"`{}` contains an anchor, but links to {kind}s are already anchored\",\n-                diag_info.ori_link,\n-                kind = res.descr(),\n-            ),\n-            0,\n-        ),\n-    };\n+fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n+    let msg = format!(\"`{}` contains multiple anchors\", diag_info.ori_link);\n+    anchor_failure(cx, diag_info, &msg, 1)\n+}\n+\n+fn report_anchor_conflict(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, res: Res) {\n+    let (link, kind) = (diag_info.ori_link, res.descr());\n+    let msg = format!(\"`{link}` contains an anchor, but links to {kind}s are already anchored\");\n+    anchor_failure(cx, diag_info, &msg, 0)\n+}\n \n+/// Report an anchor failure.\n+fn anchor_failure(\n+    cx: &DocContext<'_>,\n+    diag_info: DiagnosticInfo<'_>,\n+    msg: &str,\n+    anchor_idx: usize,\n+) {\n     report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, |diag, sp| {\n         if let Some(mut sp) = sp {\n             if let Some((fragment_offset, _)) =\n@@ -2208,13 +1944,6 @@ fn anchor_failure(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, failure: A\n             }\n             diag.span_label(sp, \"invalid anchor\");\n         }\n-        if let AnchorFailure::RustdocAnchorConflict(Res::Primitive(_)) = failure {\n-            if let Some(sp) = sp {\n-                span_bug!(sp, \"anchors should be allowed now\");\n-            } else {\n-                bug!(\"anchors should be allowed now\");\n-            }\n-        }\n     });\n }\n \n@@ -2235,6 +1964,40 @@ fn disambiguator_error(\n     });\n }\n \n+fn report_malformed_generics(\n+    cx: &DocContext<'_>,\n+    diag_info: DiagnosticInfo<'_>,\n+    err: MalformedGenerics,\n+    path_str: &str,\n+) {\n+    report_diagnostic(\n+        cx.tcx,\n+        BROKEN_INTRA_DOC_LINKS,\n+        &format!(\"unresolved link to `{}`\", path_str),\n+        &diag_info,\n+        |diag, sp| {\n+            let note = match err {\n+                MalformedGenerics::UnbalancedAngleBrackets => \"unbalanced angle brackets\",\n+                MalformedGenerics::MissingType => \"missing type for generic parameters\",\n+                MalformedGenerics::HasFullyQualifiedSyntax => {\n+                    diag.note(\n+                        \"see https://github.com/rust-lang/rust/issues/74563 for more information\",\n+                    );\n+                    \"fully-qualified syntax is unsupported\"\n+                }\n+                MalformedGenerics::InvalidPathSeparator => \"has invalid path separator\",\n+                MalformedGenerics::TooManyAngleBrackets => \"too many angle brackets\",\n+                MalformedGenerics::EmptyAngleBrackets => \"empty angle brackets\",\n+            };\n+            if let Some(span) = sp {\n+                diag.span_label(span, note);\n+            } else {\n+                diag.note(note);\n+            }\n+        },\n+    );\n+}\n+\n /// Report an ambiguity error, where there were multiple possible resolutions.\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n@@ -2331,17 +2094,6 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n     });\n }\n \n-/// Given an enum variant's res, return the res of its enum and the associated fragment.\n-fn handle_variant(\n-    cx: &DocContext<'_>,\n-    res: Res,\n-) -> Result<(Res, Option<ItemFragment>), ErrorKind<'static>> {\n-    let parent = cx.tcx.parent(res.def_id(cx.tcx));\n-    let parent_def = Res::Def(DefKind::Enum, parent);\n-    let variant = cx.tcx.expect_variant_res(res.as_hir_res().unwrap());\n-    Ok((parent_def, Some(ItemFragment(FragmentKind::Variant, variant.def_id))))\n-}\n-\n /// Resolve a primitive type or value.\n fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<Res> {\n     if ns != TypeNS {\n@@ -2381,7 +2133,7 @@ fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<Res> {\n     Some(Res::Primitive(prim))\n }\n \n-fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<'static>> {\n+fn strip_generics_from_path(path_str: &str) -> Result<String, MalformedGenerics> {\n     let mut stripped_segments = vec![];\n     let mut path = path_str.chars().peekable();\n     let mut segment = Vec::new();\n@@ -2396,24 +2148,18 @@ fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<\n                         stripped_segments.push(stripped_segment);\n                     }\n                 } else {\n-                    return Err(ResolutionFailure::MalformedGenerics(\n-                        MalformedGenerics::InvalidPathSeparator,\n-                    ));\n+                    return Err(MalformedGenerics::InvalidPathSeparator);\n                 }\n             }\n             '<' => {\n                 segment.push(chr);\n \n                 match path.next() {\n                     Some('<') => {\n-                        return Err(ResolutionFailure::MalformedGenerics(\n-                            MalformedGenerics::TooManyAngleBrackets,\n-                        ));\n+                        return Err(MalformedGenerics::TooManyAngleBrackets);\n                     }\n                     Some('>') => {\n-                        return Err(ResolutionFailure::MalformedGenerics(\n-                            MalformedGenerics::EmptyAngleBrackets,\n-                        ));\n+                        return Err(MalformedGenerics::EmptyAngleBrackets);\n                     }\n                     Some(chr) => {\n                         segment.push(chr);\n@@ -2441,16 +2187,10 @@ fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<\n \n     let stripped_path = stripped_segments.join(\"::\");\n \n-    if !stripped_path.is_empty() {\n-        Ok(stripped_path)\n-    } else {\n-        Err(ResolutionFailure::MalformedGenerics(MalformedGenerics::MissingType))\n-    }\n+    if !stripped_path.is_empty() { Ok(stripped_path) } else { Err(MalformedGenerics::MissingType) }\n }\n \n-fn strip_generics_from_path_segment(\n-    segment: Vec<char>,\n-) -> Result<String, ResolutionFailure<'static>> {\n+fn strip_generics_from_path_segment(segment: Vec<char>) -> Result<String, MalformedGenerics> {\n     let mut stripped_segment = String::new();\n     let mut param_depth = 0;\n \n@@ -2465,9 +2205,7 @@ fn strip_generics_from_path_segment(\n             if latest_generics_chunk.contains(\" as \") {\n                 // The segment tries to use fully-qualified syntax, which is currently unsupported.\n                 // Give a helpful error message instead of completely ignoring the angle brackets.\n-                return Err(ResolutionFailure::MalformedGenerics(\n-                    MalformedGenerics::HasFullyQualifiedSyntax,\n-                ));\n+                return Err(MalformedGenerics::HasFullyQualifiedSyntax);\n             }\n         } else {\n             if param_depth == 0 {\n@@ -2482,6 +2220,6 @@ fn strip_generics_from_path_segment(\n         Ok(stripped_segment)\n     } else {\n         // The segment has unbalanced angle brackets, e.g. `Vec<T` or `Vec<T>>`\n-        Err(ResolutionFailure::MalformedGenerics(MalformedGenerics::UnbalancedAngleBrackets))\n+        Err(MalformedGenerics::UnbalancedAngleBrackets)\n     }\n }"}, {"sha": "0ac27087a97824758ea91e17ea018250f0f43844", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2d691170885b32502b391b8b1a0d54d2419a5653/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d691170885b32502b391b8b1a0d54d2419a5653/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=2d691170885b32502b391b8b1a0d54d2419a5653", "patch": "@@ -40,6 +40,7 @@ crate fn early_resolve_intra_doc_links(\n         traits_in_scope: Default::default(),\n         all_traits: Default::default(),\n         all_trait_impls: Default::default(),\n+        all_macro_rules: Default::default(),\n         document_private_items,\n     };\n \n@@ -64,7 +65,7 @@ crate fn early_resolve_intra_doc_links(\n         traits_in_scope: link_resolver.traits_in_scope,\n         all_traits: Some(link_resolver.all_traits),\n         all_trait_impls: Some(link_resolver.all_trait_impls),\n-        all_macro_rules: link_resolver.resolver.take_all_macro_rules(),\n+        all_macro_rules: link_resolver.all_macro_rules,\n     }\n }\n \n@@ -82,6 +83,7 @@ struct EarlyDocLinkResolver<'r, 'ra> {\n     traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     all_traits: Vec<DefId>,\n     all_trait_impls: Vec<DefId>,\n+    all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n     document_private_items: bool,\n }\n \n@@ -134,24 +136,21 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                 // using privacy, private traits and impls from other crates are never documented in\n                 // the current crate, and links in their doc comments are not resolved.\n                 for &def_id in &all_traits {\n-                    if self.resolver.cstore().visibility_untracked(def_id) == Visibility::Public {\n+                    if self.resolver.cstore().visibility_untracked(def_id).is_public() {\n                         self.resolve_doc_links_extern_impl(def_id, false);\n                     }\n                 }\n                 for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n-                    if self.resolver.cstore().visibility_untracked(trait_def_id)\n-                        == Visibility::Public\n+                    if self.resolver.cstore().visibility_untracked(trait_def_id).is_public()\n                         && simplified_self_ty.and_then(|ty| ty.def()).map_or(true, |ty_def_id| {\n-                            self.resolver.cstore().visibility_untracked(ty_def_id)\n-                                == Visibility::Public\n+                            self.resolver.cstore().visibility_untracked(ty_def_id).is_public()\n                         })\n                     {\n                         self.resolve_doc_links_extern_impl(impl_def_id, false);\n                     }\n                 }\n                 for (ty_def_id, impl_def_id) in all_inherent_impls {\n-                    if self.resolver.cstore().visibility_untracked(ty_def_id) == Visibility::Public\n-                    {\n+                    if self.resolver.cstore().visibility_untracked(ty_def_id).is_public() {\n                         self.resolve_doc_links_extern_impl(impl_def_id, true);\n                     }\n                 }\n@@ -178,8 +177,7 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n             self.resolver.cstore().associated_item_def_ids_untracked(def_id, self.sess),\n         );\n         for assoc_def_id in assoc_item_def_ids {\n-            if !is_inherent\n-                || self.resolver.cstore().visibility_untracked(assoc_def_id) == Visibility::Public\n+            if !is_inherent || self.resolver.cstore().visibility_untracked(assoc_def_id).is_public()\n             {\n                 self.resolve_doc_links_extern_outer(assoc_def_id, def_id);\n             }\n@@ -279,7 +277,7 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n \n         for child in self.resolver.module_children_or_reexports(module_id) {\n             // This condition should give a superset of `denied` from `fn clean_use_statement`.\n-            if child.vis == Visibility::Public\n+            if child.vis.is_public()\n                 || self.document_private_items\n                     && child.vis != Visibility::Restricted(module_id)\n                     && module_id.is_local()\n@@ -343,8 +341,10 @@ impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n                     self.all_trait_impls.push(self.resolver.local_def_id(item.id).to_def_id());\n                 }\n                 ItemKind::MacroDef(macro_def) if macro_def.macro_rules => {\n-                    self.parent_scope.macro_rules =\n+                    let (macro_rules_scope, res) =\n                         self.resolver.macro_rules_scope(self.resolver.local_def_id(item.id));\n+                    self.parent_scope.macro_rules = macro_rules_scope;\n+                    self.all_macro_rules.insert(item.ident.name, res);\n                 }\n                 _ => {}\n             }"}]}