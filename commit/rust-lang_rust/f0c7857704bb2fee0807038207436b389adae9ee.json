{"sha": "f0c7857704bb2fee0807038207436b389adae9ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYzc4NTc3MDRiYjJmZWUwODA3MDM4MjA3NDM2YjM4OWFkYWU5ZWU=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-15T19:54:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T11:17:01Z"}, "message": "Separate libfmt_macros module", "tree": {"sha": "ef777944c2394fd26411902598482d575227c08b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef777944c2394fd26411902598482d575227c08b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0c7857704bb2fee0807038207436b389adae9ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0c7857704bb2fee0807038207436b389adae9ee", "html_url": "https://github.com/rust-lang/rust/commit/f0c7857704bb2fee0807038207436b389adae9ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0c7857704bb2fee0807038207436b389adae9ee/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c77d3ae9f28fc5831c84c17b44c2884f2d78217d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c77d3ae9f28fc5831c84c17b44c2884f2d78217d", "html_url": "https://github.com/rust-lang/rust/commit/c77d3ae9f28fc5831c84c17b44c2884f2d78217d"}], "stats": {"total": 489, "additions": 244, "deletions": 245}, "files": [{"sha": "f6e9143dd0583e2dd2e9f9e2195d7acbe3c2dea6", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 245, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/f0c7857704bb2fee0807038207436b389adae9ee/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c7857704bb2fee0807038207436b389adae9ee/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=f0c7857704bb2fee0807038207436b389adae9ee", "patch": "@@ -622,248 +622,4 @@ impl<'a> Parser<'a> {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    fn same(fmt: &'static str, p: &[Piece<'static>]) {\n-        let parser = Parser::new(fmt, None, vec![], false);\n-        assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n-    }\n-\n-    fn fmtdflt() -> FormatSpec<'static> {\n-        return FormatSpec {\n-            fill: None,\n-            align: AlignUnknown,\n-            flags: 0,\n-            precision: CountImplied,\n-            width: CountImplied,\n-            ty: \"\",\n-        };\n-    }\n-\n-    fn musterr(s: &str) {\n-        let mut p = Parser::new(s, None, vec![], false);\n-        p.next();\n-        assert!(!p.errors.is_empty());\n-    }\n-\n-    #[test]\n-    fn simple() {\n-        same(\"asdf\", &[String(\"asdf\")]);\n-        same(\"a{{b\", &[String(\"a\"), String(\"{b\")]);\n-        same(\"a}}b\", &[String(\"a\"), String(\"}b\")]);\n-        same(\"a}}\", &[String(\"a\"), String(\"}\")]);\n-        same(\"}}\", &[String(\"}\")]);\n-        same(\"\\\\}}\", &[String(\"\\\\\"), String(\"}\")]);\n-    }\n-\n-    #[test]\n-    fn invalid01() {\n-        musterr(\"{\")\n-    }\n-    #[test]\n-    fn invalid02() {\n-        musterr(\"}\")\n-    }\n-    #[test]\n-    fn invalid04() {\n-        musterr(\"{3a}\")\n-    }\n-    #[test]\n-    fn invalid05() {\n-        musterr(\"{:|}\")\n-    }\n-    #[test]\n-    fn invalid06() {\n-        musterr(\"{:>>>}\")\n-    }\n-\n-    #[test]\n-    fn format_nothing() {\n-        same(\"{}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: fmtdflt(),\n-               })]);\n-    }\n-    #[test]\n-    fn format_position() {\n-        same(\"{3}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: fmtdflt(),\n-               })]);\n-    }\n-    #[test]\n-    fn format_position_nothing_else() {\n-        same(\"{3:}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: fmtdflt(),\n-               })]);\n-    }\n-    #[test]\n-    fn format_type() {\n-        same(\"{3:a}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"a\",\n-                   },\n-               })]);\n-    }\n-    #[test]\n-    fn format_align_fill() {\n-        same(\"{3:>}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignRight,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"\",\n-                   },\n-               })]);\n-        same(\"{3:0<}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: Some('0'),\n-                       align: AlignLeft,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"\",\n-                   },\n-               })]);\n-        same(\"{3:*<abcd}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: Some('*'),\n-                       align: AlignLeft,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"abcd\",\n-                   },\n-               })]);\n-    }\n-    #[test]\n-    fn format_counts() {\n-        use syntax_pos::{GLOBALS, Globals, edition};\n-        GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n-        same(\"{:10s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountIs(10),\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        same(\"{:10$.10s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountIs(10),\n-                       width: CountIsParam(10),\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        same(\"{:.*s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(1),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountIsParam(0),\n-                       width: CountImplied,\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        same(\"{:.10$s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountIsParam(10),\n-                       width: CountImplied,\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        same(\"{:a$.b$s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountIsName(Symbol::intern(\"b\")),\n-                       width: CountIsName(Symbol::intern(\"a\")),\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        });\n-    }\n-    #[test]\n-    fn format_flags() {\n-        same(\"{:-}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: (1 << FlagSignMinus as u32),\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"\",\n-                   },\n-               })]);\n-        same(\"{:+#}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"\",\n-                   },\n-               })]);\n-    }\n-    #[test]\n-    fn format_mixture() {\n-        same(\"abcd {3:a} efg\",\n-             &[String(\"abcd \"),\n-               NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"a\",\n-                   },\n-               }),\n-               String(\" efg\")]);\n-    }\n-}\n+mod tests;"}, {"sha": "7282d4a5f248b8127b2d8ea2f2eb6b6d37a210f5", "filename": "src/libfmt_macros/tests.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/f0c7857704bb2fee0807038207436b389adae9ee/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c7857704bb2fee0807038207436b389adae9ee/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=f0c7857704bb2fee0807038207436b389adae9ee", "patch": "@@ -0,0 +1,243 @@\n+use super::*;\n+\n+fn same(fmt: &'static str, p: &[Piece<'static>]) {\n+    let parser = Parser::new(fmt, None, vec![], false);\n+    assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n+}\n+\n+fn fmtdflt() -> FormatSpec<'static> {\n+    return FormatSpec {\n+        fill: None,\n+        align: AlignUnknown,\n+        flags: 0,\n+        precision: CountImplied,\n+        width: CountImplied,\n+        ty: \"\",\n+    };\n+}\n+\n+fn musterr(s: &str) {\n+    let mut p = Parser::new(s, None, vec![], false);\n+    p.next();\n+    assert!(!p.errors.is_empty());\n+}\n+\n+#[test]\n+fn simple() {\n+    same(\"asdf\", &[String(\"asdf\")]);\n+    same(\"a{{b\", &[String(\"a\"), String(\"{b\")]);\n+    same(\"a}}b\", &[String(\"a\"), String(\"}b\")]);\n+    same(\"a}}\", &[String(\"a\"), String(\"}\")]);\n+    same(\"}}\", &[String(\"}\")]);\n+    same(\"\\\\}}\", &[String(\"\\\\\"), String(\"}\")]);\n+}\n+\n+#[test]\n+fn invalid01() {\n+    musterr(\"{\")\n+}\n+#[test]\n+fn invalid02() {\n+    musterr(\"}\")\n+}\n+#[test]\n+fn invalid04() {\n+    musterr(\"{3a}\")\n+}\n+#[test]\n+fn invalid05() {\n+    musterr(\"{:|}\")\n+}\n+#[test]\n+fn invalid06() {\n+    musterr(\"{:>>>}\")\n+}\n+\n+#[test]\n+fn format_nothing() {\n+    same(\"{}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: fmtdflt(),\n+           })]);\n+}\n+#[test]\n+fn format_position() {\n+    same(\"{3}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: fmtdflt(),\n+           })]);\n+}\n+#[test]\n+fn format_position_nothing_else() {\n+    same(\"{3:}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: fmtdflt(),\n+           })]);\n+}\n+#[test]\n+fn format_type() {\n+    same(\"{3:a}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"a\",\n+               },\n+           })]);\n+}\n+#[test]\n+fn format_align_fill() {\n+    same(\"{3:>}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignRight,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"\",\n+               },\n+           })]);\n+    same(\"{3:0<}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: Some('0'),\n+                   align: AlignLeft,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"\",\n+               },\n+           })]);\n+    same(\"{3:*<abcd}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: Some('*'),\n+                   align: AlignLeft,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"abcd\",\n+               },\n+           })]);\n+}\n+#[test]\n+fn format_counts() {\n+    use syntax_pos::{GLOBALS, Globals, edition};\n+    GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n+    same(\"{:10s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountIs(10),\n+                   ty: \"s\",\n+               },\n+           })]);\n+    same(\"{:10$.10s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountIs(10),\n+                   width: CountIsParam(10),\n+                   ty: \"s\",\n+               },\n+           })]);\n+    same(\"{:.*s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(1),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountIsParam(0),\n+                   width: CountImplied,\n+                   ty: \"s\",\n+               },\n+           })]);\n+    same(\"{:.10$s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountIsParam(10),\n+                   width: CountImplied,\n+                   ty: \"s\",\n+               },\n+           })]);\n+    same(\"{:a$.b$s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountIsName(Symbol::intern(\"b\")),\n+                   width: CountIsName(Symbol::intern(\"a\")),\n+                   ty: \"s\",\n+               },\n+           })]);\n+    });\n+}\n+#[test]\n+fn format_flags() {\n+    same(\"{:-}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: (1 << FlagSignMinus as u32),\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"\",\n+               },\n+           })]);\n+    same(\"{:+#}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"\",\n+               },\n+           })]);\n+}\n+#[test]\n+fn format_mixture() {\n+    same(\"abcd {3:a} efg\",\n+         &[String(\"abcd \"),\n+           NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"a\",\n+               },\n+           }),\n+           String(\" efg\")]);\n+}"}]}