{"sha": "4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMGY0ZjVlMzExYjc0NDNiMjllYTMxYWQwZTY4ZTZiNGFhNjM3MzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-15T06:27:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-15T22:24:53Z"}, "message": "Refactor the lexer to use FilePos types", "tree": {"sha": "6109fe27f2ae9a5d984aeb72c97d41efc15f104d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6109fe27f2ae9a5d984aeb72c97d41efc15f104d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "html_url": "https://github.com/rust-lang/rust/commit/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1dff40bae94dd0fd1e4846fd7b76723d0a3f9f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1dff40bae94dd0fd1e4846fd7b76723d0a3f9f9", "html_url": "https://github.com/rust-lang/rust/commit/b1dff40bae94dd0fd1e4846fd7b76723d0a3f9f9"}], "stats": {"total": 139, "additions": 85, "deletions": 54}, "files": [{"sha": "e1c5eb07eb8f5665c7798ea3d11ff729c1274f11", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "patch": "@@ -200,11 +200,8 @@ pub impl FileMap {\n                                      start_pos);\n     }\n \n-    fn next_line(@self, +chpos: CharPos, +byte_pos: BytePos) {\n-        self.lines.push(FilePos {\n-            ch: chpos,\n-            byte: byte_pos + self.start_pos.byte\n-        });\n+    fn next_line(@self, +pos: FilePos) {\n+        self.lines.push(pos);\n     }\n \n     pub fn get_line(@self, line: int) -> ~str unsafe {\n@@ -231,6 +228,18 @@ pub impl CodeMap {\n     }\n \n     pub fn add_filemap(@self, filemap: @FileMap) {\n+        let expected_byte_pos = if self.files.len() == 0 {\n+            0\n+        } else {\n+            let last_start = self.files.last().start_pos.byte.to_uint();\n+            let last_len = self.files.last().src.len();\n+            last_start + last_len\n+        };\n+        let actual_byte_pos = filemap.start_pos.byte.to_uint();\n+        debug!(\"codemap: adding filemap: %s\", filemap.name);\n+        debug!(\"codemap: expected offset: %u\", expected_byte_pos);\n+        debug!(\"codemap: actual offset: %u\", actual_byte_pos);\n+        assert expected_byte_pos == actual_byte_pos;\n         self.files.push(filemap);\n     }\n "}, {"sha": "726dbbb56e2a46b1c8a60b413a1fda7f5c5c2e38", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "patch": "@@ -58,10 +58,13 @@ fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                   _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"include\");\n     let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n-    let p = parse::new_parser_from_file(cx.parse_sess(), cx.cfg(),\n-                                        &res_rel_file(cx, sp, &Path(file)),\n-                                        parse::parser::SOURCE_FILE);\n-    return p.parse_expr();\n+    let (p, rdr) = parse::new_parser_etc_from_file(\n+        cx.parse_sess(), cx.cfg(),\n+        &res_rel_file(cx, sp, &Path(file)),\n+        parse::parser::SOURCE_FILE);\n+    let e = p.parse_expr();\n+    parse::update_parse_sess_position(&cx.parse_sess(), &rdr);\n+    return e;\n }\n \n fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,"}, {"sha": "c5ffbb2ab0a39a31ddfe223ab5dfdbdd7142cfda", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "patch": "@@ -11,6 +11,7 @@ export parse_crate_from_source_str;\n export parse_expr_from_source_str, parse_item_from_source_str;\n export parse_stmt_from_source_str;\n export parse_from_source_str;\n+export update_parse_sess_position;\n \n use parser::Parser;\n use attr::parser_attr;\n@@ -76,7 +77,7 @@ fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n     let leading_attrs = p.parse_inner_attrs_and_next();\n     let { inner: crate_attrs, next: first_cdir_attr } = leading_attrs;\n     let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);\n-    eval::update_parse_sess_position(&sess, &rdr);\n+    update_parse_sess_position(&sess, &rdr);\n     let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n     let companionmod = input.filestem().map(|s| Path(*s));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n@@ -96,7 +97,7 @@ fn parse_crate_from_source_file(input: &Path, cfg: ast::crate_cfg,\n     let (p, rdr) = new_parser_etc_from_file(sess, cfg, input,\n                                             parser::SOURCE_FILE);\n     let r = p.parse_crate_mod(cfg);\n-    eval::update_parse_sess_position(&sess, &rdr);\n+    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n@@ -106,7 +107,7 @@ fn parse_crate_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                                                   codemap::FssNone, source);\n     let r = p.parse_crate_mod(cfg);\n     p.abort_if_errors();\n-    eval::update_parse_sess_position(&sess, &rdr);\n+    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n@@ -116,7 +117,7 @@ fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                                                   codemap::FssNone, source);\n     let r = p.parse_expr();\n     p.abort_if_errors();\n-    eval::update_parse_sess_position(&sess, &rdr);\n+    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n@@ -127,7 +128,7 @@ fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                                                   codemap::FssNone, source);\n     let r = p.parse_item(attrs);\n     p.abort_if_errors();\n-    eval::update_parse_sess_position(&sess, &rdr);\n+    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n@@ -138,7 +139,7 @@ fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                                                   codemap::FssNone, source);\n     let r = p.parse_stmt(attrs);\n     p.abort_if_errors();\n-    eval::update_parse_sess_position(&sess, &rdr);\n+    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n@@ -155,7 +156,7 @@ fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n     p.abort_if_errors();\n-    eval::update_parse_sess_position(&sess, &rdr);\n+    update_parse_sess_position(&sess, &rdr);\n     move r\n }\n \n@@ -216,3 +217,10 @@ fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n                                     None, tt);\n     return Parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n }\n+\n+fn update_parse_sess_position(sess: &parse_sess, r: &lexer::string_reader) {\n+    sess.pos = FilePos {\n+        ch: r.last_pos.ch,\n+        byte: r.last_pos.byte\n+    };\n+}"}, {"sha": "92736b9f3619899215d9b38497ec7b8e4ff6e4cd", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "patch": "@@ -131,7 +131,7 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n fn push_blank_line_comment(rdr: string_reader, comments: &mut ~[cmnt]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n-    comments.push({style: blank_line, lines: v, pos: rdr.chpos});\n+    comments.push({style: blank_line, lines: v, pos: rdr.last_pos.ch});\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n@@ -148,7 +148,7 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n                                             comments: &mut ~[cmnt]) {\n     debug!(\">>> shebang comment\");\n-    let p = rdr.chpos;\n+    let p = rdr.last_pos.ch;\n     debug!(\"<<< shebang comment\");\n     comments.push({\n         style: if code_to_the_left { trailing } else { isolated },\n@@ -160,7 +160,7 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n     debug!(\">>> line comments\");\n-    let p = rdr.chpos;\n+    let p = rdr.last_pos.ch;\n     let mut lines: ~[~str] = ~[];\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n@@ -209,7 +209,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n     debug!(\">>> block comment\");\n-    let p = rdr.chpos;\n+    let p = rdr.last_pos.ch;\n     let mut lines: ~[~str] = ~[];\n     let mut col: CharPos = rdr.col;\n     bump(rdr);\n@@ -319,7 +319,7 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         }\n \n \n-        let bstart = rdr.pos;\n+        let bstart = rdr.pos.byte;\n         rdr.next_token();\n         //discard, and look ahead; we're working with internal state\n         let {tok: tok, sp: sp} = rdr.peek();"}, {"sha": "47dbc0cd6eea1e1fb708dd2c7cb83919f7c1533e", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "patch": "@@ -1,8 +1,8 @@\n+use parse::update_parse_sess_position;\n use parser::{Parser, SOURCE_FILE};\n use attr::parser_attr;\n \n export eval_crate_directives_to_mod;\n-export update_parse_sess_position;\n \n type ctx =\n     @{sess: parse::parse_sess,\n@@ -74,13 +74,6 @@ fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n     }\n }\n \n-fn update_parse_sess_position(sess: &parse_sess, r: &lexer::string_reader) {\n-    sess.pos = FilePos {\n-        ch: r.chpos,\n-        byte: sess.pos.byte + r.pos\n-    };\n-}\n-\n fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n     match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n       Some(d) => d,"}, {"sha": "459935def677babd837a26572cce81885aad992d", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=4a0f4f5e311b7443b29ea31ad0e68e6b4aa63736", "patch": "@@ -1,5 +1,5 @@\n use diagnostic::span_handler;\n-use codemap::{span, CodeMap, CharPos, BytePos};\n+use codemap::{span, CodeMap, CharPos, BytePos, FilePos};\n use ext::tt::transcribe::{tt_reader,  new_tt_reader, dup_tt_reader,\n                              tt_next_token};\n \n@@ -21,10 +21,10 @@ trait reader {\n type string_reader = @{\n     span_diagnostic: span_handler,\n     src: @~str,\n+    mut pos: FilePos,\n+    mut last_pos: FilePos,\n     mut col: CharPos,\n-    mut pos: BytePos,\n     mut curr: char,\n-    mut chpos: CharPos,\n     filemap: @codemap::FileMap,\n     interner: @token::ident_interner,\n     /* cached: */\n@@ -48,9 +48,10 @@ fn new_low_level_string_reader(span_diagnostic: span_handler,\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n     let r = @{span_diagnostic: span_diagnostic, src: filemap.src,\n-              mut col: CharPos(0), mut pos: BytePos(0),\n+              mut pos: filemap.start_pos,\n+              mut last_pos: filemap.start_pos,\n+              mut col: CharPos(0),\n               mut curr: initial_char,\n-              mut chpos: filemap.start_pos.ch,\n               filemap: filemap, interner: itr,\n               /* dummy values; not read */\n               mut peek_tok: token::EOF,\n@@ -61,7 +62,9 @@ fn new_low_level_string_reader(span_diagnostic: span_handler,\n \n fn dup_string_reader(&&r: string_reader) -> string_reader {\n     @{span_diagnostic: r.span_diagnostic, src: r.src,\n-      mut col: r.col, mut pos: r.pos, mut curr: r.curr, mut chpos: r.chpos,\n+      mut pos: r.pos,\n+      mut last_pos: r.last_pos,\n+      mut col: r.col, mut curr: r.curr,\n       filemap: r.filemap, interner: r.interner,\n       mut peek_tok: r.peek_tok, mut peek_span: r.peek_span}\n }\n@@ -116,34 +119,48 @@ fn string_advance_token(&&r: string_reader) {\n     if is_eof(r) {\n         r.peek_tok = token::EOF;\n     } else {\n-        let start_chpos = r.chpos;\n+        let start_chpos = r.last_pos.ch;\n         r.peek_tok = next_token_inner(r);\n-        r.peek_span = ast_util::mk_sp(start_chpos, r.chpos);\n+        r.peek_span = ast_util::mk_sp(start_chpos, r.last_pos.ch);\n     };\n \n }\n \n+fn byte_offset(rdr: string_reader) -> BytePos {\n+    (rdr.pos.byte - rdr.filemap.start_pos.byte)\n+}\n+\n fn get_str_from(rdr: string_reader, start: BytePos) -> ~str unsafe {\n     // I'm pretty skeptical about this subtraction. What if there's a\n     // multi-byte character before the mark?\n-    return str::slice(*rdr.src, start.to_uint() - 1u, rdr.pos.to_uint() - 1u);\n+    return str::slice(*rdr.src, start.to_uint() - 1u,\n+                      byte_offset(rdr).to_uint() - 1u);\n }\n \n fn bump(rdr: string_reader) {\n-    if rdr.pos.to_uint() < (*rdr.src).len() {\n+    rdr.last_pos = rdr.pos;\n+    let current_byte_offset = byte_offset(rdr).to_uint();;\n+    if current_byte_offset < (*rdr.src).len() {\n+        let last_char = rdr.curr;\n+        let next = str::char_range_at(*rdr.src, current_byte_offset);\n+        let byte_offset_diff = next.next - current_byte_offset;\n+        rdr.pos = FilePos {\n+            ch: rdr.pos.ch + CharPos(1u),\n+            byte: rdr.pos.byte + BytePos(byte_offset_diff)\n+        };\n+        rdr.curr = next.ch;\n         rdr.col += CharPos(1u);\n-        rdr.chpos += CharPos(1u);\n-        if rdr.curr == '\\n' {\n-            rdr.filemap.next_line(rdr.chpos, rdr.pos);\n+        if last_char == '\\n' {\n+            rdr.filemap.next_line(rdr.last_pos);\n             rdr.col = CharPos(0u);\n         }\n-        let next = str::char_range_at(*rdr.src, rdr.pos.to_uint());\n-        rdr.pos = BytePos(next.next);\n-        rdr.curr = next.ch;\n     } else {\n         // XXX: What does this accomplish?\n         if (rdr.curr != -1 as char) {\n-            rdr.chpos += CharPos(1u);\n+            rdr.pos = FilePos {\n+                ch: rdr.pos.ch + CharPos(1u),\n+                byte: rdr.pos.byte + BytePos(1u)\n+            };\n             rdr.col += CharPos(1u);\n             rdr.curr = -1 as char;\n         }\n@@ -153,8 +170,9 @@ fn is_eof(rdr: string_reader) -> bool {\n     rdr.curr == -1 as char\n }\n fn nextch(rdr: string_reader) -> char {\n-    if rdr.pos.to_uint() < (*rdr.src).len() {\n-        return str::char_at(*rdr.src, rdr.pos.to_uint());\n+    let offset = byte_offset(rdr).to_uint();\n+    if offset < (*rdr.src).len() {\n+        return str::char_at(*rdr.src, offset);\n     } else { return -1 as char; }\n }\n \n@@ -211,15 +229,15 @@ fn consume_any_line_comment(rdr: string_reader)\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n             if rdr.curr == '/' || rdr.curr == '!' {\n-                let start_chpos = rdr.chpos - CharPos(2u);\n+                let start_chpos = rdr.pos.ch - CharPos(2u);\n                 let mut acc = ~\"//\";\n                 while rdr.curr != '\\n' && !is_eof(rdr) {\n                     str::push_char(&mut acc, rdr.curr);\n                     bump(rdr);\n                 }\n                 return Some({\n                     tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n-                    sp: ast_util::mk_sp(start_chpos, rdr.chpos)\n+                    sp: ast_util::mk_sp(start_chpos, rdr.pos.ch)\n                 });\n             } else {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n@@ -234,7 +252,7 @@ fn consume_any_line_comment(rdr: string_reader)\n         if nextch(rdr) == '!' {\n             let cmap = @CodeMap::new();\n             (*cmap).files.push(rdr.filemap);\n-            let loc = cmap.lookup_char_pos_adj(rdr.chpos);\n+            let loc = cmap.lookup_char_pos_adj(rdr.last_pos.ch);\n             if loc.line == 1u && loc.col == CharPos(0u) {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n@@ -250,7 +268,7 @@ fn consume_block_comment(rdr: string_reader)\n \n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n-        let start_chpos = rdr.chpos - CharPos(2u);\n+        let start_chpos = rdr.pos.ch - CharPos(2u);\n         let mut acc = ~\"/*\";\n         while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n             str::push_char(&mut acc, rdr.curr);\n@@ -264,7 +282,7 @@ fn consume_block_comment(rdr: string_reader)\n             bump(rdr);\n             return Some({\n                 tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n-                sp: ast_util::mk_sp(start_chpos, rdr.chpos)\n+                sp: ast_util::mk_sp(start_chpos, rdr.pos.ch)\n             });\n         }\n     } else {\n@@ -584,7 +602,7 @@ fn next_token_inner(rdr: string_reader) -> token::Token {\n         return token::LIT_INT(c2 as i64, ast::ty_char);\n       }\n       '\"' => {\n-        let n = rdr.pos;\n+        let n = byte_offset(rdr);\n         bump(rdr);\n         while rdr.curr != '\"' {\n             if is_eof(rdr) {"}]}