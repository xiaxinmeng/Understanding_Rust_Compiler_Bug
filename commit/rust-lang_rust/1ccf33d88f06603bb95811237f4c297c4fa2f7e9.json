{"sha": "1ccf33d88f06603bb95811237f4c297c4fa2f7e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjY2YzM2Q4OGYwNjYwM2JiOTU4MTEyMzdmNGMyOTdjNGZhMmY3ZTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T07:51:30Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T07:51:30Z"}, "message": "Minor, move code", "tree": {"sha": "b455e9193b7bb383cb1f27d58c416d57e9035b2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b455e9193b7bb383cb1f27d58c416d57e9035b2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ccf33d88f06603bb95811237f4c297c4fa2f7e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ccf33d88f06603bb95811237f4c297c4fa2f7e9", "html_url": "https://github.com/rust-lang/rust/commit/1ccf33d88f06603bb95811237f4c297c4fa2f7e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ccf33d88f06603bb95811237f4c297c4fa2f7e9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "html_url": "https://github.com/rust-lang/rust/commit/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e"}], "stats": {"total": 243, "additions": 123, "deletions": 120}, "files": [{"sha": "14adb8ae73346b0b41336247b4616ab854ed3506", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1ccf33d88f06603bb95811237f4c297c4fa2f7e9/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ccf33d88f06603bb95811237f4c297c4fa2f7e9/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=1ccf33d88f06603bb95811237f4c297c4fa2f7e9", "patch": "@@ -1,9 +1,11 @@\n //! Utilities for LSP-related boilerplate code.\n-use std::error::Error;\n+use std::{error::Error, ops::Range};\n \n+use crate::from_proto;\n use crossbeam_channel::Sender;\n use lsp_server::{Message, Notification};\n use ra_db::Canceled;\n+use ra_ide::LineIndex;\n use serde::{de::DeserializeOwned, Serialize};\n \n pub fn show_message(\n@@ -42,3 +44,116 @@ where\n {\n     Notification::new(N::METHOD.to_string(), params)\n }\n+\n+pub(crate) fn apply_document_changes(\n+    old_text: &mut String,\n+    content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n+) {\n+    let mut line_index = LineIndex::new(old_text);\n+    // The changes we got must be applied sequentially, but can cross lines so we\n+    // have to keep our line index updated.\n+    // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n+    // remember the last valid line in the index and only rebuild it if needed.\n+    // The VFS will normalize the end of lines to `\\n`.\n+    enum IndexValid {\n+        All,\n+        UpToLineExclusive(u64),\n+    }\n+\n+    impl IndexValid {\n+        fn covers(&self, line: u64) -> bool {\n+            match *self {\n+                IndexValid::UpToLineExclusive(to) => to > line,\n+                _ => true,\n+            }\n+        }\n+    }\n+\n+    let mut index_valid = IndexValid::All;\n+    for change in content_changes {\n+        match change.range {\n+            Some(range) => {\n+                if !index_valid.covers(range.end.line) {\n+                    line_index = LineIndex::new(&old_text);\n+                }\n+                index_valid = IndexValid::UpToLineExclusive(range.start.line);\n+                let range = from_proto::text_range(&line_index, range);\n+                old_text.replace_range(Range::<usize>::from(range), &change.text);\n+            }\n+            None => {\n+                *old_text = change.text;\n+                index_valid = IndexValid::UpToLineExclusive(0);\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use lsp_types::{Position, Range, TextDocumentContentChangeEvent};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_apply_document_changes() {\n+        macro_rules! c {\n+            [$($sl:expr, $sc:expr; $el:expr, $ec:expr => $text:expr),+] => {\n+                vec![$(TextDocumentContentChangeEvent {\n+                    range: Some(Range {\n+                        start: Position { line: $sl, character: $sc },\n+                        end: Position { line: $el, character: $ec },\n+                    }),\n+                    range_length: None,\n+                    text: String::from($text),\n+                }),+]\n+            };\n+        }\n+\n+        let mut text = String::new();\n+        apply_document_changes(&mut text, vec![]);\n+        assert_eq!(text, \"\");\n+        apply_document_changes(\n+            &mut text,\n+            vec![TextDocumentContentChangeEvent {\n+                range: None,\n+                range_length: None,\n+                text: String::from(\"the\"),\n+            }],\n+        );\n+        assert_eq!(text, \"the\");\n+        apply_document_changes(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n+        assert_eq!(text, \"the quick\");\n+        apply_document_changes(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        assert_eq!(text, \"quick foxes\");\n+        apply_document_changes(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        assert_eq!(text, \"quick foxes\\ndream\");\n+        apply_document_changes(&mut text, c![1, 0; 1, 0 => \"have \"]);\n+        assert_eq!(text, \"quick foxes\\nhave dream\");\n+        apply_document_changes(\n+            &mut text,\n+            c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n+        );\n+        assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n+        apply_document_changes(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n+        apply_document_changes(\n+            &mut text,\n+            c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n+        );\n+        assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n+        apply_document_changes(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n+\n+        text = String::from(\"\u2764\ufe0f\");\n+        apply_document_changes(&mut text, c![0, 0; 0, 0 => \"a\"]);\n+        assert_eq!(text, \"a\u2764\ufe0f\");\n+\n+        text = String::from(\"a\\nb\");\n+        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        assert_eq!(text, \"adcb\");\n+\n+        text = String::from(\"a\\nb\");\n+        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        assert_eq!(text, \"a\u021bc\\ncb\");\n+    }\n+}"}, {"sha": "3b3b832091f731bea7f3dda63a00d202ef4b6bfc", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 7, "deletions": 119, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/1ccf33d88f06603bb95811237f4c297c4fa2f7e9/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ccf33d88f06603bb95811237f4c297c4fa2f7e9/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=1ccf33d88f06603bb95811237f4c297c4fa2f7e9", "patch": "@@ -1,18 +1,16 @@\n //! The main loop of `rust-analyzer` responsible for dispatching LSP\n //! requests/replies and notifications back to the client.\n use std::{\n-    env, fmt,\n-    ops::Range,\n-    panic,\n+    env, fmt, panic,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n-use lsp_types::{request::Request as _, NumberOrString, TextDocumentContentChangeEvent};\n+use lsp_types::{request::Request as _, NumberOrString};\n use ra_db::VfsPath;\n-use ra_ide::{Canceled, FileId, LineIndex};\n+use ra_ide::{Canceled, FileId};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n use serde::{de::DeserializeOwned, Serialize};\n@@ -24,7 +22,10 @@ use crate::{\n     from_proto,\n     global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot, Status},\n     handlers, lsp_ext,\n-    lsp_utils::{is_canceled, notification_cast, notification_is, notification_new, show_message},\n+    lsp_utils::{\n+        apply_document_changes, is_canceled, notification_cast, notification_is, notification_new,\n+        show_message,\n+    },\n     request_metrics::RequestMetrics,\n     LspError, Result,\n };\n@@ -548,49 +549,6 @@ fn on_notification(\n     Ok(())\n }\n \n-fn apply_document_changes(\n-    old_text: &mut String,\n-    content_changes: Vec<TextDocumentContentChangeEvent>,\n-) {\n-    let mut line_index = LineIndex::new(old_text);\n-    // The changes we got must be applied sequentially, but can cross lines so we\n-    // have to keep our line index updated.\n-    // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n-    // remember the last valid line in the index and only rebuild it if needed.\n-    // The VFS will normalize the end of lines to `\\n`.\n-    enum IndexValid {\n-        All,\n-        UpToLineExclusive(u64),\n-    }\n-\n-    impl IndexValid {\n-        fn covers(&self, line: u64) -> bool {\n-            match *self {\n-                IndexValid::UpToLineExclusive(to) => to > line,\n-                _ => true,\n-            }\n-        }\n-    }\n-\n-    let mut index_valid = IndexValid::All;\n-    for change in content_changes {\n-        match change.range {\n-            Some(range) => {\n-                if !index_valid.covers(range.end.line) {\n-                    line_index = LineIndex::new(&old_text);\n-                }\n-                index_valid = IndexValid::UpToLineExclusive(range.start.line);\n-                let range = from_proto::text_range(&line_index, range);\n-                old_text.replace_range(Range::<usize>::from(range), &change.text);\n-            }\n-            None => {\n-                *old_text = change.text;\n-                index_valid = IndexValid::UpToLineExclusive(0);\n-            }\n-        }\n-    }\n-}\n-\n fn on_check_task(\n     task: flycheck::Message,\n     global_state: &mut GlobalState,\n@@ -862,73 +820,3 @@ fn update_file_notifications_on_threadpool(\n         })\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use lsp_types::{Position, Range, TextDocumentContentChangeEvent};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn test_apply_document_changes() {\n-        macro_rules! c {\n-            [$($sl:expr, $sc:expr; $el:expr, $ec:expr => $text:expr),+] => {\n-                vec![$(TextDocumentContentChangeEvent {\n-                    range: Some(Range {\n-                        start: Position { line: $sl, character: $sc },\n-                        end: Position { line: $el, character: $ec },\n-                    }),\n-                    range_length: None,\n-                    text: String::from($text),\n-                }),+]\n-            };\n-        }\n-\n-        let mut text = String::new();\n-        apply_document_changes(&mut text, vec![]);\n-        assert_eq!(text, \"\");\n-        apply_document_changes(\n-            &mut text,\n-            vec![TextDocumentContentChangeEvent {\n-                range: None,\n-                range_length: None,\n-                text: String::from(\"the\"),\n-            }],\n-        );\n-        assert_eq!(text, \"the\");\n-        apply_document_changes(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n-        assert_eq!(text, \"the quick\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n-        assert_eq!(text, \"quick foxes\");\n-        apply_document_changes(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n-        assert_eq!(text, \"quick foxes\\ndream\");\n-        apply_document_changes(&mut text, c![1, 0; 1, 0 => \"have \"]);\n-        assert_eq!(text, \"quick foxes\\nhave dream\");\n-        apply_document_changes(\n-            &mut text,\n-            c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n-        );\n-        assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        apply_document_changes(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n-        assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n-        apply_document_changes(\n-            &mut text,\n-            c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n-        );\n-        assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        apply_document_changes(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n-        assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n-\n-        text = String::from(\"\u2764\ufe0f\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 0 => \"a\"]);\n-        assert_eq!(text, \"a\u2764\ufe0f\");\n-\n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n-        assert_eq!(text, \"adcb\");\n-\n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n-        assert_eq!(text, \"a\u021bc\\ncb\");\n-    }\n-}"}]}