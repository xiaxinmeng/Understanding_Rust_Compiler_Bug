{"sha": "3a06a93f5999233807afba6109c6a29f768163a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMDZhOTNmNTk5OTIzMzgwN2FmYmE2MTA5YzZhMjlmNzY4MTYzYTQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-04T02:48:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-04T02:48:11Z"}, "message": "Rollup merge of #61413 - davidtwco:async-argument-order-in-a-sane-way, r=eddyb\n\nRe-implement async fn drop order lowering\n\nThis PR re-implements the async fn drop order lowering changes so\nthat it all takes place in HIR lowering, building atop the work done by\n@eddyb to refactor `Res::Upvar`.\n\nPreviously, this types involved in the lowering were constructed in\nlibsyntax as they had to be used during name resolution and HIR\nlowering. This was awful because none of that logic should have existed\nin libsyntax.\n\nThis commit also changes `ArgSource` to keep a `HirId` to the original\nargument pattern rather than a cloned copy of the pattern.\n\nOnly b7aa4ed and 71fb8fa should be reviewed, any other commits\nare from #61276 (though 447e336 might end up staying in this PR).\n\nAs a nice side effect, it also fixes #61187 (cc #61192).\n\nr? @eddyb\ncc @cramertj", "tree": {"sha": "eeb3baaec3d493ff827c769fd0ece89118d56ac2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeb3baaec3d493ff827c769fd0ece89118d56ac2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a06a93f5999233807afba6109c6a29f768163a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc9dvrCRBK7hj4Ov3rIwAAdHIIAAARV4YBWN/LHjmiIzcQfkRN\nl/RSnQT8LkhcimO8tCzNLkUKJDhoPwZ6Tg8FoauM09N4Bhhf4A1qAbk2MJDM6f63\nD3jCegpakubmEVQeCfafZilJsRYWX468X9XtSBkjWWyTJ5aUf2YbaGPel2RNzT23\nA3kghgpl7pnt7S3HTC7o4bpnyNbvu6JiRGb6lvnfzWy+na3kT7eS4fyMuo+ZrIwX\nCL7YMIf1hKr/SVawdozcqnLfFxazH0VIMEaoSmJW5FEChNi+JiVJxCb43VSeUqR7\niMVbZr9l08/StbPmVb4KCorspca7yV2G+Ndbg/h8T31xFb+lbg9PYYbn+vO8+GA=\n=c02R\n-----END PGP SIGNATURE-----\n", "payload": "tree eeb3baaec3d493ff827c769fd0ece89118d56ac2\nparent 156351419611f3ee6f6b1327e6021676630e64a8\nparent 2bb92aa02ff98e13970602e7a7f9555050f1dbe7\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559616491 +0200\ncommitter GitHub <noreply@github.com> 1559616491 +0200\n\nRollup merge of #61413 - davidtwco:async-argument-order-in-a-sane-way, r=eddyb\n\nRe-implement async fn drop order lowering\n\nThis PR re-implements the async fn drop order lowering changes so\nthat it all takes place in HIR lowering, building atop the work done by\n@eddyb to refactor `Res::Upvar`.\n\nPreviously, this types involved in the lowering were constructed in\nlibsyntax as they had to be used during name resolution and HIR\nlowering. This was awful because none of that logic should have existed\nin libsyntax.\n\nThis commit also changes `ArgSource` to keep a `HirId` to the original\nargument pattern rather than a cloned copy of the pattern.\n\nOnly b7aa4ed and 71fb8fa should be reviewed, any other commits\nare from #61276 (though 447e336 might end up staying in this PR).\n\nAs a nice side effect, it also fixes #61187 (cc #61192).\n\nr? @eddyb\ncc @cramertj\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a06a93f5999233807afba6109c6a29f768163a4", "html_url": "https://github.com/rust-lang/rust/commit/3a06a93f5999233807afba6109c6a29f768163a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a06a93f5999233807afba6109c6a29f768163a4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "156351419611f3ee6f6b1327e6021676630e64a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/156351419611f3ee6f6b1327e6021676630e64a8", "html_url": "https://github.com/rust-lang/rust/commit/156351419611f3ee6f6b1327e6021676630e64a8"}, {"sha": "2bb92aa02ff98e13970602e7a7f9555050f1dbe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb92aa02ff98e13970602e7a7f9555050f1dbe7", "html_url": "https://github.com/rust-lang/rust/commit/2bb92aa02ff98e13970602e7a7f9555050f1dbe7"}], "stats": {"total": 1073, "additions": 361, "deletions": 712}, "files": [{"sha": "9cf365addca9bb060e3a5c941d1c38d0c3230fd9", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -262,9 +262,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_pat(&mut self, p: &'v Pat) {\n         walk_pat(self, p)\n     }\n-    fn visit_argument_source(&mut self, s: &'v ArgSource) {\n-        walk_argument_source(self, s)\n-    }\n     fn visit_anon_const(&mut self, c: &'v AnonConst) {\n         walk_anon_const(self, c)\n     }\n@@ -402,17 +399,10 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n     for argument in &body.arguments {\n         visitor.visit_id(argument.hir_id);\n         visitor.visit_pat(&argument.pat);\n-        visitor.visit_argument_source(&argument.source);\n     }\n     visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_argument_source<'v, V: Visitor<'v>>(visitor: &mut V, source: &'v ArgSource) {\n-    if let ArgSource::AsyncFn(pat) = source {\n-        visitor.visit_pat(pat);\n-    }\n-}\n-\n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition."}, {"sha": "14a6e93341e3290c3b988dbcdae837962c2f66a4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 246, "deletions": 224, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -50,6 +50,7 @@ use errors::Applicability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_data_structures::sync::Lrc;\n \n use std::collections::{BTreeSet, BTreeMap};\n use std::mem;\n@@ -58,17 +59,17 @@ use syntax::attr;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::source_map::{respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n-use syntax_pos::Span;\n+use syntax_pos::{edition, Span};\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -465,32 +466,6 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_pat(self, p)\n             }\n \n-            fn visit_fn(&mut self, fk: visit::FnKind<'lcx>, fd: &'lcx FnDecl, s: Span, _: NodeId) {\n-                if fk.header().map(|h| h.asyncness.node.is_async()).unwrap_or(false) {\n-                    // Don't visit the original pattern for async functions as it will be\n-                    // replaced.\n-                    for arg in &fd.inputs {\n-                        if let ArgSource::AsyncFn(pat) = &arg.source { self.visit_pat(pat); }\n-                        self.visit_ty(&arg.ty)\n-                    }\n-                    self.visit_fn_ret_ty(&fd.output);\n-\n-                    match fk {\n-                        visit::FnKind::ItemFn(_, decl, _, body) => {\n-                            self.visit_fn_header(decl);\n-                            self.visit_block(body)\n-                        },\n-                        visit::FnKind::Method(_, sig, _, body) => {\n-                            self.visit_fn_header(&sig.header);\n-                            self.visit_block(body)\n-                        },\n-                        visit::FnKind::Closure(body) => self.visit_expr(body),\n-                    }\n-                } else {\n-                    visit::walk_fn(self, fk, fd, s)\n-                }\n-            }\n-\n             fn visit_item(&mut self, item: &'lcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n@@ -806,7 +781,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn record_body(&mut self, value: hir::Expr, arguments: HirVec<hir::Arg>) -> hir::BodyId {\n+    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n         if self.is_generator && self.is_async_body {\n             span_err!(\n                 self.sess,\n@@ -855,6 +830,27 @@ impl<'a> LoweringContext<'a> {\n         self.sess.diagnostic()\n     }\n \n+    /// Reuses the span but adds information like the kind of the desugaring and features that are\n+    /// allowed inside this span.\n+    fn mark_span_with_reason(\n+        &self,\n+        reason: CompilerDesugaringKind,\n+        span: Span,\n+        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    ) -> Span {\n+        let mark = Mark::fresh(Mark::root());\n+        mark.set_expn_info(source_map::ExpnInfo {\n+            call_site: span,\n+            def_site: Some(span),\n+            format: source_map::CompilerDesugaring(reason),\n+            allow_internal_unstable,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition: edition::Edition::from_session(),\n+        });\n+        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n+    }\n+\n     fn with_anonymous_lifetime_mode<R>(\n         &mut self,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n@@ -1125,27 +1121,21 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n-        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_is_async_body = mem::replace(&mut self.is_async_body, true);\n+        let capture_clause = self.lower_capture_clause(capture_clause);\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(P(ty.clone())),\n             None => FunctionRetTy::Default(span),\n         };\n-        let decl = FnDecl {\n+        let ast_decl = FnDecl {\n             inputs: vec![],\n             output,\n             c_variadic: false\n         };\n-        // Lower the arguments before the body otherwise the body will call `lower_res` expecting\n-        // the argument to have been assigned an id already.\n-        let arguments = self.lower_args(Some(&decl));\n-        let body_expr = body(self);\n-        let body_id = self.record_body(body_expr, arguments);\n-        self.is_generator = prev_is_generator;\n-        self.is_async_body = prev_is_async_body;\n-\n-        let capture_clause = self.lower_capture_clause(capture_clause);\n-        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n+        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n+        let body_id = self.lower_fn_body(&ast_decl, |this| {\n+            this.is_async_body = true;\n+            body(this)\n+        });\n         let generator = hir::Expr {\n             hir_id: self.lower_node_id(closure_node_id),\n             node: hir::ExprKind::Closure(capture_clause, decl, body_id, span,\n@@ -1154,7 +1144,7 @@ impl<'a> LoweringContext<'a> {\n             attrs: ThinVec::new(),\n         };\n \n-        let unstable_span = self.sess.source_map().mark_span_with_reason(\n+        let unstable_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n             Some(vec![sym::gen_future].into()),\n@@ -1164,18 +1154,32 @@ impl<'a> LoweringContext<'a> {\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n     }\n \n-    fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n-    where\n-        F: FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n-    {\n-        let prev_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_async = mem::replace(&mut self.is_async_body, false);\n-        let arguments = self.lower_args(decl);\n-        let result = f(self);\n-        let r = self.record_body(result, arguments);\n-        self.is_generator = prev_generator;\n-        self.is_async_body = prev_async;\n-        return r;\n+    fn lower_body(\n+        &mut self,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+    ) -> hir::BodyId {\n+        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n+        let prev_is_async_body = mem::replace(&mut self.is_async_body, false);\n+        let (arguments, result) = f(self);\n+        let body_id = self.record_body(arguments, result);\n+        self.is_generator = prev_is_generator;\n+        self.is_async_body = prev_is_async_body;\n+        body_id\n+    }\n+\n+    fn lower_fn_body(\n+        &mut self,\n+        decl: &FnDecl,\n+        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n+    ) -> hir::BodyId {\n+        self.lower_body(|this| (\n+            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            body(this),\n+        ))\n+    }\n+\n+    fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n+        self.lower_body(|this| (hir_vec![], this.lower_expr(expr)))\n     }\n \n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n@@ -1561,7 +1565,7 @@ impl<'a> LoweringContext<'a> {\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile as\n         // frequently opened issues show.\n-        let exist_ty_span = self.sess.source_map().mark_span_with_reason(\n+        let exist_ty_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::ExistentialReturnType,\n             span,\n             None,\n@@ -2266,40 +2270,21 @@ impl<'a> LoweringContext<'a> {\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n-            source: self.lower_local_source(l.source),\n+            source: hir::LocalSource::Normal,\n         }, ids)\n     }\n \n-    fn lower_local_source(&mut self, ls: LocalSource) -> hir::LocalSource {\n-        match ls {\n-            LocalSource::Normal => hir::LocalSource::Normal,\n-            LocalSource::AsyncFn => hir::LocalSource::AsyncFn,\n-        }\n-    }\n-\n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n         match m {\n             Mutability::Mutable => hir::MutMutable,\n             Mutability::Immutable => hir::MutImmutable,\n         }\n     }\n \n-    fn lower_args(&mut self, decl: Option<&FnDecl>) -> HirVec<hir::Arg> {\n-        decl.map_or(hir_vec![], |decl| decl.inputs.iter().map(|x| self.lower_arg(x)).collect())\n-    }\n-\n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n         hir::Arg {\n             hir_id: self.lower_node_id(arg.id),\n             pat: self.lower_pat(&arg.pat),\n-            source: self.lower_arg_source(&arg.source),\n-        }\n-    }\n-\n-    fn lower_arg_source(&mut self, source: &ArgSource) -> hir::ArgSource {\n-        match source {\n-            ArgSource::Normal => hir::ArgSource::Normal,\n-            ArgSource::AsyncFn(pat) => hir::ArgSource::AsyncFn(self.lower_pat(pat)),\n         }\n     }\n \n@@ -2435,7 +2420,7 @@ impl<'a> LoweringContext<'a> {\n     ) -> hir::FunctionRetTy {\n         let span = output.span();\n \n-        let exist_ty_span = self.sess.source_map().mark_span_with_reason(\n+        let exist_ty_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n             None,\n@@ -2998,11 +2983,14 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+    fn lower_block_with_stmts(\n+        &mut self,\n+        b: &Block,\n+        targeted_by_break: bool,\n+        mut stmts: Vec<hir::Stmt>,\n+    ) -> P<hir::Block> {\n         let mut expr = None;\n \n-        let mut stmts = vec![];\n-\n         for (index, stmt) in b.stmts.iter().enumerate() {\n             if index == b.stmts.len() - 1 {\n                 if let StmtKind::Expr(ref e) = stmt.node {\n@@ -3025,56 +3013,136 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_async_body(\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+        self.lower_block_with_stmts(b, targeted_by_break, vec![])\n+    }\n+\n+    fn lower_maybe_async_body(\n         &mut self,\n         decl: &FnDecl,\n-        asyncness: &IsAsync,\n+        asyncness: IsAsync,\n         body: &Block,\n     ) -> hir::BodyId {\n-        self.lower_body(Some(&decl), |this| {\n-            if let IsAsync::Async { closure_id, ref arguments, .. } = asyncness {\n-                let mut body = body.clone();\n+        let closure_id = match asyncness {\n+            IsAsync::Async { closure_id, .. } => closure_id,\n+            IsAsync::NotAsync => return self.lower_fn_body(&decl, |this| {\n+                let body = this.lower_block(body, false);\n+                this.expr_block(body, ThinVec::new())\n+            }),\n+        };\n \n-                // Async function arguments are lowered into the closure body so that they are\n-                // captured and so that the drop order matches the equivalent non-async functions.\n-                //\n-                //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n-                //       async move {\n-                //       }\n-                //     }\n-                //\n-                //     // ...becomes...\n-                //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n-                //       async move {\n-                //         let __arg2 = __arg2;\n-                //         let <pattern> = __arg2;\n-                //         let __arg1 = __arg1;\n-                //         let <pattern> = __arg1;\n-                //         let __arg0 = __arg0;\n-                //         let <pattern> = __arg0;\n-                //       }\n-                //     }\n+        self.lower_body(|this| {\n+            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut statements: Vec<hir::Stmt> = Vec::new();\n+\n+            // Async function arguments are lowered into the closure body so that they are\n+            // captured and so that the drop order matches the equivalent non-async functions.\n+            //\n+            // from:\n+            //\n+            //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+            //       async move {\n+            //       }\n+            //     }\n+            //\n+            // into:\n+            //\n+            //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+            //       async move {\n+            //         let __arg2 = __arg2;\n+            //         let <pattern> = __arg2;\n+            //         let __arg1 = __arg1;\n+            //         let <pattern> = __arg1;\n+            //         let __arg0 = __arg0;\n+            //         let <pattern> = __arg0;\n+            //       }\n+            //     }\n+            //\n+            // If `<pattern>` is a simple ident, then it is lowered to a single\n+            // `let <pattern> = <pattern>;` statement as an optimization.\n+            for (index, argument) in decl.inputs.iter().enumerate() {\n+                let argument = this.lower_arg(argument);\n+                let span = argument.pat.span;\n+\n+                // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n+                let (ident, is_simple_argument) = match argument.pat.node {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n+                        (ident, true),\n+                    _ => {\n+                        // Replace the ident for bindings that aren't simple.\n+                        let name = format!(\"__arg{}\", index);\n+                        let ident = Ident::from_str(&name);\n+\n+                        (ident, false)\n+                    },\n+                };\n+\n+                let desugared_span =\n+                    this.mark_span_with_reason(CompilerDesugaringKind::Async, span, None);\n+\n+                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // async function.\n                 //\n-                // If `<pattern>` is a simple ident, then it is lowered to a single\n-                // `let <pattern> = <pattern>;` statement as an optimization.\n-                for a in arguments.iter().rev() {\n-                    if let Some(pat_stmt) = a.pat_stmt.clone() {\n-                        body.stmts.insert(0, pat_stmt);\n-                    }\n-                    body.stmts.insert(0, a.move_stmt.clone());\n-                }\n+                // If this is the simple case, this argument will end up being the same as the\n+                // original argument, but with a different pattern id.\n+                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n+                let new_argument = hir::Arg {\n+                    hir_id: argument.hir_id,\n+                    pat: new_argument_pat,\n+                };\n \n-                let async_expr = this.make_async_expr(\n-                    CaptureBy::Value, *closure_id, None, body.span,\n-                    |this| {\n-                        let body = this.lower_block(&body, false);\n-                        this.expr_block(body, ThinVec::new())\n-                    });\n-                this.expr(body.span, async_expr, ThinVec::new())\n-            } else {\n-                let body = this.lower_block(body, false);\n-                this.expr_block(body, ThinVec::new())\n+                if is_simple_argument {\n+                    // If this is the simple case, then we only insert one statement that is\n+                    // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n+                    // `HirId`s are densely assigned.\n+                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let stmt = this.stmt_let_pat(\n+                        desugared_span, Some(P(expr)), argument.pat, hir::LocalSource::AsyncFn);\n+                    statements.push(stmt);\n+                } else {\n+                    // If this is not the simple case, then we construct two statements:\n+                    //\n+                    // ```\n+                    // let __argN = __argN;\n+                    // let <pat> = __argN;\n+                    // ```\n+                    //\n+                    // The first statement moves the argument into the closure and thus ensures\n+                    // that the drop order is correct.\n+                    //\n+                    // The second statement creates the bindings that the user wrote.\n+\n+                    // Construct the `let mut __argN = __argN;` statement. It must be a mut binding\n+                    // because the user may have specified a `ref mut` binding in the next\n+                    // statement.\n+                    let (move_pat, move_id) = this.pat_ident_binding_mode(\n+                        desugared_span, ident, hir::BindingAnnotation::Mutable);\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let move_stmt = this.stmt_let_pat(\n+                        desugared_span, Some(P(move_expr)), move_pat, hir::LocalSource::AsyncFn);\n+\n+                    // Construct the `let <pat> = __argN;` statement. We re-use the original\n+                    // argument's pattern so that `HirId`s are densely assigned.\n+                    let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n+                    let pattern_stmt = this.stmt_let_pat(\n+                        desugared_span, Some(P(pattern_expr)), argument.pat,\n+                        hir::LocalSource::AsyncFn);\n+\n+                    statements.push(move_stmt);\n+                    statements.push(pattern_stmt);\n+                };\n+\n+                arguments.push(new_argument);\n             }\n+\n+            let async_expr = this.make_async_expr(\n+                CaptureBy::Value, closure_id, None, body.span,\n+                |this| {\n+                    let body = this.lower_block_with_stmts(body, false, statements);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n+            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n         })\n     }\n \n@@ -3098,7 +3166,6 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n-                let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemKind::Static(\n                     self.lower_ty(\n                         t,\n@@ -3109,11 +3176,10 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     ),\n                     self.lower_mutability(m),\n-                    value,\n+                    self.lower_const_body(e),\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemKind::Const(\n                     self.lower_ty(\n                         t,\n@@ -3123,50 +3189,31 @@ impl<'a> LoweringContext<'a> {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n                     ),\n-                    value\n+                    self.lower_const_body(e)\n                 )\n             }\n-            ItemKind::Fn(ref decl, ref header, ref generics, ref body) => {\n+            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     this.current_item = Some(ident.span);\n-                    let mut lower_fn = |decl: &FnDecl| {\n-                        // Note: we don't need to change the return type from `T` to\n-                        // `impl Future<Output = T>` here because lower_body\n-                        // only cares about the input argument patterns in the function\n-                        // declaration (decl), not the return types.\n-                        let body_id = this.lower_async_body(&decl, &header.asyncness.node, body);\n-\n-                        let (generics, fn_decl) = this.add_in_band_defs(\n-                            generics,\n-                            fn_def_id,\n-                            AnonymousLifetimeMode::PassThrough,\n-                            |this, idty| this.lower_fn_decl(\n-                                &decl,\n-                                Some((fn_def_id, idty)),\n-                                true,\n-                                header.asyncness.node.opt_return_id()\n-                            ),\n-                        );\n \n-                        (body_id, generics, fn_decl)\n-                    };\n+                    // Note: we don't need to change the return type from `T` to\n+                    // `impl Future<Output = T>` here because lower_body\n+                    // only cares about the input argument patterns in the function\n+                    // declaration (decl), not the return types.\n+                    let body_id = this.lower_maybe_async_body(&decl, header.asyncness.node, body);\n \n-                    let (body_id, generics, fn_decl) = if let IsAsync::Async {\n-                        arguments, ..\n-                    } = &header.asyncness.node {\n-                        let mut decl = decl.clone();\n-                        // Replace the arguments of this async function with the generated\n-                        // arguments that will be moved into the closure.\n-                        for (i, a) in arguments.clone().drain(..).enumerate() {\n-                            if let Some(arg) = a.arg {\n-                                decl.inputs[i] = arg;\n-                            }\n-                        }\n-                        lower_fn(&decl)\n-                    } else {\n-                        lower_fn(decl)\n-                    };\n+                    let (generics, fn_decl) = this.add_in_band_defs(\n+                        generics,\n+                        fn_def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, idty| this.lower_fn_decl(\n+                            &decl,\n+                            Some((fn_def_id, idty)),\n+                            true,\n+                            header.asyncness.node.opt_return_id()\n+                        ),\n+                    );\n \n                     hir::ItemKind::Fn(\n                         fn_decl,\n@@ -3548,7 +3595,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_ty(ty, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n-                        .map(|x| self.lower_body(None, |this| this.lower_expr(x))),\n+                        .map(|x| self.lower_const_body(x)),\n                 ),\n             ),\n             TraitItemKind::Method(ref sig, None) => {\n@@ -3563,7 +3610,7 @@ impl<'a> LoweringContext<'a> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n             }\n             TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                let body_id = self.lower_body(Some(&sig.decl), |this| {\n+                let body_id = self.lower_fn_body(&sig.decl, |this| {\n                     let body = this.lower_block(body, false);\n                     this.expr_block(body, ThinVec::new())\n                 });\n@@ -3627,48 +3674,26 @@ impl<'a> LoweringContext<'a> {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, node) = match i.node {\n-            ImplItemKind::Const(ref ty, ref expr) => {\n-                let body_id = self.lower_body(None, |this| this.lower_expr(expr));\n-                (\n-                    self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                    hir::ImplItemKind::Const(\n-                        self.lower_ty(ty, ImplTraitContext::disallowed()),\n-                        body_id,\n-                    ),\n-                )\n-            }\n+            ImplItemKind::Const(ref ty, ref expr) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+                    self.lower_const_body(expr),\n+                ),\n+            ),\n             ImplItemKind::Method(ref sig, ref body) => {\n-                let mut lower_method = |sig: &MethodSig| {\n-                    let body_id = self.lower_async_body(\n-                        &sig.decl, &sig.header.asyncness.node, body\n-                    );\n-                    let impl_trait_return_allow = !self.is_in_trait_impl;\n-                    let (generics, sig) = self.lower_method_sig(\n-                        &i.generics,\n-                        sig,\n-                        impl_item_def_id,\n-                        impl_trait_return_allow,\n-                        sig.header.asyncness.node.opt_return_id(),\n-                    );\n-                    (body_id, generics, sig)\n-                };\n-\n-                let (body_id, generics, sig) = if let IsAsync::Async {\n-                    ref arguments, ..\n-                } = sig.header.asyncness.node {\n-                    let mut sig = sig.clone();\n-                    // Replace the arguments of this async function with the generated\n-                    // arguments that will be moved into the closure.\n-                    for (i, a) in arguments.clone().drain(..).enumerate() {\n-                        if let Some(arg) = a.arg {\n-                            sig.decl.inputs[i] = arg;\n-                        }\n-                    }\n-                    lower_method(&sig)\n-                } else {\n-                    lower_method(sig)\n-                };\n                 self.current_item = Some(i.span);\n+                let body_id = self.lower_maybe_async_body(\n+                    &sig.decl, sig.header.asyncness.node, body\n+                );\n+                let impl_trait_return_allow = !self.is_in_trait_impl;\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    impl_item_def_id,\n+                    impl_trait_return_allow,\n+                    sig.header.asyncness.node.opt_return_id(),\n+                );\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n@@ -3860,7 +3885,7 @@ impl<'a> LoweringContext<'a> {\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n     ) -> (hir::Generics, hir::MethodSig) {\n-        let header = self.lower_fn_header(&sig.header);\n+        let header = self.lower_fn_header(sig.header);\n         let (generics, decl) = self.add_in_band_defs(\n             generics,\n             fn_def_id,\n@@ -3882,10 +3907,10 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_header(&mut self, h: &FnHeader) -> hir::FnHeader {\n+    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n         hir::FnHeader {\n             unsafety: self.lower_unsafety(h.unsafety),\n-            asyncness: self.lower_asyncness(&h.asyncness.node),\n+            asyncness: self.lower_asyncness(h.asyncness.node),\n             constness: self.lower_constness(h.constness),\n             abi: h.abi,\n         }\n@@ -3905,7 +3930,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_asyncness(&mut self, a: &IsAsync) -> hir::IsAsync {\n+    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n         match a {\n             IsAsync::Async { .. } => hir::IsAsync::Async,\n             IsAsync::NotAsync => hir::IsAsync::NotAsync,\n@@ -4064,7 +4089,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_new_scopes(|this| {\n             hir::AnonConst {\n                 hir_id: this.lower_node_id(c.id),\n-                body: this.lower_body(None, |this| this.lower_expr(&c.value)),\n+                body: this.lower_const_body(&c.value),\n             }\n         })\n     }\n@@ -4151,10 +4176,7 @@ impl<'a> LoweringContext<'a> {\n                 let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n \n                 // Lower condition:\n-                let span_block = self\n-                    .sess\n-                    .source_map()\n-                    .mark_span_with_reason(IfTemporary, cond.span, None);\n+                let span_block = self.mark_span_with_reason(IfTemporary, cond.span, None);\n                 let cond = self.lower_expr(cond);\n                 // Wrap in a construct equivalent to `{ let _t = $cond; _t }` to preserve drop\n                 // semantics since `if cond { ... }` don't let temporaries live outside of `cond`.\n@@ -4184,7 +4206,7 @@ impl<'a> LoweringContext<'a> {\n             }),\n             ExprKind::TryBlock(ref body) => {\n                 self.with_catch_scope(body.id, |this| {\n-                    let unstable_span = this.sess.source_map().mark_span_with_reason(\n+                    let unstable_span = this.mark_span_with_reason(\n                         CompilerDesugaringKind::TryBlock,\n                         body.span,\n                         Some(vec![sym::try_trait].into()),\n@@ -4222,7 +4244,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::Await(_origin, ref expr) => self.lower_await(e.span, expr),\n             ExprKind::Closure(\n-                capture_clause, ref asyncness, movability, ref decl, ref body, fn_decl_span\n+                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n                     let outer_decl = FnDecl {\n@@ -4255,12 +4277,12 @@ impl<'a> LoweringContext<'a> {\n \n                         // Transform `async |x: u8| -> X { ... }` into\n                         // `|x: u8| future_from_generator(|| -> X { ... })`.\n-                        let body_id = this.lower_body(Some(&outer_decl), |this| {\n+                        let body_id = this.lower_fn_body(&outer_decl, |this| {\n                             let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n                                 Some(&**ty)\n                             } else { None };\n                             let async_body = this.make_async_expr(\n-                                capture_clause, *closure_id, async_ret_ty, body.span,\n+                                capture_clause, closure_id, async_ret_ty, body.span,\n                                 |this| {\n                                     this.with_new_scopes(|this| this.lower_expr(body))\n                                 });\n@@ -4281,7 +4303,7 @@ impl<'a> LoweringContext<'a> {\n                     self.with_new_scopes(|this| {\n                         this.current_item = Some(fn_decl_span);\n                         let mut is_generator = false;\n-                        let body_id = this.lower_body(Some(decl), |this| {\n+                        let body_id = this.lower_fn_body(decl, |this| {\n                             let e = this.lower_expr(body);\n                             is_generator = this.is_generator;\n                             e\n@@ -4616,7 +4638,7 @@ impl<'a> LoweringContext<'a> {\n                 // expand <head>\n                 let mut head = self.lower_expr(head);\n                 let head_sp = head.span;\n-                let desugared_span = self.sess.source_map().mark_span_with_reason(\n+                let desugared_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::ForLoop,\n                     head_sp,\n                     None,\n@@ -4770,13 +4792,13 @@ impl<'a> LoweringContext<'a> {\n                 //                 return Try::from_error(From::from(err)),\n                 // }\n \n-                let unstable_span = self.sess.source_map().mark_span_with_reason(\n+                let unstable_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     e.span,\n                     Some(vec![sym::try_trait].into()),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n-                let try_span = self.sess.source_map().mark_span_with_reason(\n+                let try_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     try_span,\n                     Some(vec![sym::try_trait].into()),\n@@ -5573,12 +5595,12 @@ impl<'a> LoweringContext<'a> {\n             err.emit();\n             return hir::ExprKind::Err;\n         }\n-        let span = self.sess.source_map().mark_span_with_reason(\n+        let span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n             None,\n         );\n-        let gen_future_span = self.sess.source_map().mark_span_with_reason(\n+        let gen_future_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n             Some(vec![sym::gen_future].into()),"}, {"sha": "a4484c81738983c53d434ec3be8086d6c5f78ec4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -64,17 +64,16 @@ impl<'a> DefCollector<'a> {\n         id: NodeId,\n         name: Name,\n         span: Span,\n-        header: &'a FnHeader,\n+        header: &FnHeader,\n         generics: &'a Generics,\n         decl: &'a FnDecl,\n         body: &'a Block,\n     ) {\n-        let (closure_id, return_impl_trait_id, arguments) = match &header.asyncness.node {\n+        let (closure_id, return_impl_trait_id) = match header.asyncness.node {\n             IsAsync::Async {\n                 closure_id,\n                 return_impl_trait_id,\n-                arguments,\n-            } => (closure_id, return_impl_trait_id, arguments),\n+            } => (closure_id, return_impl_trait_id),\n             _ => unreachable!(),\n         };\n \n@@ -83,38 +82,16 @@ impl<'a> DefCollector<'a> {\n         let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n         let fn_def = self.create_def(id, fn_def_data, span);\n         return self.with_parent(fn_def, |this| {\n-            this.create_def(*return_impl_trait_id, DefPathData::ImplTrait, span);\n+            this.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n \n             visit::walk_generics(this, generics);\n-\n-            // Walk the generated arguments for the `async fn`.\n-            for (i, a) in arguments.iter().enumerate() {\n-                use visit::Visitor;\n-                if let Some(arg) = &a.arg {\n-                    this.visit_ty(&arg.ty);\n-                } else {\n-                    this.visit_ty(&decl.inputs[i].ty);\n-                }\n-            }\n-\n-            // We do not invoke `walk_fn_decl` as this will walk the arguments that are being\n-            // replaced.\n-            visit::walk_fn_ret_ty(this, &decl.output);\n+            visit::walk_fn_decl(this, decl);\n \n             let closure_def = this.create_def(\n-                *closure_id, DefPathData::ClosureExpr, span,\n+                closure_id, DefPathData::ClosureExpr, span,\n             );\n             this.with_parent(closure_def, |this| {\n-                use visit::Visitor;\n-                // Walk each of the generated statements before the regular block body.\n-                for a in arguments {\n-                    this.visit_stmt(&a.move_stmt);\n-                    if let Some(pat_stmt) = &a.pat_stmt {\n-                        this.visit_stmt(&pat_stmt);\n-                    }\n-                }\n-\n-                visit::walk_block(this, &body);\n+                visit::walk_block(this, body);\n             })\n         })\n     }\n@@ -302,7 +279,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         match expr.node {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n-            ExprKind::Closure(_, ref asyncness, ..) => {\n+            ExprKind::Closure(_, asyncness, ..) => {\n                 let closure_def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n                                           expr.span);\n@@ -311,7 +288,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 // Async closures desugar to closures inside of closures, so\n                 // we must create two defs.\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n-                    let async_def = self.create_def(*closure_id,\n+                    let async_def = self.create_def(closure_id,\n                                                     DefPathData::ClosureExpr,\n                                                     expr.span);\n                     self.parent_def = Some(async_def);"}, {"sha": "65fc56f2c48787e8d1747f4aa912d549bd214888", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -1929,26 +1929,6 @@ pub struct InlineAsm {\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub hir_id: HirId,\n-    pub source: ArgSource,\n-}\n-\n-impl Arg {\n-    /// Returns the pattern representing the original binding for this argument.\n-    pub fn original_pat(&self) -> &P<Pat> {\n-        match &self.source {\n-            ArgSource::Normal => &self.pat,\n-            ArgSource::AsyncFn(pat) => &pat,\n-        }\n-    }\n-}\n-\n-/// Represents the source of an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum ArgSource {\n-    /// Argument as specified by the user.\n-    Normal,\n-    /// Generated argument from `async fn` lowering, contains the original binding pattern.\n-    AsyncFn(P<Pat>),\n }\n \n /// Represents the header (not the body) of a function declaration."}, {"sha": "ecdcb4bbf114a44de9a37f4c530c3d4ef42748b8", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -86,12 +86,12 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_arg_sup.original_pat().simple_ident() {\n+        let span_label_var1 = match anon_arg_sup.pat.simple_ident() {\n             Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n             None => String::new(),\n         };\n \n-        let span_label_var2 = match anon_arg_sub.original_pat().simple_ident() {\n+        let span_label_var2 = match anon_arg_sub.pat.simple_ident() {\n             Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n             None => String::new(),\n         };"}, {"sha": "0efc124e31fee10350238d7be32f935ef6639813", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = match arg.original_pat().simple_ident() {\n+        let (error_var, span_label_var) = match arg.pat.simple_ident() {\n             Some(simple_ident) => (\n                 format!(\"the type of `{}`\", simple_ident),\n                 format!(\"the type of `{}`\", simple_ident),"}, {"sha": "c5c6c4b944700c0fdef79fb6a6a9debda17d9528", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -1335,30 +1335,6 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n         run_early_pass!(self, check_mac, mac);\n     }\n-\n-    fn visit_fn_header(&mut self, header: &'a ast::FnHeader) {\n-        // Unlike in HIR lowering and name resolution, the `AsyncArgument` statements are not added\n-        // to the function body and the arguments do not replace those in the declaration. They are\n-        // still visited manually here so that buffered lints can be emitted.\n-        if let ast::IsAsync::Async { ref arguments, .. } = header.asyncness.node {\n-            for a in arguments {\n-                // Visit the argument..\n-                if let Some(arg) = &a.arg {\n-                    self.visit_pat(&arg.pat);\n-                    if let ast::ArgSource::AsyncFn(pat) = &arg.source {\n-                        self.visit_pat(pat);\n-                    }\n-                    self.visit_ty(&arg.ty);\n-                }\n-\n-                // ..and the statement.\n-                self.visit_stmt(&a.move_stmt);\n-                if let Some(pat_stmt) = &a.pat_stmt {\n-                    self.visit_stmt(&pat_stmt);\n-                }\n-            }\n-        }\n-    }\n }\n \n struct LateLintPassObjects<'a> {"}, {"sha": "7c57c50595bc8db00ac47645db65b10a0a97c325", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -2414,9 +2414,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 have_bound_regions,\n             } = info;\n \n-            let help_name = if let Some(body) = parent {\n-                let arg = &self.tcx.hir().body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(arg.original_pat().hir_id))\n+            let help_name = if let Some(ident) = parent.and_then(|body| {\n+                self.tcx.hir().body(body).arguments[index].pat.simple_ident()\n+            }) {\n+                format!(\"`{}`\", ident)\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };"}, {"sha": "91106ebd77e070d63ac9c6d3ff8bc5b1c922edb4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -126,6 +126,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n                             opt_ty_info = None;\n                             self_arg = None;\n                         }\n+\n                         ArgInfo(fn_sig.inputs()[index], opt_ty_info, Some(&*arg.pat), self_arg)\n                     });\n \n@@ -614,10 +615,7 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'gcx>(Ty<'gcx>,\n-                     Option<Span>,\n-                     Option<&'gcx hir::Pat>,\n-                     Option<ImplicitSelfKind>);\n+struct ArgInfo<'gcx>(Ty<'gcx>, Option<Span>, Option<&'gcx hir::Pat>, Option<ImplicitSelfKind>);\n \n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: hir::HirId,\n@@ -883,21 +881,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // debuginfo and so that error reporting knows that this is a user\n             // variable. For any other pattern the pattern introduces new\n             // variables which will be named instead.\n-            let mut name = None;\n-            if let Some(pat) = pattern {\n-                match pat.node {\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _)\n-                    | hir::PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, _) => {\n-                        name = Some(ident.name);\n-                    }\n-                    _ => (),\n-                }\n-            }\n-\n-            let source_info = SourceInfo {\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-                span: pattern.map_or(self.fn_span, |pat| pat.span)\n+            let (name, span) = if let Some(pat) = pattern {\n+                (pat.simple_ident().map(|ident| ident.name), pat.span)\n+            } else {\n+                (None, self.fn_span)\n             };\n+\n+            let source_info = SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span, };\n             self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Mut,\n                 ty,\n@@ -932,7 +922,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 match *pattern.kind {\n                     // Don't introduce extra copies for simple bindings\n-                    PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n+                    PatternKind::Binding {\n+                        mutability,\n+                        var,\n+                        mode: BindingMode::ByValue,\n+                        subpattern: None,\n+                        ..\n+                    } => {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].is_user_variable =\n                             if let Some(kind) = self_binding {"}, {"sha": "89c4a9106a4773a7dbc593b8d2842b87b58a74b6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -222,7 +222,7 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_trait_fn_not_async(&self, span: Span, asyncness: &IsAsync) {\n+    fn check_trait_fn_not_async(&self, span: Span, asyncness: IsAsync) {\n         if asyncness.is_async() {\n             struct_span_err!(self.session, span, E0706,\n                              \"trait fns cannot be declared `async`\").emit()\n@@ -561,7 +561,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.invalid_visibility(&impl_item.vis, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.header.constness);\n-                        self.check_trait_fn_not_async(impl_item.span, &sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n                     }\n                 }\n             }\n@@ -633,7 +633,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n-                        self.check_trait_fn_not_async(trait_item.span, &sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness.node);\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, mut_ident| {"}, {"sha": "f084d3b9f28c3a4c8c7dae9793f215a4fd24cf58", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -948,16 +948,6 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n         intravisit::walk_pat(self, pat);\n     }\n-\n-    fn visit_argument_source(&mut self, s: &'tcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1147,16 +1137,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n-    fn visit_argument_source(&mut self, s: &'tcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n-\n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         if let Some(ref init) = local.init {\n             if self.check_expr_pat_type(init.hir_id, init.span) {"}, {"sha": "99abe69017da729245d96620c4576ded94a23c87", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 52, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -855,15 +855,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 _: NodeId)\n     {\n         debug!(\"(resolving function) entering function\");\n-        let (rib_kind, asyncness) = match function_kind {\n-            FnKind::ItemFn(_, ref header, ..) =>\n-                (FnItemRibKind, &header.asyncness.node),\n-            FnKind::Method(_, ref sig, _, _) =>\n-                (AssocItemRibKind, &sig.header.asyncness.node),\n-            FnKind::Closure(_) =>\n-                // Async closures aren't resolved through `visit_fn`-- they're\n-                // processed separately\n-                (NormalRibKind, &IsAsync::NotAsync),\n+        let rib_kind = match function_kind {\n+            FnKind::ItemFn(..) => FnItemRibKind,\n+            FnKind::Method(..) => AssocItemRibKind,\n+            FnKind::Closure(_) => NormalRibKind,\n         };\n \n         // Create a value rib for the function.\n@@ -874,45 +869,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n \n         // Add each argument to the rib.\n         let mut bindings_list = FxHashMap::default();\n-        let mut add_argument = |argument: &ast::Arg| {\n+        for argument in &declaration.inputs {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+\n             self.visit_ty(&argument.ty);\n-            debug!(\"(resolving function) recorded argument\");\n-        };\n \n-        // Walk the generated async arguments if this is an `async fn`, otherwise walk the\n-        // normal arguments.\n-        if let IsAsync::Async { ref arguments, .. } = asyncness {\n-            for (i, a) in arguments.iter().enumerate() {\n-                if let Some(arg) = &a.arg {\n-                    add_argument(&arg);\n-                } else {\n-                    add_argument(&declaration.inputs[i]);\n-                }\n-            }\n-        } else {\n-            for a in &declaration.inputs { add_argument(a); }\n+            debug!(\"(resolving function) recorded argument\");\n         }\n-\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n         match function_kind {\n-            FnKind::ItemFn(.., body) | FnKind::Method(.., body) => {\n-                if let IsAsync::Async { ref arguments, .. } = asyncness {\n-                    let mut body = body.clone();\n-                    // Insert the generated statements into the body before attempting to\n-                    // resolve names.\n-                    for a in arguments.iter().rev() {\n-                        if let Some(pat_stmt) = a.pat_stmt.clone() {\n-                            body.stmts.insert(0, pat_stmt);\n-                        }\n-                        body.stmts.insert(0, a.move_stmt.clone());\n-                    }\n-                    self.visit_block(&body);\n-                } else {\n-                    self.visit_block(body);\n-                }\n+            FnKind::ItemFn(.., body) |\n+            FnKind::Method(.., body) => {\n+                self.visit_block(body);\n             }\n             FnKind::Closure(body) => {\n                 self.visit_expr(body);\n@@ -4178,7 +4148,7 @@ impl<'a> Resolver<'a> {\n         let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n-                    if !ident.is_gensymed() && filter_fn(binding.res()) {\n+                    if filter_fn(binding.res()) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: binding.res().article(),\n@@ -4196,7 +4166,7 @@ impl<'a> Resolver<'a> {\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n-                    if !ident.is_gensymed() && filter_fn(res) {\n+                    if filter_fn(res) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: res.article(),\n@@ -4226,7 +4196,7 @@ impl<'a> Resolver<'a> {\n                                             },\n                                         );\n \n-                                        if !ident.is_gensymed() && filter_fn(crate_mod) {\n+                                        if filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n                                                 candidate: ident.name,\n                                                 article: \"a\",\n@@ -4249,15 +4219,13 @@ impl<'a> Resolver<'a> {\n             // Add primitive types to the mix\n             if filter_fn(Res::PrimTy(Bool)) {\n                 names.extend(\n-                    self.primitive_type_table.primitive_types\n-                        .iter()\n-                        .map(|(name, _)| {\n-                            TypoSuggestion {\n-                                candidate: *name,\n-                                article: \"a\",\n-                                kind: \"primitive type\",\n-                            }\n-                        })\n+                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n+                        TypoSuggestion {\n+                            candidate: *name,\n+                            article: \"a\",\n+                            kind: \"primitive type\",\n+                        }\n+                    })\n                 )\n             }\n         } else {"}, {"sha": "db8b5eacd94d9321f2f7e7b9b1175f927590e693", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -374,7 +374,7 @@ impl Sig for ast::Item {\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Fn(ref decl, ref header, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, header, ref generics, _) => {\n                 let mut text = String::new();\n                 if header.constness.node == ast::Constness::Const {\n                     text.push_str(\"const \");"}, {"sha": "3ada80b3e8b7015e03df59364917ae815ec77cbd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -1009,16 +1009,6 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n                 _: hir::BodyId, _: Span, _: hir::HirId) { }\n-\n-    fn visit_argument_source(&mut self, s: &'gcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n /// When `check_fn` is invoked on a generator (i.e., a body that"}, {"sha": "6f8682e64671c3fb4afe381816858d7c0f7c907d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -311,16 +311,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         let ty = self.resolve(&ty, &hir_ty.span);\n         self.write_ty_to_tables(hir_ty.hir_id, ty);\n     }\n-\n-    fn visit_argument_source(&mut self, s: &'gcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {"}, {"sha": "0c00b3b20b5b3f36c8391580f64206e67b6960f7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -2019,7 +2019,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n                 Argument {\n-                    name: name_from_pat(&body.arguments[i].original_pat()),\n+                    name: name_from_pat(&body.arguments[i].pat),\n                     type_: ty.clean(cx),\n                 }\n             }).collect()"}, {"sha": "b8a10d90c3c0afe10974137fa06b5238d4a5e05a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -879,17 +879,6 @@ pub struct Local {\n     pub id: NodeId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n-    /// Origin of this local variable.\n-    pub source: LocalSource,\n-}\n-\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n-pub enum LocalSource {\n-    /// Local was parsed from source.\n-    Normal,\n-    /// Within `ast::IsAsync::Async`, a local is generated that will contain the moved arguments\n-    /// of an `async fn`.\n-    AsyncFn,\n }\n \n /// An arm of a 'match'.\n@@ -1770,16 +1759,6 @@ pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n-    pub source: ArgSource,\n-}\n-\n-/// The source of an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ArgSource {\n-    /// Argument as written by the user.\n-    Normal,\n-    /// Argument from `async fn` lowering, contains the original binding pattern.\n-    AsyncFn(P<Pat>),\n }\n \n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n@@ -1839,7 +1818,6 @@ impl Arg {\n             }),\n             ty,\n             id: DUMMY_NODE_ID,\n-            source: ArgSource::Normal,\n         };\n         match eself.node {\n             SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n@@ -1894,52 +1872,31 @@ pub enum Unsafety {\n     Normal,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct AsyncArgument {\n-    /// `__arg0`\n-    pub ident: Ident,\n-    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`. Only if\n-    /// argument is not a simple binding.\n-    pub arg: Option<Arg>,\n-    /// `let __arg0 = __arg0;` statement to be inserted at the start of the block.\n-    pub move_stmt: Stmt,\n-    /// `let <pat> = __arg0;` statement to be inserted at the start of the block, after matching\n-    /// move statement. Only if argument is not a simple binding.\n-    pub pat_stmt: Option<Stmt>,\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAsync {\n     Async {\n         closure_id: NodeId,\n         return_impl_trait_id: NodeId,\n-        /// This field stores the arguments and statements that are used in HIR lowering to\n-        /// ensure that `async fn` arguments are dropped at the correct time.\n-        ///\n-        /// The argument and statements here are generated at parse time as they are required in\n-        /// both the hir lowering, def collection and name resolution and this stops them needing\n-        /// to be created in each place.\n-        arguments: Vec<AsyncArgument>,\n     },\n     NotAsync,\n }\n \n impl IsAsync {\n-    pub fn is_async(&self) -> bool {\n-        if let IsAsync::Async { .. } = *self {\n+    pub fn is_async(self) -> bool {\n+        if let IsAsync::Async { .. } = self {\n             true\n         } else {\n             false\n         }\n     }\n \n     /// In ths case this is an `async` return, the `NodeId` for the generated `impl Trait` item.\n-    pub fn opt_return_id(&self) -> Option<NodeId> {\n+    pub fn opt_return_id(self) -> Option<NodeId> {\n         match self {\n             IsAsync::Async {\n                 return_impl_trait_id,\n                 ..\n-            } => Some(*return_impl_trait_id),\n+            } => Some(return_impl_trait_id),\n             IsAsync::NotAsync => None,\n         }\n     }\n@@ -2279,7 +2236,7 @@ impl Item {\n ///\n /// All the information between the visibility and the name of the function is\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub asyncness: Spanned<IsAsync>,"}, {"sha": "47c79f8466a95c486983fc5f1b33a4409865a562", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -516,7 +516,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -545,7 +544,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -563,7 +561,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span,\n             attrs: ThinVec::new(),\n-            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -971,8 +968,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::Arg {\n             ty,\n             pat: arg_pat,\n-            id: ast::DUMMY_NODE_ID,\n-            source: ast::ArgSource::Normal,\n+            id: ast::DUMMY_NODE_ID\n         }\n     }\n "}, {"sha": "c56c156182bd66089c3202bc7aa72d41003ae508", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -101,13 +101,6 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     fn remove(&mut self, id: ast::NodeId) -> AstFragment {\n         self.expanded_fragments.remove(&id).unwrap()\n     }\n-\n-    fn next_id(&mut self, id: &mut ast::NodeId) {\n-        if self.monotonic {\n-            assert_eq!(*id, ast::DUMMY_NODE_ID);\n-            *id = self.cx.resolver.next_node_id()\n-        }\n-    }\n }\n \n impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n@@ -189,19 +182,9 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n         noop_visit_block(block, self);\n \n         for stmt in block.stmts.iter_mut() {\n-            self.next_id(&mut stmt.id);\n-        }\n-    }\n-\n-    fn visit_asyncness(&mut self, a: &mut ast::IsAsync) {\n-        noop_visit_asyncness(a, self);\n-\n-        if let ast::IsAsync::Async { ref mut arguments, .. } = a {\n-            for argument in arguments.iter_mut() {\n-                self.next_id(&mut argument.move_stmt.id);\n-                if let Some(ref mut pat_stmt) = &mut argument.pat_stmt {\n-                    self.next_id(&mut pat_stmt.id);\n-                }\n+            if self.monotonic {\n+                assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                stmt.id = self.cx.resolver.next_node_id();\n             }\n         }\n     }"}, {"sha": "757513098995be60379061d73adeb29c129ba635", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -207,10 +207,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_local(l, self);\n     }\n \n-    fn visit_local_source(&mut self, l: &mut LocalSource) {\n-        noop_visit_local_source(l, self);\n-    }\n-\n     fn visit_mac(&mut self, _mac: &mut Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // N.B., see note about macros above. If you really want a visitor that\n@@ -234,10 +230,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_arg(a, self);\n     }\n \n-    fn visit_arg_source(&mut self, a: &mut ArgSource) {\n-        noop_visit_arg_source(a, self);\n-    }\n-\n     fn visit_generics(&mut self, generics: &mut Generics) {\n         noop_visit_generics(generics, self);\n     }\n@@ -522,17 +514,13 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(args: &mut Parenth\n }\n \n pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n-    let Local { id, pat, ty, init, span, attrs, source } = local.deref_mut();\n+    let Local { id, pat, ty, init, span, attrs } = local.deref_mut();\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(ty, |ty| vis.visit_ty(ty));\n     visit_opt(init, |init| vis.visit_expr(init));\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n-    vis.visit_local_source(source);\n-}\n-\n-pub fn noop_visit_local_source<T: MutVisitor>(_local_source: &mut LocalSource, _vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n@@ -571,18 +559,10 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty, source }: &mut Arg, vis: &mut T) {\n+pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty }: &mut Arg, vis: &mut T) {\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     vis.visit_ty(ty);\n-    vis.visit_arg_source(source);\n-}\n-\n-pub fn noop_visit_arg_source<T: MutVisitor>(source: &mut ArgSource, vis: &mut T) {\n-    match source {\n-        ArgSource::Normal => {},\n-        ArgSource::AsyncFn(pat) => vis.visit_pat(pat),\n-    }\n }\n \n pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n@@ -690,25 +670,9 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n \n pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T) {\n     match asyncness {\n-        IsAsync::Async { closure_id, return_impl_trait_id, ref mut arguments } => {\n+        IsAsync::Async { closure_id, return_impl_trait_id } => {\n             vis.visit_id(closure_id);\n             vis.visit_id(return_impl_trait_id);\n-            for AsyncArgument { ident, arg, pat_stmt, move_stmt } in arguments.iter_mut() {\n-                vis.visit_ident(ident);\n-                if let Some(arg) = arg {\n-                    vis.visit_arg(arg);\n-                }\n-                visit_clobber(move_stmt, |stmt| {\n-                    vis.flat_map_stmt(stmt)\n-                        .expect_one(\"expected visitor to produce exactly one item\")\n-                });\n-                visit_opt(pat_stmt, |stmt| {\n-                    visit_clobber(stmt, |stmt| {\n-                        vis.flat_map_stmt(stmt)\n-                            .expect_one(\"expected visitor to produce exactly one item\")\n-                    })\n-                });\n-            }\n         }\n         IsAsync::NotAsync => {}\n     }"}, {"sha": "5df22f28797a4813a49d7530e517e1f2f123de3d", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -27,7 +27,7 @@ crate fn dummy_arg(ident: Ident) -> Arg {\n         span: ident.span,\n         id: ast::DUMMY_NODE_ID\n     };\n-    Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal }\n+    Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID }\n }\n \n pub enum Error {"}, {"sha": "ae1e5116c676e884847f1715be28fc1cd2ac15e2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 129, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -1,9 +1,9 @@\n // ignore-tidy-filelength\n \n-use crate::ast::{AngleBracketedArgs, AsyncArgument, ParenthesizedArgs, AttrStyle, BareFnTy};\n+use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n use crate::ast::{GenericBound, TraitBoundModifier};\n use crate::ast::Unsafety;\n-use crate::ast::{Mod, AnonConst, Arg, ArgSource, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n+use crate::ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n use crate::ast::Block;\n use crate::ast::{BlockCheckMode, CaptureBy, Movability};\n use crate::ast::{Constness, Crate};\n@@ -16,7 +16,7 @@ use crate::ast::{GenericParam, GenericParamKind};\n use crate::ast::GenericArg;\n use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n use crate::ast::{Label, Lifetime};\n-use crate::ast::{Local, LocalSource};\n+use crate::ast::Local;\n use crate::ast::MacStmtStyle;\n use crate::ast::{Mac, Mac_, MacDelimiter};\n use crate::ast::{MutTy, Mutability};\n@@ -51,7 +51,7 @@ use crate::parse::diagnostics::{Error, dummy_arg};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n-use syntax_pos::{Span, BytePos, DUMMY_SP, FileName, hygiene::CompilerDesugaringKind};\n+use syntax_pos::{Span, BytePos, DUMMY_SP, FileName};\n use log::debug;\n \n use std::borrow::Cow;\n@@ -1126,7 +1126,6 @@ impl<'a> Parser<'a> {\n             IsAsync::Async {\n                 closure_id: ast::DUMMY_NODE_ID,\n                 return_impl_trait_id: ast::DUMMY_NODE_ID,\n-                arguments: Vec::new(),\n             }\n         } else {\n             IsAsync::NotAsync\n@@ -1185,12 +1184,12 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n         } else {\n-            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n \n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n \n-            let mut decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n+            let decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n                 // This is somewhat dubious; We don't want to allow\n                 // argument names to be left off if there is a\n                 // definition...\n@@ -1199,7 +1198,6 @@ impl<'a> Parser<'a> {\n                 p.parse_arg_general(p.span.rust_2018(), true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n-            self.construct_async_arguments(&mut asyncness, &mut decl);\n \n             let sig = ast::MethodSig {\n                 header: FnHeader {\n@@ -1563,7 +1561,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal })\n+        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n     }\n \n     /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n@@ -1581,8 +1579,7 @@ impl<'a> Parser<'a> {\n         Ok(Arg {\n             ty: t,\n             pat,\n-            id: ast::DUMMY_NODE_ID,\n-            source: ast::ArgSource::Normal,\n+            id: ast::DUMMY_NODE_ID\n         })\n     }\n \n@@ -4213,7 +4210,6 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: lo.to(hi),\n             attrs,\n-            source: LocalSource::Normal,\n         }))\n     }\n \n@@ -5664,16 +5660,15 @@ impl<'a> Parser<'a> {\n     /// Parses an item-position function declaration.\n     fn parse_item_fn(&mut self,\n                      unsafety: Unsafety,\n-                     mut asyncness: Spanned<IsAsync>,\n+                     asyncness: Spanned<IsAsync>,\n                      constness: Spanned<Constness>,\n                      abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n         let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n-        let mut decl = self.parse_fn_decl(allow_c_variadic)?;\n+        let decl = self.parse_fn_decl(allow_c_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        self.construct_async_arguments(&mut asyncness, &mut decl);\n         let header = FnHeader { unsafety, asyncness, constness, abi };\n         Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n     }\n@@ -5853,14 +5848,13 @@ impl<'a> Parser<'a> {\n             Ok((Ident::invalid(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n-            let mut decl = self.parse_fn_decl_with_self(|p| {\n+            let decl = self.parse_fn_decl_with_self(|p| {\n                 p.parse_arg_general(true, true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n-            self.construct_async_arguments(&mut asyncness, &mut decl);\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n@@ -7222,7 +7216,6 @@ impl<'a> Parser<'a> {\n                                     respan(async_span, IsAsync::Async {\n                                         closure_id: ast::DUMMY_NODE_ID,\n                                         return_impl_trait_id: ast::DUMMY_NODE_ID,\n-                                        arguments: Vec::new(),\n                                     }),\n                                     respan(fn_span, Constness::NotConst),\n                                     Abi::Rust)?;\n@@ -7853,116 +7846,6 @@ impl<'a> Parser<'a> {\n             Applicability::MaybeIncorrect,\n         ).emit();\n     }\n-\n-    /// When lowering a `async fn` to the HIR, we need to move all of the arguments of the function\n-    /// into the generated closure so that they are dropped when the future is polled and not when\n-    /// it is created.\n-    ///\n-    /// The arguments of the function are replaced in HIR lowering with the arguments created by\n-    /// this function and the statements created here are inserted at the top of the closure body.\n-    fn construct_async_arguments(&mut self, asyncness: &mut Spanned<IsAsync>, decl: &mut FnDecl) {\n-        // FIXME(davidtwco): This function should really live in the HIR lowering but because\n-        // the types constructed here need to be used in parts of resolve so that the correct\n-        // locals are considered upvars, it is currently easier for it to live here in the parser,\n-        // where it can be constructed once.\n-        if let IsAsync::Async { ref mut arguments, .. } = asyncness.node {\n-            for (index, input) in decl.inputs.iter_mut().enumerate() {\n-                let id = ast::DUMMY_NODE_ID;\n-                let span = input.pat.span;\n-                let desugared_span = self.sess.source_map()\n-                    .mark_span_with_reason(CompilerDesugaringKind::Async, span, None);\n-\n-                // Construct a name for our temporary argument.\n-                let name = format!(\"__arg{}\", index);\n-                let ident = Ident::from_str(&name).gensym();\n-\n-                // Check if this is a ident pattern, if so, we can optimize and avoid adding a\n-                // `let <pat> = __argN;` statement, instead just adding a `let <pat> = <pat>;`\n-                // statement.\n-                let (binding_mode, ident, is_simple_pattern) = match input.pat.node {\n-                    PatKind::Ident(binding_mode @ BindingMode::ByValue(_), ident, _) => {\n-                        // Simple patterns like this don't have a generated argument, but they are\n-                        // moved into the closure with a statement, so any `mut` bindings on the\n-                        // argument will be unused. This binding mode can't be removed, because\n-                        // this would affect the input to procedural macros, but they can have\n-                        // their span marked as being the result of a compiler desugaring so\n-                        // that they aren't linted against.\n-                        input.pat.span = desugared_span;\n-\n-                        (binding_mode, ident, true)\n-                    }\n-                    _ => (BindingMode::ByValue(Mutability::Mutable), ident, false),\n-                };\n-\n-                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n-                // async function if it isn't a simple pattern.\n-                let arg = if is_simple_pattern {\n-                    None\n-                } else {\n-                    Some(Arg {\n-                        ty: input.ty.clone(),\n-                        id,\n-                        pat: P(Pat {\n-                            id,\n-                            node: PatKind::Ident(\n-                                BindingMode::ByValue(Mutability::Immutable), ident, None,\n-                            ),\n-                            span: desugared_span,\n-                        }),\n-                        source: ArgSource::AsyncFn(input.pat.clone()),\n-                    })\n-                };\n-\n-                // Construct a `let __argN = __argN;` statement to insert at the top of the\n-                // async closure. This makes sure that the argument is captured by the closure and\n-                // that the drop order is correct.\n-                let move_local = Local {\n-                    pat: P(Pat {\n-                        id,\n-                        node: PatKind::Ident(binding_mode, ident, None),\n-                        span: desugared_span,\n-                    }),\n-                    // We explicitly do not specify the type for this statement. When the user's\n-                    // argument type is `impl Trait` then this would require the\n-                    // `impl_trait_in_bindings` feature to also be present for that same type to\n-                    // be valid in this binding. At the time of writing (13 Mar 19),\n-                    // `impl_trait_in_bindings` is not stable.\n-                    ty: None,\n-                    init: Some(P(Expr {\n-                        id,\n-                        node: ExprKind::Path(None, ast::Path {\n-                            span,\n-                            segments: vec![PathSegment { ident, id, args: None }],\n-                        }),\n-                        span,\n-                        attrs: ThinVec::new(),\n-                    })),\n-                    id,\n-                    span,\n-                    attrs: ThinVec::new(),\n-                    source: LocalSource::AsyncFn,\n-                };\n-\n-                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n-                // async closure if this isn't a simple pattern.\n-                let pat_stmt = if is_simple_pattern {\n-                    None\n-                } else {\n-                    Some(Stmt {\n-                        id,\n-                        node: StmtKind::Local(P(Local {\n-                            pat: input.pat.clone(),\n-                            ..move_local.clone()\n-                        })),\n-                        span,\n-                    })\n-                };\n-\n-                let move_stmt = Stmt { id, node: StmtKind::Local(P(move_local)), span };\n-                arguments.push(AsyncArgument { ident, arg, pat_stmt, move_stmt });\n-            }\n-        }\n-    }\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, handler: &errors::Handler) {"}, {"sha": "b81dc53ef6836061b2a5b107b4da3cf994e00534", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -357,7 +357,7 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl,\n-                     header: &ast::FnHeader,\n+                     header: ast::FnHeader,\n                      name: ast::Ident,\n                      generics: &ast::Generics)\n                      -> String {\n@@ -1040,7 +1040,7 @@ impl<'a> State<'a> {\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 self.head(\"\")?;\n-                self.print_fn(decl, &ast::FnHeader::default(),\n+                self.print_fn(decl, ast::FnHeader::default(),\n                               Some(item.ident),\n                               generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n@@ -1170,7 +1170,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            ast::ItemKind::Fn(ref decl, ref header, ref param_names, ref body) => {\n+            ast::ItemKind::Fn(ref decl, header, ref param_names, ref body) => {\n                 self.head(\"\")?;\n                 self.print_fn(\n                     decl,\n@@ -1522,7 +1522,7 @@ impl<'a> State<'a> {\n                             vis: &ast::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n-                      &m.header,\n+                      m.header,\n                       Some(ident),\n                       &generics,\n                       vis)\n@@ -2113,7 +2113,7 @@ impl<'a> State<'a> {\n                 self.bclose_(expr.span, INDENT_UNIT)?;\n             }\n             ast::ExprKind::Closure(\n-                capture_clause, ref asyncness, movability, ref decl, ref body, _) => {\n+                capture_clause, asyncness, movability, ref decl, ref body, _) => {\n                 self.print_movability(movability)?;\n                 self.print_asyncness(asyncness)?;\n                 self.print_capture_clause(capture_clause)?;\n@@ -2710,7 +2710,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    header: &ast::FnHeader,\n+                    header: ast::FnHeader,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     vis: &ast::Visibility) -> io::Result<()> {\n@@ -2765,7 +2765,8 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_asyncness(&mut self, asyncness: &ast::IsAsync) -> io::Result<()> {\n+    pub fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n+                                -> io::Result<()> {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\")?;\n         }\n@@ -3037,7 +3038,7 @@ impl<'a> State<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n-                      &ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n+                      ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n                       name,\n                       &generics,\n                       &source_map::dummy_spanned(ast::VisibilityKind::Inherited))?;\n@@ -3100,7 +3101,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                header: &ast::FnHeader,\n+                                header: ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n         self.s.word(visibility_qualified(vis, \"\"))?;\n \n@@ -3109,7 +3110,7 @@ impl<'a> State<'a> {\n             ast::Constness::Const => self.word_nbsp(\"const\")?\n         }\n \n-        self.print_asyncness(&header.asyncness.node)?;\n+        self.print_asyncness(header.asyncness.node)?;\n         self.print_unsafety(header.unsafety)?;\n \n         if header.abi != Abi::Rust {\n@@ -3158,7 +3159,7 @@ mod tests {\n             assert_eq!(\n                 fun_to_string(\n                     &decl,\n-                    &ast::FnHeader {\n+                    ast::FnHeader {\n                         unsafety: ast::Unsafety::Normal,\n                         constness: source_map::dummy_spanned(ast::Constness::NotConst),\n                         asyncness: source_map::dummy_spanned(ast::IsAsync::NotAsync),"}, {"sha": "a21d2df416206fc3c44534800ea3d2ff79d7a070", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -935,27 +935,6 @@ impl SourceMap {\n \n         None\n     }\n-\n-    /// Reuses the span but adds information like the kind of the desugaring and features that are\n-    /// allowed inside this span.\n-    pub fn mark_span_with_reason(\n-        &self,\n-        reason: hygiene::CompilerDesugaringKind,\n-        span: Span,\n-        allow_internal_unstable: Option<Lrc<[symbol::Symbol]>>,\n-    ) -> Span {\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: span,\n-            def_site: Some(span),\n-            format: CompilerDesugaring(reason),\n-            allow_internal_unstable,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: edition::Edition::from_session(),\n-        });\n-        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n-    }\n }\n \n impl SourceMapper for SourceMap {"}, {"sha": "eb516b5c7c62fd7e5e07fcb865a1a206187ca509", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -544,9 +544,6 @@ pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FunctionR\n pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) {\n     for argument in &function_declaration.inputs {\n         visitor.visit_pat(&argument.pat);\n-        if let ArgSource::AsyncFn(pat) = &argument.source {\n-            visitor.visit_pat(pat);\n-        }\n         visitor.visit_ty(&argument.ty)\n     }\n     visitor.visit_fn_ret_ty(&function_declaration.output)"}, {"sha": "44ddbb98809b4f0d217bc234df31b15071520e35", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -129,7 +129,6 @@ fn stmt_let_undescore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n         attrs: ThinVec::new(),\n-        source: ast::LocalSource::Normal,\n     });\n     ast::Stmt {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "8b939b43b8bd406fdfb717943131a4300419440a", "filename": "src/test/ui/async-await/issues/issue-61187.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -0,0 +1,9 @@\n+// edition:2018\n+#![feature(async_await)]\n+\n+fn main() {\n+}\n+\n+async fn response(data: Vec<u8>) {\n+    data.reverse(); //~ ERROR E0596\n+}"}, {"sha": "a03142263202ef304fb469d94a9b465444952d3f", "filename": "src/test/ui/async-await/issues/issue-61187.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -0,0 +1,11 @@\n+error[E0596]: cannot borrow `data` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-61187.rs:8:5\n+   |\n+LL | async fn response(data: Vec<u8>) {\n+   |                   ---- help: consider changing this to be mutable: `mut data`\n+LL |     data.reverse();\n+   |     ^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "ef9e7e39df0bcf593918664cb827b08c55c35ec2", "filename": "src/test/ui/underscore-lifetime/underscore-lifetime-binders.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a06a93f5999233807afba6109c6a29f768163a4/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a06a93f5999233807afba6109c6a29f768163a4/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr?ref=3a06a93f5999233807afba6109c6a29f768163a4", "patch": "@@ -30,7 +30,7 @@ error[E0106]: missing lifetime specifier\n LL | fn foo2(_: &'_ u8, y: &'_ u8) -> &'_ u8 { y }\n    |                                   ^^ expected lifetime parameter\n    |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `_` or `y`\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from argument 1 or `y`\n \n error: aborting due to 5 previous errors\n "}]}