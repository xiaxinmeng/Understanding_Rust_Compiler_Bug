{"sha": "b5c54df59fa0a99fa860db82e6e82f9c0fbd7115", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YzU0ZGY1OWZhMGE5OWZhODYwZGI4MmU2ZTgyZjljMGZiZDcxMTU=", "commit": {"author": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-06-30T16:41:23Z"}, "committer": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T19:36:02Z"}, "message": "collections::bitv: Add documentation and #[inline]'s\n\nAdd documentation to methods on BitvSet that were missing them. Also\nmake sure #[inline] is on all methods that are (a) one-liners or (b)\nprivate methods whose only purpose is code deduplication.", "tree": {"sha": "6a6d811e2d86bd8cd9c9c1110799ade1c535c092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a6d811e2d86bd8cd9c9c1110799ade1c535c092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5c54df59fa0a99fa860db82e6e82f9c0fbd7115", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c54df59fa0a99fa860db82e6e82f9c0fbd7115", "html_url": "https://github.com/rust-lang/rust/commit/b5c54df59fa0a99fa860db82e6e82f9c0fbd7115", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5c54df59fa0a99fa860db82e6e82f9c0fbd7115/comments", "author": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7f335a09ccfa0777847cd7b36d117322b965ad1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f335a09ccfa0777847cd7b36d117322b965ad1", "html_url": "https://github.com/rust-lang/rust/commit/a7f335a09ccfa0777847cd7b36d117322b965ad1"}], "stats": {"total": 28, "additions": 26, "deletions": 2}, "files": [{"sha": "0f8e93cbaef96f1b8f02d27e58ea9a395589d28f", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b5c54df59fa0a99fa860db82e6e82f9c0fbd7115/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c54df59fa0a99fa860db82e6e82f9c0fbd7115/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=b5c54df59fa0a99fa860db82e6e82f9c0fbd7115", "patch": "@@ -68,6 +68,7 @@ struct MaskWords<'a> {\n \n impl<'a> Iterator<(uint, uint)> for MaskWords<'a> {\n     /// Returns (offset, word)\n+    #[inline]\n     fn next<'a>(&'a mut self) -> Option<(uint, uint)> {\n         let ret = self.next_word;\n         match ret {\n@@ -347,6 +348,7 @@ pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n }\n \n impl ops::Index<uint,bool> for Bitv {\n+    #[inline]\n     fn index(&self, i: &uint) -> bool {\n         self.get(*i)\n     }\n@@ -453,23 +455,27 @@ impl Default for BitvSet {\n \n impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n+    #[inline]\n     pub fn new() -> BitvSet {\n         BitvSet(Bitv::new(0, false))\n     }\n \n     /// Creates a new bit vector set from the given bit vector\n+    #[inline]\n     pub fn from_bitv(bitv: Bitv) -> BitvSet {\n         BitvSet(bitv)\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n+    #[inline]\n     pub fn capacity(&self) -> uint {\n         let &BitvSet(ref bitv) = self;\n         bitv.storage.len() * uint::BITS\n     }\n \n     /// Consumes this set to return the underlying bit vector\n+    #[inline]\n     pub fn unwrap(self) -> Bitv {\n         let BitvSet(bitv) = self;\n         bitv\n@@ -515,29 +521,37 @@ impl BitvSet {\n     }\n \n     /// Union in-place with the specified other bit vector\n+    #[inline]\n     pub fn union_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n     /// Intersect in-place with the specified other bit vector\n+    #[inline]\n     pub fn intersect_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n     /// Difference in-place with the specified other bit vector\n+    #[inline]\n     pub fn difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n     /// Symmetric difference in-place with the specified other bit vector\n+    #[inline]\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n+    /// Iterator over each uint stored in the BitvSet\n+    #[inline]\n     pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n         BitPositions {set: self, next_idx: 0}\n     }\n \n+    /// Iterator over each uint stored in the `self` setminus `other`\n+    #[inline]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -548,6 +562,8 @@ impl BitvSet {\n         }\n     }\n \n+    /// Iterator over each uint stored in the symmetric difference of `self` and `other`\n+    #[inline]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -558,6 +574,8 @@ impl BitvSet {\n         }\n     }\n \n+    /// Iterator over each uint stored in `self` intersect `other`\n+    #[inline]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n         let min = cmp::min(self.capacity(), other.capacity());\n         TwoBitPositions {\n@@ -569,6 +587,8 @@ impl BitvSet {\n         }.take(min)\n     }\n \n+    /// Iterator over each uint stored in `self` union `other`\n+    #[inline]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -612,18 +632,21 @@ impl Collection for BitvSet {\n }\n \n impl Mutable for BitvSet {\n+    #[inline]\n     fn clear(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n         bitv.clear();\n     }\n }\n \n impl Set<uint> for BitvSet {\n+    #[inline]\n     fn contains(&self, value: &uint) -> bool {\n         let &BitvSet(ref bitv) = self;\n         *value < bitv.nbits && bitv.get(*value)\n     }\n \n+    #[inline]\n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).count() > 0\n     }\n@@ -647,6 +670,7 @@ impl Set<uint> for BitvSet {\n         return true;\n     }\n \n+    #[inline]\n     fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n@@ -737,7 +761,6 @@ pub struct TwoBitPositions<'a> {\n }\n \n impl<'a> Iterator<uint> for BitPositions<'a> {\n-    #[inline]\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.capacity() {\n             let idx = self.next_idx;\n@@ -751,13 +774,13 @@ impl<'a> Iterator<uint> for BitPositions<'a> {\n         return None;\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         (0, Some(self.set.capacity() - self.next_idx))\n     }\n }\n \n impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n-    #[inline]\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.capacity() ||\n               self.next_idx < self.other.capacity() {\n@@ -785,6 +808,7 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n         return None;\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         let cap = cmp::max(self.set.capacity(), self.other.capacity());\n         (0, Some(cap - self.next_idx))"}]}