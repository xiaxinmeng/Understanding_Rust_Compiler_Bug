{"sha": "1151d6204919202340e22cef15ca69aa183b41d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNTFkNjIwNDkxOTIwMjM0MGUyMmNlZjE1Y2E2OWFhMTgzYjQxZDE=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-21T10:26:17Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-27T19:06:36Z"}, "message": "split ignore_qualifiers", "tree": {"sha": "7da7b153abab2467bf1a49864a97be23331d8724", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7da7b153abab2467bf1a49864a97be23331d8724"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1151d6204919202340e22cef15ca69aa183b41d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1151d6204919202340e22cef15ca69aa183b41d1", "html_url": "https://github.com/rust-lang/rust/commit/1151d6204919202340e22cef15ca69aa183b41d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1151d6204919202340e22cef15ca69aa183b41d1/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6c0d17c8d6be89c6ef00de14fbafaf76d276d55", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6c0d17c8d6be89c6ef00de14fbafaf76d276d55", "html_url": "https://github.com/rust-lang/rust/commit/c6c0d17c8d6be89c6ef00de14fbafaf76d276d55"}], "stats": {"total": 377, "additions": 196, "deletions": 181}, "files": [{"sha": "1a9e20e79fe1ed0ed9a455138d7d77a145c257c9", "filename": "src/librustc_infer/infer/outlives/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty;\n \n use super::explicit_outlives_bounds;\n \n@@ -69,15 +69,15 @@ pub struct OutlivesEnvironment<'tcx> {\n pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n \n impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n+    pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut env = OutlivesEnvironment {\n             param_env,\n             free_region_map: Default::default(),\n             region_bound_pairs_map: Default::default(),\n             region_bound_pairs_accum: vec![],\n         };\n \n-        env.add_outlives_bounds(None, explicit_outlives_bounds(tcx, param_env));\n+        env.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n \n         env\n     }"}, {"sha": "541a2f18045c4a5b9a24356f09c27b62f027be7e", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -5,10 +5,9 @@ pub mod obligations;\n pub mod verify;\n \n use rustc_middle::traits::query::OutlivesBound;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty;\n \n pub fn explicit_outlives_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n     debug!(\"explicit_outlives_bounds()\");"}, {"sha": "8f20b5743df4fd7f1927b633af652bd1ff197688", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -331,9 +331,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         compare_ty: impl Fn(Ty<'tcx>) -> bool,\n         predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n-        let tcx = self.tcx;\n         predicates\n-            .filter_map(move |p| p.to_opt_type_outlives(tcx))\n+            .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n             .filter(move |p| compare_ty(p.0))\n     }"}, {"sha": "901685d1d844a6373571acf0a9eae26c9509321d", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -131,14 +131,14 @@ fn predicate_obligation<'tcx>(\n }\n \n impl Elaborator<'tcx> {\n-    pub fn filter_to_traits(self) -> FilterToTraits<'tcx, Self> {\n-        FilterToTraits::new(self.visited.tcx, self)\n+    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n+        FilterToTraits::new(self)\n     }\n \n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n-        match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+        match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n             ty::PredicateKind::ForAll(_) => {\n                 bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n             }\n@@ -275,7 +275,7 @@ impl Iterator for Elaborator<'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'tcx> = FilterToTraits<'tcx, Elaborator<'tcx>>;\n+pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n \n pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -297,23 +297,22 @@ pub fn transitive_bounds<'tcx>(\n \n /// A filter around an iterator of predicates that makes it yield up\n /// just trait references.\n-pub struct FilterToTraits<'tcx, I> {\n-    tcx: TyCtxt<'tcx>,\n+pub struct FilterToTraits<I> {\n     base_iterator: I,\n }\n \n-impl<'tcx, I> FilterToTraits<'tcx, I> {\n-    fn new(tcx: TyCtxt<'tcx>, base: I) -> FilterToTraits<'tcx, I> {\n-        FilterToTraits { tcx, base_iterator: base }\n+impl<I> FilterToTraits<I> {\n+    fn new(base: I) -> FilterToTraits<I> {\n+        FilterToTraits { base_iterator: base }\n     }\n }\n \n-impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToTraits<'tcx, I> {\n+impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         while let Some(obligation) = self.base_iterator.next() {\n-            if let Some(data) = obligation.predicate.to_opt_poly_trait_ref(self.tcx) {\n+            if let Some(data) = obligation.predicate.to_opt_poly_trait_ref() {\n                 return Some(data);\n             }\n         }"}, {"sha": "9566cdb164359e28001f6576b89ae3c456fa9dae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -1210,7 +1210,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n             for &(predicate, span) in predicates.predicates {\n                 // We don't actually look inside of the predicate,\n                 // so it is safe to skip this binder here.\n-                let predicate_kind_name = match predicate.ignore_qualifiers(cx.tcx).skip_binder().kind() {\n+                let predicate_kind_name = match predicate.ignore_qualifiers().skip_binder().kind() {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1495,13 +1495,12 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n \n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.ignore_qualifiers(tcx).skip_binder().kind() {\n+            .filter_map(|(pred, _)| match pred.ignore_qualifiers().skip_binder().kind() {\n                 &ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match a {\n                     ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n                     _ => None,\n@@ -1512,13 +1511,12 @@ impl ExplicitOutlivesRequirements {\n     }\n \n     fn lifetimes_outliving_type<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.ignore_qualifiers(tcx).skip_binder().kind() {\n+            .filter_map(|(pred, _)| match pred.ignore_qualifiers().skip_binder().kind() {\n                 &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n                     a.is_param(index).then_some(b)\n                 }\n@@ -1539,10 +1537,10 @@ impl ExplicitOutlivesRequirements {\n \n         match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n-                Self::lifetimes_outliving_lifetime(tcx, inferred_outlives, index)\n+                Self::lifetimes_outliving_lifetime(inferred_outlives, index)\n             }\n             hir::GenericParamKind::Type { .. } => {\n-                Self::lifetimes_outliving_type(tcx, inferred_outlives, index)\n+                Self::lifetimes_outliving_type(inferred_outlives, index)\n             }\n             hir::GenericParamKind::Const { .. } => Vec::new(),\n         }\n@@ -1694,11 +1692,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                             cx.tcx.named_region(predicate.lifetime.hir_id)\n                         {\n                             (\n-                                Self::lifetimes_outliving_lifetime(\n-                                    cx.tcx,\n-                                    inferred_outlives,\n-                                    index,\n-                                ),\n+                                Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n                                 &predicate.bounds,\n                                 predicate.span,\n                             )\n@@ -1714,11 +1708,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                                 if let Res::Def(DefKind::TyParam, def_id) = path.res {\n                                     let index = ty_generics.param_def_id_to_index[&def_id];\n                                     (\n-                                        Self::lifetimes_outliving_type(\n-                                            cx.tcx,\n-                                            inferred_outlives,\n-                                            index,\n-                                        ),\n+                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n                                         &predicate.bounds,\n                                         predicate.span,\n                                     )"}, {"sha": "3f1f397fc8e5a50a5dfb47bb835f753f5bcd5191", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n-                            predicate.ignore_qualifiers(cx.tcx).skip_binder().kind()\n+                            predicate.ignore_qualifiers().skip_binder().kind()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "3782f2b8404809e35849a5c0b9a965abc998a105", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -1050,7 +1050,30 @@ impl<'tcx> Predicate<'tcx> {\n     }\n \n     /// Skips `PredicateKind::ForAll`.\n-    pub fn ignore_qualifiers(self, tcx: TyCtxt<'tcx>) -> Binder<Predicate<'tcx>> {\n+    pub fn ignore_qualifiers(self) -> Binder<Predicate<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::ForAll(binder) => binder,\n+            ty::PredicateKind::Projection(..)\n+            | ty::PredicateKind::Trait(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::RegionOutlives(..) => Binder::dummy(self),\n+        }\n+    }\n+\n+    /// Skips `PredicateKind::ForAll`, while allowing for unbound variables.\n+    ///\n+    /// This method requires the `TyCtxt` as it has to shift the unbound variables\n+    /// outwards.\n+    ///\n+    /// Do not use this method if you may end up just skipping the binder, as this\n+    /// would leave the unbound variables at an incorrect binding level.\n+    pub fn ignore_qualifiers_with_unbound_vars(self, tcx: TyCtxt<'tcx>) -> Binder<Predicate<'tcx>> {\n         match self.kind() {\n             &PredicateKind::ForAll(binder) => binder,\n             ty::PredicateKind::Projection(..)\n@@ -1226,7 +1249,7 @@ impl<'tcx> Predicate<'tcx> {\n         // from the substitution and the value being substituted into, and\n         // this trick achieves that).\n         let substs = trait_ref.skip_binder().substs;\n-        let pred = *self.ignore_qualifiers(tcx).skip_binder();\n+        let pred = *self.ignore_qualifiers().skip_binder();\n         let new = pred.subst(tcx, substs);\n         if new != pred { new.potentially_qualified(tcx, PredicateKind::ForAll) } else { self }\n     }\n@@ -1427,8 +1450,8 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n }\n \n impl<'tcx> Predicate<'tcx> {\n-    pub fn to_opt_poly_trait_ref(self, tcx: TyCtxt<'tcx>) -> Option<PolyTraitRef<'tcx>> {\n-        self.ignore_qualifiers(tcx)\n+    pub fn to_opt_poly_trait_ref(self) -> Option<PolyTraitRef<'tcx>> {\n+        self.ignore_qualifiers()\n             .map_bound(|pred| match pred.kind() {\n                 &PredicateKind::Trait(ref t, _) => Some(t.trait_ref),\n                 PredicateKind::Projection(..)\n@@ -1445,11 +1468,8 @@ impl<'tcx> Predicate<'tcx> {\n             .transpose()\n     }\n \n-    pub fn to_opt_type_outlives(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        self.ignore_qualifiers(tcx)\n+    pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n+        self.ignore_qualifiers()\n             .map_bound(|pred| match pred.kind() {\n                 &PredicateKind::TypeOutlives(data) => Some(data),\n                 PredicateKind::Trait(..)"}, {"sha": "1f9fc4818839fa715cc1b68427411a7835b8cbb9", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -572,7 +572,16 @@ pub trait PrettyPrinter<'tcx>:\n                     let mut is_sized = false;\n                     p!(write(\"impl\"));\n                     for predicate in bounds.predicates {\n-                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref(self.tcx()) {\n+                        // Note: We can't use `to_opt_poly_trait_ref` here as `predicate`\n+                        // may contain unbound variables. We therefore do this manually.\n+                        //\n+                        // FIXME(lcnr): Find out why exactly this is the case :)\n+                        if let ty::PredicateKind::Trait(pred, _) = predicate\n+                            .ignore_qualifiers_with_unbound_vars(self.tcx())\n+                            .skip_binder()\n+                            .kind()\n+                        {\n+                            let trait_ref = ty::Binder::bind(pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n                                 is_sized = true;"}, {"sha": "c28f23dc7d611639f33e83667d3db4c2c5b64302", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -590,7 +590,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let mut found = false;\n                     for predicate in bounds.predicates {\n                         if let ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n-                            predicate.ignore_qualifiers(self.infcx.tcx).skip_binder().kind()\n+                            predicate.ignore_qualifiers().skip_binder().kind()\n                         {\n                             if let ty::RegionKind::ReStatic = r {\n                                 found = true;"}, {"sha": "beee31812563ed4d536ea5abd4b58fb81222a767", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -274,7 +274,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n \n         // Insert the facts we know from the predicates. Why? Why not.\n         let param_env = self.param_env;\n-        self.add_outlives_bounds(outlives::explicit_outlives_bounds(self.infcx.tcx, param_env));\n+        self.add_outlives_bounds(outlives::explicit_outlives_bounds(param_env));\n \n         // Finally:\n         // - outlives is reflexive, so `'r: 'r` for every region `'r`"}, {"sha": "c176fbf90b63f157270a67d55f5e557aa2ab3cf9", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -24,7 +24,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n     loop {\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n-            match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+            match predicate.ignore_qualifiers().skip_binder().kind() {\n                 ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n                 ty::PredicateKind::RegionOutlives(_)\n                 | ty::PredicateKind::TypeOutlives(_)"}, {"sha": "3591a707ac039b2e1fb78078956e83f6bb164bde", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -84,31 +84,33 @@ where\n             || (!self.def_id_visitor.shallow() && substs.visit_with(self))\n     }\n \n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+        match predicate.kind() {\n+            &ty::PredicateKind::ForAll(pred) => {\n+                // This visitor does not care about bound regions as we only\n+                // look at `DefId`s.\n+                self.visit_predicate(*pred.skip_binder())\n+            }\n+            &ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n+                self.visit_trait(trait_ref)\n+            }\n+            &ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+                ty.visit_with(self)\n+                    || self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n+            }\n+            &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n+                ty.visit_with(self)\n+            }\n+            ty::PredicateKind::RegionOutlives(..) => false,\n+            _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+        }\n+    }\n+\n     fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n-        for (predicate, _span) in predicates {\n-            // This visitor does not care about bound regions.\n-            match predicate.ignore_qualifiers(self.def_id_visitor.tcx()).skip_binder().kind() {\n-                &ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n-                    if self.visit_trait(trait_ref) {\n-                        return true;\n-                    }\n-                }\n-                &ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n-                    if ty.visit_with(self) {\n-                        return true;\n-                    }\n-                    if self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx())) {\n-                        return true;\n-                    }\n-                }\n-                &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n-                    if ty.visit_with(self) {\n-                        return true;\n-                    }\n-                }\n-                ty::PredicateKind::RegionOutlives(..) => {}\n-                _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+        for &(predicate, _span) in predicates {\n+            if self.visit_predicate(predicate) {\n+                return true;\n             }\n         }\n         false"}, {"sha": "b482f073858b92b97681a3f925b6a25a111556d5", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -1155,7 +1155,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         for predicate in &bounds.predicates {\n             if let ty::PredicateKind::Projection(projection) =\n-                predicate.ignore_qualifiers(tcx).skip_binder().kind()\n+                predicate.ignore_qualifiers().skip_binder().kind()\n             {\n                 if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n@@ -1254,7 +1254,7 @@ crate fn required_region_bounds(\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n             debug!(\"required_region_bounds(obligation={:?})\", obligation);\n-            match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+            match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n                 ty::PredicateKind::Projection(..)\n                 | ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::Subtype(..)"}, {"sha": "2dbb40363971c4d8b6a9943b09ffa77782c14c11", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -418,8 +418,8 @@ impl AutoTraitFinder<'tcx> {\n                 ty::PredicateKind::Trait(new_trait, _),\n                 ty::PredicateKind::Trait(old_trait, _),\n             ) = (\n-                new_pred.ignore_qualifiers(self.tcx).skip_binder().kind(),\n-                old_pred.ignore_qualifiers(self.tcx).skip_binder().kind(),\n+                new_pred.ignore_qualifiers().skip_binder().kind(),\n+                old_pred.ignore_qualifiers().skip_binder().kind(),\n             ) {\n                 if new_trait.def_id() == old_trait.def_id() {\n                     let new_substs = new_trait.trait_ref.substs;\n@@ -639,7 +639,7 @@ impl AutoTraitFinder<'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n \n-            match predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+            match predicate.ignore_qualifiers().skip_binder().kind() {\n                 &ty::PredicateKind::Trait(p, _) => {\n                     if self.is_param_no_infer(p.trait_ref.substs)\n                         && !only_projections"}, {"sha": "f5717285defbcd7f38a423215bc33fc0ed58b631", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+                match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n                     ty::PredicateKind::ForAll(_) => {\n                         bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n                     }\n@@ -1091,8 +1091,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n         let (cond, error) = match (\n-            cond.ignore_qualifiers(self.tcx).skip_binder().kind(),\n-            error.ignore_qualifiers(self.tcx).skip_binder().kind(),\n+            cond.ignore_qualifiers().skip_binder().kind(),\n+            error.ignore_qualifiers().skip_binder().kind(),\n         ) {\n             (ty::PredicateKind::Trait(..), &ty::PredicateKind::Trait(error, _)) => {\n                 (cond, ty::Binder::bind(error))\n@@ -1105,7 +1105,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n             if let &ty::PredicateKind::Trait(implication, _) =\n-                obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+                obligation.predicate.ignore_qualifiers().skip_binder().kind()\n             {\n                 let error = error.to_poly_trait_ref();\n                 let implication = ty::Binder::bind(implication).to_poly_trait_ref();\n@@ -1187,7 +1187,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n             if let &ty::PredicateKind::Projection(data) =\n-                predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+                predicate.ignore_qualifiers().skip_binder().kind()\n             {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n@@ -1480,7 +1480,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+        let mut err = match predicate.ignore_qualifiers().skip_binder().kind() {\n             &ty::PredicateKind::Trait(data, _) => {\n                 let trait_ref = ty::Binder::bind(data.trait_ref);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n@@ -1734,7 +1734,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         let (pred, item_def_id, span) = match (\n-            obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind(),\n+            obligation.predicate.ignore_qualifiers().skip_binder().kind(),\n             obligation.cause.code.peel_derives(),\n         ) {\n             ("}, {"sha": "1b618cea6008f9af4a0dcb2655b065daf427bf5b", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n         let (mut trait_ref, mut target_ty) =\n-            match obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+            match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n                 ty::PredicateKind::Trait(p, _) => (Some(p.trait_ref), Some(p.self_ty())),\n                 _ => (None, None),\n             };"}, {"sha": "54df3559683f32a92d80ed518b6ea20166e38d83", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -237,7 +237,7 @@ fn do_normalize_predicates<'tcx>(\n \n         // We can use the `elaborated_env` here; the region code only\n         // cares about declarations like `'a: 'b`.\n-        let outlives_env = OutlivesEnvironment::new(tcx, elaborated_env);\n+        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n \n         infcx.resolve_regions_and_report_errors(\n             region_context,\n@@ -328,7 +328,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // This works fairly well because trait matching  does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+        .drain_filter(|predicate| match predicate.ignore_qualifiers().skip_binder().kind() {\n             ty::PredicateKind::TypeOutlives(..) => true,\n             _ => false,\n         })"}, {"sha": "b3525ddeb2147164f9fce9777b7f19f7e4ed465f", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -245,7 +245,7 @@ fn predicates_reference_self(\n         .iter()\n         .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|(predicate, &sp)| {\n-            match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+            match predicate.ignore_qualifiers().skip_binder().kind() {\n                 ty::PredicateKind::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n                     if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n@@ -299,7 +299,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n-        match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+        match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n             ty::PredicateKind::Trait(ref trait_pred, _) => {\n                 trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n             }\n@@ -400,7 +400,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         // A trait object can't claim to live more than the concrete type,\n         // so outlives predicates will always hold.\n         .cloned()\n-        .filter(|(p, _)| p.to_opt_type_outlives(tcx).is_none())\n+        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n         .collect::<Vec<_>>()\n         // Do a shallow visit so that `contains_illegal_self_type_reference`\n         // may apply it's custom visiting."}, {"sha": "a5199b7fbefa814263573183288de899903916e6", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -665,7 +665,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n         .obligations\n         .iter()\n         .filter(|obligation| {\n-            match obligation.predicate.ignore_qualifiers(infcx.tcx).skip_binder().kind() {\n+            match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n                 // We found a `T: Foo<X = U>` predicate, let's check\n                 // if `U` references any unresolved type\n                 // variables. In principle, we only care if this\n@@ -934,7 +934,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n         if let &ty::PredicateKind::Projection(data) =\n-            predicate.ignore_qualifiers(infcx.tcx).skip_binder().kind()\n+            predicate.ignore_qualifiers().skip_binder().kind()\n         {\n             let data = ty::Binder::bind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n@@ -1228,7 +1228,7 @@ fn confirm_object_candidate<'cx, 'tcx>(\n         // item with the correct name\n \n         let env_predicates = env_predicates.filter_map(|o| {\n-            match o.predicate.ignore_qualifiers(selcx.tcx()).skip_binder().kind() {\n+            match o.predicate.ignore_qualifiers().skip_binder().kind() {\n                 &ty::PredicateKind::Projection(data)\n                     if data.projection_ty.item_def_id == obligation.predicate.item_def_id =>\n                 {"}, {"sha": "76154adb1751c65f770e1e8826e722058a8ab7c2", "filename": "src/librustc_trait_selection/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -16,7 +16,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n         if let ty::PredicateKind::Trait(trait_ref, _) =\n-            key.value.predicate.ignore_qualifiers(tcx).skip_binder().kind()\n+            key.value.predicate.ignore_qualifiers().skip_binder().kind()\n         {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {"}, {"sha": "1d5441b8eff85c76616db6e9897122ea7e00d605", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -181,15 +181,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         stack: &TraitObligationStack<'o, 'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        let tcx = self.tcx();\n         debug!(\"assemble_candidates_from_caller_bounds({:?})\", stack.obligation);\n \n         let all_bounds = stack\n             .obligation\n             .param_env\n             .caller_bounds()\n             .iter()\n-            .filter_map(move |o| o.to_opt_poly_trait_ref(tcx));\n+            .filter_map(|o| o.to_opt_poly_trait_ref());\n \n         // Micro-optimization: filter out predicates relating to different traits.\n         let matching_bounds ="}, {"sha": "f8b2e0925819f6c6d73dc6cc5bd4fc1d44f55265", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -408,7 +408,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        match obligation.predicate.ignore_qualifiers(self.tcx()).skip_binder().kind() {\n+        match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n             ty::PredicateKind::ForAll(_) => {\n                 bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n             }\n@@ -792,7 +792,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate.ignore_qualifiers(self.tcx()).skip_binder().kind() {\n+        let result = match predicate.ignore_qualifiers().skip_binder().kind() {\n             ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n@@ -1301,8 +1301,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let matching_bound = predicates.iter().find_map(|bound| {\n-            if let ty::PredicateKind::Trait(bound, _) = bound.kind() {\n-                let bound = bound.to_poly_trait_ref();\n+            if let ty::PredicateKind::Trait(pred, _) =\n+                bound.ignore_qualifiers().skip_binder().kind()\n+            {\n+                let bound = ty::Binder::bind(pred.trait_ref);\n                 if self.infcx.probe(|_| {\n                     self.match_projection(obligation, bound, placeholder_trait_predicate.trait_ref)\n                 }) {"}, {"sha": "9b737d464174a44b77eb0b0c00712b832eb656b6", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -497,7 +497,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String>\n         Vec::with_capacity(predicates.len() + types_without_default_bounds.len());\n \n     for (p, _) in predicates {\n-        if let Some(poly_trait_ref) = p.to_opt_poly_trait_ref(tcx) {\n+        if let Some(poly_trait_ref) = p.to_opt_poly_trait_ref() {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n                 types_without_default_bounds.remove(poly_trait_ref.self_ty().skip_binder());\n                 continue;"}, {"sha": "cc8997078e0f09e8be8d249074b31370ec3a8513", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n \n         let items = predicates.predicates.iter().rev().filter_map(|(pred, span)| {\n             pred.subst_supertrait(tcx, &trait_ref)\n-                .to_opt_poly_trait_ref(tcx)\n+                .to_opt_poly_trait_ref()\n                 .map(|trait_ref| item.clone_and_push(trait_ref, *span))\n         });\n         debug!(\"expand_trait_aliases: items={:?}\", items.clone());\n@@ -170,15 +170,14 @@ impl Iterator for SupertraitDefIds<'tcx> {\n     type Item = DefId;\n \n     fn next(&mut self) -> Option<DefId> {\n-        let tcx = self.tcx;\n         let def_id = self.stack.pop()?;\n         let predicates = self.tcx.super_predicates_of(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend(\n             predicates\n                 .predicates\n                 .iter()\n-                .filter_map(move |(pred, _)| pred.to_opt_poly_trait_ref(tcx))\n+                .filter_map(|(pred, _)| pred.to_opt_poly_trait_ref())\n                 .map(|trait_ref| trait_ref.def_id())\n                 .filter(|&super_def_id| visited.insert(super_def_id)),\n         );"}, {"sha": "fd762f9d57156855146076f15ae41f7dcae7ae09", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -196,7 +196,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n         };\n \n     // It is fine to skip the binder as we don't care about regions here.\n-    match pred.ignore_qualifiers(tcx).skip_binder().kind() {\n+    match pred.ignore_qualifiers().skip_binder().kind() {\n         ty::PredicateKind::Projection(proj) => {\n             // The obligation comes not from the current `impl` nor the `trait` being implemented,\n             // but rather from a \"second order\" obligation, where an associated type has a\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n         let extend = |obligation: traits::PredicateObligation<'tcx>| {\n             let mut cause = cause.clone();\n-            if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_ref(tcx) {\n+            if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_ref() {\n                 let derived_cause = traits::DerivedObligationCause {\n                     parent_trait_ref,\n                     parent_code: Rc::new(obligation.cause.code.clone()),"}, {"sha": "7857b19bd90b7b399d23ba03b1a7226f9910a701", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -79,7 +79,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n         let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n                 // FIXME(chalk): forall\n-                match predicate.ignore_qualifiers(interner.tcx).skip_binder().kind() {\n+                match predicate\n+                    .ignore_qualifiers_with_unbound_vars(interner.tcx)\n+                    .skip_binder()\n+                    .kind()\n+                {\n                     ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n                     &ty::PredicateKind::Trait(predicate, _) => {\n                         let predicate = ty::Binder::bind(predicate);\n@@ -102,9 +106,10 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             .intern(interner),\n                         )\n                     }\n-                    ty::PredicateKind::RegionOutlives(predicate) => {\n+                    &ty::PredicateKind::RegionOutlives(predicate) => {\n+                        let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, predicate);\n+                            collect_bound_vars(interner, interner.tcx, &predicate);\n \n                         Some(\n                             chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n@@ -186,14 +191,15 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n         // FIXME(chalk): forall\n-        match self.ignore_qualifiers(interner.tcx).skip_binder().kind() {\n+        match self.ignore_qualifiers_with_unbound_vars(interner.tcx).skip_binder().kind() {\n             ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n             &ty::PredicateKind::Trait(predicate, _) => {\n                 ty::Binder::bind(predicate).lower_into(interner)\n             }\n-            ty::PredicateKind::RegionOutlives(predicate) => {\n+            &ty::PredicateKind::RegionOutlives(predicate) => {\n+                let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, predicate);\n+                    collect_bound_vars(interner, interner.tcx, &predicate);\n \n                 chalk_ir::GoalData::Quantified(\n                     chalk_ir::QuantifierKind::ForAll,\n@@ -555,21 +561,22 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n         // FIXME(chalk): forall\n-        match self.ignore_qualifiers(interner.tcx).skip_binder().kind() {\n+        match self.ignore_qualifiers_with_unbound_vars(interner.tcx).skip_binder().kind() {\n             ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n             &ty::PredicateKind::Trait(predicate, _) => {\n-                let predicate = &ty::Binder::bind(predicate);\n+                let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, predicate);\n+                    collect_bound_vars(interner, interner.tcx, &predicate);\n \n                 Some(chalk_ir::Binders::new(\n                     binders,\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n             }\n-            ty::PredicateKind::RegionOutlives(predicate) => {\n+            &ty::PredicateKind::RegionOutlives(predicate) => {\n+                let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, predicate);\n+                    collect_bound_vars(interner, interner.tcx, &predicate);\n \n                 Some(chalk_ir::Binders::new(\n                     binders,"}, {"sha": "cdc22b987a79896283fa71d43102aa732f2dbeb1", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -27,9 +27,7 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n                 // always only region relations, and we are about to\n                 // erase those anyway:\n                 debug_assert_eq!(\n-                    normalized_obligations\n-                        .iter()\n-                        .find(|p| not_outlives_predicate(tcx, &p.predicate)),\n+                    normalized_obligations.iter().find(|p| not_outlives_predicate(&p.predicate)),\n                     None,\n                 );\n \n@@ -41,8 +39,8 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n     })\n }\n \n-fn not_outlives_predicate(tcx: TyCtxt<'tcx>, p: &ty::Predicate<'tcx>) -> bool {\n-    match p.ignore_qualifiers(tcx).skip_binder().kind() {\n+fn not_outlives_predicate(p: &ty::Predicate<'tcx>) -> bool {\n+    match p.ignore_qualifiers().skip_binder().kind() {\n         ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n         ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", p),\n         ty::PredicateKind::Trait(..)"}, {"sha": "9daf665dd41ab3895defa78b1c22e7ef849403f4", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -392,23 +392,23 @@ fn associated_type_projection_predicates(\n \n     let predicates = item_predicates.filter_map(|obligation| {\n         let pred = obligation.predicate;\n-        match pred.kind() {\n+        match pred.ignore_qualifiers().skip_binder().kind() {\n             ty::PredicateKind::Trait(tr, _) => {\n-                if let ty::Projection(p) = tr.skip_binder().self_ty().kind {\n+                if let ty::Projection(p) = tr.self_ty().kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n                 }\n             }\n             ty::PredicateKind::Projection(proj) => {\n-                if let ty::Projection(p) = proj.skip_binder().projection_ty.self_ty().kind {\n+                if let ty::Projection(p) = proj.projection_ty.self_ty().kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n                 }\n             }\n             ty::PredicateKind::TypeOutlives(outlives) => {\n-                if let ty::Projection(p) = outlives.skip_binder().0.kind {\n+                if let ty::Projection(p) = outlives.0.kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n@@ -443,25 +443,24 @@ fn opaque_type_projection_predicates(\n \n     let filtered_predicates = predicates.filter_map(|obligation| {\n         let pred = obligation.predicate;\n-        match pred.kind() {\n+        match pred.ignore_qualifiers().skip_binder().kind() {\n             ty::PredicateKind::Trait(tr, _) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = tr.skip_binder().self_ty().kind {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = tr.self_ty().kind {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n                 }\n             }\n             ty::PredicateKind::Projection(proj) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) =\n-                    proj.skip_binder().projection_ty.self_ty().kind\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = proj.projection_ty.self_ty().kind\n                 {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n                 }\n             }\n             ty::PredicateKind::TypeOutlives(outlives) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = outlives.skip_binder().0.kind {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = outlives.0.kind {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }"}, {"sha": "01d48ece663fb5315c1488dff5a16d9503b65ef6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -1706,7 +1706,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     obligation.predicate\n                 );\n \n-                match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+                match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n                     &ty::PredicateKind::Trait(pred, _) => {\n                         let pred = ty::Binder::bind(pred);\n                         associated_types.entry(span).or_default().extend(\n@@ -2097,7 +2097,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             || {\n                 traits::transitive_bounds(\n                     tcx,\n-                    predicates.iter().filter_map(move |(p, _)| p.to_opt_poly_trait_ref(tcx)),\n+                    predicates.iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref()),\n                 )\n             },\n             || param_name.to_string(),"}, {"sha": "3918eac23eaf8b228cc5f399405df5ee4fc20309", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n \n                 if let &ty::PredicateKind::Projection(proj_predicate) =\n-                    obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+                    obligation.predicate.ignore_qualifiers().skip_binder().kind()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n@@ -632,7 +632,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n             if let &ty::PredicateKind::Projection(proj_predicate) =\n-                obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+                obligation.predicate.ignore_qualifiers().skip_binder().kind()\n             {\n                 self.deduce_future_output_from_projection(\n                     obligation.cause.span,"}, {"sha": "4df39971afa0eb3d19819c18be79dc0598261f66", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -582,25 +582,24 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred =\n-                match obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n-                    &ty::PredicateKind::Trait(trait_pred, _)\n-                        if traits.contains(&trait_pred.def_id()) =>\n-                    {\n-                        if unsize_did == trait_pred.def_id() {\n-                            let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n-                            if let ty::Tuple(..) = unsize_ty.kind {\n-                                debug!(\"coerce_unsized: found unsized tuple coercion\");\n-                                has_unsized_tuple_coercion = true;\n-                            }\n+            let trait_pred = match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n+                &ty::PredicateKind::Trait(trait_pred, _)\n+                    if traits.contains(&trait_pred.def_id()) =>\n+                {\n+                    if unsize_did == trait_pred.def_id() {\n+                        let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n+                        if let ty::Tuple(..) = unsize_ty.kind {\n+                            debug!(\"coerce_unsized: found unsized tuple coercion\");\n+                            has_unsized_tuple_coercion = true;\n                         }\n-                        ty::Binder::bind(trait_pred)\n-                    }\n-                    _ => {\n-                        coercion.obligations.push(obligation);\n-                        continue;\n                     }\n-                };\n+                    ty::Binder::bind(trait_pred)\n+                }\n+                _ => {\n+                    coercion.obligations.push(obligation);\n+                    continue;\n+                }\n+            };\n             match selcx.select(&obligation.with(trait_pred)) {\n                 // Uncertain or unimplemented.\n                 Ok(None) => {"}, {"sha": "c06bbc3d015c3fa7b9cc16fd9d0f98ea742b6f2e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -127,7 +127,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         // it did the wrong thing, so I chose to preserve existing\n         // behavior, since it ought to be simply more\n         // conservative. -nmatsakis\n-        let outlives_env = OutlivesEnvironment::new(infcx.tcx, ty::ParamEnv::empty());\n+        let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n \n         infcx.resolve_regions_and_report_errors(\n             drop_impl_did.to_def_id(),\n@@ -227,8 +227,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n             match (\n-                predicate.ignore_qualifiers(tcx).skip_binder().kind(),\n-                p.ignore_qualifiers(tcx).skip_binder().kind(),\n+                predicate.ignore_qualifiers().skip_binder().kind(),\n+                p.ignore_qualifiers().skip_binder().kind(),\n             ) {\n                 (&ty::PredicateKind::Trait(a, _), &ty::PredicateKind::Trait(b, _)) => {\n                     relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()"}, {"sha": "645862fa924d0e631a330d60ea808c6b8f06d0f4", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n             .filter_map(|obligation| {\n-                match obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+                match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n                     ty::PredicateKind::Trait(trait_pred, _)\n                         if trait_pred.def_id() == sized_def_id =>\n                     {"}, {"sha": "9c5e3cbc93844a338f77c3c6977b26e59a520e63", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -795,7 +795,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_param(&mut self, param_ty: ty::ParamTy) {\n-        let tcx = self.tcx;\n         // FIXME: do we want to commit to this behavior for param bounds?\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n "}, {"sha": "0900bc583ae1f7578ad813a2197151092e33dd09", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -578,7 +578,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // We don't care about regions here, so it's fine to skip the binder here.\n                             if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) = (\n                                 &self_ty.kind,\n-                                parent_pred.ignore_qualifiers(tcx).skip_binder().kind(),\n+                                parent_pred.ignore_qualifiers().skip_binder().kind(),\n                             ) {\n                                 if let ty::Adt(def, _) = p.trait_ref.self_ty().kind {\n                                     let node = def.did.as_local().map(|def_id| {\n@@ -631,7 +631,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        match pred.ignore_qualifiers(tcx).skip_binder().kind() {\n+                        match pred.ignore_qualifiers().skip_binder().kind() {\n                             &ty::PredicateKind::Projection(pred) => {\n                                 let pred = ty::Binder::bind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n@@ -959,7 +959,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // implementing a trait would be legal but is rejected\n                 // here).\n                 unsatisfied_predicates.iter().all(|(p, _)| {\n-                    match p.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+                    match p.ignore_qualifiers().skip_binder().kind() {\n                         // Hide traits if they are present in predicates as they can be fixed without\n                         // having to implement them.\n                         ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,"}, {"sha": "0cb0c7d0e3044d85ec15be9422bf66fe0d064e03", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -2400,7 +2400,7 @@ fn bounds_from_generic_predicates<'tcx>(\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+        match predicate.ignore_qualifiers().skip_binder().kind() {\n             ty::PredicateKind::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n@@ -3894,7 +3894,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .pending_obligations()\n             .into_iter()\n             .filter_map(move |obligation| {\n-                match obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+                match obligation.predicate.ignore_qualifiers().skip_binder().kind() {\n                     ty::PredicateKind::ForAll(_) => {\n                         bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n                     }\n@@ -4250,7 +4250,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             if let ty::PredicateKind::Trait(predicate, _) =\n-                error.obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+                error.obligation.predicate.ignore_qualifiers().skip_binder().kind()\n             {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n@@ -4298,12 +4298,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::PredicateKind::Trait(predicate, _) = error\n-                            .obligation\n-                            .predicate\n-                            .ignore_qualifiers(self.tcx)\n-                            .skip_binder()\n-                            .kind()\n+                        if let ty::PredicateKind::Trait(predicate, _) =\n+                            error.obligation.predicate.ignore_qualifiers().skip_binder().kind()\n                         {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860)."}, {"sha": "221e5f72dc977b135d5a263212ecf5094d187285", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> RegionCtxt<'a, 'tcx> {\n         let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n-        let outlives_environment = OutlivesEnvironment::new(fcx.tcx, param_env);\n+        let outlives_environment = OutlivesEnvironment::new(param_env);\n         RegionCtxt {\n             fcx,\n             region_scope_tree,"}, {"sha": "8c6161a62647346b780450776524de5e5228a51d", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -292,7 +292,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                     }\n \n                     // Finally, resolve all regions.\n-                    let outlives_env = OutlivesEnvironment::new(tcx, param_env);\n+                    let outlives_env = OutlivesEnvironment::new(param_env);\n                     infcx.resolve_regions_and_report_errors(\n                         impl_did.to_def_id(),\n                         &outlives_env,\n@@ -549,7 +549,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n         }\n \n         // Finally, resolve all regions.\n-        let outlives_env = OutlivesEnvironment::new(tcx, param_env);\n+        let outlives_env = OutlivesEnvironment::new(param_env);\n         infcx.resolve_regions_and_report_errors(impl_did, &outlives_env, RegionckMode::default());\n \n         CoerceUnsizedInfo { custom_kind: kind }"}, {"sha": "636c178d34877bee6c42cc6e650a41ed53201714", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -552,7 +552,7 @@ fn type_param_predicates(\n     let extra_predicates = extend.into_iter().chain(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n-            .filter(|(predicate, _)| match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+            .filter(|(predicate, _)| match predicate.ignore_qualifiers().skip_binder().kind() {\n                 ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n                 _ => false,\n             }),\n@@ -1004,8 +1004,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateKind::Trait(bound, _) = pred.ignore_qualifiers(tcx).skip_binder().kind()\n-        {\n+        if let ty::PredicateKind::Trait(bound, _) = pred.ignore_qualifiers().skip_binder().kind() {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }"}, {"sha": "85fe2dba25021db692a53c8efc8b174c2de7df9b", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -183,7 +183,7 @@ pub fn setup_constraining_predicates<'tcx>(\n             // Note that we don't have to care about binders here,\n             // as the impl trait ref never contains any late-bound regions.\n             if let ty::PredicateKind::Projection(projection) =\n-                predicates[j].0.ignore_qualifiers(tcx).skip_binder().kind()\n+                predicates[j].0.ignore_qualifiers().skip_binder().kind()\n             {\n                 // Special case: watch out for some kind of sneaky attempt\n                 // to project out an associated type defined by this very"}, {"sha": "50312a99175db889b91665a1d078908a28defc34", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -163,7 +163,7 @@ fn get_impl_substs<'tcx>(\n     let impl2_substs = translate_substs(infcx, param_env, impl1_def_id, impl1_substs, impl2_node);\n \n     // Conservatively use an empty `ParamEnv`.\n-    let outlives_env = OutlivesEnvironment::new(tcx, ty::ParamEnv::empty());\n+    let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n     infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env, RegionckMode::default());\n     let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n         Ok(s) => s,\n@@ -199,7 +199,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n         if let ty::PredicateKind::Projection(proj) =\n-            predicate.ignore_qualifiers(tcx).skip_binder().kind()\n+            predicate.ignore_qualifiers().skip_binder().kind()\n         {\n             let projection_ty = proj.projection_ty;\n             let projected_ty = proj.ty;\n@@ -361,7 +361,7 @@ fn check_predicates<'tcx>(\n \n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n-    match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+    match predicate.ignore_qualifiers().skip_binder().kind() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n@@ -394,7 +394,7 @@ fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n-    match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+    match predicate.ignore_qualifiers().skip_binder().kind() {\n         ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n         ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             Some(tcx.trait_def(pred.def_id()).specialization_kind)"}, {"sha": "ac2f8ae36c3df0bdc45c1fda79c77c39eb8000a9", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1151d6204919202340e22cef15ca69aa183b41d1/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=1151d6204919202340e22cef15ca69aa183b41d1", "patch": "@@ -29,7 +29,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n-                match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+                match predicate.ignore_qualifiers().skip_binder().kind() {\n                     ty::PredicateKind::ForAll(_) => bug!(\"unepected predicate: {:?}\", predicate),\n \n                     ty::PredicateKind::TypeOutlives(OutlivesPredicate(ref ty, ref reg)) => {"}]}