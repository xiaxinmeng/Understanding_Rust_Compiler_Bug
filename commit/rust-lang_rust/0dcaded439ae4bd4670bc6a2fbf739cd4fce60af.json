{"sha": "0dcaded439ae4bd4670bc6a2fbf739cd4fce60af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkY2FkZWQ0MzlhZTRiZDQ2NzBiYzZhMmZiZjczOWNkNGZjZTYwYWY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-06-11T15:00:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-06-11T15:28:51Z"}, "message": "move source to a seaparate file", "tree": {"sha": "9f97e6be462d8c3b38da74af095f4160adeda51c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f97e6be462d8c3b38da74af095f4160adeda51c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af", "html_url": "https://github.com/rust-lang/rust/commit/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4512fadb1b332b13bb41b0aa8a28aa964664842", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4512fadb1b332b13bb41b0aa8a28aa964664842", "html_url": "https://github.com/rust-lang/rust/commit/c4512fadb1b332b13bb41b0aa8a28aa964664842"}], "stats": {"total": 246, "additions": 125, "deletions": 121}, "files": [{"sha": "0cfab27dc189899f1dc22c3024c1b93c86a9c04d", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 120, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=0dcaded439ae4bd4670bc6a2fbf739cd4fce60af", "patch": "@@ -1,10 +1,12 @@\n+pub(crate) mod src;\n+\n use std::sync::Arc;\n \n use ra_db::{CrateId, SourceRootId, Edition, FileId};\n use ra_syntax::{ast::{self, NameOwner, TypeAscriptionOwner}, TreeArc};\n \n use crate::{\n-    Name, AsName, AstId, Ty, HirFileId, Either, KnownName,\n+    Name, AsName, AstId, Ty, Either, KnownName, HasSource,\n     HirDatabase, DefDatabase, AstDatabase,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n@@ -20,22 +22,6 @@ use crate::{\n     type_ref::Mutability,\n };\n \n-pub struct Source<T> {\n-    pub file_id: HirFileId,\n-    pub ast: T,\n-}\n-\n-impl<T> From<(HirFileId, T)> for Source<T> {\n-    fn from((file_id, ast): (HirFileId, T)) -> Self {\n-        Source { file_id, ast }\n-    }\n-}\n-\n-pub trait HasSource {\n-    type Ast;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<Self::Ast>;\n-}\n-\n /// hir::Crate describes a single crate. It's the main interface with which\n /// a crate's dependencies interact. Mostly, it should be just a proxy for the\n /// root module.\n@@ -195,28 +181,6 @@ impl Module {\n         })\n     }\n \n-    /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n-    pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl_id = def_map[self.module_id].declaration;\n-        let file_id = def_map[self.module_id].definition;\n-        let module_source = ModuleSource::new(db, file_id, decl_id);\n-        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n-        (file_id, module_source).into()\n-    }\n-\n-    /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n-    /// `None` for the crate root.\n-    pub fn declaration_source(\n-        self,\n-        db: &(impl DefDatabase + AstDatabase),\n-    ) -> Option<Source<TreeArc<ast::Module>>> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl = def_map[self.module_id].declaration?;\n-        let ast = decl.to_node(db);\n-        Some((decl.file_id(), ast).into())\n-    }\n-\n     /// Returns the syntax of the last path segment corresponding to this import\n     pub fn import_source(\n         self,\n@@ -343,13 +307,6 @@ pub enum FieldSource {\n     Pos(TreeArc<ast::PosFieldDef>),\n }\n \n-impl HasSource for StructField {\n-    type Ast = FieldSource;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<FieldSource> {\n-        self.source_impl(db).into()\n-    }\n-}\n-\n impl StructField {\n     pub fn name(&self, db: &impl HirDatabase) -> Name {\n         self.parent.variant_data(db).fields().unwrap()[self.id].name.clone()\n@@ -369,13 +326,6 @@ pub struct Struct {\n     pub(crate) id: StructId,\n }\n \n-impl HasSource for Struct {\n-    type Ast = TreeArc<ast::StructDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n-        self.id.source(db).into()\n-    }\n-}\n-\n impl Struct {\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         self.id.module(db)\n@@ -430,13 +380,6 @@ pub struct Union {\n     pub(crate) id: StructId,\n }\n \n-impl HasSource for Union {\n-    type Ast = TreeArc<ast::StructDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n-        self.id.source(db).into()\n-    }\n-}\n-\n impl Union {\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n         db.struct_data(Struct { id: self.id }).name.clone()\n@@ -463,13 +406,6 @@ pub struct Enum {\n     pub(crate) id: EnumId,\n }\n \n-impl HasSource for Enum {\n-    type Ast = TreeArc<ast::EnumDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumDef>> {\n-        self.id.source(db).into()\n-    }\n-}\n-\n impl Enum {\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         self.id.module(db)\n@@ -513,13 +449,6 @@ pub struct EnumVariant {\n     pub(crate) id: EnumVariantId,\n }\n \n-impl HasSource for EnumVariant {\n-    type Ast = TreeArc<ast::EnumVariant>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumVariant>> {\n-        self.source_impl(db)\n-    }\n-}\n-\n impl EnumVariant {\n     pub fn module(&self, db: &impl HirDatabase) -> Module {\n         self.parent.module(db)\n@@ -589,14 +518,6 @@ pub struct Function {\n     pub(crate) id: FunctionId,\n }\n \n-impl HasSource for Function {\n-    type Ast = TreeArc<ast::FnDef>;\n-\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::FnDef>> {\n-        self.id.source(db).into()\n-    }\n-}\n-\n /// The declared signature of a function.\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FnSignature {\n@@ -743,14 +664,6 @@ pub struct Const {\n     pub(crate) id: ConstId,\n }\n \n-impl HasSource for Const {\n-    type Ast = TreeArc<ast::ConstDef>;\n-\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::ConstDef>> {\n-        self.id.source(db).into()\n-    }\n-}\n-\n impl Const {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n@@ -827,14 +740,6 @@ pub struct Static {\n     pub(crate) id: StaticId,\n }\n \n-impl HasSource for Static {\n-    type Ast = TreeArc<ast::StaticDef>;\n-\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StaticDef>> {\n-        self.id.source(db).into()\n-    }\n-}\n-\n impl Static {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n@@ -860,13 +765,6 @@ pub struct Trait {\n     pub(crate) id: TraitId,\n }\n \n-impl HasSource for Trait {\n-    type Ast = TreeArc<ast::TraitDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TraitDef>> {\n-        self.id.source(db).into()\n-    }\n-}\n-\n impl Trait {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n@@ -906,13 +804,6 @@ pub struct TypeAlias {\n     pub(crate) id: TypeAliasId,\n }\n \n-impl HasSource for TypeAlias {\n-    type Ast = TreeArc<ast::TypeAliasDef>;\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TypeAliasDef>> {\n-        self.id.source(db).into()\n-    }\n-}\n-\n impl TypeAlias {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n@@ -962,14 +853,6 @@ pub struct MacroDef {\n     pub(crate) id: MacroDefId,\n }\n \n-impl HasSource for MacroDef {\n-    type Ast = TreeArc<ast::MacroCall>;\n-\n-    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::MacroCall>> {\n-        (self.id.0.file_id(), self.id.0.to_node(db)).into()\n-    }\n-}\n-\n impl MacroDef {}\n \n pub enum Container {"}, {"sha": "7484faf04abc7f420a3c65065377d4bbc7192625", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=0dcaded439ae4bd4670bc6a2fbf739cd4fce60af", "patch": "@@ -0,0 +1,120 @@\n+use ra_syntax::{TreeArc, ast};\n+\n+use crate::{\n+    HirFileId, DefDatabase, AstDatabase, Module, ModuleSource,\n+    StructField, Struct, Enum, Union, EnumVariant, Function, Static, Trait, Const, TypeAlias,\n+    FieldSource, MacroDef, ids::AstItemDef,\n+};\n+\n+pub struct Source<T> {\n+    pub file_id: HirFileId,\n+    pub ast: T,\n+}\n+\n+impl<T> From<(HirFileId, T)> for Source<T> {\n+    fn from((file_id, ast): (HirFileId, T)) -> Self {\n+        Source { file_id, ast }\n+    }\n+}\n+\n+pub trait HasSource {\n+    type Ast;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<Self::Ast>;\n+}\n+\n+/// NB: Module is !HasSource, becase it has two source nodes at the same time:\n+/// definition and declaration.\n+impl Module {\n+    /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n+    pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl_id = def_map[self.module_id].declaration;\n+        let file_id = def_map[self.module_id].definition;\n+        let module_source = ModuleSource::new(db, file_id, decl_id);\n+        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n+        (file_id, module_source).into()\n+    }\n+\n+    /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n+    /// `None` for the crate root.\n+    pub fn declaration_source(\n+        self,\n+        db: &(impl DefDatabase + AstDatabase),\n+    ) -> Option<Source<TreeArc<ast::Module>>> {\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl = def_map[self.module_id].declaration?;\n+        let ast = decl.to_node(db);\n+        Some((decl.file_id(), ast).into())\n+    }\n+}\n+\n+impl HasSource for StructField {\n+    type Ast = FieldSource;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<FieldSource> {\n+        self.source_impl(db).into()\n+    }\n+}\n+impl HasSource for Struct {\n+    type Ast = TreeArc<ast::StructDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n+        self.id.source(db).into()\n+    }\n+}\n+impl HasSource for Union {\n+    type Ast = TreeArc<ast::StructDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StructDef>> {\n+        self.id.source(db).into()\n+    }\n+}\n+impl HasSource for Enum {\n+    type Ast = TreeArc<ast::EnumDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumDef>> {\n+        self.id.source(db).into()\n+    }\n+}\n+impl HasSource for EnumVariant {\n+    type Ast = TreeArc<ast::EnumVariant>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::EnumVariant>> {\n+        self.source_impl(db)\n+    }\n+}\n+impl HasSource for Function {\n+    type Ast = TreeArc<ast::FnDef>;\n+\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::FnDef>> {\n+        self.id.source(db).into()\n+    }\n+}\n+impl HasSource for Const {\n+    type Ast = TreeArc<ast::ConstDef>;\n+\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::ConstDef>> {\n+        self.id.source(db).into()\n+    }\n+}\n+impl HasSource for Static {\n+    type Ast = TreeArc<ast::StaticDef>;\n+\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::StaticDef>> {\n+        self.id.source(db).into()\n+    }\n+}\n+impl HasSource for Trait {\n+    type Ast = TreeArc<ast::TraitDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TraitDef>> {\n+        self.id.source(db).into()\n+    }\n+}\n+impl HasSource for TypeAlias {\n+    type Ast = TreeArc<ast::TypeAliasDef>;\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::TypeAliasDef>> {\n+        self.id.source(db).into()\n+    }\n+}\n+impl HasSource for MacroDef {\n+    type Ast = TreeArc<ast::MacroCall>;\n+\n+    fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<TreeArc<ast::MacroCall>> {\n+        (self.id.0.file_id(), self.id.0.to_node(db)).into()\n+    }\n+}"}, {"sha": "1690296e503a20f707dee712fe2a9d58ac313e57", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dcaded439ae4bd4670bc6a2fbf739cd4fce60af/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=0dcaded439ae4bd4670bc6a2fbf739cd4fce60af", "patch": "@@ -81,5 +81,6 @@ pub use self::code_model::{\n     StructField, FieldSource,\n     Static, Const, ConstSignature,\n     Trait, TypeAlias, MacroDef, Container,\n-    BuiltinType, Source, HasSource,\n+    BuiltinType,\n+    src::{Source, HasSource},\n };"}]}