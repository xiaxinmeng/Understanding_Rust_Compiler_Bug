{"sha": "ecebfe0c9cee0694e986af63a446031606825d18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZWJmZTBjOWNlZTA2OTRlOTg2YWY2M2E0NDYwMzE2MDY4MjVkMTg=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-21T17:12:17Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:14:20Z"}, "message": "Move check_for_loop_arg back to mod; split into 4 lint files", "tree": {"sha": "d089d8756a5e2615728a7aafb9f64607292e1467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d089d8756a5e2615728a7aafb9f64607292e1467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecebfe0c9cee0694e986af63a446031606825d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecebfe0c9cee0694e986af63a446031606825d18", "html_url": "https://github.com/rust-lang/rust/commit/ecebfe0c9cee0694e986af63a446031606825d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecebfe0c9cee0694e986af63a446031606825d18/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cfdef6de19a0aaddcc3018baf1031ae54c419f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cfdef6de19a0aaddcc3018baf1031ae54c419f6", "html_url": "https://github.com/rust-lang/rust/commit/7cfdef6de19a0aaddcc3018baf1031ae54c419f6"}], "stats": {"total": 180, "additions": 176, "deletions": 4}, "files": [{"sha": "d5d2bedaf1b4e6ed77bfe889f05f74d48a03a236", "filename": "clippy_lints/src/loops/explicit_into_iter_loop.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs?ref=ecebfe0c9cee0694e986af63a446031606825d18", "patch": "@@ -0,0 +1,20 @@\n+use super::EXPLICIT_INTO_ITER_LOOP;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+pub(super) fn check_explicit_into_iter_loop(cx: &LateContext<'_>, method_args: &'hir [Expr<'hir>], arg: &Expr<'_>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, method_args[0].span, \"_\", &mut applicability);\n+    span_lint_and_sugg(\n+        cx,\n+        EXPLICIT_INTO_ITER_LOOP,\n+        arg.span,\n+        \"it is more concise to loop over containers instead of using explicit \\\n+            iteration methods\",\n+        \"to write this more concisely, try\",\n+        object.to_string(),\n+        applicability,\n+    );\n+}"}, {"sha": "14184865da3375a88f9847e05056fa3f71893217", "filename": "clippy_lints/src/loops/explicit_iter_loop.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs?ref=ecebfe0c9cee0694e986af63a446031606825d18", "patch": "@@ -0,0 +1,21 @@\n+use super::EXPLICIT_ITER_LOOP;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+pub(super) fn lint_iter_method(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+    let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n+    span_lint_and_sugg(\n+        cx,\n+        EXPLICIT_ITER_LOOP,\n+        arg.span,\n+        \"it is more concise to loop over references to containers instead of using explicit \\\n+         iteration methods\",\n+        \"to write this more concisely, try\",\n+        format!(\"&{}{}\", muta, object),\n+        applicability,\n+    )\n+}"}, {"sha": "1339af33759afe14fba7bae328b551a4e7b340d2", "filename": "clippy_lints/src/loops/for_loops_over_fallibles.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs?ref=ecebfe0c9cee0694e986af63a446031606825d18", "patch": "@@ -0,0 +1,45 @@\n+use super::FOR_LOOPS_OVER_FALLIBLES;\n+use crate::utils::{is_type_diagnostic_item, snippet, span_lint_and_help};\n+use rustc_hir::{Expr, Pat};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+/// Checks for `for` loops over `Option`s and `Result`s.\n+pub(super) fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(arg);\n+    if is_type_diagnostic_item(cx, ty, sym::option_type) {\n+        span_lint_and_help(\n+            cx,\n+            FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n+                `if let` statement\",\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            None,\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n+    } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n+        span_lint_and_help(\n+            cx,\n+            FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n+                `if let` statement\",\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            None,\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n+    }\n+}"}, {"sha": "7a5a873a358a5747bf3e719270f319266a947d8d", "filename": "clippy_lints/src/loops/iter_next_loop.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs?ref=ecebfe0c9cee0694e986af63a446031606825d18", "patch": "@@ -0,0 +1,14 @@\n+use super::ITER_NEXT_LOOP;\n+use crate::utils::span_lint;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+pub(super) fn lint(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    span_lint(\n+        cx,\n+        ITER_NEXT_LOOP,\n+        expr.span,\n+        \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n+        probably not what you want\",\n+    );\n+}"}, {"sha": "4594afc233283d384c771d2fa8236dee955df488", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecebfe0c9cee0694e986af63a446031606825d18/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=ecebfe0c9cee0694e986af63a446031606825d18", "patch": "@@ -1,11 +1,14 @@\n mod empty_loop;\n mod explicit_counter_loop;\n-mod for_loop_arg;\n+mod explicit_into_iter_loop;\n+mod explicit_iter_loop;\n mod for_loop_over_map_kv;\n mod for_loop_range;\n+mod for_loops_over_fallibles;\n mod for_mut_range_bound;\n mod for_single_element_loop;\n mod infinite_loop;\n+mod iter_next_loop;\n mod manual_flatten;\n mod manual_memcpy;\n mod needless_collect;\n@@ -15,11 +18,13 @@ mod utils;\n mod while_let_loop;\n mod while_let_on_iterator;\n \n-use crate::utils::higher;\n-use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n+use crate::utils::{higher, is_type_diagnostic_item, match_trait_method, match_type, paths};\n+use rustc_hir::{Expr, ExprKind, LoopSource, Mutability, Pat};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n \n declare_clippy_lint! {\n@@ -588,10 +593,77 @@ fn check_for_loop<'tcx>(\n         for_loop_range::check_for_loop_range(cx, pat, arg, body, expr);\n         explicit_counter_loop::check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     }\n-    for_loop_arg::check_for_loop_arg(cx, pat, arg, expr);\n+    check_for_loop_arg(cx, pat, arg, expr);\n     for_loop_over_map_kv::check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     for_mut_range_bound::check_for_mut_range_bound(cx, arg, body);\n     for_single_element_loop::check_for_single_element_loop(cx, pat, arg, body, expr);\n     same_item_push::detect_same_item_push(cx, pat, arg, body, expr);\n     manual_flatten::check_manual_flatten(cx, pat, arg, body, span);\n }\n+\n+fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n+    let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n+    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n+        // just the receiver, no arguments\n+        if args.len() == 1 {\n+            let method_name = &*method.ident.as_str();\n+            // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n+            if method_name == \"iter\" || method_name == \"iter_mut\" {\n+                if is_ref_iterable_type(cx, &args[0]) {\n+                    explicit_iter_loop::lint_iter_method(cx, args, arg, method_name);\n+                }\n+            } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n+                let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+                if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n+                    explicit_into_iter_loop::check_explicit_into_iter_loop(cx, args, arg);\n+                } else {\n+                    let ref_receiver_ty = cx.tcx.mk_ref(\n+                        cx.tcx.lifetimes.re_erased,\n+                        ty::TypeAndMut {\n+                            ty: receiver_ty,\n+                            mutbl: Mutability::Not,\n+                        },\n+                    );\n+                    if TyS::same_type(receiver_ty_adjusted, ref_receiver_ty) {\n+                        explicit_iter_loop::lint_iter_method(cx, args, arg, method_name)\n+                    }\n+                }\n+            } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n+                iter_next_loop::lint(cx, expr);\n+                next_loop_linted = true;\n+            }\n+        }\n+    }\n+    if !next_loop_linted {\n+        for_loops_over_fallibles::check_arg_type(cx, pat, arg);\n+    }\n+}\n+\n+/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n+/// for `&T` and `&mut T`, such as `Vec`.\n+#[rustfmt::skip]\n+fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n+    // will allow further borrows afterwards\n+    let ty = cx.typeck_results().expr_ty(e);\n+    is_iterable_array(ty, cx) ||\n+    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+    match_type(cx, ty, &paths::LINKED_LIST) ||\n+    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+    match_type(cx, ty, &paths::BINARY_HEAP) ||\n+    match_type(cx, ty, &paths::BTREEMAP) ||\n+    match_type(cx, ty, &paths::BTREESET)\n+}\n+\n+fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n+    match ty.kind() {\n+        ty::Array(_, n) => n\n+            .try_eval_usize(cx.tcx, cx.param_env)\n+            .map_or(false, |val| (0..=32).contains(&val)),\n+        _ => false,\n+    }\n+}"}]}