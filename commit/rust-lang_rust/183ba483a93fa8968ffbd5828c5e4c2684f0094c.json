{"sha": "183ba483a93fa8968ffbd5828c5e4c2684f0094c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4M2JhNDgzYTkzZmE4OTY4ZmZiZDU4MjhjNWU0YzI2ODRmMDA5NGM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-03T17:23:38Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-03T18:48:35Z"}, "message": "Reorder functions in rename.rs", "tree": {"sha": "7e795081ebc93569d1f816b6a149f68ae7478f2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e795081ebc93569d1f816b6a149f68ae7478f2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/183ba483a93fa8968ffbd5828c5e4c2684f0094c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/183ba483a93fa8968ffbd5828c5e4c2684f0094c", "html_url": "https://github.com/rust-lang/rust/commit/183ba483a93fa8968ffbd5828c5e4c2684f0094c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/183ba483a93fa8968ffbd5828c5e4c2684f0094c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "603481f534e7da99dc759e0d25f25f18a100ac10", "url": "https://api.github.com/repos/rust-lang/rust/commits/603481f534e7da99dc759e0d25f25f18a100ac10", "html_url": "https://github.com/rust-lang/rust/commit/603481f534e7da99dc759e0d25f25f18a100ac10"}], "stats": {"total": 376, "additions": 187, "deletions": 189}, "files": [{"sha": "878ca1afc98aeefa0eb218b64391e2e380db46cd", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 187, "deletions": 189, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/183ba483a93fa8968ffbd5828c5e4c2684f0094c/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183ba483a93fa8968ffbd5828c5e4c2684f0094c/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=183ba483a93fa8968ffbd5828c5e4c2684f0094c", "patch": "@@ -122,7 +122,7 @@ fn check_identifier(new_name: &str) -> RenameResult<IdentifierKind> {\n                 Ok(IdentifierKind::Lifetime)\n             }\n             (SyntaxKind::LIFETIME_IDENT, _) => {\n-                bail!(\"Invalid name `{0}`: Cannot rename lifetime to {0}\", new_name)\n+                bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n             }\n             (_, Some(syntax_error)) => bail!(\"Invalid name `{}`: {}\", new_name, syntax_error),\n             (_, None) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n@@ -162,119 +162,6 @@ fn find_definition(\n     .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n-fn source_edit_from_references(\n-    _sema: &Semantics<RootDatabase>,\n-    file_id: FileId,\n-    references: &[FileReference],\n-    def: Definition,\n-    new_name: &str,\n-) -> (FileId, TextEdit) {\n-    let mut edit = TextEdit::builder();\n-    for reference in references {\n-        let (range, replacement) = match &reference.name {\n-            // if the ranges differ then the node is inside a macro call, we can't really attempt\n-            // to make special rewrites like shorthand syntax and such, so just rename the node in\n-            // the macro input\n-            ast::NameLike::NameRef(name_ref)\n-                if name_ref.syntax().text_range() == reference.range =>\n-            {\n-                source_edit_from_name_ref(name_ref, new_name, def)\n-            }\n-            ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n-                source_edit_from_name(name, new_name)\n-            }\n-            _ => None,\n-        }\n-        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n-        edit.replace(range, replacement);\n-    }\n-    (file_id, edit.finish())\n-}\n-\n-fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n-    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n-        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n-            return Some((\n-                TextRange::empty(ident_pat.syntax().text_range().start()),\n-                format!(\"{}: \", new_name),\n-            ));\n-        }\n-    }\n-    None\n-}\n-\n-fn source_edit_from_name_ref(\n-    name_ref: &ast::NameRef,\n-    new_name: &str,\n-    def: Definition,\n-) -> Option<(TextRange, String)> {\n-    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n-        let rcf_name_ref = record_field.name_ref();\n-        let rcf_expr = record_field.expr();\n-        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n-            // field: init-expr, check if we can use a field init shorthand\n-            (Some(field_name), Some(init)) => {\n-                if field_name == *name_ref {\n-                    if init.text() == new_name {\n-                        mark::hit!(test_rename_field_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n-                    }\n-                } else if init == *name_ref {\n-                    if field_name.text() == new_name {\n-                        mark::hit!(test_rename_local_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n-                    }\n-                }\n-                None\n-            }\n-            // init shorthand\n-            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n-            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n-            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n-                mark::hit!(test_rename_field_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().start();\n-                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n-            }\n-            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n-                mark::hit!(test_rename_local_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().end();\n-                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n-            }\n-            _ => None,\n-        }\n-    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n-        let rcf_name_ref = record_field.name_ref();\n-        let rcf_pat = record_field.pat();\n-        match (rcf_name_ref, rcf_pat) {\n-            // field: rename\n-            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n-                // field name is being renamed\n-                if pat.name().map_or(false, |it| it.text() == new_name) {\n-                    mark::hit!(test_rename_field_put_init_shorthand_pat);\n-                    // same names, we can use a shorthand here instead/\n-                    // we do not want to erase attributes hence this range start\n-                    let s = field_name.syntax().text_range().start();\n-                    let e = record_field.syntax().text_range().end();\n-                    Some((TextRange::new(s, e), pat.to_string()))\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n fn rename_mod(\n     sema: &Semantics<RootDatabase>,\n     module: Module,\n@@ -308,18 +195,75 @@ fn rename_mod(\n                 TextEdit::replace(name.syntax().text_range(), new_name.to_string()),\n             ),\n             _ => unreachable!(),\n-        };\n+        }\n     }\n     let def = Definition::ModuleDef(ModuleDef::Module(module));\n     let usages = def.usages(sema).all();\n     let ref_edits = usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, references, def, new_name)\n+        (file_id, source_edit_from_references(references, def, new_name))\n     });\n     source_change.extend(ref_edits);\n \n     Ok(source_change)\n }\n \n+fn rename_reference(\n+    sema: &Semantics<RootDatabase>,\n+    def: Definition,\n+    new_name: &str,\n+) -> RenameResult<SourceChange> {\n+    let ident_kind = check_identifier(new_name)?;\n+\n+    let def_is_lbl_or_lt = matches!(\n+        def,\n+        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n+    );\n+    match (ident_kind, def) {\n+        (IdentifierKind::ToSelf, _)\n+        | (IdentifierKind::Underscore, _)\n+        | (IdentifierKind::Ident, _)\n+            if def_is_lbl_or_lt =>\n+        {\n+            mark::hit!(rename_not_a_lifetime_ident_ref);\n+            bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n+        }\n+        (IdentifierKind::Lifetime, _) if def_is_lbl_or_lt => mark::hit!(rename_lifetime),\n+        (IdentifierKind::Lifetime, _) => {\n+            mark::hit!(rename_not_an_ident_ref);\n+            bail!(\"Invalid name `{}`: not an identifier\", new_name)\n+        }\n+        (IdentifierKind::ToSelf, Definition::Local(local)) if local.is_self(sema.db) => {\n+            // no-op\n+            mark::hit!(rename_self_to_self);\n+            return Ok(SourceChange::default());\n+        }\n+        (ident_kind, Definition::Local(local)) if local.is_self(sema.db) => {\n+            mark::hit!(rename_self_to_param);\n+            return rename_self_to_param(sema, local, new_name, ident_kind);\n+        }\n+        (IdentifierKind::ToSelf, Definition::Local(local)) => {\n+            mark::hit!(rename_to_self);\n+            return rename_to_self(sema, local);\n+        }\n+        (IdentifierKind::ToSelf, _) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => mark::hit!(rename_ident),\n+    }\n+\n+    let usages = def.usages(sema).all();\n+    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n+        mark::hit!(rename_underscore_multiple);\n+        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n+    }\n+    let mut source_change = SourceChange::default();\n+    source_change.extend(usages.iter().map(|(&file_id, references)| {\n+        (file_id, source_edit_from_references(&references, def, new_name))\n+    }));\n+\n+    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n+    source_change.insert_source_edit(file_id, edit);\n+    Ok(source_change)\n+}\n+\n fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameResult<SourceChange> {\n     if never!(local.is_self(sema.db)) {\n         bail!(\"rename_to_self invoked on self\");\n@@ -384,7 +328,7 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n     let usages = def.usages(sema).all();\n     let mut source_change = SourceChange::default();\n     source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, references, def, \"self\")\n+        (file_id, source_edit_from_references(references, def, \"self\"))\n     }));\n     source_change.insert_source_edit(\n         file_id.original_file(sema.db),\n@@ -394,29 +338,6 @@ fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameRe\n     Ok(source_change)\n }\n \n-fn text_edit_from_self_param(self_param: &ast::SelfParam, new_name: &str) -> Option<TextEdit> {\n-    fn target_type_name(impl_def: &ast::Impl) -> Option<String> {\n-        if let Some(ast::Type::PathType(p)) = impl_def.self_ty() {\n-            return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n-        }\n-        None\n-    }\n-\n-    let impl_def = self_param.syntax().ancestors().find_map(|it| ast::Impl::cast(it))?;\n-    let type_name = target_type_name(&impl_def)?;\n-\n-    let mut replacement_text = String::from(new_name);\n-    replacement_text.push_str(\": \");\n-    match (self_param.amp_token(), self_param.mut_token()) {\n-        (None, None) => (),\n-        (Some(_), None) => replacement_text.push('&'),\n-        (_, Some(_)) => replacement_text.push_str(\"&mut \"),\n-    };\n-    replacement_text.push_str(type_name.as_str());\n-\n-    Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))\n-}\n-\n fn rename_self_to_param(\n     sema: &Semantics<RootDatabase>,\n     local: hir::Local,\n@@ -441,66 +362,143 @@ fn rename_self_to_param(\n     let mut source_change = SourceChange::default();\n     source_change.insert_source_edit(file_id.original_file(sema.db), edit);\n     source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, &references, def, new_name)\n+        (file_id, source_edit_from_references(&references, def, new_name))\n     }));\n     Ok(source_change)\n }\n \n-fn rename_reference(\n-    sema: &Semantics<RootDatabase>,\n+fn text_edit_from_self_param(self_param: &ast::SelfParam, new_name: &str) -> Option<TextEdit> {\n+    fn target_type_name(impl_def: &ast::Impl) -> Option<String> {\n+        if let Some(ast::Type::PathType(p)) = impl_def.self_ty() {\n+            return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n+        }\n+        None\n+    }\n+\n+    let impl_def = self_param.syntax().ancestors().find_map(|it| ast::Impl::cast(it))?;\n+    let type_name = target_type_name(&impl_def)?;\n+\n+    let mut replacement_text = String::from(new_name);\n+    replacement_text.push_str(\": \");\n+    match (self_param.amp_token(), self_param.mut_token()) {\n+        (Some(_), None) => replacement_text.push('&'),\n+        (Some(_), Some(_)) => replacement_text.push_str(\"&mut \"),\n+        (_, _) => (),\n+    };\n+    replacement_text.push_str(type_name.as_str());\n+\n+    Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))\n+}\n+\n+fn source_edit_from_references(\n+    references: &[FileReference],\n     def: Definition,\n     new_name: &str,\n-) -> RenameResult<SourceChange> {\n-    let ident_kind = check_identifier(new_name)?;\n-\n-    let def_is_lbl_or_lt = matches!(\n-        def,\n-        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n-    );\n-    match (ident_kind, def) {\n-        (IdentifierKind::ToSelf, _)\n-        | (IdentifierKind::Underscore, _)\n-        | (IdentifierKind::Ident, _)\n-            if def_is_lbl_or_lt =>\n-        {\n-            mark::hit!(rename_not_a_lifetime_ident_ref);\n-            bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n-        }\n-        (IdentifierKind::Lifetime, _) if def_is_lbl_or_lt => mark::hit!(rename_lifetime),\n-        (IdentifierKind::Lifetime, _) => {\n-            mark::hit!(rename_not_an_ident_ref);\n-            bail!(\"Invalid name `{}`: not an identifier\", new_name)\n-        }\n-        (IdentifierKind::ToSelf, Definition::Local(local)) if local.is_self(sema.db) => {\n-            // no-op\n-            mark::hit!(rename_self_to_self);\n-            return Ok(SourceChange::default());\n-        }\n-        (ident_kind, Definition::Local(local)) if local.is_self(sema.db) => {\n-            mark::hit!(rename_self_to_param);\n-            return rename_self_to_param(sema, local, new_name, ident_kind);\n-        }\n-        (IdentifierKind::ToSelf, Definition::Local(local)) => {\n-            mark::hit!(rename_to_self);\n-            return rename_to_self(sema, local);\n+) -> TextEdit {\n+    let mut edit = TextEdit::builder();\n+    for reference in references {\n+        let (range, replacement) = match &reference.name {\n+            // if the ranges differ then the node is inside a macro call, we can't really attempt\n+            // to make special rewrites like shorthand syntax and such, so just rename the node in\n+            // the macro input\n+            ast::NameLike::NameRef(name_ref)\n+                if name_ref.syntax().text_range() == reference.range =>\n+            {\n+                source_edit_from_name_ref(name_ref, new_name, def)\n+            }\n+            ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n+                source_edit_from_name(name, new_name)\n+            }\n+            _ => None,\n         }\n-        (IdentifierKind::ToSelf, _) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n-        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => mark::hit!(rename_ident),\n+        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n+        edit.replace(range, replacement);\n     }\n+    edit.finish()\n+}\n \n-    let usages = def.usages(sema).all();\n-    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n-        mark::hit!(rename_underscore_multiple);\n-        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n+fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n+    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n+        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n+            return Some((\n+                TextRange::empty(ident_pat.syntax().text_range().start()),\n+                [new_name, \": \"].concat(),\n+            ));\n+        }\n     }\n-    let mut source_change = SourceChange::default();\n-    source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        source_edit_from_references(sema, file_id, &references, def, new_name)\n-    }));\n+    None\n+}\n \n-    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n-    source_change.insert_source_edit(file_id, edit);\n-    Ok(source_change)\n+fn source_edit_from_name_ref(\n+    name_ref: &ast::NameRef,\n+    new_name: &str,\n+    def: Definition,\n+) -> Option<(TextRange, String)> {\n+    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_expr = record_field.expr();\n+        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n+            // field: init-expr, check if we can use a field init shorthand\n+            (Some(field_name), Some(init)) => {\n+                if field_name == *name_ref {\n+                    if init.text() == new_name {\n+                        mark::hit!(test_rename_field_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead.\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                    }\n+                } else if init == *name_ref {\n+                    if field_name.text() == new_name {\n+                        mark::hit!(test_rename_local_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead.\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                    }\n+                }\n+                None\n+            }\n+            // init shorthand\n+            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n+            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n+            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n+                mark::hit!(test_rename_field_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().start();\n+                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n+            }\n+            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n+                mark::hit!(test_rename_local_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().end();\n+                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n+            }\n+            _ => None,\n+        }\n+    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_pat = record_field.pat();\n+        match (rcf_name_ref, rcf_pat) {\n+            // field: rename\n+            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n+                // field name is being renamed\n+                if pat.name().map_or(false, |it| it.text() == new_name) {\n+                    mark::hit!(test_rename_field_put_init_shorthand_pat);\n+                    // same names, we can use a shorthand here instead/\n+                    // we do not want to erase attributes hence this range start\n+                    let s = field_name.syntax().text_range().start();\n+                    let e = record_field.syntax().text_range().end();\n+                    Some((TextRange::new(s, e), pat.to_string()))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n }\n \n fn source_edit_from_def("}]}