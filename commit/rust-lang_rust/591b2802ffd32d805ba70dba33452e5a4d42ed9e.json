{"sha": "591b2802ffd32d805ba70dba33452e5a4d42ed9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MWIyODAyZmZkMzJkODA1YmE3MGRiYTMzNDUyZTVhNGQ0MmVkOWU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-14T01:00:17Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-14T01:00:17Z"}, "message": "Make trans only generate calls to the _dyn malloc upcalls, so we can get rid of the non dyn ones.", "tree": {"sha": "81e8e2687df6d1ac8b5d2c60ce437ae01ca197ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81e8e2687df6d1ac8b5d2c60ce437ae01ca197ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/591b2802ffd32d805ba70dba33452e5a4d42ed9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/591b2802ffd32d805ba70dba33452e5a4d42ed9e", "html_url": "https://github.com/rust-lang/rust/commit/591b2802ffd32d805ba70dba33452e5a4d42ed9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/591b2802ffd32d805ba70dba33452e5a4d42ed9e/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c0d41cffae78725c20a40302e81ef1246c3e4c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0d41cffae78725c20a40302e81ef1246c3e4c7", "html_url": "https://github.com/rust-lang/rust/commit/4c0d41cffae78725c20a40302e81ef1246c3e4c7"}], "stats": {"total": 69, "additions": 26, "deletions": 43}, "files": [{"sha": "9e736252fd66465c1b7bd848e00c8c65ec59fa74", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/591b2802ffd32d805ba70dba33452e5a4d42ed9e/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/591b2802ffd32d805ba70dba33452e5a4d42ed9e/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=591b2802ffd32d805ba70dba33452e5a4d42ed9e", "patch": "@@ -156,6 +156,7 @@ exchange_malloc(rust_task *task, type_desc *td, uintptr_t size) {\n     return (uintptr_t)header;\n }\n \n+// FIXME: remove after snapshot (6/13/12)\n struct s_exchange_malloc_args {\n     uintptr_t retval;\n     type_desc *td;\n@@ -238,6 +239,7 @@ shared_malloc(rust_task *task, type_desc *td, uintptr_t size) {\n     return (uintptr_t)box;\n }\n \n+// FIXME: remove after snapshot (6/13/12)\n struct s_malloc_args {\n     uintptr_t retval;\n     type_desc *td;"}, {"sha": "3925f005de8aa66cf48244c18db26ea824d14467", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/591b2802ffd32d805ba70dba33452e5a4d42ed9e/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591b2802ffd32d805ba70dba33452e5a4d42ed9e/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=591b2802ffd32d805ba70dba33452e5a4d42ed9e", "patch": "@@ -10,10 +10,8 @@ import lib::llvm::{type_names, ModuleRef, ValueRef, TypeRef};\n type upcalls =\n     {_fail: ValueRef,\n      trace: ValueRef,\n-     malloc: ValueRef,\n      malloc_dyn: ValueRef,\n      free: ValueRef,\n-     exchange_malloc: ValueRef,\n      exchange_malloc_dyn: ValueRef,\n      exchange_free: ValueRef,\n      validate_box: ValueRef,\n@@ -57,17 +55,12 @@ fn declare_upcalls(targ_cfg: @session::config,\n           trace: dv(\"trace\", [T_ptr(T_i8()),\n                               T_ptr(T_i8()),\n                               int_t]),\n-          malloc:\n-              nothrow(d(\"malloc\", [T_ptr(tydesc_type)],\n           malloc_dyn:\n               nothrow(d(\"malloc_dyn\",\n                         [T_ptr(tydesc_type), int_t],\n                         T_ptr(T_i8()))),\n           free:\n               nothrow(dv(\"free\", [T_ptr(T_i8())])),\n-          exchange_malloc:\n-              nothrow(d(\"exchange_malloc\", [T_ptr(tydesc_type)],\n-                        T_ptr(T_i8()))),\n           exchange_malloc_dyn:\n               nothrow(d(\"exchange_malloc_dyn\",\n                         [T_ptr(tydesc_type), int_t],"}, {"sha": "57e0751f3190c92261198a98c8eb1a31ac27e312", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/591b2802ffd32d805ba70dba33452e5a4d42ed9e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591b2802ffd32d805ba70dba33452e5a4d42ed9e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=591b2802ffd32d805ba70dba33452e5a4d42ed9e", "patch": "@@ -348,17 +348,17 @@ fn opaque_box_body(bcx: block,\n     PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n }\n \n-// malloc_raw: expects an unboxed type and returns a pointer to\n-// enough space for a box of that type.  This includes a rust_opaque_box\n-// header.\n-fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n+// malloc_raw_dyn: allocates a box to contain a given type, but with a\n+// potentially dynamic size.\n+fn malloc_raw_dyn(bcx: block, t: ty::t, heap: heap,\n+                  size: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n     let (mk_fn, upcall) = alt heap {\n-      heap_shared { (ty::mk_imm_box, ccx.upcalls.malloc) }\n+      heap_shared { (ty::mk_imm_box, ccx.upcalls.malloc_dyn) }\n       heap_exchange {\n-        (ty::mk_imm_uniq, ccx.upcalls.exchange_malloc )\n+        (ty::mk_imm_uniq, ccx.upcalls.exchange_malloc_dyn )\n       }\n     };\n \n@@ -372,52 +372,40 @@ fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n     lazily_emit_all_tydesc_glue(ccx, copy static_ti);\n \n     // Allocate space:\n-    let rval = Call(bcx, upcall, [lltydesc]);\n+    let rval = Call(bcx, upcall, [lltydesc, size]);\n     ret PointerCast(bcx, rval, llty);\n }\n \n-// malloc_general: usefully wraps malloc_raw; allocates a box,\n+// malloc_raw: expects an unboxed type and returns a pointer to\n+// enough space for a box of that type.  This includes a rust_opaque_box\n+// header.\n+fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n+    malloc_raw_dyn(bcx, t, heap, llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n+}\n+\n+// malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a box,\n // and pulls out the body\n-fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n+fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef) ->\n     {box: ValueRef, body: ValueRef} {\n     let _icx = bcx.insn_ctxt(\"malloc_general\");\n-    let box = malloc_raw(bcx, t, heap);\n+    let box = malloc_raw_dyn(bcx, t, heap, size);\n     let non_gc_box = non_gc_box_cast(bcx, box);\n     let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n }\n \n fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    malloc_general(bcx, t, heap_shared)\n+    malloc_general_dyn(bcx, t, heap_shared,\n+                       llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n }\n fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    malloc_general(bcx, t, heap_exchange)\n-}\n-\n-fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_dyn_raw\");\n-    let ccx = bcx.ccx();\n-\n-    // Grab the TypeRef type of box_ptr_ty.\n-    let box_ptr_ty = ty::mk_imm_uniq(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr_ty);\n-\n-    // Get the tydesc for the body:\n-    let mut static_ti = none;\n-    let lltydesc = get_tydesc(ccx, t, static_ti);\n-    lazily_emit_all_tydesc_glue(ccx, static_ti);\n-\n-    // Allocate space:\n-    let rval = Call(bcx, ccx.upcalls.exchange_malloc_dyn, [lltydesc, size]);\n-    ret PointerCast(bcx, rval, llty);\n+    malloc_general_dyn(bcx, t, heap_exchange,\n+                       llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n }\n \n fn malloc_unique_dyn(bcx: block, t: ty::t, size: ValueRef\n                     ) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_dyn\");\n-    let box = malloc_unique_dyn_raw(bcx, t, size);\n-    let body = GEPi(bcx, box, [0u, abi::box_field_body]);\n-    ret {box: box, body: body};\n+    malloc_general_dyn(bcx, t, heap_exchange, size)\n }\n \n // Type descriptor and type glue stuff"}, {"sha": "868826d975bfd93e79a326f16c1cab15bfbded71", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/591b2802ffd32d805ba70dba33452e5a4d42ed9e/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/591b2802ffd32d805ba70dba33452e5a4d42ed9e/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=591b2802ffd32d805ba70dba33452e5a4d42ed9e", "patch": "@@ -553,8 +553,8 @@ fn make_opaque_cbox_take_glue(\n         let sz = Add(bcx, sz, shape::llsize_of(ccx, T_box_header(ccx)));\n \n         // Allocate memory, update original ptr, and copy existing data\n-        let malloc = ccx.upcalls.exchange_malloc;\n-        let cbox_out = Call(bcx, malloc, [tydesc]);\n+        let malloc = ccx.upcalls.exchange_malloc_dyn;\n+        let cbox_out = Call(bcx, malloc, [tydesc, sz]);\n         let cbox_out = PointerCast(bcx, cbox_out, llopaquecboxty);\n         call_memmove(bcx, cbox_out, cbox_in, sz);\n         Store(bcx, cbox_out, cboxptr);"}]}