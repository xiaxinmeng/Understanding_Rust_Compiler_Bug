{"sha": "d4ed46fa757d753b64cd45de2604878780d7189a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZWQ0NmZhNzU3ZDc1M2I2NGNkNDVkZTI2MDQ4Nzg3ODBkNzE4OWE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-04-27T16:26:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-27T16:26:25Z"}, "message": "Merge pull request #495 from bjorn3/use_cg_clif_link\n\nUse cg clif link", "tree": {"sha": "5a2b0fbeb5bb09159bdaa0044e04f937b4991878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a2b0fbeb5bb09159bdaa0044e04f937b4991878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4ed46fa757d753b64cd45de2604878780d7189a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcxIKxCRBK7hj4Ov3rIwAAdHIIAGRFJkuNJP8WanA865/xcpPH\n3RlJkKX/KgZRfAIULVRANWIvUW1YMuB6pec71bFRjlyJC0mbfickmllmkAjlAh2g\nNjuuHX39fsltJzFtuYoYpRkO2oofeaUB0Nvjqsqq1ntQoT2yVEUsO6qmc9h00cgS\nM+Q55CCx/EDKm1Z9YNbnuQXbFmSMUdzpwbzg3llOU38R4Ngp9YgdLApVmdUkuY19\nzyjECR9lHU6fmpblHAGlPhrJ+/dyix7PwfvEPVnMWKQ/pf4TWxOatlYOdU/wZvMN\nJSeiEOcMu9wEMaTXrToz8eoe0KetB5JHzx5p6QifkJgACg3ySoGwUV/8QdmegrI=\n=PVKh\n-----END PGP SIGNATURE-----\n", "payload": "tree 5a2b0fbeb5bb09159bdaa0044e04f937b4991878\nparent 964edb9a618528247637c0fed6cf174bd8fe5e50\nparent aeecb45bebc26499ba7382627733e2677fab1af6\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1556382385 +0200\ncommitter GitHub <noreply@github.com> 1556382385 +0200\n\nMerge pull request #495 from bjorn3/use_cg_clif_link\n\nUse cg clif link"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ed46fa757d753b64cd45de2604878780d7189a", "html_url": "https://github.com/rust-lang/rust/commit/d4ed46fa757d753b64cd45de2604878780d7189a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4ed46fa757d753b64cd45de2604878780d7189a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "964edb9a618528247637c0fed6cf174bd8fe5e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/964edb9a618528247637c0fed6cf174bd8fe5e50", "html_url": "https://github.com/rust-lang/rust/commit/964edb9a618528247637c0fed6cf174bd8fe5e50"}, {"sha": "aeecb45bebc26499ba7382627733e2677fab1af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeecb45bebc26499ba7382627733e2677fab1af6", "html_url": "https://github.com/rust-lang/rust/commit/aeecb45bebc26499ba7382627733e2677fab1af6"}], "stats": {"total": 932, "additions": 90, "deletions": 842}, "files": [{"sha": "80bc1c90a47204c3c0e6e3c640114159d5686940", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4ed46fa757d753b64cd45de2604878780d7189a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d4ed46fa757d753b64cd45de2604878780d7189a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d4ed46fa757d753b64cd45de2604878780d7189a", "patch": "@@ -19,7 +19,7 @@ dependencies = [\n [[package]]\n name = \"ar\"\n version = \"0.6.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+source = \"git+https://github.com/bjorn3/rust-ar.git?branch=non_multiple_of_two_identifiers_gnu_format#efa2308b9ded41f4977d4fed98dac7af4d9075cf\"\n dependencies = [\n  \"byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -582,7 +582,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ar 0.6.2 (git+https://github.com/bjorn3/rust-ar.git?branch=non_multiple_of_two_identifiers_gnu_format)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cranelift 0.30.0 (git+https://github.com/CraneStation/cranelift.git)\",\n@@ -843,7 +843,7 @@ dependencies = [\n [metadata]\n \"checksum aho-corasick 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e6f484ae0c99fec2e858eb6134949117399f222608d84cadb3f58c1f97c2364c\"\n \"checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n-\"checksum ar 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"579681b3fecd1e9d6b5ce6969e05f9feb913f296eddaf595be1166a5ca597bc4\"\n+\"checksum ar 0.6.2 (git+https://github.com/bjorn3/rust-ar.git?branch=non_multiple_of_two_identifiers_gnu_format)\" = \"<none>\"\n \"checksum arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92c7fb76bc8826a8b33b4ee5bb07a247a81e76764ab4d55e8f73e3a4d8808c71\"\n \"checksum atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652\"\n \"checksum autocfg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a6d640bee2da49f60a4068a7fae53acde8982514ab7bae8b8cea9e88cbcfd799\""}, {"sha": "c5565699cdedb2f76c9400698ea4a25bceb1f92d", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4ed46fa757d753b64cd45de2604878780d7189a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4ed46fa757d753b64cd45de2604878780d7189a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d4ed46fa757d753b64cd45de2604878780d7189a", "patch": "@@ -38,5 +38,8 @@ indexmap = \"1.0.2\"\n #[patch.\"https://github.com/gimli-rs/gimli.git\"]\n #gimli = { path = \"../\" }\n \n+[patch.crates-io]\n+ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"non_multiple_of_two_identifiers_gnu_format\" }\n+\n [profile.dev.overrides.\"*\"]\n opt-level = 3"}, {"sha": "648a407984ca5c0e6263bec46c369bc968ad6981", "filename": "build_sysroot/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4ed46fa757d753b64cd45de2604878780d7189a/build_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4ed46fa757d753b64cd45de2604878780d7189a/build_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.toml?ref=d4ed46fa757d753b64cd45de2604878780d7189a", "patch": "@@ -13,6 +13,7 @@ alloc_system = { path = \"./alloc_system\" }\n \n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/src/tools/rustc-std-workspace-core\" }\n+rustc-std-workspace-alloc = { path = \"./rustc-std-workspace-alloc\" }\n compiler_builtins = { path = \"./compiler_builtins\" }\n \n [profile.release]"}, {"sha": "221365373ffaba3644ec198ce848390bdbe91eee", "filename": "build_sysroot/rustc-std-workspace-alloc/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4ed46fa757d753b64cd45de2604878780d7189a/build_sysroot%2Frustc-std-workspace-alloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d4ed46fa757d753b64cd45de2604878780d7189a/build_sysroot%2Frustc-std-workspace-alloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Frustc-std-workspace-alloc%2FCargo.toml?ref=d4ed46fa757d753b64cd45de2604878780d7189a", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+name = \"rustc-std-workspace-alloc\"\n+version = \"1.0.0\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+license = 'MIT/Apache-2.0'\n+description = \"\"\"\n+Hack for the compiler's own build system\n+\"\"\"\n+edition = \"2018\"\n+\n+[lib]\n+path = \"lib.rs\"\n+\n+[dependencies]\n+alloc = { path = \"../sysroot_src/src/liballoc\" }"}, {"sha": "cf216ec9d29a7c3a107377f141d2d23ef46305d8", "filename": "build_sysroot/rustc-std-workspace-alloc/lib.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4ed46fa757d753b64cd45de2604878780d7189a/build_sysroot%2Frustc-std-workspace-alloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ed46fa757d753b64cd45de2604878780d7189a/build_sysroot%2Frustc-std-workspace-alloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Frustc-std-workspace-alloc%2Flib.rs?ref=d4ed46fa757d753b64cd45de2604878780d7189a", "patch": "@@ -0,0 +1,5 @@\n+#![feature(no_core)]\n+#![no_core]\n+#![deny(rust_2018_idioms)]\n+\n+pub use ::alloc::*;"}, {"sha": "20a8642cbd1754de0d79a3611f72de62e8262988", "filename": "example/alloc_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4ed46fa757d753b64cd45de2604878780d7189a/example%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ed46fa757d753b64cd45de2604878780d7189a/example%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Falloc_example.rs?ref=d4ed46fa757d753b64cd45de2604878780d7189a", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, alloc_system, core_intrinsics, alloc, alloc_prelude, alloc_error_handler)]\n+#![feature(start, box_syntax, alloc_system, core_intrinsics, alloc_prelude, alloc_error_handler)]\n #![no_std]\n \n extern crate alloc;"}, {"sha": "ea6357b539a22584bc1258261a58ecd10a5ada29", "filename": "src/archive.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d4ed46fa757d753b64cd45de2604878780d7189a/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ed46fa757d753b64cd45de2604878780d7189a/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=d4ed46fa757d753b64cd45de2604878780d7189a", "patch": "@@ -1,4 +1,3 @@\n-use std::collections::HashMap;\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n@@ -8,12 +7,14 @@ use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, find_library};\n \n struct ArchiveConfig<'a> {\n-    pub sess: &'a Session,\n-    pub dst: PathBuf,\n-    pub src: Option<PathBuf>,\n-    pub lib_search_paths: Vec<PathBuf>,\n+    sess: &'a Session,\n+    dst: PathBuf,\n+    src: Option<PathBuf>,\n+    lib_search_paths: Vec<PathBuf>,\n+    use_gnu_style_archive: bool,\n }\n \n+#[derive(Debug)]\n enum ArchiveEntry {\n     FromArchive { archive_index: usize, entry_index: usize },\n     File(File),\n@@ -22,7 +23,9 @@ enum ArchiveEntry {\n pub struct ArArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n     src_archives: Vec<ar::Archive<File>>,\n-    entries: HashMap<String, ArchiveEntry>,\n+    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n+    // the end of an archive for linkers to not get confused.\n+    entries: Vec<(String, ArchiveEntry)>,\n     update_symbols: bool,\n }\n \n@@ -34,25 +37,27 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             dst: output.to_path_buf(),\n             src: input.map(|p| p.to_path_buf()),\n             lib_search_paths: archive_search_paths(sess),\n+            // FIXME test for linux and System V derivatives instead\n+            use_gnu_style_archive: !sess.target.target.options.is_like_osx,\n         };\n \n         let (src_archives, entries) = if let Some(src) = &config.src {\n             let mut archive = ar::Archive::new(File::open(src).unwrap());\n-            let mut entries = HashMap::new();\n+            let mut entries = Vec::new();\n \n             let mut i = 0;\n             while let Some(entry) = archive.next_entry() {\n                 let entry = entry.unwrap();\n-                entries.insert(\n+                entries.push((\n                     String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n                     ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n-                );\n+                ));\n                 i += 1;\n             }\n \n             (vec![archive], entries)\n         } else {\n-            (vec![], HashMap::new())\n+            (vec![], Vec::new())\n         };\n \n         ArArchiveBuilder {\n@@ -64,22 +69,22 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     }\n \n     fn src_files(&mut self) -> Vec<String> {\n-        self.entries.keys().cloned().collect()\n+        self.entries.iter().map(|(name, _)| name.clone()).collect()\n     }\n \n     fn remove_file(&mut self, name: &str) {\n-        let file = self.entries.remove(name);\n-        assert!(\n-            file.is_some(),\n-            \"Tried to remove file not existing in src archive\",\n-        );\n+        let index = self.entries\n+            .iter()\n+            .position(|(entry_name, _)| entry_name == name)\n+            .expect(\"Tried to remove file not existing in src archive\");\n+        self.entries.remove(index);\n     }\n \n     fn add_file(&mut self, file: &Path) {\n-        self.entries.insert(\n+        self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string(),\n             ArchiveEntry::File(File::open(file).unwrap()),\n-        );\n+        ));\n     }\n \n     fn add_native_library(&mut self, name: &str) {\n@@ -119,24 +124,44 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     }\n \n     fn build(mut self) {\n-        let mut builder = ar::Builder::new(File::create(&self.config.dst).unwrap());\n+        enum BuilderKind {\n+            Bsd(ar::Builder<File>),\n+            Gnu(ar::GnuBuilder<File>),\n+        }\n+\n+        let archive_file = File::create(&self.config.dst).unwrap();\n+        let mut builder = if self.config.use_gnu_style_archive {\n+            BuilderKind::Gnu(ar::GnuBuilder::new(\n+                archive_file,\n+                self.entries.iter().map(|(name, _)| name.as_bytes().to_vec()).collect(),\n+            ))\n+        } else {\n+            BuilderKind::Bsd(ar::Builder::new(archive_file))\n+        };\n \n         // Add all files\n         for (entry_name, entry) in self.entries.into_iter() {\n             match entry {\n                 ArchiveEntry::FromArchive { archive_index, entry_index } => {\n                     let entry = self.src_archives[archive_index].jump_to_entry(entry_index).unwrap();\n                     let orig_header = entry.header();\n+\n                     let mut header =\n                         ar::Header::new(orig_header.identifier().to_vec(), orig_header.size());\n                     header.set_mtime(orig_header.mtime());\n                     header.set_uid(orig_header.uid());\n                     header.set_gid(orig_header.gid());\n                     header.set_mode(orig_header.mode());\n-                    builder.append(&header, entry).unwrap();\n+                    match builder {\n+                        BuilderKind::Bsd(ref mut builder) => builder.append(&header, entry).unwrap(),\n+                        BuilderKind::Gnu(ref mut builder) => builder.append(&header, entry).unwrap(),\n+                    }\n                 }\n                 ArchiveEntry::File(mut file) => {\n-                    builder.append_file(entry_name.as_bytes(), &mut file).unwrap();\n+                    match builder {\n+                        BuilderKind::Bsd(ref mut builder) => builder.append_file(entry_name.as_bytes(), &mut file).unwrap(),\n+                        BuilderKind::Gnu(ref mut builder) => builder.append_file(entry_name.as_bytes(), &mut file).unwrap(),\n+                    }\n                 }\n             }\n         }\n@@ -169,10 +194,10 @@ impl<'a> ArArchiveBuilder<'a> {\n             let entry = entry.unwrap();\n             let file_name = String::from_utf8(entry.header().identifier().to_vec()).unwrap();\n             if !skip(&file_name) {\n-                self.entries.insert(\n+                self.entries.push((\n                     file_name,\n                     ArchiveEntry::FromArchive { archive_index, entry_index: i },\n-                );\n+                ));\n             }\n             i += 1;\n         }"}, {"sha": "db73d930665fbb053f9c4ef8ea52240d45c24447", "filename": "src/lib.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d4ed46fa757d753b64cd45de2604878780d7189a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ed46fa757d753b64cd45de2604878780d7189a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d4ed46fa757d753b64cd45de2604878780d7189a", "patch": "@@ -28,7 +28,6 @@ use rustc::util::common::ErrorReported;\n use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::CrateInfo;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use rustc_codegen_utils::link::out_filename;\n use rustc_mir::monomorphize::partitioning::CodegenUnitExt;\n \n use cranelift::codegen::settings;\n@@ -46,8 +45,6 @@ mod common;\n mod constant;\n mod debuginfo;\n mod intrinsics;\n-mod link;\n-mod link_copied;\n mod linkage;\n mod main_shim;\n mod metadata;\n@@ -343,13 +340,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                 } else {\n                     None\n                 },\n-                metadata_module: CompiledModule {\n+                metadata_module: Some(CompiledModule {\n                     name: \"dummy_metadata\".to_string(),\n                     kind: ModuleKind::Metadata,\n                     object: None,\n                     bytecode: None,\n                     bytecode_compressed: None,\n-                },\n+                }),\n                 crate_hash: tcx.crate_hash(LOCAL_CRATE),\n                 metadata,\n                 windows_subsystem: None, // Windows is not yet supported\n@@ -366,20 +363,21 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         _dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported> {\n-        let res = *res\n+        use rustc_codegen_ssa::back::link::link_binary;\n+\n+        let codegen_results = *res\n             .downcast::<CodegenResults>()\n             .expect(\"Expected CraneliftCodegenBackend's CodegenResult, found Box<Any>\");\n \n-        for &crate_type in sess.crate_types.borrow().iter() {\n-            let output_name = out_filename(sess, crate_type, &outputs, &res.crate_name.as_str());\n-            match crate_type {\n-                CrateType::Rlib => link::link_rlib(sess, &res, output_name),\n-                CrateType::Dylib | CrateType::Executable => {\n-                    link::link_natively(sess, crate_type, &res, &output_name);\n-                }\n-                _ => sess.fatal(&format!(\"Unsupported crate type: {:?}\", crate_type)),\n-            }\n-        }\n+        let target_cpu = ::target_lexicon::HOST.to_string();\n+        link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n+            sess,\n+            &codegen_results,\n+            outputs,\n+            &codegen_results.crate_name.as_str(),\n+            &target_cpu,\n+        );\n+\n         Ok(())\n     }\n }"}, {"sha": "7694892a8e80a7c835e42539ae8d6efa6c658f28", "filename": "src/link.rs", "status": "removed", "additions": 0, "deletions": 463, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/964edb9a618528247637c0fed6cf174bd8fe5e50/src%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964edb9a618528247637c0fed6cf174bd8fe5e50/src%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flink.rs?ref=964edb9a618528247637c0fed6cf174bd8fe5e50", "patch": "@@ -1,463 +0,0 @@\n-use std::ascii;\n-use std::char;\n-use std::env;\n-use std::fs::File;\n-use std::io;\n-use std::path::{Path, PathBuf};\n-use std::str;\n-\n-use tempfile::Builder as TempFileBuilder;\n-\n-use rustc::session::config::{self, CrateType, DebugInfo, RUST_CGU_EXT};\n-use rustc::session::search_paths::PathKind;\n-use rustc::session::Session;\n-use rustc_codegen_ssa::METADATA_FILENAME;\n-use rustc_codegen_ssa::back::command::Command;\n-use rustc_codegen_ssa::back::link::*;\n-use rustc_codegen_ssa::back::linker::*;\n-use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-use rustc_target::spec::{LinkerFlavor, PanicStrategy, RelroLevel};\n-\n-use crate::prelude::*;\n-\n-use crate::link_copied::*;\n-\n-pub(crate) fn link_rlib(sess: &Session, res: &CodegenResults, output_name: PathBuf) {\n-    let file = File::create(&output_name).unwrap();\n-    let mut builder = ar::Builder::new(file);\n-\n-    // Add main object file\n-    for module in &res.modules {\n-        if let Some(ref object_path) = module.object {\n-            let object = File::open(object_path).expect(\"Someone deleted our object file\");\n-            let object_len = object.metadata().unwrap().len();\n-            builder\n-                .append(\n-                    &ar::Header::new(\n-                        (module.name.to_string() + RUST_CGU_EXT).into_bytes(),\n-                        object_len,\n-                    ),\n-                    object,\n-                )\n-                .unwrap();\n-        }\n-    }\n-\n-    // Non object files need to be added after object files, because ranlib will\n-    // try to read the native architecture from the first file, even if it isn't\n-    // an object file\n-    builder\n-        .append(\n-            &ar::Header::new(\n-                METADATA_FILENAME.as_bytes().to_vec(),\n-                res.metadata.raw_data.len() as u64,\n-            ),\n-            ::std::io::Cursor::new(res.metadata.raw_data.clone()),\n-        )\n-        .unwrap();\n-\n-    // Finalize archive\n-    std::mem::drop(builder);\n-\n-    // Run ranlib to be able to link the archive\n-    let status = std::process::Command::new(\"ranlib\")\n-        .arg(output_name)\n-        .status()\n-        .expect(\"Couldn't run ranlib\");\n-    if !status.success() {\n-        sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n-    }\n-}\n-\n-pub(crate) fn link_natively(\n-    sess: &Session,\n-    crate_type: CrateType,\n-    codegen_results: &CodegenResults,\n-    out_filename: &Path,\n-) {\n-    let tmpdir = match TempFileBuilder::new().prefix(\"rustc\").tempdir() {\n-        Ok(tmpdir) => tmpdir,\n-        Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n-    };\n-\n-    let (linker, flavor) = linker_and_flavor(sess);\n-\n-    // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n-\n-    let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n-    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n-        if sess.crt_static() {\n-            cmd.args(args);\n-        }\n-    }\n-    if let Some(ref args) = sess.opts.debugging_opts.pre_link_args {\n-        cmd.args(args);\n-    }\n-    cmd.args(&sess.opts.debugging_opts.pre_link_arg);\n-\n-    let pre_link_objects = if crate_type == config::CrateType::Executable {\n-        &sess.target.target.options.pre_link_objects_exe\n-    } else {\n-        &sess.target.target.options.pre_link_objects_dll\n-    };\n-    for obj in pre_link_objects {\n-        cmd.arg(root.join(obj));\n-    }\n-\n-    if crate_type == config::CrateType::Executable && sess.crt_static() {\n-        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n-            cmd.arg(root.join(obj));\n-        }\n-    }\n-\n-    if sess.target.target.options.is_like_emscripten {\n-        cmd.arg(\"-s\");\n-        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n-            \"DISABLE_EXCEPTION_CATCHING=1\"\n-        } else {\n-            \"DISABLE_EXCEPTION_CATCHING=0\"\n-        });\n-    }\n-\n-    {\n-        let target_cpu = ::target_lexicon::HOST.to_string();\n-        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, &target_cpu);\n-        link_args(&mut *linker, flavor, sess, crate_type, tmpdir.path(),\n-                  out_filename, codegen_results);\n-        cmd = linker.finalize();\n-    }\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    for obj in &sess.target.target.options.post_link_objects {\n-        cmd.arg(root.join(obj));\n-    }\n-    if sess.crt_static() {\n-        for obj in &sess.target.target.options.post_link_objects_crt {\n-            cmd.arg(root.join(obj));\n-        }\n-    }\n-    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    for &(ref k, ref v) in &sess.target.target.options.link_env {\n-        cmd.env(k, v);\n-    }\n-\n-    if sess.opts.debugging_opts.print_link_args {\n-        println!(\"{:?}\", &cmd);\n-    }\n-\n-    // May have not found libraries in the right formats.\n-    sess.abort_if_errors();\n-\n-    // Invoke the system linker\n-    //\n-    // Note that there's a terribly awful hack that really shouldn't be present\n-    // in any compiler. Here an environment variable is supported to\n-    // automatically retry the linker invocation if the linker looks like it\n-    // segfaulted.\n-    //\n-    // Gee that seems odd, normally segfaults are things we want to know about!\n-    // Unfortunately though in rust-lang/rust#38878 we're experiencing the\n-    // linker segfaulting on Travis quite a bit which is causing quite a bit of\n-    // pain to land PRs when they spuriously fail due to a segfault.\n-    //\n-    // The issue #38878 has some more debugging information on it as well, but\n-    // this unfortunately looks like it's just a race condition in macOS's linker\n-    // with some thread pool working in the background. It seems that no one\n-    // currently knows a fix for this so in the meantime we're left with this...\n-    let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n-    let mut prog;\n-    let mut i = 0;\n-    loop {\n-        i += 1;\n-        prog = exec_linker(sess, &mut cmd, out_filename, tmpdir.path());\n-        let output = match prog {\n-            Ok(ref output) => output,\n-            Err(_) => break,\n-        };\n-        if output.status.success() {\n-            break\n-        }\n-        let mut out = output.stderr.clone();\n-        out.extend(&output.stdout);\n-        let out = String::from_utf8_lossy(&out);\n-\n-        // Check to see if the link failed with \"unrecognized command line option:\n-        // '-no-pie'\" for gcc or \"unknown argument: '-no-pie'\" for clang. If so,\n-        // reperform the link step without the -no-pie option. This is safe because\n-        // if the linker doesn't support -no-pie then it should not default to\n-        // linking executables as pie. Different versions of gcc seem to use\n-        // different quotes in the error message so don't check for them.\n-        if sess.target.target.options.linker_is_gnu &&\n-           flavor != LinkerFlavor::Ld &&\n-           (out.contains(\"unrecognized command line option\") ||\n-            out.contains(\"unknown argument\")) &&\n-           out.contains(\"-no-pie\") &&\n-           cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-no-pie\") {\n-            for arg in cmd.take_args() {\n-                if arg.to_string_lossy() != \"-no-pie\" {\n-                    cmd.arg(arg);\n-                }\n-            }\n-            continue;\n-        }\n-        if !retry_on_segfault || i > 3 {\n-            break\n-        }\n-        let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n-        let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n-        if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n-            break\n-        }\n-    }\n-\n-    match prog {\n-        Ok(prog) => {\n-            fn escape_string(s: &[u8]) -> String {\n-                str::from_utf8(s).map(|s| s.to_owned())\n-                    .unwrap_or_else(|_| {\n-                        let mut x = \"Non-UTF-8 output: \".to_string();\n-                        x.extend(s.iter()\n-                                  .flat_map(|&b| ascii::escape_default(b))\n-                                  .map(char::from));\n-                        x\n-                    })\n-            }\n-            if !prog.status.success() {\n-                let mut output = prog.stderr.clone();\n-                output.extend_from_slice(&prog.stdout);\n-                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n-                                         pname.display(),\n-                                         prog.status))\n-                    .note(&format!(\"{:?}\", &cmd))\n-                    .note(&escape_string(&output))\n-                    .emit();\n-                sess.abort_if_errors();\n-            }\n-        },\n-        Err(e) => {\n-            let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n-\n-            let mut linker_error = {\n-                if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n-                } else {\n-                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n-                }\n-            };\n-\n-            linker_error.note(&e.to_string());\n-\n-            if !linker_not_found {\n-                linker_error.note(&format!(\"{:?}\", &cmd));\n-            }\n-\n-            linker_error.emit();\n-\n-            if sess.target.target.options.is_like_msvc && linker_not_found {\n-                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n-                    but `link.exe` was not found\");\n-                sess.note_without_error(\"please ensure that VS 2013, VS 2015 or VS 2017 \\\n-                    was installed with the Visual C++ option\");\n-            }\n-            sess.abort_if_errors();\n-        }\n-    }\n-\n-\n-    // On macOS, debuggers need this utility to get run to do some munging of\n-    // the symbols. Note, though, that if the object files are being preserved\n-    // for their debug information there's no need for us to run dsymutil.\n-    if sess.target.target.options.is_like_osx &&\n-        sess.opts.debuginfo != DebugInfo::None\n-    {\n-        if let Err(e) = Command::new(\"dsymutil\").arg(out_filename).output() {\n-            sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n-        }\n-    }\n-}\n-\n-fn link_args(cmd: &mut dyn Linker,\n-             flavor: LinkerFlavor,\n-             sess: &Session,\n-             crate_type: config::CrateType,\n-             tmpdir: &Path,\n-             out_filename: &Path,\n-             codegen_results: &CodegenResults) {\n-\n-    // Linker plugins should be specified early in the list of arguments\n-    cmd.linker_plugin_lto();\n-\n-    // The default library location, we need this to find the runtime.\n-    // The location of crates will be determined as needed.\n-    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n-\n-    // target descriptor\n-    let t = &sess.target.target;\n-\n-    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        cmd.add_object(obj);\n-    }\n-    cmd.output_filename(out_filename);\n-\n-    if crate_type == config::CrateType::Executable &&\n-       sess.target.target.options.is_like_windows {\n-        if let Some(ref s) = codegen_results.windows_subsystem {\n-            cmd.subsystem(s);\n-        }\n-    }\n-\n-    // If we're building a dynamic library then some platforms need to make sure\n-    // that all symbols are exported correctly from the dynamic library.\n-    if crate_type != config::CrateType::Executable ||\n-       sess.target.target.options.is_like_emscripten {\n-        cmd.export_symbols(tmpdir, crate_type);\n-    }\n-\n-    // When linking a dynamic library, we put the metadata into a section of the\n-    // executable. This metadata is in a separate object file from the main\n-    // object file, so we link that in here.\n-    if crate_type == config::CrateType::Dylib ||\n-       crate_type == config::CrateType::ProcMacro {\n-        if let Some(obj) = codegen_results.metadata_module.object.as_ref() {\n-            cmd.add_object(obj);\n-        }\n-    }\n-\n-    let obj = codegen_results.allocator_module\n-        .as_ref()\n-        .and_then(|m| m.object.as_ref());\n-    if let Some(obj) = obj {\n-        cmd.add_object(obj);\n-    }\n-\n-    // Try to strip as much out of the generated object by removing unused\n-    // sections if possible. See more comments in linker.rs\n-    if !sess.opts.cg.link_dead_code {\n-        let keep_metadata = crate_type == config::CrateType::Dylib;\n-        cmd.gc_sections(keep_metadata);\n-    }\n-\n-    let used_link_args = &codegen_results.crate_info.link_args;\n-\n-    if crate_type == config::CrateType::Executable {\n-        let mut position_independent_executable = false;\n-\n-        if t.options.position_independent_executables {\n-            let empty_vec = Vec::new();\n-            let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n-            let more_args = &sess.opts.cg.link_arg;\n-            let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n-\n-            if !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n-                position_independent_executable = true;\n-            }\n-        }\n-\n-        if position_independent_executable {\n-            cmd.position_independent_executable();\n-        } else {\n-            // recent versions of gcc can be configured to generate position\n-            // independent executables by default. We have to pass -no-pie to\n-            // explicitly turn that off. Not applicable to ld.\n-            if sess.target.target.options.linker_is_gnu\n-                && flavor != LinkerFlavor::Ld {\n-                cmd.no_position_independent_executable();\n-            }\n-        }\n-    }\n-\n-    let relro_level = match sess.opts.debugging_opts.relro_level {\n-        Some(level) => level,\n-        None => t.options.relro_level,\n-    };\n-    match relro_level {\n-        RelroLevel::Full => {\n-            cmd.full_relro();\n-        },\n-        RelroLevel::Partial => {\n-            cmd.partial_relro();\n-        },\n-        RelroLevel::Off => {\n-            cmd.no_relro();\n-        },\n-        RelroLevel::None => {\n-        },\n-    }\n-\n-    // Pass optimization flags down to the linker.\n-    cmd.optimize();\n-\n-    // Pass debuginfo flags down to the linker.\n-    cmd.debuginfo();\n-\n-    // We want to, by default, prevent the compiler from accidentally leaking in\n-    // any system libraries, so we may explicitly ask linkers to not link to any\n-    // libraries by default. Note that this does not happen for windows because\n-    // windows pulls in some large number of libraries and I couldn't quite\n-    // figure out which subset we wanted.\n-    //\n-    // This is all naturally configurable via the standard methods as well.\n-    if !sess.opts.cg.default_linker_libraries.unwrap_or(false) &&\n-        t.options.no_default_libraries\n-    {\n-        cmd.no_default_libraries();\n-    }\n-\n-    // Take careful note of the ordering of the arguments we pass to the linker\n-    // here. Linkers will assume that things on the left depend on things to the\n-    // right. Things on the right cannot depend on things on the left. This is\n-    // all formally implemented in terms of resolving symbols (libs on the right\n-    // resolve unknown symbols of libs on the left, but not vice versa).\n-    //\n-    // For this reason, we have organized the arguments we pass to the linker as\n-    // such:\n-    //\n-    //  1. The local object that LLVM just generated\n-    //  2. Local native libraries\n-    //  3. Upstream rust libraries\n-    //  4. Upstream native libraries\n-    //\n-    // The rationale behind this ordering is that those items lower down in the\n-    // list can't depend on items higher up in the list. For example nothing can\n-    // depend on what we just generated (e.g., that'd be a circular dependency).\n-    // Upstream rust libraries are not allowed to depend on our local native\n-    // libraries as that would violate the structure of the DAG, in that\n-    // scenario they are required to link to them as well in a shared fashion.\n-    //\n-    // Note that upstream rust libraries may contain native dependencies as\n-    // well, but they also can't depend on what we just started to add to the\n-    // link line. And finally upstream native libraries can't depend on anything\n-    // in this DAG so far because they're only dylibs and dylibs can only depend\n-    // on other dylibs (e.g., other native deps).\n-    add_local_native_libraries(cmd, sess, codegen_results);\n-    add_upstream_rust_crates(cmd, sess, codegen_results, crate_type, tmpdir);\n-    add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n-\n-    // Tell the linker what we're doing.\n-    if crate_type != config::CrateType::Executable {\n-        cmd.build_dylib(out_filename);\n-    }\n-    if crate_type == config::CrateType::Executable && sess.crt_static() {\n-        cmd.build_static_executable();\n-    }\n-\n-    if sess.opts.debugging_opts.pgo_gen.enabled() {\n-        cmd.pgo_gen();\n-    }\n-\n-    // Finally add all the linker arguments provided on the command line along\n-    // with any #[link_args] attributes found inside the crate\n-    if let Some(ref args) = sess.opts.cg.link_args {\n-        cmd.args(args);\n-    }\n-    cmd.args(&sess.opts.cg.link_arg);\n-    cmd.args(&used_link_args);\n-}"}, {"sha": "a1205b079437e75ddd2abeea57e543c464af9c12", "filename": "src/link_copied.rs", "status": "removed", "additions": 0, "deletions": 336, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/964edb9a618528247637c0fed6cf174bd8fe5e50/src%2Flink_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964edb9a618528247637c0fed6cf174bd8fe5e50/src%2Flink_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flink_copied.rs?ref=964edb9a618528247637c0fed6cf174bd8fe5e50", "patch": "@@ -1,336 +0,0 @@\n-//! All functions here are copied from https://github.com/rust-lang/rust/blob/942864a000efd74b73e36bda5606b2cdb55ecf39/src/librustc_codegen_llvm/back/link.rs\n-\n-use std::path::Path;\n-\n-use rustc::middle::cstore::NativeLibraryKind;\n-use rustc::middle::dependency_format::Linkage;\n-use rustc::session::config::{self, OutputType, RUST_CGU_EXT};\n-use rustc::session::Session;\n-use rustc::util::common::time;\n-use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n-use rustc_codegen_ssa::back::linker::*;\n-use rustc_codegen_ssa::back::link::*;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-\n-use crate::prelude::*;\n-\n-use crate::archive::ArArchiveBuilder;\n-\n-// # Rust Crate linking\n-//\n-// Rust crates are not considered at all when creating an rlib output. All\n-// dependencies will be linked when producing the final output (instead of\n-// the intermediate rlib version)\n-pub fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n-                            sess: &Session,\n-                            codegen_results: &CodegenResults,\n-                            crate_type: config::CrateType,\n-                            tmpdir: &Path) {\n-    // All of the heavy lifting has previously been accomplished by the\n-    // dependency_format module of the compiler. This is just crawling the\n-    // output of that module, adding crates as necessary.\n-    //\n-    // Linking to a rlib involves just passing it to the linker (the linker\n-    // will slurp up the object files inside), and linking to a dynamic library\n-    // involves just passing the right -l flag.\n-\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n-\n-    // Invoke get_used_crates to ensure that we get a topological sorting of\n-    // crates.\n-    let deps = &codegen_results.crate_info.used_crates_dynamic;\n-\n-    // There's a few internal crates in the standard library (aka libcore and\n-    // libstd) which actually have a circular dependence upon one another. This\n-    // currently arises through \"weak lang items\" where libcore requires things\n-    // like `rust_begin_unwind` but libstd ends up defining it. To get this\n-    // circular dependence to work correctly in all situations we'll need to be\n-    // sure to correctly apply the `--start-group` and `--end-group` options to\n-    // GNU linkers, otherwise if we don't use any other symbol from the standard\n-    // library it'll get discarded and the whole application won't link.\n-    //\n-    // In this loop we're calculating the `group_end`, after which crate to\n-    // pass `--end-group` and `group_start`, before which crate to pass\n-    // `--start-group`. We currently do this by passing `--end-group` after\n-    // the first crate (when iterating backwards) that requires a lang item\n-    // defined somewhere else. Once that's set then when we've defined all the\n-    // necessary lang items we'll pass `--start-group`.\n-    //\n-    // Note that this isn't amazing logic for now but it should do the trick\n-    // for the current implementation of the standard library.\n-    let mut group_end = None;\n-    let mut group_start = None;\n-    let mut end_with = FxHashSet::default();\n-    let info = &codegen_results.crate_info;\n-    for &(cnum, _) in deps.iter().rev() {\n-        if let Some(missing) = info.missing_lang_items.get(&cnum) {\n-            end_with.extend(missing.iter().cloned());\n-            if end_with.len() > 0 && group_end.is_none() {\n-                group_end = Some(cnum);\n-            }\n-        }\n-        end_with.retain(|item| info.lang_item_to_crate.get(item) != Some(&cnum));\n-        if end_with.len() == 0 && group_end.is_some() {\n-            group_start = Some(cnum);\n-            break\n-        }\n-    }\n-\n-    // If we didn't end up filling in all lang items from upstream crates then\n-    // we'll be filling it in with our crate. This probably means we're the\n-    // standard library itself, so skip this for now.\n-    if group_end.is_some() && group_start.is_none() {\n-        group_end = None;\n-    }\n-\n-    let mut compiler_builtins = None;\n-\n-    for &(cnum, _) in deps.iter() {\n-        if group_start == Some(cnum) {\n-            cmd.group_start();\n-        }\n-\n-        // We may not pass all crates through to the linker. Some crates may\n-        // appear statically in an existing dylib, meaning we'll pick up all the\n-        // symbols from the dylib.\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        match data[cnum.as_usize() - 1] {\n-            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-            }\n-            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n-                link_sanitizer_runtime(cmd, sess, codegen_results, tmpdir, cnum);\n-            }\n-            // compiler-builtins are always placed last to ensure that they're\n-            // linked correctly.\n-            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n-                assert!(compiler_builtins.is_none());\n-                compiler_builtins = Some(cnum);\n-            }\n-            Linkage::NotLinked |\n-            Linkage::IncludedFromDylib => {}\n-            Linkage::Static => {\n-                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-            }\n-            Linkage::Dynamic => {\n-                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n-            }\n-        }\n-\n-        if group_end == Some(cnum) {\n-            cmd.group_end();\n-        }\n-    }\n-\n-    // compiler-builtins are always placed last to ensure that they're\n-    // linked correctly.\n-    // We must always link the `compiler_builtins` crate statically. Even if it\n-    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n-    // is used)\n-    if let Some(cnum) = compiler_builtins {\n-        add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-    }\n-\n-    // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(config: &config::Config, stem: &'a str) -> &'a str {\n-        if stem.starts_with(\"lib\") && !config.target.options.is_like_windows {\n-            &stem[3..]\n-        } else {\n-            stem\n-        }\n-    }\n-\n-    // We must link the sanitizer runtime using -Wl,--whole-archive but since\n-    // it's packed in a .rlib, it contains stuff that are not objects that will\n-    // make the linker error. So we must remove those bits from the .rlib before\n-    // linking it.\n-    fn link_sanitizer_runtime(cmd: &mut dyn Linker,\n-                              sess: &Session,\n-                              codegen_results: &CodegenResults,\n-                              tmpdir: &Path,\n-                              cnum: CrateNum) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        if sess.target.target.options.is_like_osx {\n-            // On Apple platforms, the sanitizer is always built as a dylib, and\n-            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n-            // rpath to the library as well (the rpath should be absolute, see\n-            // PR #41352 for details).\n-            //\n-            // FIXME: Remove this logic into librustc_*san once Cargo supports it\n-            let rpath = cratepath.parent().unwrap();\n-            let rpath = rpath.to_str().expect(\"non-utf8 component in path\");\n-            cmd.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let mut archive = ArArchiveBuilder::new(sess, &dst, Some(cratepath));\n-        archive.update_symbols();\n-\n-        for f in archive.src_files() {\n-            if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n-                archive.remove_file(&f);\n-            }\n-        }\n-\n-        archive.build();\n-\n-        cmd.link_whole_rlib(&dst);\n-    }\n-\n-    // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO and\n-    // dynamic libraries. Specifically:\n-    //\n-    // * For LTO, we remove upstream object files.\n-    // * For dylibs we remove metadata and bytecode from upstream rlibs\n-    //\n-    // When performing LTO, almost(*) all of the bytecode from the upstream\n-    // libraries has already been included in our object file output. As a\n-    // result we need to remove the object files in the upstream libraries so\n-    // the linker doesn't try to include them twice (or whine about duplicate\n-    // symbols). We must continue to include the rest of the rlib, however, as\n-    // it may contain static native libraries which must be linked in.\n-    //\n-    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n-    // their bytecode wasn't included. The object files in those libraries must\n-    // still be passed to the linker.\n-    //\n-    // When making a dynamic library, linkers by default don't include any\n-    // object files in an archive if they're not necessary to resolve the link.\n-    // We basically want to convert the archive (rlib) to a dylib, though, so we\n-    // *do* want everything included in the output, regardless of whether the\n-    // linker thinks it's needed or not. As a result we must use the\n-    // --whole-archive option (or the platform equivalent). When using this\n-    // option the linker will fail if there are non-objects in the archive (such\n-    // as our own metadata and/or bytecode). All in all, for rlibs to be\n-    // entirely included in dylibs, we need to remove all non-object files.\n-    //\n-    // Note, however, that if we're not doing LTO or we're not producing a dylib\n-    // (aka we're making an executable), we can just pass the rlib blindly to\n-    // the linker (fast) because it's fine if it's not actually included as\n-    // we're at the end of the dependency chain.\n-    fn add_static_crate(cmd: &mut dyn Linker,\n-                        sess: &Session,\n-                        codegen_results: &CodegenResults,\n-                        tmpdir: &Path,\n-                        crate_type: config::CrateType,\n-                        cnum: CrateNum) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        // See the comment above in `link_staticlib` and `link_rlib` for why if\n-        // there's a static library that's not relevant we skip all object\n-        // files.\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-        let skip_native = native_libs.iter().any(|lib| {\n-            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n-        });\n-\n-        if (!are_upstream_rust_objects_already_included(sess) ||\n-            ignored_for_lto(sess, &codegen_results.crate_info, cnum)) &&\n-           crate_type != config::CrateType::Dylib &&\n-           !skip_native {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n-            return\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let name = cratepath.file_name().unwrap().to_str().unwrap();\n-        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-\n-        time(sess, &format!(\"altering {}.rlib\", name), || {\n-            let mut archive = ArArchiveBuilder::new(sess, &dst, Some(cratepath));\n-            archive.update_symbols();\n-\n-            let mut any_objects = false;\n-            for f in archive.src_files() {\n-                if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n-                    archive.remove_file(&f);\n-                    continue\n-                }\n-\n-                let canonical = f.replace(\"-\", \"_\");\n-                let canonical_name = name.replace(\"-\", \"_\");\n-\n-                // Look for `.rcgu.o` at the end of the filename to conclude\n-                // that this is a Rust-related object file.\n-                fn looks_like_rust(s: &str) -> bool {\n-                    let path = Path::new(s);\n-                    let ext = path.extension().and_then(|s| s.to_str());\n-                    if ext != Some(OutputType::Object.extension()) {\n-                        return false\n-                    }\n-                    let ext2 = path.file_stem()\n-                        .and_then(|s| Path::new(s).extension())\n-                        .and_then(|s| s.to_str());\n-                    ext2 == Some(RUST_CGU_EXT)\n-                }\n-\n-                let is_rust_object =\n-                    canonical.starts_with(&canonical_name) &&\n-                    looks_like_rust(&f);\n-\n-                // If we've been requested to skip all native object files\n-                // (those not generated by the rust compiler) then we can skip\n-                // this file. See above for why we may want to do this.\n-                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n-\n-                // If we're performing LTO and this is a rust-generated object\n-                // file, then we don't need the object file as it's part of the\n-                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                // though, so we let that object file slide.\n-                let skip_because_lto = are_upstream_rust_objects_already_included(sess) &&\n-                    is_rust_object &&\n-                    (sess.target.target.options.no_builtins ||\n-                     !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n-\n-                if skip_because_cfg_say_so || skip_because_lto {\n-                    archive.remove_file(&f);\n-                } else {\n-                    any_objects = true;\n-                }\n-            }\n-\n-            if !any_objects {\n-                return\n-            }\n-            archive.build();\n-\n-            // If we're creating a dylib, then we need to include the\n-            // whole of each object in our archive into that artifact. This is\n-            // because a `dylib` can be reused as an intermediate artifact.\n-            //\n-            // Note, though, that we don't want to include the whole of a\n-            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n-            // repeatedly linked anyway.\n-            if crate_type == config::CrateType::Dylib &&\n-                codegen_results.crate_info.compiler_builtins != Some(cnum) {\n-                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            } else {\n-                cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            }\n-        });\n-    }\n-\n-    // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n-        // If we're performing LTO, then it should have been previously required\n-        // that all upstream rust dependencies were available in an rlib format.\n-        assert!(!are_upstream_rust_objects_already_included(sess));\n-\n-        // Just need to tell the linker about where the library lives and\n-        // what its name is\n-        let parent = cratepath.parent();\n-        if let Some(dir) = parent {\n-            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n-        }\n-        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_rust_dylib(&unlib(&sess.target, filestem),\n-                            parent.unwrap_or(Path::new(\"\")));\n-    }\n-}"}]}