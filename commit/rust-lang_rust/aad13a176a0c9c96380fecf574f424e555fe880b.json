{"sha": "aad13a176a0c9c96380fecf574f424e555fe880b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZDEzYTE3NmEwYzljOTYzODBmZWNmNTc0ZjQyNGU1NTVmZTg4MGI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-26T12:13:12Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-26T12:13:12Z"}, "message": "centralize Scalar size sanity checks and also do them in release builds", "tree": {"sha": "2decdde3adb5bc04e400eb43358aa624be0c2e65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2decdde3adb5bc04e400eb43358aa624be0c2e65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aad13a176a0c9c96380fecf574f424e555fe880b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aad13a176a0c9c96380fecf574f424e555fe880b", "html_url": "https://github.com/rust-lang/rust/commit/aad13a176a0c9c96380fecf574f424e555fe880b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aad13a176a0c9c96380fecf574f424e555fe880b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3defb3f18fdd6d2bd74b3de7a2d932133c99303b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3defb3f18fdd6d2bd74b3de7a2d932133c99303b", "html_url": "https://github.com/rust-lang/rust/commit/3defb3f18fdd6d2bd74b3de7a2d932133c99303b"}], "stats": {"total": 133, "additions": 54, "deletions": 79}, "files": [{"sha": "56173dfe304fc5c36bd01df95ab13308568bf155", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=aad13a176a0c9c96380fecf574f424e555fe880b", "patch": "@@ -2,7 +2,6 @@\n \n use super::{\n     Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n-    truncate,\n };\n \n use crate::ty::layout::{Size, Align};\n@@ -382,18 +381,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n         };\n \n-        let bytes = match val {\n-            Scalar::Ptr(val) => {\n-                assert_eq!(type_size, cx.data_layout().pointer_size);\n-                val.offset.bytes() as u128\n-            }\n-\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, type_size.bytes());\n-                debug_assert_eq!(truncate(data, Size::from_bytes(size.into())), data,\n-                    \"Unexpected value of size {} when writing to memory\", size);\n-                data\n-            },\n+        let bytes = match val.to_bits_or_ptr(type_size, cx) {\n+            Err(val) => val.offset.bytes() as u128,\n+            Ok(data) => data,\n         };\n \n         let endian = cx.data_layout().endian;"}, {"sha": "3aed90c70adf7de7757b401ae9d394274fcf9240", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=aad13a176a0c9c96380fecf574f424e555fe880b", "patch": "@@ -232,7 +232,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n-    /// Returns this pointers offset from the allocation base, or from NULL (for\n+    /// Returns this pointer's offset from the allocation base, or from NULL (for\n     /// integer pointers).\n     #[inline]\n     pub fn get_ptr_offset(self, cx: &impl HasDataLayout) -> Size {\n@@ -269,7 +269,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn from_uint(i: impl Into<u128>, size: Size) -> Self {\n         let i = i.into();\n-        debug_assert_eq!(truncate(i, size), i,\n+        assert_eq!(truncate(i, size), i,\n                          \"Unsigned value {} does not fit in {} bits\", i, size.bits());\n         Scalar::Raw { data: i, size: size.bytes() as u8 }\n     }\n@@ -279,7 +279,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         let i = i.into();\n         // `into` performed sign extension, we have to truncate\n         let truncated = truncate(i as u128, size);\n-        debug_assert_eq!(sign_extend(truncated, size) as i128, i,\n+        assert_eq!(sign_extend(truncated, size) as i128, i,\n                          \"Signed value {} does not fit in {} bits\", i, size.bits());\n         Scalar::Raw { data: truncated, size: size.bytes() as u8 }\n     }\n@@ -294,12 +294,35 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Raw { data: f.to_bits() as u128, size: 8 }\n     }\n \n+    #[inline]\n+    pub fn to_bits_or_ptr(\n+        self,\n+        target_size: Size,\n+        cx: &impl HasDataLayout,\n+    ) -> Result<u128, Pointer<Tag>> {\n+        match self {\n+            Scalar::Raw { data, size } => {\n+                assert_eq!(target_size.bytes(), size as u64);\n+                assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n+                assert_eq!(truncate(data, target_size), data,\n+                            \"Scalar value {:#x} exceeds size of {} bytes\", data, size);\n+                Ok(data)\n+            }\n+            Scalar::Ptr(ptr) => {\n+                assert_eq!(target_size, cx.data_layout().pointer_size);\n+                Err(ptr)\n+            }\n+        }\n+    }\n+\n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n             Scalar::Raw { data, size } => {\n                 assert_eq!(target_size.bytes(), size as u64);\n                 assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n+                assert_eq!(truncate(data, target_size), data,\n+                            \"Scalar value {:#x} exceeds size of {} bytes\", data, size);\n                 Ok(data)\n             }\n             Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n@@ -350,58 +373,51 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn to_u8(self) -> EvalResult<'static, u8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u8 as u128, b);\n         Ok(b as u8)\n     }\n \n     pub fn to_u32(self) -> EvalResult<'static, u32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u32 as u128, b);\n         Ok(b as u32)\n     }\n \n     pub fn to_u64(self) -> EvalResult<'static, u64> {\n         let sz = Size::from_bits(64);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n     }\n \n     pub fn to_usize(self, cx: &impl HasDataLayout) -> EvalResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n     }\n \n     pub fn to_i8(self) -> EvalResult<'static, i8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i8 as i128, b);\n         Ok(b as i8)\n     }\n \n     pub fn to_i32(self) -> EvalResult<'static, i32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i32 as i128, b);\n         Ok(b as i32)\n     }\n \n     pub fn to_i64(self) -> EvalResult<'static, i64> {\n         let sz = Size::from_bits(64);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i64 as i128, b);\n         Ok(b as i64)\n     }\n \n     pub fn to_isize(self, cx: &impl HasDataLayout) -> EvalResult<'static, i64> {\n-        let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n-        assert_eq!(b as i64 as i128, b);\n+        let sz = cx.data_layout().pointer_size;\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n         Ok(b as i64)\n     }\n "}, {"sha": "bf81b7f0da5258fee7c8bff4374072bb0ce4ff63", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=aad13a176a0c9c96380fecf574f424e555fe880b", "patch": "@@ -443,7 +443,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n         ct: &'tcx ty::Const<'tcx>,\n     ) -> Result<Self::Const, Self::Error> {\n         // only print integers\n-        if let ConstValue::Scalar(Scalar::Bits { .. }) = ct.val {\n+        if let ConstValue::Scalar(Scalar::Raw { .. }) = ct.val {\n             if ct.ty.is_integral() {\n                 return self.pretty_print_const(ct);\n             }"}, {"sha": "69df36348a69e6ffbe47801b1d71cabda1f14a0f", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=aad13a176a0c9c96380fecf574f424e555fe880b", "patch": "@@ -101,6 +101,5 @@ fn parse_float<'tcx>(\n         }\n     };\n \n-    // We trust that `data` is properly truncated.\n-    Ok(ConstValue::Scalar(Scalar::Raw { data, size }))\n+    Ok(ConstValue::Scalar(Scalar::from_uint(data, Size::from_bytes(size))))\n }"}, {"sha": "76b11ac2fe6463a4515782d743e1a2b30dc018ee", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=aad13a176a0c9c96380fecf574f424e555fe880b", "patch": "@@ -6,7 +6,7 @@ use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n-    Scalar, EvalResult, Pointer, PointerArithmetic, InterpError, truncate\n+    Scalar, EvalResult, Pointer, PointerArithmetic, InterpError,\n };\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n@@ -135,29 +135,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n-        match val {\n-            Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n-            Scalar::Raw { data, size } => {\n-                debug_assert_eq!(size as u64, src_layout.size.bytes());\n-                debug_assert_eq!(truncate(data, Size::from_bytes(size.into())), data,\n-                    \"Unexpected value of size {} before casting\", size);\n-\n-                let res = match src_layout.ty.sty {\n-                    Float(fty) => self.cast_from_float(data, fty, dest_layout.ty)?,\n-                    _ => self.cast_from_int(data, src_layout, dest_layout)?,\n-                };\n-\n-                // Sanity check\n-                match res {\n-                    Scalar::Ptr(_) => bug!(\"Fabricated a ptr value from an int...?\"),\n-                    Scalar::Raw { data, size } => {\n-                        debug_assert_eq!(size as u64, dest_layout.size.bytes());\n-                        debug_assert_eq!(truncate(data, Size::from_bytes(size.into())), data,\n-                            \"Unexpected value of size {} after casting\", size);\n-                    }\n+        match val.to_bits_or_ptr(src_layout.size, self) {\n+            Err(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n+            Ok(data) => {\n+                match src_layout.ty.sty {\n+                    Float(fty) => self.cast_from_float(data, fty, dest_layout.ty),\n+                    _ => self.cast_from_int(data, src_layout, dest_layout),\n                 }\n-                // Done\n-                Ok(res)\n             }\n         }\n     }\n@@ -177,7 +161,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n         use rustc::ty::TyKind::*;\n         match dest_layout.ty.sty {\n-            Int(_) | Uint(_) => {\n+            Int(_) | Uint(_) | RawPtr(_) => {\n                 let v = self.truncate(v, dest_layout);\n                 Ok(Scalar::from_uint(v, dest_layout.size))\n             }\n@@ -205,15 +189,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 Ok(Scalar::from_uint(v, Size::from_bytes(4)))\n             },\n \n-            // No alignment check needed for raw pointers.\n-            // But we have to truncate to target ptr size.\n-            RawPtr(_) => {\n-                Ok(Scalar::from_uint(\n-                    self.truncate_to_ptr(v).0,\n-                    self.pointer_size(),\n-                ))\n-            },\n-\n             // Casts to bool are not permitted by rustc, no need to handle them here.\n             _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }"}, {"sha": "e3a843993abba03add8ef7ce071e031dc374c51d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=aad13a176a0c9c96380fecf574f424e555fe880b", "patch": "@@ -247,16 +247,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         required_align: Align\n     ) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n-        let (offset, alloc_align) = match ptr {\n-            Scalar::Ptr(ptr) => {\n+        let (offset, alloc_align) = match ptr.to_bits_or_ptr(self.pointer_size(), self) {\n+            Err(ptr) => {\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n                 let align = self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead)?;\n                 (ptr.offset.bytes(), align)\n             }\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, self.pointer_size().bytes());\n-                assert!(data < (1u128 << self.pointer_size().bits()));\n+            Ok(data) => {\n                 // check this is not NULL\n                 if data == 0 {\n                     return err!(InvalidNullPointerUsage);"}, {"sha": "3e3c92344092f38b2e794d5fc779e2d81c73bbe9", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=aad13a176a0c9c96380fecf574f424e555fe880b", "patch": "@@ -639,18 +639,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             } => {\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;\n-                match raw_discr {\n-                    ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n+                let raw_discr = raw_discr.not_undef()\n+                    .map_err(|_| InterpError::InvalidDiscriminant(ScalarMaybeUndef::Undef))?;\n+                match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n+                    Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok();\n                         if !ptr_valid {\n-                            return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n+                            return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n-                    ScalarMaybeUndef::Scalar(Scalar::Raw { data: raw_discr, size }) => {\n-                        assert_eq!(size as u64, discr_val.layout.size.bytes());\n+                    Ok(raw_discr) => {\n                         let adjusted_discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n                         if variants_start <= adjusted_discr && adjusted_discr <= variants_end {\n@@ -665,8 +666,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                             (dataful_variant.as_u32() as u128, dataful_variant)\n                         }\n                     },\n-                    ScalarMaybeUndef::Undef =>\n-                        return err!(InvalidDiscriminant(ScalarMaybeUndef::Undef)),\n                 }\n             }\n         })"}, {"sha": "d88d0af75fb75628de3c7d3bc7343f16685885bd", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad13a176a0c9c96380fecf574f424e555fe880b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=aad13a176a0c9c96380fecf574f424e555fe880b", "patch": "@@ -480,8 +480,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 wrapping_range_format(&layout.valid_range, max_hi),\n             )\n         );\n-        let bits = match value {\n-            Scalar::Ptr(ptr) => {\n+        let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n+            Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n                     // only NULL is not allowed.\n                     // We can call `check_align` to check non-NULL-ness, but have to also look\n@@ -509,10 +509,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     );\n                 }\n             }\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, op.layout.size.bytes());\n+            Ok(data) =>\n                 data\n-            }\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n         if wrapping_range_contains(&layout.valid_range, bits) {"}]}