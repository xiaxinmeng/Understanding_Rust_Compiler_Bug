{"sha": "193574ae1e3881f95afb8b3e385a9e410ac6798a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MzU3NGFlMWUzODgxZjk1YWZiOGIzZTM4NWE5ZTQxMGFjNjc5OGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-05T01:56:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-05T01:56:48Z"}, "message": "auto merge of #14529 : brson/rust/ptr, r=brson\n\nThis time we're not promoting anything directly to 'stable', but instead promoting functions we're happy with to 'unstable'. They'll become stable in another pass later.\r\n\r\n* null and mut_null are unstable. Their names may change if the unsafe\r\n  pointer types change.\r\n* copy_memory and copy_overlapping_memory are unstable. We think they\r\n  aren't going to change.\r\n* set_memory and zero_memory are experimental. Both the names and\r\n  the semantics are under question.\r\n* swap and replace are unstable and probably won't change.\r\n* read is unstable, probably won't change\r\n* read_and_zero is experimental. It's necessity is in doubt.\r\n* mem::overwrite is now called ptr::write to match read and is\r\n  unstable. mem::overwrite is now deprecated\r\n* array_each, array_each_with_len, buf_len, and position are\r\n  all deprecated because they use old style iteration and their\r\n  utility is generally under question.\r\n\r\nNote that `mem::overwrite`, which was just declared stable last week, is deprecated now in favor of `ptr::write`. Woo!", "tree": {"sha": "169d7f666b23207484a732ff533715b2ca16535e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/169d7f666b23207484a732ff533715b2ca16535e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/193574ae1e3881f95afb8b3e385a9e410ac6798a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/193574ae1e3881f95afb8b3e385a9e410ac6798a", "html_url": "https://github.com/rust-lang/rust/commit/193574ae1e3881f95afb8b3e385a9e410ac6798a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/193574ae1e3881f95afb8b3e385a9e410ac6798a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa09561bb606bb622136ac9ad3702ab1179db5b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa09561bb606bb622136ac9ad3702ab1179db5b2", "html_url": "https://github.com/rust-lang/rust/commit/aa09561bb606bb622136ac9ad3702ab1179db5b2"}, {"sha": "9b228f8424d207fc412bf549d3d9dc8262415f27", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b228f8424d207fc412bf549d3d9dc8262415f27", "html_url": "https://github.com/rust-lang/rust/commit/9b228f8424d207fc412bf549d3d9dc8262415f27"}], "stats": {"total": 128, "additions": 80, "deletions": 48}, "files": [{"sha": "e0a48682963b48bc839547c1ec600632f51e2e09", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=193574ae1e3881f95afb8b3e385a9e410ac6798a", "patch": "@@ -213,14 +213,14 @@ pub struct Unique<T> {\n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n-            let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n+            let ptr = malloc(mem::size_of::<T>() as size_t) as *mut T;\n             // we *need* valid pointer.\n             assert!(!ptr.is_null());\n             // `*ptr` is uninitialized, and `*ptr = value` would\n             // attempt to destroy it `overwrite` moves a value into\n             // this memory without attempting to drop the original\n             // value.\n-            mem::overwrite(&mut *ptr, value);\n+            ptr::write(&mut *ptr, value);\n             Unique{ptr: ptr}\n         }\n     }"}, {"sha": "871f8197c9a28fa7b72fad471dc79bfcd39f157e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=193574ae1e3881f95afb8b3e385a9e410ac6798a", "patch": "@@ -36,7 +36,7 @@ use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n use std::mem;\n use std::num;\n-use std::ptr::read;\n+use std::ptr;\n use std::rc::Rc;\n use std::rt::heap::allocate;\n \n@@ -209,7 +209,7 @@ impl Arena {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n                                             mem::min_align_of::<T>());\n             let ptr = ptr as *mut T;\n-            mem::overwrite(&mut (*ptr), op());\n+            ptr::write(&mut (*ptr), op());\n             return &*ptr;\n         }\n     }\n@@ -262,7 +262,7 @@ impl Arena {\n             // has *not* been initialized yet.\n             *ty_ptr = mem::transmute(tydesc);\n             // Actually initialize it\n-            mem::overwrite(&mut(*ptr), op());\n+            ptr::write(&mut(*ptr), op());\n             // Now that we are done, update the tydesc to indicate that\n             // the object is there.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n@@ -360,7 +360,7 @@ impl<T> TypedArenaChunk<T> {\n         let mut chunk = unsafe {\n             let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>());\n             let mut chunk: Box<TypedArenaChunk<T>> = mem::transmute(chunk);\n-            mem::overwrite(&mut chunk.next, next);\n+            ptr::write(&mut chunk.next, next);\n             chunk\n         };\n \n@@ -376,7 +376,7 @@ impl<T> TypedArenaChunk<T> {\n         if intrinsics::needs_drop::<T>() {\n             let mut start = self.start();\n             for _ in range(0, len) {\n-                read(start as *T); // run the destructor on the pointer\n+                ptr::read(start as *T); // run the destructor on the pointer\n                 start = start.offset(mem::size_of::<T>() as int)\n             }\n         }\n@@ -442,7 +442,7 @@ impl<T> TypedArena<T> {\n             }\n \n             let ptr: &'a mut T = mem::transmute(this.ptr);\n-            mem::overwrite(ptr, object);\n+            ptr::write(ptr, object);\n             this.ptr = this.ptr.offset(1);\n             let ptr: &'a T = ptr;\n             ptr"}, {"sha": "d73c07ee17d0bb82f2c8147e894cbc341fd44c04", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=193574ae1e3881f95afb8b3e385a9e410ac6798a", "patch": "@@ -13,7 +13,8 @@\n #![allow(missing_doc)]\n \n use std::clone::Clone;\n-use std::mem::{overwrite, zeroed, replace, swap};\n+use std::mem::{zeroed, replace, swap};\n+use std::ptr;\n use std::slice;\n \n /// A priority queue implemented with a binary heap\n@@ -163,13 +164,13 @@ impl<T: Ord> PriorityQueue<T> {\n                 let parent = (pos - 1) >> 1;\n                 if new > *self.data.get(parent) {\n                     let x = replace(self.data.get_mut(parent), zeroed());\n-                    overwrite(self.data.get_mut(pos), x);\n+                    ptr::write(self.data.get_mut(pos), x);\n                     pos = parent;\n                     continue\n                 }\n                 break\n             }\n-            overwrite(self.data.get_mut(pos), new);\n+            ptr::write(self.data.get_mut(pos), new);\n         }\n     }\n \n@@ -185,12 +186,12 @@ impl<T: Ord> PriorityQueue<T> {\n                     child = right;\n                 }\n                 let x = replace(self.data.get_mut(child), zeroed());\n-                overwrite(self.data.get_mut(pos), x);\n+                ptr::write(self.data.get_mut(pos), x);\n                 pos = child;\n                 child = 2 * pos + 1;\n             }\n \n-            overwrite(self.data.get_mut(pos), new);\n+            ptr::write(self.data.get_mut(pos), new);\n             self.siftup(start, pos);\n         }\n     }"}, {"sha": "8933c95350d593928ab112e2d24bd5f3c4bd5ce6", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=193574ae1e3881f95afb8b3e385a9e410ac6798a", "patch": "@@ -155,16 +155,16 @@ pub unsafe fn uninit<T>() -> T {\n /// contained at the location `dst`. This could leak allocations or resources,\n /// so care must be taken to previously deallocate the value at `dst`.\n #[inline]\n-#[stable]\n+#[deprecated = \"use ptr::write\"]\n pub unsafe fn overwrite<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n /// Deprecated, use `overwrite` instead\n #[inline]\n-#[deprecated = \"this function has been renamed to `overwrite`\"]\n+#[deprecated = \"use ptr::write\"]\n pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n-    overwrite(dst, src)\n+    ptr::write(dst, src)\n }\n \n /// Convert an u16 to little endian from the target's endianness."}, {"sha": "b2776b78b1ce3bdcc5f62664f54cca133716dab0", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=193574ae1e3881f95afb8b3e385a9e410ac6798a", "patch": "@@ -95,36 +95,6 @@ use option::{Some, None, Option};\n \n #[cfg(not(test))] use cmp::{PartialEq, Eq, PartialOrd, Equiv};\n \n-/// Return the offset of the first null pointer in `buf`.\n-#[inline]\n-pub unsafe fn buf_len<T>(buf: **T) -> uint {\n-    position(buf, |i| *i == null())\n-}\n-\n-impl<T> Clone for *T {\n-    #[inline]\n-    fn clone(&self) -> *T {\n-        *self\n-    }\n-}\n-\n-impl<T> Clone for *mut T {\n-    #[inline]\n-    fn clone(&self) -> *mut T {\n-        *self\n-    }\n-}\n-\n-/// Return the first offset `i` such that `f(buf[i]) == true`.\n-#[inline]\n-pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n-    let mut i = 0;\n-    loop {\n-        if f(&(*buf.offset(i as int))) { return i; }\n-        else { i += 1; }\n-    }\n-}\n-\n /// Create a null pointer.\n ///\n /// # Example\n@@ -136,6 +106,7 @@ pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n /// assert!(p.is_null());\n /// ```\n #[inline]\n+#[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn null<T>() -> *T { 0 as *T }\n \n /// Create an unsafe mutable null pointer.\n@@ -149,6 +120,7 @@ pub fn null<T>() -> *T { 0 as *T }\n /// assert!(p.is_null());\n /// ```\n #[inline]\n+#[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n /// Copies data from one location to another.\n@@ -174,6 +146,7 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n /// ```\n ///\n #[inline]\n+#[unstable]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n     intrinsics::copy_memory(dst, src, count)\n }\n@@ -215,6 +188,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n /// If the source and destination overlap then the behavior of this\n /// function is undefined.\n #[inline]\n+#[unstable]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n                                             src: *T,\n                                             count: uint) {\n@@ -224,19 +198,23 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n /// bytes of memory starting at `dst` to `c`.\n #[inline]\n+#[experimental = \"uncertain about naming and semantics\"]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     intrinsics::set_memory(dst, c, count)\n }\n \n /// Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n #[inline]\n+#[experimental = \"uncertain about naming and semantics\"]\n+#[allow(experimental)]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n \n /// Swap the values at two mutable locations of the same type, without\n /// deinitialising either. They may overlap.\n #[inline]\n+#[unstable]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninitialized();\n@@ -255,13 +233,15 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// Replace the value at a mutable location with a new one, returning the old\n /// value, without deinitialising either.\n #[inline]\n+#[unstable]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n }\n \n /// Reads the value from `*src` and returns it.\n #[inline(always)]\n+#[unstable]\n pub unsafe fn read<T>(src: *T) -> T {\n     let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n@@ -271,6 +251,8 @@ pub unsafe fn read<T>(src: *T) -> T {\n /// Reads the value from `*src` and nulls it out.\n /// This currently prevents destructors from executing.\n #[inline(always)]\n+#[experimental]\n+#[allow(experimental)]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n     let tmp = read(&*dest);\n@@ -281,9 +263,22 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n+/// Unsafely overwrite a memory location with the given value without destroying\n+/// the old value.\n+///\n+/// This operation is unsafe because it does not destroy the previous value\n+/// contained at the location `dst`. This could leak allocations or resources,\n+/// so care must be taken to previously deallocate the value at `dst`.\n+#[inline]\n+#[unstable]\n+pub unsafe fn write<T>(dst: *mut T, src: T) {\n+    intrinsics::move_val_init(&mut *dst, src)\n+}\n+\n /// Given a **T (pointer to an array of pointers),\n /// iterate through each *T, up to the provided `len`,\n /// passing to the provided callback function\n+#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     if arr.is_null() {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n@@ -303,6 +298,8 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n ///\n /// This will only work with a null-terminated\n /// pointer array.\n+#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n+#[allow(deprecated)]\n pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n     if arr.is_null()  {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n@@ -311,6 +308,25 @@ pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n     array_each_with_len(arr, len, cb);\n }\n \n+/// Return the offset of the first null pointer in `buf`.\n+#[inline]\n+#[deprecated = \"use a loop and RawPtr::offset\"]\n+#[allow(deprecated)]\n+pub unsafe fn buf_len<T>(buf: **T) -> uint {\n+    position(buf, |i| *i == null())\n+}\n+\n+/// Return the first offset `i` such that `f(buf[i]) == true`.\n+#[inline]\n+#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n+pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n+    let mut i = 0;\n+    loop {\n+        if f(&(*buf.offset(i as int))) { return i; }\n+        else { i += 1; }\n+    }\n+}\n+\n /// Methods on raw pointers\n pub trait RawPtr<T> {\n     /// Returns the null pointer.\n@@ -426,6 +442,20 @@ impl<T> Equiv<*T> for *mut T {\n     }\n }\n \n+impl<T> Clone for *T {\n+    #[inline]\n+    fn clone(&self) -> *T {\n+        *self\n+    }\n+}\n+\n+impl<T> Clone for *mut T {\n+    #[inline]\n+    fn clone(&self) -> *mut T {\n+        *self\n+    }\n+}\n+\n // Equality for extern \"C\" fn pointers\n #[cfg(not(test))]\n mod externfnpointers {"}, {"sha": "2c6f2978aa735727b4beb6a4d271ba4a3ce832b2", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=193574ae1e3881f95afb8b3e385a9e410ac6798a", "patch": "@@ -77,7 +77,7 @@ impl<A: Clone> Clone for ~[A] {\n             try_finally(\n                 &mut i, (),\n                 |i, ()| while *i < len {\n-                    mem::overwrite(\n+                    ptr::write(\n                         &mut(*p.offset(*i as int)),\n                         self.unsafe_ref(*i).clone());\n                     *i += 1;"}, {"sha": "6312d9115effbc85a9863da63039ad77bb9c05b3", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193574ae1e3881f95afb8b3e385a9e410ac6798a/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=193574ae1e3881f95afb8b3e385a9e410ac6798a", "patch": "@@ -1093,7 +1093,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     #[inline]\n     unsafe fn init_elem(self, i: uint, val: T) {\n-        mem::overwrite(&mut (*self.as_mut_ptr().offset(i as int)), val);\n+        ptr::write(&mut (*self.as_mut_ptr().offset(i as int)), val);\n     }\n \n     #[inline]\n@@ -1218,6 +1218,7 @@ pub mod bytes {\n \n     impl<'a> MutableByteVector for &'a mut [u8] {\n         #[inline]\n+        #[allow(experimental)]\n         fn set_memory(self, value: u8) {\n             unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n         }"}]}