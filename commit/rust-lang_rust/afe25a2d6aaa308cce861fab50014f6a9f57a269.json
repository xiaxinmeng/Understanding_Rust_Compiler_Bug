{"sha": "afe25a2d6aaa308cce861fab50014f6a9f57a269", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZTI1YTJkNmFhYTMwOGNjZTg2MWZhYjUwMDE0ZjZhOWY1N2EyNjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-09T03:41:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-09T03:41:22Z"}, "message": "Auto merge of #26515 - quantheory:check_enum_recursion, r=nrc\n\nFixes #23302.\r\n\r\nNote that there's an odd situation regarding the following, most likely due to some inadequacy in `const_eval`:\r\n\r\n```rust\r\nenum Y {\r\n    A = 1usize,\r\n    B,\r\n}\r\n```\r\n\r\nIn this case, `Y::B as usize` might be considered a constant expression in some cases, but not others.  (See #23513, for a related problem where there is only one variant, with no discriminant, and it doesn't behave nicely as a constant expression either.)\r\n\r\nMost of the complexity in this PR is basically future-proofing, to ensure that when `Y::B as usize` is fully made to be a constant expression, it can't be used to set `Y::A`, and thus indirectly itself.", "tree": {"sha": "b5dd91309e3ed292722faa5e4ea8295cd0df293e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5dd91309e3ed292722faa5e4ea8295cd0df293e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afe25a2d6aaa308cce861fab50014f6a9f57a269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afe25a2d6aaa308cce861fab50014f6a9f57a269", "html_url": "https://github.com/rust-lang/rust/commit/afe25a2d6aaa308cce861fab50014f6a9f57a269", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afe25a2d6aaa308cce861fab50014f6a9f57a269/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3198e1acf3301fdcfe527feb327ccd02d0e4434b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3198e1acf3301fdcfe527feb327ccd02d0e4434b", "html_url": "https://github.com/rust-lang/rust/commit/3198e1acf3301fdcfe527feb327ccd02d0e4434b"}, {"sha": "b952c0e4e9f3c169c6647fd05fef68ae1119865a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b952c0e4e9f3c169c6647fd05fef68ae1119865a", "html_url": "https://github.com/rust-lang/rust/commit/b952c0e4e9f3c169c6647fd05fef68ae1119865a"}], "stats": {"total": 206, "additions": 170, "deletions": 36}, "files": [{"sha": "3dbc80d352d15598adc357cfc16c47c6e2a34a3e", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afe25a2d6aaa308cce861fab50014f6a9f57a269/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe25a2d6aaa308cce861fab50014f6a9f57a269/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=afe25a2d6aaa308cce861fab50014f6a9f57a269", "patch": "@@ -1211,7 +1211,6 @@ register_diagnostics! {\n     E0138,\n     E0139,\n     E0264, // unknown external lang item\n-    E0266, // expected item\n     E0269, // not all control paths return a value\n     E0270, // computation may converge in a function marked as diverging\n     E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter"}, {"sha": "312a4708e8dde8959ce77d5e2edee92d17c1cb1c", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 140, "deletions": 34, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/afe25a2d6aaa308cce861fab50014f6a9f57a269/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe25a2d6aaa308cce861fab50014f6a9f57a269/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=afe25a2d6aaa308cce861fab50014f6a9f57a269", "patch": "@@ -13,68 +13,90 @@\n \n use ast_map;\n use session::Session;\n-use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefMap};\n+use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefVariant, DefMap};\n+use util::nodemap::NodeMap;\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n+use std::cell::RefCell;\n+\n struct CheckCrateVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n     def_map: &'a DefMap,\n-    ast_map: &'a ast_map::Map<'ast>\n+    ast_map: &'a ast_map::Map<'ast>,\n+    // `discriminant_map` is a cache that associates the `NodeId`s of local\n+    // variant definitions with the discriminant expression that applies to\n+    // each one. If the variant uses the default values (starting from `0`),\n+    // then `None` is stored.\n+    discriminant_map: RefCell<NodeMap<Option<&'ast ast::Expr>>>,\n }\n \n-impl<'v, 'a, 'ast> Visitor<'v> for CheckCrateVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, it: &ast::Item) {\n+impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n+    fn visit_item(&mut self, it: &'ast ast::Item) {\n         match it.node {\n-            ast::ItemStatic(_, _, ref expr) |\n-            ast::ItemConst(_, ref expr) => {\n+            ast::ItemStatic(..) |\n+            ast::ItemConst(..) => {\n                 let mut recursion_visitor =\n                     CheckItemRecursionVisitor::new(self, &it.span);\n                 recursion_visitor.visit_item(it);\n-                visit::walk_expr(self, &*expr)\n             },\n-            _ => visit::walk_item(self, it)\n+            ast::ItemEnum(ref enum_def, ref generics) => {\n+                // We could process the whole enum, but handling the variants\n+                // with discriminant expressions one by one gives more specific,\n+                // less redundant output.\n+                for variant in &enum_def.variants {\n+                    if let Some(_) = variant.node.disr_expr {\n+                        let mut recursion_visitor =\n+                            CheckItemRecursionVisitor::new(self, &variant.span);\n+                        recursion_visitor.populate_enum_discriminants(enum_def);\n+                        recursion_visitor.visit_variant(variant, generics);\n+                    }\n+                }\n+            }\n+            _ => {}\n         }\n+        visit::walk_item(self, it)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'ast ast::TraitItem) {\n         match ti.node {\n             ast::ConstTraitItem(_, ref default) => {\n-                if let Some(ref expr) = *default {\n+                if let Some(_) = *default {\n                     let mut recursion_visitor =\n                         CheckItemRecursionVisitor::new(self, &ti.span);\n                     recursion_visitor.visit_trait_item(ti);\n-                    visit::walk_expr(self, &*expr)\n                 }\n             }\n-            _ => visit::walk_trait_item(self, ti)\n+            _ => {}\n         }\n+        visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'ast ast::ImplItem) {\n         match ii.node {\n-            ast::ConstImplItem(_, ref expr) => {\n+            ast::ConstImplItem(..) => {\n                 let mut recursion_visitor =\n                     CheckItemRecursionVisitor::new(self, &ii.span);\n                 recursion_visitor.visit_impl_item(ii);\n-                visit::walk_expr(self, &*expr)\n             }\n-            _ => visit::walk_impl_item(self, ii)\n+            _ => {}\n         }\n+        visit::walk_impl_item(self, ii)\n     }\n }\n \n pub fn check_crate<'ast>(sess: &Session,\n-                         krate: &ast::Crate,\n+                         krate: &'ast ast::Crate,\n                          def_map: &DefMap,\n                          ast_map: &ast_map::Map<'ast>) {\n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n         def_map: def_map,\n-        ast_map: ast_map\n+        ast_map: ast_map,\n+        discriminant_map: RefCell::new(NodeMap()),\n     };\n     visit::walk_crate(&mut visitor, krate);\n     sess.abort_if_errors();\n@@ -85,53 +107,120 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a DefMap,\n-    idstack: Vec<ast::NodeId>\n+    discriminant_map: &'a RefCell<NodeMap<Option<&'ast ast::Expr>>>,\n+    idstack: Vec<ast::NodeId>,\n }\n \n impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n-    fn new(v: &CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n+    fn new(v: &'a CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n            -> CheckItemRecursionVisitor<'a, 'ast> {\n         CheckItemRecursionVisitor {\n             root_span: span,\n             sess: v.sess,\n             ast_map: v.ast_map,\n             def_map: v.def_map,\n-            idstack: Vec::new()\n+            discriminant_map: &v.discriminant_map,\n+            idstack: Vec::new(),\n         }\n     }\n     fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F)\n           where F: Fn(&mut Self) {\n-        if self.idstack.iter().any(|x| x == &(id)) {\n+        if self.idstack.iter().any(|x| *x == id) {\n             span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n             return;\n         }\n         self.idstack.push(id);\n         f(self);\n         self.idstack.pop();\n     }\n+    // If a variant has an expression specifying its discriminant, then it needs\n+    // to be checked just like a static or constant. However, if there are more\n+    // variants with no explicitly specified discriminant, those variants will\n+    // increment the same expression to get their values.\n+    //\n+    // So for every variant, we need to track whether there is an expression\n+    // somewhere in the enum definition that controls its discriminant. We do\n+    // this by starting from the end and searching backward.\n+    fn populate_enum_discriminants(&self, enum_definition: &'ast ast::EnumDef) {\n+        // Get the map, and return if we already processed this enum or if it\n+        // has no variants.\n+        let mut discriminant_map = self.discriminant_map.borrow_mut();\n+        match enum_definition.variants.first() {\n+            None => { return; }\n+            Some(variant) if discriminant_map.contains_key(&variant.node.id) => {\n+                return;\n+            }\n+            _ => {}\n+        }\n+\n+        // Go through all the variants.\n+        let mut variant_stack: Vec<ast::NodeId> = Vec::new();\n+        for variant in enum_definition.variants.iter().rev() {\n+            variant_stack.push(variant.node.id);\n+            // When we find an expression, every variant currently on the stack\n+            // is affected by that expression.\n+            if let Some(ref expr) = variant.node.disr_expr {\n+                for id in &variant_stack {\n+                    discriminant_map.insert(*id, Some(expr));\n+                }\n+                variant_stack.clear()\n+            }\n+        }\n+        // If we are at the top, that always starts at 0, so any variant on the\n+        // stack has a default value and does not need to be checked.\n+        for id in &variant_stack {\n+            discriminant_map.insert(*id, None);\n+        }\n+    }\n }\n \n-impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, it: &ast::Item) {\n+impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n+    fn visit_item(&mut self, it: &'ast ast::Item) {\n         self.with_item_id_pushed(it.id, |v| visit::walk_item(v, it));\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    fn visit_enum_def(&mut self, enum_definition: &'ast ast::EnumDef,\n+                      generics: &'ast ast::Generics) {\n+        self.populate_enum_discriminants(enum_definition);\n+        visit::walk_enum_def(self, enum_definition, generics);\n+    }\n+\n+    fn visit_variant(&mut self, variant: &'ast ast::Variant,\n+                     _: &'ast ast::Generics) {\n+        let variant_id = variant.node.id;\n+        let maybe_expr;\n+        if let Some(get_expr) = self.discriminant_map.borrow().get(&variant_id) {\n+            // This is necessary because we need to let the `discriminant_map`\n+            // borrow fall out of scope, so that we can reborrow farther down.\n+            maybe_expr = (*get_expr).clone();\n+        } else {\n+            self.sess.span_bug(variant.span,\n+                               \"`check_static_recursion` attempted to visit \\\n+                                variant with unknown discriminant\")\n+        }\n+        // If `maybe_expr` is `None`, that's because no discriminant is\n+        // specified that affects this variant. Thus, no risk of recursion.\n+        if let Some(expr) = maybe_expr {\n+            self.with_item_id_pushed(expr.id, |v| visit::walk_expr(v, expr));\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast ast::TraitItem) {\n         self.with_item_id_pushed(ti.id, |v| visit::walk_trait_item(v, ti));\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'ast ast::ImplItem) {\n         self.with_item_id_pushed(ii.id, |v| visit::walk_impl_item(v, ii));\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+    fn visit_expr(&mut self, e: &'ast ast::Expr) {\n         match e.node {\n             ast::ExprPath(..) => {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n                     Some(DefAssociatedConst(def_id, _)) |\n-                    Some(DefConst(def_id)) if\n-                            ast_util::is_local(def_id) => {\n+                    Some(DefConst(def_id))\n+                           if ast_util::is_local(def_id) => {\n                         match self.ast_map.get(def_id.node) {\n                           ast_map::NodeItem(item) =>\n                             self.visit_item(item),\n@@ -141,11 +230,28 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                             self.visit_impl_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n-                            span_err!(self.sess, e.span, E0266,\n-                              \"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node));\n-                            return;\n-                          },\n+                              self.sess.span_bug(\n+                                  e.span,\n+                                  &format!(\"expected item, found {}\",\n+                                           self.ast_map.node_to_string(def_id.node)));\n+                          }\n+                        }\n+                    }\n+                    // For variants, we only want to check expressions that\n+                    // affect the specific variant used, but we need to check\n+                    // the whole enum definition to see what expression that\n+                    // might be (if any).\n+                    Some(DefVariant(enum_id, variant_id, false))\n+                           if ast_util::is_local(enum_id) => {\n+                        if let ast::ItemEnum(ref enum_def, ref generics) =\n+                               self.ast_map.expect_item(enum_id.local_id()).node {\n+                            self.populate_enum_discriminants(enum_def);\n+                            let variant = self.ast_map.expect_variant(variant_id.local_id());\n+                            self.visit_variant(variant, generics);\n+                        } else {\n+                            self.sess.span_bug(e.span,\n+                                \"`check_static_recursion` found \\\n+                                 non-enum in DefVariant\");\n                         }\n                     }\n                     _ => ()"}, {"sha": "649052d123c8813fe3daa7b72470f03a14d8a2ec", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afe25a2d6aaa308cce861fab50014f6a9f57a269/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe25a2d6aaa308cce861fab50014f6a9f57a269/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=afe25a2d6aaa308cce861fab50014f6a9f57a269", "patch": "@@ -90,6 +90,11 @@ pub trait Visitor<'v> : Sized {\n         walk_struct_def(self, s)\n     }\n     fn visit_struct_field(&mut self, s: &'v StructField) { walk_struct_field(self, s) }\n+    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n+                      generics: &'v Generics) {\n+        walk_enum_def(self, enum_definition, generics)\n+    }\n+\n     fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) { walk_variant(self, v, g) }\n \n     /// Visits an optional reference to a lifetime. The `span` is the span of some surrounding\n@@ -268,7 +273,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n-            walk_enum_def(visitor, enum_definition, type_parameters)\n+            visitor.visit_enum_def(enum_definition, type_parameters)\n         }\n         ItemDefaultImpl(_, ref trait_ref) => {\n             visitor.visit_trait_ref(trait_ref)"}, {"sha": "7ac8cf45edbefe8d443d7336666f7db41ca0421a", "filename": "src/test/compile-fail/issue-23302.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/afe25a2d6aaa308cce861fab50014f6a9f57a269/src%2Ftest%2Fcompile-fail%2Fissue-23302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe25a2d6aaa308cce861fab50014f6a9f57a269/src%2Ftest%2Fcompile-fail%2Fissue-23302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23302.rs?ref=afe25a2d6aaa308cce861fab50014f6a9f57a269", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that an enum with recursion in the discriminant throws\n+// the appropriate error (rather than, say, blowing the stack).\n+enum X {\n+    A = X::A as isize, //~ ERROR E0265\n+}\n+\n+// Since `Y::B` here defaults to `Y::A+1`, this is also a\n+// recursive definition.\n+enum Y {\n+    A = Y::B as isize, //~ ERROR E0265\n+    B,\n+}\n+\n+fn main() { }"}]}