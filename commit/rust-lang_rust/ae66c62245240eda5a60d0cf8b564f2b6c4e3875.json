{"sha": "ae66c62245240eda5a60d0cf8b564f2b6c4e3875", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNjZjNjIyNDUyNDBlZGE1YTYwZDBjZjhiNTY0ZjJiNmM0ZTM4NzU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-16T17:46:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-16T17:46:34Z"}, "message": "Rollup merge of #72060 - lcnr:move-list, r=estebank\n\nmove `ty::List` into a new submodule\n\n`rustc_middle/ty` is currently right below the 3000 lines tidy file length limit.\n\nMoves `rustc_middle::ty::List` to the private module `rustc_middle::ty::list` and adds\na `pub use self::list::List` at its previous location.", "tree": {"sha": "2182fe7c6f4d881f0f1ca02d18a6f05565b2e663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2182fe7c6f4d881f0f1ca02d18a6f05565b2e663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae66c62245240eda5a60d0cf8b564f2b6c4e3875", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJewCb6CRBK7hj4Ov3rIwAAdHIIABOehpwSp8oTOjPsH8dJBlqp\n2sUjZnTMFVMIdbG/irTTx2UGURQUv6tfJkE1FQ3T4CGPawtvbfz0eJTWGgf+JK8K\noVCFpJ4kxG8jDNxdjl8QQ7W7uNRnYeBn9pPvg+Cr2Cio7BEHb3G3v5LKr3lVR+8D\nlx+UprtKmYQxWaL+9EBHRZQeqJ4/xA7YnYUpld9k6JBbQUoUxd8M4RmCud7OF/Uq\nvvReq3wfRBcslievWmxtJxd1VkpZpl0a5u72aBNwmGQ2F3r/J3wX6l7KX7vsM/7M\nf3tcURZZOnJ+2JemkHBtqWEYGmxfYH+A/2VoK/ThUuDX9DtfJSocE+PvlK3cKFw=\n=VBf8\n-----END PGP SIGNATURE-----\n", "payload": "tree 2182fe7c6f4d881f0f1ca02d18a6f05565b2e663\nparent ec5610ff8c41eb0664dab868dc9186a21e2f13b0\nparent bb6a6e08325a38f735b4806f5146e0d6a3fa687f\nauthor Ralf Jung <post@ralfj.de> 1589651194 +0200\ncommitter GitHub <noreply@github.com> 1589651194 +0200\n\nRollup merge of #72060 - lcnr:move-list, r=estebank\n\nmove `ty::List` into a new submodule\n\n`rustc_middle/ty` is currently right below the 3000 lines tidy file length limit.\n\nMoves `rustc_middle::ty::List` to the private module `rustc_middle::ty::list` and adds\na `pub use self::list::List` at its previous location.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae66c62245240eda5a60d0cf8b564f2b6c4e3875", "html_url": "https://github.com/rust-lang/rust/commit/ae66c62245240eda5a60d0cf8b564f2b6c4e3875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae66c62245240eda5a60d0cf8b564f2b6c4e3875/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5610ff8c41eb0664dab868dc9186a21e2f13b0", "html_url": "https://github.com/rust-lang/rust/commit/ec5610ff8c41eb0664dab868dc9186a21e2f13b0"}, {"sha": "bb6a6e08325a38f735b4806f5146e0d6a3fa687f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb6a6e08325a38f735b4806f5146e0d6a3fa687f", "html_url": "https://github.com/rust-lang/rust/commit/bb6a6e08325a38f735b4806f5146e0d6a3fa687f"}], "stats": {"total": 300, "additions": 155, "deletions": 145}, "files": [{"sha": "6427c547a8f295afbed58035d186a354237dab4e", "filename": "src/librustc_middle/ty/list.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/ae66c62245240eda5a60d0cf8b564f2b6c4e3875/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae66c62245240eda5a60d0cf8b564f2b6c4e3875/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=ae66c62245240eda5a60d0cf8b564f2b6c4e3875", "patch": "@@ -0,0 +1,149 @@\n+use crate::arena::Arena;\n+\n+use rustc_serialize::{Encodable, Encoder};\n+\n+use std::cmp::{self, Ordering};\n+use std::fmt;\n+use std::hash::{Hash, Hasher};\n+use std::mem;\n+use std::ops::Deref;\n+use std::ptr;\n+use std::slice;\n+\n+extern \"C\" {\n+    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n+    /// pointers.\n+    type OpaqueListContents;\n+}\n+\n+/// A wrapper for slices with the additional invariant\n+/// that the slice is interned and no other slice with\n+/// the same contents can exist in the same context.\n+/// This means we can use pointer for both\n+/// equality comparisons and hashing.\n+/// Note: `Slice` was already taken by the `Ty`.\n+#[repr(C)]\n+pub struct List<T> {\n+    len: usize,\n+    data: [T; 0],\n+    opaque: OpaqueListContents,\n+}\n+\n+unsafe impl<T: Sync> Sync for List<T> {}\n+\n+impl<T: Copy> List<T> {\n+    #[inline]\n+    pub(super) fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n+        assert!(!mem::needs_drop::<T>());\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(!slice.is_empty());\n+\n+        // Align up the size of the len (usize) field\n+        let align = mem::align_of::<T>();\n+        let align_mask = align - 1;\n+        let offset = mem::size_of::<usize>();\n+        let offset = (offset + align_mask) & !align_mask;\n+\n+        let size = offset + slice.len() * mem::size_of::<T>();\n+\n+        let mem = arena\n+            .dropless\n+            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n+        unsafe {\n+            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n+            // Write the length\n+            result.len = slice.len();\n+\n+            // Write the elements\n+            let arena_slice = slice::from_raw_parts_mut(result.data.as_mut_ptr(), result.len);\n+            arena_slice.copy_from_slice(slice);\n+\n+            result\n+        }\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for List<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for List<T> {\n+    #[inline]\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<T> Ord for List<T>\n+where\n+    T: Ord,\n+{\n+    fn cmp(&self, other: &List<T>) -> Ordering {\n+        if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n+    }\n+}\n+\n+impl<T> PartialOrd for List<T>\n+where\n+    T: PartialOrd,\n+{\n+    fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n+        if self == other {\n+            Some(Ordering::Equal)\n+        } else {\n+            <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n+        }\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for List<T> {\n+    #[inline]\n+    fn eq(&self, other: &List<T>) -> bool {\n+        ptr::eq(self, other)\n+    }\n+}\n+impl<T: Eq> Eq for List<T> {}\n+\n+impl<T> Hash for List<T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const List<T>).hash(s)\n+    }\n+}\n+\n+impl<T> Deref for List<T> {\n+    type Target = [T];\n+    #[inline(always)]\n+    fn deref(&self) -> &[T] {\n+        self.as_ref()\n+    }\n+}\n+\n+impl<T> AsRef<[T]> for List<T> {\n+    #[inline(always)]\n+    fn as_ref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.data.as_ptr(), self.len) }\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a List<T> {\n+    type Item = &'a T;\n+    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+    #[inline(always)]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self[..].iter()\n+    }\n+}\n+\n+impl<T> List<T> {\n+    #[inline(always)]\n+    pub fn empty<'a>() -> &'a List<T> {\n+        #[repr(align(64), C)]\n+        struct EmptySlice([u8; 64]);\n+        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n+        assert!(mem::align_of::<T>() <= 64);\n+        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+    }\n+}"}, {"sha": "6d6e1699feb222c37fde257fef0c083cac1f6405", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 145, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ae66c62245240eda5a60d0cf8b564f2b6c4e3875/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae66c62245240eda5a60d0cf8b564f2b6c4e3875/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=ae66c62245240eda5a60d0cf8b564f2b6c4e3875", "patch": "@@ -4,7 +4,6 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n \n-use crate::arena::Arena;\n use crate::hir::exports::ExportMap;\n use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n@@ -43,13 +42,11 @@ use rustc_span::Span;\n use rustc_target::abi::{Align, VariantIdx};\n \n use std::cell::RefCell;\n-use std::cmp::{self, Ordering};\n+use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::ops::Deref;\n use std::ops::Range;\n-use std::slice;\n-use std::{mem, ptr};\n+use std::ptr;\n \n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n@@ -81,6 +78,8 @@ pub use self::context::{\n \n pub use self::instance::{Instance, InstanceDef};\n \n+pub use self::list::List;\n+\n pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n@@ -112,6 +111,7 @@ pub mod walk;\n mod context;\n mod diagnostics;\n mod instance;\n+mod list;\n mod structural_impls;\n mod sty;\n \n@@ -663,148 +663,9 @@ pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n-\n-pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n-\n-extern \"C\" {\n-    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n-    /// pointers.\n-    type OpaqueListContents;\n-}\n-\n-/// A wrapper for slices with the additional invariant\n-/// that the slice is interned and no other slice with\n-/// the same contents can exist in the same context.\n-/// This means we can use pointer for both\n-/// equality comparisons and hashing.\n-/// Note: `Slice` was already taken by the `Ty`.\n-#[repr(C)]\n-pub struct List<T> {\n-    len: usize,\n-    data: [T; 0],\n-    opaque: OpaqueListContents,\n-}\n-\n-unsafe impl<T: Sync> Sync for List<T> {}\n-\n-impl<T: Copy> List<T> {\n-    #[inline]\n-    fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n-        assert!(!mem::needs_drop::<T>());\n-        assert!(mem::size_of::<T>() != 0);\n-        assert!(!slice.is_empty());\n-\n-        // Align up the size of the len (usize) field\n-        let align = mem::align_of::<T>();\n-        let align_mask = align - 1;\n-        let offset = mem::size_of::<usize>();\n-        let offset = (offset + align_mask) & !align_mask;\n-\n-        let size = offset + slice.len() * mem::size_of::<T>();\n-\n-        let mem = arena\n-            .dropless\n-            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n-        unsafe {\n-            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n-            // Write the length\n-            result.len = slice.len();\n-\n-            // Write the elements\n-            let arena_slice = slice::from_raw_parts_mut(result.data.as_mut_ptr(), result.len);\n-            arena_slice.copy_from_slice(slice);\n-\n-            result\n-        }\n-    }\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for List<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        (**self).fmt(f)\n-    }\n-}\n-\n-impl<T: Encodable> Encodable for List<T> {\n-    #[inline]\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<T> Ord for List<T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &List<T>) -> Ordering {\n-        if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n-    }\n-}\n-\n-impl<T> PartialOrd for List<T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n-        if self == other {\n-            Some(Ordering::Equal)\n-        } else {\n-            <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n-        }\n-    }\n-}\n-\n-impl<T: PartialEq> PartialEq for List<T> {\n-    #[inline]\n-    fn eq(&self, other: &List<T>) -> bool {\n-        ptr::eq(self, other)\n-    }\n-}\n-impl<T: Eq> Eq for List<T> {}\n-\n-impl<T> Hash for List<T> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const List<T>).hash(s)\n-    }\n-}\n-\n-impl<T> Deref for List<T> {\n-    type Target = [T];\n-    #[inline(always)]\n-    fn deref(&self) -> &[T] {\n-        self.as_ref()\n-    }\n-}\n-\n-impl<T> AsRef<[T]> for List<T> {\n-    #[inline(always)]\n-    fn as_ref(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.data.as_ptr(), self.len) }\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a List<T> {\n-    type Item = &'a T;\n-    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n-    #[inline(always)]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self[..].iter()\n-    }\n-}\n-\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<Ty<'tcx>> {}\n \n-impl<T> List<T> {\n-    #[inline(always)]\n-    pub fn empty<'a>() -> &'a List<T> {\n-        #[repr(align(64), C)]\n-        struct EmptySlice([u8; 64]);\n-        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n-        assert!(mem::align_of::<T>() <= 64);\n-        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n-    }\n-}\n+pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarPath {"}]}