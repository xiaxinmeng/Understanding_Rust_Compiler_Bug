{"sha": "9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "node_id": "C_kwDOAAsO6NoAKDliNWFhMDYzZDhlOTgwOGVhY2QyN2EwYmY3NWE4NTQ5NWZmMDFiZDQ", "commit": {"author": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-08-20T13:36:04Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-09-28T12:28:22Z"}, "message": "More tracing instrumentation", "tree": {"sha": "79a03125a311add6c7c95f15387da4a52520399b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79a03125a311add6c7c95f15387da4a52520399b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "html_url": "https://github.com/rust-lang/rust/commit/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83f147b3baf21acfc367a6da1045d212cd3957e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/83f147b3baf21acfc367a6da1045d212cd3957e4", "html_url": "https://github.com/rust-lang/rust/commit/83f147b3baf21acfc367a6da1045d212cd3957e4"}], "stats": {"total": 575, "additions": 252, "deletions": 323}, "files": [{"sha": "15309ccd8df278ef157210533c15436bd75780ad", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -327,6 +327,7 @@ impl TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     }\n }\n \n+#[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n     mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n     infcx: &InferCtxt<'_, 'tcx>,\n@@ -341,7 +342,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n     let _errors = fulfill_cx.select_all_or_error(infcx).err().unwrap_or_else(Vec::new);\n \n     let (sub_region, cause) = infcx.with_region_constraints(|region_constraints| {\n-        debug!(?region_constraints);\n+        debug!(\"{:#?}\", region_constraints);\n         region_constraints.constraints.iter().find_map(|(constraint, cause)| {\n             match *constraint {\n                 Constraint::RegSubReg(sub, sup) if sup == placeholder_region && sup != sub => {\n@@ -356,7 +357,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n         })\n     })?;\n \n-    debug!(?sub_region, ?cause);\n+    debug!(?sub_region, \"cause = {:#?}\", cause);\n     let nice_error = match (error_region, sub_region) {\n         (Some(error_region), &ty::ReVar(vid)) => NiceRegionError::new(\n             infcx,"}, {"sha": "6ffa0095e4b74a36c9525f1f47c2056fa36904db", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -144,6 +144,7 @@ fn mir_borrowck<'tcx>(\n /// If `return_body_with_facts` is true, then return the body with non-erased\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n+#[instrument(skip(infcx, input_body, input_promoted), level = \"debug\")]\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n@@ -152,7 +153,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n     let def = input_body.source.with_opt_param().as_local().unwrap();\n \n-    debug!(\"do_mir_borrowck(def = {:?})\", def);\n+    debug!(?def);\n \n     let tcx = infcx.tcx;\n     let param_env = tcx.param_env(def.did);"}, {"sha": "e5924f9d08478ff484bcf5feef030bb7a48419cc", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -54,6 +54,7 @@ crate struct NllOutput<'tcx> {\n /// Rewrites the regions in the MIR to use NLL variables, also scraping out the set of universal\n /// regions (e.g., region parameters) declared on the function. That set will need to be given to\n /// `compute_regions`.\n+#[instrument(skip(infcx, param_env, body, promoted), level = \"debug\")]\n pub(crate) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -62,7 +63,7 @@ pub(crate) fn replace_regions_in_mir<'cx, 'tcx>(\n ) -> UniversalRegions<'tcx> {\n     let def = body.source.with_opt_param().as_local().unwrap();\n \n-    debug!(\"replace_regions_in_mir(def={:?})\", def);\n+    debug!(?def);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n     let universal_regions = UniversalRegions::new(infcx, def, param_env);"}, {"sha": "65d6e3a4ae574875fda0078e78982af562f8457d", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 26, "deletions": 45, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -552,6 +552,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Performs region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n+    #[instrument(skip(self, infcx, body, polonius_output), level = \"debug\")]\n     pub(super) fn solve(\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -607,10 +608,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n+    #[instrument(skip(self, _body), level = \"debug\")]\n     fn propagate_constraints(&mut self, _body: &Body<'tcx>) {\n-        debug!(\"propagate_constraints()\");\n-\n-        debug!(\"propagate_constraints: constraints={:#?}\", {\n+        debug!(\"constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n             constraints.sort();\n             constraints\n@@ -637,12 +637,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// computed, by unioning the values of its successors.\n     /// Assumes that all successors have been computed already\n     /// (which is assured by iterating over SCCs in dependency order).\n+    #[instrument(skip(self), level = \"debug\")]\n     fn compute_value_for_scc(&mut self, scc_a: ConstraintSccIndex) {\n         let constraint_sccs = self.constraint_sccs.clone();\n \n         // Walk each SCC `B` such that `A: B`...\n         for &scc_b in constraint_sccs.successors(scc_a) {\n-            debug!(\"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\", scc_a, scc_b);\n+            debug!(?scc_b);\n \n             // ...and add elements from `B` into `A`. One complication\n             // arises because of universes: If `B` contains something\n@@ -663,11 +664,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.apply_member_constraint(scc_a, m_c_i, member_constraints.choice_regions(m_c_i));\n         }\n \n-        debug!(\n-            \"propagate_constraint_sccs: scc_a = {:?} has value {:?}\",\n-            scc_a,\n-            self.scc_values.region_value_str(scc_a),\n-        );\n+        debug!(value = ?self.scc_values.region_value_str(scc_a));\n     }\n \n     /// Invoked for each `R0 member of [R1..Rn]` constraint.\n@@ -681,14 +678,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// is considered a *lower bound*.  If possible, we will modify\n     /// the constraint to set it equal to one of the option regions.\n     /// If we make any changes, returns true, else false.\n+    #[instrument(skip(self, member_constraint_index), level = \"debug\")]\n     fn apply_member_constraint(\n         &mut self,\n         scc: ConstraintSccIndex,\n         member_constraint_index: NllMemberConstraintIndex,\n         choice_regions: &[ty::RegionVid],\n     ) -> bool {\n-        debug!(\"apply_member_constraint(scc={:?}, choice_regions={:#?})\", scc, choice_regions,);\n-\n         // Create a mutable vector of the options. We'll try to winnow\n         // them down.\n         let mut choice_regions: Vec<ty::RegionVid> = choice_regions.to_vec();\n@@ -714,7 +710,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .universal_regions_outlived_by(scc)\n                 .all(|lb| self.universal_region_relations.outlives(o_r, lb))\n         });\n-        debug!(\"apply_member_constraint: after lb, choice_regions={:?}\", choice_regions);\n+        debug!(?choice_regions, \"after lb\");\n \n         // Now find all the *upper bounds* -- that is, each UB is a\n         // free region that must outlive the member region `R0` (`UB:\n@@ -723,10 +719,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let rev_scc_graph = self.reverse_scc_graph();\n         let universal_region_relations = &self.universal_region_relations;\n         for ub in rev_scc_graph.upper_bounds(scc) {\n-            debug!(\"apply_member_constraint: ub={:?}\", ub);\n+            debug!(?ub);\n             choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n         }\n-        debug!(\"apply_member_constraint: after ub, choice_regions={:?}\", choice_regions);\n+        debug!(?choice_regions, \"after ub\");\n \n         // If we ruled everything out, we're done.\n         if choice_regions.is_empty() {\n@@ -735,7 +731,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Otherwise, we need to find the minimum remaining choice, if\n         // any, and take that.\n-        debug!(\"apply_member_constraint: choice_regions remaining are {:#?}\", choice_regions);\n+        debug!(\"choice_regions remaining are {:#?}\", choice_regions);\n         let min = |r1: ty::RegionVid, r2: ty::RegionVid| -> Option<ty::RegionVid> {\n             let r1_outlives_r2 = self.universal_region_relations.outlives(r1, r2);\n             let r2_outlives_r1 = self.universal_region_relations.outlives(r2, r1);\n@@ -748,27 +744,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n         let mut min_choice = choice_regions[0];\n         for &other_option in &choice_regions[1..] {\n-            debug!(\n-                \"apply_member_constraint: min_choice={:?} other_option={:?}\",\n-                min_choice, other_option,\n-            );\n+            debug!(?min_choice, ?other_option,);\n             match min(min_choice, other_option) {\n                 Some(m) => min_choice = m,\n                 None => {\n-                    debug!(\n-                        \"apply_member_constraint: {:?} and {:?} are incomparable; no min choice\",\n-                        min_choice, other_option,\n-                    );\n+                    debug!(?min_choice, ?other_option, \"incomparable; no min choice\",);\n                     return false;\n                 }\n             }\n         }\n \n         let min_choice_scc = self.constraint_sccs.scc(min_choice);\n-        debug!(\n-            \"apply_member_constraint: min_choice={:?} best_choice_scc={:?}\",\n-            min_choice, min_choice_scc,\n-        );\n+        debug!(?min_choice, ?min_choice_scc);\n         if self.scc_values.add_region(scc, min_choice_scc) {\n             self.member_constraints_applied.push(AppliedMemberConstraint {\n                 member_region_scc: scc,\n@@ -1091,8 +1078,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///   include the CFG anyhow.\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub(crate) fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\"universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n+        debug!(r = %self.region_value_str(r));\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n@@ -1102,7 +1090,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n         }\n \n-        debug!(\"universal_upper_bound: r={:?} lub={:?}\", r, lub);\n+        debug!(?lub);\n \n         lub\n     }\n@@ -1262,9 +1250,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     // Evaluate whether `sup_region: sub_region`.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn eval_outlives(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n-        debug!(\"eval_outlives({:?}: {:?})\", sup_region, sub_region);\n-\n         debug!(\n             \"eval_outlives: sup_region's value = {:?} universal={:?}\",\n             self.region_value_str(sup_region),\n@@ -1467,15 +1454,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Things that are to be propagated are accumulated into the\n     /// `outlives_requirements` vector.\n+    #[instrument(\n+        skip(self, body, propagated_outlives_requirements, errors_buffer),\n+        level = \"debug\"\n+    )]\n     fn check_universal_region(\n         &self,\n         body: &Body<'tcx>,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n-        debug!(\"check_universal_region(fr={:?})\", longer_fr);\n-\n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n \n         // Because this free region must be in the ROOT universe, we\n@@ -1880,21 +1869,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n+    #[instrument(skip(self), level = \"trace\")]\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n-        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n-        debug!(\"find_sub_region_live_at: {:?} is in scc {:?}\", fr1, self.constraint_sccs.scc(fr1));\n-        debug!(\n-            \"find_sub_region_live_at: {:?} is in universe {:?}\",\n-            fr1,\n-            self.scc_universes[self.constraint_sccs.scc(fr1)]\n-        );\n+        trace!(scc = ?self.constraint_sccs.scc(fr1));\n+        trace!(universe = ?self.scc_universes[self.constraint_sccs.scc(fr1)]);\n         self.find_constraint_paths_between_regions(fr1, |r| {\n             // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n-            debug!(\n-                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n-                r,\n-                self.liveness_constraints.region_value_str(r),\n-            );\n+            trace!(?r, liveness_constraints=?self.liveness_constraints.region_value_str(r));\n             self.liveness_constraints.contains(r, elem)\n         })\n         .or_else(|| {"}, {"sha": "20567610f6557895076e7a79ef877d3259df641b", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -7,13 +7,13 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n+#[instrument(skip(infcx, body, promoted), level = \"debug\")]\n pub fn renumber_mir<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) {\n-    debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);\n+    debug!(?body.arg_count);\n \n     let mut visitor = NllVisitor { infcx };\n \n@@ -26,12 +26,11 @@ pub fn renumber_mir<'tcx>(\n \n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n+#[instrument(skip(infcx), level = \"debug\")]\n pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'_, 'tcx>, value: T) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n-    debug!(\"renumber_regions(value={:?})\", value);\n-\n     infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n         let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n         infcx.next_nll_region_var(origin)\n@@ -56,12 +55,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n-        debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n-\n         *ty = self.renumber_regions(ty);\n \n-        debug!(\"visit_ty: ty={:?}\", ty);\n+        debug!(?ty);\n     }\n \n     fn process_projection_elem(\n@@ -80,21 +78,19 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n         None\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, location: Location) {\n-        debug!(\"visit_substs(substs={:?}, location={:?})\", substs, location);\n-\n         *substs = self.renumber_regions(*substs);\n \n-        debug!(\"visit_substs: substs={:?}\", substs);\n+        debug!(?substs);\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn visit_region(&mut self, region: &mut ty::Region<'tcx>, location: Location) {\n-        debug!(\"visit_region(region={:?}, location={:?})\", region, location);\n-\n         let old_region = *region;\n         *region = self.renumber_regions(&old_region);\n \n-        debug!(\"visit_region: region={:?}\", region);\n+        debug!(?region);\n     }\n \n     fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _location: Location) {"}, {"sha": "7d4df59902aedbb759d4aecac35fde788168996d", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -24,6 +24,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// **Any `rustc_infer::infer` operations that might generate region\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n+    #[instrument(skip(self, category, op), level = \"trace\")]\n     pub(super) fn fully_perform_op<R, Op>(\n         &mut self,\n         locations: Locations,\n@@ -131,14 +132,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn prove_predicate(\n         &mut self,\n         predicate: ty::Predicate<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) {\n-        debug!(\"prove_predicate(predicate={:?}, location={:?})\", predicate, locations,);\n-\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             locations,\n@@ -150,11 +150,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n     where\n         T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n     {\n-        debug!(\"normalize(value={:?}, location={:?})\", value, location);\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.to_locations(),"}, {"sha": "ab1a7461b4b9bf5c05149d443af0a0d1f944d7b3", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -53,9 +53,8 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn convert_all(&mut self, query_constraints: &QueryRegionConstraints<'tcx>) {\n-        debug!(\"convert_all(query_constraints={:#?})\", query_constraints);\n-\n         let QueryRegionConstraints { outlives, member_constraints } = query_constraints;\n \n         // Annoying: to invoke `self.to_region_vid`, we need access to"}, {"sha": "24332690bec31c51c269dd79bef5c0a6567dfa41", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -20,6 +20,7 @@ use crate::universal_regions::UniversalRegions;\n use super::{Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    #[instrument(skip(self, body, universal_regions), level = \"debug\")]\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n         body: &Body<'tcx>,\n@@ -64,10 +65,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             );\n         }\n \n-        debug!(\n-            \"equate_inputs_and_outputs: normalized_input_tys = {:?}, local_decls = {:?}\",\n-            normalized_input_tys, body.local_decls\n-        );\n+        debug!(?normalized_input_tys, ?body.local_decls);\n \n         // Equate expected input tys with those in the MIR.\n         for (argument_index, &normalized_input_ty) in normalized_input_tys.iter().enumerate() {\n@@ -160,9 +158,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, span), level = \"debug\")]\n     fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, span: Span) {\n-        debug!(\"equate_normalized_input_or_output(a={:?}, b={:?})\", a, b);\n-\n         if let Err(_) =\n             self.eq_types(a, b, Locations::All(span), ConstraintCategory::BoringNoLocation)\n         {"}, {"sha": "55790bd2daa9be150db33acb103dc982b9a254e9", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -197,6 +197,11 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                 .into_iter()\n                 .filter_map(|(opaque_type_key, mut decl)| {\n                     decl.concrete_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n+                    trace!(\n+                        \"finalized opaque type {:?} to {:#?}\",\n+                        opaque_type_key,\n+                        decl.concrete_ty.kind()\n+                    );\n                     if decl.concrete_ty.has_infer_types_or_consts() {\n                         infcx.tcx.sess.delay_span_bug(\n                             body.span,\n@@ -247,6 +252,18 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n }\n \n+#[instrument(\n+    skip(\n+        infcx,\n+        body,\n+        promoted,\n+        region_bound_pairs,\n+        borrowck_context,\n+        universal_region_relations,\n+        extra\n+    ),\n+    level = \"debug\"\n+)]\n fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -1114,13 +1131,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, data), level = \"debug\")]\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory,\n         data: &QueryRegionConstraints<'tcx>,\n     ) {\n-        debug!(\"push_region_constraints: constraints generated at {:?} are {:#?}\", locations, data);\n+        debug!(\"constraints generated: {:#?}\", data);\n \n         constraint_conversion::ConstraintConversion::new(\n             self.infcx,\n@@ -1180,6 +1198,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         self.relate_types(expected, ty::Variance::Invariant, found, locations, category)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn relate_type_and_user_type(\n         &mut self,\n         a: Ty<'tcx>,\n@@ -1188,11 +1207,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        debug!(\n-            \"relate_type_and_user_type(a={:?}, v={:?}, user_ty={:?}, locations={:?})\",\n-            a, v, user_ty, locations,\n-        );\n-\n         let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n \n@@ -1250,20 +1264,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     ///   generics of `foo`). Note that `anon_ty` is not just the opaque type,\n     ///   but the entire return type (which may contain opaque types within it).\n     /// * `revealed_ty` would be `Box<(T, u32)>`\n+    #[instrument(skip(self), level = \"debug\")]\n     fn eq_opaque_type_and_type(\n         &mut self,\n         revealed_ty: Ty<'tcx>,\n         anon_ty: Ty<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        debug!(\n-            \"eq_opaque_type_and_type( \\\n-             revealed_ty={:?}, \\\n-             anon_ty={:?})\",\n-            revealed_ty, anon_ty\n-        );\n-\n         // Fast path for the common case.\n         if !anon_ty.has_opaque_types() {\n             if let Err(terr) = self.eq_types(anon_ty, revealed_ty, locations, category) {\n@@ -1283,7 +1291,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let body = self.body;\n         let mir_def_id = body.source.def_id().expect_local();\n \n-        debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", mir_def_id);\n+        debug!(?mir_def_id);\n         self.fully_perform_op(\n             locations,\n             category,\n@@ -1305,12 +1313,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         anon_ty,\n                         locations.span(body),\n                     ));\n-                    debug!(\n-                        \"eq_opaque_type_and_type: \\\n-                         instantiated output_ty={:?} \\\n-                         revealed_ty={:?}\",\n-                        output_ty, revealed_ty\n-                    );\n+                    debug!(?output_ty, ?revealed_ty);\n \n                     // Make sure that the inferred types are well-formed. I'm\n                     // not entirely sure this is needed (the HIR type check\n@@ -1328,7 +1331,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             .eq(output_ty, revealed_ty)?,\n                     );\n \n-                    debug!(\"eq_opaque_type_and_type: equated\");\n+                    debug!(\"equated\");\n \n                     Ok(InferOk { value: (), obligations: obligations.into_vec() })\n                 },\n@@ -1368,8 +1371,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    #[instrument(skip(self, body, location), level = \"debug\")]\n     fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n-        debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rv)) => {\n@@ -1522,13 +1525,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, body, term_location), level = \"debug\")]\n     fn check_terminator(\n         &mut self,\n         body: &Body<'tcx>,\n         term: &Terminator<'tcx>,\n         term_location: Location,\n     ) {\n-        debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n         match term.kind {\n             TerminatorKind::Goto { .. }\n@@ -2685,9 +2688,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         tcx.predicates_of(def_id).instantiate(tcx, substs)\n     }\n \n+    #[instrument(skip(self, body), level = \"debug\")]\n     fn typeck_mir(&mut self, body: &Body<'tcx>) {\n         self.last_span = body.span;\n-        debug!(\"run_on_mir: {:?}\", body.span);\n+        debug!(?body.span);\n \n         for (local, local_decl) in body.local_decls.iter_enumerated() {\n             self.check_local(&body, local, local_decl);"}, {"sha": "b788529dc1cd4847628d6b5912c93a8e92d55973", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -17,6 +17,7 @@ use crate::type_check::{BorrowCheckContext, Locations};\n ///\n /// N.B., the type `a` is permitted to have unresolved inference\n /// variables, but not the type `b`.\n+#[instrument(skip(infcx, param_env, borrowck_context), level = \"debug\")]\n pub(super) fn relate_types<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -27,7 +28,6 @@ pub(super) fn relate_types<'tcx>(\n     category: ConstraintCategory,\n     borrowck_context: &mut BorrowCheckContext<'_, 'tcx>,\n ) -> Fallible<()> {\n-    debug!(\"relate_types(a={:?}, v={:?}, b={:?}, locations={:?})\", a, v, b, locations);\n     TypeRelating::new(\n         infcx,\n         NllTypeRelatingDelegate::new("}, {"sha": "b84f28b6a9edf408999fd4dde15a3da2e90b0ef3", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -405,6 +405,7 @@ where\n     /// Call this method when `inspect_node` has returned `None`. Having the\n     /// caller decide avoids mutual recursion between the two methods and allows\n     /// us to maintain an allocated stack for nodes on the path between calls.\n+    #[instrument(skip(self, initial), level = \"debug\")]\n     fn walk_unvisited_node(&mut self, initial: G::Node) -> WalkReturn<S> {\n         struct VisitingNodeFrame<G: DirectedGraph, Successors> {\n             node: G::Node,\n@@ -451,7 +452,7 @@ where\n                 Some(iter) => iter,\n                 None => {\n                     // This None marks that we still have the initialize this node's frame.\n-                    debug!(\"walk_unvisited_node(depth = {:?}, node = {:?})\", depth, node);\n+                    debug!(?depth, ?node);\n \n                     debug_assert!(matches!(self.node_states[node], NodeState::NotVisited));\n \n@@ -478,10 +479,7 @@ where\n                 return_value.take().into_iter().map(|walk| (*successor_node, Some(walk)));\n \n             let successor_walk = successors.by_ref().map(|successor_node| {\n-                debug!(\n-                    \"walk_unvisited_node: node = {:?} successor_ode = {:?}\",\n-                    node, successor_node\n-                );\n+                debug!(?node, ?successor_node);\n                 (successor_node, self.inspect_node(successor_node))\n             });\n \n@@ -491,10 +489,7 @@ where\n                         // Track the minimum depth we can reach.\n                         assert!(successor_min_depth <= depth);\n                         if successor_min_depth < *min_depth {\n-                            debug!(\n-                                \"walk_unvisited_node: node = {:?} successor_min_depth = {:?}\",\n-                                node, successor_min_depth\n-                            );\n+                            debug!(?node, ?successor_min_depth);\n                             *min_depth = successor_min_depth;\n                             *min_cycle_root = successor_node;\n                         }\n@@ -503,16 +498,13 @@ where\n                     Some(WalkReturn::Complete { scc_index: successor_scc_index }) => {\n                         // Push the completed SCC indices onto\n                         // the `successors_stack` for later.\n-                        debug!(\n-                            \"walk_unvisited_node: node = {:?} successor_scc_index = {:?}\",\n-                            node, successor_scc_index\n-                        );\n+                        debug!(?node, ?successor_scc_index);\n                         successors_stack.push(successor_scc_index);\n                     }\n \n                     None => {\n                         let depth = depth + 1;\n-                        debug!(\"walk_node(depth = {:?}, node = {:?})\", depth, successor_node);\n+                        debug!(?depth, ?successor_node);\n                         // Remember which node the return value will come from.\n                         frame.successor_node = successor_node;\n                         // Start a new stack frame the step into it."}, {"sha": "cff848eeb6a0fc818cb718c2b396cdb3ce41308f", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -187,11 +187,11 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn sub<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n-        debug!(\"sub({:?} <: {:?})\", a, b);\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n             let mut fields = at.infcx.combine_fields(trace, at.param_env);\n@@ -204,11 +204,11 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n     /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn eq<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n-        debug!(\"eq({:?} == {:?})\", a, b);\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n             let mut fields = at.infcx.combine_fields(trace, at.param_env);\n@@ -219,11 +219,11 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn lub<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n-        debug!(\"lub({:?} \\\\/ {:?})\", a, b);\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n             let mut fields = at.infcx.combine_fields(trace, at.param_env);\n@@ -234,11 +234,11 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn glb<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n-        debug!(\"glb({:?} /\\\\ {:?})\", a, b);\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n             let mut fields = at.infcx.combine_fields(trace, at.param_env);"}, {"sha": "2296cc6129ae8594a70f579b546d307a844418ad", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -49,6 +49,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ///   the same thing happens, but the resulting query is marked as ambiguous.\n     /// - Finally, if any of the obligations result in a hard error,\n     ///   then `Err(NoSolution)` is returned.\n+    #[instrument(skip(self, inference_vars, answer, fulfill_cx), level = \"trace\")]\n     pub fn make_canonicalized_query_response<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n@@ -62,7 +63,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n         let canonical_result = self.canonicalize_response(query_response);\n \n-        debug!(\"make_canonicalized_query_response: canonical_result = {:#?}\", canonical_result);\n+        debug!(\"canonical_result = {:#?}\", canonical_result);\n \n         Ok(self.tcx.arena.alloc(canonical_result))\n     }\n@@ -94,6 +95,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     /// Helper for `make_canonicalized_query_response` that does\n     /// everything up until the final canonicalization.\n+    #[instrument(skip(self, fulfill_cx), level = \"debug\")]\n     fn make_query_response<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n@@ -105,13 +107,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     {\n         let tcx = self.tcx;\n \n-        debug!(\n-            \"make_query_response(\\\n-             inference_vars={:?}, \\\n-             answer={:?})\",\n-            inference_vars, answer,\n-        );\n-\n         // Select everything, returning errors.\n         let true_errors = fulfill_cx.select_where_possible(self).err().unwrap_or_else(Vec::new);\n         debug!(\"true_errors = {:#?}\", true_errors);"}, {"sha": "773753a0363264400be63ce562bae19850ffa3e8", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -94,13 +94,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// the actual types (`?T`, `Option<?T>`) -- and remember that\n     /// after the snapshot is popped, the variable `?T` is no longer\n     /// unified.\n+    #[instrument(skip(self, f), level = \"debug\")]\n     pub fn fudge_inference_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n         F: FnOnce() -> Result<T, E>,\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"fudge_inference_if_ok()\");\n-\n         let variable_lengths = self.variable_lengths();\n         let (mut fudger, value) = self.probe(|_| {\n             match f() {"}, {"sha": "ae85e55da6ae321b7a8889ca74e009b1795d401c", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Binder, TypeFoldable};\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n         a: Binder<'tcx, T>,\n@@ -18,8 +19,6 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        debug!(\"higher_ranked_sub(a={:?}, b={:?})\", a, b);\n-\n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n         // that function subtyping works correctly with respect to regions"}, {"sha": "18836d5a68e26e8cdf67f5f1b18c9182ef6c54a9", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -807,8 +807,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, snapshot), level = \"debug\")]\n     fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n-        debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot {\n             undo_snapshot,\n             region_constraints_snapshot,\n@@ -825,8 +825,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n     }\n \n+    #[instrument(skip(self, snapshot), level = \"debug\")]\n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n-        debug!(\"commit_from()\");\n         let CombinedSnapshot {\n             undo_snapshot,\n             region_constraints_snapshot: _,\n@@ -841,23 +841,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Executes `f` and commit the bindings.\n+    #[instrument(skip(self, f), level = \"debug\")]\n     pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n-        debug!(\"commit_unconditionally()\");\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n         self.commit_from(snapshot);\n         r\n     }\n \n     /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`.\n+    #[instrument(skip(self, f), level = \"debug\")]\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n     {\n-        debug!(\"commit_if_ok()\");\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n         debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n@@ -873,23 +873,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` then unroll any bindings it creates.\n+    #[instrument(skip(self, f), level = \"debug\")]\n     pub fn probe<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n-        debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n         self.rollback_to(\"probe\", snapshot);\n         r\n     }\n \n     /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n+    #[instrument(skip(self, f), level = \"debug\")]\n     pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n-        debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n         let was_skip_leak_check = self.skip_leak_check.get();\n         if should_skip {\n@@ -946,18 +946,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn sub_regions(\n         &self,\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n-        debug!(\"sub_regions({:?} <: {:?})\", a, b);\n         self.inner.borrow_mut().unwrap_region_constraints().make_subregion(origin, a, b);\n     }\n \n     /// Require that the region `r` be equal to one of the regions in\n     /// the set `regions`.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn member_constraint(\n         &self,\n         opaque_type_def_id: DefId,\n@@ -966,7 +967,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         region: ty::Region<'tcx>,\n         in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n     ) {\n-        debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n         self.inner.borrow_mut().unwrap_region_constraints().member_constraint(\n             opaque_type_def_id,\n             definition_span,"}, {"sha": "29a9cbc7a99c368be1fcaaeea7fabf3a0bdeeff3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -507,30 +507,30 @@ where\n         true\n     }\n \n+    #[instrument(skip(self, info), level = \"trace\")]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n         info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n-        debug!(\"relate_with_variance(variance={:?}, a={:?}, b={:?})\", variance, a, b);\n-\n         let old_ambient_variance = self.ambient_variance;\n         self.ambient_variance = self.ambient_variance.xform(variance);\n         self.ambient_variance_info = self.ambient_variance_info.xform(info);\n \n-        debug!(\"relate_with_variance: ambient_variance = {:?}\", self.ambient_variance);\n+        debug!(?self.ambient_variance);\n \n         let r = self.relate(a, b)?;\n \n         self.ambient_variance = old_ambient_variance;\n \n-        debug!(\"relate_with_variance: r={:?}\", r);\n+        debug!(?r);\n \n         Ok(r)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let a = self.infcx.shallow_resolve(a);\n \n@@ -573,26 +573,27 @@ where\n             }\n \n             _ => {\n-                debug!(\"tys(a={:?}, b={:?}, variance={:?})\", a, b, self.ambient_variance);\n+                debug!(?a, ?b, ?self.ambient_variance);\n \n                 // Will also handle unification of `IntVar` and `FloatVar`.\n                 self.infcx.super_combine_tys(self, a, b)\n             }\n         }\n     }\n \n+    #[instrument(skip(self), level = \"trace\")]\n     fn regions(\n         &mut self,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"regions(a={:?}, b={:?}, variance={:?})\", a, b, self.ambient_variance);\n+        debug!(?self.ambient_variance);\n \n         let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n         let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n \n-        debug!(\"regions: v_a = {:?}\", v_a);\n-        debug!(\"regions: v_b = {:?}\", v_b);\n+        debug!(?v_a);\n+        debug!(?v_b);\n \n         if self.ambient_covariance() {\n             // Covariance: a <= b. Hence, `b: a`.\n@@ -628,6 +629,7 @@ where\n         }\n     }\n \n+    #[instrument(skip(self), level = \"trace\")]\n     fn binders<T>(\n         &mut self,\n         a: ty::Binder<'tcx, T>,\n@@ -655,7 +657,7 @@ where\n         // - Instantiate binders on `b` universally, yielding a universe U1.\n         // - Instantiate binders on `a` existentially in U1.\n \n-        debug!(\"binders({:?}: {:?}, ambient_variance={:?})\", a, b, self.ambient_variance);\n+        debug!(?self.ambient_variance);\n \n         if let (Some(a), Some(b)) = (a.no_bound_vars(), b.no_bound_vars()) {\n             // Fast path for the common case.\n@@ -673,8 +675,8 @@ where\n             let b_scope = self.create_scope(b, UniversallyQuantified(true));\n             let a_scope = self.create_scope(a, UniversallyQuantified(false));\n \n-            debug!(\"binders: a_scope = {:?} (existential)\", a_scope);\n-            debug!(\"binders: b_scope = {:?} (universal)\", b_scope);\n+            debug!(?a_scope, \"(existential)\");\n+            debug!(?b_scope, \"(universal)\");\n \n             self.b_scopes.push(b_scope);\n             self.a_scopes.push(a_scope);\n@@ -717,8 +719,8 @@ where\n             let a_scope = self.create_scope(a, UniversallyQuantified(true));\n             let b_scope = self.create_scope(b, UniversallyQuantified(false));\n \n-            debug!(\"binders: a_scope = {:?} (universal)\", a_scope);\n-            debug!(\"binders: b_scope = {:?} (existential)\", b_scope);\n+            debug!(?a_scope, \"(universal)\");\n+            debug!(?b_scope, \"(existential)\");\n \n             self.a_scopes.push(a_scope);\n             self.b_scopes.push(b_scope);"}, {"sha": "df4fdb3a982ecaabd2e839be78a20e9f6362e574", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -540,17 +540,15 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         });\n     }\n \n+    #[instrument(skip(self, origin), level = \"debug\")]\n     pub fn make_subregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n     ) {\n         // cannot add constraints once regions are resolved\n-        debug!(\n-            \"RegionConstraintCollector: make_subregion({:?}, {:?}) due to {:?}\",\n-            sub, sup, origin\n-        );\n+        debug!(\"origin = {:#?}\", origin);\n \n         match (sub, sup) {\n             (&ReLateBound(..), _) | (_, &ReLateBound(..)) => {"}, {"sha": "e16491dcc90b25eeb62ff3858833d11fbfb406f2", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -79,6 +79,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n             == Some(FoundFlags)\n     }\n \n+    #[instrument(level = \"trace\")]\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         self.visit_with(&mut HasTypeFlagsVisitor { tcx: None, flags }).break_value()\n             == Some(FoundFlags)\n@@ -476,21 +477,16 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n         t\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, _) if debruijn < self.current_index => {\n-                debug!(\n-                    \"RegionFolder.fold_region({:?}) skipped bound region (current index={:?})\",\n-                    r, self.current_index\n-                );\n+                debug!(?self.current_index, \"skipped bound region\");\n                 *self.skipped_regions = true;\n                 r\n             }\n             _ => {\n-                debug!(\n-                    \"RegionFolder.fold_region({:?}) folding free region (current_index={:?})\",\n-                    r, self.current_index\n-                );\n+                debug!(?self.current_index, \"folding free region\");\n                 (self.fold_region_fn)(r, self.current_index)\n             }\n         }\n@@ -1125,16 +1121,23 @@ struct HasTypeFlagsVisitor<'tcx> {\n     flags: ty::TypeFlags,\n }\n \n+impl std::fmt::Debug for HasTypeFlagsVisitor<'tcx> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        self.flags.fmt(fmt)\n+    }\n+}\n+\n impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n     type BreakTy = FoundFlags;\n     fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n         bug!(\"we shouldn't call this method as we manually look at ct substs\");\n     }\n \n     #[inline]\n+    #[instrument(level = \"trace\")]\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = t.flags();\n-        debug!(\"HasTypeFlagsVisitor: t={:?} flags={:?} self.flags={:?}\", t, flags, self.flags);\n+        trace!(t.flags=?t.flags());\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n@@ -1146,9 +1149,10 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n     }\n \n     #[inline]\n+    #[instrument(skip(self), level = \"trace\")]\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = r.type_flags();\n-        debug!(\"HasTypeFlagsVisitor: r={:?} r.flags={:?} self.flags={:?}\", r, flags, self.flags);\n+        trace!(r.flags=?flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n@@ -1157,9 +1161,10 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n     }\n \n     #[inline]\n+    #[instrument(level = \"trace\")]\n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_const(c);\n-        debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n+        trace!(r.flags=?flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n@@ -1171,9 +1176,10 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n     }\n \n     #[inline]\n+    #[instrument(level = \"trace\")]\n     fn visit_unevaluated_const(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_unevaluated_const(uv);\n-        debug!(\"HasTypeFlagsVisitor: uv={:?} uv.flags={:?} self.flags={:?}\", uv, flags, self.flags);\n+        trace!(r.flags=?flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n@@ -1185,12 +1191,10 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n     }\n \n     #[inline]\n+    #[instrument(level = \"trace\")]\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = predicate.inner.flags;\n-        debug!(\n-            \"HasTypeFlagsVisitor: predicate={:?} flags={:?} self.flags={:?}\",\n-            predicate, flags, self.flags\n-        );\n+        trace!(predicate.flags=?flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {"}, {"sha": "308b4d2fefc71c7ade6cf71e8e84ddaf1377f0e2", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -98,14 +98,14 @@ pub trait Printer<'tcx>: Sized {\n \n     // Defaults (should not be overridden):\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn default_print_def_path(\n         self,\n         def_id: DefId,\n         substs: &'tcx [GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n-        debug!(\"default_print_def_path: def_id={:?}, substs={:?}\", def_id, substs);\n         let key = self.tcx().def_key(def_id);\n-        debug!(\"default_print_def_path: key={:?}\", key);\n+        debug!(?key);\n \n         match key.disambiguated_data.data {\n             DefPathData::CrateRoot => {"}, {"sha": "b8bca6363db802e7a62db0c5c98edda3fb0f35f3", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -2033,12 +2033,11 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         Ok(inner)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<'tcx, T>)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"prepare_late_bound_region_info(value: {:?})\", value);\n-\n         struct LateBoundRegionNameCollector<'a, 'tcx> {\n             tcx: TyCtxt<'tcx>,\n             used_region_names: &'a mut FxHashSet<Symbol>,\n@@ -2052,8 +2051,9 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n                 Some(self.tcx)\n             }\n \n+            #[instrument(skip(self), level = \"trace\")]\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                debug!(\"LateBoundRegionNameCollector::visit_region(r: {:?}, address: {:p})\", r, &r);\n+                trace!(\"address: {:p}\", r);\n                 if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n                     self.used_region_names.insert(name);\n                 } else if let ty::RePlaceholder(ty::PlaceholderRegion {\n@@ -2068,8 +2068,8 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n \n             // We collect types in order to prevent really large types from compiling for\n             // a really long time. See issue #83150 for why this is necessary.\n+            #[instrument(skip(self), level = \"trace\")]\n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                debug!(\"LateBoundRegionNameCollector::visit_ty(ty: {:?}\", ty);\n                 let not_previously_inserted = self.type_collector.insert(ty);\n                 if not_previously_inserted {\n                     ty.super_visit_with(self)"}, {"sha": "d4032cdf696cdc6e7c28c225e02b151538ed46ce", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -516,6 +516,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Expands the given impl trait type, stopping if the type is recursive.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn try_expand_impl_trait_type(\n         self,\n         def_id: DefId,\n@@ -532,6 +533,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         let expanded_type = visitor.expand_opaque_ty(def_id, substs).unwrap();\n+        trace!(?expanded_type);\n         if visitor.found_recursion { Err(expanded_type) } else { Ok(expanded_type) }\n     }\n }"}, {"sha": "474f4f2a79b2a7475a25344d49f0f9193b48d04c", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -602,6 +602,7 @@ impl<'tcx> AnalysisDomain<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n     type Idx = InitIndex;\n \n+    #[instrument(skip(self, trans), level = \"debug\")]\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -613,24 +614,19 @@ impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n         let init_loc_map = &move_data.init_loc_map;\n         let rev_lookup = &move_data.rev_lookup;\n \n-        debug!(\n-            \"statement {:?} at loc {:?} initializes move_indexes {:?}\",\n-            stmt, location, &init_loc_map[location]\n-        );\n+        debug!(\"initializes move_indexes {:?}\", &init_loc_map[location]);\n         trans.gen_all(init_loc_map[location].iter().copied());\n \n         if let mir::StatementKind::StorageDead(local) = stmt.kind {\n             // End inits for StorageDead, so that an immutable variable can\n             // be reinitialized on the next iteration of the loop.\n             let move_path_index = rev_lookup.find_local(local);\n-            debug!(\n-                \"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n-                stmt, location, &init_path_map[move_path_index]\n-            );\n+            debug!(\"clears the ever initialized status of {:?}\", init_path_map[move_path_index]);\n             trans.kill_all(init_path_map[move_path_index].iter().copied());\n         }\n     }\n \n+    #[instrument(skip(self, trans, _terminator), level = \"debug\")]\n     fn terminator_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -640,10 +636,8 @@ impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n         let (body, move_data) = (self.body, self.move_data());\n         let term = body[location.block].terminator();\n         let init_loc_map = &move_data.init_loc_map;\n-        debug!(\n-            \"terminator {:?} at loc {:?} initializes move_indexes {:?}\",\n-            term, location, &init_loc_map[location]\n-        );\n+        debug!(?term);\n+        debug!(\"initializes move_indexes {:?}\", init_loc_map[location]);\n         trans.gen_all(\n             init_loc_map[location]\n                 .iter()"}, {"sha": "eb6f302a11da825aa195388a3bc29df9333c4f20", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -2740,6 +2740,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         for input in inputs {\n             gather.visit_ty(input);\n         }\n+        trace!(?gather.anon_count);\n         let late_bound_vars = self.map.late_bound_vars.entry(hir_id).or_default();\n         let named_late_bound_vars = late_bound_vars.len() as u32;\n         late_bound_vars.extend(\n@@ -3028,6 +3029,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 NestedVisitorMap::None\n             }\n \n+            #[instrument(skip(self), level = \"trace\")]\n             fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n                 // If we enter a `BareFn`, then we enter a *new* binding scope\n                 if let hir::TyKind::BareFn(_) = ty.kind {\n@@ -3048,6 +3050,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 intravisit::walk_generic_args(self, path_span, generic_args)\n             }\n \n+            #[instrument(skip(self), level = \"trace\")]\n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n                 if lifetime_ref.is_elided() {\n                     self.anon_count += 1;"}, {"sha": "10eef7d31e6553cd04b8579170306078e3a9f896", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -20,6 +20,9 @@\n #![recursion_limit = \"256\"]\n #![allow(rustdoc::private_intra_doc_links)]\n \n+#[macro_use]\n+extern crate tracing;\n+\n pub use rustc_hir::def::{Namespace, PerNS};\n \n use Determinacy::*;"}, {"sha": "c2205462680fc88d48aa100d1c3f172752392e06", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -517,6 +517,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         debug!(?id_substs);\n         let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n             substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n+        debug!(\"map = {:#?}\", map);\n \n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n@@ -672,6 +673,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         self.tcx\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match r {\n             // Ignore bound regions and `'static` regions that appear in the\n@@ -1098,18 +1100,17 @@ fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hi\n ///\n /// Requires that trait definitions have been processed so that we can\n /// elaborate predicates and walk supertraits.\n+#[instrument(skip(tcx, predicates), level = \"debug\")]\n crate fn required_region_bounds(\n     tcx: TyCtxt<'tcx>,\n     erased_self_ty: Ty<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n ) -> Vec<ty::Region<'tcx>> {\n-    debug!(\"required_region_bounds(erased_self_ty={:?})\", erased_self_ty);\n-\n     assert!(!erased_self_ty.has_escaping_bound_vars());\n \n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n-            debug!(\"required_region_bounds(obligation={:?})\", obligation);\n+            debug!(?obligation);\n             match obligation.predicate.kind().skip_binder() {\n                 ty::PredicateKind::Projection(..)\n                 | ty::PredicateKind::Trait(..)"}, {"sha": "b751918463b31ef73a192880d31abc3e6bbe372d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -1195,13 +1195,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         false\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn report_fulfillment_error(\n         &self,\n         error: &FulfillmentError<'tcx>,\n         body_id: Option<hir::BodyId>,\n         fallback_has_occurred: bool,\n     ) {\n-        debug!(\"report_fulfillment_error({:?})\", error);\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n                 self.report_selection_error(\n@@ -1528,6 +1528,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         )\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn maybe_report_ambiguity(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1542,8 +1543,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let span = obligation.cause.span;\n \n         debug!(\n-            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n-            predicate, obligation, body_id, obligation.cause.code,\n+            ?predicate, ?obligation.cause.code,\n         );\n \n         // Ambiguity errors are often caused as fallout from earlier\n@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut err = match bound_predicate.skip_binder() {\n             ty::PredicateKind::Trait(data) => {\n                 let trait_ref = bound_predicate.rebind(data.trait_ref);\n-                debug!(\"trait_ref {:?}\", trait_ref);\n+                debug!(?trait_ref);\n \n                 if predicate.references_error() {\n                     return;"}, {"sha": "397f1da75ef01d5dfc69328e14ccb87742ad1091", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -220,6 +220,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.filter_impls(candidates.pop().unwrap().candidate, stack.obligation)\n     }\n \n+    #[instrument(skip(self, stack), level = \"debug\")]\n     pub(super) fn assemble_candidates<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,"}, {"sha": "8554723740fb0f33e173961567f31431fd71b64b", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -601,12 +601,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(ImplSourceGeneratorData { generator_def_id, substs, nested: obligations })\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn confirm_closure_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        debug!(?obligation, \"confirm_closure_candidate\");\n-\n         let kind = self\n             .tcx()\n             .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n@@ -680,6 +679,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// because these output type parameters should not affect the\n     /// selection of the impl. Therefore, if there is a mismatch, we\n     /// report an error to the user.\n+    #[instrument(skip(self), level = \"trace\")]\n     fn confirm_poly_trait_refs(\n         &mut self,\n         obligation_cause: ObligationCause<'tcx>,"}, {"sha": "af0c7c8f9566dfe65b54ee6acccf030c18e3e731", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -451,6 +451,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Evaluates the predicates in `predicates` recursively. Note that\n     /// this applies projections in the predicates, and therefore\n     /// is run within an inference probe.\n+    #[instrument(skip(self, stack), level = \"debug\")]\n     fn evaluate_predicates_recursively<'o, I>(\n         &mut self,\n         stack: TraitObligationStackList<'o, 'tcx>,\n@@ -460,7 +461,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,\n     {\n         let mut result = EvaluatedToOk;\n-        debug!(?predicates, \"evaluate_predicates_recursively\");\n         for obligation in predicates {\n             let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n             if let EvaluatedToErr = eval {\n@@ -683,13 +683,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result\n     }\n \n+    #[instrument(skip(self, previous_stack), level = \"debug\")]\n     fn evaluate_trait_predicate_recursively<'o>(\n         &mut self,\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         mut obligation: TraitObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        debug!(?obligation, \"evaluate_trait_predicate_recursively\");\n-\n         if !self.intercrate\n             && obligation.is_global(self.tcx())\n             && obligation\n@@ -701,7 +700,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // If a param env has no global bounds, global obligations do not\n             // depend on its particular value in order to work, so we can clear\n             // out the param env and get better caching.\n-            debug!(\"evaluate_trait_predicate_recursively - in global\");\n+            debug!(\"in global\");\n             obligation.param_env = obligation.param_env.without_caller_bounds();\n         }\n \n@@ -753,7 +752,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         } else {\n             debug!(?result, \"PROVISIONAL\");\n             debug!(\n-                \"evaluate_trait_predicate_recursively: caching provisionally because {:?} \\\n+                \"caching provisionally because {:?} \\\n                  is a cycle participant (at depth {}, reached depth {})\",\n                 fresh_trait_ref, stack.depth, reached_depth,\n             );\n@@ -2124,13 +2123,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn match_poly_trait_ref(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n-        debug!(?obligation, ?poly_trait_ref, \"match_poly_trait_ref\");\n-\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n@@ -2174,12 +2172,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn closure_trait_ref_unnormalized(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> ty::PolyTraitRef<'tcx> {\n-        debug!(?obligation, ?substs, \"closure_trait_ref_unnormalized\");\n         let closure_sig = substs.as_closure().sig();\n \n         debug!(?closure_sig);"}, {"sha": "27d76a6935904efbacd3f6e4e198a7984b525a9c", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -441,6 +441,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Checks that the correct number of generic arguments have been provided.\n     /// This is used both for datatypes and function calls.\n+    #[instrument(skip(tcx, gen_pos), level = \"debug\")]\n     pub(crate) fn check_generic_arg_count(\n         tcx: TyCtxt<'_>,\n         span: Span,\n@@ -452,11 +453,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         has_self: bool,\n         infer_args: bool,\n     ) -> GenericArgCountResult {\n-        debug!(\n-            \"check_generic_arg_count(span: {:?}, def_id: {:?}, seg: {:?}, gen_params: {:?}, gen_args: {:?})\",\n-            span, def_id, seg, gen_params, gen_args\n-        );\n-\n         let default_counts = gen_params.own_defaults();\n         let param_counts = gen_params.own_counts();\n \n@@ -556,9 +552,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut check_types_and_consts =\n             |expected_min, expected_max, provided, params_offset, args_offset| {\n                 debug!(\n-                    \"check_types_and_consts(expected_min: {:?}, expected_max: {:?}, \\\n-                        provided: {:?}, params_offset: {:?}, args_offset: {:?}\",\n-                    expected_min, expected_max, provided, params_offset, args_offset\n+                    ?expected_min,\n+                    ?expected_max,\n+                    ?provided,\n+                    ?params_offset,\n+                    ?args_offset,\n+                    \"check_types_and_consts\"\n                 );\n                 if (expected_min..=expected_max).contains(&provided) {\n                     return true;\n@@ -589,7 +588,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 };\n \n-                debug!(\"gen_args_info: {:?}\", gen_args_info);\n+                debug!(?gen_args_info);\n \n                 WrongNumberOfGenericArgs::new(\n                     tcx,\n@@ -614,8 +613,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     - default_counts.types\n                     - default_counts.consts\n             };\n-            debug!(\"expected_min: {:?}\", expected_min);\n-            debug!(\"arg_counts.lifetimes: {:?}\", gen_args.num_lifetime_params());\n+            debug!(?expected_min);\n+            debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n \n             check_types_and_consts(\n                 expected_min,"}, {"sha": "c1d14413554ac71e3b829e3b5961f7eb62fdff4d", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -70,6 +70,7 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n ///\n /// * ...\n /// * inherited: other fields inherited from the enclosing fn (if any)\n+#[instrument(skip(inherited, body), level = \"debug\")]\n pub(super) fn check_fn<'a, 'tcx>(\n     inherited: &'a Inherited<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -82,8 +83,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n     let mut fn_sig = fn_sig;\n \n-    debug!(\"check_fn(sig={:?}, fn_id={}, param_env={:?})\", fn_sig, fn_id, param_env);\n-\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);"}, {"sha": "410ac24b1f19c84a8659e5186f31f5c264db201d", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -33,6 +33,7 @@ struct ClosureSignatures<'tcx> {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    #[instrument(skip(self, expr, _capture, decl, body_id), level = \"debug\")]\n     pub fn check_expr_closure(\n         &self,\n         expr: &hir::Expr<'_>,\n@@ -42,7 +43,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         gen: Option<hir::Movability>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        debug!(\"check_expr_closure(expr={:?},expected={:?})\", expr, expected);\n+        trace!(\"decl = {:#?}\", decl);\n+        trace!(\"expr = {:#?}\", expr);\n \n         // It's always helpful for inference if we know the kind of\n         // closure sooner rather than later, so first examine the expected\n@@ -55,6 +57,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.check_closure(expr, expected_kind, decl, body, gen, expected_sig)\n     }\n \n+    #[instrument(skip(self, expr, body, decl), level = \"debug\")]\n     fn check_closure(\n         &self,\n         expr: &hir::Expr<'_>,\n@@ -64,14 +67,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         gen: Option<hir::Movability>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> Ty<'tcx> {\n-        debug!(\"check_closure(opt_kind={:?}, expected_sig={:?})\", opt_kind, expected_sig);\n-\n+        trace!(\"decl = {:#?}\", decl);\n         let expr_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n+        debug!(?expr_def_id);\n \n         let ClosureSignatures { bound_sig, liberated_sig } =\n             self.sig_of_closure(expr.hir_id, expr_def_id.to_def_id(), decl, body, expected_sig);\n \n-        debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n+        debug!(?bound_sig, ?liberated_sig);\n \n         let return_type_pre_known = !liberated_sig.output().is_ty_infer();\n \n@@ -130,10 +133,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             )\n         });\n \n-        debug!(\n-            \"check_closure: expr_def_id={:?}, sig={:?}, opt_kind={:?}\",\n-            expr_def_id, sig, opt_kind\n-        );\n+        debug!(?sig, ?opt_kind);\n \n         let closure_kind_ty = match opt_kind {\n             Some(kind) => kind.to_ty(self.tcx),\n@@ -159,19 +159,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let closure_type = self.tcx.mk_closure(expr_def_id.to_def_id(), closure_substs.substs);\n \n-        debug!(\"check_closure: expr.hir_id={:?} closure_type={:?}\", expr.hir_id, closure_type);\n+        debug!(?expr.hir_id, ?closure_type);\n \n         closure_type\n     }\n \n     /// Given the expected type, figures out what it can about this closure we\n     /// are about to type check:\n+    #[instrument(skip(self), level = \"debug\")]\n     fn deduce_expectations_from_expected_type(\n         &self,\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n-        debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\", expected_ty);\n-\n         match *expected_ty.kind() {\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n@@ -314,15 +313,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// If there is no expected signature, then we will convert the\n     /// types that the user gave into a signature.\n+    #[instrument(skip(self, hir_id, expr_def_id, decl, body), level = \"debug\")]\n     fn sig_of_closure_no_expectation(\n         &self,\n         hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ClosureSignatures<'tcx> {\n-        debug!(\"sig_of_closure_no_expectation()\");\n-\n         let bound_sig = self.supplied_sig_of_closure(hir_id, expr_def_id, decl, body);\n \n         self.closure_sigs(expr_def_id, body, bound_sig)\n@@ -375,6 +373,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - `expected_sig`: the expected signature (if any). Note that\n     ///   this is missing a binder: that is, there may be late-bound\n     ///   regions with depth 1, which are bound then by the closure.\n+    #[instrument(skip(self, hir_id, expr_def_id, decl, body), level = \"debug\")]\n     fn sig_of_closure_with_expectation(\n         &self,\n         hir_id: hir::HirId,\n@@ -383,8 +382,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        debug!(\"sig_of_closure_with_expectation(expected_sig={:?})\", expected_sig);\n-\n         // Watch out for some surprises and just ignore the\n         // expectation if things don't see to match up with what we\n         // expect.\n@@ -553,6 +550,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// types that the user gave into a signature.\n     ///\n     /// Also, record this closure signature for later.\n+    #[instrument(skip(self, decl, body), level = \"debug\")]\n     fn supplied_sig_of_closure(\n         &self,\n         hir_id: hir::HirId,\n@@ -562,10 +560,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n \n-        debug!(\n-            \"supplied_sig_of_closure(decl={:?}, body.generator_kind={:?})\",\n-            decl, body.generator_kind,\n-        );\n+        trace!(\"decl = {:#?}\", decl);\n+        debug!(?body.generator_kind);\n \n         let bound_vars = self.tcx.late_bound_vars(hir_id);\n \n@@ -578,7 +574,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // we expect the return type of the block to match that of the enclosing\n                 // function.\n                 Some(hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn)) => {\n-                    debug!(\"supplied_sig_of_closure: closure is async fn body\");\n+                    debug!(\"closure is async fn body\");\n                     self.deduce_future_output_from_obligations(expr_def_id).unwrap_or_else(|| {\n                         // AFAIK, deducing the future output\n                         // always succeeds *except* in error cases\n@@ -606,7 +602,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             bound_vars,\n         );\n \n-        debug!(\"supplied_sig_of_closure: result={:?}\", result);\n+        debug!(?result);\n \n         let c_result = self.inh.infcx.canonicalize_response(result);\n         self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);"}, {"sha": "79763942d05d96f6ce3011f5f1ae0ac733ba67d3", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -482,12 +482,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // &[T; n] or &mut [T; n] -> &[T]\n     // or &mut [T; n] -> &mut [T]\n     // or &Concrete -> &Trait, etc.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn coerce_unsized(&self, mut source: Ty<'tcx>, mut target: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsized(source={:?}, target={:?})\", source, target);\n-\n         source = self.shallow_resolve(source);\n         target = self.shallow_resolve(target);\n-        debug!(\"coerce_unsized: resolved source={:?} target={:?}\", source, target);\n+        debug!(?source, ?target);\n \n         // These 'if' statements require some explanation.\n         // The `CoerceUnsized` trait is special - it is only"}, {"sha": "dcfbaff7ec792f74935e91559725837b5777580f", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -59,6 +59,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.demand_suptype_with_origin(&self.misc(sp), expected, actual)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn demand_suptype_with_origin(\n         &self,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "602ecd34f831128f7ba8d93f2f6df7d2b62d65a5", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self, expr), level = \"debug\")]\n     pub(super) fn check_expr_with_expectation(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n@@ -254,12 +254,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n+    #[instrument(skip(self, expr), level = \"debug\")]\n     fn check_expr_kind(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        debug!(\"check_expr_kind(expected={:?}, expr={:?})\", expected, expr);\n+        trace!(\"expr={:#?}\", expr);\n \n         let tcx = self.tcx;\n         match expr.kind {"}, {"sha": "7b9629e534bf92348446f6ce5f9d5d73af35ce34", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 22, "deletions": 44, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -87,23 +87,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.resolve_vars_with_obligations_and_mutate_fulfillment(ty, |_| {})\n     }\n \n+    #[instrument(skip(self, mutate_fulfillment_errors), level = \"debug\")]\n     pub(in super::super) fn resolve_vars_with_obligations_and_mutate_fulfillment(\n         &self,\n         mut ty: Ty<'tcx>,\n         mutate_fulfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n     ) -> Ty<'tcx> {\n-        debug!(\"resolve_vars_with_obligations(ty={:?})\", ty);\n-\n         // No Infer()? Nothing needs doing.\n         if !ty.has_infer_types_or_consts() {\n-            debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n+            debug!(\"no inference var, nothing needs doing\");\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.resolve_vars_if_possible(ty);\n         if !ty.has_infer_types_or_consts() {\n-            debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n+            debug!(?ty);\n             return ty;\n         }\n \n@@ -114,7 +113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.select_obligations_where_possible(false, mutate_fulfillment_errors);\n         ty = self.resolve_vars_if_possible(ty);\n \n-        debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n+        debug!(?ty);\n         ty\n     }\n \n@@ -230,57 +229,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// This should be invoked **before any unifications have\n     /// occurred**, so that annotations like `Vec<_>` are preserved\n     /// properly.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn write_user_type_annotation_from_substs(\n         &self,\n         hir_id: hir::HirId,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n         user_self_ty: Option<UserSelfTy<'tcx>>,\n     ) {\n-        debug!(\n-            \"write_user_type_annotation_from_substs: hir_id={:?} def_id={:?} substs={:?} \\\n-             user_self_ty={:?} in fcx {}\",\n-            hir_id,\n-            def_id,\n-            substs,\n-            user_self_ty,\n-            self.tag(),\n-        );\n+        debug!(\"fcx {}\", self.tag());\n \n         if self.can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n             let canonicalized = self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n                 def_id,\n                 UserSubsts { substs, user_self_ty },\n             ));\n-            debug!(\"write_user_type_annotation_from_substs: canonicalized={:?}\", canonicalized);\n+            debug!(?canonicalized);\n             self.write_user_type_annotation(hir_id, canonicalized);\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn write_user_type_annotation(\n         &self,\n         hir_id: hir::HirId,\n         canonical_user_type_annotation: CanonicalUserType<'tcx>,\n     ) {\n-        debug!(\n-            \"write_user_type_annotation: hir_id={:?} canonical_user_type_annotation={:?} tag={}\",\n-            hir_id,\n-            canonical_user_type_annotation,\n-            self.tag(),\n-        );\n+        debug!(\"fcx {}\", self.tag());\n \n         if !canonical_user_type_annotation.is_identity() {\n             self.typeck_results\n                 .borrow_mut()\n                 .user_provided_types_mut()\n                 .insert(hir_id, canonical_user_type_annotation);\n         } else {\n-            debug!(\"write_user_type_annotation: skipping identity substs\");\n+            debug!(\"skipping identity substs\");\n         }\n     }\n \n+    #[instrument(skip(self, expr), level = \"debug\")]\n     pub fn apply_adjustments(&self, expr: &hir::Expr<'_>, adj: Vec<Adjustment<'tcx>>) {\n-        debug!(\"apply_adjustments(expr={:?}, adj={:?})\", expr, adj);\n+        debug!(\"expr = {:#?}\", expr);\n \n         if adj.is_empty() {\n             return;\n@@ -652,8 +641,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub(in super::super) fn select_all_obligations_or_error(&self) {\n-        debug!(\"select_all_obligations_or_error\");\n         if let Err(errors) = self\n             .fulfillment_cx\n             .borrow_mut()\n@@ -694,16 +683,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ret_ty.builtin_deref(true).unwrap()\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn self_type_matches_expected_vid(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         expected_vid: ty::TyVid,\n     ) -> bool {\n         let self_ty = self.shallow_resolve(trait_ref.skip_binder().self_ty());\n-        debug!(\n-            \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?}, expected_vid={:?})\",\n-            trait_ref, self_ty, expected_vid\n-        );\n+        debug!(?self_ty);\n+\n         match *self_ty.kind() {\n             ty::Infer(ty::TyVar(found_vid)) => {\n                 // FIXME: consider using `sub_root_var` here so we\n@@ -716,6 +704,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub(in super::super) fn obligations_for_self_ty<'b>(\n         &'b self,\n         self_ty: ty::TyVid,\n@@ -725,12 +714,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // FIXME: consider using `sub_root_var` here so we\n         // can see through subtyping.\n         let ty_var_root = self.root_var(self_ty);\n-        debug!(\n-            \"obligations_for_self_ty: self_ty={:?} ty_var_root={:?} pending_obligations={:?}\",\n-            self_ty,\n-            ty_var_root,\n-            self.fulfillment_cx.borrow().pending_obligations()\n-        );\n+        trace!(\"pending_obligations = {:#?}\", self.fulfillment_cx.borrow().pending_obligations());\n \n         self.fulfillment_cx\n             .borrow()\n@@ -780,6 +764,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Unifies the output type with the expected type early, for more coercions\n     /// and forward type information on the input expressions.\n+    #[instrument(skip(self, call_span), level = \"debug\")]\n     pub(in super::super) fn expected_inputs_for_expected_output(\n         &self,\n         call_span: Span,\n@@ -826,10 +811,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Ok(formal_args.iter().map(|&ty| self.resolve_vars_if_possible(ty)).collect())\n             })\n             .unwrap_or_default();\n-        debug!(\n-            \"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n-            formal_args, formal_ret, expect_args, expected_ret\n-        );\n+        debug!(?formal_args, ?formal_ret, ?expect_args, ?expected_ret);\n         expect_args\n     }\n \n@@ -1195,6 +1177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n+    #[instrument(skip(self, span), level = \"debug\")]\n     pub fn instantiate_value_path(\n         &self,\n         segments: &[hir::PathSegment<'_>],\n@@ -1203,11 +1186,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         hir_id: hir::HirId,\n     ) -> (Ty<'tcx>, Res) {\n-        debug!(\n-            \"instantiate_value_path(segments={:?}, self_ty={:?}, res={:?}, hir_id={})\",\n-            segments, self_ty, res, hir_id,\n-        );\n-\n         let tcx = self.tcx;\n \n         let path_segs = match res {\n@@ -1230,7 +1208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             Res::Def(DefKind::AssocFn | DefKind::AssocConst, def_id) => {\n                 let container = tcx.associated_item(def_id).container;\n-                debug!(\"instantiate_value_path: def_id={:?} container={:?}\", def_id, container);\n+                debug!(?def_id, ?container);\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n                         callee::check_legal_trait_for_method_call(tcx, span, None, span, trait_did)"}, {"sha": "1f2ccffa6f247f909c88b9220792f02777bb473b", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -122,6 +122,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InferBorrowKindVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Analysis starting point.\n+    #[instrument(skip(self, body), level = \"debug\")]\n     fn analyze_closure(\n         &self,\n         closure_hir_id: hir::HirId,\n@@ -130,8 +131,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         body: &'tcx hir::Body<'tcx>,\n         capture_clause: hir::CaptureBy,\n     ) {\n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_hir_id, body.id());\n-\n         // Extract the type of the closure.\n         let ty = self.node_ty(closure_hir_id);\n         let (closure_def_id, substs) = match *ty.kind() {\n@@ -1683,23 +1682,20 @@ struct InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n     fn adjust_upvar_borrow_kind_for_consume(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n         diag_expr_id: hir::HirId,\n     ) {\n-        debug!(\n-            \"adjust_upvar_borrow_kind_for_consume(place_with_id={:?}, diag_expr_id={:?})\",\n-            place_with_id, diag_expr_id\n-        );\n         let tcx = self.fcx.tcx;\n         let upvar_id = if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             upvar_id\n         } else {\n             return;\n         };\n \n-        debug!(\"adjust_upvar_borrow_kind_for_consume: upvar={:?}\", upvar_id);\n+        debug!(?upvar_id);\n \n         let usage_span = tcx.hir().span(diag_expr_id);\n \n@@ -1718,16 +1714,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n     /// to). If the place is based on a by-ref upvar, this implies that\n     /// the upvar must be borrowed using an `&mut` borrow.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn adjust_upvar_borrow_kind_for_mut(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n         diag_expr_id: hir::HirId,\n     ) {\n-        debug!(\n-            \"adjust_upvar_borrow_kind_for_mut(place_with_id={:?}, diag_expr_id={:?})\",\n-            place_with_id, diag_expr_id\n-        );\n-\n         if let PlaceBase::Upvar(_) = place_with_id.place.base {\n             // Raw pointers don't inherit mutability\n             if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n@@ -1737,16 +1729,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn adjust_upvar_borrow_kind_for_unique(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n         diag_expr_id: hir::HirId,\n     ) {\n-        debug!(\n-            \"adjust_upvar_borrow_kind_for_unique(place_with_id={:?}, diag_expr_id={:?})\",\n-            place_with_id, diag_expr_id\n-        );\n-\n         if let PlaceBase::Upvar(_) = place_with_id.place.base {\n             if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n                 // Raw pointers don't inherit mutability.\n@@ -1783,6 +1771,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     /// moving from left to right as needed (but never right to left).\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn adjust_upvar_borrow_kind(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n@@ -1791,10 +1780,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     ) {\n         let curr_capture_info = self.capture_information[&place_with_id.place];\n \n-        debug!(\n-            \"adjust_upvar_borrow_kind(place={:?}, diag_expr_id={:?}, capture_info={:?}, kind={:?})\",\n-            place_with_id, diag_expr_id, curr_capture_info, kind\n-        );\n+        debug!(?curr_capture_info);\n \n         if let ty::UpvarCapture::ByValue(_) = curr_capture_info.capture_kind {\n             // It's already captured by value, we don't need to do anything here\n@@ -1814,6 +1800,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         };\n     }\n \n+    #[instrument(skip(self, diag_expr_id), level = \"debug\")]\n     fn init_capture_info_for_place(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n@@ -1840,7 +1827,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n             self.capture_information.insert(place_with_id.place.clone(), capture_info);\n         } else {\n-            debug!(\"Not upvar: {:?}\", place_with_id);\n+            debug!(\"Not upvar\");\n         }\n     }\n }\n@@ -1867,27 +1854,22 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n-        debug!(\"consume(place_with_id={:?}, diag_expr_id={:?})\", place_with_id, diag_expr_id);\n-\n         if !self.capture_information.contains_key(&place_with_id.place) {\n             self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n         }\n \n         self.adjust_upvar_borrow_kind_for_consume(&place_with_id, diag_expr_id);\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn borrow(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n         diag_expr_id: hir::HirId,\n         bk: ty::BorrowKind,\n     ) {\n-        debug!(\n-            \"borrow(place_with_id={:?}, diag_expr_id={:?}, bk={:?})\",\n-            place_with_id, diag_expr_id, bk\n-        );\n-\n         // The region here will get discarded/ignored\n         let dummy_capture_kind =\n             ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: bk, region: &ty::ReErased });\n@@ -1924,9 +1906,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n-        debug!(\"mutate(assignee_place={:?}, diag_expr_id={:?})\", assignee_place, diag_expr_id);\n-\n         self.borrow(assignee_place, diag_expr_id, ty::BorrowKind::MutBorrow);\n     }\n }"}, {"sha": "b267909be7bd9b2ad49da63d5fe8c7e290930e1f", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5aa063d8e9808eacd27a0bf75a85495ff01bd4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=9b5aa063d8e9808eacd27a0bf75a85495ff01bd4", "patch": "@@ -497,6 +497,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             fcx_typeck_results.generator_interior_types.clone();\n     }\n \n+    #[instrument(skip(self, span), level = \"debug\")]\n     fn visit_opaque_types(&mut self, span: Span) {\n         let opaque_types = self.fcx.infcx.inner.borrow().opaque_types.clone();\n         for (opaque_type_key, opaque_defn) in opaque_types {\n@@ -564,6 +565,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, span), level = \"debug\")]\n     fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         // Export associated path extensions and method resolutions.\n         if let Some(def) =\n@@ -579,7 +581,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         let n_ty = self.fcx.node_ty(hir_id);\n         let n_ty = self.resolve(n_ty, &span);\n         self.write_ty_to_typeck_results(hir_id, n_ty);\n-        debug!(\"node {:?} has type {:?}\", hir_id, n_ty);\n+        debug!(?n_ty);\n \n         // Resolve any substitutions\n         if let Some(substs) = self.fcx.typeck_results.borrow().node_substs_opt(hir_id) {\n@@ -590,31 +592,33 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, span), level = \"debug\")]\n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n         let adjustment = self.fcx.typeck_results.borrow_mut().adjustments_mut().remove(hir_id);\n         match adjustment {\n             None => {\n-                debug!(\"no adjustments for node {:?}\", hir_id);\n+                debug!(\"no adjustments for node\");\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(adjustment, &span);\n-                debug!(\"adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n+                debug!(?resolved_adjustment);\n                 self.typeck_results.adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n \n+    #[instrument(skip(self, span), level = \"debug\")]\n     fn visit_pat_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n         let adjustment = self.fcx.typeck_results.borrow_mut().pat_adjustments_mut().remove(hir_id);\n         match adjustment {\n             None => {\n-                debug!(\"no pat_adjustments for node {:?}\", hir_id);\n+                debug!(\"no pat_adjustments for node\");\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(adjustment, &span);\n-                debug!(\"pat_adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n+                debug!(?resolved_adjustment);\n                 self.typeck_results.pat_adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n         }"}]}