{"sha": "60ca03e8aa00956d1511969da5f1844a02483bc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwY2EwM2U4YWEwMDk1NmQxNTExOTY5ZGE1ZjE4NDRhMDI0ODNiYzk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-13T17:07:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-13T17:07:04Z"}, "message": "Merge #9252\n\n9252: internal: refactor mismatched args count diagnostic r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "7729eb4ae1ef7a4cf0e0be42dfc2ef36c65cec1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7729eb4ae1ef7a4cf0e0be42dfc2ef36c65cec1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60ca03e8aa00956d1511969da5f1844a02483bc9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgxjs4CRBK7hj4Ov3rIwAAExgIAE+zDA9LTZYgZGLyVoiaPmfG\nK/2PmpDwRZvoV0jMqjBHyYj1Is6OIEcMNaiJ/o+pA/40YWK8NJ6hjDvc0e3I+fj0\nsGIQYtKdDm75Qv6dTL/p4WOvVLUuuQz5A8ZYKZuNFOXxjUNMKGPFHPAP0s3Lgnxi\n5a+uVmuAJoLi5eRP7atHdq8QnsRj1vLIwF1xiWaOIx8yjNGYww1wJi/1kJtl0Ghs\nWsKcNbYH4HtqBqiWl6kNGmYL5TGg5HkCLMr04D80G80KHY/TShZrmpOmrRr15AOf\nEOGa4Ay62Ys+A1zPndLPj1OdB+lZarbYwIzUTdeiTv83ZsImIZsfGbJxT6qbMTw=\n=qhB9\n-----END PGP SIGNATURE-----\n", "payload": "tree 7729eb4ae1ef7a4cf0e0be42dfc2ef36c65cec1e\nparent 8e5f469da8d5ed0e4c0519c883498097aeadd7ac\nparent 8d391ec981562785ec92ce3afe950972c523f925\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623604024 +0000\ncommitter GitHub <noreply@github.com> 1623604024 +0000\n\nMerge #9252\n\n9252: internal: refactor mismatched args count diagnostic r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60ca03e8aa00956d1511969da5f1844a02483bc9", "html_url": "https://github.com/rust-lang/rust/commit/60ca03e8aa00956d1511969da5f1844a02483bc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60ca03e8aa00956d1511969da5f1844a02483bc9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e5f469da8d5ed0e4c0519c883498097aeadd7ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e5f469da8d5ed0e4c0519c883498097aeadd7ac", "html_url": "https://github.com/rust-lang/rust/commit/8e5f469da8d5ed0e4c0519c883498097aeadd7ac"}, {"sha": "8d391ec981562785ec92ce3afe950972c523f925", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d391ec981562785ec92ce3afe950972c523f925", "html_url": "https://github.com/rust-lang/rust/commit/8d391ec981562785ec92ce3afe950972c523f925"}], "stats": {"total": 1514, "additions": 752, "deletions": 762}, "files": [{"sha": "f839616ce43148c9d38a4390f60bf85e9856d3fd", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 111, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -32,14 +32,19 @@ macro_rules! diagnostics {\n }\n \n diagnostics![\n-    UnresolvedModule,\n+    BreakOutsideOfLoop,\n+    InactiveCode,\n+    MacroError,\n+    MismatchedArgCount,\n+    MissingFields,\n+    MissingUnsafe,\n+    NoSuchField,\n+    UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n     UnresolvedImport,\n     UnresolvedMacroCall,\n+    UnresolvedModule,\n     UnresolvedProcMacro,\n-    MacroError,\n-    MissingFields,\n-    InactiveCode,\n ];\n \n #[derive(Debug)]\n@@ -88,101 +93,22 @@ pub struct MacroError {\n \n #[derive(Debug)]\n pub struct UnimplementedBuiltinMacro {\n-    pub file: HirFileId,\n-    pub node: SyntaxNodePtr,\n-}\n-\n-impl Diagnostic for UnimplementedBuiltinMacro {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unimplemented-builtin-macro\")\n-    }\n-\n-    fn message(&self) -> String {\n-        \"unimplemented built-in macro\".to_string()\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone())\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n+    pub node: InFile<SyntaxNodePtr>,\n }\n \n-// Diagnostic: no-such-field\n-//\n-// This diagnostic is triggered if created structure does not have field provided in record.\n #[derive(Debug)]\n pub struct NoSuchField {\n-    pub file: HirFileId,\n-    pub field: AstPtr<ast::RecordExprField>,\n+    pub field: InFile<AstPtr<ast::RecordExprField>>,\n }\n \n-impl Diagnostic for NoSuchField {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"no-such-field\")\n-    }\n-\n-    fn message(&self) -> String {\n-        \"no such field\".to_string()\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.field.clone().into())\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: break-outside-of-loop\n-//\n-// This diagnostic is triggered if the `break` keyword is used outside of a loop.\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n }\n \n-impl Diagnostic for BreakOutsideOfLoop {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"break-outside-of-loop\")\n-    }\n-    fn message(&self) -> String {\n-        \"break outside of loop\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: missing-unsafe\n-//\n-// This diagnostic is triggered if an operation marked as `unsafe` is used outside of an `unsafe` function or block.\n #[derive(Debug)]\n pub struct MissingUnsafe {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n-}\n-\n-impl Diagnostic for MissingUnsafe {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-unsafe\")\n-    }\n-    fn message(&self) -> String {\n-        format!(\"This operation is unsafe and requires an unsafe function or block\")\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n }\n \n #[derive(Debug)]\n@@ -218,36 +144,13 @@ impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n     }\n }\n \n-// Diagnostic: mismatched-arg-count\n-//\n-// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n-    pub file: HirFileId,\n-    pub call_expr: AstPtr<ast::Expr>,\n+    pub call_expr: InFile<AstPtr<ast::Expr>>,\n     pub expected: usize,\n     pub found: usize,\n }\n \n-impl Diagnostic for MismatchedArgCount {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"mismatched-arg-count\")\n-    }\n-    fn message(&self) -> String {\n-        let s = if self.expected == 1 { \"\" } else { \"s\" };\n-        format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.call_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-    fn is_experimental(&self) -> bool {\n-        true\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct RemoveThisSemicolon {\n     pub file: HirFileId,"}, {"sha": "c1af5f0978acac937143ad3ed382b0ce857c0245", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -606,8 +606,12 @@ impl Module {\n                     let node = ast.to_node(db.upcast());\n                     // Must have a name, otherwise we wouldn't emit it.\n                     let name = node.name().expect(\"unimplemented builtin macro with no name\");\n-                    let ptr = SyntaxNodePtr::from(AstPtr::new(&name));\n-                    sink.push(UnimplementedBuiltinMacro { file: ast.file_id, node: ptr });\n+                    acc.push(\n+                        UnimplementedBuiltinMacro {\n+                            node: ast.with_value(SyntaxNodePtr::from(AstPtr::new(&name))),\n+                        }\n+                        .into(),\n+                    );\n                 }\n             }\n         }\n@@ -1073,22 +1077,20 @@ impl Function {\n             match d {\n                 hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n                     let field = source_map.field_syntax(*expr);\n-                    sink.push(NoSuchField { file: field.file_id, field: field.value })\n+                    acc.push(NoSuchField { field }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n-                    let ptr = source_map\n+                    let expr = source_map\n                         .expr_syntax(*expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n-                    sink.push(BreakOutsideOfLoop { file: ptr.file_id, expr: ptr.value })\n+                    acc.push(BreakOutsideOfLoop { expr }.into())\n                 }\n             }\n         }\n \n         for expr in hir_ty::diagnostics::missing_unsafe(db, self.id.into()) {\n             match source_map.expr_syntax(expr) {\n-                Ok(in_file) => {\n-                    sink.push(MissingUnsafe { file: in_file.file_id, expr: in_file.value })\n-                }\n+                Ok(expr) => acc.push(MissingUnsafe { expr }.into()),\n                 Err(SyntheticSyntax) => {\n                     // FIXME: Here and eslwhere in this file, the `expr` was\n                     // desugared, report or assert that this doesn't happen.\n@@ -1174,12 +1176,9 @@ impl Function {\n                 }\n                 BodyValidationDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     match source_map.expr_syntax(call_expr) {\n-                        Ok(source_ptr) => sink.push(MismatchedArgCount {\n-                            file: source_ptr.file_id,\n-                            call_expr: source_ptr.value,\n-                            expected,\n-                            found,\n-                        }),\n+                        Ok(source_ptr) => acc.push(\n+                            MismatchedArgCount { call_expr: source_ptr, expected, found }.into(),\n+                        ),\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }"}, {"sha": "4c92d0cf4c1522008baa3d62fa3a9d8c6cfa692b", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 482, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -4,14 +4,19 @@\n //! macro-expanded files, but we need to present them to the users in terms of\n //! original files. So we need to map the ranges.\n \n-mod unresolved_module;\n+mod break_outside_of_loop;\n+mod inactive_code;\n+mod macro_error;\n+mod mismatched_arg_count;\n+mod missing_fields;\n+mod missing_unsafe;\n+mod no_such_field;\n+mod unimplemented_builtin_macro;\n mod unresolved_extern_crate;\n mod unresolved_import;\n mod unresolved_macro_call;\n+mod unresolved_module;\n mod unresolved_proc_macro;\n-mod macro_error;\n-mod inactive_code;\n-mod missing_fields;\n \n mod fixes;\n mod field_shorthand;\n@@ -160,9 +165,6 @@ pub(crate) fn diagnostics(\n         .on::<hir::diagnostics::MissingOkOrSomeInTailExpr, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n         })\n-        .on::<hir::diagnostics::NoSuchField, _>(|d| {\n-            res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n-        })\n         .on::<hir::diagnostics::RemoveThisSemicolon, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n         })\n@@ -185,11 +187,6 @@ pub(crate) fn diagnostics(\n                     .with_code(Some(d.code())),\n             );\n         })\n-        .on::<hir::diagnostics::UnimplementedBuiltinMacro, _>(|d| {\n-            let display_range = sema.diagnostics_display_range(d.display_source()).range;\n-            res.borrow_mut()\n-                .push(Diagnostic::hint(display_range, d.message()).with_code(Some(d.code())));\n-        })\n         // Only collect experimental diagnostics when they're enabled.\n         .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n         .filter(|diag| !config.disabled.contains(diag.code().as_str()));\n@@ -224,13 +221,18 @@ pub(crate) fn diagnostics(\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n-            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::unresolved_module(&ctx, &d),\n+            AnyDiagnostic::BreakOutsideOfLoop(d) => break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n+            AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n+            AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n+            AnyDiagnostic::MissingUnsafe(d) => missing_unsafe::missing_unsafe(&ctx, &d),\n+            AnyDiagnostic::MismatchedArgCount(d) => mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n+            AnyDiagnostic::NoSuchField(d) => no_such_field::no_such_field(&ctx, &d),\n+            AnyDiagnostic::UnimplementedBuiltinMacro(d) => unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n             AnyDiagnostic::UnresolvedImport(d) => unresolved_import::unresolved_import(&ctx, &d),\n             AnyDiagnostic::UnresolvedMacroCall(d) => unresolved_macro_call::unresolved_macro_call(&ctx, &d),\n+            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::unresolved_module(&ctx, &d),\n             AnyDiagnostic::UnresolvedProcMacro(d) => unresolved_proc_macro::unresolved_proc_macro(&ctx, &d),\n-            AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n-            AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n \n             AnyDiagnostic::InactiveCode(d) => match inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,\n@@ -715,223 +717,6 @@ mod foo;\n         );\n     }\n \n-    #[test]\n-    fn break_outside_of_loop() {\n-        check_diagnostics(\n-            r#\"\n-fn foo() { break; }\n-         //^^^^^ break outside of loop\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-struct S { foo: i32, bar: () }\n-impl S {\n-    fn new() -> S {\n-        S {\n-      //^ Missing structure fields:\n-      //|    - bar\n-            foo: 92,\n-            baz: 62,\n-          //^^^^^^^ no such field\n-        }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-    #[test]\n-    fn no_such_field_with_feature_flag_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-struct MyStruct {\n-    my_val: usize,\n-    #[cfg(feature = \"foo\")]\n-    bar: bool,\n-}\n-\n-impl MyStruct {\n-    #[cfg(feature = \"foo\")]\n-    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n-        Self { my_val, bar }\n-    }\n-    #[cfg(not(feature = \"foo\"))]\n-    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n-        Self { my_val }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_enum_with_feature_flag_diagnostics() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-enum Foo {\n-    #[cfg(not(feature = \"foo\"))]\n-    Buz,\n-    #[cfg(feature = \"foo\")]\n-    Bar,\n-    Baz\n-}\n-\n-fn test_fn(f: Foo) {\n-    match f {\n-        Foo::Bar => {},\n-        Foo::Baz => {},\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:foo cfg:feature=foo\n-struct S {\n-    #[cfg(feature = \"foo\")]\n-    foo: u32,\n-    #[cfg(not(feature = \"foo\"))]\n-    bar: u32,\n-}\n-\n-impl S {\n-    #[cfg(feature = \"foo\")]\n-    fn new(foo: u32) -> Self {\n-        Self { foo }\n-    }\n-    #[cfg(not(feature = \"foo\"))]\n-    fn new(bar: u32) -> Self {\n-        Self { bar }\n-    }\n-    fn new2(bar: u32) -> Self {\n-        #[cfg(feature = \"foo\")]\n-        { Self { foo: bar } }\n-        #[cfg(not(feature = \"foo\"))]\n-        { Self { bar } }\n-    }\n-    fn new2(val: u32) -> Self {\n-        Self {\n-            #[cfg(feature = \"foo\")]\n-            foo: val,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: val,\n-        }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_such_field_with_type_macro() {\n-        check_diagnostics(\n-            r#\"\n-macro_rules! Type { () => { u32 }; }\n-struct Foo { bar: Type![] }\n-\n-impl Foo {\n-    fn new() -> Self {\n-        Foo { bar: 0 }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn missing_unsafe_diagnostic_with_raw_ptr() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    let x = &5 as *const usize;\n-    unsafe { let y = *x; }\n-    let z = *x;\n-}         //^^ This operation is unsafe and requires an unsafe function or block\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn missing_unsafe_diagnostic_with_unsafe_call() {\n-        check_diagnostics(\n-            r#\"\n-struct HasUnsafe;\n-\n-impl HasUnsafe {\n-    unsafe fn unsafe_fn(&self) {\n-        let x = &5 as *const usize;\n-        let y = *x;\n-    }\n-}\n-\n-unsafe fn unsafe_fn() {\n-    let x = &5 as *const usize;\n-    let y = *x;\n-}\n-\n-fn main() {\n-    unsafe_fn();\n-  //^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n-    HasUnsafe.unsafe_fn();\n-  //^^^^^^^^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n-    unsafe {\n-        unsafe_fn();\n-        HasUnsafe.unsafe_fn();\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn missing_unsafe_diagnostic_with_static_mut() {\n-        check_diagnostics(\n-            r#\"\n-struct Ty {\n-    a: u8,\n-}\n-\n-static mut STATIC_MUT: Ty = Ty { a: 0 };\n-\n-fn main() {\n-    let x = STATIC_MUT.a;\n-          //^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n-    unsafe {\n-        let x = STATIC_MUT.a;\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_missing_unsafe_diagnostic_with_safe_intrinsic() {\n-        check_diagnostics(\n-            r#\"\n-extern \"rust-intrinsic\" {\n-    pub fn bitreverse(x: u32) -> u32; // Safe intrinsic\n-    pub fn floorf32(x: f32) -> f32; // Unsafe intrinsic\n-}\n-\n-fn main() {\n-    let _ = bitreverse(12);\n-    let _ = floorf32(12.0);\n-          //^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n-}\n-\"#,\n-        );\n-    }\n-\n     // Register the required standard library types to make the tests work\n     fn add_filter_map_with_find_next_boilerplate(body: &str) -> String {\n         let prefix = r#\"\n@@ -1053,256 +838,6 @@ fn x(a: S) {\n         )\n     }\n \n-    #[test]\n-    fn simple_free_fn_zero() {\n-        check_diagnostics(\n-            r#\"\n-fn zero() {}\n-fn f() { zero(1); }\n-       //^^^^^^^ Expected 0 arguments, found 1\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-fn zero() {}\n-fn f() { zero(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn simple_free_fn_one() {\n-        check_diagnostics(\n-            r#\"\n-fn one(arg: u8) {}\n-fn f() { one(); }\n-       //^^^^^ Expected 1 argument, found 0\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-fn one(arg: u8) {}\n-fn f() { one(1); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_as_fn() {\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self) {} }\n-\n-fn f() {\n-    S::method();\n-} //^^^^^^^^^^^ Expected 1 argument, found 0\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self) {} }\n-\n-fn f() {\n-    S::method(&S);\n-    S.method();\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_with_arg() {\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self, arg: u8) {} }\n-\n-            fn f() {\n-                S.method();\n-            } //^^^^^^^^^^ Expected 1 argument, found 0\n-            \"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self, arg: u8) {} }\n-\n-fn f() {\n-    S::method(&S, 0);\n-    S.method(1);\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_unknown_receiver() {\n-        // note: this is incorrect code, so there might be errors on this in the\n-        // future, but we shouldn't emit an argument count diagnostic here\n-        check_diagnostics(\n-            r#\"\n-trait Foo { fn method(&self, arg: usize) {} }\n-\n-fn f() {\n-    let x;\n-    x.method();\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_struct() {\n-        check_diagnostics(\n-            r#\"\n-struct Tup(u8, u16);\n-fn f() {\n-    Tup(0);\n-} //^^^^^^ Expected 2 arguments, found 1\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn enum_variant() {\n-        check_diagnostics(\n-            r#\"\n-enum En { Variant(u8, u16), }\n-fn f() {\n-    En::Variant(0);\n-} //^^^^^^^^^^^^^^ Expected 2 arguments, found 1\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn enum_variant_type_macro() {\n-        check_diagnostics(\n-            r#\"\n-macro_rules! Type {\n-    () => { u32 };\n-}\n-enum Foo {\n-    Bar(Type![])\n-}\n-impl Foo {\n-    fn new() {\n-        Foo::Bar(0);\n-        Foo::Bar(0, 1);\n-      //^^^^^^^^^^^^^^ Expected 1 argument, found 2\n-        Foo::Bar();\n-      //^^^^^^^^^^ Expected 1 argument, found 0\n-    }\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn varargs() {\n-        check_diagnostics(\n-            r#\"\n-extern \"C\" {\n-    fn fixed(fixed: u8);\n-    fn varargs(fixed: u8, ...);\n-    fn varargs2(...);\n-}\n-\n-fn f() {\n-    unsafe {\n-        fixed(0);\n-        fixed(0, 1);\n-      //^^^^^^^^^^^ Expected 1 argument, found 2\n-        varargs(0);\n-        varargs(0, 1);\n-        varargs2();\n-        varargs2(0);\n-        varargs2(0, 1);\n-    }\n-}\n-        \"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn arg_count_lambda() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    let f = |()| ();\n-    f();\n-  //^^^ Expected 1 argument, found 0\n-    f(());\n-    f((), ());\n-  //^^^^^^^^^ Expected 1 argument, found 2\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn cfgd_out_call_arguments() {\n-        check_diagnostics(\n-            r#\"\n-struct C(#[cfg(FALSE)] ());\n-impl C {\n-    fn new() -> Self {\n-        Self(\n-            #[cfg(FALSE)]\n-            (),\n-        )\n-    }\n-\n-    fn method(&self) {}\n-}\n-\n-fn main() {\n-    C::new().method(#[cfg(FALSE)] 0);\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn cfgd_out_fn_params() {\n-        check_diagnostics(\n-            r#\"\n-fn foo(#[cfg(NEVER)] x: ()) {}\n-\n-struct S;\n-\n-impl S {\n-    fn method(#[cfg(NEVER)] self) {}\n-    fn method2(#[cfg(NEVER)] self, arg: u8) {}\n-    fn method3(self, #[cfg(NEVER)] arg: u8) {}\n-}\n-\n-extern \"C\" {\n-    fn fixed(fixed: u8, #[cfg(NEVER)] ...);\n-    fn varargs(#[cfg(not(NEVER))] ...);\n-}\n-\n-fn main() {\n-    foo();\n-    S::method();\n-    S::method2(0);\n-    S::method3(S);\n-    S.method3();\n-    unsafe {\n-        fixed(0);\n-        varargs(1, 2, 3);\n-    }\n-}\n-            \"#,\n-        )\n-    }\n-\n     #[test]\n     fn missing_semicolon() {\n         check_diagnostics("}, {"sha": "80e68f3cc03d62bb72ee415641a7f7cc735d7a9a", "filename": "crates/ide/src/diagnostics/break_outside_of_loop.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fbreak_outside_of_loop.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -0,0 +1,30 @@\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: break-outside-of-loop\n+//\n+// This diagnostic is triggered if the `break` keyword is used outside of a loop.\n+pub(super) fn break_outside_of_loop(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::BreakOutsideOfLoop,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"break-outside-of-loop\",\n+        \"break outside of loop\",\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn break_outside_of_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() { break; }\n+         //^^^^^ break outside of loop\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "crates/ide/src/diagnostics/fixes/create_field.rs", "status": "modified", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -1,156 +1 @@\n-use hir::{db::AstDatabase, diagnostics::NoSuchField, HasSource, HirDisplay, Semantics};\n-use ide_db::{base_db::FileId, source_change::SourceChange, RootDatabase};\n-use syntax::{\n-    ast::{self, edit::IndentLevel, make},\n-    AstNode,\n-};\n-use text_edit::TextEdit;\n \n-use crate::{\n-    diagnostics::{fix, DiagnosticWithFixes},\n-    Assist, AssistResolveStrategy,\n-};\n-impl DiagnosticWithFixes for NoSuchField {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        missing_record_expr_field_fixes(\n-            sema,\n-            self.file.original_file(sema.db),\n-            &self.field.to_node(&root),\n-        )\n-    }\n-}\n-\n-fn missing_record_expr_field_fixes(\n-    sema: &Semantics<RootDatabase>,\n-    usage_file_id: FileId,\n-    record_expr_field: &ast::RecordExprField,\n-) -> Option<Vec<Assist>> {\n-    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n-    let def_id = sema.resolve_variant(record_lit)?;\n-    let module;\n-    let def_file_id;\n-    let record_fields = match def_id {\n-        hir::VariantDef::Struct(s) => {\n-            module = s.module(sema.db);\n-            let source = s.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-        hir::VariantDef::Union(u) => {\n-            module = u.module(sema.db);\n-            let source = u.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            source.value.record_field_list()?\n-        }\n-        hir::VariantDef::Variant(e) => {\n-            module = e.module(sema.db);\n-            let source = e.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-    };\n-    let def_file_id = def_file_id.original_file(sema.db);\n-\n-    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n-    if new_field_type.is_unknown() {\n-        return None;\n-    }\n-    let new_field = make::record_field(\n-        None,\n-        make::name(&record_expr_field.field_name()?.text()),\n-        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n-    );\n-\n-    let last_field = record_fields.fields().last()?;\n-    let last_field_syntax = last_field.syntax();\n-    let indent = IndentLevel::from_node(last_field_syntax);\n-\n-    let mut new_field = new_field.to_string();\n-    if usage_file_id != def_file_id {\n-        new_field = format!(\"pub(crate) {}\", new_field);\n-    }\n-    new_field = format!(\"\\n{}{}\", indent, new_field);\n-\n-    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n-    if needs_comma {\n-        new_field = format!(\",{}\", new_field);\n-    }\n-\n-    let source_change = SourceChange::from_text_edit(\n-        def_file_id,\n-        TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n-    );\n-\n-    return Some(vec![fix(\n-        \"create_field\",\n-        \"Create field\",\n-        source_change,\n-        record_expr_field.syntax().text_range(),\n-    )]);\n-\n-    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n-        match field_def_list {\n-            ast::FieldList::RecordFieldList(it) => Some(it),\n-            ast::FieldList::TupleFieldList(_) => None,\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_fix;\n-\n-    #[test]\n-    fn test_add_field_from_usage() {\n-        check_fix(\n-            r\"\n-fn main() {\n-    Foo { bar: 3, baz$0: false};\n-}\n-struct Foo {\n-    bar: i32\n-}\n-\",\n-            r\"\n-fn main() {\n-    Foo { bar: 3, baz: false};\n-}\n-struct Foo {\n-    bar: i32,\n-    baz: bool\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_add_field_in_other_file_from_usage() {\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-mod foo;\n-\n-fn main() {\n-    foo::Foo { bar: 3, $0baz: false};\n-}\n-//- /foo.rs\n-struct Foo {\n-    bar: i32\n-}\n-\"#,\n-            r#\"\n-struct Foo {\n-    bar: i32,\n-    pub(crate) baz: bool\n-}\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "08e1cfa5fccecd20dd368254df690b88a0005e8e", "filename": "crates/ide/src/diagnostics/mismatched_arg_count.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmismatched_arg_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmismatched_arg_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmismatched_arg_count.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -0,0 +1,272 @@\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: mismatched-arg-count\n+//\n+// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n+pub(super) fn mismatched_arg_count(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::MismatchedArgCount,\n+) -> Diagnostic {\n+    let s = if d.expected == 1 { \"\" } else { \"s\" };\n+    let message = format!(\"expected {} argument{}, found {}\", d.expected, s, d.found);\n+    Diagnostic::new(\n+        \"mismatched-arg-count\",\n+        message,\n+        ctx.sema.diagnostics_display_range(d.call_expr.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn simple_free_fn_zero() {\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(1); }\n+       //^^^^^^^ expected 0 arguments, found 1\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_free_fn_one() {\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(); }\n+       //^^^^^ expected 1 argument, found 0\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(1); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_as_fn() {\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method();\n+} //^^^^^^^^^^^ expected 1 argument, found 0\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method(&S);\n+    S.method();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_arg() {\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n+\n+            fn f() {\n+                S.method();\n+            } //^^^^^^^^^^ expected 1 argument, found 0\n+            \"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n+\n+fn f() {\n+    S::method(&S, 0);\n+    S.method(1);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_unknown_receiver() {\n+        // note: this is incorrect code, so there might be errors on this in the\n+        // future, but we shouldn't emit an argument count diagnostic here\n+        check_diagnostics(\n+            r#\"\n+trait Foo { fn method(&self, arg: usize) {} }\n+\n+fn f() {\n+    let x;\n+    x.method();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct() {\n+        check_diagnostics(\n+            r#\"\n+struct Tup(u8, u16);\n+fn f() {\n+    Tup(0);\n+} //^^^^^^ expected 2 arguments, found 1\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn enum_variant() {\n+        check_diagnostics(\n+            r#\"\n+enum En { Variant(u8, u16), }\n+fn f() {\n+    En::Variant(0);\n+} //^^^^^^^^^^^^^^ expected 2 arguments, found 1\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn enum_variant_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type {\n+    () => { u32 };\n+}\n+enum Foo {\n+    Bar(Type![])\n+}\n+impl Foo {\n+    fn new() {\n+        Foo::Bar(0);\n+        Foo::Bar(0, 1);\n+      //^^^^^^^^^^^^^^ expected 1 argument, found 2\n+        Foo::Bar();\n+      //^^^^^^^^^^ expected 1 argument, found 0\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn varargs() {\n+        check_diagnostics(\n+            r#\"\n+extern \"C\" {\n+    fn fixed(fixed: u8);\n+    fn varargs(fixed: u8, ...);\n+    fn varargs2(...);\n+}\n+\n+fn f() {\n+    unsafe {\n+        fixed(0);\n+        fixed(0, 1);\n+      //^^^^^^^^^^^ expected 1 argument, found 2\n+        varargs(0);\n+        varargs(0, 1);\n+        varargs2();\n+        varargs2(0);\n+        varargs2(0, 1);\n+    }\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn arg_count_lambda() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let f = |()| ();\n+    f();\n+  //^^^ expected 1 argument, found 0\n+    f(());\n+    f((), ());\n+  //^^^^^^^^^ expected 1 argument, found 2\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn cfgd_out_call_arguments() {\n+        check_diagnostics(\n+            r#\"\n+struct C(#[cfg(FALSE)] ());\n+impl C {\n+    fn new() -> Self {\n+        Self(\n+            #[cfg(FALSE)]\n+            (),\n+        )\n+    }\n+\n+    fn method(&self) {}\n+}\n+\n+fn main() {\n+    C::new().method(#[cfg(FALSE)] 0);\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn cfgd_out_fn_params() {\n+        check_diagnostics(\n+            r#\"\n+fn foo(#[cfg(NEVER)] x: ()) {}\n+\n+struct S;\n+\n+impl S {\n+    fn method(#[cfg(NEVER)] self) {}\n+    fn method2(#[cfg(NEVER)] self, arg: u8) {}\n+    fn method3(self, #[cfg(NEVER)] arg: u8) {}\n+}\n+\n+extern \"C\" {\n+    fn fixed(fixed: u8, #[cfg(NEVER)] ...);\n+    fn varargs(#[cfg(not(NEVER))] ...);\n+}\n+\n+fn main() {\n+    foo();\n+    S::method();\n+    S::method2(0);\n+    S::method3(S);\n+    S.method3();\n+    unsafe {\n+        fixed(0);\n+        varargs(1, 2, 3);\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+}"}, {"sha": "5c47e8d0af1ba27fa0b488412e07297620faa9ee", "filename": "crates/ide/src/diagnostics/missing_unsafe.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_unsafe.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -0,0 +1,101 @@\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: missing-unsafe\n+//\n+// This diagnostic is triggered if an operation marked as `unsafe` is used outside of an `unsafe` function or block.\n+pub(super) fn missing_unsafe(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Diagnostic {\n+    Diagnostic::new(\n+        \"missing-unsafe\",\n+        \"this operation is unsafe and requires an unsafe function or block\",\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_raw_ptr() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    unsafe { let y = *x; }\n+    let z = *x;\n+}         //^^ this operation is unsafe and requires an unsafe function or block\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_unsafe_call() {\n+        check_diagnostics(\n+            r#\"\n+struct HasUnsafe;\n+\n+impl HasUnsafe {\n+    unsafe fn unsafe_fn(&self) {\n+        let x = &5 as *const usize;\n+        let y = *x;\n+    }\n+}\n+\n+unsafe fn unsafe_fn() {\n+    let x = &5 as *const usize;\n+    let y = *x;\n+}\n+\n+fn main() {\n+    unsafe_fn();\n+  //^^^^^^^^^^^ this operation is unsafe and requires an unsafe function or block\n+    HasUnsafe.unsafe_fn();\n+  //^^^^^^^^^^^^^^^^^^^^^ this operation is unsafe and requires an unsafe function or block\n+    unsafe {\n+        unsafe_fn();\n+        HasUnsafe.unsafe_fn();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_static_mut() {\n+        check_diagnostics(\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = STATIC_MUT.a;\n+          //^^^^^^^^^^ this operation is unsafe and requires an unsafe function or block\n+    unsafe {\n+        let x = STATIC_MUT.a;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_missing_unsafe_diagnostic_with_safe_intrinsic() {\n+        check_diagnostics(\n+            r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn bitreverse(x: u32) -> u32; // Safe intrinsic\n+    pub fn floorf32(x: f32) -> f32; // Unsafe intrinsic\n+}\n+\n+fn main() {\n+    let _ = bitreverse(12);\n+    let _ = floorf32(12.0);\n+          //^^^^^^^^^^^^^^ this operation is unsafe and requires an unsafe function or block\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "61962de28e8f072a0212e41b8d4f8d20a616f938", "filename": "crates/ide/src/diagnostics/no_such_field.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -0,0 +1,286 @@\n+use hir::{db::AstDatabase, HasSource, HirDisplay, Semantics};\n+use ide_db::{base_db::FileId, source_change::SourceChange, RootDatabase};\n+use syntax::{\n+    ast::{self, edit::IndentLevel, make},\n+    AstNode,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    diagnostics::{fix, Diagnostic, DiagnosticsContext},\n+    Assist,\n+};\n+\n+// Diagnostic: no-such-field\n+//\n+// This diagnostic is triggered if created structure does not have field provided in record.\n+pub(super) fn no_such_field(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Diagnostic {\n+    Diagnostic::new(\n+        \"no-such-field\",\n+        \"no such field\".to_string(),\n+        ctx.sema.diagnostics_display_range(d.field.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.field.file_id)?;\n+    missing_record_expr_field_fixes(\n+        &ctx.sema,\n+        d.field.file_id.original_file(ctx.sema.db),\n+        &d.field.value.to_node(&root),\n+    )\n+}\n+\n+fn missing_record_expr_field_fixes(\n+    sema: &Semantics<RootDatabase>,\n+    usage_file_id: FileId,\n+    record_expr_field: &ast::RecordExprField,\n+) -> Option<Vec<Assist>> {\n+    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n+    let def_id = sema.resolve_variant(record_lit)?;\n+    let module;\n+    let def_file_id;\n+    let record_fields = match def_id {\n+        hir::VariantDef::Struct(s) => {\n+            module = s.module(sema.db);\n+            let source = s.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+        hir::VariantDef::Union(u) => {\n+            module = u.module(sema.db);\n+            let source = u.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            source.value.record_field_list()?\n+        }\n+        hir::VariantDef::Variant(e) => {\n+            module = e.module(sema.db);\n+            let source = e.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+    };\n+    let def_file_id = def_file_id.original_file(sema.db);\n+\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n+    if new_field_type.is_unknown() {\n+        return None;\n+    }\n+    let new_field = make::record_field(\n+        None,\n+        make::name(&record_expr_field.field_name()?.text()),\n+        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n+    );\n+\n+    let last_field = record_fields.fields().last()?;\n+    let last_field_syntax = last_field.syntax();\n+    let indent = IndentLevel::from_node(last_field_syntax);\n+\n+    let mut new_field = new_field.to_string();\n+    if usage_file_id != def_file_id {\n+        new_field = format!(\"pub(crate) {}\", new_field);\n+    }\n+    new_field = format!(\"\\n{}{}\", indent, new_field);\n+\n+    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n+    if needs_comma {\n+        new_field = format!(\",{}\", new_field);\n+    }\n+\n+    let source_change = SourceChange::from_text_edit(\n+        def_file_id,\n+        TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n+    );\n+\n+    return Some(vec![fix(\n+        \"create_field\",\n+        \"Create field\",\n+        source_change,\n+        record_expr_field.syntax().text_range(),\n+    )]);\n+\n+    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n+        match field_def_list {\n+            ast::FieldList::RecordFieldList(it) => Some(it),\n+            ast::FieldList::TupleFieldList(_) => None,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn no_such_field_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+impl S {\n+    fn new() -> S {\n+        S {\n+      //^ Missing structure fields:\n+      //|    - bar\n+            foo: 92,\n+            baz: 62,\n+          //^^^^^^^ no such field\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct MyStruct {\n+    my_val: usize,\n+    #[cfg(feature = \"foo\")]\n+    bar: bool,\n+}\n+\n+impl MyStruct {\n+    #[cfg(feature = \"foo\")]\n+    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n+        Self { my_val, bar }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n+        Self { my_val }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_enum_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+enum Foo {\n+    #[cfg(not(feature = \"foo\"))]\n+    Buz,\n+    #[cfg(feature = \"foo\")]\n+    Bar,\n+    Baz\n+}\n+\n+fn test_fn(f: Foo) {\n+    match f {\n+        Foo::Bar => {},\n+        Foo::Baz => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct S {\n+    #[cfg(feature = \"foo\")]\n+    foo: u32,\n+    #[cfg(not(feature = \"foo\"))]\n+    bar: u32,\n+}\n+\n+impl S {\n+    #[cfg(feature = \"foo\")]\n+    fn new(foo: u32) -> Self {\n+        Self { foo }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    fn new(bar: u32) -> Self {\n+        Self { bar }\n+    }\n+    fn new2(bar: u32) -> Self {\n+        #[cfg(feature = \"foo\")]\n+        { Self { foo: bar } }\n+        #[cfg(not(feature = \"foo\"))]\n+        { Self { bar } }\n+    }\n+    fn new2(val: u32) -> Self {\n+        Self {\n+            #[cfg(feature = \"foo\")]\n+            foo: val,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: val,\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type { () => { u32 }; }\n+struct Foo { bar: Type![] }\n+\n+impl Foo {\n+    fn new() -> Self {\n+        Foo { bar: 0 }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_field_from_usage() {\n+        check_fix(\n+            r\"\n+fn main() {\n+    Foo { bar: 3, baz$0: false};\n+}\n+struct Foo {\n+    bar: i32\n+}\n+\",\n+            r\"\n+fn main() {\n+    Foo { bar: 3, baz: false};\n+}\n+struct Foo {\n+    bar: i32,\n+    baz: bool\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_add_field_in_other_file_from_usage() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod foo;\n+\n+fn main() {\n+    foo::Foo { bar: 3, $0baz: false};\n+}\n+//- /foo.rs\n+struct Foo {\n+    bar: i32\n+}\n+\"#,\n+            r#\"\n+struct Foo {\n+    bar: i32,\n+    pub(crate) baz: bool\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "09faa3bbc714f18c02d4c59873bf135f924a513d", "filename": "crates/ide/src/diagnostics/unimplemented_builtin_macro.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Funimplemented_builtin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Funimplemented_builtin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funimplemented_builtin_macro.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -0,0 +1,19 @@\n+use crate::{\n+    diagnostics::{Diagnostic, DiagnosticsContext},\n+    Severity,\n+};\n+\n+// Diagnostic: unimplemented-builtin-macro\n+//\n+// This diagnostic is shown for builtin macros which are not yet implemented by rust-analyzer\n+pub(super) fn unimplemented_builtin_macro(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnimplementedBuiltinMacro,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"unimplemented-builtin-macro\",\n+        \"unimplemented built-in macro\".to_string(),\n+        ctx.sema.diagnostics_display_range(d.node.clone()).range,\n+    )\n+    .severity(Severity::WeakWarning)\n+}"}]}