{"sha": "a8f50453d0426de82b939bb1bbbd42af1a8a3d22", "node_id": "C_kwDOAAsO6NoAKGE4ZjUwNDUzZDA0MjZkZTgyYjkzOWJiMWJiYmQ0MmFmMWE4YTNkMjI", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-29T22:01:31Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-30T15:39:58Z"}, "message": "Use some more `const_eval_select` in pointer methods for compile times", "tree": {"sha": "0036f0ba264bad3b4d1bbc2b00fff4641a73740c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0036f0ba264bad3b4d1bbc2b00fff4641a73740c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8f50453d0426de82b939bb1bbbd42af1a8a3d22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f50453d0426de82b939bb1bbbd42af1a8a3d22", "html_url": "https://github.com/rust-lang/rust/commit/a8f50453d0426de82b939bb1bbbd42af1a8a3d22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8f50453d0426de82b939bb1bbbd42af1a8a3d22/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c0b403f19fc6febcd1e36a83fc307ecc11de943", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c0b403f19fc6febcd1e36a83fc307ecc11de943", "html_url": "https://github.com/rust-lang/rust/commit/0c0b403f19fc6febcd1e36a83fc307ecc11de943"}], "stats": {"total": 88, "additions": 66, "deletions": 22}, "files": [{"sha": "0a74c03d70f3a6cf17c95e9a059d49f2960f0945", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a8f50453d0426de82b939bb1bbbd42af1a8a3d22/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f50453d0426de82b939bb1bbbd42af1a8a3d22/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=a8f50453d0426de82b939bb1bbbd42af1a8a3d22", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n-use crate::intrinsics;\n+use crate::intrinsics::{self, const_eval_select};\n use crate::mem;\n use crate::slice::{self, SliceIndex};\n \n@@ -34,12 +34,23 @@ impl<T: ?Sized> *const T {\n     #[rustc_const_unstable(feature = \"const_ptr_is_null\", issue = \"74939\")]\n     #[inline]\n     pub const fn is_null(self) -> bool {\n-        // Compare via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        match (self as *const u8).guaranteed_eq(null()) {\n-            None => false,\n-            Some(res) => res,\n+        #[inline]\n+        fn runtime_impl(ptr: *const u8) -> bool {\n+            ptr.addr() == 0\n         }\n+\n+        #[inline]\n+        const fn const_impl(ptr: *const u8) -> bool {\n+            // Compare via a cast to a thin pointer, so fat pointers are only\n+            // considering their \"data\" part for null-ness.\n+            match (ptr).guaranteed_eq(null_mut()) {\n+                None => false,\n+                Some(res) => res,\n+            }\n+        }\n+\n+        // SAFETY: The two versions are equivalent at runtime.\n+        unsafe { const_eval_select((self as *const u8,), const_impl, runtime_impl) }\n     }\n \n     /// Casts to a pointer of another type.\n@@ -1587,11 +1598,22 @@ impl<T: ?Sized> *const T {\n             panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n-        // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n-        // The cast to `()` is used to\n-        //   1. deal with fat pointers; and\n-        //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n-        self.cast::<()>().align_offset(align) == 0\n+        #[inline]\n+        fn runtime_impl(ptr: *const (), align: usize) -> bool {\n+            ptr.addr() & (align - 1) == 0\n+        }\n+\n+        #[inline]\n+        const fn const_impl(ptr: *const (), align: usize) -> bool {\n+            // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n+            // The cast to `()` is used to\n+            //   1. deal with fat pointers; and\n+            //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n+            ptr.align_offset(align) == 0\n+        }\n+\n+        // SAFETY: The two versions are equivalent at runtime.\n+        unsafe { const_eval_select((self.cast::<()>(), align), const_impl, runtime_impl) }\n     }\n }\n "}, {"sha": "d70fb70c79fa4dc6dacc84297e67a062235bd8d8", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a8f50453d0426de82b939bb1bbbd42af1a8a3d22/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f50453d0426de82b939bb1bbbd42af1a8a3d22/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=a8f50453d0426de82b939bb1bbbd42af1a8a3d22", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n-use crate::intrinsics;\n+use crate::intrinsics::{self, const_eval_select};\n use crate::slice::{self, SliceIndex};\n \n impl<T: ?Sized> *mut T {\n@@ -33,12 +33,23 @@ impl<T: ?Sized> *mut T {\n     #[rustc_const_unstable(feature = \"const_ptr_is_null\", issue = \"74939\")]\n     #[inline]\n     pub const fn is_null(self) -> bool {\n-        // Compare via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        match (self as *mut u8).guaranteed_eq(null_mut()) {\n-            None => false,\n-            Some(res) => res,\n+        #[inline]\n+        fn runtime_impl(ptr: *mut u8) -> bool {\n+            ptr.addr() == 0\n         }\n+\n+        #[inline]\n+        const fn const_impl(ptr: *mut u8) -> bool {\n+            // Compare via a cast to a thin pointer, so fat pointers are only\n+            // considering their \"data\" part for null-ness.\n+            match (ptr).guaranteed_eq(null_mut()) {\n+                None => false,\n+                Some(res) => res,\n+            }\n+        }\n+\n+        // SAFETY: The two versions are equivalent at runtime.\n+        unsafe { const_eval_select((self as *mut u8,), const_impl, runtime_impl) }\n     }\n \n     /// Casts to a pointer of another type.\n@@ -1859,11 +1870,22 @@ impl<T: ?Sized> *mut T {\n             panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n-        // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n-        // The cast to `()` is used to\n-        //   1. deal with fat pointers; and\n-        //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n-        self.cast::<()>().align_offset(align) == 0\n+        #[inline]\n+        fn runtime_impl(ptr: *mut (), align: usize) -> bool {\n+            ptr.addr() & (align - 1) == 0\n+        }\n+\n+        #[inline]\n+        const fn const_impl(ptr: *mut (), align: usize) -> bool {\n+            // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n+            // The cast to `()` is used to\n+            //   1. deal with fat pointers; and\n+            //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n+            ptr.align_offset(align) == 0\n+        }\n+\n+        // SAFETY: The two versions are equivalent at runtime.\n+        unsafe { const_eval_select((self.cast::<()>(), align), const_impl, runtime_impl) }\n     }\n }\n "}]}