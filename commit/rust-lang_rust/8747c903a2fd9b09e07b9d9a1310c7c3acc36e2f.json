{"sha": "8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NDdjOTAzYTJmZDliMDllMDdiOWQ5YTEzMTBjN2MzYWNjMzZlMmY=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-17T01:26:01Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-17T01:35:03Z"}, "message": "Refactoring", "tree": {"sha": "e32b43a9ca5f3e865c558e0437697fe7b880585c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e32b43a9ca5f3e865c558e0437697fe7b880585c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f", "html_url": "https://github.com/rust-lang/rust/commit/8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "039ab2e820defdee3b547c765739614ccbfd3c44", "url": "https://api.github.com/repos/rust-lang/rust/commits/039ab2e820defdee3b547c765739614ccbfd3c44", "html_url": "https://github.com/rust-lang/rust/commit/039ab2e820defdee3b547c765739614ccbfd3c44"}], "stats": {"total": 97, "additions": 46, "deletions": 51}, "files": [{"sha": "7ca1ff595746a7f33f12251d509d2aeb2a4ca06b", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f", "patch": "@@ -35,16 +35,17 @@ use crate::{\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat,Array, self},\n     generics::{GenericParams, HasGenericParams},\n     path::{GenericArgs, GenericArg},\n+    ModuleDef,\n     adt::VariantDef,\n     resolve::{Resolver, Resolution},\n     nameres::Namespace,\n+    ty::infer::diagnostics::InferenceDiagnostic,\n     diagnostics::DiagnosticSink,\n };\n use super::{\n     Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, CallableDef, TraitRef,\n     traits::{ Solution, Obligation, Guidance},\n };\n-use self::diagnostics::InferenceDiagnostic;\n \n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n@@ -462,28 +463,25 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let mut actual_def_ty: Option<Ty> = None;\n \n         // resolve intermediate segments\n-        for segment in &path.segments[remaining_index..] {\n+        for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n             let ty = match resolved {\n                 Resolution::Def(def) => {\n                     // FIXME resolve associated items from traits as well\n                     let typable: Option<TypableDef> = def.into();\n                     let typable = typable?;\n \n-                    let mut ty = self.db.type_for_def(typable, Namespace::Types);\n+                    let ty = self.db.type_for_def(typable, Namespace::Types);\n \n-                    if remaining_index > 0 {\n-                        // For example, this substs will take `Gen::*<u32>*::make`\n-                        let substs = Ty::substs_from_path_segment(\n-                            self.db,\n-                            &self.resolver,\n-                            &path.segments[remaining_index - 1],\n-                            typable,\n-                        );\n-\n-                        ty = ty.subst(&substs);\n-                    }\n+                    // For example, this substs will take `Gen::*<u32>*::make`\n+                    assert!(remaining_index > 0);\n+                    let substs = Ty::substs_from_path_segment(\n+                        self.db,\n+                        &self.resolver,\n+                        &path.segments[remaining_index + i - 1],\n+                        typable,\n+                    );\n \n-                    ty\n+                    ty.subst(&substs)\n                 }\n                 Resolution::LocalBinding(_) => {\n                     // can't have a local binding in an associated item path\n@@ -541,45 +539,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         match resolved {\n             Resolution::Def(def) => {\n-                // Helpper function for finding self types\n-                let find_self_types = || -> Option<Substs> {\n-                    let actual_def_ty = actual_def_ty?;\n-\n-                    if let crate::ModuleDef::Function(func) = def {\n-                        // We only do the infer if parent has generic params\n-                        let gen = func.generic_params(self.db);\n-                        if gen.count_parent_params() == 0 {\n-                            return None;\n-                        }\n-\n-                        let impl_block = func.impl_block(self.db)?.target_ty(self.db);\n-                        let impl_block_substs = impl_block.substs()?;\n-                        let actual_substs = actual_def_ty.substs()?;\n-\n-                        let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n-\n-                        // The following code *link up* the function actual parma type\n-                        // and impl_block type param index\n-                        impl_block_substs.iter().zip(actual_substs.iter()).for_each(\n-                            |(param, pty)| {\n-                                if let Ty::Param { idx, .. } = param {\n-                                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n-                                        *s = pty.clone();\n-                                    }\n-                                }\n-                            },\n-                        );\n-\n-                        Some(Substs(new_substs.into()))\n-                    } else {\n-                        None\n-                    }\n-                };\n-\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n                 let mut ty = self.db.type_for_def(typable, Namespace::Values);\n-                if let Some(sts) = find_self_types() {\n+                if let Some(sts) = self.find_self_types(&def, actual_def_ty) {\n                     ty = ty.subst(&sts);\n                 }\n \n@@ -604,6 +567,38 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n+    fn find_self_types(&self, def: &ModuleDef, actual_def_ty: Option<Ty>) -> Option<Substs> {\n+        let actual_def_ty = actual_def_ty?;\n+\n+        if let crate::ModuleDef::Function(func) = def {\n+            // We only do the infer if parent has generic params\n+            let gen = func.generic_params(self.db);\n+            if gen.count_parent_params() == 0 {\n+                return None;\n+            }\n+\n+            let impl_block = func.impl_block(self.db)?.target_ty(self.db);\n+            let impl_block_substs = impl_block.substs()?;\n+            let actual_substs = actual_def_ty.substs()?;\n+\n+            let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n+\n+            // The following code *link up* the function actual parma type\n+            // and impl_block type param index\n+            impl_block_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n+                if let Ty::Param { idx, .. } = param {\n+                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n+                        *s = pty.clone();\n+                    }\n+                }\n+            });\n+\n+            Some(Substs(new_substs.into()))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n         let path = match path {\n             Some(path) => path,"}]}