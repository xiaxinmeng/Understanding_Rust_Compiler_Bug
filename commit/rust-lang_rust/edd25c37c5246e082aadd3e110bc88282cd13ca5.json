{"sha": "edd25c37c5246e082aadd3e110bc88282cd13ca5", "node_id": "C_kwDOAAsO6NoAKGVkZDI1YzM3YzUyNDZlMDgyYWFkZDNlMTEwYmM4ODI4MmNkMTNjYTU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-03T16:43:33Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-30T17:04:41Z"}, "message": "Simplify recursion scheme.", "tree": {"sha": "db74c601c4318a01ad9733fc74da93d32e62fe2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db74c601c4318a01ad9733fc74da93d32e62fe2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edd25c37c5246e082aadd3e110bc88282cd13ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edd25c37c5246e082aadd3e110bc88282cd13ca5", "html_url": "https://github.com/rust-lang/rust/commit/edd25c37c5246e082aadd3e110bc88282cd13ca5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edd25c37c5246e082aadd3e110bc88282cd13ca5/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445", "url": "https://api.github.com/repos/rust-lang/rust/commits/73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445", "html_url": "https://github.com/rust-lang/rust/commit/73e9f37eaa05fbf2bb7657d6b80fe1afd0a6d445"}], "stats": {"total": 130, "additions": 51, "deletions": 79}, "files": [{"sha": "45195138f274c48ad2a24cc6d4848267c4af29ee", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 51, "deletions": 79, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/edd25c37c5246e082aadd3e110bc88282cd13ca5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd25c37c5246e082aadd3e110bc88282cd13ca5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=edd25c37c5246e082aadd3e110bc88282cd13ca5", "patch": "@@ -1288,21 +1288,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_field(\n-        &mut self,\n-        adt_def: ty::AdtDef<'tcx>,\n-        variant_index: VariantIdx,\n-        field_index: usize,\n-    ) {\n-        let variant = &adt_def.variant(variant_index);\n-        let field = &variant.fields[field_index];\n-\n-        let def_id = field.did;\n-        debug!(\"EncodeContext::encode_field({:?})\", def_id);\n-\n-        record!(self.tables.kind[def_id] <- EntryKind::Field);\n-    }\n-\n     fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>, def_id: DefId) {\n         debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1657,6 +1642,52 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n             }\n         }\n+        // In some cases, along with the item itself, we also\n+        // encode some sub-items. Usually we want some info from the item\n+        // so it's easier to do that here then to wait until we would encounter\n+        // normally in the visitor walk.\n+        match item.kind {\n+            hir::ItemKind::Enum(..) => {\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                self.encode_fields(def);\n+\n+                for (i, variant) in def.variants().iter_enumerated() {\n+                    self.encode_enum_variant_info(def, i);\n+\n+                    if let Some(_ctor_def_id) = variant.ctor_def_id {\n+                        self.encode_enum_variant_ctor(def, i);\n+                    }\n+                }\n+            }\n+            hir::ItemKind::Struct(ref struct_def, _) => {\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                self.encode_fields(def);\n+\n+                // If the struct has a constructor, encode it.\n+                if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                    let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n+                    self.encode_struct_ctor(def, ctor_def_id.to_def_id());\n+                }\n+            }\n+            hir::ItemKind::Union(..) => {\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                self.encode_fields(def);\n+            }\n+            hir::ItemKind::Impl { .. } => {\n+                for &trait_item_def_id in\n+                    self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                {\n+                    self.encode_info_for_impl_item(trait_item_def_id);\n+                }\n+            }\n+            hir::ItemKind::Trait(..) => {\n+                for &item_def_id in self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                {\n+                    self.encode_info_for_trait_item(item_def_id);\n+                }\n+            }\n+            _ => {}\n+        }\n     }\n \n     fn encode_info_for_closure(&mut self, hir_id: hir::HirId) {\n@@ -2062,7 +2093,6 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n             _ => self.encode_info_for_item(item.def_id.to_def_id(), item),\n         }\n-        self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);\n@@ -2078,7 +2108,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_fields(&mut self, adt_def: ty::AdtDef<'tcx>) {\n         for (variant_index, variant) in adt_def.variants().iter_enumerated() {\n             for (field_index, _field) in variant.fields.iter().enumerate() {\n-                self.encode_field(adt_def, variant_index, field_index);\n+                let variant = &adt_def.variant(variant_index);\n+                let field = &variant.fields[field_index];\n+                let def_id = field.did;\n+                debug!(\"EncodeContext::encode_field({:?})\", def_id);\n+                record!(self.tables.kind[def_id] <- EntryKind::Field);\n             }\n         }\n     }\n@@ -2103,68 +2137,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.encode_info_for_closure(expr.hir_id);\n         }\n     }\n-\n-    /// In some cases, along with the item itself, we also\n-    /// encode some sub-items. Usually we want some info from the item\n-    /// so it's easier to do that here then to wait until we would encounter\n-    /// normally in the visitor walk.\n-    fn encode_addl_info_for_item(&mut self, item: &hir::Item<'_>) {\n-        match item.kind {\n-            hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::Macro(..)\n-            | hir::ItemKind::Mod(..)\n-            | hir::ItemKind::ForeignMod { .. }\n-            | hir::ItemKind::GlobalAsm(..)\n-            | hir::ItemKind::ExternCrate(..)\n-            | hir::ItemKind::Use(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::TraitAlias(..) => {\n-                // no sub-item recording needed in these cases\n-            }\n-            hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-\n-                for (i, variant) in def.variants().iter_enumerated() {\n-                    self.encode_enum_variant_info(def, i);\n-\n-                    if let Some(_ctor_def_id) = variant.ctor_def_id {\n-                        self.encode_enum_variant_ctor(def, i);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::Struct(ref struct_def, _) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-\n-                // If the struct has a constructor, encode it.\n-                if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                    let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n-                    self.encode_struct_ctor(def, ctor_def_id.to_def_id());\n-                }\n-            }\n-            hir::ItemKind::Union(..) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-            }\n-            hir::ItemKind::Impl { .. } => {\n-                for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_impl_item(trait_item_def_id);\n-                }\n-            }\n-            hir::ItemKind::Trait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_trait_item(item_def_id);\n-                }\n-            }\n-        }\n-    }\n }\n \n /// Used to prefetch queries which will be needed later by metadata encoding."}]}