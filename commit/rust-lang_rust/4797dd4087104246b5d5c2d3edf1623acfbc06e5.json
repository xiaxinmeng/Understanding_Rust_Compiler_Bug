{"sha": "4797dd4087104246b5d5c2d3edf1623acfbc06e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3OTdkZDQwODcxMDQyNDZiNWQ1YzJkM2VkZjE2MjNhY2ZiYzA2ZTU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-17T08:13:41Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-16T17:13:41Z"}, "message": "rustc: selectively trans branches for `if <literal-bool>`.\n\nThat is, the `b` branch in `if true { a } else { b }` will not be\ntrans'd, and that expression will be exactly the same as `a`. This\nmeans that, for example, macros conditionally expanding to `if false\n{ .. }` (like debug!) will not waste time in LLVM (or trans).", "tree": {"sha": "197e9278accfb30a18fc860420c8ba5ce6aaa845", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/197e9278accfb30a18fc860420c8ba5ce6aaa845"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4797dd4087104246b5d5c2d3edf1623acfbc06e5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4797dd4087104246b5d5c2d3edf1623acfbc06e5", "html_url": "https://github.com/rust-lang/rust/commit/4797dd4087104246b5d5c2d3edf1623acfbc06e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4797dd4087104246b5d5c2d3edf1623acfbc06e5/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e252277fe9b44ed9a913aeeb9f55dc85eaadace4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e252277fe9b44ed9a913aeeb9f55dc85eaadace4", "html_url": "https://github.com/rust-lang/rust/commit/e252277fe9b44ed9a913aeeb9f55dc85eaadace4"}], "stats": {"total": 72, "additions": 55, "deletions": 17}, "files": [{"sha": "36f1f5cdbefc8b4e131621c1f8078e2354d51862", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 55, "deletions": 17, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4797dd4087104246b5d5c2d3edf1623acfbc06e5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4797dd4087104246b5d5c2d3edf1623acfbc06e5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=4797dd4087104246b5d5c2d3edf1623acfbc06e5", "patch": "@@ -63,6 +63,38 @@ pub fn trans_if(bcx: block,\n     let _indenter = indenter();\n \n     let _icx = push_ctxt(\"trans_if\");\n+\n+    match cond.node {\n+        // `if true` and `if false` can be trans'd more efficiently,\n+        // by dropping branches that are known to be impossible.\n+        ast::expr_lit(@ref l) => match l.node {\n+            ast::lit_bool(true) => {\n+                // if true { .. } [else { .. }]\n+                let then_bcx_in = scope_block(bcx, thn.info(), \"if_true_then\");\n+                let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n+                let then_bcx_out = trans_block_cleanups(then_bcx_out,\n+                                                        block_cleanups(then_bcx_in));\n+                Br(bcx, then_bcx_in.llbb);\n+                return then_bcx_out;\n+            }\n+            ast::lit_bool(false) => {\n+                match els {\n+                    // if false { .. } else { .. }\n+                    Some(elexpr) => {\n+                        let (else_bcx_in, else_bcx_out) =\n+                            trans_if_else(bcx, elexpr, dest, \"if_false_else\");\n+                        Br(bcx, else_bcx_in.llbb);\n+                        return else_bcx_out;\n+                    }\n+                    // if false { .. }\n+                    None => return bcx,\n+                }\n+            }\n+            _ => {}\n+        },\n+        _ => {}\n+    }\n+\n     let Result {bcx, val: cond_val} =\n         expr::trans_to_datum(bcx, cond).to_result();\n \n@@ -80,22 +112,8 @@ pub fn trans_if(bcx: block,\n     // 'else' context\n     let (else_bcx_in, next_bcx) = match els {\n       Some(elexpr) => {\n-        let else_bcx_in = scope_block(bcx, els.info(), \"else\");\n-        let else_bcx_out = match elexpr.node {\n-          ast::expr_if(_, _, _) => {\n-            let elseif_blk = ast_util::block_from_expr(elexpr);\n-            trans_block(else_bcx_in, &elseif_blk, dest)\n-          }\n-          ast::expr_block(ref blk) => {\n-            trans_block(else_bcx_in, blk, dest)\n-          }\n-          // would be nice to have a constraint on ifs\n-          _ => bcx.tcx().sess.bug(\"strange alternative in if\")\n-        };\n-        let else_bcx_out = trans_block_cleanups(else_bcx_out,\n-                                                block_cleanups(else_bcx_in));\n-\n-        (else_bcx_in, join_blocks(bcx, [then_bcx_out, else_bcx_out]))\n+          let (else_bcx_in, else_bcx_out) = trans_if_else(bcx, elexpr, dest, \"else\");\n+          (else_bcx_in, join_blocks(bcx, [then_bcx_out, else_bcx_out]))\n       }\n       _ => {\n           let next_bcx = sub_block(bcx, \"next\");\n@@ -109,7 +127,27 @@ pub fn trans_if(bcx: block,\n            then_bcx_in.to_str(), else_bcx_in.to_str());\n \n     CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n-    next_bcx\n+    return next_bcx;\n+\n+    // trans `else [ if { .. } ... | { .. } ]`\n+    fn trans_if_else(bcx: block, elexpr: @ast::expr,\n+                     dest: expr::Dest, scope_name: &str) -> (block, block) {\n+        let else_bcx_in = scope_block(bcx, elexpr.info(), scope_name);\n+        let else_bcx_out = match elexpr.node {\n+            ast::expr_if(_, _, _) => {\n+                let elseif_blk = ast_util::block_from_expr(elexpr);\n+                trans_block(else_bcx_in, &elseif_blk, dest)\n+            }\n+            ast::expr_block(ref blk) => {\n+                trans_block(else_bcx_in, blk, dest)\n+            }\n+            // would be nice to have a constraint on ifs\n+            _ => bcx.tcx().sess.bug(\"strange alternative in if\")\n+        };\n+        let else_bcx_out = trans_block_cleanups(else_bcx_out,\n+                                                block_cleanups(else_bcx_in));\n+        (else_bcx_in, else_bcx_out)\n+    }\n }\n \n pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {"}]}