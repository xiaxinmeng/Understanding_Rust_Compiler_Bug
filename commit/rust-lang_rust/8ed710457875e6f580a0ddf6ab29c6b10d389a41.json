{"sha": "8ed710457875e6f580a0ddf6ab29c6b10d389a41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZDcxMDQ1Nzg3NWU2ZjU4MGEwZGRmNmFiMjljNmIxMGQzODlhNDE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-08T12:32:21Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-08T12:32:21Z"}, "message": "Refactoring and add some docs", "tree": {"sha": "9c8cd6ab578167c6677a18173618ae53b2167012", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c8cd6ab578167c6677a18173618ae53b2167012"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ed710457875e6f580a0ddf6ab29c6b10d389a41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed710457875e6f580a0ddf6ab29c6b10d389a41", "html_url": "https://github.com/rust-lang/rust/commit/8ed710457875e6f580a0ddf6ab29c6b10d389a41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ed710457875e6f580a0ddf6ab29c6b10d389a41/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c785c7312da834c62b44c4f2736dbde3404b64dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c785c7312da834c62b44c4f2736dbde3404b64dd", "html_url": "https://github.com/rust-lang/rust/commit/c785c7312da834c62b44c4f2736dbde3404b64dd"}], "stats": {"total": 189, "additions": 106, "deletions": 83}, "files": [{"sha": "ce39a40bb545d6dd55121d413e4430c4765a1f93", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed710457875e6f580a0ddf6ab29c6b10d389a41/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed710457875e6f580a0ddf6ab29c6b10d389a41/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=8ed710457875e6f580a0ddf6ab29c6b10d389a41", "patch": "@@ -44,7 +44,9 @@ impl<'a> Parser<'a> {\n     }\n \n     fn finish(self, parsed_token: usize, src: &mut SubtreeTokenSource) -> Option<tt::TokenTree> {\n-        let res = src.bump_n(parsed_token, self.cur_pos);\n+        let res = src.bump_n(parsed_token);\n+        *self.cur_pos += res.len();\n+\n         let res: Vec<_> = res.into_iter().cloned().collect();\n \n         match res.len() {"}, {"sha": "4b37c2bdadd522eaac23af7bca4515e00d29b47d", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 103, "deletions": 82, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/8ed710457875e6f580a0ddf6ab29c6b10d389a41/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed710457875e6f580a0ddf6ab29c6b10d389a41/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=8ed710457875e6f580a0ddf6ab29c6b10d389a41", "patch": "@@ -11,7 +11,7 @@ struct TtToken {\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n-enum WalkIndex {\n+enum WalkCursor {\n     DelimiterBegin(Option<TtToken>),\n     Token(usize, Option<TtToken>),\n     DelimiterEnd(Option<TtToken>),\n@@ -22,7 +22,7 @@ enum WalkIndex {\n struct SubTreeWalker<'a> {\n     pos: usize,\n     stack: Vec<(&'a tt::Subtree, Option<usize>)>,\n-    idx: WalkIndex,\n+    cursor: WalkCursor,\n     last_steps: Vec<usize>,\n     subtree: &'a tt::Subtree,\n }\n@@ -32,7 +32,7 @@ impl<'a> SubTreeWalker<'a> {\n         let mut res = SubTreeWalker {\n             pos: 0,\n             stack: vec![],\n-            idx: WalkIndex::Eof,\n+            cursor: WalkCursor::Eof,\n             last_steps: vec![],\n             subtree,\n         };\n@@ -41,46 +41,51 @@ impl<'a> SubTreeWalker<'a> {\n         res\n     }\n \n+    fn is_eof(&self) -> bool {\n+        self.cursor == WalkCursor::Eof\n+    }\n+\n     fn reset(&mut self) {\n         self.pos = 0;\n         self.stack = vec![(self.subtree, None)];\n-        self.idx = WalkIndex::DelimiterBegin(convert_delim(self.subtree.delimiter, false));\n+        self.cursor = WalkCursor::DelimiterBegin(convert_delim(self.subtree.delimiter, false));\n         self.last_steps = vec![];\n \n         while self.is_empty_delimiter() {\n             self.forward_unchecked();\n         }\n     }\n \n-    // This funciton will fast forward the pos cursor,\n+    // This funciton will fast forward the cursor,\n     // Such that backward will stop at `start_pos` point\n     fn start_from_nth(&mut self, start_pos: usize) {\n         self.reset();\n         self.pos = start_pos;\n-        self.idx = self.walk_token(start_pos, false);\n+        self.cursor = self.walk_token(start_pos, 0, false);\n \n         while self.is_empty_delimiter() {\n             self.forward_unchecked();\n         }\n     }\n \n     fn current(&self) -> Option<&TtToken> {\n-        match &self.idx {\n-            WalkIndex::DelimiterBegin(t) => t.as_ref(),\n-            WalkIndex::Token(_, t) => t.as_ref(),\n-            WalkIndex::DelimiterEnd(t) => t.as_ref(),\n-            WalkIndex::Eof => None,\n+        match &self.cursor {\n+            WalkCursor::DelimiterBegin(t) => t.as_ref(),\n+            WalkCursor::Token(_, t) => t.as_ref(),\n+            WalkCursor::DelimiterEnd(t) => t.as_ref(),\n+            WalkCursor::Eof => None,\n         }\n     }\n \n     fn is_empty_delimiter(&self) -> bool {\n-        match &self.idx {\n-            WalkIndex::DelimiterBegin(None) => true,\n-            WalkIndex::DelimiterEnd(None) => true,\n+        match &self.cursor {\n+            WalkCursor::DelimiterBegin(None) => true,\n+            WalkCursor::DelimiterEnd(None) => true,\n             _ => false,\n         }\n     }\n \n+    /// Move cursor backward by 1 step with empty checking\n     fn backward(&mut self) {\n         if self.last_steps.is_empty() {\n             return;\n@@ -94,62 +99,61 @@ impl<'a> SubTreeWalker<'a> {\n             }\n         }\n \n-        // Move forward a little bit\n+        // Move forward if it is empty delimiter\n         if self.last_steps.is_empty() {\n             while self.is_empty_delimiter() {\n                 self.forward_unchecked();\n             }\n         }\n     }\n \n+    /// Move cursor backward by 1 step without empty check\n+    ///\n+    /// Depends on the current state of cursor:\n+    ///\n+    /// * Delimiter Begin => Pop the stack, goto last walking token  (`walk_token`)\n+    /// * Token => Goto prev token  (`walk_token`)\n+    /// * Delimiter End => Goto the last child token (`walk_token`)\n+    /// * Eof => push the root subtree, and set it as Delimiter End\n     fn backward_unchecked(&mut self) {\n         if self.last_steps.is_empty() {\n             return;\n         }\n \n         let last_step = self.last_steps.pop().unwrap();\n-        let do_walk_token = match self.idx {\n-            WalkIndex::DelimiterBegin(_) => None,\n-            WalkIndex::Token(u, _) => Some(u),\n-            WalkIndex::DelimiterEnd(_) => {\n+        let do_walk_token = match self.cursor {\n+            WalkCursor::DelimiterBegin(_) => None,\n+            WalkCursor::Token(u, _) => Some(u),\n+            WalkCursor::DelimiterEnd(_) => {\n                 let (top, _) = self.stack.last().unwrap();\n                 Some(top.token_trees.len())\n             }\n-            WalkIndex::Eof => None,\n+            WalkCursor::Eof => None,\n         };\n \n-        self.idx = match do_walk_token {\n-            Some(u) if last_step > u => WalkIndex::DelimiterBegin(convert_delim(\n-                self.stack.last().unwrap().0.delimiter,\n-                false,\n-            )),\n-            Some(u) => self.walk_token(u - last_step, true),\n-            None => match self.idx {\n-                WalkIndex::Eof => {\n+        self.cursor = match do_walk_token {\n+            Some(u) => self.walk_token(u, last_step, true),\n+            None => match self.cursor {\n+                WalkCursor::Eof => {\n                     self.stack.push((self.subtree, None));\n-                    WalkIndex::DelimiterEnd(convert_delim(\n+                    WalkCursor::DelimiterEnd(convert_delim(\n                         self.stack.last().unwrap().0.delimiter,\n                         true,\n                     ))\n                 }\n                 _ => {\n-                    let (_, last_top_idx) = self.stack.pop().unwrap();\n+                    let (_, last_top_cursor) = self.stack.pop().unwrap();\n                     assert!(!self.stack.is_empty());\n \n-                    match last_top_idx.unwrap() {\n-                        0 => WalkIndex::DelimiterBegin(convert_delim(\n-                            self.stack.last().unwrap().0.delimiter,\n-                            false,\n-                        )),\n-                        c => self.walk_token(c - 1, true),\n-                    }\n+                    self.walk_token(last_top_cursor.unwrap(), last_step, true)\n                 }\n             },\n         };\n     }\n \n+    /// Move cursor forward by 1 step with empty checking\n     fn forward(&mut self) {\n-        if self.idx == WalkIndex::Eof {\n+        if self.is_eof() {\n             return;\n         }\n \n@@ -162,57 +166,80 @@ impl<'a> SubTreeWalker<'a> {\n         }\n     }\n \n+    /// Move cursor forward by 1 step without empty checking\n+    ///\n+    /// Depends on the current state of cursor:\n+    ///\n+    /// * Delimiter Begin => Goto the first child token (`walk_token`)\n+    /// * Token => Goto next token  (`walk_token`)\n+    /// * Delimiter End => Pop the stack, goto last walking token  (`walk_token`)\n+    ///   \n     fn forward_unchecked(&mut self) {\n-        if self.idx == WalkIndex::Eof {\n+        if self.is_eof() {\n             return;\n         }\n \n         let step = self.current().map(|x| x.n_tokens).unwrap_or(1);\n         self.last_steps.push(step);\n \n-        let do_walk_token = match self.idx {\n-            WalkIndex::DelimiterBegin(_) => Some(0),\n-            WalkIndex::Token(u, _) => Some(u + step),\n-            WalkIndex::DelimiterEnd(_) => None,\n+        let do_walk_token = match self.cursor {\n+            WalkCursor::DelimiterBegin(_) => Some((0, 0)),\n+            WalkCursor::Token(u, _) => Some((u, step)),\n+            WalkCursor::DelimiterEnd(_) => None,\n             _ => unreachable!(),\n         };\n \n-        let (top, _) = self.stack.last().unwrap();\n-\n-        self.idx = match do_walk_token {\n-            Some(u) if u >= top.token_trees.len() => {\n-                WalkIndex::DelimiterEnd(convert_delim(self.stack.last().unwrap().0.delimiter, true))\n-            }\n-            Some(u) => self.walk_token(u, false),\n+        self.cursor = match do_walk_token {\n+            Some((u, step)) => self.walk_token(u, step, false),\n             None => {\n                 let (_, last_top_idx) = self.stack.pop().unwrap();\n                 match self.stack.last() {\n-                    Some(top) => match last_top_idx.unwrap() {\n-                        idx if idx + 1 >= top.0.token_trees.len() => {\n-                            WalkIndex::DelimiterEnd(convert_delim(top.0.delimiter, true))\n-                        }\n-                        idx => self.walk_token(idx + 1, false),\n-                    },\n-\n-                    None => WalkIndex::Eof,\n+                    Some(_) => self.walk_token(last_top_idx.unwrap(), 1, false),\n+                    None => WalkCursor::Eof,\n                 }\n             }\n         };\n     }\n \n-    fn walk_token(&mut self, pos: usize, backward: bool) -> WalkIndex {\n+    /// Traversal child token\n+    /// Depends on the new position, it returns:\n+    ///\n+    /// * new position < 0 => DelimiterBegin\n+    /// * new position > token_tree.len() => DelimiterEnd\n+    /// * if new position is a subtree, depends on traversal direction:\n+    /// ** backward => DelimiterEnd\n+    /// ** forward => DelimiterBegin\n+    /// * if new psoition is a leaf, return walk_leaf()\n+    fn walk_token(&mut self, pos: usize, offset: usize, backward: bool) -> WalkCursor {\n         let (top, _) = self.stack.last().unwrap();\n+\n+        if backward && pos < offset {\n+            return WalkCursor::DelimiterBegin(convert_delim(\n+                self.stack.last().unwrap().0.delimiter,\n+                false,\n+            ));\n+        }\n+\n+        if !backward && pos + offset >= top.token_trees.len() {\n+            return WalkCursor::DelimiterEnd(convert_delim(\n+                self.stack.last().unwrap().0.delimiter,\n+                true,\n+            ));\n+        }\n+\n+        let pos = if backward { pos - offset } else { pos + offset };\n+\n         match &top.token_trees[pos] {\n             tt::TokenTree::Subtree(subtree) => {\n                 self.stack.push((subtree, Some(pos)));\n                 let delim = convert_delim(self.stack.last().unwrap().0.delimiter, backward);\n                 if backward {\n-                    WalkIndex::DelimiterEnd(delim)\n+                    WalkCursor::DelimiterEnd(delim)\n                 } else {\n-                    WalkIndex::DelimiterBegin(delim)\n+                    WalkCursor::DelimiterBegin(delim)\n                 }\n             }\n-            tt::TokenTree::Leaf(leaf) => WalkIndex::Token(pos, Some(self.walk_leaf(leaf, pos))),\n+            tt::TokenTree::Leaf(leaf) => WalkCursor::Token(pos, Some(self.walk_leaf(leaf, pos))),\n         }\n     }\n \n@@ -240,7 +267,11 @@ pub(crate) struct WalkerOwner<'a> {\n }\n \n impl<'a> WalkerOwner<'a> {\n-    fn token_idx<'b>(&self, pos: usize) -> Option<TtToken> {\n+    fn new(subtree: &'a tt::Subtree) -> Self {\n+        WalkerOwner { walker: RefCell::new(SubTreeWalker::new(subtree)), offset: 0 }\n+    }\n+\n+    fn get<'b>(&self, pos: usize) -> Option<TtToken> {\n         self.set_walker_pos(pos);\n         let walker = self.walker.borrow();\n         walker.current().cloned()\n@@ -254,26 +285,22 @@ impl<'a> WalkerOwner<'a> {\n     fn set_walker_pos(&self, mut pos: usize) {\n         pos += self.offset;\n         let mut walker = self.walker.borrow_mut();\n-        while pos > walker.pos && walker.idx != WalkIndex::Eof {\n+        while pos > walker.pos && !walker.is_eof() {\n             walker.forward();\n         }\n         while pos < walker.pos {\n             walker.backward();\n         }\n     }\n \n-    fn new(subtree: &'a tt::Subtree) -> Self {\n-        WalkerOwner { walker: RefCell::new(SubTreeWalker::new(subtree)), offset: 0 }\n-    }\n-\n-    fn collect_token_tree(&mut self, n: usize) -> Vec<&tt::TokenTree> {\n+    fn collect_token_trees(&mut self, n: usize) -> Vec<&tt::TokenTree> {\n         self.start_from_nth(self.offset);\n \n         let mut res = vec![];\n         let mut walker = self.walker.borrow_mut();\n \n         while walker.pos - self.offset < n {\n-            if let WalkIndex::Token(u, tt) = &walker.idx {\n+            if let WalkCursor::Token(u, tt) = &walker.cursor {\n                 if walker.stack.len() == 1 {\n                     // We only collect the topmost child\n                     res.push(&walker.stack[0].0.token_trees[*u]);\n@@ -294,7 +321,7 @@ impl<'a> WalkerOwner<'a> {\n \n impl<'a> Querier for WalkerOwner<'a> {\n     fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr) {\n-        let tkn = self.token_idx(uidx).unwrap();\n+        let tkn = self.get(uidx).unwrap();\n         (tkn.kind, tkn.text)\n     }\n }\n@@ -319,31 +346,25 @@ impl<'a> SubtreeTokenSource<'a> {\n         &self.walker\n     }\n \n-    pub(crate) fn bump_n(\n-        &mut self,\n-        parsed_tokens: usize,\n-        cursor_pos: &mut usize,\n-    ) -> Vec<&tt::TokenTree> {\n-        let res = self.walker.collect_token_tree(parsed_tokens);\n-        *cursor_pos += res.len();\n-\n+    pub(crate) fn bump_n(&mut self, parsed_tokens: usize) -> Vec<&tt::TokenTree> {\n+        let res = self.walker.collect_token_trees(parsed_tokens);\n         res\n     }\n }\n \n impl<'a> TokenSource for SubtreeTokenSource<'a> {\n     fn token_kind(&self, pos: usize) -> SyntaxKind {\n-        if let Some(tok) = self.walker.token_idx(pos) {\n+        if let Some(tok) = self.walker.get(pos) {\n             tok.kind\n         } else {\n             SyntaxKind::EOF\n         }\n     }\n     fn is_token_joint_to_next(&self, pos: usize) -> bool {\n-        self.walker.token_idx(pos).unwrap().is_joint_to_next\n+        self.walker.get(pos).unwrap().is_joint_to_next\n     }\n     fn is_keyword(&self, pos: usize, kw: &str) -> bool {\n-        self.walker.token_idx(pos).unwrap().text == *kw\n+        self.walker.get(pos).unwrap().text == *kw\n     }\n }\n "}]}