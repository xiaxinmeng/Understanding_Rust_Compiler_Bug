{"sha": "963e4bc756c91fa9ffd4850576655bc3980230c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2M2U0YmM3NTZjOTFmYTlmZmQ0ODUwNTc2NjU1YmMzOTgwMjMwYzc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-13T11:34:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-13T11:34:32Z"}, "message": "Rollup merge of #65248 - estebank:mention-if-let, r=cramertj\n\nSuggest `if let` on `let` refutable binding\n\nFix #58385.", "tree": {"sha": "737b1f10c6800b4c06331a55b5c5398b5da1adf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/737b1f10c6800b4c06331a55b5c5398b5da1adf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/963e4bc756c91fa9ffd4850576655bc3980230c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdowvICRBK7hj4Ov3rIwAAdHIIAI8wia/zlCafChYYqlb8UD8p\nbDiLppEWqZhOwAKSZ9a5leeNCNb9JmVSQhojcAX8oO3oYHHhjh9bD4tqp++MKuPw\n6cmbwFWDcqW/WMiaHDVWfelHfzTP66WXiYZrc1Y/3pIV5IWyYceWfmNmIC/lhB4P\naNgKu3lUgmWMz4bHbKtoJcK6mgacX365YTvL66N7UH9Zdq7NJOmsUrNSBepTWfBA\nBD9m+bwVzmBsPUmHXm/FgJ1AmA/gzRqa+owbA/KR3LlWu4GbhyOvmVv6SeYat5SH\nAkeqU34mUxdrdSfLIl7MV/7Vg1VlnuODDjHv0E8JSTij6xkd7kqdQ7HyQt2UbJo=\n=KK19\n-----END PGP SIGNATURE-----\n", "payload": "tree 737b1f10c6800b4c06331a55b5c5398b5da1adf9\nparent 82fb193cdfa2bed376e7763477e1f57db7e48a54\nparent 4bb1592402003184cd73c6ee5b135df084ea5abc\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1570966472 +0200\ncommitter GitHub <noreply@github.com> 1570966472 +0200\n\nRollup merge of #65248 - estebank:mention-if-let, r=cramertj\n\nSuggest `if let` on `let` refutable binding\n\nFix #58385.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/963e4bc756c91fa9ffd4850576655bc3980230c7", "html_url": "https://github.com/rust-lang/rust/commit/963e4bc756c91fa9ffd4850576655bc3980230c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/963e4bc756c91fa9ffd4850576655bc3980230c7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82fb193cdfa2bed376e7763477e1f57db7e48a54", "url": "https://api.github.com/repos/rust-lang/rust/commits/82fb193cdfa2bed376e7763477e1f57db7e48a54", "html_url": "https://github.com/rust-lang/rust/commit/82fb193cdfa2bed376e7763477e1f57db7e48a54"}, {"sha": "4bb1592402003184cd73c6ee5b135df084ea5abc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb1592402003184cd73c6ee5b135df084ea5abc", "html_url": "https://github.com/rust-lang/rust/commit/4bb1592402003184cd73c6ee5b135df084ea5abc"}], "stats": {"total": 178, "additions": 169, "deletions": 9}, "files": [{"sha": "9bed4fb66ea9dee219f92a8039f9eda3bd1ee191", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -62,12 +62,13 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n     fn visit_local(&mut self, loc: &'tcx hir::Local) {\n         intravisit::walk_local(self, loc);\n \n-        self.check_irrefutable(&loc.pat, match loc.source {\n-            hir::LocalSource::Normal => \"local binding\",\n-            hir::LocalSource::ForLoopDesugar => \"`for` loop binding\",\n-            hir::LocalSource::AsyncFn => \"async fn binding\",\n-            hir::LocalSource::AwaitDesugar => \"`await` future binding\",\n-        });\n+        let (msg, sp) = match loc.source {\n+            hir::LocalSource::Normal => (\"local binding\", Some(loc.span)),\n+            hir::LocalSource::ForLoopDesugar => (\"`for` loop binding\", None),\n+            hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n+            hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n+        };\n+        self.check_irrefutable(&loc.pat, msg, sp);\n \n         // Check legality of move bindings and `@` patterns.\n         self.check_patterns(false, &loc.pat);\n@@ -77,7 +78,7 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n         intravisit::walk_body(self, body);\n \n         for param in &body.params {\n-            self.check_irrefutable(&param.pat, \"function argument\");\n+            self.check_irrefutable(&param.pat, \"function argument\", None);\n             self.check_patterns(false, &param.pat);\n         }\n     }\n@@ -242,7 +243,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         })\n     }\n \n-    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n+    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx = PatCtxt::new(self.tcx,\n@@ -266,18 +267,35 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 \"refutable pattern in {}: {} not covered\",\n                 origin, joined_patterns\n             );\n-            match &pat.kind {\n+            let suggest_if_let = match &pat.kind {\n                 hir::PatKind::Path(hir::QPath::Resolved(None, path))\n                     if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n                 {\n                     const_not_var(&mut err, cx.tcx, pat, path);\n+                    false\n                 }\n                 _ => {\n                     err.span_label(\n                         pat.span,\n                         pattern_not_covered_label(&witnesses, &joined_patterns),\n                     );\n+                    true\n+                }\n+            };\n+\n+            if let (Some(span), true) = (sp, suggest_if_let) {\n+                err.note(\"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n+                          an `enum` with only one variant\");\n+                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    err.span_suggestion(\n+                        span,\n+                        \"you might want to use `if let` to ignore the variant that isn't matched\",\n+                        format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n+                        Applicability::HasPlaceholders,\n+                    );\n                 }\n+                err.note(\"for more information, visit \\\n+                          https://doc.rust-lang.org/book/ch18-02-refutability.html\");\n             }\n \n             adt_defined_here(cx, &mut err, pattern_ty, &witnesses);"}, {"sha": "087cc3c86a68d9da9657af1e97c7c47b50dd4dad", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1\n    |\n LL |     A = { let 0 = 0; 0 },\n    |               ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     A = { if let 0 = 0 { /* */ } 0 },\n+   |           ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "80d9f794bc1d5ae35165abf4b5e935102e16ec3b", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n    |                        ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     let x: [i32; { if let 0 = 0 { /* */ } 0 }] = [];\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e6b2f212bb43057873daa4c5e8b54467dee0f46d", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -3,24 +3,52 @@ error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n    |                      ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL | const X: i32 = { if let 0 = 0 { /* */ } 0 };\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n    |                       ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL | static Y: i32 = { if let 0 = 0 { /* */ } 0 };\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n    |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n    |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "d865b59f0b9459a5c9ce3f164df3b8f5fcd9d671", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -11,6 +11,13 @@ LL | | }\n ...\n LL |       let Helper::U(u) = Helper::T(t, []);\n    |           ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Helper::U(u) = Helper::T(t, []) { /* */ }\n+   |\n \n error[E0381]: use of possibly-uninitialized variable: `u`\n   --> $DIR/empty-never-array.rs:12:5"}, {"sha": "577c6e886d52331e5c8b3975b22006d0c67fbe2e", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `None` not covered\n    |\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Some(y) = x { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d77fbc1e8239debff1410553b2f698755bc305b8", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.nll.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -0,0 +1,16 @@\n+error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+  --> $DIR/feature-gate-exhaustive-patterns.rs:7:9\n+   |\n+LL |     let Ok(_x) = foo();\n+   |         ^^^^^^ pattern `Err(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Ok(_x) = foo() { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0005`."}, {"sha": "d77fbc1e8239debff1410553b2f698755bc305b8", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Ok(_x) = foo() { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d3c8e876b8a8816b778272b0d8f21e6a168eac3f", "filename": "src/test/ui/issues/issue-31561.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -12,6 +12,13 @@ LL | | }\n ...\n LL |       let Thing::Foo(y) = Thing::Foo(1);\n    |           ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Thing::Foo(y) = Thing::Foo(1) { /* */ }\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "e5f01174ac1bf7539ebbb0d6cab2a6f0acf806a0", "filename": "src/test/ui/match/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -41,6 +41,13 @@ LL | | }\n ...\n LL |       let E::A = e;\n    |           ^^^^ patterns `B` and `C` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let E::A = e { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:40:11\n@@ -85,6 +92,13 @@ LL | | }\n ...\n LL |       let E::A = e;\n    |           ^^^^ patterns `&B` and `&C` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let E::A = e { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:48:11\n@@ -129,6 +143,13 @@ LL | | }\n ...\n LL |       let E::A = e;\n    |           ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let E::A = e { /* */ }\n+   |\n \n error[E0004]: non-exhaustive patterns: `None` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:65:11\n@@ -163,6 +184,13 @@ LL | | }\n ...\n LL |       let Opt::Some(ref _x) = e;\n    |           ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Opt::Some(ref _x) = e { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 8 previous errors\n "}, {"sha": "f9ae75b18317deeccae691d293ebebf51ebfcb4d", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Ok(x) = res { /* */ }\n+   |\n \n error[E0381]: use of possibly-uninitialized variable: `x`\n   --> $DIR/recursive-types-are-not-uninhabited.rs:8:5"}, {"sha": "0cf5d9cd5f12a6e6a223a61aae2ff7fa475d002b", "filename": "src/test/ui/refutable-pattern-errors.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -9,6 +9,13 @@ error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` an\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n    |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let (1, (Some(1), 2..=3)) = (1, (None, 2)) { /* */ }\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "26e1be34ea75dfb651fa8c4e38c791bb842a617f", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -12,6 +12,13 @@ LL | | }\n ...\n LL |       let Foo::D(_y) = x;\n    |           ^^^^^^^^^^ pattern `A(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Foo::D(_y) = x { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "a49344e45cec652775d6737f3b8c178d9477e0fa", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963e4bc756c91fa9ffd4850576655bc3980230c7/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=963e4bc756c91fa9ffd4850576655bc3980230c7", "patch": "@@ -51,6 +51,13 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Ok(x) = x { /* */ }\n+   |\n \n error: aborting due to 7 previous errors\n "}]}