{"sha": "b24f97801138cb675fbb9e9151d189b6527c4ef5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNGY5NzgwMTEzOGNiNjc1ZmJiOWU5MTUxZDE4OWI2NTI3YzRlZjU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-19T12:34:45Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-22T08:16:09Z"}, "message": "Drop arguments on the caller side, not the callee\n\nThis makes it easier for the caller to optimize the take/drop away for\ntemporary values, and opens up new possibilities for alias handling.\n\nBreaks tail calls.", "tree": {"sha": "ba9c5a3fe56dd18c5e14a742b150cf240037eb67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba9c5a3fe56dd18c5e14a742b150cf240037eb67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b24f97801138cb675fbb9e9151d189b6527c4ef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b24f97801138cb675fbb9e9151d189b6527c4ef5", "html_url": "https://github.com/rust-lang/rust/commit/b24f97801138cb675fbb9e9151d189b6527c4ef5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b24f97801138cb675fbb9e9151d189b6527c4ef5/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35c962e9a18e1fc73939990865bfc799e485c23b", "url": "https://api.github.com/repos/rust-lang/rust/commits/35c962e9a18e1fc73939990865bfc799e485c23b", "html_url": "https://github.com/rust-lang/rust/commit/35c962e9a18e1fc73939990865bfc799e485c23b"}], "stats": {"total": 272, "additions": 125, "deletions": 147}, "files": [{"sha": "a1981e1d2832dae6fce5bbc89cf31410e62652f8", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=b24f97801138cb675fbb9e9151d189b6527c4ef5", "patch": "@@ -148,26 +148,24 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n         time(time_passes, \"freevar finding\",\n              bind freevars::annotate_freevars(sess, def_map, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n-    time::<()>(time_passes, \"typechecking\",\n-               bind typeck::check_crate(ty_cx, crate));\n-    time::<()>(time_passes, \"alt checking\",\n-               bind middle::check_alt::check_crate(ty_cx, crate));\n+    time(time_passes, \"typechecking\",\n+         bind typeck::check_crate(ty_cx, crate));\n+    time(time_passes, \"alt checking\",\n+         bind middle::check_alt::check_crate(ty_cx, crate));\n     if sess.get_opts().run_typestate {\n         time(time_passes, \"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n-    time(time_passes, \"alias checking\",\n-         bind middle::alias::check_crate(ty_cx, crate));\n-    time::<()>(time_passes, \"kind checking\",\n-               bind kind::check_crate(ty_cx, crate));\n+    let mut_map = time(time_passes, \"alias checking\",\n+                       bind middle::alias::check_crate(ty_cx, crate));\n+    time(time_passes, \"kind checking\",\n+         bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n-    let llmod =\n-        time::<llvm::llvm::ModuleRef>(time_passes, \"translation\",\n-                                      bind trans::trans_crate(sess, crate,\n-                                                              ty_cx, output,\n-                                                              ast_map));\n-    time::<()>(time_passes, \"LLVM passes\",\n-               bind link::write::run_passes(sess, llmod, output));\n+    let llmod = time(time_passes, \"translation\",\n+                     bind trans::trans_crate(sess, crate, ty_cx, output,\n+                                             ast_map, mut_map));\n+    time(time_passes, \"LLVM passes\",\n+         bind link::write::run_passes(sess, llmod, output));\n }\n \n fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,"}, {"sha": "e29c06c9239524119f37c09065a440fa6c0b5a14", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=b24f97801138cb675fbb9e9151d189b6527c4ef5", "patch": "@@ -36,20 +36,25 @@ type scope = @[restrict];\n \n tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n-type ctx = {tcx: ty::ctxt, local_map: std::map::hashmap<node_id, local_info>};\n+type mut_map = std::map::hashmap<node_id, ()>;\n+type ctx = {tcx: ty::ctxt,\n+            local_map: std::map::hashmap<node_id, local_info>,\n+            mut_map: mut_map};\n \n-fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n+fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) -> mut_map {\n     // Stores information about object fields and function\n     // arguments that's otherwise not easily available.\n-    let cx = @{tcx: tcx, local_map: std::map::new_int_hash()};\n-    let v =\n-        @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n-          visit_item: bind visit_item(cx, _, _, _),\n-          visit_expr: bind visit_expr(cx, _, _, _),\n-          visit_decl: bind visit_decl(cx, _, _, _)\n-             with *visit::default_visitor::<scope>()};\n+    let cx = @{tcx: tcx,\n+               local_map: std::map::new_int_hash(),\n+               mut_map: std::map::new_int_hash()};\n+    let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n+              visit_item: bind visit_item(cx, _, _, _),\n+              visit_expr: bind visit_expr(cx, _, _, _),\n+              visit_decl: bind visit_decl(cx, _, _, _)\n+              with *visit::default_visitor::<scope>()};\n     visit::visit_crate(*crate, @[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n+    ret cx.mut_map;\n }\n \n fn visit_fn(cx: &@ctx, f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n@@ -425,6 +430,7 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     alt dest.node {\n       ast::expr_path(p) {\n         let dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n+        cx.mut_map.insert(dnum, ());\n         if is_immutable_alias(*cx, sc, dnum) {\n             cx.tcx.sess.span_err(dest.span, \"assigning to immutable alias\");\n         } else if is_immutable_objfield(*cx, dnum) {"}, {"sha": "8932300257c8a1339acd2508c839b18f9d43ca87", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 87, "deletions": 114, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b24f97801138cb675fbb9e9151d189b6527c4ef5", "patch": "@@ -3443,7 +3443,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n \n     // First, synthesize a tuple type containing the types of all the\n     // bound expressions.\n-    // bindings_ty = ~[bound_ty1, bound_ty2, ...]\n+    // bindings_ty = [bound_ty1, bound_ty2, ...]\n     let bindings_ty: ty::t = ty::mk_tup(bcx_tcx(bcx), bound_tys);\n \n     // NB: keep this in sync with T_closure_ptr; we're making\n@@ -4323,16 +4323,8 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n                     if is_val { T_ptr(llout_arg_ty) } else { llout_arg_ty };\n                 val = bcx.build.PointerCast(val, ty);\n             }\n-            if is_val {\n-                if type_is_immediate(cx.ccx, e_ty) {\n-                    val = bcx.build.Load(val);\n-                    bcx = copy_ty(bcx, val, e_ty).bcx;\n-                } else {\n-                    bcx = copy_ty(bcx, val, e_ty).bcx;\n-                    if !ty::type_is_structural(cx.ccx.tcx, e_ty) {\n-                        val = bcx.build.Load(val);\n-                    }\n-                }\n+            if is_val && type_is_immediate(cx.ccx, e_ty) {\n+                val = bcx.build.Load(val);\n             }\n             llargs += [val];\n             b += 1;\n@@ -4343,15 +4335,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n           none. {\n             let arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n             if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n-\n-                // If the argument was passed by value and isn't a\n-                // pointer type, we need to spill it to an alloca in\n-                // order to do a pointer cast. Argh.\n-                if is_val && !ty::type_is_boxed(cx.ccx.tcx, out_arg.ty) {\n-                    let argp = do_spill(bcx, arg);\n-                    argp = bcx.build.PointerCast(argp, T_ptr(llout_arg_ty));\n-                    arg = bcx.build.Load(argp);\n-                } else { arg = bcx.build.PointerCast(arg, llout_arg_ty); }\n+                arg = bcx.build.PointerCast(arg, llout_arg_ty);\n             }\n             llargs += [arg];\n             a += 1u;\n@@ -4371,7 +4355,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n         type_of_fn_from_ty(bcx_ccx(bcx), sp, outgoing_fty, ty_param_count);\n     lltargetfn = bcx.build.PointerCast(lltargetfn, T_ptr(T_ptr(lltargetty)));\n     lltargetfn = bcx.build.Load(lltargetfn);\n-    llvm::LLVMSetTailCall(bcx.build.FastCall(lltargetfn, llargs), 1);\n+    bcx.build.FastCall(lltargetfn, llargs);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n     ret {val: llthunk, ty: llthunk_ty};\n@@ -4468,29 +4452,30 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n         // to have type lldestty0 (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty0);\n     } else if arg.mode == ty::mo_val {\n-        if ty::type_owns_heap_mem(ccx.tcx, e_ty) {\n+        // Eliding take/drop for appending of external vectors currently\n+        // corrupts memory. I can't figure out why, and external vectors\n+        // are on the way out anyway, so this simply turns off the\n+        // optimization for that case.\n+        let is_ext_vec_plus = alt e.node {\n+          ast::expr_binary(_, _, _) {\n+            ty::type_is_sequence(ccx.tcx, e_ty) &&\n+                !ty::sequence_is_interior(ccx.tcx, e_ty)\n+          }\n+          _ { false }\n+        };\n+        if !lv.is_mem && !is_ext_vec_plus {\n+            // Do nothing for temporaries, just give them to callee\n+        } else if ty::type_is_structural(ccx.tcx, e_ty) {\n             let dst = alloc_ty(bcx, e_ty);\n+            bcx = copy_val(dst.bcx, INIT, dst.val, val, e_ty).bcx;\n             val = dst.val;\n-            bcx = move_val_if_temp(dst.bcx, INIT, val, lv, e_ty).bcx;\n-        } else if lv.is_mem {\n-            val = load_if_immediate(bcx, val, e_ty);\n-            bcx = copy_ty(bcx, val, e_ty).bcx;\n+            add_clean_temp(bcx, val, e_ty);\n         } else {\n-            // Eliding take/drop for appending of external vectors currently\n-            // corrupts memory. I can't figure out why, and external vectors\n-            // are on the way out anyway, so this simply turns off the\n-            // optimization for that case.\n-            let is_ext_vec_plus =\n-                alt e.node {\n-                  ast::expr_binary(_, _, _) {\n-                    ty::type_is_sequence(ccx.tcx, e_ty) &&\n-                        !ty::sequence_is_interior(ccx.tcx, e_ty)\n-                  }\n-                  _ { false }\n-                };\n-            if is_ext_vec_plus {\n-                bcx = copy_ty(bcx, val, e_ty).bcx;\n-            } else { revoke_clean(bcx, val); }\n+            if lv.is_mem {\n+                val = load_if_immediate(bcx, val, e_ty);\n+            }\n+            bcx = copy_ty(bcx, val, e_ty).bcx;\n+            add_clean_temp(bcx, val, e_ty);\n         }\n     } else if type_is_immediate(ccx, e_ty) && !lv.is_mem {\n         val = do_spill(bcx, val);\n@@ -4620,13 +4605,14 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n          to_revoke: to_revoke};\n }\n \n-fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n+fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n               lliterbody: &option::t<ValueRef>, args: &[@ast::expr],\n               id: ast::node_id) -> result {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n-\n+    let cx = new_scope_block_ctxt(in_cx, \"call\");\n+    in_cx.build.Br(cx.llbb);\n     let f_res = trans_lval_gen(cx, f);\n     let fn_ty: ty::t;\n     alt f_res.method_ty {\n@@ -4691,7 +4677,7 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n                 // Retval doesn't correspond to anything really tangible\n                 // in the frame, but it's a ref all the same, so we put a\n                 // note here to drop it when we're done in this scope.\n-                add_clean_temp(cx, retval, ret_ty);\n+                add_clean_temp(in_cx, retval, ret_ty);\n             }\n           }\n           some(_) {\n@@ -4705,7 +4691,13 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n         for {v: v, t: t}: {v: ValueRef, t: ty::t} in args_res.to_zero {\n             zero_alloca(bcx, v, t)\n         }\n-        for v: ValueRef in args_res.to_revoke { revoke_clean(bcx, v) }\n+        for v: ValueRef in args_res.to_revoke {\n+            revoke_clean(bcx, v)\n+        }\n+        bcx = trans_block_cleanups(bcx, cx);\n+        let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n+        bcx.build.Br(next_cx.llbb);\n+        bcx = next_cx;\n     }\n     ret rslt(bcx, retval);\n }\n@@ -5230,7 +5222,9 @@ fn trans_fail_value(cx: &@block_ctxt, sp_opt: &option::t<span>,\n     ret rslt(cx, C_nil());\n }\n \n-fn trans_put(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n+fn trans_put(in_cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n+    let cx = new_scope_block_ctxt(in_cx, \"put\");\n+    in_cx.build.Br(cx.llbb);\n     let llcallee = C_nil();\n     let llenv = C_nil();\n     alt { cx.fcx.lliterbody } {\n@@ -5260,7 +5254,10 @@ fn trans_put(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n       }\n     }\n     bcx.build.FastCall(llcallee, llargs);\n-    ret rslt(bcx, C_nil());\n+    bcx = trans_block_cleanups(bcx, cx);\n+    let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n+    bcx.build.Br(next_cx.llbb);\n+    ret rslt(next_cx, C_nil());\n }\n \n fn trans_uniq(cx: &@block_ctxt, contents: &@ast::expr) -> lval_result {\n@@ -5817,57 +5814,40 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n     }\n }\n \n-fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg],\n-                        arg_tys: &[ty::arg]) {\n+fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt,\n+                        args: &[ast::arg], arg_tys: &[ty::arg]) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let arg_n: uint = 0u;\n     for aarg: ast::arg in args {\n-        if aarg.mode == ast::val {\n-            let argval, arg_ty = arg_tys.(arg_n).ty;\n-            alt bcx.fcx.llargs.find(aarg.id) {\n-              some(x) { argval = x; }\n-              _ {\n-                bcx_ccx(bcx).sess.span_fatal(\n-                    aarg.ty.span,\n-                    \"unbound arg ID in copy_args_to_allocas\");\n-              }\n-            }\n-            let a;\n-            if ty::type_is_structural(fcx_tcx(fcx), arg_ty) {\n-                a = alloca(bcx, llvm::LLVMGetElementType(val_ty(argval)));\n-                bcx = memmove_ty(bcx, a, argval, arg_ty).bcx;\n-            } else {\n-                a = do_spill(bcx, argval);\n+        let arg_ty = arg_tys[arg_n].ty;\n+        alt aarg.mode {\n+          ast::val. {\n+            // Structural types are passed by pointer, and we use the\n+            // pointed-to memory for the local.\n+            if !ty::type_is_structural(fcx_tcx(fcx), arg_ty) {\n+                // Overwrite the llargs entry for this arg with its alloca.\n+                let aval = bcx.fcx.llargs.get(aarg.id);\n+                let addr = do_spill(bcx, aval);\n+                bcx.fcx.llargs.insert(aarg.id, addr);\n+\n+                // Args that are locally assigned to need to do a local\n+                // take/drop\n+                if fcx.lcx.ccx.mut_map.contains_key(aarg.id) {\n+                    bcx = copy_ty(bcx, aval, arg_ty).bcx;\n+                    add_clean(scope, addr, arg_ty);\n+                }\n             }\n-\n-            // Overwrite the llargs entry for this arg with its alloca.\n-            bcx.fcx.llargs.insert(aarg.id, a);\n+          }\n+          ast::move. {\n+            add_clean(scope, bcx.fcx.llargs.get(aarg.id), arg_ty);\n+          }\n+          _ {}\n         }\n         arg_n += 1u;\n     }\n     fcx.llcopyargs = bcx.llbb;\n }\n \n-fn add_cleanups_for_args(bcx: &@block_ctxt, args: &[ast::arg],\n-                         arg_tys: &[ty::arg]) {\n-    let arg_n: uint = 0u;\n-    for aarg: ast::arg in args {\n-        if aarg.mode == ast::val || aarg.mode == ast::move {\n-            let argval;\n-            alt bcx.fcx.llargs.find(aarg.id) {\n-              some(x) { argval = x; }\n-              _ {\n-                bcx_ccx(bcx).sess.span_fatal(\n-                    aarg.ty.span,\n-                    \"unbound arg ID in add_cleanups_for_args\");\n-              }\n-            }\n-            add_clean(bcx, argval, arg_tys[arg_n].ty);\n-        }\n-        arg_n += 1u;\n-    }\n-}\n-\n fn is_terminated(cx: &@block_ctxt) -> bool {\n     let inst = llvm::LLVMGetLastInstruction(cx.llbb);\n     ret llvm::LLVMIsATerminatorInst(inst) as int != 0;\n@@ -5964,8 +5944,15 @@ fn trans_closure(bcx_maybe: &option::t<@block_ctxt>,\n       some(llself) { populate_fn_ctxt_from_llself(fcx, llself); }\n       _ { }\n     }\n+\n+    // Create the first basic block in the function and keep a handle on it to\n+    //  pass to finish_fn later.\n+    let bcx = new_top_block_ctxt(fcx);\n+    let lltop = bcx.llbb;\n+    let block_ty = node_id_type(cx.ccx, f.body.node.id);\n+\n     let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n-    copy_args_to_allocas(fcx, f.decl.inputs, arg_tys);\n+    copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys);\n \n     // Figure out if we need to build a closure and act accordingly\n     let res =\n@@ -5989,12 +5976,6 @@ fn trans_closure(bcx_maybe: &option::t<@block_ctxt>,\n           _ { none }\n         };\n \n-    // Create the first basic block in the function and keep a handle on it to\n-    //  pass to finish_fn later.\n-    let bcx = new_top_block_ctxt(fcx);\n-    add_cleanups_for_args(bcx, f.decl.inputs, arg_tys);\n-    let lltop = bcx.llbb;\n-    let block_ty = node_id_type(cx.ccx, f.body.node.id);\n \n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n@@ -6119,8 +6100,8 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         i += 1u;\n     }\n     let arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);\n-    copy_args_to_allocas(fcx, fn_args, arg_tys);\n     let bcx = new_top_block_ctxt(fcx);\n+    copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n     let lltop = bcx.llbb;\n \n     // Cast the tag to a type we can GEP into.\n@@ -6333,16 +6314,12 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n         let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n         let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n         let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n-        let args = if takes_ivec {\n-            ~[lloutputarg, lltaskarg, llenvarg, llargvarg]\n-        } else {\n-            // If the crate's main function doesn't take the args vector then\n-            // we're responsible for freeing it\n-            bcx = maybe_free_ivec_heap_part(bcx, llargvarg,\n-                                            ty::mk_str(ccx.tcx)).bcx;\n-            ~[lloutputarg, lltaskarg, llenvarg]\n-        };\n+        let args = [lloutputarg, lltaskarg, llenvarg];\n+        if takes_ivec { args += [llargvarg]; }\n         bcx.build.FastCall(main_llfn, args);\n+        // We're responsible for freeing the arg vector\n+        bcx = maybe_free_ivec_heap_part(bcx, llargvarg,\n+                                        ty::mk_str(ccx.tcx)).bcx;\n         build_return(bcx);\n \n         finish_fn(fcx, lltop);\n@@ -6555,7 +6532,6 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     let args = ty::ty_fn_args(ccx.tcx, fn_type);\n     // Build up the list of arguments.\n \n-    let drop_args: [{val: ValueRef, ty: ty::t}] = [];\n     let i = arg_n;\n     for arg: ty::arg in args {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n@@ -6564,7 +6540,6 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n             let llarg_i32 = convert_arg_to_i32(bcx, llarg, arg.ty, arg.mode);\n             call_args += [llarg_i32];\n         } else { call_args += [llarg]; }\n-        if arg.mode == ty::mo_val { drop_args += [{val: llarg, ty: arg.ty}]; }\n         i += 1u;\n     }\n     let r;\n@@ -6594,9 +6569,8 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n         rptr = result.rptr;\n       }\n       _ {\n-        r =\n-            trans_native_call(bcx.build, ccx.externs, ccx.llmod, name,\n-                              call_args);\n+        r = trans_native_call(bcx.build, ccx.externs,\n+                              ccx.llmod, name, call_args);\n         rptr = bcx.build.BitCast(fcx.llretptr, T_ptr(T_i32()));\n       }\n     }\n@@ -6606,9 +6580,6 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n \n     if !rty_is_nil && !uses_retptr { bcx.build.Store(r, rptr); }\n \n-    for d: {val: ValueRef, ty: ty::t} in drop_args {\n-        bcx = drop_ty(bcx, d.val, d.ty).bcx;\n-    }\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n }\n@@ -6927,7 +6898,8 @@ fn write_abi_version(ccx: &@crate_ctxt) {\n }\n \n fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n-               output: &str, amap: &ast_map::map) -> ModuleRef {\n+               output: &str, amap: &ast_map::map, mut_map: alias::mut_map)\n+    -> ModuleRef {\n     let llmod =\n         llvm::LLVMModuleCreateWithNameInContext(str::buf(\"rust_out\"),\n                                                 llvm::LLVMGetGlobalContext());\n@@ -6979,6 +6951,7 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n           type_sha1s: sha1s,\n           type_short_names: short_names,\n           tcx: tcx,\n+          mut_map: mut_map,\n           stats:\n               {mutable n_static_tydescs: 0u,\n                mutable n_derived_tydescs: 0u,"}, {"sha": "bf7a03cdbf117f05a9d266a393fece09b7327a49", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=b24f97801138cb675fbb9e9151d189b6527c4ef5", "patch": "@@ -142,6 +142,7 @@ type crate_ctxt =\n      type_sha1s: hashmap<ty::t, str>,\n      type_short_names: hashmap<ty::t, str>,\n      tcx: ty::ctxt,\n+     mut_map: alias::mut_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      rust_object_type: TypeRef,"}, {"sha": "5bbd281ef485b4c1f817bd24ad3d084e70429191", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=b24f97801138cb675fbb9e9151d189b6527c4ef5", "patch": "@@ -50,17 +50,17 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n+    //  Create the first block context in the function and keep a handle on it\n+    //  to pass to finish_fn later.\n+    let bcx = new_top_block_ctxt(fcx);\n+    let lltop = bcx.llbb;\n+\n     // Both regular arguments and type parameters are handled here.\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none::<ty::t>,\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n                               ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n-    copy_args_to_allocas(fcx, fn_args, arg_tys);\n-\n-    //  Create the first block context in the function and keep a handle on it\n-    //  to pass to finish_fn later.\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n+    copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n     // Pick up the type of this object by looking at our own output type, that\n     // is, the output type of the object constructor we're building."}, {"sha": "ef04e66d756ae481fd31e90861d5979f72aac7db", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=b24f97801138cb675fbb9e9151d189b6527c4ef5", "patch": "@@ -334,7 +334,6 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n \n     let fold_mac = bind fold_mac_(_, fld);\n \n-\n     ret alt e {\n           expr_vec(exprs, mut) {\n             expr_vec(fld.map_exprs(fld.fold_expr, exprs), mut)"}, {"sha": "d20f345b3affff29827c8303b35c6c3894f27416", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=b24f97801138cb675fbb9e9151d189b6527c4ef5", "patch": "@@ -1081,7 +1081,8 @@ fn parse_dot_or_call_expr_with(p: &parser, e: @ast::expr) -> @ast::expr {\n                     parse_seq(token::LPAREN, token::RPAREN,\n                               some(token::COMMA), parse_expr, p);\n                 hi = es.span.hi;\n-                e = mk_expr(p, lo, hi, ast::expr_call(e, es.node));\n+                let nd = ast::expr_call(e, es.node);\n+                e = mk_expr(p, lo, hi, nd);\n             }\n           }\n           token::LBRACKET. {"}, {"sha": "357821ac34ea557bc630bb769bab02d32778ea6d", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24f97801138cb675fbb9e9151d189b6527c4ef5/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=b24f97801138cb675fbb9e9151d189b6527c4ef5", "patch": "@@ -6,7 +6,7 @@ mod foo {\n     export g;\n \n     // not exported\n-    tag t { t1; }\n+    tag t { t1; t2; }\n \n     fn f() -> t { ret t1; }\n "}]}