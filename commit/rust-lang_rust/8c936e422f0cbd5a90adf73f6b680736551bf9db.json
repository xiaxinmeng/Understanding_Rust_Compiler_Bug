{"sha": "8c936e422f0cbd5a90adf73f6b680736551bf9db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjOTM2ZTQyMmYwY2JkNWE5MGFkZjczZjZiNjgwNzM2NTUxYmY5ZGI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-11-30T14:19:12Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-05-23T16:51:42Z"}, "message": "Update inherent_impls", "tree": {"sha": "960d64313fe48381ef9c4cd68224d0f97d8b44fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/960d64313fe48381ef9c4cd68224d0f97d8b44fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c936e422f0cbd5a90adf73f6b680736551bf9db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c936e422f0cbd5a90adf73f6b680736551bf9db", "html_url": "https://github.com/rust-lang/rust/commit/8c936e422f0cbd5a90adf73f6b680736551bf9db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c936e422f0cbd5a90adf73f6b680736551bf9db/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ba144d5dd095390e10bd0000ae80c208fb2d74c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba144d5dd095390e10bd0000ae80c208fb2d74c", "html_url": "https://github.com/rust-lang/rust/commit/4ba144d5dd095390e10bd0000ae80c208fb2d74c"}], "stats": {"total": 48, "additions": 21, "deletions": 27}, "files": [{"sha": "a66a27d140772b64306cad9d649995662a155458", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=8c936e422f0cbd5a90adf73f6b680736551bf9db", "patch": "@@ -58,6 +58,7 @@ macro_rules! arena_types {\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx, rustc::ty::Ty<'tcx>>\n                 >,\n+            [few] crate_inherent_impls: rustc::ty::CrateInherentImpls,\n         ], $tcx);\n     )\n }"}, {"sha": "b2b555d84319c4ff69050c11acdc4d3116a03af1", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=8c936e422f0cbd5a90adf73f6b680736551bf9db", "patch": "@@ -277,7 +277,7 @@ rustc_queries! {\n         /// Maps a `DefId` of a type to a list of its inherent impls.\n         /// Contains implementations of methods that are inherent to a type.\n         /// Methods in these implementations don't need to be exported.\n-        query inherent_impls(_: DefId) -> Lrc<Vec<DefId>> {\n+        query inherent_impls(_: DefId) -> &'tcx [DefId] {\n             eval_always\n         }\n     }\n@@ -383,7 +383,7 @@ rustc_queries! {\n         /// Not meant to be used directly outside of coherence.\n         /// (Defined only for `LOCAL_CRATE`.)\n         query crate_inherent_impls(k: CrateNum)\n-            -> Lrc<CrateInherentImpls> {\n+            -> &'tcx CrateInherentImpls {\n             eval_always\n             desc { \"all inherent impls defined in crate `{:?}`\", k }\n         }"}, {"sha": "535da8557ee906c9cea882ad65bc840f6a166b6e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8c936e422f0cbd5a90adf73f6b680736551bf9db", "patch": "@@ -3389,7 +3389,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// (constructing this map requires touching the entire crate).\n #[derive(Clone, Debug, Default, HashStable)]\n pub struct CrateInherentImpls {\n-    pub inherent_impls: DefIdMap<Lrc<Vec<DefId>>>,\n+    pub inherent_impls: DefIdMap<Vec<DefId>>,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]"}, {"sha": "d94c07ce072a5245a59ace812547645a1ae01075", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=8c936e422f0cbd5a90adf73f6b680736551bf9db", "patch": "@@ -135,7 +135,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         (cdata.mir_const_qualif(def_id.index), tcx.arena.alloc(BitSet::new_empty(0)))\n     }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n-    inherent_impls => { Lrc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+    inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     static_mutability => { cdata.static_mutability(def_id.index) }"}, {"sha": "a2ea0fd6f553c00a77b51b4c0cbe81806817ebc3", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=8c936e422f0cbd5a90adf73f6b680736551bf9db", "patch": "@@ -1013,12 +1013,15 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    pub fn get_inherent_implementations_for_type(&self, id: DefIndex) -> Vec<DefId> {\n-        self.entry(id)\n-            .inherent_impls\n-            .decode(self)\n-            .map(|index| self.local_def_id(index))\n-            .collect()\n+    pub fn get_inherent_implementations_for_type(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, '_>,\n+        id: DefIndex\n+    ) -> &'tcx [DefId] {\n+        tcx.arena.alloc_from_iter(self.entry(id)\n+                                      .inherent_impls\n+                                      .decode(self)\n+                                      .map(|index| self.local_def_id(index)))\n     }\n \n     pub fn get_implementations_for_trait(&self,"}, {"sha": "644d95963e652cdf5a882fbf05675178dafaec9c", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c936e422f0cbd5a90adf73f6b680736551bf9db/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=8c936e422f0cbd5a90adf73f6b680736551bf9db", "patch": "@@ -13,14 +13,13 @@ use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::{self, CrateInherentImpls, TyCtxt};\n \n-use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       crate_num: CrateNum)\n-                                      -> Lrc<CrateInherentImpls> {\n+                                      -> &'tcx CrateInherentImpls {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -29,13 +28,13 @@ pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         impls_map: Default::default(),\n     };\n     krate.visit_all_item_likes(&mut collect);\n-    Lrc::new(collect.impls_map)\n+    tcx.arena.alloc(collect.impls_map)\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type.\n pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 ty_def_id: DefId)\n-                                -> Lrc<Vec<DefId>> {\n+                                -> &'tcx [DefId] {\n     assert!(ty_def_id.is_local());\n \n     // NB. Until we adopt the red-green dep-tracking algorithm (see\n@@ -53,15 +52,11 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n \n-    thread_local! {\n-        static EMPTY_DEF_ID_VEC: Lrc<Vec<DefId>> = Lrc::new(vec![])\n-    }\n-\n     let result = tcx.dep_graph.with_ignore(|| {\n         let crate_map = tcx.crate_inherent_impls(ty_def_id.krate);\n         match crate_map.inherent_impls.get(&ty_def_id) {\n-            Some(v) => v.clone(),\n-            None => EMPTY_DEF_ID_VEC.with(|v| v.clone())\n+            Some(v) => &v[..],\n+            None => &[],\n         }\n     });\n \n@@ -289,13 +284,8 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n             let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n-            let mut rc_vec = self.impls_map.inherent_impls\n-                                           .entry(def_id)\n-                                           .or_default();\n-\n-            // At this point, there should not be any clones of the\n-            // `Lrc`, so we can still safely push into it in place:\n-            Lrc::get_mut(&mut rc_vec).unwrap().push(impl_def_id);\n+            let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n+            vec.push(impl_def_id);\n         } else {\n             struct_span_err!(self.tcx.sess,\n                              item.span,"}]}