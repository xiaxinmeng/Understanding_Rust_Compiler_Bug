{"sha": "457e78cd538ed057a2546ced28688cec44dcf264", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1N2U3OGNkNTM4ZWQwNTdhMjU0NmNlZDI4Njg4Y2VjNDRkY2YyNjQ=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-16T23:44:22Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-18T00:14:32Z"}, "message": "Make by-val explicit self actually work. Closes #2585.", "tree": {"sha": "22b66ee1d14d9d50dd75e157d40c54599b20d5ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22b66ee1d14d9d50dd75e157d40c54599b20d5ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/457e78cd538ed057a2546ced28688cec44dcf264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/457e78cd538ed057a2546ced28688cec44dcf264", "html_url": "https://github.com/rust-lang/rust/commit/457e78cd538ed057a2546ced28688cec44dcf264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/457e78cd538ed057a2546ced28688cec44dcf264/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b457c265482fee2ecb44e4c7a98da8b887756db", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b457c265482fee2ecb44e4c7a98da8b887756db", "html_url": "https://github.com/rust-lang/rust/commit/2b457c265482fee2ecb44e4c7a98da8b887756db"}], "stats": {"total": 269, "additions": 199, "deletions": 70}, "files": [{"sha": "609b4d2778cb262a91392284ba6211e423d362e9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -1522,9 +1522,10 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     s.ann.post(ann_node);\n }\n \n-fn print_self_ty(s: ps, self_ty: ast::self_ty_) {\n+// Returns whether it printed anything\n+fn print_self_ty(s: ps, self_ty: ast::self_ty_) -> bool {\n     match self_ty {\n-      ast::sty_static | ast::sty_by_ref => {}\n+      ast::sty_static | ast::sty_by_ref => { return false; }\n       ast::sty_value => { word(s.s, ~\"self\"); }\n       ast::sty_region(m) => {\n         word(s.s, ~\"&\"); print_mutability(s, m); word(s.s, ~\"self\");\n@@ -1536,6 +1537,7 @@ fn print_self_ty(s: ps, self_ty: ast::self_ty_) {\n         word(s.s, ~\"~\"); print_mutability(s, m); word(s.s, ~\"self\");\n       }\n     }\n+    return true;\n }\n \n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n@@ -1556,8 +1558,7 @@ fn print_fn_args(s: ps, decl: ast::fn_decl,\n     box(s, 0u, inconsistent);\n     let mut first = true;\n     for opt_self_ty.each |self_ty| {\n-        first = false;\n-        print_self_ty(s, self_ty);\n+        first = !print_self_ty(s, self_ty);\n     }\n \n     for decl.inputs.each |arg| {\n@@ -1780,8 +1781,7 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n     box(s, 0u, inconsistent);\n     let mut first = true;\n     for opt_self_ty.each |self_ty| {\n-        first = false;\n-        print_self_ty(s, self_ty);\n+        first = !print_self_ty(s, self_ty);\n     }\n     for decl.inputs.each |arg| {\n         if first { first = false; } else { word_space(s, ~\",\"); }"}, {"sha": "342113a17b1dfeab8c416ec779b1a3e90d7a9890", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -412,7 +412,9 @@ trait read_method_map_entry_helper {\n impl ebml::ebml_deserializer: read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n         let mme = deserialize_method_map_entry(self);\n-        {derefs: mme.derefs, origin: mme.origin.tr(xcx)}\n+        {derefs: mme.derefs,\n+         self_mode: mme.self_mode,\n+         origin: mme.origin.tr(xcx)}\n     }\n }\n "}, {"sha": "35675b9102b32c254cab2acb4ae396343d173967", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -215,6 +215,51 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n \n fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     debug!{\"kind::check_expr(%s)\", expr_to_str(e)};\n+\n+    // Handle any kind bounds on type parameters\n+    do option::iter(cx.tcx.node_type_substs.find(e.id)) |ts| {\n+        let bounds = match check e.node {\n+          expr_path(_) => {\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n+            ty::lookup_item_type(cx.tcx, did).bounds\n+          }\n+          _ => {\n+            // Type substitions should only occur on paths and\n+            // method calls, so this needs to be a method call.\n+            match cx.method_map.get(e.id).origin {\n+              typeck::method_static(did) => {\n+                // n.b.: When we encode class/impl methods, the bounds\n+                // that we encode include both the class/impl bounds\n+                // and then the method bounds themselves...\n+                ty::lookup_item_type(cx.tcx, did).bounds\n+              }\n+              typeck::method_param({trait_id:trt_id,\n+                                    method_num:n_mth, _}) |\n+              typeck::method_trait(trt_id, n_mth) => {\n+                // ...trait methods bounds, in contrast, include only the\n+                // method bounds, so we must preprend the tps from the\n+                // trait itself.  This ought to be harmonized.\n+                let trt_bounds =\n+                    ty::lookup_item_type(cx.tcx, trt_id).bounds;\n+                let mth = ty::trait_methods(cx.tcx, trt_id)[n_mth];\n+                @(vec::append(*trt_bounds, *mth.tps))\n+              }\n+            }\n+          }\n+        };\n+        if vec::len(ts) != vec::len(*bounds) {\n+            // Fail earlier to make debugging easier\n+            fail fmt!(\"Internal error: in kind::check_expr, length \\\n+                       mismatch between actual and declared bounds: actual = \\\n+                        %s (%u tys), declared = %? (%u tys)\",\n+                      tys_to_str(cx.tcx, ts), ts.len(),\n+                      *bounds, (*bounds).len());\n+        }\n+        do vec::iter2(ts, *bounds) |ty, bound| {\n+            check_bounds(cx, e.id, e.span, ty, bound)\n+        }\n+    }\n+\n     match e.node {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n@@ -266,45 +311,12 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             i += 1u;\n         }\n       }\n-      expr_path(_) | expr_field(_, _, _) => {\n-        do option::iter(cx.tcx.node_type_substs.find(e.id)) |ts| {\n-            let bounds = match check e.node {\n-              expr_path(_) => {\n-                let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n-                ty::lookup_item_type(cx.tcx, did).bounds\n-              }\n-              expr_field(base, _, _) => {\n-                match cx.method_map.get(e.id).origin {\n-                  typeck::method_static(did) => {\n-                    // n.b.: When we encode class/impl methods, the bounds\n-                    // that we encode include both the class/impl bounds\n-                    // and then the method bounds themselves...\n-                    ty::lookup_item_type(cx.tcx, did).bounds\n-                  }\n-                  typeck::method_param({trait_id:trt_id,\n-                                        method_num:n_mth, _}) |\n-                  typeck::method_trait(trt_id, n_mth) => {\n-                    // ...trait methods bounds, in contrast, include only the\n-                    // method bounds, so we must preprend the tps from the\n-                    // trait itself.  This ought to be harmonized.\n-                    let trt_bounds =\n-                        ty::lookup_item_type(cx.tcx, trt_id).bounds;\n-                    let mth = ty::trait_methods(cx.tcx, trt_id)[n_mth];\n-                    @(vec::append(*trt_bounds, *mth.tps))\n-                  }\n-                }\n-              }\n-            };\n-            if vec::len(ts) != vec::len(*bounds) {\n-              // Fail earlier to make debugging easier\n-              fail fmt!{\"Internal error: in kind::check_expr, length \\\n-                  mismatch between actual and declared bounds: actual = \\\n-                  %s (%u tys), declared = %? (%u tys)\",\n-                  tys_to_str(cx.tcx, ts), ts.len(), *bounds, (*bounds).len()};\n-            }\n-            do vec::iter2(ts, *bounds) |ty, bound| {\n-                check_bounds(cx, e.id, e.span, ty, bound)\n-            }\n+      expr_field(lhs, _, _) => {\n+        // If this is a method call with a by-val argument, we need\n+        // to check the copy\n+        match cx.method_map.find(e.id) {\n+          some({self_mode: by_copy, _}) => maybe_copy(cx, lhs),\n+          _ => ()\n         }\n       }\n       expr_repeat(element, count_expr, _) => {"}, {"sha": "0e068f68312876fcb53db6eaf51b6ab4ae0fe3da", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -1984,7 +1984,7 @@ type lval_result = {bcx: block, val: ValueRef, kind: lval_kind};\n enum callee_env {\n     null_env,\n     is_closure,\n-    self_env(ValueRef, ty::t, option<ValueRef>),\n+    self_env(ValueRef, ty::t, option<ValueRef>, ast::rmode),\n }\n type lval_maybe_callee = {bcx: block,\n                           val: ValueRef,\n@@ -2447,7 +2447,9 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     }\n }\n \n-fn cast_self(cx: block, slf: val_self_pair) -> ValueRef {\n+// This shouldn't exist. We should cast self *once*, but right now this\n+// conflicts with default methods.\n+fn cast_self(cx: block, slf: val_self_data) -> ValueRef {\n     PointerCast(cx, slf.v, T_ptr(type_of(cx.ccx(), slf.t)))\n }\n \n@@ -3201,7 +3203,7 @@ fn trans_call_inner(\n           null_env => {\n             llvm::LLVMGetUndef(T_opaque_box_ptr(ccx))\n           }\n-          self_env(e, _, _) => {\n+          self_env(e, _, _, _) => {\n             PointerCast(bcx, e, T_opaque_box_ptr(ccx))\n           }\n           is_closure => {\n@@ -3225,6 +3227,13 @@ fn trans_call_inner(\n \n         let llretslot = args_res.retslot;\n \n+        // Now that the arguments have finished evaluating, we need to revoke\n+        // the cleanup for the self argument, if it exists\n+        match f_res.env {\n+          self_env(e, _, _, ast::by_copy) => revoke_clean(bcx, e),\n+          _ => (),\n+        }\n+\n         /* If the block is terminated,\n         then one or more of the args has\n         type _|_. Since that means it diverges, the code\n@@ -4635,7 +4644,10 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n     let mut arg_n = first_real_arg;\n     match ty_self {\n       impl_self(tt) => {\n-        cx.llself = some({v: cx.llenv, t: tt});\n+        cx.llself = some({v: cx.llenv, t: tt, is_owned: false});\n+      }\n+      impl_owned_self(tt) => {\n+        cx.llself = some({v: cx.llenv, t: tt, is_owned: true});\n       }\n       no_self => ()\n     }\n@@ -4662,6 +4674,21 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n         tcx.sess.bug(~\"someone forgot\\\n                 to document an invariant in copy_args_to_allocas!\");\n     };\n+\n+    match fcx.llself {\n+      some(copy slf) => {\n+        // We really should do this regardless of whether self is owned,\n+        // but it doesn't work right with default method impls yet.\n+        if slf.is_owned {\n+            let self_val = PointerCast(bcx, slf.v,\n+                                       T_ptr(type_of(bcx.ccx(), slf.t)));\n+            fcx.llself = some({v: self_val with slf});\n+            add_clean(bcx, self_val, slf.t);\n+        }\n+      }\n+      _ => {}\n+    }\n+\n     for vec::each(arg_tys) |arg| {\n         let id = args[arg_n].id;\n         let argval = match fcx.llargs.get(id) {\n@@ -4705,7 +4732,7 @@ fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     Br(raw_block(fcx, false, fcx.llloadenv), lltop);\n }\n \n-enum self_arg { impl_self(ty::t), no_self, }\n+enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n \n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n@@ -4897,7 +4924,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   }\n \n   // note we don't want to take *or* drop self.\n-  fcx.llself = some({v: selfptr, t: rslt_ty});\n+  fcx.llself = some({v: selfptr, t: rslt_ty, is_owned: false});\n \n   // Translate the body of the ctor\n   bcx = trans_block(bcx_top, body, ignore);"}, {"sha": "8414995181f0c1fb3c6ed720ed8d710ad53d32b4", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -141,7 +141,7 @@ type crate_ctxt = {\n      mut do_not_commit_warning_issued: bool};\n \n // Types used for llself.\n-type val_self_pair = {v: ValueRef, t: ty::t};\n+type val_self_data = {v: ValueRef, t: ty::t, is_owned: bool};\n \n enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n@@ -177,7 +177,7 @@ type fn_ctxt = @{\n     mut llreturn: BasicBlockRef,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n-    mut llself: option<val_self_pair>,\n+    mut llself: option<val_self_data>,\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     mut personality: option<ValueRef>,"}, {"sha": "07923695183ec7b3fefc3d58662e32a310790b74", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -35,12 +35,11 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               ast::sty_uniq(_) => {\n                 impl_self(ty::mk_imm_uniq(ccx.tcx, self_ty))\n               }\n-              // XXX: Is this right at all?\n               ast::sty_region(*) => {\n                 impl_self(ty::mk_imm_ptr(ccx.tcx, self_ty))\n               }\n               ast::sty_value => {\n-                ccx.sess.unimpl(~\"by value self type not implemented\");\n+                impl_owned_self(self_ty)\n               }\n               ast::sty_by_ref => { impl_self(self_ty) }\n             };\n@@ -54,18 +53,22 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     }\n }\n \n-fn trans_self_arg(bcx: block, base: @ast::expr, derefs: uint) -> result {\n+fn trans_self_arg(bcx: block, base: @ast::expr,\n+                  mentry: typeck::method_map_entry) -> result {\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let basety = expr_ty(bcx, base);\n-    let m_by_ref = ast::expl(ast::by_ref);\n+    let mode = ast::expl(mentry.self_mode);\n     let mut temp_cleanups = ~[];\n-    let result = trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n+    let result = trans_arg_expr(bcx, {mode: mode, ty: basety},\n                                 T_ptr(type_of::type_of(bcx.ccx(), basety)),\n-                                base, temp_cleanups, none, derefs);\n+                                base, temp_cleanups, none, mentry.derefs);\n \n     // by-ref self argument should not require cleanup in the case of\n     // other arguments failing:\n-    assert temp_cleanups == ~[];\n+    //assert temp_cleanups == ~[];\n+    //do vec::iter(temp_cleanups) |c| {\n+    //    revoke_clean(bcx, c)\n+    //}\n \n     return result;\n }\n@@ -76,16 +79,19 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n     match mentry.origin {\n       typeck::method_static(did) => {\n-        let {bcx, val} = trans_self_arg(bcx, self, mentry.derefs);\n-        {env: self_env(val, node_id_type(bcx, self.id), none)\n+\n+\n+        let {bcx, val} = trans_self_arg(bcx, self, mentry);\n+        {env: self_env(val, node_id_type(bcx, self.id), none,\n+                       mentry.self_mode)\n          with lval_static_fn(bcx, did, callee_id)}\n       }\n       typeck::method_param({trait_id:trait_id, method_num:off,\n                             param_num:p, bound_num:b}) => {\n         match check bcx.fcx.param_substs {\n           some(substs) => {\n             let vtbl = find_vtable_in_fn_ctxt(substs, p, b);\n-            trans_monomorphized_callee(bcx, callee_id, self, mentry.derefs,\n+            trans_monomorphized_callee(bcx, callee_id, self, mentry,\n                                        trait_id, off, vtbl)\n           }\n         }\n@@ -184,7 +190,8 @@ fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n }\n \n fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n-                              base: @ast::expr, derefs: uint,\n+                              base: @ast::expr,\n+                              mentry: typeck::method_map_entry,\n                               trait_id: ast::def_id, n_method: uint,\n                               vtbl: typeck::vtable_origin)\n     -> lval_maybe_callee {\n@@ -200,10 +207,11 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n             = vec::append(impl_substs,\n                           vec::tailn(node_substs,\n                                      node_substs.len() - n_m_tps));\n-        let {bcx, val} = trans_self_arg(bcx, base, derefs);\n+        let {bcx, val} = trans_self_arg(bcx, base, mentry);\n         let lval = lval_static_fn_inner(bcx, mth_id, callee_id, ty_substs,\n                                         some(sub_origins));\n-        {env: self_env(val, node_id_type(bcx, base.id), none),\n+        {env: self_env(val, node_id_type(bcx, base.id),\n+                       none, mentry.self_mode),\n          val: PointerCast(bcx, lval.val, T_ptr(type_of_fn_from_ty(\n              ccx, node_id_type(bcx, callee_id))))\n          with lval}\n@@ -230,7 +238,9 @@ fn trans_trait_callee(bcx: block, val: ValueRef,\n     let llbox = Load(bcx, GEPi(bcx, val, ~[0u, 1u]));\n     // FIXME[impl] I doubt this is alignment-safe (#2534)\n     let self = GEPi(bcx, llbox, ~[0u, abi::box_field_body]);\n-    let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), some(llbox));\n+    let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), some(llbox),\n+                       // XXX: is this bogosity?\n+                       ast::by_ref);\n     let llfty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));"}, {"sha": "ded6a2b41f891e159a6feb0b95d484daed73d40d", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -113,6 +113,9 @@ type method_map_entry = {\n     // number of derefs that are required on the receiver\n     derefs: uint,\n \n+    // the mode by which the self parameter needs to be passed\n+    self_mode: ast::rmode,\n+\n     // method details being invoked\n     origin: method_origin\n };"}, {"sha": "a885fa0b5c0f99166876bd2537da2573fb8b5e21", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -5,7 +5,7 @@ import middle::resolve3::{Impl, MethodInfo};\n import middle::ty::{mk_box, mk_rptr, mk_uniq};\n import syntax::ast::{def_id,\n                      sty_static, sty_box, sty_by_ref, sty_region, sty_uniq};\n-import syntax::ast::{sty_value};\n+import syntax::ast::{sty_value, by_ref, by_copy};\n import syntax::ast_map;\n import syntax::ast_map::node_id_to_str;\n import syntax::ast_util::{dummy_sp, new_def_hash};\n@@ -56,6 +56,13 @@ fn transform_self_type_for_method\n     }\n }\n \n+fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n+    match self_type {\n+      sty_value => by_copy,\n+      _ => by_ref\n+    }\n+}\n+\n struct lookup {\n     let fcx: @fn_ctxt;\n     let expr: @ast::expr;\n@@ -478,6 +485,8 @@ struct lookup {\n                          n_tps_m: m.n_tps,\n                          fty: fty,\n                          entry: {derefs: self.derefs,\n+                                 self_mode: get_mode_from_self_type(\n+                                     m.self_type),\n                                  origin: method_static(m.did)},\n                          mode: mode});\n                     self.candidate_impls.insert(im.did, ());\n@@ -506,7 +515,9 @@ struct lookup {\n              rcvr_ty: self.self_ty,\n              n_tps_m: (*m.tps).len(),\n              fty: fty,\n-             entry: {derefs: self.derefs, origin: origin},\n+             entry: {derefs: self.derefs,\n+                     self_mode: get_mode_from_self_type(m.self_ty),\n+                     origin: origin},\n              mode: subtyping_mode});\n     }\n "}, {"sha": "7bf490c3da241b1a8d1aab2c206023a213e62e9d", "filename": "src/test/run-pass/explicit-self.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/457e78cd538ed057a2546ced28688cec44dcf264/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e78cd538ed057a2546ced28688cec44dcf264/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=457e78cd538ed057a2546ced28688cec44dcf264", "patch": "@@ -0,0 +1,64 @@\n+\n+const tau: float = 2.0*3.14159265358979323;\n+\n+type point = {x: float, y: float};\n+type size = {w: float, h: float};\n+enum shape {\n+    circle(point, float),\n+    rectangle(point, size)\n+}\n+\n+\n+fn compute_area(shape: &shape) -> float {\n+    match *shape {\n+        circle(_, radius) => 0.5 * tau * radius * radius,\n+        rectangle(_, ref size) => size.w * size.h\n+    }\n+}\n+\n+impl shape {\n+    // self is in the implicit self region\n+    fn select<T>(&self, threshold: float,\n+                 a: &T, b: &T) -> &T {\n+        if compute_area(self) > threshold {a} else {b}\n+    }\n+}\n+\n+fn select_based_on_unit_circle<T>(\n+    threshold: float, a: &T, b: &T) -> &T {\n+\n+    let shape = &circle({x: 0.0, y: 0.0}, 1.0);\n+    shape.select(threshold, a, b)\n+}\n+\n+\n+struct thing {\n+    x: {mut a: @int};\n+    new (x: {mut a: @int}) { self.x = copy x; }\n+}\n+\n+\n+impl thing {\n+    fn foo(@self) -> int { *self.x.a }\n+    fn bar(~self) -> int { *self.x.a }\n+    fn quux(&self) -> int { *self.x.a }\n+    fn baz(&self) -> &self/{mut a: @int} { &self.x }\n+    fn spam(self) -> int { *self.x.a }\n+}\n+\n+trait Nus { fn f(&self); }\n+impl thing: Nus { fn f(&self) {} }\n+\n+fn main() {\n+\n+    let x = @thing({mut a: @10});\n+    assert x.foo() == 10;\n+    assert x.quux() == 10;\n+\n+    let y = ~thing({mut a: @10});\n+    assert y.bar() == 10;\n+    assert y.quux() == 10;\n+\n+    let z = thing({mut a: @11});\n+    assert z.spam() == 11;\n+}"}]}