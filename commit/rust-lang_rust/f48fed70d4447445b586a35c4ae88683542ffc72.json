{"sha": "f48fed70d4447445b586a35c4ae88683542ffc72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OGZlZDcwZDQ0NDc0NDViNTg2YTM1YzRhZTg4NjgzNTQyZmZjNzI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-04-17T12:26:17Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-04-17T12:26:17Z"}, "message": "Rustup", "tree": {"sha": "e3b0bdd79b58dc01a8847b62d2df941e2486bbd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3b0bdd79b58dc01a8847b62d2df941e2486bbd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f48fed70d4447445b586a35c4ae88683542ffc72", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlrV5+kACgkQpp+NIls6\n19n7hRAAsDebdzqJxrg7iQrjKfZOExfm/6QQQ9CAb0cMids5ff8jD8aenqXZrQ9X\nf/7FHBa9RB/yCmlF4oDJzpaLpFZ3t0RB0/e/4MQOhORBQ/VbL9ZnFJwYUm+E32sE\n3Zbl9nd/EmwvLqm10YgTNqYcX7FAxod4GEfG/0yAciudDw0RIGSQG++5c53vWyex\nms+EecWHUct7zu/neVml2q/vS16kvyvm0cNR4L+HFKnUrzu4Hq8QohAvZpci4PTx\no7JCFQR+ZlSyLnghISvsNquQVsZwGExBpw11e021WikkSBsyEULr0RRC+m+VIrpL\nw7DjCPgKujkIHOwhzKqgGci20/d9010oUiuwMW6iBvLzEVrrGbBjNjV7jW/YYmUy\n8poGUmcY+GM6ZQK6nkM5zesvPs/s2pvTXFNfzbdbEwMt008/72i1VRMdPxEXzN2E\nkArano7r1nMBTEGVA0djvvzDVlgLLiBWUVs8JgHV7mQyFVtK4Ivht+GtDXYGy8Yn\nqNQs9PvUeafuJv3kkX+qtUyjxPMDMNK/ab3zVCEG0hUL/Zl4perUpAZPXvXgR3tQ\nutNsUjOPgBTNUahVOGuPI2/xqIcnRgqBxeDg9bRhTNljTJWNCvXtbPOr7lpEmyOB\nqp/K5Wu9QLEfU+0BO6n43mB/seO9/iSZtrVSUVO1ZGFdUUyWoX4=\n=AMqq\n-----END PGP SIGNATURE-----", "payload": "tree e3b0bdd79b58dc01a8847b62d2df941e2486bbd8\nparent 3f1b2bdd6895f9aedb22601bd28bc690d5a55a1e\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1523967977 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1523967977 +0200\n\nRustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f48fed70d4447445b586a35c4ae88683542ffc72", "html_url": "https://github.com/rust-lang/rust/commit/f48fed70d4447445b586a35c4ae88683542ffc72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f48fed70d4447445b586a35c4ae88683542ffc72/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f1b2bdd6895f9aedb22601bd28bc690d5a55a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f1b2bdd6895f9aedb22601bd28bc690d5a55a1e", "html_url": "https://github.com/rust-lang/rust/commit/3f1b2bdd6895f9aedb22601bd28bc690d5a55a1e"}], "stats": {"total": 53, "additions": 14, "deletions": 39}, "files": [{"sha": "6ba86c81e0401403bc5d0fcb1d18a41e7bf7b380", "filename": "miri/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f48fed70d4447445b586a35c4ae88683542ffc72/miri%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48fed70d4447445b586a35c4ae88683542ffc72/miri%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fmiri.rs?ref=f48fed70d4447445b586a35c4ae88683542ffc72", "patch": "@@ -130,7 +130,7 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n         state.hir_crate.unwrap().visit_all_item_likes(\n             &mut Visitor(tcx, state),\n         );\n-    } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n+    } else if let Some((entry_node_id, _, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n         let start_wrapper = tcx.lang_items().start_fn().and_then(|start_fn| {\n             if tcx.is_mir_available(start_fn) {"}, {"sha": "7c8183b50984f293c91d6fc292904a2022f10961", "filename": "miri/lib.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f48fed70d4447445b586a35c4ae88683542ffc72/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48fed70d4447445b586a35c4ae88683542ffc72/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=f48fed70d4447445b586a35c4ae88683542ffc72", "patch": "@@ -385,26 +385,11 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     fn global_item_with_linkage<'a>(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        mutability: Mutability,\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n-        // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n-        trace!(\"Initializing an extern global with NULL\");\n-        let ptr_size = ecx.memory.pointer_size();\n-        let ptr_align = ecx.tcx.data_layout.pointer_align;\n-        let ptr = ecx.memory.allocate(\n-            ptr_size,\n-            ptr_align,\n-            None,\n-        )?;\n-        ecx.memory.write_ptr_sized_unsigned(ptr, ptr_align, PrimVal::Bytes(0))?;\n-        ecx.memory.mark_static_initialized(ptr.alloc_id, mutability)?;\n-        ecx.tcx.interpret_interner.cache(\n-            instance.def_id(),\n-            ptr.alloc_id,\n-        );\n-        Ok(())\n+        panic!(\"remove this function from rustc\");\n     }\n \n     fn check_locks<'a>("}, {"sha": "2de620510ffef84c9ea4fd729e291da046156f89", "filename": "miri/validation.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f48fed70d4447445b586a35c4ae88683542ffc72/miri%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f48fed70d4447445b586a35c4ae88683542ffc72/miri%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fvalidation.rs?ref=f48fed70d4447445b586a35c4ae88683542ffc72", "patch": "@@ -638,7 +638,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n         }\n \n-        let res = do catch {\n+        let res: EvalResult<'tcx> = do catch {\n             match query.ty.sty {\n                 TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n                     if mode.acquiring() {\n@@ -648,7 +648,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                         // FIXME: It would be great to rule out Undef here, but that doesn't actually work.\n                         // Passing around undef data is a thing that e.g. Vec::extend_with does.\n                     }\n-                    Ok(())\n                 }\n                 TyBool | TyFloat(_) | TyChar => {\n                     if mode.acquiring() {\n@@ -657,9 +656,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                         val.to_bytes()?;\n                         // TODO: Check if these are valid bool/float/codepoint/UTF-8\n                     }\n-                    Ok(())\n                 }\n-                TyNever => err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n+                TyNever => return err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n                 TyRef(region,\n                     ty::TypeAndMut {\n                         ty: pointee_ty,\n@@ -680,29 +678,26 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                             _ => {}\n                         }\n                     }\n-                    self.validate_ptr(val, query.place.0, pointee_ty, query.re, query.mutbl, mode)\n+                    self.validate_ptr(val, query.place.0, pointee_ty, query.re, query.mutbl, mode)?;\n                 }\n                 TyAdt(adt, _) if adt.is_box() => {\n                     let val = self.read_place(query.place.1)?;\n-                    self.validate_ptr(val, query.place.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n+                    self.validate_ptr(val, query.place.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)?;\n                 }\n                 TyFnPtr(_sig) => {\n                     let ptr = self.read_place(query.place.1)?;\n                     let ptr = self.into_ptr(ptr)?.to_ptr()?;\n                     self.memory.get_fn(ptr)?;\n                     // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                    Ok(())\n                 }\n                 TyFnDef(..) => {\n                     // This is a zero-sized type with all relevant data sitting in the type.\n                     // There is nothing to validate.\n-                    Ok(())\n                 }\n \n                 // Compound types\n                 TyStr => {\n                     // TODO: Validate strings\n-                    Ok(())\n                 }\n                 TySlice(elem_ty) => {\n                     let len = match query.place.1 {\n@@ -725,7 +720,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                             mode,\n                         )?;\n                     }\n-                    Ok(())\n                 }\n                 TyArray(elem_ty, len) => {\n                     let len_val = match len.val {\n@@ -751,7 +745,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                             mode,\n                         )?;\n                     }\n-                    Ok(())\n                 }\n                 TyDynamic(_data, _region) => {\n                     // Check that this is a valid vtable\n@@ -770,7 +763,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n                     // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n                     // their return values.  So, it doesn't seem like there's anything else to do.\n-                    Ok(())\n                 }\n                 TyAdt(adt, _) => {\n                     if Some(adt.did) == self.tcx.tcx.lang_items().unsafe_cell_type() &&\n@@ -804,19 +796,17 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                                 self.validate_fields(\n                                     ValidationQuery { place, ..query },\n                                     mode,\n-                                )\n+                                )?;\n                             } else {\n                                 // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n-                                Ok(())\n                             }\n                         }\n                         AdtKind::Struct => {\n-                            self.validate_fields(query, mode)\n+                            self.validate_fields(query, mode)?;\n                         }\n                         AdtKind::Union => {\n                             // No guarantees are provided for union types.\n                             // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n-                            Ok(())\n                         }\n                     }\n                 }\n@@ -825,10 +815,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     // TODO: Check if the signature matches for `TyClosure`\n                     // (should be the same check as what terminator/mod.rs already does on call?).\n                     // Is there other things we can/should check?  Like vtable pointers?\n-                    self.validate_fields(query, mode)\n+                    self.validate_fields(query, mode)?;\n                 }\n                 // FIXME: generators aren't validated right now\n-                TyGenerator(..) => Ok(()),\n+                TyGenerator(..) => {},\n                 _ => bug!(\"We already established that this is a type we support. ({})\", query.ty),\n             }\n         };\n@@ -840,7 +830,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             // release if it is.  But of course that can't even always be statically determined.\n             Err(EvalError { kind: EvalErrorKind::ReadUndefBytes, .. })\n                 if mode == ValidationMode::ReleaseUntil(None) => {\n-                return Ok(());\n+                Ok(())\n             }\n             res => res,\n         }"}]}