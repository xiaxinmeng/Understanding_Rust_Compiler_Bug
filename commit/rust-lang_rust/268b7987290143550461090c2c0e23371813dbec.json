{"sha": "268b7987290143550461090c2c0e23371813dbec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2OGI3OTg3MjkwMTQzNTUwNDYxMDkwYzJjMGUyMzM3MTgxM2RiZWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-12T08:30:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-12T08:30:24Z"}, "message": "Merge #3938\n\n3938: fix missing match arm false positive r=flodiebold a=JoshMcguigan\n\nThis fixes #3932 by skipping the missing match arm diagnostic in the case any of the match arms don't type check properly against the match expression. \r\n\r\nI think this is the appropriate behavior for this diagnostic, since `is_useful` relies on all match arms being well formed, and the case of a malformed match arm should probably be handled by a different diagnostic.\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>", "tree": {"sha": "5dcdab30670131d405d34d0c20a8785bbf1ee181", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dcdab30670131d405d34d0c20a8785bbf1ee181"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/268b7987290143550461090c2c0e23371813dbec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJektGgCRBK7hj4Ov3rIwAAdHIIAAZoj+x5J6OFKDnIXfxgqwM0\nPMjGWUP+FG5uoGZjfml97tX/AB88SLUrx2Pat2W4KODB45jaJoVVRr70N8GHA8tO\nfWtR0RBBoX3IwWehwqt4zgwVRlKkT4L8FLitIIBUxMpdI4SFPL4LMcengYedhxRn\nRuEVeACX1c7C9eX0Z2Z4AJuNJlQnUsWly0aIhXhZ1Fs06tbvaRnkhXxyOvvE0NCy\n19pOgJnjiZCG3kmUeVPzWvDi9joTF4HXnO6nAlOMDuj+ET07f6D+DjHBOjKDUEVN\nYp/0tS3xuGRyFML3FHwYlVBfzlM3AYCAgBOwHa/iwumMhp9KlnYda0EXtczXLSM=\n=c6og\n-----END PGP SIGNATURE-----\n", "payload": "tree 5dcdab30670131d405d34d0c20a8785bbf1ee181\nparent a8e032820f14cad3630299a1ae16c62dcf59f358\nparent bb2e5308b77e5d115df17411aaa2dd26be171b0a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586680224 +0000\ncommitter GitHub <noreply@github.com> 1586680224 +0000\n\nMerge #3938\n\n3938: fix missing match arm false positive r=flodiebold a=JoshMcguigan\n\nThis fixes #3932 by skipping the missing match arm diagnostic in the case any of the match arms don't type check properly against the match expression. \r\n\r\nI think this is the appropriate behavior for this diagnostic, since `is_useful` relies on all match arms being well formed, and the case of a malformed match arm should probably be handled by a different diagnostic.\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/268b7987290143550461090c2c0e23371813dbec", "html_url": "https://github.com/rust-lang/rust/commit/268b7987290143550461090c2c0e23371813dbec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/268b7987290143550461090c2c0e23371813dbec/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8e032820f14cad3630299a1ae16c62dcf59f358", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e032820f14cad3630299a1ae16c62dcf59f358", "html_url": "https://github.com/rust-lang/rust/commit/a8e032820f14cad3630299a1ae16c62dcf59f358"}, {"sha": "bb2e5308b77e5d115df17411aaa2dd26be171b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb2e5308b77e5d115df17411aaa2dd26be171b0a", "html_url": "https://github.com/rust-lang/rust/commit/bb2e5308b77e5d115df17411aaa2dd26be171b0a"}], "stats": {"total": 265, "additions": 253, "deletions": 12}, "files": [{"sha": "c482cf6190ad130e03a97648a4c942e9cb27a9f6", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 246, "deletions": 6, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/268b7987290143550461090c2c0e23371813dbec/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268b7987290143550461090c2c0e23371813dbec/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=268b7987290143550461090c2c0e23371813dbec", "patch": "@@ -972,6 +972,47 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_end_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (false, ..) => {},\n+                    (true, ..) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_beginning_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (.., false) => {},\n+                    (.., true) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (..) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn tuple_of_tuple_and_bools_no_arms() {\n         let content = r\"\n@@ -1315,8 +1356,9 @@ mod tests {\n             }\n         \";\n \n-        // Match arms with the incorrect type are filtered out.\n-        check_diagnostic(content);\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(content);\n     }\n \n     #[test]\n@@ -1330,8 +1372,9 @@ mod tests {\n             }\n         \";\n \n-        // Match arms with the incorrect type are filtered out.\n-        check_diagnostic(content);\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(content);\n     }\n \n     #[test]\n@@ -1344,8 +1387,9 @@ mod tests {\n             }\n         \";\n \n-        // Match arms with the incorrect type are filtered out.\n-        check_diagnostic(content);\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(content);\n     }\n \n     #[test]\n@@ -1383,6 +1427,102 @@ mod tests {\n         // we don't create a diagnostic).\n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn expr_diverges() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop {} {\n+                    Either::A => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn expr_loop_with_break() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop { break Foo::A } {\n+                    Either::A => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn expr_partially_diverges() {\n+        let content = r\"\n+            enum Either<T> {\n+                A(T),\n+                B,\n+            }\n+            fn foo() -> Either<!> {\n+                Either::B\n+            }\n+            fn test_fn() -> u32 {\n+                match foo() {\n+                    Either::A(val) => val,\n+                    Either::B => 0,\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(false, .., true) => {},\n+                    Either::A(false, .., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_ellipsis_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(..) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n }\n \n #[cfg(test)]\n@@ -1452,4 +1592,104 @@ mod false_negatives {\n         // We do not currently handle patterns with internal `or`s.\n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn expr_diverges_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop {} {\n+                    Either::A => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // Even though the match expression diverges, rustc fails\n+        // to compile here since `Either::B` is missing.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn expr_loop_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop { break Foo::A } {\n+                    Either::A => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We currently infer the type of `loop { break Foo::A }` to `!`, which\n+        // causes us to skip the diagnostic since `Either::A` doesn't type check\n+        // with `!`.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (false, ..) => {},\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // The `..` pattern is currently lowered to a single `Pat::Wild`\n+        // no matter how many fields the `..` pattern is covering. This\n+        // causes the match arm in this test not to type check against\n+        // the match expression, which causes this diagnostic not to\n+        // fire.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (.., false) => {},\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // See comments on `tuple_of_bools_with_ellipsis_at_end_missing_arm`.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(false, .., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // The `..` pattern is currently lowered to a single `Pat::Wild`\n+        // no matter how many fields the `..` pattern is covering. This\n+        // causes us to return a `MatchCheckErr::MalformedMatchArm` in\n+        // `Pat::specialize_constructor`.\n+        check_no_diagnostic(content);\n+    }\n }"}, {"sha": "21abbcf1e2d157f7344219ae514e112d0d8284ab", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/268b7987290143550461090c2c0e23371813dbec/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268b7987290143550461090c2c0e23371813dbec/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=268b7987290143550461090c2c0e23371813dbec", "patch": "@@ -161,12 +161,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let mut seen = Matrix::empty();\n         for pat in pats {\n-            // We skip any patterns whose type we cannot resolve.\n-            //\n-            // This could lead to false positives in this diagnostic, so\n-            // it might be better to skip the entire diagnostic if we either\n-            // cannot resolve a match arm or determine that the match arm has\n-            // the wrong type.\n             if let Some(pat_ty) = infer.type_of_pat.get(pat) {\n                 // We only include patterns whose type matches the type\n                 // of the match expression. If we had a InvalidMatchArmPattern\n@@ -189,8 +183,15 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                     // to the matrix here.\n                     let v = PatStack::from_pattern(pat);\n                     seen.push(&cx, v);\n+                    continue;\n                 }\n             }\n+\n+            // If we can't resolve the type of a pattern, or the pattern type doesn't\n+            // fit the match expression, we skip this diagnostic. Skipping the entire\n+            // diagnostic rather than just not including this match arm is preferred\n+            // to avoid the chance of false positives.\n+            return;\n         }\n \n         match is_useful(&cx, &seen, &PatStack::from_wild()) {"}]}