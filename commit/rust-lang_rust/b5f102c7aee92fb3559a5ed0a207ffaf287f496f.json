{"sha": "b5f102c7aee92fb3559a5ed0a207ffaf287f496f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZjEwMmM3YWVlOTJmYjM1NTlhNWVkMGEyMDdmZmFmMjg3ZjQ5NmY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-14T08:29:45Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-14T16:15:46Z"}, "message": "Rollup merge of #48840 - varkor:idxset-cleanup, r=pnkfelix\n\nRemove some unnecessary IdxSet methods\n\nThis replaces `IdxSet:: reset_to_empty` with `IdxSet:: clear`, and `IdxSet::elems`/`IdxSet::each_bit` with `IdxSet::iter`. Based on some [comments on #rustc](https://botbot.me/mozilla/rustc/2018-01-23/?msg=96063396).\n\nr? @pnkfelix", "tree": {"sha": "996cf64585aaf6f418d82fd92a96035ba3b591dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/996cf64585aaf6f418d82fd92a96035ba3b591dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5f102c7aee92fb3559a5ed0a207ffaf287f496f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlqpSrIACgkQ/vbIBR0O\nATzGaxAAvKrxDabbPJnk9F5blJOCqpU6W2X50MbbYj/CmEbRkY/dwyJHD4ZQexGh\nDCq5f6Rq9QR2Bz3e07Wj7N1/5C62mTQYFKcDv2DSSWMdXdj+ZCXXpg13EfWemIih\n8YScebN30UE2Ga/1DPj4Vsbpwlx3V1ytw76/8YARUvJWlyGpEX88zOJqMm4u3lNj\n38JPQfg+80wvfi7/FrYRI1NqclYfdRe7jRSG48vp7dOrCyD53KHM5d9i9kgYtA3O\ncpISNmmcQrZwGZvn9A101YivRnKSzAB64+KJqAKvuG6SFV0rVGLOx5pLQVbbj7dg\n3SxvoE992qrE5/iW34gR8NfMShE9P++IjCrsjqOUH65HJjFr9h+d2ntsN5301rKc\np6ysKgzdZqKC7B6GRpuJo7L+CkH4JLFrF+aIoVJDOnReHYmOzHuYNjTfDwH/qLTB\nxz97jOcWAPDjALiq9WqoUux9JNwHDgWcjxje+khJUTL8NufJwGAp59TYfa2aXMMB\nXifsJaUwIaBQjSYOiQh5JEpej40FOnl+XtVt5lBiyRcx7dNRSNNl/9Y3JHSXrkiy\nk7dTuzGTSp3U4dAPEErdyxWFbEVIQ2QeOfwDhCBkhM+cfIpBA0K6bmm0/ZCGCGfr\ncHpykkxGly4DdG01THGE592gtpdEC48pr2Td6KJqIwexv/6RvCE=\n=JQ8e\n-----END PGP SIGNATURE-----", "payload": "tree 996cf64585aaf6f418d82fd92a96035ba3b591dd\nparent c65ee94365b3a3545b9eb77d4f528c56f19a23bd\nparent f69a0999e742a6fc45fd4b962c30c56d04c2245c\nauthor kennytm <kennytm@gmail.com> 1521016185 +0800\ncommitter kennytm <kennytm@gmail.com> 1521044146 +0800\n\nRollup merge of #48840 - varkor:idxset-cleanup, r=pnkfelix\n\nRemove some unnecessary IdxSet methods\n\nThis replaces `IdxSet:: reset_to_empty` with `IdxSet:: clear`, and `IdxSet::elems`/`IdxSet::each_bit` with `IdxSet::iter`. Based on some [comments on #rustc](https://botbot.me/mozilla/rustc/2018-01-23/?msg=96063396).\n\nr? @pnkfelix\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f102c7aee92fb3559a5ed0a207ffaf287f496f", "html_url": "https://github.com/rust-lang/rust/commit/b5f102c7aee92fb3559a5ed0a207ffaf287f496f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c65ee94365b3a3545b9eb77d4f528c56f19a23bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c65ee94365b3a3545b9eb77d4f528c56f19a23bd", "html_url": "https://github.com/rust-lang/rust/commit/c65ee94365b3a3545b9eb77d4f528c56f19a23bd"}, {"sha": "f69a0999e742a6fc45fd4b962c30c56d04c2245c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f69a0999e742a6fc45fd4b962c30c56d04c2245c", "html_url": "https://github.com/rust-lang/rust/commit/f69a0999e742a6fc45fd4b962c30c56d04c2245c"}], "stats": {"total": 105, "additions": 18, "deletions": 87}, "files": [{"sha": "7ab6a2691488ed148aa388b2478470ef7a1d89ff", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=b5f102c7aee92fb3559a5ed0a207ffaf287f496f", "patch": "@@ -224,70 +224,6 @@ impl<T: Idx> IdxSet<T> {\n             _pd: PhantomData,\n         }\n     }\n-\n-    /// Calls `f` on each index value held in this set, up to the\n-    /// bound `max_bits` on the size of universe of indexes.\n-    pub fn each_bit<F>(&self, max_bits: usize, f: F) where F: FnMut(T) {\n-        each_bit(self, max_bits, f)\n-    }\n-\n-    /// Removes all elements from this set.\n-    pub fn reset_to_empty(&mut self) {\n-        for word in self.words_mut() { *word = 0; }\n-    }\n-\n-    pub fn elems(&self, universe_size: usize) -> Elems<T> {\n-        Elems { i: 0, set: self, universe_size: universe_size }\n-    }\n-}\n-\n-pub struct Elems<'a, T: Idx> { i: usize, set: &'a IdxSet<T>, universe_size: usize }\n-\n-impl<'a, T: Idx> Iterator for Elems<'a, T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> {\n-        if self.i >= self.universe_size { return None; }\n-        let mut i = self.i;\n-        loop {\n-            if i >= self.universe_size {\n-                self.i = i; // (mark iteration as complete.)\n-                return None;\n-            }\n-            if self.set.contains(&T::new(i)) {\n-                self.i = i + 1; // (next element to start at.)\n-                return Some(T::new(i));\n-            }\n-            i = i + 1;\n-        }\n-    }\n-}\n-\n-fn each_bit<T: Idx, F>(words: &IdxSet<T>, max_bits: usize, mut f: F) where F: FnMut(T) {\n-    let usize_bits: usize = mem::size_of::<usize>() * 8;\n-\n-    for (word_index, &word) in words.words().iter().enumerate() {\n-        if word != 0 {\n-            let base_index = word_index * usize_bits;\n-            for offset in 0..usize_bits {\n-                let bit = 1 << offset;\n-                if (word & bit) != 0 {\n-                    // NB: we round up the total number of bits\n-                    // that we store in any given bit set so that\n-                    // it is an even multiple of usize::BITS. This\n-                    // means that there may be some stray bits at\n-                    // the end that do not correspond to any\n-                    // actual value; that's why we first check\n-                    // that we are in range of bits_per_block.\n-                    let bit_index = base_index + offset as usize;\n-                    if bit_index >= max_bits {\n-                        return;\n-                    } else {\n-                        f(Idx::new(bit_index));\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n pub struct Iter<'a, T: Idx> {"}, {"sha": "6e1a798910dc6d6e16dd5f14cddea6454334cd8d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b5f102c7aee92fb3559a5ed0a207ffaf287f496f", "patch": "@@ -530,7 +530,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     // Look for any active borrows to locals\n                     let domain = flow_state.borrows.operator();\n                     let data = domain.borrows();\n-                    flow_state.borrows.with_elems_outgoing(|borrows| {\n+                    flow_state.borrows.with_iter_outgoing(|borrows| {\n                         for i in borrows {\n                             let borrow = &data[i.borrow_index()];\n                             self.check_for_local_borrow(borrow, span);\n@@ -546,7 +546,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // so this \"extra check\" serves as a kind of backup.\n                 let domain = flow_state.borrows.operator();\n                 let data = domain.borrows();\n-                flow_state.borrows.with_elems_outgoing(|borrows| {\n+                flow_state.borrows.with_iter_outgoing(|borrows| {\n                     for i in borrows {\n                         let borrow = &data[i.borrow_index()];\n                         let context = ContextKind::StorageDead.new(loc);\n@@ -1292,7 +1292,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             place\n         );\n \n-        for i in flow_state.ever_inits.elems_incoming() {\n+        for i in flow_state.ever_inits.iter_incoming() {\n             let init = self.move_data.inits[i];\n             let init_place = &self.move_data.move_paths[init.path].place;\n             if self.places_conflict(&init_place, place, Deep) {\n@@ -2129,8 +2129,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        let mut elems_incoming = flow_state.borrows.elems_incoming();\n-        while let Some(i) = elems_incoming.next() {\n+        let mut iter_incoming = flow_state.borrows.iter_incoming();\n+        while let Some(i) = iter_incoming.next() {\n             let borrowed = &data[i.borrow_index()];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {"}, {"sha": "0fbb54e8e0a089abb88178c82b1b9b3cf4b58343", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=b5f102c7aee92fb3559a5ed0a207ffaf287f496f", "patch": "@@ -12,7 +12,7 @@\n //! locations.\n \n use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_set::{IdxSetBuf, Iter};\n use rustc_data_structures::indexed_vec::Idx;\n \n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n@@ -81,8 +81,7 @@ where\n     where\n         F: FnMut(BD::Idx),\n     {\n-        self.curr_state\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n+        self.curr_state.iter().for_each(f)\n     }\n \n     /// Iterate over each `gen` bit in the current effect (invoke\n@@ -92,8 +91,7 @@ where\n     where\n         F: FnMut(BD::Idx),\n     {\n-        self.stmt_gen\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n+        self.stmt_gen.iter().for_each(f)\n     }\n \n     pub fn new(results: DataflowResults<BD>) -> Self {\n@@ -119,23 +117,21 @@ where\n     }\n \n     /// Returns an iterator over the elements present in the current state.\n-    pub fn elems_incoming(&self) -> iter::Peekable<indexed_set::Elems<BD::Idx>> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.curr_state.elems(univ).peekable()\n+    pub fn iter_incoming(&self) -> iter::Peekable<Iter<BD::Idx>> {\n+        self.curr_state.iter().peekable()\n     }\n \n     /// Creates a clone of the current state and applies the local\n     /// effects to the clone (leaving the state of self intact).\n     /// Invokes `f` with an iterator over the resulting state.\n-    pub fn with_elems_outgoing<F>(&self, f: F)\n+    pub fn with_iter_outgoing<F>(&self, f: F)\n     where\n-        F: FnOnce(indexed_set::Elems<BD::Idx>),\n+        F: FnOnce(Iter<BD::Idx>),\n     {\n         let mut curr_state = self.curr_state.clone();\n         curr_state.union(&self.stmt_gen);\n         curr_state.subtract(&self.stmt_kill);\n-        let univ = self.base_results.sets().bits_per_block();\n-        f(curr_state.elems(univ));\n+        f(curr_state.iter());\n     }\n }\n \n@@ -147,8 +143,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     }\n \n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n+        self.stmt_gen.clear();\n+        self.stmt_kill.clear();\n         {\n             let mut sets = BlockSets {\n                 on_entry: &mut self.curr_state,\n@@ -172,8 +168,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     }\n \n     fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n+        self.stmt_gen.clear();\n+        self.stmt_kill.clear();\n         {\n             let mut sets = BlockSets {\n                 on_entry: &mut self.curr_state,"}, {"sha": "74e41ef9c93ee31183973870459c0c3a035e252b", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f102c7aee92fb3559a5ed0a207ffaf287f496f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=b5f102c7aee92fb3559a5ed0a207ffaf287f496f", "patch": "@@ -444,8 +444,7 @@ pub struct DataflowState<O: BitDenotation>\n impl<O: BitDenotation> DataflowState<O> {\n     pub fn each_bit<F>(&self, words: &IdxSet<O::Idx>, f: F) where F: FnMut(O::Idx)\n     {\n-        let bits_per_block = self.operator.bits_per_block();\n-        words.each_bit(bits_per_block, f)\n+        words.iter().for_each(f)\n     }\n \n     pub(crate) fn interpret_set<'c, P>(&self,"}]}