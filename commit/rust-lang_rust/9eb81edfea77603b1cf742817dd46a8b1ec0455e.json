{"sha": "9eb81edfea77603b1cf742817dd46a8b1ec0455e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjgxZWRmZWE3NzYwM2IxY2Y3NDI4MTdkZDQ2YThiMWVjMDQ1NWU=", "commit": {"author": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-06-30T17:53:52Z"}, "committer": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T19:36:02Z"}, "message": "collections::bitv: Implement several methods for `Bitv` and `BitvSet`\n\nOn Bitv:\n   - Add .push() and .pop() which take and return bool, respectively\n   - Add .truncate() which truncates a Bitv to a specific length\n   - Add .grow() which grows a Bitv by a specific length\n   - Add .reserve() which grows the underlying storage to be able to hold\n     a specified number of bits without resizing\n   - Implement FromIterator<Vec<bool>>\n   - Implement Extendable<bool>\n   - Implement Collection\n   - Implement Mutable\n   - Remove .from_bools() since FromIterator<Vec<bool>> now accomplishes this.\n   - Remove .assign() since Clone::clone_from() accomplishes this.\n\nOn BitvSet:\n   - Add .reserve() which grows the underlying storage to be able to hold\n     a specified number of bits without resizing\n   - Add .get_ref() and .get_mut_ref() to return references to the\n     underlying Bitv", "tree": {"sha": "28055e61bc481cf0a84dfcbb6a975ea366cb080c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28055e61bc481cf0a84dfcbb6a975ea366cb080c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb81edfea77603b1cf742817dd46a8b1ec0455e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb81edfea77603b1cf742817dd46a8b1ec0455e", "html_url": "https://github.com/rust-lang/rust/commit/9eb81edfea77603b1cf742817dd46a8b1ec0455e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb81edfea77603b1cf742817dd46a8b1ec0455e/comments", "author": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5c54df59fa0a99fa860db82e6e82f9c0fbd7115", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c54df59fa0a99fa860db82e6e82f9c0fbd7115", "html_url": "https://github.com/rust-lang/rust/commit/b5c54df59fa0a99fa860db82e6e82f9c0fbd7115"}], "stats": {"total": 336, "additions": 295, "deletions": 41}, "files": [{"sha": "e041906839cd37c6992bb1dd6071aac8cc361e55", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 295, "deletions": 41, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/9eb81edfea77603b1cf742817dd46a8b1ec0455e/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb81edfea77603b1cf742817dd46a8b1ec0455e/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=9eb81edfea77603b1cf742817dd46a8b1ec0455e", "patch": "@@ -51,7 +51,6 @@ use vec::Vec;\n /// println!(\"{}\", bv.to_str());\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[deriving(Clone)]\n pub struct Bitv {\n     /// Internal representation of the bit vector\n     storage: Vec<uint>,\n@@ -159,17 +158,6 @@ impl Bitv {\n         self.process(other, |w1, w2| w1 & w2)\n     }\n \n-    /**\n-     * Assigns the value of `v1` to `self`\n-     *\n-     * Both bitvectors must be the same length. Returns `true` if `self` was\n-     * changed\n-     */\n-    #[inline]\n-    pub fn assign(&mut self, other: &Bitv) -> bool {\n-        self.process(other, |_, w| w)\n-    }\n-\n     /// Retrieve the value at index `i`\n     #[inline]\n     pub fn get(&self, i: uint) -> bool {\n@@ -195,12 +183,6 @@ impl Bitv {\n                           else { *self.storage.get(w) & !flag };\n     }\n \n-    /// Set all bits to 0\n-    #[inline]\n-    pub fn clear(&mut self) {\n-        for w in self.storage.mut_iter() { *w = 0u; }\n-    }\n-\n     /// Set all bits to 1\n     #[inline]\n     pub fn set_all(&mut self) {\n@@ -313,6 +295,132 @@ impl Bitv {\n         }\n         true\n     }\n+\n+    /// Shorten a Bitv, dropping excess elements.\n+    ///\n+    /// If `len` is greater than the vector's current length, this has no\n+    /// effect.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::bitv::Bitv;\n+    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n+    /// let expected: Bitv = vec![false, true].iter().map(|n| *n).collect();\n+    /// bvec.truncate(2);\n+    /// assert_eq!(bvec, expected);\n+    /// ```\n+    pub fn truncate(&mut self, len: uint) {\n+        if len < self.len() {\n+            self.nbits = len;\n+            let word_len = (len + uint::BITS - 1) / uint::BITS;\n+            self.storage.truncate(word_len);\n+            if len % uint::BITS > 0 {\n+                let mask = (1 << len % uint::BITS) - 1;\n+                *self.storage.get_mut(word_len - 1) &= mask;\n+            }\n+        }\n+    }\n+\n+    /// Grows the vector to be able to store `size` bits without resizing\n+    pub fn reserve(&mut self, size: uint) {\n+        let old_size = self.storage.len();\n+        let size = (size + uint::BITS - 1) / uint::BITS;\n+        if old_size < size {\n+            self.storage.grow(size - old_size, &0);\n+        }\n+    }\n+\n+    /// Returns the capacity in bits for this bit vector. Inserting any\n+    /// element less than this amount will not trigger a resizing.\n+    #[inline]\n+    pub fn capacity(&self) -> uint {\n+        self.storage.len() * uint::BITS\n+    }\n+\n+    /// Grows the `Bitv` in-place.\n+    ///\n+    /// Adds `n` copies of `value` to the `Bitv`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::bitv::Bitv;\n+    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n+    /// bvec.grow(2, true);\n+    /// assert_eq!(bvec, vec![false, true, true, false, true, true].iter().map(|n| *n).collect());\n+    /// ```\n+    pub fn grow(&mut self, n: uint, value: bool) {\n+        let new_nbits = self.nbits + n;\n+        let new_nwords = (new_nbits + uint::BITS - 1) / uint::BITS;\n+        let full_value = if value { !0 } else { 0 };\n+        // Correct the old tail word\n+        let old_last_word = (self.nbits + uint::BITS - 1) / uint::BITS - 1;\n+        if self.nbits % uint::BITS > 0 {\n+            let overhang = self.nbits % uint::BITS; // # of already-used bits\n+            let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110....0\n+            if value {\n+                *self.storage.get_mut(old_last_word) |= mask;\n+            } else {\n+                *self.storage.get_mut(old_last_word) &= !mask;\n+            }\n+        }\n+        // Fill in words after the old tail word\n+        let stop_idx = cmp::min(self.storage.len(), new_nwords);\n+        for idx in range(old_last_word + 1, stop_idx) {\n+            *self.storage.get_mut(idx) = full_value;\n+        }\n+        // Allocate new words, if needed\n+        if new_nwords > self.storage.len() {\n+          let to_add = new_nwords - self.storage.len();\n+          self.storage.grow(to_add, &full_value);\n+        }\n+        // Adjust internal bit count\n+        self.nbits = new_nbits;\n+    }\n+\n+    /// Shorten a `Bitv` by one, returning the removed element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::bitv::Bitv;\n+    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n+    /// let expected: Bitv = vec![false, true, true].iter().map(|n| *n).collect();\n+    /// let popped = bvec.pop();\n+    /// assert_eq!(popped, false);\n+    /// assert_eq!(bvec, expected);\n+    /// ```\n+    pub fn pop(&mut self) -> bool {\n+        let ret = self.get(self.nbits - 1);\n+        // If we are unusing a whole word, make sure it is zeroed out\n+        if self.nbits % uint::BITS == 1 {\n+            *self.storage.get_mut(self.nbits / uint::BITS) = 0;\n+        }\n+        self.nbits -= 1;\n+        ret\n+    }\n+\n+    /// Pushes a `bool` onto the `Bitv`\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::bitv::Bitv;\n+    /// let prototype: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n+    /// let mut bvec: Bitv = vec![false, true].iter().map(|n| *n).collect();\n+    /// bvec.push(true);\n+    /// bvec.push(false);\n+    /// assert_eq!(prototype, bvec);\n+    /// ```\n+    pub fn push(&mut self, elem: bool) {\n+        let insert_pos = self.nbits;\n+        self.nbits += 1;\n+        if self.storage.len() * uint::BITS < self.nbits {\n+            self.storage.push(0);\n+        }\n+        self.set(insert_pos, elem);\n+    }\n }\n \n /**\n@@ -328,13 +436,6 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     })\n }\n \n-/**\n- * Transform a `[bool]` into a `Bitv` by converting each `bool` into a bit.\n- */\n-pub fn from_bools(bools: &[bool]) -> Bitv {\n-    from_fn(bools.len(), |i| bools[i])\n-}\n-\n /**\n  * Create a `Bitv` of the specified length where the value at each\n  * index is `f(index)`.\n@@ -347,6 +448,57 @@ pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n     bitv\n }\n \n+impl Default for Bitv {\n+    #[inline]\n+    fn default() -> Bitv { Bitv::new(0, false) }\n+}\n+\n+impl Collection for Bitv {\n+    #[inline]\n+    fn len(&self) -> uint { self.nbits }\n+}\n+\n+impl Mutable for Bitv {\n+    #[inline]\n+    fn clear(&mut self) {\n+        for w in self.storage.mut_iter() { *w = 0u; }\n+    }\n+}\n+\n+impl FromIterator<bool> for Bitv {\n+    fn from_iter<I:Iterator<bool>>(iterator: I) -> Bitv {\n+        let mut ret = Bitv::new(0, false);\n+        ret.extend(iterator);\n+        ret\n+    }\n+}\n+\n+impl Extendable<bool> for Bitv {\n+    #[inline]\n+    fn extend<I: Iterator<bool>>(&mut self, mut iterator: I) {\n+        let (min, _) = iterator.size_hint();\n+        let nbits = self.nbits;\n+        self.reserve(nbits + min);\n+        for element in iterator {\n+            self.push(element)\n+        }\n+    }\n+}\n+\n+impl Clone for Bitv {\n+    #[inline]\n+    fn clone(&self) -> Bitv {\n+        Bitv { storage: self.storage.clone(), nbits: self.nbits }\n+    }\n+\n+    #[inline]\n+    fn clone_from(&mut self, source: &Bitv) {\n+        self.nbits = source.nbits;\n+        self.storage.reserve(source.storage.len());\n+        for (i, w) in self.storage.mut_iter().enumerate() { *w = *source.storage.get(i); }\n+    }\n+}\n+\n impl ops::Index<uint,bool> for Bitv {\n     #[inline]\n     fn index(&self, i: &uint) -> bool {\n@@ -471,7 +623,13 @@ impl BitvSet {\n     #[inline]\n     pub fn capacity(&self) -> uint {\n         let &BitvSet(ref bitv) = self;\n-        bitv.storage.len() * uint::BITS\n+        bitv.capacity()\n+    }\n+\n+    /// Grows the underlying vector to be able to store `size` bits\n+    pub fn reserve(&mut self, size: uint) {\n+        let &BitvSet(ref mut bitv) = self;\n+        bitv.reserve(size)\n     }\n \n     /// Consumes this set to return the underlying bit vector\n@@ -481,24 +639,28 @@ impl BitvSet {\n         bitv\n     }\n \n+    /// Returns a reference to the underlying bit vector\n+    #[inline]\n+    pub fn get_ref<'a>(&'a self) -> &'a Bitv {\n+        let &BitvSet(ref bitv) = self;\n+        bitv\n+    }\n+\n+    /// Returns a mutable reference to the underlying bit vector\n     #[inline]\n-    /// Grows the vector to be able to store bits with indices `[0, size - 1]`\n-    fn grow(&mut self, size: uint) {\n+    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut Bitv {\n         let &BitvSet(ref mut bitv) = self;\n-        let old_size = bitv.storage.len();\n-        let size = (size + uint::BITS - 1) / uint::BITS;\n-        if old_size < size {\n-            bitv.storage.grow(size - old_size, &0);\n-        }\n+        bitv\n     }\n \n     #[inline]\n     fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n-        // Expand the vector if necessary\n-        self.grow(other.capacity());\n         // Unwrap Bitvs\n         let &BitvSet(ref mut self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n+        // Expand the vector if necessary\n+        self_bitv.reserve(other_bitv.capacity());\n+        // Apply values\n         for (i, w) in other_bitv.mask_words(0) {\n             let old = *self_bitv.storage.get(i);\n             let new = f(old, w);\n@@ -683,7 +845,7 @@ impl MutableSet<uint> for BitvSet {\n         }\n         if value >= self.capacity() {\n             let new_cap = cmp::max(value + 1, self.capacity() * 2);\n-            self.grow(new_cap);\n+            self.reserve(new_cap);\n         }\n         let &BitvSet(ref mut bitv) = self;\n         if value >= bitv.nbits {\n@@ -824,7 +986,7 @@ mod tests {\n     use test::Bencher;\n \n     use {Set, Mutable, MutableSet};\n-    use bitv::{Bitv, BitvSet, from_bools, from_fn, from_bytes};\n+    use bitv::{Bitv, BitvSet, from_fn, from_bytes};\n     use bitv;\n     use vec::Vec;\n \n@@ -1187,8 +1349,9 @@ mod tests {\n \n     #[test]\n     fn test_from_bools() {\n-        assert!(from_bools([true, false, true, true]).to_str().as_slice() ==\n-                \"1011\");\n+        let bools = vec![true, false, true, true];\n+        let bitv: Bitv = bools.iter().map(|n| *n).collect();\n+        assert_eq!(bitv.to_str().as_slice(), \"1011\");\n     }\n \n     #[test]\n@@ -1200,7 +1363,7 @@ mod tests {\n     #[test]\n     fn test_bitv_iterator() {\n         let bools = [true, false, true, true];\n-        let bitv = from_bools(bools);\n+        let bitv: Bitv = bools.iter().map(|n| *n).collect();\n \n         for (act, &ex) in bitv.iter().zip(bools.iter()) {\n             assert_eq!(ex, act);\n@@ -1210,7 +1373,7 @@ mod tests {\n     #[test]\n     fn test_bitv_set_iterator() {\n         let bools = [true, false, true, true];\n-        let bitv = BitvSet::from_bitv(from_bools(bools));\n+        let bitv = BitvSet::from_bitv(bools.iter().map(|n| *n).collect());\n \n         let idxs: Vec<uint> = bitv.iter().collect();\n         assert_eq!(idxs, vec!(0, 2, 3));\n@@ -1499,6 +1662,97 @@ mod tests {\n         assert!(!v.none());\n     }\n \n+    #[test]\n+    fn test_bitv_push_pop() {\n+        let mut s = Bitv::new(5 * uint::BITS - 2, false);\n+        assert_eq!(s.len(), 5 * uint::BITS - 2);\n+        assert_eq!(s.get(5 * uint::BITS - 3), false);\n+        s.push(true);\n+        s.push(true);\n+        assert_eq!(s.get(5 * uint::BITS - 2), true);\n+        assert_eq!(s.get(5 * uint::BITS - 1), true);\n+        // Here the internal vector will need to be extended\n+        s.push(false);\n+        assert_eq!(s.get(5 * uint::BITS), false);\n+        s.push(false);\n+        assert_eq!(s.get(5 * uint::BITS + 1), false);\n+        assert_eq!(s.len(), 5 * uint::BITS + 2);\n+        // Pop it all off\n+        assert_eq!(s.pop(), false);\n+        assert_eq!(s.pop(), false);\n+        assert_eq!(s.pop(), true);\n+        assert_eq!(s.pop(), true);\n+        assert_eq!(s.len(), 5 * uint::BITS - 2);\n+    }\n+\n+    #[test]\n+    fn test_bitv_truncate() {\n+        let mut s = Bitv::new(5 * uint::BITS, true);\n+\n+        assert_eq!(s, Bitv::new(5 * uint::BITS, true));\n+        assert_eq!(s.len(), 5 * uint::BITS);\n+        s.truncate(4 * uint::BITS);\n+        assert_eq!(s, Bitv::new(4 * uint::BITS, true));\n+        assert_eq!(s.len(), 4 * uint::BITS);\n+        // Truncating to a size > s.len() should be a noop\n+        s.truncate(5 * uint::BITS);\n+        assert_eq!(s, Bitv::new(4 * uint::BITS, true));\n+        assert_eq!(s.len(), 4 * uint::BITS);\n+        s.truncate(3 * uint::BITS - 10);\n+        assert_eq!(s, Bitv::new(3 * uint::BITS - 10, true));\n+        assert_eq!(s.len(), 3 * uint::BITS - 10);\n+        s.truncate(0);\n+        assert_eq!(s, Bitv::new(0, true));\n+        assert_eq!(s.len(), 0);\n+    }\n+\n+    #[test]\n+    fn test_bitv_reserve() {\n+        let mut s = Bitv::new(5 * uint::BITS, true);\n+        // Check capacity\n+        assert_eq!(s.capacity(), 5 * uint::BITS);\n+        s.reserve(2 * uint::BITS);\n+        assert_eq!(s.capacity(), 5 * uint::BITS);\n+        s.reserve(7 * uint::BITS);\n+        assert_eq!(s.capacity(), 7 * uint::BITS);\n+        s.reserve(7 * uint::BITS);\n+        assert_eq!(s.capacity(), 7 * uint::BITS);\n+        s.reserve(7 * uint::BITS + 1);\n+        assert_eq!(s.capacity(), 8 * uint::BITS);\n+        // Check that length hasn't changed\n+        assert_eq!(s.len(), 5 * uint::BITS);\n+        s.push(true);\n+        s.push(false);\n+        s.push(true);\n+        assert_eq!(s.get(5 * uint::BITS - 1), true);\n+        assert_eq!(s.get(5 * uint::BITS - 0), true);\n+        assert_eq!(s.get(5 * uint::BITS + 1), false);\n+        assert_eq!(s.get(5 * uint::BITS + 2), true);\n+    }\n+\n+    #[test]\n+    fn test_bitv_grow() {\n+        let mut bitv = from_bytes([0b10110110, 0b00000000, 0b10101010]);\n+        bitv.grow(32, true);\n+        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF]));\n+        bitv.grow(64, false);\n+        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n+        bitv.grow(16, true);\n+        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n+    }\n+\n+    #[test]\n+    fn test_bitv_extend() {\n+        let mut bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n+        let ext = from_bytes([0b01001001, 0b10010010, 0b10111101]);\n+        bitv.extend(ext.iter());\n+        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b11111111,\n+                                     0b01001001, 0b10010010, 0b10111101]));\n+    }\n+\n     #[test]\n     fn test_bitv_set_show() {\n         let mut s = BitvSet::new();"}]}